var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __publicField = (obj2, key, value) => {
  __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj2, member, msg) => {
  if (!member.has(obj2))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj2, member, getter) => {
  __accessCheck(obj2, member, "read from private field");
  return getter ? getter.call(obj2) : member.get(obj2);
};
var __privateAdd = (obj2, member, value) => {
  if (member.has(obj2))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
(function() {
  var _handleOnce, _all, _once, _events;
  "use strict";
  /**
  * @license
  * Copyright 2019 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  const constructionToken = Symbol();
  const styleSheetCache = new Map();
  class CSSResult {
    constructor(cssText, safeToken) {
      this["_$cssResult$"] = true;
      if (safeToken !== constructionToken) {
        throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      }
      this.cssText = cssText;
    }
    get styleSheet() {
      let styleSheet = styleSheetCache.get(this.cssText);
      if (supportsAdoptingStyleSheets && styleSheet === void 0) {
        styleSheetCache.set(this.cssText, styleSheet = new CSSStyleSheet());
        styleSheet.replaceSync(this.cssText);
      }
      return styleSheet;
    }
    toString() {
      return this.cssText;
    }
  }
  const textFromCSSResult = (value) => {
    if (value["_$cssResult$"] === true) {
      return value.cssText;
    } else if (typeof value === "number") {
      return value;
    } else {
      throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
    }
  };
  const unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), constructionToken);
  const css$1 = (strings, ...values) => {
    const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v2, idx) => acc + textFromCSSResult(v2) + strings[idx + 1], strings[0]);
    return new CSSResult(cssText, constructionToken);
  };
  const adoptStyles = (renderRoot, styles2) => {
    if (supportsAdoptingStyleSheets) {
      renderRoot.adoptedStyleSheets = styles2.map((s2) => s2 instanceof CSSStyleSheet ? s2 : s2.styleSheet);
    } else {
      styles2.forEach((s2) => {
        const style = document.createElement("style");
        const nonce = window["litNonce"];
        if (nonce !== void 0) {
          style.setAttribute("nonce", nonce);
        }
        style.textContent = s2.cssText;
        renderRoot.appendChild(style);
      });
    }
  };
  const cssResultFromStyleSheet = (sheet) => {
    let cssText = "";
    for (const rule of sheet.cssRules) {
      cssText += rule.cssText;
    }
    return unsafeCSS(cssText);
  };
  const getCompatibleStyle = supportsAdoptingStyleSheets ? (s2) => s2 : (s2) => s2 instanceof CSSStyleSheet ? cssResultFromStyleSheet(s2) : s2;
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a$4, _b$3, _c$3;
  var _d$2;
  let requestUpdateThenable;
  let issueWarning$2;
  const polyfillSupport$2 = window.reactiveElementPolyfillSupportDevMode;
  {
    const issuedWarnings = (_a$4 = globalThis.litIssuedWarnings) !== null && _a$4 !== void 0 ? _a$4 : globalThis.litIssuedWarnings = new Set();
    issueWarning$2 = (code, warning) => {
      warning += ` See https://lit.dev/msg/${code} for more information.`;
      if (!issuedWarnings.has(warning)) {
        console.warn(warning);
        issuedWarnings.add(warning);
      }
    };
    issueWarning$2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
    if (((_b$3 = window.ShadyDOM) === null || _b$3 === void 0 ? void 0 : _b$3.inUse) && polyfillSupport$2 === void 0) {
      issueWarning$2("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
    }
    requestUpdateThenable = (name) => ({
      then: (onfulfilled, _onrejected) => {
        issueWarning$2("request-update-promise", `The \`requestUpdate\` method should no longer return a Promise but does so on \`${name}\`. Use \`updateComplete\` instead.`);
        if (onfulfilled !== void 0) {
          onfulfilled(false);
        }
      }
    });
  }
  const JSCompiler_renameProperty = (prop, _obj) => prop;
  const defaultConverter = {
    toAttribute(value, type) {
      switch (type) {
        case Boolean:
          value = value ? "" : null;
          break;
        case Object:
        case Array:
          value = value == null ? value : JSON.stringify(value);
          break;
      }
      return value;
    },
    fromAttribute(value, type) {
      let fromValue = value;
      switch (type) {
        case Boolean:
          fromValue = value !== null;
          break;
        case Number:
          fromValue = value === null ? null : Number(value);
          break;
        case Object:
        case Array:
          try {
            fromValue = JSON.parse(value);
          } catch (e2) {
            fromValue = null;
          }
          break;
      }
      return fromValue;
    }
  };
  const notEqual = (value, old) => {
    return old !== value && (old === old || value === value);
  };
  const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual
  };
  const finalized = "finalized";
  class ReactiveElement extends HTMLElement {
    constructor() {
      super();
      this.__instanceProperties = new Map();
      this.isUpdatePending = false;
      this.hasUpdated = false;
      this.__reflectingProperty = null;
      this._initialize();
    }
    static addInitializer(initializer) {
      var _a2;
      (_a2 = this._initializers) !== null && _a2 !== void 0 ? _a2 : this._initializers = [];
      this._initializers.push(initializer);
    }
    static get observedAttributes() {
      this.finalize();
      const attributes = [];
      this.elementProperties.forEach((v2, p2) => {
        const attr = this.__attributeNameForProperty(p2, v2);
        if (attr !== void 0) {
          this.__attributeToPropertyMap.set(attr, p2);
          attributes.push(attr);
        }
      });
      return attributes;
    }
    static createProperty(name, options = defaultPropertyDeclaration) {
      if (options.state) {
        options.attribute = false;
      }
      this.finalize();
      this.elementProperties.set(name, options);
      if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
        const key = typeof name === "symbol" ? Symbol() : `__${name}`;
        const descriptor2 = this.getPropertyDescriptor(name, key, options);
        if (descriptor2 !== void 0) {
          Object.defineProperty(this.prototype, name, descriptor2);
        }
      }
    }
    static getPropertyDescriptor(name, key, options) {
      return {
        get() {
          return this[key];
        },
        set(value) {
          const oldValue = this[name];
          this[key] = value;
          this.requestUpdate(name, oldValue, options);
        },
        configurable: true,
        enumerable: true
      };
    }
    static getPropertyOptions(name) {
      return this.elementProperties.get(name) || defaultPropertyDeclaration;
    }
    static finalize() {
      if (this.hasOwnProperty(finalized)) {
        return false;
      }
      this[finalized] = true;
      const superCtor = Object.getPrototypeOf(this);
      superCtor.finalize();
      this.elementProperties = new Map(superCtor.elementProperties);
      this.__attributeToPropertyMap = new Map();
      if (this.hasOwnProperty(JSCompiler_renameProperty("properties"))) {
        const props = this.properties;
        const propKeys = [
          ...Object.getOwnPropertyNames(props),
          ...Object.getOwnPropertySymbols(props)
        ];
        for (const p2 of propKeys) {
          this.createProperty(p2, props[p2]);
        }
      }
      this.elementStyles = this.finalizeStyles(this.styles);
      {
        const warnRemovedOrRenamed = (name, renamed = false) => {
          if (this.prototype.hasOwnProperty(name)) {
            issueWarning$2(renamed ? "renamed-api" : "removed-api", `\`${name}\` is implemented on class ${this.name}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
          }
        };
        warnRemovedOrRenamed("initialize");
        warnRemovedOrRenamed("requestUpdateInternal");
        warnRemovedOrRenamed("_getUpdateComplete", true);
      }
      return true;
    }
    static finalizeStyles(styles2) {
      const elementStyles = [];
      if (Array.isArray(styles2)) {
        const set = new Set(styles2.flat(Infinity).reverse());
        for (const s2 of set) {
          elementStyles.unshift(getCompatibleStyle(s2));
        }
      } else if (styles2 !== void 0) {
        elementStyles.push(getCompatibleStyle(styles2));
      }
      return elementStyles;
    }
    static __attributeNameForProperty(name, options) {
      const attribute = options.attribute;
      return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
    }
    _initialize() {
      var _a2;
      this.__updatePromise = new Promise((res) => this.enableUpdating = res);
      this._$changedProperties = new Map();
      this.__saveInstanceProperties();
      this.requestUpdate();
      (_a2 = this.constructor._initializers) === null || _a2 === void 0 ? void 0 : _a2.forEach((i2) => i2(this));
    }
    addController(controller) {
      var _a2, _b2;
      ((_a2 = this.__controllers) !== null && _a2 !== void 0 ? _a2 : this.__controllers = []).push(controller);
      if (this.renderRoot !== void 0 && this.isConnected) {
        (_b2 = controller.hostConnected) === null || _b2 === void 0 ? void 0 : _b2.call(controller);
      }
    }
    removeController(controller) {
      var _a2;
      (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.splice(this.__controllers.indexOf(controller) >>> 0, 1);
    }
    __saveInstanceProperties() {
      this.constructor.elementProperties.forEach((_v2, p2) => {
        if (this.hasOwnProperty(p2)) {
          this.__instanceProperties.set(p2, this[p2]);
          delete this[p2];
        }
      });
    }
    createRenderRoot() {
      var _a2;
      const renderRoot = (_a2 = this.shadowRoot) !== null && _a2 !== void 0 ? _a2 : this.attachShadow(this.constructor.shadowRootOptions);
      adoptStyles(renderRoot, this.constructor.elementStyles);
      return renderRoot;
    }
    connectedCallback() {
      var _a2;
      if (this.renderRoot === void 0) {
        this.renderRoot = this.createRenderRoot();
      }
      this.enableUpdating(true);
      (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
        var _a3;
        return (_a3 = c2.hostConnected) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
      });
    }
    enableUpdating(_requestedUpdate) {
    }
    disconnectedCallback() {
      var _a2;
      (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
        var _a3;
        return (_a3 = c2.hostDisconnected) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
      });
    }
    attributeChangedCallback(name, _old, value) {
      this._$attributeToProperty(name, value);
    }
    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
      var _a2, _b2;
      const attr = this.constructor.__attributeNameForProperty(name, options);
      if (attr !== void 0 && options.reflect === true) {
        const toAttribute = (_b2 = (_a2 = options.converter) === null || _a2 === void 0 ? void 0 : _a2.toAttribute) !== null && _b2 !== void 0 ? _b2 : defaultConverter.toAttribute;
        const attrValue = toAttribute(value, options.type);
        if (this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
          issueWarning$2("undefined-attribute-value", `The attribute value for the ${name} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
        }
        this.__reflectingProperty = name;
        if (attrValue == null) {
          this.removeAttribute(attr);
        } else {
          this.setAttribute(attr, attrValue);
        }
        this.__reflectingProperty = null;
      }
    }
    _$attributeToProperty(name, value) {
      var _a2, _b2, _c2;
      const ctor = this.constructor;
      const propName = ctor.__attributeToPropertyMap.get(name);
      if (propName !== void 0 && this.__reflectingProperty !== propName) {
        const options = ctor.getPropertyOptions(propName);
        const converter = options.converter;
        const fromAttribute = (_c2 = (_b2 = (_a2 = converter) === null || _a2 === void 0 ? void 0 : _a2.fromAttribute) !== null && _b2 !== void 0 ? _b2 : typeof converter === "function" ? converter : null) !== null && _c2 !== void 0 ? _c2 : defaultConverter.fromAttribute;
        this.__reflectingProperty = propName;
        this[propName] = fromAttribute(value, options.type);
        this.__reflectingProperty = null;
      }
    }
    requestUpdate(name, oldValue, options) {
      let shouldRequestUpdate = true;
      if (name !== void 0) {
        options = options || this.constructor.getPropertyOptions(name);
        const hasChanged = options.hasChanged || notEqual;
        if (hasChanged(this[name], oldValue)) {
          if (!this._$changedProperties.has(name)) {
            this._$changedProperties.set(name, oldValue);
          }
          if (options.reflect === true && this.__reflectingProperty !== name) {
            if (this.__reflectingProperties === void 0) {
              this.__reflectingProperties = new Map();
            }
            this.__reflectingProperties.set(name, options);
          }
        } else {
          shouldRequestUpdate = false;
        }
      }
      if (!this.isUpdatePending && shouldRequestUpdate) {
        this.__updatePromise = this.__enqueueUpdate();
      }
      return requestUpdateThenable(this.localName);
    }
    __enqueueUpdate() {
      return __async(this, null, function* () {
        this.isUpdatePending = true;
        try {
          yield this.__updatePromise;
        } catch (e2) {
          Promise.reject(e2);
        }
        const result2 = this.scheduleUpdate();
        if (result2 != null) {
          yield result2;
        }
        return !this.isUpdatePending;
      });
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var _a2;
      if (!this.isUpdatePending) {
        return;
      }
      if (!this.hasUpdated) {
        {
          const shadowedProperties = [];
          this.constructor.elementProperties.forEach((_v2, p2) => {
            var _a3;
            if (this.hasOwnProperty(p2) && !((_a3 = this.__instanceProperties) === null || _a3 === void 0 ? void 0 : _a3.has(p2))) {
              shadowedProperties.push(p2);
            }
          });
          if (shadowedProperties.length) {
            throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
          }
        }
      }
      if (this.__instanceProperties) {
        this.__instanceProperties.forEach((v2, p2) => this[p2] = v2);
        this.__instanceProperties = void 0;
      }
      let shouldUpdate = false;
      const changedProperties = this._$changedProperties;
      try {
        shouldUpdate = this.shouldUpdate(changedProperties);
        if (shouldUpdate) {
          this.willUpdate(changedProperties);
          (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
            var _a3;
            return (_a3 = c2.hostUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
          });
          this.update(changedProperties);
        } else {
          this.__markUpdated();
        }
      } catch (e2) {
        shouldUpdate = false;
        this.__markUpdated();
        throw e2;
      }
      if (shouldUpdate) {
        this._$didUpdate(changedProperties);
      }
    }
    willUpdate(_changedProperties) {
    }
    _$didUpdate(changedProperties) {
      var _a2;
      (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
        var _a3;
        return (_a3 = c2.hostUpdated) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
      });
      if (!this.hasUpdated) {
        this.hasUpdated = true;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
      if (this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
        issueWarning$2("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
      }
    }
    __markUpdated() {
      this._$changedProperties = new Map();
      this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this.__updatePromise;
    }
    shouldUpdate(_changedProperties) {
      return true;
    }
    update(_changedProperties) {
      if (this.__reflectingProperties !== void 0) {
        this.__reflectingProperties.forEach((v2, k2) => this.__propertyToAttribute(k2, this[k2], v2));
        this.__reflectingProperties = void 0;
      }
      this.__markUpdated();
    }
    updated(_changedProperties) {
    }
    firstUpdated(_changedProperties) {
    }
  }
  _d$2 = finalized;
  ReactiveElement[_d$2] = true;
  ReactiveElement.elementProperties = new Map();
  ReactiveElement.elementStyles = [];
  ReactiveElement.shadowRootOptions = { mode: "open" };
  polyfillSupport$2 === null || polyfillSupport$2 === void 0 ? void 0 : polyfillSupport$2({ ReactiveElement });
  {
    ReactiveElement.enabledWarnings = ["change-in-update"];
    const ensureOwnWarnings = function(ctor) {
      if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings"))) {
        ctor.enabledWarnings = ctor.enabledWarnings.slice();
      }
    };
    ReactiveElement.enableWarning = function(warning) {
      ensureOwnWarnings(this);
      if (this.enabledWarnings.indexOf(warning) < 0) {
        this.enabledWarnings.push(warning);
      }
    };
    ReactiveElement.disableWarning = function(warning) {
      ensureOwnWarnings(this);
      const i2 = this.enabledWarnings.indexOf(warning);
      if (i2 >= 0) {
        this.enabledWarnings.splice(i2, 1);
      }
    };
  }
  ((_c$3 = globalThis.reactiveElementVersions) !== null && _c$3 !== void 0 ? _c$3 : globalThis.reactiveElementVersions = []).push("1.0.1");
  if (globalThis.reactiveElementVersions.length > 1) {
    issueWarning$2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a$3, _b$2, _c$2, _d$1;
  let issueWarning$1;
  {
    (_a$3 = globalThis.litIssuedWarnings) !== null && _a$3 !== void 0 ? _a$3 : globalThis.litIssuedWarnings = new Set();
    issueWarning$1 = (code, warning) => {
      warning += code ? ` See https://lit.dev/msg/${code} for more information.` : "";
      if (!globalThis.litIssuedWarnings.has(warning)) {
        console.warn(warning);
        globalThis.litIssuedWarnings.add(warning);
      }
    };
    issueWarning$1("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  }
  const wrap = ((_b$2 = window.ShadyDOM) === null || _b$2 === void 0 ? void 0 : _b$2.inUse) && ((_c$2 = window.ShadyDOM) === null || _c$2 === void 0 ? void 0 : _c$2.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
  const trustedTypes = globalThis.trustedTypes;
  const policy = trustedTypes ? trustedTypes.createPolicy("lit-html", {
    createHTML: (s2) => s2
  }) : void 0;
  const identityFunction = (value) => value;
  const noopSanitizer = (_node, _name, _type) => identityFunction;
  const setSanitizer = (newSanitizer) => {
    if (sanitizerFactoryInternal !== noopSanitizer) {
      throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
    }
    sanitizerFactoryInternal = newSanitizer;
  };
  const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
    sanitizerFactoryInternal = noopSanitizer;
  };
  const createSanitizer = (node, name, type) => {
    return sanitizerFactoryInternal(node, name, type);
  };
  const boundAttributeSuffix = "$lit$";
  const marker = `lit$${String(Math.random()).slice(9)}$`;
  const markerMatch = "?" + marker;
  const nodeMarker = `<${markerMatch}>`;
  const d$4 = document;
  const createMarker = (v2 = "") => d$4.createComment(v2);
  const isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
  const isArray$4 = Array.isArray;
  const isIterable = (value) => {
    var _a2;
    return isArray$4(value) || typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === "function";
  };
  const SPACE_CHAR = `[ 	
\f\r]`;
  const ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
  const NAME_CHAR = `[^\\s"'>=/]`;
  const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  const COMMENT_START = 1;
  const TAG_NAME = 2;
  const DYNAMIC_TAG_NAME = 3;
  const commentEndRegex = /-->/g;
  const comment2EndRegex = />/g;
  const tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
  const ENTIRE_MATCH = 0;
  const ATTRIBUTE_NAME = 1;
  const SPACES_AND_EQUALS = 2;
  const QUOTE_CHAR = 3;
  const singleQuoteAttrEndRegex = /'/g;
  const doubleQuoteAttrEndRegex = /"/g;
  const rawTextElement = /^(?:script|style|textarea)$/i;
  const HTML_RESULT$1 = 1;
  const SVG_RESULT = 2;
  const ATTRIBUTE_PART = 1;
  const CHILD_PART = 2;
  const PROPERTY_PART = 3;
  const BOOLEAN_ATTRIBUTE_PART = 4;
  const EVENT_PART = 5;
  const ELEMENT_PART = 6;
  const COMMENT_PART = 7;
  const tag = (type) => (strings, ...values) => {
    if (strings.some((s2) => s2 === void 0)) {
      console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
    }
    return {
      ["_$litType$"]: type,
      strings,
      values
    };
  };
  const html = tag(HTML_RESULT$1);
  const noChange = Symbol.for("lit-noChange");
  const nothing = Symbol.for("lit-nothing");
  const templateCache = new WeakMap();
  const render = (value, container, options) => {
    var _a2, _b2, _c2;
    const partOwnerNode = (_a2 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a2 !== void 0 ? _a2 : container;
    let part = partOwnerNode["_$litPart$"];
    if (part === void 0) {
      const endNode = (_b2 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b2 !== void 0 ? _b2 : null;
      if (((_c2 = options) === null || _c2 === void 0 ? void 0 : _c2.clearContainerForLit2MigrationOnly) === true) {
        let n2 = container.firstChild;
        while (n2 && n2 !== endNode) {
          const next = n2.nextSibling;
          n2.remove();
          n2 = next;
        }
      }
      partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options !== null && options !== void 0 ? options : {});
    }
    part._$setValue(value);
    return part;
  };
  {
    render.setSanitizer = setSanitizer;
    render.createSanitizer = createSanitizer;
    {
      render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
    }
  }
  const walker = d$4.createTreeWalker(d$4, 129, null, false);
  let sanitizerFactoryInternal = noopSanitizer;
  const getTemplateHtml = (strings, type) => {
    const l2 = strings.length - 1;
    const attrNames = [];
    let html2 = type === SVG_RESULT ? "<svg>" : "";
    let rawTextEndRegex;
    let regex = textEndRegex;
    for (let i2 = 0; i2 < l2; i2++) {
      const s2 = strings[i2];
      let attrNameEndIndex = -1;
      let attrName;
      let lastIndex = 0;
      let match2;
      while (lastIndex < s2.length) {
        regex.lastIndex = lastIndex;
        match2 = regex.exec(s2);
        if (match2 === null) {
          break;
        }
        lastIndex = regex.lastIndex;
        if (regex === textEndRegex) {
          if (match2[COMMENT_START] === "!--") {
            regex = commentEndRegex;
          } else if (match2[COMMENT_START] !== void 0) {
            regex = comment2EndRegex;
          } else if (match2[TAG_NAME] !== void 0) {
            if (rawTextElement.test(match2[TAG_NAME])) {
              rawTextEndRegex = new RegExp(`</${match2[TAG_NAME]}`, "g");
            }
            regex = tagEndRegex;
          } else if (match2[DYNAMIC_TAG_NAME] !== void 0) {
            {
              throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
            }
          }
        } else if (regex === tagEndRegex) {
          if (match2[ENTIRE_MATCH] === ">") {
            regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
            attrNameEndIndex = -1;
          } else if (match2[ATTRIBUTE_NAME] === void 0) {
            attrNameEndIndex = -2;
          } else {
            attrNameEndIndex = regex.lastIndex - match2[SPACES_AND_EQUALS].length;
            attrName = match2[ATTRIBUTE_NAME];
            regex = match2[QUOTE_CHAR] === void 0 ? tagEndRegex : match2[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
          }
        } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
          regex = tagEndRegex;
        } else if (regex === commentEndRegex || regex === comment2EndRegex) {
          regex = textEndRegex;
        } else {
          regex = tagEndRegex;
          rawTextEndRegex = void 0;
        }
      }
      {
        console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
      }
      const end = regex === tagEndRegex && strings[i2 + 1].startsWith("/>") ? " " : "";
      html2 += regex === textEndRegex ? s2 + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s2.slice(0, attrNameEndIndex) + boundAttributeSuffix + s2.slice(attrNameEndIndex)) + marker + end : s2 + marker + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i2) : end);
    }
    const htmlResult = html2 + (strings[l2] || "<?>") + (type === SVG_RESULT ? "</svg>" : "");
    return [
      policy !== void 0 ? policy.createHTML(htmlResult) : htmlResult,
      attrNames
    ];
  };
  class Template {
    constructor({ strings, ["_$litType$"]: type }, options) {
      this.parts = [];
      let node;
      let nodeIndex = 0;
      let attrNameIndex = 0;
      const partCount = strings.length - 1;
      const parts = this.parts;
      const [html2, attrNames] = getTemplateHtml(strings, type);
      this.el = Template.createElement(html2, options);
      walker.currentNode = this.el.content;
      if (type === SVG_RESULT) {
        const content = this.el.content;
        const svgElement = content.firstChild;
        svgElement.remove();
        content.append(...svgElement.childNodes);
      }
      while ((node = walker.nextNode()) !== null && parts.length < partCount) {
        if (node.nodeType === 1) {
          {
            const tag2 = node.localName;
            if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
              const m2 = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
              if (tag2 === "template") {
                throw new Error(m2);
              } else
                issueWarning$1("", m2);
            }
          }
          if (node.hasAttributes()) {
            const attrsToRemove = [];
            for (const name of node.getAttributeNames()) {
              if (name.endsWith(boundAttributeSuffix) || name.startsWith(marker)) {
                const realName = attrNames[attrNameIndex++];
                attrsToRemove.push(name);
                if (realName !== void 0) {
                  const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                  const statics = value.split(marker);
                  const m2 = /([.?@])?(.*)/.exec(realName);
                  parts.push({
                    type: ATTRIBUTE_PART,
                    index: nodeIndex,
                    name: m2[2],
                    strings: statics,
                    ctor: m2[1] === "." ? PropertyPart : m2[1] === "?" ? BooleanAttributePart : m2[1] === "@" ? EventPart : AttributePart
                  });
                } else {
                  parts.push({
                    type: ELEMENT_PART,
                    index: nodeIndex
                  });
                }
              }
            }
            for (const name of attrsToRemove) {
              node.removeAttribute(name);
            }
          }
          if (rawTextElement.test(node.tagName)) {
            const strings2 = node.textContent.split(marker);
            const lastIndex = strings2.length - 1;
            if (lastIndex > 0) {
              node.textContent = trustedTypes ? trustedTypes.emptyScript : "";
              for (let i2 = 0; i2 < lastIndex; i2++) {
                node.append(strings2[i2], createMarker());
                walker.nextNode();
                parts.push({ type: CHILD_PART, index: ++nodeIndex });
              }
              node.append(strings2[lastIndex], createMarker());
            }
          }
        } else if (node.nodeType === 8) {
          const data = node.data;
          if (data === markerMatch) {
            parts.push({ type: CHILD_PART, index: nodeIndex });
          } else {
            let i2 = -1;
            while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
              parts.push({ type: COMMENT_PART, index: nodeIndex });
              i2 += marker.length - 1;
            }
          }
        }
        nodeIndex++;
      }
    }
    static createElement(html2, _options) {
      const el2 = d$4.createElement("template");
      el2.innerHTML = html2;
      return el2;
    }
  }
  function resolveDirective(part, value, parent = part, attributeIndex) {
    var _a2, _b2, _c2;
    var _d2;
    if (value === noChange) {
      return value;
    }
    let currentDirective = attributeIndex !== void 0 ? (_a2 = parent.__directives) === null || _a2 === void 0 ? void 0 : _a2[attributeIndex] : parent.__directive;
    const nextDirectiveConstructor = isPrimitive(value) ? void 0 : value["_$litDirective$"];
    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
      (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
      if (nextDirectiveConstructor === void 0) {
        currentDirective = void 0;
      } else {
        currentDirective = new nextDirectiveConstructor(part);
        currentDirective._$initialize(part, parent, attributeIndex);
      }
      if (attributeIndex !== void 0) {
        ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
      } else {
        parent.__directive = currentDirective;
      }
    }
    if (currentDirective !== void 0) {
      value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
    }
    return value;
  }
  class TemplateInstance {
    constructor(template2, parent) {
      this._parts = [];
      this._$disconnectableChildren = void 0;
      this._$template = template2;
      this._$parent = parent;
    }
    get parentNode() {
      return this._$parent.parentNode;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(options) {
      var _a2;
      const { el: { content }, parts } = this._$template;
      const fragment = ((_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a2 !== void 0 ? _a2 : d$4).importNode(content, true);
      walker.currentNode = fragment;
      let node = walker.nextNode();
      let nodeIndex = 0;
      let partIndex = 0;
      let templatePart = parts[0];
      while (templatePart !== void 0) {
        if (nodeIndex === templatePart.index) {
          let part;
          if (templatePart.type === CHILD_PART) {
            part = new ChildPart(node, node.nextSibling, this, options);
          } else if (templatePart.type === ATTRIBUTE_PART) {
            part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
          } else if (templatePart.type === ELEMENT_PART) {
            part = new ElementPart(node, this, options);
          }
          this._parts.push(part);
          templatePart = parts[++partIndex];
        }
        if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
          node = walker.nextNode();
          nodeIndex++;
        }
      }
      return fragment;
    }
    _update(values) {
      let i2 = 0;
      for (const part of this._parts) {
        if (part !== void 0) {
          if (part.strings !== void 0) {
            part._$setValue(values, part, i2);
            i2 += part.strings.length - 2;
          } else {
            part._$setValue(values[i2]);
          }
        }
        i2++;
      }
    }
  }
  class ChildPart {
    constructor(startNode, endNode, parent, options) {
      var _a2;
      this.type = CHILD_PART;
      this._$committedValue = nothing;
      this._$disconnectableChildren = void 0;
      this._$startNode = startNode;
      this._$endNode = endNode;
      this._$parent = parent;
      this.options = options;
      this.__isConnected = (_a2 = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a2 !== void 0 ? _a2 : true;
      {
        this._textSanitizer = void 0;
      }
    }
    get _$isConnected() {
      var _a2, _b2;
      return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
    }
    get parentNode() {
      let parentNode = wrap(this._$startNode).parentNode;
      const parent = this._$parent;
      if (parent !== void 0 && parentNode.nodeType === 11) {
        parentNode = parent.parentNode;
      }
      return parentNode;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(value, directiveParent = this) {
      if (this.parentNode === null) {
        throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
      }
      value = resolveDirective(this, value, directiveParent);
      if (isPrimitive(value)) {
        if (value === nothing || value == null || value === "") {
          if (this._$committedValue !== nothing) {
            this._$clear();
          }
          this._$committedValue = nothing;
        } else if (value !== this._$committedValue && value !== noChange) {
          this._commitText(value);
        }
      } else if (value["_$litType$"] !== void 0) {
        this._commitTemplateResult(value);
      } else if (value.nodeType !== void 0) {
        this._commitNode(value);
      } else if (isIterable(value)) {
        this._commitIterable(value);
      } else {
        this._commitText(value);
      }
    }
    _insert(node, ref = this._$endNode) {
      return wrap(wrap(this._$startNode).parentNode).insertBefore(node, ref);
    }
    _commitNode(value) {
      var _a2;
      if (this._$committedValue !== value) {
        this._$clear();
        if (sanitizerFactoryInternal !== noopSanitizer) {
          const parentNodeName = (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
          if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
            let message = "Forbidden";
            {
              if (parentNodeName === "STYLE") {
                message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
              } else {
                message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
              }
            }
            throw new Error(message);
          }
        }
        this._$committedValue = this._insert(value);
      }
    }
    _commitText(value) {
      if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
        const node = wrap(this._$startNode).nextSibling;
        {
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer(node, "data", "property");
          }
          value = this._textSanitizer(value);
        }
        node.data = value;
      } else {
        {
          const textNode = document.createTextNode("");
          this._commitNode(textNode);
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer(textNode, "data", "property");
          }
          value = this._textSanitizer(value);
          textNode.data = value;
        }
      }
      this._$committedValue = value;
    }
    _commitTemplateResult(result2) {
      var _a2;
      const { values, ["_$litType$"]: type } = result2;
      const template2 = typeof type === "number" ? this._$getTemplate(result2) : (type.el === void 0 && (type.el = Template.createElement(type.h, this.options)), type);
      if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template2) {
        this._$committedValue._update(values);
      } else {
        const instance = new TemplateInstance(template2, this);
        const fragment = instance._clone(this.options);
        instance._update(values);
        this._commitNode(fragment);
        this._$committedValue = instance;
      }
    }
    _$getTemplate(result2) {
      let template2 = templateCache.get(result2.strings);
      if (template2 === void 0) {
        templateCache.set(result2.strings, template2 = new Template(result2));
      }
      return template2;
    }
    _commitIterable(value) {
      if (!isArray$4(this._$committedValue)) {
        this._$committedValue = [];
        this._$clear();
      }
      const itemParts = this._$committedValue;
      let partIndex = 0;
      let itemPart;
      for (const item of value) {
        if (partIndex === itemParts.length) {
          itemParts.push(itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
        } else {
          itemPart = itemParts[partIndex];
        }
        itemPart._$setValue(item);
        partIndex++;
      }
      if (partIndex < itemParts.length) {
        this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
        itemParts.length = partIndex;
      }
    }
    _$clear(start = wrap(this._$startNode).nextSibling, from) {
      var _a2;
      (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, false, true, from);
      while (start && start !== this._$endNode) {
        const n2 = wrap(start).nextSibling;
        wrap(start).remove();
        start = n2;
      }
    }
    setConnected(isConnected) {
      var _a2;
      if (this._$parent === void 0) {
        this.__isConnected = isConnected;
        (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, isConnected);
      } else {
        throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
      }
    }
  }
  class AttributePart {
    constructor(element, name, strings, parent, options) {
      this.type = ATTRIBUTE_PART;
      this._$committedValue = nothing;
      this._$disconnectableChildren = void 0;
      this.element = element;
      this.name = name;
      this._$parent = parent;
      this.options = options;
      if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
        this._$committedValue = new Array(strings.length - 1).fill(new String());
        this.strings = strings;
      } else {
        this._$committedValue = nothing;
      }
      {
        this._sanitizer = void 0;
      }
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value, directiveParent = this, valueIndex, noCommit) {
      const strings = this.strings;
      let change = false;
      if (strings === void 0) {
        value = resolveDirective(this, value, directiveParent, 0);
        change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
        if (change) {
          this._$committedValue = value;
        }
      } else {
        const values = value;
        value = strings[0];
        let i2, v2;
        for (i2 = 0; i2 < strings.length - 1; i2++) {
          v2 = resolveDirective(this, values[valueIndex + i2], directiveParent, i2);
          if (v2 === noChange) {
            v2 = this._$committedValue[i2];
          }
          change || (change = !isPrimitive(v2) || v2 !== this._$committedValue[i2]);
          if (v2 === nothing) {
            value = nothing;
          } else if (value !== nothing) {
            value += (v2 !== null && v2 !== void 0 ? v2 : "") + strings[i2 + 1];
          }
          this._$committedValue[i2] = v2;
        }
      }
      if (change && !noCommit) {
        this._commitValue(value);
      }
    }
    _commitValue(value) {
      if (value === nothing) {
        wrap(this.element).removeAttribute(this.name);
      } else {
        {
          if (this._sanitizer === void 0) {
            this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
          }
          value = this._sanitizer(value !== null && value !== void 0 ? value : "");
        }
        wrap(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
      }
    }
  }
  class PropertyPart extends AttributePart {
    constructor() {
      super(...arguments);
      this.type = PROPERTY_PART;
    }
    _commitValue(value) {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
        }
        value = this._sanitizer(value);
      }
      this.element[this.name] = value === nothing ? void 0 : value;
    }
  }
  class BooleanAttributePart extends AttributePart {
    constructor() {
      super(...arguments);
      this.type = BOOLEAN_ATTRIBUTE_PART;
    }
    _commitValue(value) {
      if (value && value !== nothing) {
        wrap(this.element).setAttribute(this.name, "");
      } else {
        wrap(this.element).removeAttribute(this.name);
      }
    }
  }
  class EventPart extends AttributePart {
    constructor(element, name, strings, parent, options) {
      super(element, name, strings, parent, options);
      this.type = EVENT_PART;
      if (this.strings !== void 0) {
        throw new Error(`A \`<${element.localName}>\` has a \`@${name}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
      }
    }
    _$setValue(newListener, directiveParent = this) {
      var _a2;
      newListener = (_a2 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0 ? _a2 : nothing;
      if (newListener === noChange) {
        return;
      }
      const oldListener = this._$committedValue;
      const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
      const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
      if (shouldRemoveListener) {
        this.element.removeEventListener(this.name, this, oldListener);
      }
      if (shouldAddListener) {
        this.element.addEventListener(this.name, this, newListener);
      }
      this._$committedValue = newListener;
    }
    handleEvent(event) {
      var _a2, _b2;
      if (typeof this._$committedValue === "function") {
        this._$committedValue.call((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
      } else {
        this._$committedValue.handleEvent(event);
      }
    }
  }
  class ElementPart {
    constructor(element, parent, options) {
      this.element = element;
      this.type = ELEMENT_PART;
      this._$disconnectableChildren = void 0;
      this._$parent = parent;
      this.options = options;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value) {
      resolveDirective(this, value);
    }
  }
  const polyfillSupport$1 = window.litHtmlPolyfillSupportDevMode;
  polyfillSupport$1 === null || polyfillSupport$1 === void 0 ? void 0 : polyfillSupport$1(Template, ChildPart);
  ((_d$1 = globalThis.litHtmlVersions) !== null && _d$1 !== void 0 ? _d$1 : globalThis.litHtmlVersions = []).push("2.0.1");
  if (globalThis.litHtmlVersions.length > 1) {
    issueWarning$1("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a$2, _b$1, _c$1;
  let issueWarning;
  {
    const issuedWarnings = (_a$2 = globalThis.litIssuedWarnings) !== null && _a$2 !== void 0 ? _a$2 : globalThis.litIssuedWarnings = new Set();
    issueWarning = (code, warning) => {
      warning += ` See https://lit.dev/msg/${code} for more information.`;
      if (!issuedWarnings.has(warning)) {
        console.warn(warning);
        issuedWarnings.add(warning);
      }
    };
  }
  class LitElement extends ReactiveElement {
    constructor() {
      super(...arguments);
      this.renderOptions = { host: this };
      this.__childPart = void 0;
    }
    createRenderRoot() {
      var _a2;
      var _b2;
      const renderRoot = super.createRenderRoot();
      (_a2 = (_b2 = this.renderOptions).renderBefore) !== null && _a2 !== void 0 ? _a2 : _b2.renderBefore = renderRoot.firstChild;
      return renderRoot;
    }
    update(changedProperties) {
      const value = this.render();
      if (!this.hasUpdated) {
        this.renderOptions.isConnected = this.isConnected;
      }
      super.update(changedProperties);
      this.__childPart = render(value, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var _a2;
      super.connectedCallback();
      (_a2 = this.__childPart) === null || _a2 === void 0 ? void 0 : _a2.setConnected(true);
    }
    disconnectedCallback() {
      var _a2;
      super.disconnectedCallback();
      (_a2 = this.__childPart) === null || _a2 === void 0 ? void 0 : _a2.setConnected(false);
    }
    render() {
      return noChange;
    }
  }
  LitElement["finalized"] = true;
  LitElement["_$litElement$"] = true;
  (_b$1 = globalThis.litElementHydrateSupport) === null || _b$1 === void 0 ? void 0 : _b$1.call(globalThis, { LitElement });
  const polyfillSupport = globalThis.litElementPolyfillSupportDevMode;
  polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ LitElement });
  {
    LitElement["finalize"] = function() {
      const finalized2 = ReactiveElement.finalize.call(this);
      if (!finalized2) {
        return false;
      }
      const warnRemovedOrRenamed = (obj2, name, renamed = false) => {
        if (obj2.hasOwnProperty(name)) {
          const ctorName = (typeof obj2 === "function" ? obj2 : obj2.constructor).name;
          issueWarning(renamed ? "renamed-api" : "removed-api", `\`${name}\` is implemented on class ${ctorName}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
        }
      };
      warnRemovedOrRenamed(this, "render");
      warnRemovedOrRenamed(this, "getStyles", true);
      warnRemovedOrRenamed(this.prototype, "adoptStyles");
      return true;
    };
  }
  ((_c$1 = globalThis.litElementVersions) !== null && _c$1 !== void 0 ? _c$1 : globalThis.litElementVersions = []).push("3.0.1");
  if (globalThis.litElementVersions.length > 1) {
    issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function commonjsRequire(path2) {
    throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var isClass = { exports: {} };
  (function(module, exports) {
    (function(root) {
      const toString = Function.prototype.toString;
      function fnBody(fn2) {
        return toString.call(fn2).replace(/^[^{]*{\s*/, "").replace(/\s*}[^}]*$/, "");
      }
      function isClass2(fn2) {
        if (typeof fn2 !== "function") {
          return false;
        }
        if (/^class[\s{]/.test(toString.call(fn2))) {
          return true;
        }
        const body = fnBody(fn2);
        return /classCallCheck\(/.test(body) || /TypeError\("Cannot call a class as a function"\)/.test(body);
      }
      {
        if (module.exports) {
          exports = module.exports = isClass2;
        }
        exports.isClass = isClass2;
      }
    })();
  })(isClass, isClass.exports);
  var __isClass = isClass.exports;
  function cls(cls2) {
    if (!Array.isArray(cls2))
      cls2 = [cls2];
    for (let i2 = 0; i2 < cls2.length; i2++) {
      if (!__isClass(cls2[i2]))
        return false;
    }
    return true;
  }
  const fn$7 = function(cls$1, settings = {}) {
    const stack = {};
    if (!cls(cls$1)) {
      cls$1 = cls$1.constructor;
    }
    if (settings.includeBaseClass === true) {
      stack[cls$1.name] = cls$1;
    }
    let baseClass = cls$1;
    while (baseClass) {
      const newBaseClass = Object.getPrototypeOf(baseClass);
      if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
        stack[newBaseClass.name] = newBaseClass;
        baseClass = newBaseClass;
      } else {
        break;
      }
    }
    return stack;
  };
  function plainObject$1(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function unique(array) {
    const a2 = array.concat();
    for (let i2 = 0; i2 < a2.length; ++i2) {
      for (let j2 = i2 + 1; j2 < a2.length; ++j2) {
        if (a2[i2] === a2[j2])
          a2.splice(j2--, 1);
      }
    }
    return a2;
  }
  var lodash_clone = { exports: {} };
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result2 = Array(n2);
      while (++index < n2) {
        result2[index] = iteratee(index);
      }
      return result2;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result2 = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result2 = !!(value + "");
        } catch (e2) {
        }
      }
      return result2;
    }
    function mapToArray(map) {
      var index = -1, result2 = Array(map.size);
      map.forEach(function(value, key) {
        result2[++index] = [key, value];
      });
      return result2;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result2 = Array(set.size);
      set.forEach(function(value) {
        result2[++index] = value;
      });
      return result2;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result2 = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result2.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source2) {
      return object && copyObject(source2, keys(source2), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result2;
      if (customizer) {
        result2 = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result2 !== void 0) {
        return result2;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result2 = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result2);
        }
      } else {
        var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result2 = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result2, value));
          }
        } else {
          if (!cloneableTags[tag2]) {
            return object ? value : {};
          }
          result2 = initCloneByTag(value, tag2, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result2);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result2;
    }
    function baseCreate(proto2) {
      return isObject2(proto2) ? objectCreate(proto2) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result2 = keysFunc(object);
      return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result2 = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result2.push(key);
        }
      }
      return result2;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result2 = new buffer.constructor(buffer.length);
      buffer.copy(result2);
      return result2;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
      return result2;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result2.lastIndex = regexp.lastIndex;
      return result2;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source2, array) {
      var index = -1, length = source2.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source2[index];
      }
      return array;
    }
    function copyObject(source2, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
        assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
      }
      return object;
    }
    function copySymbols(source2, object) {
      return copyObject(source2, getSymbols(source2), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result2 = objectToString.call(value), Ctor = result2 == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result2;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result2 = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result2.index = array.index;
        result2.input = array.input;
      }
      return result2;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag2, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag2) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto2;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function clone2(value) {
      return baseClone(value, false, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      var tag2 = isObject2(value) ? objectToString.call(value) : "";
      return tag2 == funcTag || tag2 == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = clone2;
  })(lodash_clone, lodash_clone.exports);
  var __clone = lodash_clone.exports;
  var lodash_clonedeep = { exports: {} };
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result2 = Array(n2);
      while (++index < n2) {
        result2[index] = iteratee(index);
      }
      return result2;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result2 = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result2 = !!(value + "");
        } catch (e2) {
        }
      }
      return result2;
    }
    function mapToArray(map) {
      var index = -1, result2 = Array(map.size);
      map.forEach(function(value, key) {
        result2[++index] = [key, value];
      });
      return result2;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result2 = Array(set.size);
      set.forEach(function(value) {
        result2[++index] = value;
      });
      return result2;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result2 = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result2.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source2) {
      return object && copyObject(source2, keys(source2), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result2;
      if (customizer) {
        result2 = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result2 !== void 0) {
        return result2;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result2 = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result2);
        }
      } else {
        var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result2 = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result2, value));
          }
        } else {
          if (!cloneableTags[tag2]) {
            return object ? value : {};
          }
          result2 = initCloneByTag(value, tag2, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result2);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result2;
    }
    function baseCreate(proto2) {
      return isObject2(proto2) ? objectCreate(proto2) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result2 = keysFunc(object);
      return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result2 = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result2.push(key);
        }
      }
      return result2;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result2 = new buffer.constructor(buffer.length);
      buffer.copy(result2);
      return result2;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
      return result2;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result2.lastIndex = regexp.lastIndex;
      return result2;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source2, array) {
      var index = -1, length = source2.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source2[index];
      }
      return array;
    }
    function copyObject(source2, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
        assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
      }
      return object;
    }
    function copySymbols(source2, object) {
      return copyObject(source2, getSymbols(source2), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result2 = objectToString.call(value), Ctor = result2 == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result2;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result2 = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result2.index = array.index;
        result2.input = array.input;
      }
      return result2;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag2, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag2) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto2;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      var tag2 = isObject2(value) ? objectToString.call(value) : "";
      return tag2 == funcTag || tag2 == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  })(lodash_clonedeep, lodash_clonedeep.exports);
  var __deepClone = lodash_clonedeep.exports;
  function clone(object, settings = {}) {
    settings = Object.assign({ deep: false }, settings);
    if (settings.deep) {
      return __deepClone(object);
    }
    return __clone(object);
  }
  function deepAssign(referenceObj, ...objects) {
    const settings = {
      array: false,
      object: true,
      cloneChilds: true
    };
    function merge(refObj, mixWithObj) {
      for (const key of Object.keys(mixWithObj)) {
        if (settings.array === true && Array.isArray(refObj[key]) && Array.isArray(mixWithObj[key])) {
          const newArray = unique([...refObj[key], ...mixWithObj[key]]);
          refObj[key] = newArray;
          continue;
        }
        if (settings.object === true && plainObject$1(refObj[key]) && plainObject$1(mixWithObj[key])) {
          refObj[key] = merge(refObj[key], mixWithObj[key]);
          continue;
        }
        if (plainObject$1(mixWithObj[key]) && settings.cloneChilds) {
          refObj[key] = clone(mixWithObj[key], {
            deep: true
          });
        } else {
          refObj[key] = mixWithObj[key];
        }
      }
      return refObj;
    }
    const potentialSettingsObj = objects[objects.length - 1] || {};
    if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
      if (potentialSettingsObj.array !== void 0)
        settings.array = potentialSettingsObj.array;
      if (potentialSettingsObj.object !== void 0)
        settings.object = potentialSettingsObj.object;
      objects.pop();
    }
    for (let i2 = 0; i2 < objects.length; i2++) {
      const toMergeObj = objects[i2] || {};
      merge(referenceObj, toMergeObj);
    }
    return referenceObj;
  }
  function __deepMerge$1(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$1(newObj[key]) && plainObject$1(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMergeObj = args[i2];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  function unquote(string2, quotesToRemove = ['"', "'", "\u201D", "`"]) {
    string2 = string2.trim();
    quotesToRemove.forEach((quote) => {
      if (string2.substr(0, 1) === quote && string2.substr(-1) === quote) {
        string2 = string2.substr(1);
        string2 = string2.substr(0, string2.length - 1);
        return;
      }
    });
    return string2;
  }
  function get(obj2, path2, settings = {}) {
    settings = Object.assign({}, settings);
    if (obj2[path2] !== void 0)
      return obj2[path2];
    if (!path2 || path2 === "" || path2 === ".")
      return obj2;
    path2 = path2.replace(/\[(\w+)\]/g, ".$1");
    path2 = path2.replace(/^\./, "");
    let potentialPaths = [path2.replace(/\?/gm, "")];
    const parts = path2.split(".");
    for (let i2 = parts.length - 1; i2 >= 0; i2--) {
      const part = parts[i2];
      if (part.match(/\?$/)) {
        const before = parts.slice(0, i2);
        const after = parts.slice(i2 + 1);
        potentialPaths.push([...before, ...after].join("."));
        potentialPaths.push([...before, ...after.filter((a2) => !a2.match(/\?$/))].join("."));
      }
    }
    potentialPaths = unique(potentialPaths.map((s2) => s2.replace(/\?/gm, "")));
    for (let i2 = 0; i2 < potentialPaths.length; i2++) {
      const path3 = potentialPaths[i2];
      const result2 = __get(obj2, path3, settings);
      if (result2 !== void 0)
        return result2;
    }
  }
  function __get(obj2, path2, settings = {}) {
    settings = Object.assign({}, settings);
    if (obj2[path2] !== void 0)
      return obj2[path2];
    if (!path2 || path2 === "" || path2 === ".")
      return obj2;
    const a2 = path2.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p2) => unquote(p2));
    let o2 = obj2;
    while (a2.length) {
      const n2 = a2.shift().replace(/\?$/, "");
      if (typeof o2 !== "object" || !(n2 in o2)) {
        return;
      }
      o2 = o2[n2];
    }
    return o2;
  }
  var md5$1 = { exports: {} };
  var core$1 = { exports: {} };
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto2 = commonjsGlobal.crypto;
        }
        if (!crypto2 && typeof commonjsRequire === "function") {
          try {
            crypto2 = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F2() {
          }
          return function(obj2) {
            var subtype;
            F2.prototype = obj2;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties2) {
              for (var propertyName in properties2) {
                if (properties2.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties2[propertyName];
                }
              }
              if (properties2.hasOwnProperty("toString")) {
                this.toString = properties2.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  })(core$1);
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(core$1.exports);
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var T2 = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var M_offset_0 = M2[offset + 0];
            var M_offset_1 = M2[offset + 1];
            var M_offset_2 = M2[offset + 2];
            var M_offset_3 = M2[offset + 3];
            var M_offset_4 = M2[offset + 4];
            var M_offset_5 = M2[offset + 5];
            var M_offset_6 = M2[offset + 6];
            var M_offset_7 = M2[offset + 7];
            var M_offset_8 = M2[offset + 8];
            var M_offset_9 = M2[offset + 9];
            var M_offset_10 = M2[offset + 10];
            var M_offset_11 = M2[offset + 11];
            var M_offset_12 = M2[offset + 12];
            var M_offset_13 = M2[offset + 13];
            var M_offset_14 = M2[offset + 14];
            var M_offset_15 = M2[offset + 15];
            var a2 = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            a2 = FF2(a2, b2, c2, d2, M_offset_0, 7, T2[0]);
            d2 = FF2(d2, a2, b2, c2, M_offset_1, 12, T2[1]);
            c2 = FF2(c2, d2, a2, b2, M_offset_2, 17, T2[2]);
            b2 = FF2(b2, c2, d2, a2, M_offset_3, 22, T2[3]);
            a2 = FF2(a2, b2, c2, d2, M_offset_4, 7, T2[4]);
            d2 = FF2(d2, a2, b2, c2, M_offset_5, 12, T2[5]);
            c2 = FF2(c2, d2, a2, b2, M_offset_6, 17, T2[6]);
            b2 = FF2(b2, c2, d2, a2, M_offset_7, 22, T2[7]);
            a2 = FF2(a2, b2, c2, d2, M_offset_8, 7, T2[8]);
            d2 = FF2(d2, a2, b2, c2, M_offset_9, 12, T2[9]);
            c2 = FF2(c2, d2, a2, b2, M_offset_10, 17, T2[10]);
            b2 = FF2(b2, c2, d2, a2, M_offset_11, 22, T2[11]);
            a2 = FF2(a2, b2, c2, d2, M_offset_12, 7, T2[12]);
            d2 = FF2(d2, a2, b2, c2, M_offset_13, 12, T2[13]);
            c2 = FF2(c2, d2, a2, b2, M_offset_14, 17, T2[14]);
            b2 = FF2(b2, c2, d2, a2, M_offset_15, 22, T2[15]);
            a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T2[16]);
            d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T2[17]);
            c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T2[18]);
            b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T2[19]);
            a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T2[20]);
            d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T2[21]);
            c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T2[22]);
            b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T2[23]);
            a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T2[24]);
            d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T2[25]);
            c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T2[26]);
            b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T2[27]);
            a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T2[28]);
            d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T2[29]);
            c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T2[30]);
            b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T2[31]);
            a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T2[32]);
            d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T2[33]);
            c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T2[34]);
            b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T2[35]);
            a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T2[36]);
            d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T2[37]);
            c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T2[38]);
            b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T2[39]);
            a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T2[40]);
            d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T2[41]);
            c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T2[42]);
            b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T2[43]);
            a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T2[44]);
            d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T2[45]);
            c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T2[46]);
            b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T2[47]);
            a2 = II2(a2, b2, c2, d2, M_offset_0, 6, T2[48]);
            d2 = II2(d2, a2, b2, c2, M_offset_7, 10, T2[49]);
            c2 = II2(c2, d2, a2, b2, M_offset_14, 15, T2[50]);
            b2 = II2(b2, c2, d2, a2, M_offset_5, 21, T2[51]);
            a2 = II2(a2, b2, c2, d2, M_offset_12, 6, T2[52]);
            d2 = II2(d2, a2, b2, c2, M_offset_3, 10, T2[53]);
            c2 = II2(c2, d2, a2, b2, M_offset_10, 15, T2[54]);
            b2 = II2(b2, c2, d2, a2, M_offset_1, 21, T2[55]);
            a2 = II2(a2, b2, c2, d2, M_offset_8, 6, T2[56]);
            d2 = II2(d2, a2, b2, c2, M_offset_15, 10, T2[57]);
            c2 = II2(c2, d2, a2, b2, M_offset_6, 15, T2[58]);
            b2 = II2(b2, c2, d2, a2, M_offset_13, 21, T2[59]);
            a2 = II2(a2, b2, c2, d2, M_offset_4, 6, T2[60]);
            d2 = II2(d2, a2, b2, c2, M_offset_11, 10, T2[61]);
            c2 = II2(c2, d2, a2, b2, M_offset_2, 15, T2[62]);
            b2 = II2(b2, c2, d2, a2, M_offset_9, 21, T2[63]);
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H2 = hash.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H2[i2];
              H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function FF2(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 & c2 | ~b2 & d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function GG(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 & d2 | c2 & ~d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function HH(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 ^ c2 ^ d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function II2(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (c2 ^ (b2 | ~d2)) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        C2.MD5 = Hasher._createHelper(MD5);
        C2.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5$1);
  var md5 = md5$1.exports;
  var ansiStyles$1 = { exports: {} };
  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  const cssKeywords = colorName;
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert$1 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  var conversions$2 = convert$1;
  for (const model of Object.keys(convert$1)) {
    if (!("channels" in convert$1[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$1[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert$1[model];
    delete convert$1[model].channels;
    delete convert$1[model].labels;
    Object.defineProperty(convert$1[model], "channels", { value: channels });
    Object.defineProperty(convert$1[model], "labels", { value: labels });
  }
  convert$1.rgb.hsl = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const min = Math.min(r2, g2, b2);
    const max = Math.max(r2, g2, b2);
    const delta = max - min;
    let h2;
    let s2;
    if (max === min) {
      h2 = 0;
    } else if (r2 === max) {
      h2 = (g2 - b2) / delta;
    } else if (g2 === max) {
      h2 = 2 + (b2 - r2) / delta;
    } else if (b2 === max) {
      h2 = 4 + (r2 - g2) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    const l2 = (min + max) / 2;
    if (max === min) {
      s2 = 0;
    } else if (l2 <= 0.5) {
      s2 = delta / (max + min);
    } else {
      s2 = delta / (2 - max - min);
    }
    return [h2, s2 * 100, l2 * 100];
  };
  convert$1.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h2;
    let s2;
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const v2 = Math.max(r2, g2, b2);
    const diff = v2 - Math.min(r2, g2, b2);
    const diffc = function(c2) {
      return (v2 - c2) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = 0;
      s2 = 0;
    } else {
      s2 = diff / v2;
      rdif = diffc(r2);
      gdif = diffc(g2);
      bdif = diffc(b2);
      if (r2 === v2) {
        h2 = bdif - gdif;
      } else if (g2 === v2) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b2 === v2) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v2 * 100
    ];
  };
  convert$1.rgb.hwb = function(rgb) {
    const r2 = rgb[0];
    const g2 = rgb[1];
    let b2 = rgb[2];
    const h2 = convert$1.rgb.hsl(rgb)[0];
    const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
    b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
    return [h2, w2 * 100, b2 * 100];
  };
  convert$1.rgb.cmyk = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
    const c2 = (1 - r2 - k2) / (1 - k2) || 0;
    const m2 = (1 - g2 - k2) / (1 - k2) || 0;
    const y2 = (1 - b2 - k2) / (1 - k2) || 0;
    return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
  };
  function comparativeDistance(x2, y2) {
    return __pow(x2[0] - y2[0], 2) + __pow(x2[1] - y2[1], 2) + __pow(x2[2] - y2[2], 2);
  }
  convert$1.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert$1.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert$1.rgb.xyz = function(rgb) {
    let r2 = rgb[0] / 255;
    let g2 = rgb[1] / 255;
    let b2 = rgb[2] / 255;
    r2 = r2 > 0.04045 ? __pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
    g2 = g2 > 0.04045 ? __pow((g2 + 0.055) / 1.055, 2.4) : g2 / 12.92;
    b2 = b2 > 0.04045 ? __pow((b2 + 0.055) / 1.055, 2.4) : b2 / 12.92;
    const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
    const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
    const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
    return [x2 * 100, y2 * 100, z2 * 100];
  };
  convert$1.rgb.lab = function(rgb) {
    const xyz = convert$1.rgb.xyz(rgb);
    let x2 = xyz[0];
    let y2 = xyz[1];
    let z2 = xyz[2];
    x2 /= 95.047;
    y2 /= 100;
    z2 /= 108.883;
    x2 = x2 > 8856e-6 ? __pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
    y2 = y2 > 8856e-6 ? __pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
    z2 = z2 > 8856e-6 ? __pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    const l2 = 116 * y2 - 16;
    const a2 = 500 * (x2 - y2);
    const b2 = 200 * (y2 - z2);
    return [l2, a2, b2];
  };
  convert$1.hsl.rgb = function(hsl) {
    const h2 = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l2 = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s2 === 0) {
      val = l2 * 255;
      return [val, val, val];
    }
    if (l2 < 0.5) {
      t2 = l2 * (1 + s2);
    } else {
      t2 = l2 + s2 - l2 * s2;
    }
    const t1 = 2 * l2 - t2;
    const rgb = [0, 0, 0];
    for (let i2 = 0; i2 < 3; i2++) {
      t3 = h2 + 1 / 3 * -(i2 - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i2] = val * 255;
    }
    return rgb;
  };
  convert$1.hsl.hsv = function(hsl) {
    const h2 = hsl[0];
    let s2 = hsl[1] / 100;
    let l2 = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l2, 0.01);
    l2 *= 2;
    s2 *= l2 <= 1 ? l2 : 2 - l2;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v2 = (l2 + s2) / 2;
    const sv2 = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
    return [h2, sv2 * 100, v2 * 100];
  };
  convert$1.hsv.rgb = function(hsv) {
    const h2 = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v2 = hsv[2] / 100;
    const hi2 = Math.floor(h2) % 6;
    const f2 = h2 - Math.floor(h2);
    const p2 = 255 * v2 * (1 - s2);
    const q2 = 255 * v2 * (1 - s2 * f2);
    const t2 = 255 * v2 * (1 - s2 * (1 - f2));
    v2 *= 255;
    switch (hi2) {
      case 0:
        return [v2, t2, p2];
      case 1:
        return [q2, v2, p2];
      case 2:
        return [p2, v2, t2];
      case 3:
        return [p2, q2, v2];
      case 4:
        return [t2, p2, v2];
      case 5:
        return [v2, p2, q2];
    }
  };
  convert$1.hsv.hsl = function(hsv) {
    const h2 = hsv[0];
    const s2 = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const vmin = Math.max(v2, 0.01);
    let sl2;
    let l2;
    l2 = (2 - s2) * v2;
    const lmin = (2 - s2) * vmin;
    sl2 = s2 * vmin;
    sl2 /= lmin <= 1 ? lmin : 2 - lmin;
    sl2 = sl2 || 0;
    l2 /= 2;
    return [h2, sl2 * 100, l2 * 100];
  };
  convert$1.hwb.rgb = function(hwb) {
    const h2 = hwb[0] / 360;
    let wh2 = hwb[1] / 100;
    let bl2 = hwb[2] / 100;
    const ratio = wh2 + bl2;
    let f2;
    if (ratio > 1) {
      wh2 /= ratio;
      bl2 /= ratio;
    }
    const i2 = Math.floor(6 * h2);
    const v2 = 1 - bl2;
    f2 = 6 * h2 - i2;
    if ((i2 & 1) !== 0) {
      f2 = 1 - f2;
    }
    const n2 = wh2 + f2 * (v2 - wh2);
    let r2;
    let g2;
    let b2;
    switch (i2) {
      default:
      case 6:
      case 0:
        r2 = v2;
        g2 = n2;
        b2 = wh2;
        break;
      case 1:
        r2 = n2;
        g2 = v2;
        b2 = wh2;
        break;
      case 2:
        r2 = wh2;
        g2 = v2;
        b2 = n2;
        break;
      case 3:
        r2 = wh2;
        g2 = n2;
        b2 = v2;
        break;
      case 4:
        r2 = n2;
        g2 = wh2;
        b2 = v2;
        break;
      case 5:
        r2 = v2;
        g2 = wh2;
        b2 = n2;
        break;
    }
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert$1.cmyk.rgb = function(cmyk) {
    const c2 = cmyk[0] / 100;
    const m2 = cmyk[1] / 100;
    const y2 = cmyk[2] / 100;
    const k2 = cmyk[3] / 100;
    const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
    const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
    const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert$1.xyz.rgb = function(xyz) {
    const x2 = xyz[0] / 100;
    const y2 = xyz[1] / 100;
    const z2 = xyz[2] / 100;
    let r2;
    let g2;
    let b2;
    r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
    g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
    b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
    r2 = r2 > 31308e-7 ? 1.055 * __pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
    g2 = g2 > 31308e-7 ? 1.055 * __pow(g2, 1 / 2.4) - 0.055 : g2 * 12.92;
    b2 = b2 > 31308e-7 ? 1.055 * __pow(b2, 1 / 2.4) - 0.055 : b2 * 12.92;
    r2 = Math.min(Math.max(0, r2), 1);
    g2 = Math.min(Math.max(0, g2), 1);
    b2 = Math.min(Math.max(0, b2), 1);
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert$1.xyz.lab = function(xyz) {
    let x2 = xyz[0];
    let y2 = xyz[1];
    let z2 = xyz[2];
    x2 /= 95.047;
    y2 /= 100;
    z2 /= 108.883;
    x2 = x2 > 8856e-6 ? __pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
    y2 = y2 > 8856e-6 ? __pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
    z2 = z2 > 8856e-6 ? __pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    const l2 = 116 * y2 - 16;
    const a2 = 500 * (x2 - y2);
    const b2 = 200 * (y2 - z2);
    return [l2, a2, b2];
  };
  convert$1.lab.xyz = function(lab) {
    const l2 = lab[0];
    const a2 = lab[1];
    const b2 = lab[2];
    let x2;
    let y2;
    let z2;
    y2 = (l2 + 16) / 116;
    x2 = a2 / 500 + y2;
    z2 = y2 - b2 / 200;
    const y22 = __pow(y2, 3);
    const x22 = __pow(x2, 3);
    const z22 = __pow(z2, 3);
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
    z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
    x2 *= 95.047;
    y2 *= 100;
    z2 *= 108.883;
    return [x2, y2, z2];
  };
  convert$1.lab.lch = function(lab) {
    const l2 = lab[0];
    const a2 = lab[1];
    const b2 = lab[2];
    let h2;
    const hr2 = Math.atan2(b2, a2);
    h2 = hr2 * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    const c2 = Math.sqrt(a2 * a2 + b2 * b2);
    return [l2, c2, h2];
  };
  convert$1.lch.lab = function(lch) {
    const l2 = lch[0];
    const c2 = lch[1];
    const h2 = lch[2];
    const hr2 = h2 / 360 * 2 * Math.PI;
    const a2 = c2 * Math.cos(hr2);
    const b2 = c2 * Math.sin(hr2);
    return [l2, a2, b2];
  };
  convert$1.rgb.ansi16 = function(args, saturation = null) {
    const [r2, g2, b2] = args;
    let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert$1.hsv.ansi16 = function(args) {
    return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
  };
  convert$1.rgb.ansi256 = function(args) {
    const r2 = args[0];
    const g2 = args[1];
    const b2 = args[2];
    if (r2 === g2 && g2 === b2) {
      if (r2 < 8) {
        return 16;
      }
      if (r2 > 248) {
        return 231;
      }
      return Math.round((r2 - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
    return ansi;
  };
  convert$1.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r2 = (color & 1) * mult * 255;
    const g2 = (color >> 1 & 1) * mult * 255;
    const b2 = (color >> 2 & 1) * mult * 255;
    return [r2, g2, b2];
  };
  convert$1.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c2 = (args - 232) * 10 + 8;
      return [c2, c2, c2];
    }
    args -= 16;
    let rem;
    const r2 = Math.floor(args / 36) / 5 * 255;
    const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b2 = rem % 6 / 5 * 255;
    return [r2, g2, b2];
  };
  convert$1.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string2 = integer.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert$1.hex.rgb = function(args) {
    const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match2) {
      return [0, 0, 0];
    }
    let colorString = match2[0];
    if (match2[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r2 = integer >> 16 & 255;
    const g2 = integer >> 8 & 255;
    const b2 = integer & 255;
    return [r2, g2, b2];
  };
  convert$1.rgb.hcg = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const max = Math.max(Math.max(r2, g2), b2);
    const min = Math.min(Math.min(r2, g2), b2);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r2) {
      hue = (g2 - b2) / chroma % 6;
    } else if (max === g2) {
      hue = 2 + (b2 - r2) / chroma;
    } else {
      hue = 4 + (r2 - g2) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert$1.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l2 = hsl[2] / 100;
    const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
    let f2 = 0;
    if (c2 < 1) {
      f2 = (l2 - 0.5 * c2) / (1 - c2);
    }
    return [hsl[0], c2 * 100, f2 * 100];
  };
  convert$1.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const c2 = s2 * v2;
    let f2 = 0;
    if (c2 < 1) {
      f2 = (v2 - c2) / (1 - c2);
    }
    return [hsv[0], c2 * 100, f2 * 100];
  };
  convert$1.hcg.rgb = function(hcg) {
    const h2 = hcg[0] / 360;
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    if (c2 === 0) {
      return [g2 * 255, g2 * 255, g2 * 255];
    }
    const pure = [0, 0, 0];
    const hi2 = h2 % 1 * 6;
    const v2 = hi2 % 1;
    const w2 = 1 - v2;
    let mg2 = 0;
    switch (Math.floor(hi2)) {
      case 0:
        pure[0] = 1;
        pure[1] = v2;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v2;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v2;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg2 = (1 - c2) * g2;
    return [
      (c2 * pure[0] + mg2) * 255,
      (c2 * pure[1] + mg2) * 255,
      (c2 * pure[2] + mg2) * 255
    ];
  };
  convert$1.hcg.hsv = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c2 + g2 * (1 - c2);
    let f2 = 0;
    if (v2 > 0) {
      f2 = c2 / v2;
    }
    return [hcg[0], f2 * 100, v2 * 100];
  };
  convert$1.hcg.hsl = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const l2 = g2 * (1 - c2) + 0.5 * c2;
    let s2 = 0;
    if (l2 > 0 && l2 < 0.5) {
      s2 = c2 / (2 * l2);
    } else if (l2 >= 0.5 && l2 < 1) {
      s2 = c2 / (2 * (1 - l2));
    }
    return [hcg[0], s2 * 100, l2 * 100];
  };
  convert$1.hcg.hwb = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c2 + g2 * (1 - c2);
    return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
  };
  convert$1.hwb.hcg = function(hwb) {
    const w2 = hwb[1] / 100;
    const b2 = hwb[2] / 100;
    const v2 = 1 - b2;
    const c2 = v2 - w2;
    let g2 = 0;
    if (c2 < 1) {
      g2 = (v2 - c2) / (1 - c2);
    }
    return [hwb[0], c2 * 100, g2 * 100];
  };
  convert$1.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert$1.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert$1.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert$1.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert$1.gray.hsv = convert$1.gray.hsl;
  convert$1.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert$1.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert$1.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert$1.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string2 = integer.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert$1.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  const conversions$1 = conversions$2;
  function buildGraph() {
    const graph = {};
    const models2 = Object.keys(conversions$1);
    for (let len = models2.length, i2 = 0; i2 < len; i2++) {
      graph[models2[i2]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue2 = [fromModel];
    graph[fromModel].distance = 0;
    while (queue2.length) {
      const current = queue2.pop();
      const adjacents = Object.keys(conversions$1[current]);
      for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
        const adjacent = adjacents[i2];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue2.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to2) {
    return function(args) {
      return to2(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn2 = conversions$1[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn2 = link(conversions$1[graph[cur].parent][cur], fn2);
      cur = graph[cur].parent;
    }
    fn2.conversion = path2;
    return fn2;
  }
  var route$1 = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models2 = Object.keys(graph);
    for (let len = models2.length, i2 = 0; i2 < len; i2++) {
      const toModel = models2[i2];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  const conversions = conversions$2;
  const route = route$1;
  const convert = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn2) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn2(args);
    };
    if ("conversion" in fn2) {
      wrappedFn.conversion = fn2.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn2) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result2 = fn2(args);
      if (typeof result2 === "object") {
        for (let len = result2.length, i2 = 0; i2 < len; i2++) {
          result2[i2] = Math.round(result2[i2]);
        }
      }
      return result2;
    };
    if ("conversion" in fn2) {
      wrappedFn.conversion = fn2.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn2 = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn2);
      convert[fromModel][toModel].raw = wrapRaw(fn2);
    });
  });
  var colorConvert = convert;
  (function(module) {
    const wrapAnsi16 = (fn2, offset) => (...args) => {
      const code = fn2(...args);
      return `[${code + offset}m`;
    };
    const wrapAnsi256 = (fn2, offset) => (...args) => {
      const code = fn2(...args);
      return `[${38 + offset};5;${code}m`;
    };
    const wrapAnsi16m = (fn2, offset) => (...args) => {
      const rgb = fn2(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    const ansi2ansi = (n2) => n2;
    const rgb2rgb = (r2, g2, b2) => [r2, g2, b2];
    const setLazyProperty = (object, property2, get2) => {
      Object.defineProperty(object, property2, {
        get: () => {
          const value = get2();
          Object.defineProperty(object, property2, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    let colorConvert$1;
    const makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert$1 === void 0) {
        colorConvert$1 = colorConvert;
      }
      const offset = isBackground ? 10 : 0;
      const styles2 = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles2[name] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles2[name] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles2;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "[39m";
      styles2.bgColor.close = "[49m";
      setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles2;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  })(ansiStyles$1);
  var browser = {
    stdout: false,
    stderr: false
  };
  const stringReplaceAll$1 = (string2, substring, replacer) => {
    let index = string2.indexOf(substring);
    if (index === -1) {
      return string2;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string2.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string2.substr(endIndex);
    return returnValue;
  };
  const stringEncaseCRLFWithFirstIndex$1 = (string2, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string2[index - 1] === "\r";
      returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string2.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string2.substr(endIndex);
    return returnValue;
  };
  var util$1 = {
    stringReplaceAll: stringReplaceAll$1,
    stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
  };
  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape$1(c2) {
    const u2 = c2[0] === "u";
    const bracket = c2[1] === "{";
    if (u2 && !bracket && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
      return String.fromCharCode(parseInt(c2.slice(1), 16));
    }
    if (u2 && bracket) {
      return String.fromCodePoint(parseInt(c2.slice(2, -1), 16));
    }
    return ESCAPES.get(c2) || c2;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape2, character) => escape2 ? unescape$1(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk2, styles2) {
    const enabled = {};
    for (const layer of styles2) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk2;
    for (const [styleName, styles3] of Object.entries(enabled)) {
      if (!Array.isArray(styles3)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
    }
    return current;
  }
  var templates = (chalk2, temporary) => {
    const styles2 = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m2, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape$1(escapeCharacter));
      } else if (style) {
        const string2 = chunk.join("");
        chunk = [];
        chunks.push(styles2.length === 0 ? string2 : buildStyle(chalk2, styles2)(string2));
        styles2.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles2.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk2, styles2)(chunk.join("")));
        chunk = [];
        styles2.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles2.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
  const ansiStyles = ansiStyles$1.exports;
  const { stdout: stdoutColor, stderr: stderrColor } = browser;
  const {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = util$1;
  const { isArray: isArray$3 } = Array;
  const levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  const styles = Object.create(null);
  const applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  class ChalkClass {
    constructor(options) {
      return chalkFactory(options);
    }
  }
  const chalkFactory = (options) => {
    const chalk2 = {};
    applyOptions(chalk2, options);
    chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
    Object.setPrototypeOf(chalk2, Chalk.prototype);
    Object.setPrototypeOf(chalk2.template, chalk2);
    chalk2.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk2.template.Instance = ChalkClass;
    return chalk2.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, __spreadProps(__spreadValues({}, styles), {
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  }));
  const createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  const createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray$3(arguments_[0]) && isArray$3(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto);
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  const applyStyle = (self2, string2) => {
    if (self2.level <= 0 || !string2) {
      return self2._isEmpty ? "" : string2;
    }
    let styler = self2._styler;
    if (styler === void 0) {
      return string2;
    }
    const { openAll, closeAll } = styler;
    if (string2.indexOf("") !== -1) {
      while (styler !== void 0) {
        string2 = stringReplaceAll(string2, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string2.indexOf("\n");
    if (lfIndex !== -1) {
      string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
    }
    return openAll + string2 + closeAll;
  };
  let template;
  const chalkTag = (chalk2, ...strings) => {
    const [firstString] = strings;
    if (!isArray$3(firstString) || !isArray$3(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i2 = 1; i2 < firstString.length; i2++) {
      parts.push(String(arguments_[i2 - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i2]));
    }
    if (template === void 0) {
      template = templates;
    }
    return template(chalk2, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  const chalk = Chalk();
  chalk.supportsColor = stdoutColor;
  chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
  chalk.stderr.supportsColor = stderrColor;
  var source$1 = chalk;
  function classInstance(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name === "Object")
      return false;
    if (Object.prototype.toString.call(object) === "[object Object]")
      return false;
    if (object.constructor === Object)
      return false;
    return true;
  }
  function deepMap(objectOrArray, processor, settings = {}, _path = []) {
    settings = __deepMerge$1({
      classInstances: false,
      array: true,
      privateProps: false,
      cloneFirst: true
    }, settings);
    const isArray2 = Array.isArray(objectOrArray);
    let newObject = isArray2 ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
    Object.keys(objectOrArray).forEach((prop) => {
      if (!settings.privateProps && prop.match(/^_/))
        return;
      if (plainObject$1(objectOrArray[prop]) || classInstance(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
        const res2 = deepMap(objectOrArray[prop], processor, settings, [
          ..._path,
          prop
        ]);
        if (isArray2) {
          newObject.push(res2);
        } else {
          if (prop === "..." && plainObject$1(res2)) {
            newObject = Object.assign(Object.assign({}, newObject), res2);
          } else {
            newObject[prop] = res2;
          }
        }
        return;
      }
      const res = processor({
        object: objectOrArray,
        prop,
        value: objectOrArray[prop],
        path: [..._path, prop].join(".")
      });
      if (res === -1) {
        delete objectOrArray[prop];
        return;
      }
      if (isArray2)
        newObject.push(res);
      else {
        if (prop === "..." && plainObject$1(res)) {
          newObject = Object.assign(Object.assign({}, newObject), res);
        } else {
          newObject[prop] = res;
        }
      }
    });
    return newObject;
  }
  function isMap(value) {
    return value instanceof Map;
  }
  function isArray$2(value) {
    return value && typeof value === "object" && value.constructor === Array;
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isFunction(value) {
    return value && {}.toString.call(value) === "[object Function]";
  }
  function isJson(value) {
    try {
      const res = JSON.parse(value);
      if (Object.keys(res).length)
        return true;
      return false;
    } catch (e2) {
      return false;
    }
    return true;
  }
  function isObject$1(value) {
    return value && typeof value === "object" && value.constructor === Object;
  }
  function mapToObject(map) {
    const obj2 = {};
    for (const [k2, v2] of map)
      obj2[k2] = v2;
    return obj2;
  }
  var decycle_1;
  const isArray$1 = (e2) => Array.isArray(e2), isObject = (e2) => Object.prototype.toString.call(e2).slice(8, -1) === "Object", validate$1 = (e2) => {
    if (e2 === void 0)
      throw new Error("This method requires one parameter");
    if (!isArray$1(e2) && !isObject(e2))
      throw new TypeError("This method only accepts arrays and objects");
  }, findRef = (e2, r2) => Object.keys(r2).find((a2) => r2[a2] === e2), decycle = (e2) => {
    validate$1(e2);
    let r2 = {};
    const a2 = (e3, c2 = "$") => {
      const s2 = findRef(e3, r2);
      return s2 ? { $ref: s2 } : isArray$1(e3) || isObject(e3) ? (r2[c2] = e3, isArray$1(e3) ? e3.map((e4, r3) => a2(e4, `${c2}[${r3}]`)) : Object.keys(e3).reduce((r3, s3) => (r3[s3] = a2(e3[s3], `${c2}.${s3}`), r3), {})) : e3;
    };
    return a2(e2);
  };
  decycle_1 = decycle;
  function fn$6(value, settings = {}) {
    settings = __deepMerge$1({
      beautify: true,
      highlight: true,
      verbose: true,
      theme: {
        number: source$1.yellow,
        default: source$1.white,
        keyword: source$1.blue,
        regexp: source$1.red,
        string: source$1.whiteBright,
        class: source$1.yellow,
        function: source$1.yellow,
        comment: source$1.gray,
        variable: source$1.red,
        attr: source$1.green
      }
    }, settings);
    if (typeof value === "string")
      return value;
    if (value === null)
      return null;
    if (value === void 0)
      return void 0;
    if (value instanceof Error) {
      const errorStr = value.toString();
      const stackStr = value.stack;
      const messageStr = value.message;
      if (settings.verbose) {
        return [
          `<red>${value.constructor.name || "Error"}</red>`,
          "",
          messageStr,
          "",
          stackStr
        ].join("\n");
      }
      return errorStr;
    }
    if (isMap(value)) {
      value = mapToObject(value);
    }
    if (isObject$1(value) || isArray$2(value) || isJson(value)) {
      try {
        value = decycle_1(value);
      } catch (e2) {
      }
      value = deepMap(value, ({ value: value2 }) => {
        if (value2 instanceof Map)
          return mapToObject(value2);
        return value2;
      });
      let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
      prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
      if (settings.highlight)
        ;
      return prettyString;
    }
    if (isBoolean(value)) {
      if (value)
        return "true";
      else
        return "false";
    }
    if (isFunction(value)) {
      return "" + value;
    }
    let returnString = "";
    try {
      value = decycle_1(value);
      returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    } catch (e2) {
      try {
        returnString = value.toString();
      } catch (e3) {
        returnString = value;
      }
    }
    return returnString;
  }
  var __parse = (value) => {
    if (typeof value !== "string")
      return value;
    value = value.split("\u2800").join("").trim();
    try {
      return Function(`
      "use strict";
      return (${value});
    `)();
    } catch (e2) {
      return value;
    }
  };
  const __encryptedMessages = {};
  var __md5 = {
    encrypt: function(message) {
      if (typeof message !== "string")
        message = fn$6(message);
      const string2 = md5(message).toString();
      __encryptedMessages[string2] = message;
      return string2;
    },
    decrypt: function(message) {
      if (!__encryptedMessages[message]) {
        console.warn(`The message "${message}" cannot be decrypted...`);
        return;
      }
      const string2 = __encryptedMessages[message];
      delete __encryptedMessages[message];
      return __parse(string2);
    }
  };
  function availableColors(settings) {
    settings = Object.assign({ excludeBasics: false }, settings !== null && settings !== void 0 ? settings : {});
    const _colors = [
      "yellow",
      "cyan",
      "green",
      "magenta",
      "blue",
      "red",
      "grey",
      "gray"
    ];
    let colors = _colors;
    if (settings.excludeBasics) {
      colors = _colors.filter((c2) => {
        return c2 !== "white" && c2 !== "black" && c2 !== "grey" && c2 !== "gray";
      });
    }
    return colors;
  }
  function pickRandom(array) {
    return array[Math.round(Math.random() * (array.length - 1))];
  }
  const _colorUsedByScope = {};
  const _colorsStack = {};
  function getColorFor(ref, settings) {
    settings = __deepMerge$1({
      scope: "default",
      excludeBasics: true
    }, settings !== null && settings !== void 0 ? settings : {});
    const availableColors$1 = availableColors(settings);
    const scopeId = __md5.encrypt(settings.scope);
    const refId = __md5.encrypt(ref);
    if (_colorsStack[`${scopeId}.${refId}`])
      return _colorsStack[`${scopeId}.${refId}`];
    if (!_colorUsedByScope[scopeId])
      _colorUsedByScope[scopeId] = [];
    if (_colorUsedByScope[scopeId].length >= availableColors$1.length) {
      const color = pickRandom(availableColors$1);
      _colorsStack[`${scopeId}.${refId}`] = color;
      return color;
    } else {
      for (let i2 = 0; i2 < availableColors$1.length; i2++) {
        if (_colorUsedByScope[scopeId].indexOf(availableColors$1[i2]) === -1) {
          _colorUsedByScope[scopeId].push(availableColors$1[i2]);
          _colorsStack[`${scopeId}.${refId}`] = availableColors$1[i2];
          return availableColors$1[i2];
        }
      }
    }
  }
  var __set = (obj2, path2, value, settings = {}) => {
    settings = Object.assign({}, settings);
    if (!path2 || path2 === "" || path2 === ".") {
      obj2 = value;
      return;
    }
    path2 = path2.replace(/\[(\w+)\]/g, ".[$1]");
    const a2 = unquote(path2).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p2) => unquote(p2));
    let o2 = obj2;
    while (a2.length - 1) {
      const n2 = a2.shift();
      if (!(n2 in o2)) {
        if (a2[0].match(/^\[[0-9]+\]$/))
          o2[n2] = [];
        else
          o2[n2] = {};
      }
      o2 = o2[n2];
    }
    if (a2[0].match(/^\[[0-9]+\]$/)) {
      if (!Array.isArray(o2))
        o2 = [];
      o2.push(value);
    } else {
      o2[a2[0]] = value;
    }
    return get(obj2, path2);
  };
  function toJson(object) {
    const newObj = {};
    deepMap(object, ({ value, path: path2 }) => {
      __set(newObj, path2, value);
      return value;
    }, {
      privateProps: false,
      classInstances: true
    });
    return newObj;
  }
  class SClass {
    constructor(settings = {}) {
      this._settings = {};
      this._interfacesStack = {};
      generateInterfacesStack(this);
      setSettings(this, settings);
      applyInterfaces(this);
      this.metas = getMetas(this);
      Object.defineProperty(this, "metas", {
        enumerable: true,
        value: getMetas(this)
      });
    }
    get formattedName() {
      var _a2, _b2, _c2;
      let name = `<yellow>${((_a2 = this.metas) === null || _a2 === void 0 ? void 0 : _a2.name) || ""}</yellow>`;
      if ((_b2 = this.metas) === null || _b2 === void 0 ? void 0 : _b2.id) {
        name += ` <cyan>${(_c2 = this.metas) === null || _c2 === void 0 ? void 0 : _c2.id}</cyan>`;
      }
      return name;
    }
    static extends(Cls) {
      class SClass2 extends Cls {
        constructor(settings, ...args) {
          super(...args);
          this._settings = {};
          this._interfacesStack = {};
          generateInterfacesStack(this);
          setSettings(this, settings);
          applyInterfaces(this);
          this.metas = getMetas(this);
          Object.defineProperty(this, "metas", {
            enumerable: true,
            value: getMetas(this)
          });
        }
        get formattedName() {
          let name = `<yellow>${this.name || ""}</yellow>`;
          if (this.id) {
            name += ` <cyan>${this.id}</cyan>`;
          }
          return name;
        }
        expose(instance, settings) {
          return expose(this, instance, settings);
        }
        applyInterface(name, on2) {
          return applyInterface(this, name, on2);
        }
        getInterface(name) {
          return getInterface(this, name);
        }
        toPlainObject() {
          return toPlainObject(this);
        }
      }
      return SClass2;
    }
    expose(instance, settings) {
      return expose(this, instance, settings);
    }
    applyInterface(name, on2) {
      return applyInterface(this, name, on2);
    }
    getInterface(name) {
      return getInterface(this, name);
    }
    toPlainObject() {
      return toPlainObject(this);
    }
  }
  function getMetas(ctx) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    let name = `<yellow>${((_a2 = ctx._settings.metas) === null || _a2 === void 0 ? void 0 : _a2.name) || ""}</yellow>`;
    if ((_b2 = ctx._settings.metas) === null || _b2 === void 0 ? void 0 : _b2.id) {
      name += ` <cyan>${ctx._settings.metas.id}</cyan>`;
    }
    const metasObj = {
      id: (_d2 = (_c2 = ctx._settings.metas) === null || _c2 === void 0 ? void 0 : _c2.id) !== null && _d2 !== void 0 ? _d2 : ctx.constructor.name,
      name: (_f2 = (_e2 = ctx._settings.metas) === null || _e2 === void 0 ? void 0 : _e2.name) !== null && _f2 !== void 0 ? _f2 : ctx.constructor.name,
      formattedName: name,
      color: (_h2 = (_g2 = ctx._settings.metas) === null || _g2 === void 0 ? void 0 : _g2.color) !== null && _h2 !== void 0 ? _h2 : "yellow"
    };
    return metasObj;
  }
  function generateInterfacesStack(ctx) {
    const extendsStack = fn$7(ctx, {
      includeBaseClass: true
    });
    Object.keys(extendsStack).forEach((className) => {
      const cls2 = extendsStack[className];
      if (cls2.interfaces) {
        ctx._interfacesStack[className] = cls2.interfaces;
      }
    });
  }
  function expose(ctx, instance, settings) {
    settings = __deepMerge$1({
      as: void 0,
      props: []
    }, settings);
    if (settings.as && typeof settings.as === "string") {
      ctx[settings.as] = instance;
    }
    if (settings.props) {
      settings.props.forEach((prop) => {
        if (instance[prop].bind && typeof instance[prop].bind === "function") {
          ctx[prop] = instance[prop].bind(instance);
        } else {
          ctx[prop] = instance[prop];
        }
      });
    }
  }
  function getInterfaceObj(ctx, name) {
    let interfaceObj = get(ctx._interfacesStack, name);
    if (!interfaceObj) {
      const keys = Object.keys(ctx._interfacesStack);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const interfacesObj = ctx._interfacesStack[keys[i2]];
        if (interfacesObj[name] !== void 0) {
          if (plainObject$1(interfacesObj[name])) {
            interfaceObj = interfacesObj[name];
          } else {
            interfaceObj = {
              apply: true,
              on: name === "settings" ? "_settings" : name === "this" ? ctx : void 0,
              class: interfacesObj[name]
            };
          }
          break;
        }
      }
    }
    if (name === "settings" && interfaceObj.on === void 0) {
      if (ctx.settings !== void 0)
        interfaceObj.on = "settings";
      else if (ctx._settings !== void 0)
        interfaceObj.on = "_settings";
    }
    return interfaceObj;
  }
  function toPlainObject(ctx) {
    return toJson(ctx);
  }
  function getInterface(ctx, name) {
    const interfaceObj = getInterfaceObj(ctx, name);
    if (plainObject$1(interfaceObj))
      return interfaceObj.class;
    return interfaceObj;
  }
  function applyInterfaces(ctx) {
    const keys = Object.keys(ctx._interfacesStack);
    for (let i2 = keys.length - 1; i2 >= 0; i2--) {
      const interfacesObj = ctx._interfacesStack[keys[i2]];
      const className = keys[i2];
      Object.keys(interfacesObj).forEach((name) => {
        const interfaceObj = interfacesObj[name];
        let settings;
        if (plainObject$1(interfaceObj)) {
          settings = Object.assign({}, Object.assign({ apply: true, on: name === "settings" ? "_settings" : name === "this" ? ctx : void 0 }, interfaceObj));
        } else {
          settings = Object.assign({}, {
            apply: true,
            on: name === "settings" ? "_settings" : name === "this" ? ctx : void 0,
            class: interfaceObj
          });
        }
        if (settings.apply !== true)
          return;
        if (settings.on) {
          if (typeof settings.on === "string" && get(ctx, settings.on) !== void 0) {
            applyInterface(ctx, `${className}.${name}`, settings.on);
          } else if (typeof settings.on === "object") {
            applyInterface(ctx, `${className}.${name}`, settings.on);
          } else if (ctx[name] !== void 0) {
            applyInterface(ctx, `${className}.${name}`);
          }
        }
      });
    }
  }
  function applyInterface(ctx, name, on2 = null) {
    const interfaceObj = getInterfaceObj(ctx, `${name}`);
    if (!interfaceObj) {
      throw new Error(`You try to apply the interface named "<yellow>${name}</yellow>" on the context "<cyan>${ctx.name}</cyan>" but it does not exists...`);
    }
    if (on2 !== void 0)
      interfaceObj.on = on2;
    if (!interfaceObj) {
      throw `Sorry the the asked interface "<yellow>${name}</yellow>" does not exists on the class "<cyan>${ctx.constructor.name}</cyan>"`;
    }
    if (name.includes(".")) {
      name = name.split(".").slice(1).join(".");
    }
    if (plainObject$1(interfaceObj)) {
      let onValue;
      if (interfaceObj.on && typeof interfaceObj.on === "string") {
        onValue = get(ctx, interfaceObj.on);
      } else if (interfaceObj.on && typeof interfaceObj.on === "object") {
        onValue = interfaceObj.on;
      } else {
        onValue = get(ctx, name);
      }
      let applyId = ctx.constructor.name;
      if (ctx.id)
        applyId += `(${ctx.id})`;
      if (name)
        applyId += `.${name}`;
      if (interfaceObj.on && interfaceObj.on.constructor)
        applyId += `.${interfaceObj.on.constructor.name}`;
      if (interfaceObj.on && interfaceObj.on.id)
        applyId += `(${interfaceObj.on.id})`;
      let res;
      if (name === "this") {
        res = interfaceObj.class.apply(onValue || {}, {
          id: applyId,
          throw: true
        });
        deepAssign(ctx, res.value);
        return ctx;
      } else {
        res = interfaceObj.class.apply(onValue, {
          id: applyId,
          throw: true
        });
        if (interfaceObj.on && typeof interfaceObj.on === "object") {
          const returnValue = deepAssign(interfaceObj.on, res);
          return returnValue;
        } else if (interfaceObj.on && typeof interfaceObj.on === "string") {
          return deepAssign(get(ctx, interfaceObj.on), res);
        } else if (ctx[name] !== void 0) {
          return ctx[name];
        } else {
          return res;
        }
      }
    }
  }
  function setSettings(ctx, settings = {}) {
    var _a2;
    ctx._settings = settings;
    if (!ctx._settings.metas)
      ctx._settings.metas = {};
    if (!((_a2 = ctx._settings.metas) === null || _a2 === void 0 ? void 0 : _a2.id))
      ctx._settings.metas.id = ctx.constructor.name;
    if (!ctx.constructor.name.match(/^SConfig/)) {
      if (!ctx._settings.metas.color)
        ctx._settings.metas.color = getColorFor(ctx.constructor.name, {
          scope: "class"
        });
    } else if (!ctx._settings.metas.color)
      ctx._settings.metas.color = "yellow";
  }
  function isInteger(data) {
    return typeof data === "number" && !isNaN(data) && function(x2) {
      return (x2 | 0) === x2;
    }(parseFloat(data));
  }
  function upperFirst(string2) {
    return string2.charAt(0).toUpperCase() + string2.slice(1);
  }
  function typeOf(value, settings = {}) {
    settings = __deepMerge$1({
      of: false,
      customClass: true
    }, settings);
    let type;
    if (Array.isArray(value))
      type = "Array";
    else if (value instanceof Map)
      type = "Map";
    else if (value === null)
      type = "Null";
    else if (value === void 0)
      type = "Undefined";
    else if (typeof value === "string")
      type = "String";
    else if (isInteger(value))
      type = "Integer";
    else if (typeof value === "number")
      type = "Number";
    else if (typeof value === "boolean")
      type = "Boolean";
    else if (value instanceof RegExp)
      type = "RegExp";
    else if (settings.customClass === true && cls(value) && value.name !== void 0) {
      type = upperFirst(value.name);
    } else if (settings.customClass === true && value.constructor !== void 0 && value.constructor.name !== void 0) {
      type = upperFirst(value.constructor.name);
    } else if (settings.customClass === false && cls(value)) {
      type = "Class";
    } else if (typeof value === "function")
      type = "Function";
    else if (typeof value === "object")
      type = "Object";
    else
      type = "Unknown";
    const avoidTypes = [
      "Null",
      "Undefined",
      "String",
      "Integer",
      "Number",
      "Boolean",
      "Unknown"
    ];
    if (settings.of === true && !avoidTypes.includes(type)) {
      const loopOn = Array.isArray(value) ? [...value.keys()] : Object.keys(value);
      const receivedTypes = [];
      loopOn.forEach((valueIndex) => {
        const valueToCheck = value[valueIndex];
        const childType = typeOf(valueToCheck, {
          of: false,
          customClass: settings.customClass
        });
        if (!receivedTypes.includes(childType)) {
          receivedTypes.push(childType);
        }
      });
      type += `<${receivedTypes.join("|")}>`;
    }
    return type;
  }
  const fn$5 = function(stack, callback, settings = {}) {
    settings = Object.assign({ newStack: false }, settings);
    const stackType = typeOf(stack).toLowerCase();
    let loopOnKeys;
    if (stackType === "object")
      loopOnKeys = Object.keys(stack);
    else if (stackType === "array")
      loopOnKeys = Array.from(Array(stack.length).keys());
    else if (stackType === "number" || stackType === "integer")
      loopOnKeys = Array.from(Array(Math.round(stack)).keys());
    else if (stackType === "string")
      loopOnKeys = Array.from(stack);
    else if (stackType === "set")
      loopOnKeys = Array.from(stack);
    else
      loopOnKeys = Array.from(stack.keys());
    if (stackType === "string" || stackType === "number" || stackType === "integer" || stackType === "set")
      settings.newStack = true;
    let newStack = [];
    if (stackType === "object")
      newStack = {};
    else if (stackType === "map")
      newStack = new Map();
    else if (stackType === "set")
      newStack = new Set();
    let value;
    let newValue;
    const _get = (s2, k2) => {
      switch (typeOf(s2).toLowerCase()) {
        case "array":
        case "object":
          return s2[k2];
        case "string":
          return k2;
        case "number":
        case "integer":
          return k2;
        case "map":
          return s2.get(k2);
        case "set":
          return k2;
      }
    };
    const _set = (s2, k2, v2) => {
      switch (typeOf(s2).toLowerCase()) {
        case "array":
          if (settings.newStack === true)
            s2.push(v2);
          else
            s2[k2] = v2;
          break;
        case "object":
          s2[k2] = v2;
          break;
        case "number":
        case "integer":
        case "string":
          s2.push(v2);
          break;
        case "map":
          s2.set(k2, v2);
          break;
        case "set":
          s2.add(v2);
          break;
      }
    };
    for (let i2 = 0; i2 < loopOnKeys.length; i2++) {
      const key = loopOnKeys[i2];
      value = _get(stack, key);
      newValue = callback({ key, prop: key, value, i: i2, idx: i2 });
      if (newValue === -1)
        break;
      _set(settings.newStack ? newStack : stack, key, newValue);
    }
    if (stackType === "string") {
      return newStack.join("");
    }
    return settings.newStack ? newStack : stack;
  };
  source$1.level = 3;
  const tagsMap = {
    black: (tag2, content) => source$1.black(content),
    red: (tag2, content) => source$1.red(content),
    green: (tag2, content) => source$1.green(content),
    yellow: (tag2, content) => source$1.yellow(content),
    blue: (tag2, content) => source$1.blue(content),
    magenta: (tag2, content) => source$1.magenta(content),
    cyan: (tag2, content) => source$1.cyan(content),
    white: (tag2, content) => source$1.white(content),
    grey: (tag2, content) => source$1.grey(content),
    bgBlack: (tag2, content) => source$1.bgBlack(content),
    bgRed: (tag2, content) => source$1.bgRed(content),
    bgGreen: (tag2, content) => source$1.bgGreen(content),
    bgYellow: (tag2, content) => source$1.bgYellow(content),
    bgBlue: (tag2, content) => source$1.bgBlue(content),
    bgMagenta: (tag2, content) => source$1.bgMagenta(content),
    bgCyan: (tag2, content) => source$1.bgCyan(content),
    bgWhite: (tag2, content) => source$1.bgWhite(content),
    bold: (tag2, content) => source$1.bold(content),
    dim: (tag2, content) => source$1.dim(content),
    italic: (tag2, content) => source$1.italic(content),
    underline: (tag2, content) => source$1.underline(content),
    strike: (tag2, content) => source$1.strike(content),
    h1: (tag2, content) => {
      return source$1.underline(source$1.bold(content)) + "\n\n";
    },
    h2: (tag2, content) => {
      return source$1.bold(content) + "\n";
    },
    date: (tag2, content) => new Date().getDate().toString().padStart("0", 2) + "-" + (new Date().getMonth() + 1).toString().padStart("0", 2) + "-" + new Date().getFullYear().toString().padStart("0", 2),
    time: (tag2, content) => new Date().getHours().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2),
    day: (tag2, content) => new Date().getDate().toString().padStart("0", 2),
    days: (tag2, content) => new Date().getDate().toString().padStart("0", 2),
    month: (tag2, content) => new Date().getMonth().toString().padStart("0", 2),
    months: (tag2, content) => new Date().getMonth().toString().padStart("0", 2),
    year: (tag2, content) => new Date().getFullYear().toString().padStart("0", 2),
    years: (tag2, content) => new Date().getFullYear().toString().padStart("0", 2),
    hour: (tag2, content) => new Date().getHours().toString().padStart("0", 2),
    hours: (tag2, content) => new Date().getHours().toString().padStart("0", 2),
    minute: (tag2, content) => new Date().getMinutes().toString().padStart("0", 2),
    minutes: (tag2, content) => new Date().getMinutes().toString().padStart("0", 2),
    second: (tag2, content) => new Date().getSeconds().toString().padStart("0", 2),
    seconds: (tag2, content) => new Date().getSeconds().toString().padStart("0", 2),
    br: (tag2, content) => "\n"
  };
  function replaceTags(text, tags) {
    if (!text)
      text = "";
    text = fn$6(text);
    let oneLineText = text.replace(/\r\n/g, "|rn|");
    oneLineText = oneLineText.replace(/\n/g, "|n|");
    oneLineText = oneLineText.replace(/\r/g, "|r|");
    Object.keys(tags).forEach((tagName) => {
      const reg = new RegExp(`<s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`, "g");
      const tagsArray = oneLineText.match(reg);
      const singleReg = new RegExp(`\\s?<${tagName}\\s?/>\\s?`, "g");
      const singleTagsArray = oneLineText.match(singleReg);
      if (tagsArray) {
        for (let i2 = 0; i2 < tagsArray.length; i2++) {
          const t2 = tagsArray[i2];
          const tagArgs = t2.match(`<\\s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`);
          if (!tagArgs)
            continue;
          const tagToReplace = tagArgs[0];
          const tagContent = tagArgs[1];
          oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
        }
      }
      if (singleTagsArray) {
        for (let i2 = 0; i2 < singleTagsArray.length; i2++) {
          const t2 = singleTagsArray[i2];
          const tagArgs = t2.match(`\\s?<${tagName}\\s?/>\\s?`);
          if (!tagArgs)
            continue;
          const tagToReplace = tagArgs[0];
          const tagContent = "";
          oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
        }
      }
    });
    oneLineText = oneLineText.replace(/\|rn\|/g, "\r\n");
    oneLineText = oneLineText.replace(/\|n\|/g, "\n");
    oneLineText = oneLineText.replace(/\|r\|/g, "\r");
    return oneLineText;
  }
  function parseHtml(message) {
    let isArray2 = false;
    if (Array.isArray(message)) {
      isArray2 = true;
    } else {
      message = [message];
    }
    message = message.map((m2) => {
      return replaceTags(m2, tagsMap);
    });
    if (isArray2)
      return message;
    return message[0];
  }
  function parseSingleTypeString(typeString) {
    let ofStr = "", typeStr = typeString;
    const ofPartsString = typeString.match(/<(.+)>$/gm);
    if (ofPartsString && ofPartsString.length) {
      ofStr = ofPartsString[0].replace("<", "").replace(">", "");
    }
    if (ofStr !== "") {
      typeStr = typeStr.replace(`<${ofStr}>`, "");
    }
    let ofTypes = ofStr !== "" ? [ofStr.toLowerCase()] : void 0;
    if (ofStr !== void 0 && ofStr.includes("|")) {
      ofTypes = ofStr.split("|").map((t2) => t2.trim().toLowerCase());
    }
    return {
      type: typeStr,
      of: ofTypes
    };
  }
  const fn$4 = function parseTypeString(typeString) {
    typeString = typeString.toLowerCase().trim();
    typeString = typeString.split("|").map((part) => {
      part = part.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, "array<$1>");
      return part;
    }).join("|");
    typeString = typeString.split("|").map((part) => {
      part = part.trim().replace(/^([a-zA-Z0-9-_]+)\{\}$/, "object<$1>");
      return part;
    }).join("|");
    let types = [], inGroup = false, currentStr = "";
    for (let i2 = 0; i2 < typeString.length; i2++) {
      const char = typeString[i2];
      if (char === "<") {
        inGroup = true;
        currentStr += char;
      } else if (char === ">") {
        inGroup = false;
        currentStr += char;
      } else if (char === "|") {
        if (inGroup === false) {
          types.push(currentStr);
          currentStr = "";
        } else {
          currentStr += char;
        }
      } else {
        currentStr += char;
      }
    }
    types.push(currentStr);
    const finalTypes = [];
    types.forEach((type) => {
      finalTypes.push(parseSingleTypeString(type));
    });
    const res = {
      raw: typeString,
      types: finalTypes
    };
    return res;
  };
  var __isNode = () => {
    return typeof process !== "undefined" && process.release && process.release.name === "node";
  };
  class STypeResult {
    constructor(data) {
      this._data = data;
    }
    get typeString() {
      return this._data.typeString;
    }
    get value() {
      return this._data.value;
    }
    get received() {
      return this._data.received;
    }
    get expected() {
      return this._data.expected;
    }
    get issues() {
      return this._data.issues;
    }
    get settings() {
      return this._data.settings;
    }
    hasIssues() {
      if (this._data)
        return true;
      return false;
    }
    toString() {
      if (__isNode()) {
        return this.toConsole();
      } else {
        return `The method "toHtml" has not being integrated for now...`;
      }
    }
    toConsole() {
      const headerArray = [
        `<underline><magenta>${this._data.settings.name}</magenta></underline>`,
        "",
        "<underline>Received value</underline>",
        "",
        `${fn$6(this._data.value, {
          beautify: true
        })}`,
        ""
      ];
      const issuesArray = [];
      Object.keys(this._data.issues).forEach((ruleId) => {
        const issueObj = this._data.issues[ruleId];
        const message = [];
        if (issueObj.expected.type) {
          message.push(`- Expected "<yellow>${issueObj.expected.type}</yellow>"`);
        }
        if (issueObj.received.type) {
          message.push(`- Received "<red>${issueObj.received.type}</red>"`);
        }
        if (issueObj.message) {
          message.push(["<underline>Details:</underline>", issueObj.message].join("\n"));
        }
        issuesArray.push(message.join("\n"));
      });
      const settingsArray = [
        "",
        `<underline>Settings</underline>`,
        "",
        `${fn$6(this._data.settings, {
          beautify: true
        })}`
      ];
      return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${this.settings.verbose ? settingsArray.join("\n") : ""}
    `).trim();
    }
  }
  class SType {
    constructor(typeString, settings = {}) {
      this.typeString = typeString;
      typeString = typeString.toLowerCase().trim();
      if (this.constructor._instanciatedTypes[typeString] !== void 0)
        return this.constructor._instanciatedTypes[typeString];
      this.types = fn$4(typeString).types;
      this._settings = __deepMerge$1({
        id: this.constructor.name,
        name: this.constructor.name,
        customTypes: true,
        interfaces: true
      }, settings);
      this.constructor._instanciatedTypes[typeString] = this;
    }
    static registerType(type) {
      if (type.id === void 0 || typeof type.id !== "string") {
        throw new Error(`Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...`);
      }
      this._registeredTypes[type.id] = type;
    }
    is(value, settings = {}) {
      const res = this.check(value, settings);
      if (res === true)
        return true;
      else if (res instanceof STypeResult)
        return !res.hasIssues();
      return true;
    }
    check(value, settings = {}) {
      settings = __deepMerge$1(this._settings, settings);
      const issues = {};
      for (let i2 = 0; i2 < this.types.length; i2++) {
        const typeObj = this.types[i2], typeId = typeObj.type;
        const res2 = this._isType(value, typeId, settings);
        if (res2 === true) {
          if (typeObj.of === void 0)
            return true;
          const typeOf$1 = typeOf(value);
          if (typeOf$1 !== "Array" && typeOf$1 !== "Object" && typeOf$1 !== "Map") {
            throw new Error(`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${typeOf$1}</cyan>" that does not support "child" value(s)...`);
          }
          const loopOn = typeOf$1 === "Object" ? Object.keys(value) : Array.from(value.keys());
          if (!loopOn.length)
            return true;
          for (let k2 = 0; k2 < loopOn.length; k2++) {
            for (let j2 = 0; j2 < typeObj.of.length; j2++) {
              const type = typeObj.of[j2];
              const idx = loopOn[k2];
              const v2 = typeOf$1 === "Map" ? value.get(idx) : value[idx];
              const ofRes = this._isType(v2, type, settings);
              if (ofRes !== true) {
                issues[typeObj.type] = {
                  expected: {
                    type: typeObj.type
                  },
                  received: {
                    type: typeOf(v2),
                    value: v2
                  }
                };
              } else {
                return true;
              }
            }
          }
        } else {
          const issueObj = {
            expected: {
              type: typeObj.type
            },
            received: {
              type: typeOf(value),
              value
            }
          };
          if (res2 !== void 0 && res2 !== null && res2 !== false && res2.toString && typeof res2.toString === "function") {
            issueObj.message = res2.toString();
          }
          issues[typeObj.type] = issueObj;
        }
      }
      const res = new STypeResult({
        typeString: this.typeString,
        value,
        expected: {
          type: this.typeString
        },
        received: {
          type: typeOf(value)
        },
        issues,
        settings
      });
      return res;
    }
    _isType(value, type, settings = {}) {
      settings = __deepMerge$1(this._settings, settings);
      if (this.constructor._registeredTypes[type.toLowerCase()] === void 0) {
        if (settings.interfaces === true) {
          const availableInterfaceTypes = SInterface.getAvailableTypes();
          if (availableInterfaceTypes[type] !== void 0) {
            const res = availableInterfaceTypes[type].apply(value, {});
            return res;
          }
        }
        if (settings.customTypes === true) {
          const typeOf$1 = typeOf(value).toLowerCase();
          const extendsStack = Object.keys(fn$7(value)).map((s2) => s2.toLowerCase());
          if (type === typeOf$1 || extendsStack.indexOf(type) !== -1)
            return true;
        }
        throw new Error(`Sorry but you try to validate a value with the type "<yellow>${type}</yellow>" but this type is not registered...`);
      }
      return this.constructor._registeredTypes[type.toLowerCase()].is(value);
    }
    cast(value, params, settings) {
      settings = __deepMerge$1(this._settings, settings);
      const verboseObj = {
        value,
        issues: {},
        settings,
        toString() {
          const strAr = Object.entries(this.issues);
          return strAr.map((l2) => l2[1]).join("\n");
        }
      };
      if (this.is(value)) {
        return value;
      }
      for (let i2 = 0; i2 < this.types.length; i2++) {
        const typeObj = this.types[i2], typeId = typeObj.type;
        const descriptorObj = this.constructor._registeredTypes[typeId.toLowerCase()];
        if (descriptorObj === void 0) {
          continue;
        }
        if (descriptorObj.cast === void 0)
          continue;
        let castedValue;
        castedValue = descriptorObj.cast(value, params);
        if (castedValue instanceof Error) {
          verboseObj.issues[typeId] = castedValue.toString();
          continue;
        }
        if (typeObj.of !== void 0 && this.canHaveChilds(castedValue) === false) {
          const issueStr = `Sorry but the passed type "<yellow>${typeId}</yellow>" has some child(s) dependencies "<green>${typeObj.of.join("|")}</green>" but this type can not have child(s)`;
          throw new Error(parseHtml(issueStr));
        } else if (typeObj.of !== void 0) {
          const sTypeInstance = new SType(typeObj.of.join("|"));
          castedValue = fn$5(castedValue, ({ value: value2 }) => {
            return sTypeInstance.cast(value2, params, settings);
          });
        }
        if (castedValue === null && descriptorObj.id === "null")
          return null;
        if (castedValue === void 0 && descriptorObj.id === "undefined")
          return void 0;
        if (castedValue !== null && castedValue !== void 0)
          return castedValue;
        verboseObj.issues[typeId] = `Something goes wrong but no details are available... Sorry`;
      }
      const stack = [
        `Sorry but the value of type "<cyan>${typeOf(value)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:
`
      ];
      Object.keys(verboseObj.issues).forEach((descriptorId) => {
        stack.push(`- <red>${descriptorId}</red>: ${verboseObj.issues[descriptorId]}`);
      });
      throw new Error(parseHtml(stack.join("\n")));
    }
    canHaveChilds(value) {
      const type = typeOf(value);
      return type === "Array" || type === "Object" || type === "Map";
    }
    get name() {
      return this._settings.name;
    }
    get id() {
      return this._settings.id;
    }
  }
  SType._instanciatedTypes = {};
  SType._registeredTypes = {};
  function isString(value) {
    return typeof value === "string" || value instanceof String;
  }
  const descriptor$g = {
    name: "String",
    id: "string",
    is: (value) => isString(value),
    cast: (value) => fn$6(value, {
      beautify: true
    })
  };
  const descriptor$f = {
    name: "Map",
    id: "map",
    is: (value) => isMap(value),
    cast: (value) => {
      if (isMap(value))
        return value;
      const map = new Map();
      map.set("value", value);
      return map;
    }
  };
  const descriptor$e = {
    name: "Object",
    id: "object",
    is: (value) => isObject$1(value),
    cast: (value) => {
      if (isObject$1(value))
        return value;
      return {
        value
      };
    }
  };
  const descriptor$d = {
    name: "Array",
    id: "array",
    is: (value) => {
      return Array.isArray(value);
    },
    cast: (value, params = {}) => {
      if (!value)
        return [];
      if (params.splitChars && Array.isArray(params.splitChars)) {
        value = value.split(new RegExp(`(${params.splitChars.join("|")})`, "gm")).filter((l2) => l2.trim() !== "" && params.splitChars.indexOf(l2) === -1);
      }
      if (Array.isArray(value))
        return value;
      return [value];
    }
  };
  const descriptor$c = {
    name: "Integer",
    id: "integer",
    is: (value) => Number.isInteger(value),
    cast: (value) => {
      if (typeof value !== "string" && typeof value !== "number") {
        return new Error(`Sorry but only strings and numbers can be casted to integers... Passed value: ${value}`);
      }
      const res = parseInt(value);
      if (isNaN(res))
        return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Integer</green> does not work...`);
      return res;
    }
  };
  const descriptor$b = {
    name: "Number",
    id: "number",
    is: (value) => typeof value === "number",
    cast: (value) => {
      if (typeof value !== "string") {
        return new Error(`Sorry but only strings can be casted to numbers...`);
      }
      const res = parseFloat(value);
      if (isNaN(res))
        return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Number</green> does not work...`);
      return res;
    }
  };
  const descriptor$a = {
    name: "Boolean",
    id: "boolean",
    is: (value) => typeof value === "boolean",
    cast: (value, params = {}) => {
      if (value !== false && params && params.nullishAsTrue && !value) {
        return true;
      }
      if (typeof value === "boolean")
        return value;
      if (value === null || value === void 0)
        return false;
      if (typeof value === "number") {
        if (value > 0)
          return true;
        return false;
      }
      if (typeof value === "string") {
        return value.length > 0 ? true : false;
      }
      if (Array.isArray(value)) {
        if (value.length > 0)
          return true;
        return false;
      }
      if (typeof value === "object") {
        return Object.keys(value).length > 0 ? true : false;
      }
      return new Error([
        `Sorry but for now only these types can be casted to boolean:`,
        "- <yellow>null</yellow>: Will be casted as <red>false</red>",
        "- <yellow>undefined</yellow>: Will be casted as <red>false</red>",
        "- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise",
        "- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise",
        "- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise",
        "- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"
      ].join("\n"));
    }
  };
  const descriptor$9 = {
    name: "Undefined",
    id: "undefined",
    is: (value) => value === void 0,
    cast: (value) => {
      return void 0;
    }
  };
  const descriptor$8 = {
    name: "Null",
    id: "null",
    is: (value) => value === null,
    cast: (value) => {
      return null;
    }
  };
  const descriptor$7 = {
    name: "Symbol",
    id: "symbol",
    is: (value) => typeof value === "symbol",
    cast: (value) => {
      if (typeof value === "symbol")
        return value;
      return Symbol(value);
    }
  };
  const descriptor$6 = {
    name: "Bigint",
    id: "bigint",
    is: (value) => typeof value === "bigint",
    cast: (value) => {
      if (typeof value === "bigint")
        return value;
      if (typeof value !== "string" && typeof value !== "number") {
        return new Error(`Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>`);
      }
      let res;
      try {
        res = BigInt(value);
      } catch (e2) {
        res = new Error(`It seem's that the passed value "<yellow>${value}</yellow>" can not be casted to a <green>BigInt</green>`);
      }
      return res;
    }
  };
  const descriptor$5 = {
    name: "Date",
    id: "date",
    is: (value) => value instanceof Date,
    cast: (value) => {
      if (typeof value === "string") {
        return new Date(value);
      }
      if (typeof value === "number") {
        return new Date(Math.round(value));
      }
      if (plainObject$1(value)) {
        const now = new Date();
        let year = now.getFullYear(), month = 0, day = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
        if (value.year && typeof value.year === "number") {
          year = value.year;
        }
        if (value.month && typeof value.month === "number") {
          month = value.month;
        }
        if (value.day && typeof value.day === "number") {
          day = value.day;
        }
        if (value.hours && typeof value.hours === "number") {
          hours = value.hours;
        }
        if (value.minutes && typeof value.minutes === "number") {
          minutes = value.minutes;
        }
        if (value.seconds && typeof value.seconds === "number") {
          seconds = value.seconds;
        }
        if (value.milliseconds && typeof value.milliseconds === "number") {
          milliseconds = value.milliseconds;
        }
        return new Date(year, month, day, hours, minutes, seconds, milliseconds);
      }
      return new Error(`Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date`);
    }
  };
  const descriptor$4 = {
    name: "Function",
    id: "function",
    is: (value) => typeof value === "function",
    cast: (value) => {
      return new Error(`Sorry but nothing is castable to a Function`);
    }
  };
  const descriptor$3 = {
    name: "WeakMap",
    id: "weakmap",
    is: (value) => value instanceof WeakMap,
    cast: (value) => {
      return new Error(`Sorry but nothing can be casted to a WeakMap for now`);
    }
  };
  const descriptor$2 = {
    name: "WeakSet",
    id: "weakset",
    is: (value) => value instanceof WeakSet,
    cast: (value) => {
      return new Error(`Sorry but nothing can be casted to a WeakSet for now`);
    }
  };
  const descriptor$1 = {
    name: "Set",
    id: "set",
    is: (value) => value instanceof Set,
    cast: (value) => {
      if (value instanceof Set)
        return value;
      const set = new Set();
      set.add(value);
      return set;
    }
  };
  const descriptor = {
    name: "Class",
    id: "class",
    is: (value) => cls(value),
    cast: (value) => {
      return new Error(`Sorry but nothing is castable to a Class`);
    }
  };
  SType.registerType(descriptor$g);
  SType.registerType(descriptor$f);
  SType.registerType(descriptor$e);
  SType.registerType(descriptor$d);
  SType.registerType(descriptor$c);
  SType.registerType(descriptor$b);
  SType.registerType(descriptor$a);
  SType.registerType(descriptor$9);
  SType.registerType(descriptor$8);
  SType.registerType(descriptor$7);
  SType.registerType(descriptor$6);
  SType.registerType(descriptor$5);
  SType.registerType(descriptor$4);
  SType.registerType(descriptor$3);
  SType.registerType(descriptor$2);
  SType.registerType(descriptor$1);
  SType.registerType(descriptor);
  function ofType(value, typeString, settings = {}) {
    settings = Object.assign({ verbose: false }, settings);
    const typeInstance = new SType(typeString, settings);
    const res = typeInstance.is(value);
    return res;
  }
  class SDescriptorResult extends SClass {
    constructor(descriptor2, value, descriptorSettings) {
      super({});
      this._issues = {};
      this._descriptor = descriptor2;
      this._descriptorSettings = descriptorSettings;
      try {
        this._originalValue = clone(value, { deep: true });
      } catch (e2) {
        this._originalValue = value;
      }
      this.value = value;
    }
    hasIssues() {
      return Object.keys(this._issues).length >= 1;
    }
    add(ruleResult) {
      if (!ruleResult.__ruleObj.id)
        return;
      this._issues[ruleResult.__ruleObj.id] = ruleResult;
    }
    toString() {
      if (__isNode()) {
        return this.toConsole();
      } else {
        return this.toConsole();
      }
    }
    toConsole() {
      const headerArray = [
        `<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,
        "",
        `${fn$6(this.value, {
          beautify: true
        })}`,
        ""
      ];
      const issuesArray = [];
      Object.keys(this._issues).forEach((ruleId) => {
        const ruleResult = this._issues[ruleId];
        let message = "";
        if (ruleResult.__error && ruleResult.__error instanceof Error) {
          message = ruleResult.__error.message;
        } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "function") {
          message = ruleResult.__ruleObj.message(ruleResult);
        } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "string") {
          message = ruleResult.__ruleObj.message;
        }
        issuesArray.push(`-${typeof ruleResult.__propName === "string" ? ` [<magenta>${ruleResult.__propName}</magenta>]` : ""} <red>${ruleId}</red>: ${message}`);
      });
      const settingsArray = [
        "",
        `<underline>Settings</underline>`,
        "",
        `${fn$6(this._descriptorSettings, {
          beautify: true
        })}`
      ];
      return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${settingsArray.join("\n")}
    `).trim();
    }
  }
  /*!
  * is-extglob <https://github.com/jonschlinkert/is-extglob>
  *
  * Copyright (c) 2014-2016, Jon Schlinkert.
  * Licensed under the MIT License.
  */
  var isExtglob$1 = function isExtglob2(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match2;
    while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match2[2])
        return true;
      str = str.slice(match2.index + match2[0].length);
    }
    return false;
  };
  /*!
  * is-glob <https://github.com/jonschlinkert/is-glob>
  *
  * Copyright (c) 2014-2017, Jon Schlinkert.
  * Released under the MIT License.
  */
  var isExtglob = isExtglob$1;
  var chars = { "{": "}", "(": ")", "[": "]" };
  var strictCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;
    while (index < str.length) {
      if (str[index] === "*") {
        return true;
      }
      if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
        return true;
      }
      if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
        if (closeSquareIndex < index) {
          closeSquareIndex = str.indexOf("]", index);
        }
        if (closeSquareIndex > index) {
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
        }
      }
      if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
        closeCurlyIndex = str.indexOf("}", index);
        if (closeCurlyIndex > index) {
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
            return true;
          }
        }
      }
      if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
        closeParenIndex = str.indexOf(")", index);
        if (closeParenIndex > index) {
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
      if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
        if (pipeIndex < index) {
          pipeIndex = str.indexOf("|", index);
        }
        if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
          closeParenIndex = str.indexOf(")", pipeIndex);
          if (closeParenIndex > pipeIndex) {
            backSlashIndex = str.indexOf("\\", pipeIndex);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
      }
      if (str[index] === "\\") {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];
        if (close) {
          var n2 = str.indexOf(close, index);
          if (n2 !== -1) {
            index = n2 + 1;
          }
        }
        if (str[index] === "!") {
          return true;
        }
      } else {
        index++;
      }
    }
    return false;
  };
  var relaxedCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index = 0;
    while (index < str.length) {
      if (/[*?{}()[\]]/.test(str[index])) {
        return true;
      }
      if (str[index] === "\\") {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];
        if (close) {
          var n2 = str.indexOf(close, index);
          if (n2 !== -1) {
            index = n2 + 1;
          }
        }
        if (str[index] === "!") {
          return true;
        }
      } else {
        index++;
      }
    }
    return false;
  };
  var isGlob = function isGlob2(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var check = strictCheck;
    if (options && options.strict === false) {
      check = relaxedCheck;
    }
    return check(str);
  };
  var __isGlob = (string2) => {
    return isGlob(string2);
  };
  class SDescriptor extends SClass {
    constructor(settings) {
      super(__deepMerge$1({
        descriptor: {
          rules: {},
          type: "Object",
          arrayAsValue: false,
          throwOnMissingRule: false,
          defaults: true
        }
      }, settings !== null && settings !== void 0 ? settings : {}));
    }
    static registerRule(rule) {
      if (rule.id === void 0 || typeof rule.id !== "string") {
        throw new Error(`Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...`);
      }
      this._registeredRules[rule.id] = rule;
    }
    get descriptorSettings() {
      return this._settings.descriptor;
    }
    apply(value, settings) {
      const set = __deepMerge$1(this.descriptorSettings, settings || {});
      if (value === void 0 || value === null)
        value = {};
      const valuesObjToProcess = {}, finalValuesObj = {};
      this._descriptorResult = new SDescriptorResult(this, finalValuesObj, Object.assign({}, set));
      const rules = set.rules;
      if (!ofType(value, set.type)) {
        throw new Error(`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${typeOf(value)}</cyan>" but only "<green>${set.type}</green>"...`);
      }
      if (Array.isArray(value) && !set.arrayAsValue) {
        throw new Error(`Sorry but the support for arrays like values has not been integrated for not...`);
      } else if (typeof value === "object" && value !== null && value !== void 0) {
        Object.keys(rules).forEach((propName) => {
          if (__isGlob(propName) && value)
            ;
          else {
            valuesObjToProcess[propName] = get(value, propName);
          }
        });
        Object.keys(valuesObjToProcess).forEach((propName) => {
          const ruleObj2 = rules[propName];
          if (valuesObjToProcess[propName] === void 0 && set.defaults && ruleObj2.default !== void 0) {
            valuesObjToProcess[propName] = ruleObj2.default;
          }
          if (ruleObj2.interface !== void 0) {
            const interfaceValue = valuesObjToProcess[propName];
            valuesObjToProcess[propName] = ruleObj2.interface.apply(interfaceValue || {}, {});
          }
          const validationResult = this._validate(valuesObjToProcess[propName], propName, ruleObj2, set);
          if (validationResult !== void 0 && validationResult !== null) {
            __set(finalValuesObj, propName, validationResult);
          }
        });
      } else {
        console.warn(value);
        throw new Error(`You can apply an <yellow>SDescriptor</yellow> only on an Object like value...`);
      }
      if (this._descriptorResult.hasIssues()) {
        throw new Error(this._descriptorResult.toString());
      }
      return this._descriptorResult;
    }
    _validate(value, propName, rulesObj, settings) {
      if (rulesObj === void 0)
        return value;
      if (rulesObj.required === void 0 || rulesObj.required === false) {
        if (value === void 0 || value === null)
          return value;
      }
      let rulesNamesInOrder = Object.keys(rulesObj).filter((l2) => l2 !== "default");
      rulesNamesInOrder = rulesNamesInOrder.sort((a2, b2) => {
        const objA = this.constructor._registeredRules[a2];
        const objB = this.constructor._registeredRules[b2];
        if (!objA)
          return -1;
        if (!objB)
          return 1;
        if (objA.priority === void 0)
          objA.priority = 9999999999;
        if (objB.priority === void 0)
          objB.priority = 9999999999;
        return objA.priotity - objB.priority;
      }).reverse();
      let resultValue = value;
      rulesNamesInOrder.forEach((ruleName) => {
        const ruleValue = rulesObj[ruleName];
        if (this.constructor._registeredRules[ruleName] === void 0) {
          if (settings.throwOnMissingRule) {
            throw new Error(`Sorry but you try to validate a value using the "<yellow>${ruleName}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ${Object.keys(this.constructor._registeredRules).join("\n- ")}`);
          }
        } else {
          const ruleObj2 = this.constructor._registeredRules[ruleName];
          const params = ruleObj2.processParams !== void 0 ? ruleObj2.processParams(ruleValue) : ruleValue;
          const ruleSettings = ruleObj2.settings !== void 0 ? ruleObj2.settings : {};
          if (ruleSettings.mapOnArray && Array.isArray(resultValue)) {
            let newResultValue = [];
            resultValue.forEach((v2) => {
              const processedValue = this._processRule(v2, ruleObj2, propName, params, ruleSettings, settings);
              if (Array.isArray(processedValue)) {
                newResultValue = [
                  ...newResultValue,
                  ...processedValue
                ];
              } else {
                newResultValue.push(processedValue);
              }
            });
            resultValue = newResultValue;
          } else {
            const processedValue = this._processRule(resultValue, ruleObj2, propName, params, ruleSettings, settings);
            resultValue = processedValue;
          }
        }
      });
      return resultValue;
    }
    _processRule(value, ruleObj2, propName, params, ruleSettings, settings) {
      const ruleResult = ruleObj2.apply(value, params, ruleSettings, Object.assign(Object.assign({}, settings), { propName, name: `${settings.name}.${propName}` }));
      if (params && params.type && params.type.toLowerCase() === "boolean" && ruleResult === true) {
        return true;
      }
      if (ruleResult instanceof Error) {
        const obj2 = {
          __error: ruleResult,
          __ruleObj: ruleObj2,
          __propName: propName
        };
        if (this._descriptorResult) {
          this._descriptorResult.add(obj2);
          throw new Error(this._descriptorResult.toString());
        }
      } else {
        return ruleResult;
      }
    }
  }
  SDescriptor._registeredRules = {};
  SDescriptor.rules = {};
  SDescriptor.type = "Object";
  const ruleObj$3 = {
    priority: 1,
    name: "Required",
    id: "required",
    settings: {
      when: [void 0, null]
    },
    message: "This value is required",
    processParams: (params) => {
      return { value: params };
    },
    apply: (value, params, ruleSettings, settings) => {
      if (params.value === true) {
        if (ruleSettings.when.indexOf(value) !== -1) {
          return new Error("This property is <yellow>required</yellow>");
        }
      }
      return value;
    }
  };
  const ruleObj$2 = {
    prority: 10,
    name: "Type",
    id: "type",
    settings: {},
    processParams: (params) => {
      var _a2, _b2;
      if (!(params === null || params === void 0 ? void 0 : params.type) && typeof params !== "string") {
        throw new Error(`<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...`);
      }
      return Object.assign(Object.assign({}, typeof params !== "string" ? params : {}), { type: (_a2 = params.type) !== null && _a2 !== void 0 ? _a2 : params, cast: (_b2 = params.cast) !== null && _b2 !== void 0 ? _b2 : true });
    },
    apply: (value, params, ruleSettings, settings) => {
      const type = new SType(params.type, {
        metas: {
          id: settings.id
        }
      });
      if (params.cast && !type.is(value)) {
        value = type.cast(value, params);
      }
      if (!type.is(value)) {
        return new Error(`The value must be of type "<yellow>${params.type}</yellow>" but you've passed a value of type "<cyan>${typeof value}</cyan>"`);
      }
      return value;
    }
  };
  const ruleObj$1 = {
    name: "Min",
    id: "min",
    settings: {},
    accept: "Number",
    message: (resultObj) => {
      return `This value has to be minimum "<yellow>${resultObj.min}</yellow>". Received "<red>${resultObj.received}</red>"`;
    },
    processParams: (params) => {
      return { value: params };
    },
    apply: (value, params, ruleSettings, settings) => {
      if (value < params.value) {
        return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be greater or equal at <cyan>${params.value}</cyan>`);
      }
      return value;
    }
  };
  const ruleObj = {
    name: "Max",
    id: "max",
    settings: {},
    accept: "Number",
    message: (resultObj) => {
      return `This value has to be maximum "<yellow>${resultObj.max}</yellow>". Received "<red>${resultObj.received}</red>"`;
    },
    processParams: (params) => {
      return { value: params };
    },
    apply: (value, params, ruleSettings, settings) => {
      if (value > params.value) {
        return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be lower or equal at <cyan>${params.value}</cyan>`);
      }
      return value;
    }
  };
  SDescriptor.registerRule(ruleObj$3);
  SDescriptor.registerRule(ruleObj$2);
  SDescriptor.registerRule(ruleObj$1);
  SDescriptor.registerRule(ruleObj);
  function parseArgs(string2, settings = {}) {
    settings = __deepMerge$1({
      throw: true,
      defaultObj: {},
      cast: true,
      valueQuote: void 0
    }, settings);
    string2 = string2.trim();
    string2 = string2.replace(/(["'`])--/gm, "$1--\xA7 --");
    let valueQuote = settings.valueQuote;
    if (!valueQuote) {
      for (let i2 = 0; i2 < string2.length; i2++) {
        const char = string2[i2];
        if (char === '"' || char === "`" || char === "'") {
          valueQuote = char;
          break;
        }
      }
      if (!valueQuote)
        valueQuote = '"';
    }
    let stringArray = [];
    let isFunctionStyle = false;
    if (string2.match(/^\(/) && string2.match(/\)$/)) {
      isFunctionStyle = true;
      string2 = string2.slice(1, -1);
      let currentStr = "";
      let parenthesisCount = 0;
      let quotesCount = 0;
      for (let i2 = 0; i2 < string2.length; i2++) {
        const char = string2[i2];
        const previousChar = string2[i2 - 1] || string2[0];
        if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
          quotesCount++;
        } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
          quotesCount--;
        }
        if (!quotesCount && char === "(") {
          parenthesisCount++;
        } else if (!quotesCount && char === ")") {
          parenthesisCount--;
        }
        if (char === ",") {
          if (quotesCount || parenthesisCount) {
            currentStr += char;
          } else {
            stringArray.push(currentStr.trim());
            currentStr = "";
          }
        } else {
          currentStr += char;
        }
      }
      if (parenthesisCount)
        currentStr += ")".repeat(parenthesisCount);
      stringArray.push(currentStr.trim());
    } else {
      let currentStr = "";
      let quotesCount = false;
      for (let i2 = 0; i2 < string2.length; i2++) {
        const char = string2[i2];
        const previousChar = string2[i2 - 1] || string2[0];
        if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
          quotesCount = true;
        } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
          quotesCount = false;
        }
        if (char === " ") {
          if (quotesCount) {
            currentStr += char;
          } else {
            stringArray.push(currentStr.trim());
            currentStr = "";
          }
        } else {
          currentStr += char;
        }
      }
      stringArray.push(currentStr.trim());
    }
    stringArray = stringArray.map((item) => unquote(item));
    const argsObj = {};
    let currentArgName = void 0;
    let currentValue;
    stringArray = stringArray.forEach((part, i2) => {
      if (!isFunctionStyle && !part.includes(" ") && (part.slice(0, 2) === "--" || part.slice(0, 1) === "-")) {
        if (currentValue === void 0 && currentArgName !== -1 && currentArgName && argsObj[currentArgName] === void 0) {
          argsObj[currentArgName] = true;
        }
        currentArgName = part.replace(/^[-]{1,2}/, "");
        if (argsObj[currentArgName] === void 0) {
          argsObj[currentArgName] = true;
        }
      } else {
        let value;
        if (part && typeof part === "string") {
          value = part.replace(/^\\\\\\`/, "").replace(/\\\\\\`$/, "").replace(/^'/, "").replace(/'$/, "").replace(/^"/, "").replace(/"$/, "");
          if (value.match(/^\$[a-zA-Z0-9-_]+\s?:.*/)) {
            const parts = part.split(":");
            currentArgName = parts[0].trim().replace(/^\$/, "");
            value = parts.slice(1).join(":").trim();
          }
        }
        currentValue = __parse(value);
        if (typeof currentValue === "string") {
          currentValue = currentValue.replace("--\xA7 ", "");
        }
        if (currentArgName !== void 0) {
          if (argsObj[currentArgName] !== void 0 && argsObj[currentArgName] !== true) {
            if (!Array.isArray(argsObj[currentArgName])) {
              argsObj[currentArgName] = [argsObj[currentArgName]];
            }
            argsObj[currentArgName].push(currentValue);
          } else {
            argsObj[currentArgName] = currentValue;
          }
          currentValue = void 0;
          currentArgName = void 0;
        } else {
          argsObj[i2] = currentValue;
        }
      }
    });
    Object.keys(argsObj).forEach((key) => {
      const value = argsObj[key];
      if (value === void 0)
        delete argsObj[key];
    });
    return argsObj;
  }
  function getAvailableInterfaceTypes() {
    if (global !== void 0)
      return global._registeredInterfacesTypes || {};
    else if (window !== void 0)
      return window._registeredInterfacesTypes || {};
    else
      return {};
  }
  if (__isNode())
    global._registeredInterfacesTypes = {};
  else
    window._registeredInterfacesTypes = {};
  class SInterface extends SClass {
    constructor(settings) {
      super(__deepMerge$1({
        interface: {
          stripUnkown: false
        }
      }, settings !== null && settings !== void 0 ? settings : {}));
      this._definition = {};
      this._definition = this.constructor.definition;
    }
    static get definition() {
      if (this._cachedDefinition)
        return this._cachedDefinition;
      this._cachedDefinition = this._definition;
      return this._cachedDefinition;
    }
    static set definition(value) {
      this._cachedDefinition = value;
    }
    get interfaceSettings() {
      return this._settings.interface;
    }
    static registerRenderer(rendererClass) {
      if (!rendererClass.id) {
        throw new Error(`Sorry but the interface renderer "<yellow>${rendererClass.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);
      }
      this._registeredRenderers[rendererClass.id] = rendererClass;
    }
    static override(definition) {
      const _this = this;
      class SInterfaceOverrided extends this {
      }
      SInterfaceOverrided.overridedName = `${_this.name} (overrided)`;
      SInterfaceOverrided.definition = __deepMerge$1(_this.definition, definition);
      return SInterfaceOverrided;
    }
    static getAvailableTypes() {
      return getAvailableInterfaceTypes();
    }
    static makeAvailableAsType(name = null) {
      const n2 = (name || this.name).toLowerCase();
      if (global !== void 0) {
        global._registeredInterfacesTypes[n2] = this;
        global._registeredInterfacesTypes[n2.replace("interface", "")] = this;
      } else if (window !== void 0) {
        window._registeredInterfacesTypes[n2] = this;
        window._registeredInterfacesTypes[n2.replace("interface", "")] = this;
      }
    }
    static toObject() {
      var _a2;
      return {
        name: this.name,
        description: (_a2 = this.description) !== null && _a2 !== void 0 ? _a2 : "",
        definition: Object.assign({}, this.definition)
      };
    }
    static defaults() {
      const defaults = {};
      Object.keys(this.definition).forEach((key) => {
        const propObj = this.definition[key];
        if (propObj.default !== void 0) {
          defaults[key] = propObj.default;
        }
      });
      return defaults;
    }
    static apply(objectOrString, settings) {
      const int = new this({
        interface: settings !== null && settings !== void 0 ? settings : {}
      });
      return int.apply(objectOrString);
    }
    static render(renderer = "terminal", settings) {
      const set = __deepMerge$1({
        renderer: "terminal",
        exclude: ["help"]
      }, settings);
      if (!this._registeredRenderers[renderer]) {
        throw new Error(`Sorry but the requested renderer "<yellow>${renderer}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);
      }
      const rendererInstance = new this._registeredRenderers[renderer](this, set);
      return rendererInstance.render();
    }
    apply(objectOrString, settings) {
      var _a2;
      const set = __deepMerge$1(this.interfaceSettings, settings !== null && settings !== void 0 ? settings : {});
      let objectOnWhichToApplyInterface = objectOrString;
      if (typeof objectOrString === "string") {
        objectOnWhichToApplyInterface = parseArgs(objectOrString);
        Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
          for (let i2 = 0; i2 < Object.keys(this._definition).length; i2++) {
            const defArgName = Object.keys(this._definition)[i2];
            const obj2 = this._definition[defArgName];
            if (obj2.explicit) {
              if (obj2.alias && ` ${objectOrString} `.match(new RegExp(`\\s-${obj2.alias}\\s`)))
                return;
              else if (` ${objectOrString} `.match(new RegExp(`\\s--${argName}\\s`)))
                return;
              delete objectOnWhichToApplyInterface[argName];
            }
          }
        });
        Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
          for (let i2 = 0; i2 < Object.keys(this._definition).length; i2++) {
            const defArgName = Object.keys(this._definition)[i2];
            const obj2 = this._definition[defArgName];
            if (!obj2.alias)
              continue;
            if (obj2.alias === argName && objectOnWhichToApplyInterface[defArgName] === void 0) {
              objectOnWhichToApplyInterface[defArgName] = objectOnWhichToApplyInterface[argName];
              delete objectOnWhichToApplyInterface[argName];
            }
          }
        });
        Object.keys(objectOnWhichToApplyInterface).forEach((argName, i2) => {
          if (argName === `${i2}`) {
            const definitionKeys = Object.keys(this._definition);
            if (definitionKeys[i2]) {
              objectOnWhichToApplyInterface[definitionKeys[i2]] = objectOnWhichToApplyInterface[argName];
            }
            delete objectOnWhichToApplyInterface[argName];
          }
        });
      }
      const descriptor2 = new SDescriptor({
        descriptor: Object.assign({ type: "Object", rules: this._definition }, (_a2 = set.descriptor) !== null && _a2 !== void 0 ? _a2 : {})
      });
      if (set.baseObj) {
        objectOnWhichToApplyInterface = __deepMerge$1(set.baseObj, objectOnWhichToApplyInterface);
      }
      const descriptorResult = descriptor2.apply(objectOnWhichToApplyInterface);
      if (descriptorResult.hasIssues()) {
        throw new Error(descriptorResult.toString());
      }
      let resultObj = descriptorResult.value;
      if (!set.stripUnkown) {
        resultObj = __deepMerge$1(objectOnWhichToApplyInterface, resultObj);
      }
      return resultObj;
    }
  }
  SInterface.description = "";
  SInterface._registeredRenderers = {};
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function lowerCase(str) {
    return str.toLowerCase();
  }
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    var _a2 = options.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP : _a2, _b2 = options.stripRegexp, stripRegexp = _b2 === void 0 ? DEFAULT_STRIP_REGEXP : _b2, _c2 = options.transform, transform = _c2 === void 0 ? lowerCase : _c2, _d2 = options.delimiter, delimiter = _d2 === void 0 ? " " : _d2;
    var result2 = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result2.length;
    while (result2.charAt(start) === "\0")
      start++;
    while (result2.charAt(end - 1) === "\0")
      end--;
    return result2.slice(start, end).split("\0").map(transform).join(delimiter);
  }
  function replace(input, re2, value) {
    if (re2 instanceof RegExp)
      return input.replace(re2, value);
    return re2.reduce(function(input2, re3) {
      return input2.replace(re3, value);
    }, input);
  }
  function dotCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign({ delimiter: "." }, options));
  }
  function paramCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return dotCase(input, __assign({ delimiter: "-" }, options));
  }
  function dashCase(text) {
    return paramCase(text);
  }
  function wait(timeout = 0) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, timeout);
    });
  }
  function autoCast(string) {
    if (typeof string !== "string")
      return string;
    if (string.substr(0, 1) === "'" && string.substr(-1) === "'") {
      return string.substr(1, string.length - 2);
    }
    const presumedNumber = parseFloat(string);
    if (!isNaN(presumedNumber)) {
      if (presumedNumber.toString() === string) {
        return presumedNumber;
      }
    }
    if (window[string]) {
      return string;
    }
    try {
      const obj = eval(`(${string})`);
      return obj;
    } catch (e2) {
      return string;
    }
  }
  var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function adoptStyleInShadowRoot($shadowRoot, $context = document) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const $links = $context.querySelectorAll('link[rel="stylesheet"]');
      if ($links && $shadowRoot) {
        Array.from($links).forEach(($link) => __awaiter$6(this, void 0, void 0, function* () {
          $shadowRoot === null || $shadowRoot === void 0 ? void 0 : $shadowRoot.appendChild($link.cloneNode());
        }));
      }
      return true;
    });
  }
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i$4 = 0; i$4 < 256; ++i$4) {
    byteToHex.push((i$4 + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return stringify(rnds);
  }
  function uniqid() {
    return v4();
  }
  function injectStyle(style, id2 = `injected-style-${uniqid()}`, node = document.head) {
    const $tag = document.createElement("style");
    $tag.type = "text/css";
    $tag.setAttribute("id", `injected-style-${id2.toLowerCase()}`);
    $tag.innerHTML = style;
    node.appendChild($tag);
    return $tag;
  }
  function camelize(text) {
    if (!text)
      text = "";
    let res = "";
    const reg = /(?:^|[_-\s])(\w)/g;
    res = text.replace(reg, function(_2, c2) {
      return c2 ? c2.toUpperCase() : "";
    });
    res = res.substr(0, 1).toLowerCase() + res.slice(1);
    return res.trim();
  }
  function camelCase(text) {
    return camelize(text);
  }
  function getMethods(toCheck) {
    let props = [];
    let obj2 = toCheck;
    do {
      const _props = Object.getOwnPropertyNames(obj2);
      if (_props.indexOf("__defineGetter__") !== -1)
        continue;
      props = props.concat(_props);
    } while (obj2 = Object.getPrototypeOf(obj2));
    return props.sort().filter(function(e2, i2, arr) {
      if (e2 != arr[i2 + 1] && typeof toCheck[e2] == "function")
        return true;
    });
  }
  const scriptRel = "modulepreload";
  const seen = {};
  const base = "/";
  const __vitePreload = function preload(baseModule, deps) {
    if (true) {
      return baseModule();
    }
    return Promise.all(deps.map((dep) => {
      dep = `${base}${dep}`;
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link2 = document.createElement("link");
      link2.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link2.as = "script";
        link2.crossOrigin = "";
      }
      link2.href = dep;
      document.head.appendChild(link2);
      if (isCss) {
        return new Promise((res, rej) => {
          link2.addEventListener("load", res);
          link2.addEventListener("error", rej);
        });
      }
    })).then(() => baseModule());
  };
  var concatMap$1 = function(xs2, fn2) {
    var res = [];
    for (var i2 = 0; i2 < xs2.length; i2++) {
      var x2 = fn2(xs2[i2], i2);
      if (isArray(x2))
        res.push.apply(res, x2);
      else
        res.push(x2);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs2) {
    return Object.prototype.toString.call(xs2) === "[object Array]";
  };
  var balancedMatch = balanced$1;
  function balanced$1(a2, b2, str) {
    if (a2 instanceof RegExp)
      a2 = maybeMatch(a2, str);
    if (b2 instanceof RegExp)
      b2 = maybeMatch(b2, str);
    var r2 = range(a2, b2, str);
    return r2 && {
      start: r2[0],
      end: r2[1],
      pre: str.slice(0, r2[0]),
      body: str.slice(r2[0] + a2.length, r2[1]),
      post: str.slice(r2[1] + b2.length)
    };
  }
  function maybeMatch(reg, str) {
    var m2 = str.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced$1.range = range;
  function range(a2, b2, str) {
    var begs, beg, left, right, result2;
    var ai2 = str.indexOf(a2);
    var bi2 = str.indexOf(b2, ai2 + 1);
    var i2 = ai2;
    if (ai2 >= 0 && bi2 > 0) {
      if (a2 === b2) {
        return [ai2, bi2];
      }
      begs = [];
      left = str.length;
      while (i2 >= 0 && !result2) {
        if (i2 == ai2) {
          begs.push(i2);
          ai2 = str.indexOf(a2, i2 + 1);
        } else if (begs.length == 1) {
          result2 = [begs.pop(), bi2];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi2;
          }
          bi2 = str.indexOf(b2, i2 + 1);
        }
        i2 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
      }
      if (begs.length) {
        result2 = [left, right];
      }
    }
    return result2;
  }
  var concatMap = concatMap$1;
  var balanced = balancedMatch;
  var braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p2 = pre.split(",");
    p2[p2.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p2[p2.length - 1] += postParts.shift();
      p2.push.apply(p2, postParts);
    }
    parts.push.apply(parts, p2);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand$1(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el2) {
    return /^-?0\d/.test(el2);
  }
  function lte(i2, y2) {
    return i2 <= y2;
  }
  function gte(i2, y2) {
    return i2 >= y2;
  }
  function expand$1(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2 || /\$$/.test(m2.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,.*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand$1(str);
      }
      return [str];
    }
    var n2;
    if (isSequence) {
      n2 = m2.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m2.body);
      if (n2.length === 1) {
        n2 = expand$1(n2[0], false).map(embrace);
        if (n2.length === 1) {
          var post = m2.post.length ? expand$1(m2.post, false) : [""];
          return post.map(function(p2) {
            return m2.pre + n2[0] + p2;
          });
        }
      }
    }
    var pre = m2.pre;
    var post = m2.post.length ? expand$1(m2.post, false) : [""];
    var N2;
    if (isSequence) {
      var x2 = numeric(n2[0]);
      var y2 = numeric(n2[1]);
      var width = Math.max(n2[0].length, n2[1].length);
      var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
      var test = lte;
      var reverse = y2 < x2;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n2.some(isPadded);
      N2 = [];
      for (var i2 = x2; test(i2, y2); i2 += incr) {
        var c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i2);
          if (c2 === "\\")
            c2 = "";
        } else {
          c2 = String(i2);
          if (pad) {
            var need = width - c2.length;
            if (need > 0) {
              var z2 = new Array(need + 1).join("0");
              if (i2 < 0)
                c2 = "-" + z2 + c2.slice(1);
              else
                c2 = z2 + c2;
            }
          }
        }
        N2.push(c2);
      }
    } else {
      N2 = concatMap(n2, function(el2) {
        return expand$1(el2, false);
      });
    }
    for (var j2 = 0; j2 < N2.length; j2++) {
      for (var k2 = 0; k2 < post.length; k2++) {
        var expansion = pre + N2[j2] + post[k2];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  var minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path = { sep: "/" };
  try {
    path = require("path");
  } catch (er2) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = braceExpansion;
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s2) {
    return s2.split("").reduce(function(set, c2) {
      set[c2] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p2, i2, list) {
      return minimatch(p2, pattern, options);
    };
  }
  function ext(a2, b2) {
    a2 = a2 || {};
    b2 = b2 || {};
    var t2 = {};
    Object.keys(b2).forEach(function(k2) {
      t2[k2] = b2[k2];
    });
    Object.keys(a2).forEach(function(k2) {
      t2[k2] = a2[k2];
    });
    return t2;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m2 = function minimatch2(p2, pattern, options) {
      return orig.minimatch(p2, pattern, ext(def, options));
    };
    m2.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m2;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p2, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p2 === "";
    return new Minimatch(pattern, options).match(p2);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path.sep !== "/") {
      pattern = pattern.split(path.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s2) {
      return s2.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s2, si2, set2) {
      return s2.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s2) {
      return s2.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i2 = 0, l2 = pattern.length; i2 < l2 && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re2 = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re2 += star;
            hasMagic = true;
            break;
          case "?":
            re2 += qmark;
            hasMagic = true;
            break;
          default:
            re2 += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re2);
        stateChar = false;
      }
    }
    for (var i2 = 0, len = pattern.length, c2; i2 < len && (c2 = pattern.charAt(i2)); i2++) {
      this.debug("%s	%s %s %j", pattern, i2, re2, c2);
      if (escaping && reSpecials[c2]) {
        re2 += "\\" + c2;
        escaping = false;
        continue;
      }
      switch (c2) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re2, c2);
          if (inClass) {
            this.debug("  in class");
            if (c2 === "!" && i2 === classStart + 1)
              c2 = "^";
            re2 += c2;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c2;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re2 += "(";
            continue;
          }
          if (!stateChar) {
            re2 += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i2 - 1,
            reStart: re2.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re2);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re2 += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl2 = patternListStack.pop();
          re2 += pl2.close;
          if (pl2.type === "!") {
            negativeLists.push(pl2);
          }
          pl2.reEnd = re2.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re2 += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re2 += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re2 += "\\" + c2;
            continue;
          }
          inClass = true;
          classStart = i2;
          reClassStart = re2.length;
          re2 += c2;
          continue;
        case "]":
          if (i2 === classStart + 1 || !inClass) {
            re2 += "\\" + c2;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs2 = pattern.substring(classStart + 1, i2);
            try {
              RegExp("[" + cs2 + "]");
            } catch (er2) {
              var sp2 = this.parse(cs2, SUBPARSE);
              re2 = re2.substr(0, reClassStart) + "\\[" + sp2[0] + "\\]";
              hasMagic = hasMagic || sp2[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re2 += c2;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
            re2 += "\\";
          }
          re2 += c2;
      }
    }
    if (inClass) {
      cs2 = pattern.substr(classStart + 1);
      sp2 = this.parse(cs2, SUBPARSE);
      re2 = re2.substr(0, reClassStart) + "\\[" + sp2[0];
      hasMagic = hasMagic || sp2[1];
    }
    for (pl2 = patternListStack.pop(); pl2; pl2 = patternListStack.pop()) {
      var tail = re2.slice(pl2.reStart + pl2.open.length);
      this.debug("setting tail", re2, pl2);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl2, re2);
      var t2 = pl2.type === "*" ? star : pl2.type === "?" ? qmark : "\\" + pl2.type;
      hasMagic = true;
      re2 = re2.slice(0, pl2.reStart) + t2 + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re2 += "\\\\";
    }
    var addPatternStart = false;
    switch (re2.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n2 = negativeLists.length - 1; n2 > -1; n2--) {
      var nl2 = negativeLists[n2];
      var nlBefore = re2.slice(0, nl2.reStart);
      var nlFirst = re2.slice(nl2.reStart, nl2.reEnd - 8);
      var nlLast = re2.slice(nl2.reEnd - 8, nl2.reEnd);
      var nlAfter = re2.slice(nl2.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i2 = 0; i2 < openParensBefore; i2++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re2 = newRe;
    }
    if (re2 !== "" && hasMagic) {
      re2 = "(?=.)" + re2;
    }
    if (addPatternStart) {
      re2 = patternStart + re2;
    }
    if (isSub === SUBPARSE) {
      return [re2, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re2 + "$", flags);
    } catch (er2) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re2;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re2 = set.map(function(pattern) {
      return pattern.map(function(p2) {
        return p2 === GLOBSTAR ? twoStar : typeof p2 === "string" ? regExpEscape(p2) : p2._src;
      }).join("\\/");
    }).join("|");
    re2 = "^(?:" + re2 + ")$";
    if (this.negate)
      re2 = "^(?!" + re2 + ").*$";
    try {
      this.regexp = new RegExp(re2, flags);
    } catch (ex2) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm2 = new Minimatch(pattern, options);
    list = list.filter(function(f2) {
      return mm2.match(f2);
    });
    if (mm2.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f2, partial) {
    this.debug("match", f2, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f2 === "";
    if (f2 === "/" && partial)
      return true;
    var options = this.options;
    if (path.sep !== "/") {
      f2 = f2.split(path.sep).join("/");
    }
    f2 = f2.split(slashSplit);
    this.debug(this.pattern, "split", f2);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i2;
    for (i2 = f2.length - 1; i2 >= 0; i2--) {
      filename = f2[i2];
      if (filename)
        break;
    }
    for (i2 = 0; i2 < set.length; i2++) {
      var pattern = set[i2];
      var file = f2;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", { "this": this, file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi2 = 0, pi2 = 0, fl2 = file.length, pl2 = pattern.length; fi2 < fl2 && pi2 < pl2; fi2++, pi2++) {
      this.debug("matchOne loop");
      var p2 = pattern[pi2];
      var f2 = file[fi2];
      this.debug(pattern, p2, f2);
      if (p2 === false)
        return false;
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p2, f2]);
        var fr2 = fi2;
        var pr2 = pi2 + 1;
        if (pr2 === pl2) {
          this.debug("** at the end");
          for (; fi2 < fl2; fi2++) {
            if (file[fi2] === "." || file[fi2] === ".." || !options.dot && file[fi2].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr2 < fl2) {
          var swallowee = file[fr2];
          this.debug("\nglobstar while", file, fr2, pattern, pr2, swallowee);
          if (this.matchOne(file.slice(fr2), pattern.slice(pr2), partial)) {
            this.debug("globstar found match!", fr2, fl2, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr2, pattern, pr2);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr2++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr2, pattern, pr2);
          if (fr2 === fl2)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p2 === "string") {
        if (options.nocase) {
          hit = f2.toLowerCase() === p2.toLowerCase();
        } else {
          hit = f2 === p2;
        }
        this.debug("string match", p2, f2, hit);
      } else {
        hit = f2.match(p2);
        this.debug("pattern match", p2, f2, hit);
      }
      if (!hit)
        return false;
    }
    if (fi2 === fl2 && pi2 === pl2) {
      return true;
    } else if (fi2 === fl2) {
      return partial;
    } else if (pi2 === pl2) {
      var emptyFileEnd = fi2 === fl2 - 1 && file[fi2] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s2) {
    return s2.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s2) {
    return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  var ansiRegex$1 = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
  const ansiRegex = ansiRegex$1;
  var stripAnsi$1 = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
  function stripAnsi(string2) {
    return stripAnsi$1(string2);
  }
  function isTestEnv() {
    var _a2;
    return ((_a2 = process === null || process === void 0 ? void 0 : process.env) === null || _a2 === void 0 ? void 0 : _a2.NODE_ENV) === "test";
  }
  function isChildProcess() {
    if (isTestEnv())
      return false;
    return process.send !== void 0 || {}.IS_CHILD_PROCESS !== void 0;
  }
  class SLog {
    constructor(logObj) {
      var _a2;
      if (!(logObj === null || logObj === void 0 ? void 0 : logObj.value) && !logObj._logObj) {
        throw new Error(`<red>[${this.constructor.name}]</red> Sorry but you cannot instanciate a new SLog without a "<yellow>value</yellow>" property...`);
      }
      this._logObj = __deepMerge$1({
        type: SLog.TYPE_LOG,
        timestamp: Date.now(),
        decorators: true,
        time: false
      }, this.constructor._defaultLogObj, (_a2 = logObj._logObj) !== null && _a2 !== void 0 ? _a2 : logObj);
    }
    static filter(types) {
      this._filteredTypes = types;
    }
    static clearFilters() {
      this._filteredTypes = [];
    }
    static setDefaultLogObj(logObj) {
      this._defaultLogObj = logObj;
    }
    static isTypeEnabled(types) {
      if (!Array.isArray(types))
        types = [types];
      for (const type of types) {
        if (!this._filteredTypes.includes(type))
          return false;
      }
      return true;
    }
    get value() {
      return this._logObj.value;
    }
    set value(value) {
      this._logObj.value = value;
    }
    get type() {
      return this._logObj.type;
    }
    get active() {
      if (!this._logObj.type)
        return true;
      if (!this.constructor._filteredTypes.includes(this._logObj.type))
        return false;
      return true;
    }
    get decorators() {
      return this._logObj.decorators;
    }
    set decorators(value) {
      this._logObj.decorators = value;
    }
    get time() {
      return this._logObj.time;
    }
    get timestamp() {
      return this._logObj.timestamp;
    }
    get clear() {
      return this._logObj.clear;
    }
    get margin() {
      var _a2;
      return (_a2 = this._logObj.margin) !== null && _a2 !== void 0 ? _a2 : {
        top: 0,
        bottom: 0
      };
    }
    get temp() {
      return this._logObj.temp;
    }
    get as() {
      return this._logObj.as;
    }
  }
  SLog.TYPE_LOG = "log";
  SLog.TYPE_INFO = "info";
  SLog.TYPE_WARN = "warn";
  SLog.TYPE_ERROR = "error";
  SLog.TYPE_VERBOSE = "verbose";
  SLog.TYPE_VERBOSER = "verboser";
  SLog.TYPE_DECORATOR = "decorator";
  SLog.TYPE_SUMMARY = "summary";
  SLog.TYPE_CHILD_PROCESS = "child_process";
  SLog.TYPES = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_VERBOSE, SLog.TYPE_VERBOSER, SLog.TYPE_SUMMARY, SLog.TYPE_DECORATOR, SLog.TYPE_CHILD_PROCESS];
  SLog.PRESET_SILENT = [];
  SLog.PRESET_DEFAULT = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_SUMMARY, SLog.TYPE_DECORATOR, SLog.TYPE_CHILD_PROCESS];
  SLog.PRESET_WARN = [SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_CHILD_PROCESS];
  SLog.PRESET_ERROR = [SLog.TYPE_ERROR, SLog.TYPE_CHILD_PROCESS];
  SLog.PRESET_VERBOSE = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_VERBOSE, SLog.TYPE_DECORATOR, SLog.TYPE_SUMMARY, SLog.TYPE_CHILD_PROCESS];
  SLog.PRESET_VERBOSER = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_VERBOSE, SLog.TYPE_VERBOSER, SLog.TYPE_DECORATOR, SLog.TYPE_SUMMARY, SLog.TYPE_CHILD_PROCESS];
  SLog.PRESETS = ["silent", "default", "warn", "error", "verbose", "verboser"];
  SLog._filteredTypes = [];
  SLog._defaultLogObj = {};
  var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let _ipcInstance;
  if (__isNode()) {
    (() => __awaiter$5(void 0, void 0, void 0, function* () {
      const { default: __nodeIpc } = yield __vitePreload(() => Promise.resolve().then(function() {
        return nodeIpc;
      }), false ? "__VITE_PRELOAD__" : void 0);
      _ipcInstance = new __nodeIpc.IPC();
      _ipcInstance.config.id = `ipc-${process.pid}`;
      _ipcInstance.config.retry = 1500;
      _ipcInstance.config.silent = true;
      if (isChildProcess()) {
        _ipcInstance.connectTo(`ipc-${process.ppid}`, () => {
          _ipcInstance.of[`ipc-${process.ppid}`].on("connect", () => {
          });
          _ipcInstance.of[`ipc-${process.ppid}`].on("answer", (data) => {
            _ipcInstance.log(data);
            SEventEmitter.global.emit(`answer.${data.metas.askId}`, data.value, data.metas);
          });
        });
      }
    }))();
  }
  class SEventEmitter extends SClass {
    constructor(settings = {}) {
      super(__deepMerge$1({
        eventEmitter: {
          emitter: void 0,
          asyncStart: false,
          defaultCallTime: {},
          bufferTimeout: 1e3,
          bufferedEvents: [],
          forceObject: ["log", "ask"],
          defaults: {},
          castByEvent: {
            log: SLog
          },
          bind: void 0
        }
      }, settings || {}));
      this._asyncStarted = false;
      this._buffer = [];
      this._eventsStacks = {};
      this._onStackById = {};
    }
    static get global() {
      if (!this._globalInstance) {
        this._globalInstance = new SEventEmitter({
          metas: {
            id: "sugarEventSPromise"
          }
        });
      }
      return this._globalInstance;
    }
    static ipcServer(ipcSettings, eventEmitterSettings) {
      if (this._ipcPromise)
        return this._ipcPromise;
      this._ipcPromise = new Promise((resolve, reject) => __awaiter$5(this, void 0, void 0, function* () {
        var _a2;
        const eventEmitter = new this({
          eventEmitter: eventEmitterSettings !== null && eventEmitterSettings !== void 0 ? eventEmitterSettings : {}
        });
        const { default: __nodeIpc } = yield __vitePreload(() => Promise.resolve().then(function() {
          return nodeIpc;
        }), false ? "__VITE_PRELOAD__" : void 0);
        const ipcInstance = new __nodeIpc.IPC();
        ipcInstance.config = __deepMerge$1((_a2 = ipcInstance.config) !== null && _a2 !== void 0 ? _a2 : {}, {
          id: `ipc-${process.pid}`,
          retry: 1500,
          silent: true
        }, ipcSettings !== null && ipcSettings !== void 0 ? ipcSettings : {});
        ipcInstance.serve(() => {
          ipcInstance.server.on("message", (data, socket) => __awaiter$5(this, void 0, void 0, function* () {
            if (data.metas.event === "ask", data.metas) {
              const res = yield eventEmitter.emit(data.metas.event, data.value, data.metas);
              ipcInstance.server.emit(socket, `answer`, {
                value: res,
                metas: data.metas
              });
            } else {
              eventEmitter.emit(data.metas.event, data.value, data.metas);
            }
          }));
          resolve(eventEmitter);
        });
        ipcInstance.server.start();
      }));
      return this._ipcPromise;
    }
    static pipe(sourceSEventEmitter, destSEventEmitter, settings) {
      const set = Object.assign({ events: "*", prefixEvent: false, prefixValue: void 0, stripAnsi: false, trim: true, keepLineBreak: true, overrideEmitter: "bind", processor: void 0, exclude: ["finally", "resolve", "reject", "cancel", "catch"], filter: void 0 }, settings !== null && settings !== void 0 ? settings : {});
      if (!sourceSEventEmitter || !sourceSEventEmitter.on || typeof sourceSEventEmitter.on !== "function")
        return sourceSEventEmitter;
      sourceSEventEmitter.on(set.events || "*", (value, metas) => __awaiter$5(this, void 0, void 0, function* () {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
        if (!metas) {
          return;
        }
        metas.id = (_c2 = (_a2 = metas.id) !== null && _a2 !== void 0 ? _a2 : (_b2 = metas.emitter.metas) === null || _b2 === void 0 ? void 0 : _b2.id) !== null && _c2 !== void 0 ? _c2 : uniqid();
        metas.color = (_f2 = (_d2 = metas.color) !== null && _d2 !== void 0 ? _d2 : (_e2 = metas.emitter.metas) === null || _e2 === void 0 ? void 0 : _e2.color) !== null && _f2 !== void 0 ? _f2 : getColorFor(metas.id);
        if (set.exclude && set.exclude.indexOf(metas.event) !== -1)
          return;
        if (set.filter && !set.filter(value, metas))
          return;
        if (set.stripAnsi) {
          if (value && value.value && typeof value.value === "string")
            value.value = stripAnsi(value.value);
          else if (typeof value === "string")
            value = stripAnsi(value);
        }
        if (set.trim) {
          if (value && value.value && typeof value.value === "string")
            value.value = value.value.trim();
          else if (typeof value === "string")
            value = value.trim();
        }
        if (set.keepLineBreak === false) {
          if (value && value.value && typeof value.value === "string")
            value.value = value.value.replace(/\r?\n|\r/g, "");
          else if (typeof value === "string")
            value = value.replace(/\r?\n|\r/g, "");
        }
        if (set.processor) {
          const res = set.processor(value, metas);
          if (Array.isArray(res) && res.length === 2) {
            value = res[0];
            metas = res[1];
          } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
            value = res.value;
            metas = res.metas;
          } else {
            value = res;
          }
        }
        if (set.prefixValue) {
          if (value && value.value && typeof value.value === "string") {
            value.value = `${set.prefixValue}${value.value}`;
          } else if (typeof value === "string") {
            value = `${set.prefixValue}${value}`;
          }
        }
        if (metas && metas.event) {
          let emitStack = metas.event;
          if (!metas.emitter) {
            metas.emitter = this;
          }
          if (set.prefixEvent) {
            if (typeof set.prefixEvent === "string") {
              emitStack = `${set.prefixEvent}.${metas.event}`;
            } else {
              emitStack = `${metas.name}`;
            }
            metas.event = emitStack;
          }
          const emitMetas = Object.assign(Object.assign({}, metas), { level: ((_g2 = metas === null || metas === void 0 ? void 0 : metas.level) !== null && _g2 !== void 0 ? _g2 : 0) + 1 });
          if (destSEventEmitter instanceof SEventEmitter) {
            if (set.overrideEmitter === "bind" && destSEventEmitter.eventEmitterSettings.bind) {
              emitMetas.emitter = destSEventEmitter.eventEmitterSettings.bind;
            } else if (set.overrideEmitter === true) {
              emitMetas.emitter = destSEventEmitter;
            }
          }
          if (destSEventEmitter === process && isChildProcess()) {
            if (value.value && value.value instanceof Error) {
              value.value = fn$6(value.value);
            }
            _ipcInstance.of[`ipc-${process.ppid}`].emit("message", {
              value,
              metas: emitMetas
            });
          } else {
            destSEventEmitter.emit(metas.event, value, emitMetas);
          }
        }
      }));
    }
    get eventEmitterSettings() {
      return this._settings.eventEmitter;
    }
    pipe(input, settings) {
      SEventEmitter.pipe(input, this, settings);
      return input;
    }
    pipeErrors(input, settings) {
      SEventEmitter.pipe(input, this, Object.assign(Object.assign({}, settings), { events: "error" }));
      return input;
    }
    pipeFrom(input, settings) {
      return this.pipe(input, settings);
    }
    pipeTo(dest, settings) {
      SEventEmitter.pipe(this, dest, settings);
      return this;
    }
    start() {
      if (!this.eventEmitterSettings.asyncStart)
        return;
      this._asyncStarted = true;
      this._processBuffer();
    }
    _createMetas(event, metas = {}) {
      var _a2, _b2, _c2;
      return __deepMerge$1({
        event,
        name: event,
        emitter: (_b2 = (_a2 = this.eventEmitterSettings.bind) !== null && _a2 !== void 0 ? _a2 : metas === null || metas === void 0 ? void 0 : metas.emitter) !== null && _b2 !== void 0 ? _b2 : this,
        originalEmitter: (_c2 = metas === null || metas === void 0 ? void 0 : metas.originalEmitter) !== null && _c2 !== void 0 ? _c2 : this,
        time: Date.now(),
        level: 0
      }, metas !== null && metas !== void 0 ? metas : {});
    }
    emit(event, value, metas) {
      return new Promise((resolve, reject) => __awaiter$5(this, void 0, void 0, function* () {
        let metasObj = this._createMetas(event, metas);
        const isFirstLevel = !metasObj.level;
        if (plainObject$1(value)) {
          Object.keys(this.eventEmitterSettings.defaults).forEach((key) => {
            var _a2;
            const parts = key.split(",").map((l2) => l2.trim());
            if (parts.indexOf(event) === -1 && parts.indexOf("*") === -1)
              return;
            value = __deepMerge$1(value, (_a2 = this.eventEmitterSettings.defaults) === null || _a2 === void 0 ? void 0 : _a2[key]);
          });
        }
        const CastClass = this.eventEmitterSettings.castByEvent[event];
        if (CastClass && cls(CastClass) && !(value instanceof CastClass) && !value._sEventEmitterPreprocessed) {
          value = new CastClass(value);
        }
        if (event === "ask") {
          if (isFirstLevel) {
            metasObj.askId = uniqid();
          }
        }
        if (!this._asyncStarted && this.eventEmitterSettings.asyncStart) {
          this._buffer.push({
            event,
            value,
            metas: metasObj,
            resolve,
            reject
          });
          return;
        }
        this._emit({
          event,
          value,
          metas: metasObj,
          resolve,
          reject
        });
      }));
    }
    _emit(logObj) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (logObj.event === "ask") {
          this.constructor.global.on(`answer.${logObj.metas.askId}:1`, (answer, metas) => {
            logObj.resolve(answer);
          });
          this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
        } else {
          const res = yield this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
          logObj.resolve(res);
        }
      });
    }
    _registerNewEventsStacks(events) {
      if (typeof events === "string")
        events = events.split(",").map((s2) => s2.trim());
      events.forEach((event) => {
        if (!this._eventsStacks[event]) {
          this._eventsStacks[event] = {
            buffer: [],
            callStack: []
          };
        }
      });
    }
    _registerCallbackInEventStack(event, callback, settings = {}) {
      settings = Object.assign({ callNumber: void 0, filter: void 0, processor: void 0, id: void 0 }, settings);
      if (settings.id) {
        if (!this._onStackById[settings.id])
          this._onStackById[settings.id] = [];
        this._onStackById[settings.id].push({
          event,
          callback,
          settings
        });
      }
      if (!this._eventsStacks[event]) {
        this._registerNewEventsStacks(event);
      }
      const eventStackObj = this._eventsStacks[event];
      let callNumber = settings.callNumber;
      if (callNumber === void 0 && this.eventEmitterSettings.defaultCallTime[event] !== void 0) {
        callNumber = this.eventEmitterSettings.defaultCallTime[event];
      } else if (callNumber === void 0) {
        callNumber = -1;
      }
      if (typeof callback === "function")
        eventStackObj.callStack.push({
          callback,
          callNumber,
          filter: settings.filter,
          processor: settings.processor,
          called: 0
        });
      this._processBuffer();
      return this;
    }
    _processBuffer() {
      if (this._buffer.length > 0) {
        setTimeout(() => {
          this._buffer = this._buffer.filter((item) => {
            this._emit(item);
            return false;
          });
        }, this.eventEmitterSettings.bufferTimeout);
      }
    }
    _emitEventStack(event, initialValue, metasObj) {
      return __awaiter$5(this, void 0, void 0, function* () {
        let currentCallbackReturnedValue = initialValue;
        if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
          return currentCallbackReturnedValue;
        if (!this._eventsStacks[event]) {
          this._registerNewEventsStacks(event);
        }
        let eventStackArray = [];
        const eventStackObj = this._eventsStacks[event];
        if (eventStackObj && eventStackObj.callStack) {
          eventStackArray = [
            ...eventStackArray,
            ...eventStackObj.callStack
          ];
        }
        Object.keys(this._eventsStacks).forEach((stackName) => {
          if (stackName === event)
            return currentCallbackReturnedValue;
          if (minimatch_1(event, stackName) && this._eventsStacks[stackName] !== void 0) {
            eventStackArray = [
              ...eventStackArray,
              ...this._eventsStacks[stackName].callStack
            ];
          }
        });
        eventStackArray.map((item) => item.called++);
        eventStackArray = eventStackArray.filter((item) => {
          if (item.callNumber === -1)
            return true;
          if (item.called <= item.callNumber)
            return true;
          return false;
        });
        for (let i2 = 0; i2 < eventStackArray.length; i2++) {
          const item = eventStackArray[i2];
          if (!item.callback)
            return currentCallbackReturnedValue;
          if (item.filter && !item.filter(currentCallbackReturnedValue, metasObj))
            continue;
          if (item.processor) {
            const res = item.processor(currentCallbackReturnedValue, metasObj);
            if (Array.isArray(res) && res.length === 2) {
              currentCallbackReturnedValue = res[0];
              metasObj = res[1];
            } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
              currentCallbackReturnedValue = res.value;
              metasObj = res.metas;
            } else {
              currentCallbackReturnedValue = res;
            }
          }
          const callbackResult = yield item.callback(currentCallbackReturnedValue, metasObj, (metasObj === null || metasObj === void 0 ? void 0 : metasObj.askId) ? (answer) => {
            this.constructor.global.emit(`answer.${metasObj.askId}`, answer, metasObj);
          } : void 0);
          if (callbackResult !== void 0) {
            currentCallbackReturnedValue = callbackResult;
          }
        }
        return currentCallbackReturnedValue;
      });
    }
    _emitEvents(events, initialValue, metas) {
      return new Promise((resolve, reject) => __awaiter$5(this, void 0, void 0, function* () {
        if (!events)
          return this;
        if (typeof events === "string")
          events = events.split(",").map((s2) => s2.trim());
        let currentStackResult = initialValue;
        for (let i2 = 0; i2 < events.length; i2++) {
          const stackResult = yield this._emitEventStack(events[i2], currentStackResult, metas);
          if (stackResult !== void 0) {
            currentStackResult = stackResult;
          }
        }
        resolve(currentStackResult);
      }));
    }
    on(events, callback, settings) {
      const set = __deepMerge$1({
        filter: void 0,
        processor: void 0,
        id: void 0
      }, settings);
      if (typeof events === "string")
        events = events.split(",").map((s2) => s2.trim());
      events.forEach((name) => {
        const splitedName = name.split(":");
        let callNumber = -1;
        if (splitedName.length === 2) {
          name = splitedName[0];
          callNumber = parseInt(splitedName[1]);
        }
        this._registerCallbackInEventStack(name, callback, {
          callNumber,
          filter: set.filter,
          processor: set.processor,
          id: set.id
        });
      });
      return this;
    }
    off(event, callback) {
      if (!callback) {
        if (this._eventsStacks[event]) {
          delete this._eventsStacks[event];
        } else if (this._onStackById[event]) {
          this._onStackById[event].forEach((onStackByIdObj) => {
            this.off(onStackByIdObj.event, onStackByIdObj.callback);
          });
          delete this._onStackById[event];
        }
        return this;
      }
      const eventStackObj = this._eventsStacks[event];
      if (!eventStackObj)
        return this;
      eventStackObj.callStack = eventStackObj.callStack.filter((item) => {
        if (item.callback === callback)
          return false;
        return true;
      });
      this._eventsStacks[event] = eventStackObj;
      return this;
    }
    destroy() {
      this._eventsStacks = {};
    }
  }
  SEventEmitter.usableAsMixin = true;
  const fn$3 = function treatAsValue(promise, settings = {}) {
    settings = Object.assign({ during: -1 }, settings);
    let during = settings.during || -1;
    try {
      const proxy = Proxy.revocable(promise, {
        get(target, prop, receiver) {
          if (prop === "then") {
            return target;
          }
          if (during > 0)
            during--;
          else if (during === 0) {
            proxy.revoke();
          }
          return Reflect.get(...arguments);
        }
      });
      proxy.proxy.restorePromiseBehavior = () => {
        proxy.revoke();
        return promise;
      };
      return proxy.proxy;
    } catch (e2) {
      return promise;
    }
  };
  var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SPromise extends SClass.extends(Promise) {
    constructor(executorFnOrSettings = {}, settings) {
      let executorFn, resolvers = {};
      super(__deepMerge$1({
        promise: {
          treatCancelAs: "resolve",
          destroyTimeout: 1,
          preventRejectOnThrow: true,
          emitErrorEventOnThrow: true,
          resolveAtResolveEvent: false,
          rejectAtRejectEvent: false,
          proxies: {
            resolve: [],
            reject: []
          }
        }
      }, typeof executorFnOrSettings === "object" ? executorFnOrSettings : {}, settings !== null && settings !== void 0 ? settings : {}), (resolve, reject) => {
        resolvers.resolve = resolve;
        new Promise((rejectPromiseResolve, rejectPromiseReject) => {
          resolvers.reject = (...args) => {
            rejectPromiseReject(...args);
            if (this.promiseSettings.preventRejectOnThrow) {
              resolve(...args);
            } else {
              reject(...args);
            }
          };
        }).catch((e2) => {
          this.emit("catch", e2);
        });
      });
      this._promiseState = "pending";
      this._eventEmitter = new SEventEmitter(__deepMerge$1({
        metas: Object.assign({}, this.metas),
        eventEmitter: {}
      }, this._settings));
      this.expose(this._eventEmitter, {
        as: "eventEmitter",
        props: [
          "on",
          "off",
          "emit",
          "pipe",
          "pipeErrors",
          "pipeFrom",
          "pipeTo",
          "eventEmitterSettings"
        ]
      });
      this._resolvers = resolvers;
      if (this._settings.promise.destroyTimeout !== -1) {
        this.on("finally", (v2, m2) => {
          setTimeout(() => {
            this.destroy();
          }, this._settings.promise.destroyTimeout);
        });
      }
      executorFn = typeof executorFnOrSettings === "function" ? executorFnOrSettings : null;
      if (executorFn) {
        const api = {};
        getMethods(this).forEach((func) => {
          if (func.slice(0, 1) === "_")
            return;
          api[func] = this[func].bind(this);
        });
        (() => __awaiter$4(this, void 0, void 0, function* () {
          yield wait(0);
          try {
            yield executorFn(api);
          } catch (e2) {
            if (this.promiseSettings.emitErrorEventOnThrow) {
              this.emit("log", {
                type: SLog.TYPE_ERROR,
                value: e2
              });
            }
            this.reject(e2);
          }
        }))();
      }
      if (this.promiseSettings.resolveAtResolveEvent) {
        this.on("resolve", (data, metas) => {
          this.resolve(data);
        });
      }
      if (this.promiseSettings.rejectAtRejectEvent) {
        this.on("reject", (data, metas) => {
          this.reject(data);
        });
      }
    }
    static queue(promises, before, after) {
      return new SPromise(({ resolve, reject }) => __awaiter$4(this, void 0, void 0, function* () {
        const results = {};
        function next() {
          return __awaiter$4(this, void 0, void 0, function* () {
            const firstKey = Object.keys(promises)[0];
            let promise = promises[firstKey];
            if (typeof promise === "function")
              promise = promise();
            try {
              delete promises[firstKey];
              if (before)
                yield before(firstKey, promise);
              let res = yield promise;
              results[firstKey] = res;
              if (after) {
                let afterRes = yield after(firstKey, result);
                if (afterRes !== void 0)
                  result[firstKey] = afterRes;
              }
              if (Object.keys(promises).length) {
                next();
              } else {
                resolve(results);
              }
            } catch (e2) {
              reject(promise);
            }
          });
        }
        next();
      }));
    }
    static treatAsValue(promise, settings = {}) {
      return fn$3(promise, settings);
    }
    get promiseSettings() {
      return this._settings.promise;
    }
    static get [Symbol.species]() {
      return Promise;
    }
    get [Symbol.toStringTag]() {
      return "SPromise";
    }
    get promiseState() {
      return this._promiseState;
    }
    treatAsValue(settings = {}) {
      return fn$3(this, settings);
    }
    registerProxy(point, proxy) {
      const ar2 = point.split(",").map((l2) => l2.trim());
      ar2.forEach((a2) => {
        this._settings.promise.proxies[a2].push(proxy);
      });
    }
    is(status) {
      const statusArray = status.split(",").map((l2) => l2.trim());
      if (statusArray.indexOf(this._promiseState) !== -1)
        return true;
      return false;
    }
    isPending() {
      return this._promiseState === "pending";
    }
    isResolved() {
      return this._promiseState === "resolved";
    }
    isRejected() {
      return this._promiseState === "rejected";
    }
    isCanceled() {
      return this._promiseState === "canceled";
    }
    isDestroyed() {
      return this._promiseState === "destroyed";
    }
    resolve(arg, stacksOrder = "resolve,finally") {
      return this._resolve(arg, stacksOrder);
    }
    _resolve(arg, stacksOrder = "resolve,finally") {
      return __awaiter$4(this, void 0, void 0, function* () {
        if (this._promiseState === "destroyed")
          return;
        this._promiseState = "resolved";
        const stacksOrderArray = stacksOrder.split(",").map((l2) => l2.trim());
        for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
          const stack = stacksOrderArray[i2];
          arg = yield this.eventEmitter.emit(stack, arg);
        }
        for (const proxyFn of this._settings.promise.proxies.resolve || []) {
          arg = yield proxyFn(arg);
        }
        this._resolvers.resolve(arg);
        return arg;
      });
    }
    reject(arg, stacksOrder = `catch,reject,finally`) {
      return this._reject(arg, stacksOrder);
    }
    _reject(arg, stacksOrder = `catch,reject,finally`) {
      return __awaiter$4(this, void 0, void 0, function* () {
        if (this._promiseState === "destroyed")
          return;
        this._promiseState = "rejected";
        const stacksOrderArray = stacksOrder.split(",").map((l2) => l2.trim());
        for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
          const stack = stacksOrderArray[i2];
          arg = yield this.eventEmitter.emit(stack, arg);
        }
        for (const proxyFn of this._settings.promise.proxies.reject || []) {
          arg = yield proxyFn(arg);
        }
        this._resolvers.reject(arg);
        return arg;
      });
    }
    cancel(arg, stacksOrder = "cancel,finally") {
      return this._cancel(arg, stacksOrder);
    }
    _cancel(arg, stacksOrder = "cancel,finally") {
      if (this._promiseState === "destroyed")
        return;
      return new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
        this._promiseState = "canceled";
        const stacksOrderArray = stacksOrder.split(",").map((l2) => l2.trim());
        for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
          const stack = stacksOrderArray[i2];
          arg = yield this.eventEmitter.emit(stack, arg);
        }
        if (this._settings.promise.treatCancelAs === "reject") {
          this._resolvers.reject(arg);
        } else {
          this._resolvers.resolve(arg);
        }
        resolve(arg);
      }));
    }
    catch(...args) {
      super.catch(...args);
      return this.on("catch", ...args);
    }
    finally(...args) {
      return this.on("finally", ...args);
    }
    destroy() {
      this._eventEmitter.destroy();
      this._promiseState = "destroyed";
    }
  }
  function inViewportStatusChange($elm, settings) {
    let status = "out", observer, isInViewport = false;
    settings = Object.assign({ offset: "10px" }, settings !== null && settings !== void 0 ? settings : {});
    return new SPromise(({ emit: emit2 }) => {
      const _cb = () => {
        if (!isInViewport && status === "in") {
          status = "out";
          emit2("leave", $elm);
        } else if (isInViewport && status === "out") {
          status = "in";
          emit2("enter", $elm);
        }
      };
      observer = new IntersectionObserver((entries, observer2) => {
        if (!entries.length)
          return;
        const entry = entries[0];
        if (entry.intersectionRatio > 0) {
          isInViewport = true;
        } else {
          isInViewport = false;
        }
        _cb();
      }, {
        root: null,
        rootMargin: settings.offset,
        threshold: [
          0,
          0.1,
          0.2,
          0.3,
          0.4,
          0.5,
          0.6,
          0.7,
          0.8,
          0.9,
          1
        ]
      });
      observer.observe($elm);
    }, {
      id: "inViewportStatisChange"
    }).on("cancel", () => {
      var _a2;
      (_a2 = observer.disconnect) === null || _a2 === void 0 ? void 0 : _a2.call(observer);
    });
  }
  function formatDuration(duration) {
    if (duration === Infinity) {
      return "...";
    }
    if (duration < 1e3) {
      return `${duration}ms`;
    }
    if (duration < 1e3 * 60) {
      const s2 = (duration / 1e3).toFixed(0);
      const ms2 = (duration - s2 * 1e3).toFixed(0);
      return `${s2}.${ms2}s`;
    }
    if (duration < 1e3 * 60 * 60) {
      const m3 = Math.floor(duration / 1e3 / 60);
      const s2 = ((duration - m3 * 1e3 * 60) / 1e3).toFixed(0);
      return `${m3}m${s2 > 0 ? `${s2}s` : ""}`;
    }
    const h2 = Math.floor(duration / 1e3 / 60 / 60);
    const m2 = ((duration - h2 * 1e3 * 60 * 60) / 1e3 / 60).toFixed(0);
    return `${h2}h${m2 > 0 ? `${m2}m` : ""}`;
  }
  class SDuration {
    constructor(settings = {}) {
      this._settings = {};
      this.startTime = null;
      this.endTime = null;
      this.duration = null;
      this._settings = __deepMerge$1({}, settings);
      this.start();
    }
    toObject(settings = {}) {
      settings = __deepMerge$1(this._settings, settings);
      if (!this.endTime || !this.startTime)
        this.end();
      const durationMs = this.endTime - this.startTime;
      this.duration = durationMs;
      const formatedDuration = formatDuration(durationMs);
      return {
        startTime: this.startTime || -1,
        endTime: this.endTime || -1,
        duration: this.duration || -1,
        formatedDuration
      };
    }
    start(startTime = null) {
      this.startTime = startTime || Date.now();
      return this;
    }
    end(settings = {}) {
      settings = __deepMerge$1(this._settings, settings);
      this.endTime = Date.now();
      return this.toObject(settings);
    }
  }
  class SConductorSettingsInterface extends SInterface {
    static get _definition() {
      return {
        idleTimeout: {
          description: "Specify after how many milliseconds of inactity the SConductor has to be considered as idle ",
          type: "Number",
          default: 500
        },
        logTimeout: {
          description: "Specify after how many milliseconds of inactity the SConductor has to log the small analysis",
          type: "Number",
          default: 2e3
        },
        log: {
          description: "Specify if you want to log the small analysis when the SConductor is idle",
          type: "Boolean",
          default: false
        }
      };
    }
  }
  function whenDomReady(cb2 = null) {
    return new Promise((resolve, reject) => {
      if (document.readyState === "complete") {
        cb2 === null || cb2 === void 0 ? void 0 : cb2();
        resolve();
      } else {
        document.onreadystatechange = () => {
          if (document.readyState === "complete") {
            cb2 === null || cb2 === void 0 ? void 0 : cb2();
            resolve();
          }
        };
      }
    });
  }
  class WhenInteractSettingsInterface extends SInterface {
    static get _definition() {
      return {
        mouseover: {
          description: "Specify if the mouseover event has to be used",
          type: "Boolean",
          default: true
        },
        mouseout: {
          description: "Specify if the mouseout event has to be used",
          type: "Boolean",
          default: true
        },
        click: {
          description: "Specify if the click event has to be used",
          type: "Boolean",
          default: true
        },
        touchstart: {
          description: "Specify if the touchstart event has to be used",
          type: "Boolean",
          default: true
        },
        touchend: {
          description: "Specify if the touchend event has to be used",
          type: "Boolean",
          default: true
        },
        focus: {
          description: "Specify if the focus event has to be used",
          type: "Boolean",
          default: true
        }
      };
    }
  }
  function whenInteract(elm, settings) {
    return new Promise((resolve, reject) => {
      settings = WhenInteractSettingsInterface.apply(settings !== null && settings !== void 0 ? settings : {});
      function interacted(interaction) {
        resolve(interaction);
        elm.removeEventListener("mouseover", mouseover);
        elm.removeEventListener("mouseout", mouseout);
        elm.removeEventListener("click", click);
        elm.removeEventListener("touchstart", touchstart);
        elm.removeEventListener("touchend", touchend);
        elm.removeEventListener("focus", focus);
        elm.removeEventListener("focusin", focus);
      }
      function mouseover(e2) {
        interacted("mouseover");
      }
      if (settings.mouseover) {
        elm.addEventListener("mouseover", mouseover);
      }
      function mouseout(e2) {
        interacted("mouseout");
      }
      if (settings.mouseout) {
        elm.addEventListener("mouseout", mouseout);
      }
      function click(e2) {
        interacted("click");
      }
      if (settings.click) {
        elm.addEventListener("click", click);
      }
      function touchstart(e2) {
        interacted("touchstart");
      }
      if (settings.touchstart) {
        elm.addEventListener("touchstart", touchstart);
      }
      function touchend(e2) {
        interacted("touchend");
      }
      if (settings.touchend) {
        elm.addEventListener("touchend", touchend);
      }
      function focus(e2) {
        interacted("focus");
      }
      if (settings.focus === true) {
        elm.addEventListener("focus", focus);
        elm.addEventListener("focusin", focus);
      }
    });
  }
  function whenInViewport(elm, settings = {}) {
    settings = Object.assign({ offset: "10px" }, settings);
    return new Promise((resolve) => {
      const options = {
        root: null,
        rootMargin: settings.offset,
        threshold: 1
      };
      function onChange(changes, observer2) {
        changes.forEach((change) => {
          var _a2;
          if (change.intersectionRatio > 0) {
            (_a2 = observer2.disconnect) === null || _a2 === void 0 ? void 0 : _a2.call(observer2);
            resolve(elm);
          }
        });
      }
      const observer = new IntersectionObserver(onChange, options);
      observer.observe(elm);
    });
  }
  var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function whenNearViewport(elm, settings = {}) {
    settings = Object.assign({ offset: `${window.innerHeight}px ${window.innerWidth}px` }, settings);
    let observer, resizeTimeout;
    return new Promise((resolve) => __awaiter$3(this, void 0, void 0, function* () {
      const options = {
        root: null,
        rootMargin: settings.offset,
        threshold: 1
      };
      function onChange(changes, observer2) {
        changes.forEach((change) => {
          var _a2;
          if (change.intersectionRatio > 0) {
            (_a2 = observer2.disconnect) === null || _a2 === void 0 ? void 0 : _a2.call(observer2);
            resolve(elm);
          }
        });
      }
      observer = new IntersectionObserver(onChange, options);
      observer.observe(elm);
      window.addEventListener("resize", (e2) => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          var _a2;
          (_a2 = observer.disconnect) === null || _a2 === void 0 ? void 0 : _a2.call(observer);
          options.rootMargin = `${window.innerHeight}px ${window.innerWidth}px`;
          observer = new IntersectionObserver(onChange, options);
          observer.observe(elm);
        }, 500);
      });
    }));
  }
  function whenOutOfViewport(elm, settings = {}) {
    return new Promise((resolve, reject) => {
      settings = Object.assign({ offset: "10px" }, settings);
      let isInViewport = false;
      const _cb = () => {
        if (!isInViewport) {
          observer.disconnect();
          resolve(elm);
        }
      };
      const observer = new IntersectionObserver((entries, observer2) => {
        if (!entries.length)
          return;
        const entry = entries[0];
        if (entry.intersectionRatio > 0) {
          isInViewport = true;
        } else {
          isInViewport = false;
        }
        _cb();
      }, {
        root: null,
        rootMargin: settings.offset,
        threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
      });
      observer.observe(elm);
    });
  }
  function alreadyLoaded(link2) {
    const href = link2.href;
    let result2 = false;
    for (let i2 = 0; i2 < document.styleSheets.length; i2++) {
      if (document.styleSheets[i2].href && document.styleSheets[i2].href.match(href)) {
        result2 = true;
      } else if (i2 == document.styleSheets.length - 1)
        ;
    }
    return result2;
  }
  function linkLoaded(link2, cb2 = null) {
    return new Promise((resolve, reject) => {
      if (alreadyLoaded(link2)) {
        resolve(link2);
        cb2 != null && cb2(link2);
      } else {
        const img = document.createElement("img");
        img.addEventListener("error", (e2) => {
          resolve(link2);
          cb2 != null && cb2(link2);
        });
        img.src = link2.href;
      }
    });
  }
  function whenStylesheetsReady(links = null, cb2 = null) {
    if (!links) {
      links = Array.from(document.querySelectorAll('link[rel="stylesheet"]'));
    }
    const promises = [];
    [].forEach.call(neededStylesheetsStack, ($link) => {
      promises.push(linkLoaded($link));
    });
    const allPromises = Promise.all(promises);
    allPromises.then(() => {
      cb2 === null || cb2 === void 0 ? void 0 : cb2();
    });
    return allPromises;
  }
  var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SConductor extends SClass {
    constructor(settings) {
      super(__deepMerge$1({
        conductor: SConductorSettingsInterface.defaults()
      }, settings !== null && settings !== void 0 ? settings : {}));
      this._tasksStack = {};
      this._runningTasksStack = {};
      this._logTimeout = null;
      this._idleInterval = null;
      this._startTime = Date.now();
      this._idleInterval = setInterval(() => {
        this._checkIdle();
      }, this.conductorSettings.idleInterval);
    }
    static get defaultInstance() {
      if (this._defaultInstance)
        return this._defaultInstance;
      this._defaultInstance = new SConductor({
        conductor: this._defaultInstanceSettings
      });
      return this._defaultInstance;
    }
    static when(time, $elm, task) {
      return this.defaultInstance.when(time, $elm, task);
    }
    static setup(settings) {
      if (this._defaultInstance) {
        throw new Error(`Sorry but you need to call the "SConductor.setup" method before all other static methods like "when"`);
      }
      this._defaultInstanceSettings = settings;
    }
    get conductorSettings() {
      return this._settings.conductor;
    }
    _checkIdle() {
      if (Object.keys(this._runningTasksStack).length) {
        return;
      }
      let taskToExecute;
      for (let [taskId, taskObj] of Object.entries(this._tasksStack)) {
        if (taskObj.times.includes("idle")) {
          taskToExecute = taskObj;
          break;
        }
      }
      if (taskToExecute) {
        this._executeTask(taskToExecute);
      } else if (!this._logTimeout && this.conductorSettings.log) {
        this._logTimeout = setTimeout(() => {
          console.log(`[SConductor] The conductor "${this.metas.id}" has been executed tasks during ${formatDuration(Date.now() - this._startTime - this.conductorSettings.logTimeout)}`);
        }, this.conductorSettings.logTimeout);
      }
    }
    _executeTask(taskObj) {
      return __awaiter$2(this, void 0, void 0, function* () {
        this._runningTasksStack[taskObj.id] = taskObj;
        clearTimeout(this._logTimeout);
        taskObj.watchers.forEach((watcher) => {
          var _a2;
          (_a2 = watcher.cancel) === null || _a2 === void 0 ? void 0 : _a2.call(watcher);
        });
        const duration = new SDuration();
        yield taskObj.task();
        taskObj = Object.assign(Object.assign({ resolved: true }, taskObj), duration.end());
        delete this._tasksStack[taskObj.id];
        delete this._runningTasksStack[taskObj.id];
        taskObj.resolve(taskObj);
        clearInterval(this._idleInterval);
        setTimeout(() => {
          this._checkIdle();
          this._idleInterval = setInterval(() => {
            this._checkIdle();
          }, this.conductorSettings.idleTimeout);
        }, 100);
        return taskObj;
      });
    }
    _elementNeeded($elm = null, time) {
      if (!$elm) {
        throw new Error(`To use the "${time}" SConductor.when detector, you MUST pass an HTMLElement...`);
      }
    }
    when(time, $elm, task) {
      return new SPromise(({ resolve, reject }) => __awaiter$2(this, void 0, void 0, function* () {
        if (!Array.isArray(time))
          time = time.split(",").map((t2) => t2.trim());
        const taskObj = {
          id: uniqid(),
          registerTime: Date.now(),
          times: time,
          $elm,
          task,
          watchers: [],
          resolve
        };
        this._tasksStack[taskObj.id] = taskObj;
        time.forEach((t2) => {
          switch (t2) {
            case "inViewport":
              this._elementNeeded($elm, t2);
              taskObj.watchers.push(whenInViewport($elm));
              break;
            case "nearViewport":
              this._elementNeeded($elm, t2);
              taskObj.watchers.push(whenNearViewport($elm));
              break;
            case "outOfViewport":
              this._elementNeeded($elm, t2);
              taskObj.watchers.push(whenOutOfViewport($elm));
              break;
            case "interact":
              this._elementNeeded($elm, t2);
              taskObj.watchers.push(whenInteract($elm));
              break;
            case "domReady":
              taskObj.watchers.push(whenDomReady());
              break;
            case "stylesheetsReady":
              taskObj.watchers.push(whenStylesheetsReady($elm ? [$elm] : null));
              break;
            case "idle":
              taskObj.watchers.push((() => new SPromise(() => {
              }))());
              break;
          }
        });
        if (!time.length || time.includes("direct") || time.includes("directly")) {
          return this._executeTask(taskObj);
        }
        yield Promise.race(taskObj.watchers);
        this._executeTask(taskObj);
      }));
    }
  }
  SConductor._defaultInstanceSettings = {};
  class SComponentDefaultInterface extends SInterface {
    static get _definition() {
      return {
        id: {
          type: "String",
          physical: true
        },
        mounted: {
          type: "Boolean",
          default: false,
          physical: true
        },
        mountWhen: {
          type: "String",
          values: ["directly", "direct", "inViewport"],
          default: "direct"
        },
        adoptStyle: {
          type: "Boolean",
          default: true,
          physical: true
        },
        bare: {
          type: "Boolean",
          default: false,
          physical: true
        }
      };
    }
  }
  class SComponent extends SClass {
    constructor(node, props, settings = {}) {
      var _a2, _b2;
      var _c2;
      super(__deepMerge$1({
        componentUtils: {}
      }, settings));
      this.state = "pending";
      this._isInViewport = false;
      this.node = node;
      this._props = props;
      this.inViewportStatusChange.on("enter", () => {
        if (this.node.tagName.toLowerCase() === "ck-blob") {
          console.log("IN");
        }
        this._isInViewport = true;
      }).on("leave", () => {
        this._isInViewport = false;
      });
      let InterfaceToApply = (_c2 = class InlineSComponentUtilsInterface extends SInterface {
      }, _c2.definition = {}, _c2);
      InterfaceToApply.definition = Object.assign(Object.assign({}, Object.assign({}, SComponentDefaultInterface.definition)), (_b2 = (_a2 = this.componentUtilsSettings.interface) === null || _a2 === void 0 ? void 0 : _a2.definition) !== null && _b2 !== void 0 ? _b2 : {});
      this.InterfaceToApply = InterfaceToApply;
      const styleStr = this.componentUtilsSettings.style;
      this.injectStyle(styleStr !== null && styleStr !== void 0 ? styleStr : "");
    }
    get name() {
      var _a2;
      return (_a2 = this.componentUtilsSettings.name) !== null && _a2 !== void 0 ? _a2 : this.node.tagName.toLowerCase();
    }
    static setDefaultProps(selector, props) {
      selector = Array.isArray(selector) ? selector : [selector];
      selector.forEach((sel) => {
        var _a2;
        this._defaultProps[sel] = Object.assign(Object.assign({}, (_a2 = this._defaultProps[sel]) !== null && _a2 !== void 0 ? _a2 : {}), props);
      });
    }
    static getDefaultProps(selector) {
      var _a2;
      return (_a2 = this._defaultProps[selector]) !== null && _a2 !== void 0 ? _a2 : {};
    }
    get componentUtilsSettings() {
      return this._settings.componentUtils;
    }
    get inViewportStatusChange() {
      if (this._inViewportStatusChangePromise)
        return this._inViewportStatusChangePromise;
      this._inViewportStatusChangePromise = inViewportStatusChange(this.node);
      return this._inViewportStatusChangePromise;
    }
    waitAndExecute(callback) {
      return SConductor.when(this.props.mountWhen, this.node, callback);
    }
    adoptStyleInShadowRoot($shadowRoot, $context) {
      return adoptStyleInShadowRoot($shadowRoot, $context);
    }
    get props() {
      if (this._finalProps)
        return this._finalProps;
      const props = this._props;
      let passedProps = {};
      if (props.constructor.name === "NamedNodeMap") {
        Object.keys(props).forEach((key) => {
          var _a2, _b2, _c2;
          let value;
          if (((_a2 = props[key]) === null || _a2 === void 0 ? void 0 : _a2.nodeValue) !== void 0) {
            if (props[key].nodeValue === "")
              value = true;
            else
              value = props[key].nodeValue;
          }
          if (!value)
            return;
          passedProps[camelCase((_c2 = (_b2 = props[key]) === null || _b2 === void 0 ? void 0 : _b2.name) !== null && _c2 !== void 0 ? _c2 : key)] = autoCast(value);
        });
      } else {
        j;
        passedProps = props;
      }
      this._finalProps = __deepMerge$1(this.defaultProps, this.InterfaceToApply.apply(passedProps, {
        descriptor: {
          defaults: false
        }
      }));
      const _this = this;
      this._finalProps = new Proxy(this._finalProps, {
        get(target, prop, receiver) {
          return target[prop];
        },
        set(obj2, prop, value) {
          const propDef = _this.InterfaceToApply.definition[prop];
          if (propDef === null || propDef === void 0 ? void 0 : propDef.physical) {
            if (value === false || value === void 0 || value === null) {
              _this.node.removeAttribute(dashCase(prop));
            } else {
              _this.node.setAttribute(dashCase(prop), String(value));
            }
          }
          obj2[prop] = value;
          return true;
        }
      });
      Object.keys(this._finalProps).forEach((prop) => {
        this._finalProps[prop] = this._finalProps[prop];
      });
      return this._finalProps;
    }
    get defaultProps() {
      var _a2, _b2, _c2;
      if (this._defaultProps)
        return Object.assign({}, this._defaultProps);
      this._defaultProps = Object.assign({}, __deepMerge$1(this.InterfaceToApply.defaults(), (_a2 = this.componentUtilsSettings.defaultProps) !== null && _a2 !== void 0 ? _a2 : {}, (_b2 = this.constructor._defaultProps["*"]) !== null && _b2 !== void 0 ? _b2 : {}, (_c2 = this.constructor._defaultProps[this.name]) !== null && _c2 !== void 0 ? _c2 : {}));
      return this._defaultProps;
    }
    static getFinalInterface(int) {
      class InlineSComponentUtilsInterface extends SInterface {
      }
      InlineSComponentUtilsInterface.definition = SComponentDefaultInterface.definition;
      if (int) {
        InlineSComponentUtilsInterface.definition = Object.assign(Object.assign({}, SComponentDefaultInterface.definition), int.definition);
      }
      return InlineSComponentUtilsInterface;
    }
    injectStyle(css2, id2 = this.tagName) {
      if (this.constructor._injectedStyles.indexOf(id2) !== -1)
        return;
      this.constructor._injectedStyles.push(id2);
      injectStyle(css2, id2);
    }
    exposeApi(apiObj, ctx = this.node) {
      setTimeout(() => {
        let $on = this.node;
        Object.keys(apiObj).forEach((apiFnName) => {
          const apiFn = apiObj[apiFnName].bind(ctx);
          $on[apiFnName] = apiFn;
        });
      });
    }
    className(cls2 = "", style = "") {
      let clsString = cls2.split(" ").map((clsName) => `${this.node.tagName.toLowerCase()}${clsName && !clsName.match(/^__/) ? "-" : ""}${clsName}`).join(" ");
      if (style && !this.props.bare) {
        clsString += ` ${style}`;
      }
      return clsString;
    }
    isMounted() {
      var _a2;
      return (_a2 = this.node) === null || _a2 === void 0 ? void 0 : _a2.hasAttribute("mounted");
    }
    isInViewport() {
      return this._isInViewport;
    }
  }
  SComponent._defaultProps = {};
  SComponent._injectedStyles = [];
  var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SLitComponent extends LitElement {
    constructor(settings = {}) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      super();
      this._settings = {};
      this._shouldUpdate = false;
      this._settings = __deepMerge$1({
        componentUtils: {},
        litComponent: {
          shadowDom: true,
          get rootNode() {
            var _a3;
            return (_a3 = this.shadowRoot) === null || _a3 === void 0 ? void 0 : _a3.querySelector("*:first-child");
          }
        }
      }, settings);
      this.componentUtils = new SComponent(this, this.attributes, {
        componentUtils: Object.assign(Object.assign({}, (_a2 = this._settings.componentUtils) !== null && _a2 !== void 0 ? _a2 : {}), { style: (_e2 = (_c2 = (_b2 = this.constructor.styles) === null || _b2 === void 0 ? void 0 : _b2.cssText) !== null && _c2 !== void 0 ? _c2 : (_d2 = this._settings.componentUtils) === null || _d2 === void 0 ? void 0 : _d2.style) !== null && _e2 !== void 0 ? _e2 : "" })
      });
      this.props = this.componentUtils.props;
      if (this.litComponentSettings.shadowDom === false) {
        this.createRenderRoot = () => {
          return this;
        };
      }
      Object.keys(this.componentUtils.props).forEach((prop) => {
        this[prop] = this.componentUtils.props[prop];
      });
      const nodeFirstUpdated = (_f2 = this.firstUpdated) === null || _f2 === void 0 ? void 0 : _f2.bind(this);
      this.firstUpdated = () => __awaiter$1(this, void 0, void 0, function* () {
        if (nodeFirstUpdated) {
          yield nodeFirstUpdated();
        }
        this.mounted = true;
      });
      const nodeShouldUpdate = (_g2 = this.shouldUpdate) === null || _g2 === void 0 ? void 0 : _g2.bind(this);
      this.shouldUpdate = () => {
        if (nodeShouldUpdate) {
          const res = nodeShouldUpdate();
          if (!res)
            return false;
        }
        return this._shouldUpdate;
      };
      (() => __awaiter$1(this, void 0, void 0, function* () {
        yield this.componentUtils.waitAndExecute(this.mount.bind(this));
      }))();
    }
    static setDefaultProps(selector, props) {
      SComponent.setDefaultProps(selector, props);
    }
    get litComponentSettings() {
      return this._settings.litComponent;
    }
    static properties(properties2, int) {
      const propertiesObj = {};
      const InterfaceToApply = SComponent.getFinalInterface(int);
      Object.keys(InterfaceToApply.definition).forEach((prop) => {
        var _a2, _b2, _c2, _d2, _e2, _f2;
        const definition = InterfaceToApply.definition[prop];
        propertiesObj[prop] = Object.assign({}, (_a2 = definition.lit) !== null && _a2 !== void 0 ? _a2 : {});
        if (definition.physical || ((_c2 = (_b2 = definition.type) === null || _b2 === void 0 ? void 0 : _b2.toLowerCase) === null || _c2 === void 0 ? void 0 : _c2.call(_b2)) === "boolean" || ((_f2 = (_e2 = (_d2 = definition.type) === null || _d2 === void 0 ? void 0 : _d2.type) === null || _e2 === void 0 ? void 0 : _e2.toLowerCase) === null || _f2 === void 0 ? void 0 : _f2.call(_e2)) === "boolean") {
          propertiesObj[prop].reflect = true;
          propertiesObj[prop].attribute = dashCase(prop);
          propertiesObj[prop].converter = {
            toAttribute(value) {
              if (value === false || value === null)
                return null;
              return String(value);
            }
          };
        }
      });
      const props = Object.assign(Object.assign({}, propertiesObj), properties2 !== null && properties2 !== void 0 ? properties2 : {});
      return props;
    }
    mount() {
      var _a2, _b2;
      return __awaiter$1(this, void 0, void 0, function* () {
        this._shouldUpdate = true;
        this.requestUpdate();
        yield this.updateComplete;
        this.componentUtils.injectStyle((_b2 = (_a2 = this.constructor.styles) === null || _a2 === void 0 ? void 0 : _a2.cssText) !== null && _b2 !== void 0 ? _b2 : "", this.tagName);
        yield wait();
        if (this.componentUtils.props.adoptStyle && this.shadowRoot) {
          yield this.componentUtils.adoptStyleInShadowRoot(this.shadowRoot);
        }
        return true;
      });
    }
  }
  /*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var clipboardCopy_1 = clipboardCopy;
  function makeError() {
    return new DOMException("The request is not allowed", "NotAllowedError");
  }
  function copyClipboardApi(text) {
    return __async(this, null, function* () {
      if (!navigator.clipboard) {
        throw makeError();
      }
      return navigator.clipboard.writeText(text);
    });
  }
  function copyExecCommand(text) {
    return __async(this, null, function* () {
      const span = document.createElement("span");
      span.textContent = text;
      span.style.whiteSpace = "pre";
      span.style.webkitUserSelect = "auto";
      span.style.userSelect = "all";
      document.body.appendChild(span);
      const selection = window.getSelection();
      const range2 = window.document.createRange();
      selection.removeAllRanges();
      range2.selectNode(span);
      selection.addRange(range2);
      let success = false;
      try {
        success = window.document.execCommand("copy");
      } finally {
        selection.removeAllRanges();
        window.document.body.removeChild(span);
      }
      if (!success)
        throw makeError();
    });
  }
  function clipboardCopy(text) {
    return __async(this, null, function* () {
      try {
        yield copyClipboardApi(text);
      } catch (err) {
        try {
          yield copyExecCommand(text);
        } catch (err2) {
          throw err2 || err || makeError();
        }
      }
    });
  }
  const standardProperty$1 = (options, element) => {
    if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
      return __spreadProps(__spreadValues({}, element), {
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      });
    } else {
      return {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: element.key,
        initializer() {
          if (typeof element.initializer === "function") {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };
  const legacyProperty$1 = (options, proto2, name) => {
    proto2.constructor.createProperty(name, options);
  };
  function property$1(options) {
    return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty$1(options, protoOrDescriptor, name) : standardProperty$1(options, protoOrDescriptor);
  }
  class SHighlightJsComponentInterface extends SInterface {
    static get _definition() {
      return {
        successTimeout: {
          description: 'Specify the duration for displaying the "success" icon',
          type: "Number",
          default: 1500
        },
        errorTimeout: {
          description: 'Specify the duration for displaying the "error" icon',
          type: "Number",
          default: 3e3
        }
      };
    }
  }
  function copy(text) {
    return clipboardCopy_1(text);
  }
  function plainObject(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject(newObj[key]) && plainObject(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMergeObj = args[i2];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  var __css$1 = ".s-clipboard-copy {\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-clipboard-copy:not([mounted]) > * {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-clipboard-copy[state='pending'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='copy'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='success'] {\n        color: hsla(calc(var(--s-theme-color-success-h, 0) + var(--s-theme-color-success-spin ,0)),calc((var(--s-theme-color-success-s, 0)) * 1%),calc((var(--s-theme-color-success-l, 0)) * 1%),var(--s-theme-color-success-a, 1));\n    }\n\n    .s-clipboard-copy[state='success'] .icon-success {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='error'] {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0)) * 1%),var(--s-theme-color-error-a, 1));\n    }\n\n    .s-clipboard-copy[state='error'] .icon-error {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy svg {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: block;\n        width: 1em;\n        height: 1em;\n        background-size: contain;\n        opacity: 0;\n        pointer-events: none;\n    }\n";
  var __decorate$1 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  class SClipboardCopy extends SLitComponent {
    constructor() {
      super(__deepMerge({
        componentUtils: {
          interface: SHighlightJsComponentInterface
        }
      }));
      this._state = "pending";
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(__css$1)}
        `;
    }
    copy(text) {
      this._state = "copy";
      copy(text).then(() => {
        this._state = "success";
        setTimeout(() => {
          this._state = "pending";
        }, this.props.successTimeout);
      }).catch((e2) => {
        this._state = "error";
        setTimeout(() => {
          this._state = "pending";
        }, this.props.errorTimeout);
      });
    }
    render() {
      return html`
            <div
                class="${this.componentUtils.className("")}"
                state="${this._state}"
            >
                <svg
                    ref="svg"
                    class="icon-copy"
                    width="20"
                    height="20"
                    viewBox="0 0 20 20"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <g clip-path="url(#clip0)">
                        <path
                            d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z"
                            fill="currentColor"
                        />
                        <path
                            d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z"
                            fill="currentColor"
                        />
                        <path
                            d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z"
                            fill="currentColor"
                        />
                    </g>
                    <defs>
                        <clipPath id="clip0">
                            <rect width="20" height="20" fill="currentColor" />
                        </clipPath>
                    </defs>
                </svg>
                <svg
                    class="icon-success"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <svg
                    class="icon-error"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <polygon
                        points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"
                    ></polygon>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            </div>
        `;
    }
  }
  __decorate$1([
    property$1()
  ], SClipboardCopy.prototype, "_state", void 0);
  function define(props = {}, tagName = "s-clipboard-copy") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SClipboardCopy);
  }
  var deepFreezeEs6 = { exports: {} };
  function deepFreeze(obj2) {
    if (obj2 instanceof Map) {
      obj2.clear = obj2.delete = obj2.set = function() {
        throw new Error("map is read-only");
      };
    } else if (obj2 instanceof Set) {
      obj2.add = obj2.clear = obj2.delete = function() {
        throw new Error("set is read-only");
      };
    }
    Object.freeze(obj2);
    Object.getOwnPropertyNames(obj2).forEach(function(name) {
      var prop = obj2[name];
      if (typeof prop == "object" && !Object.isFrozen(prop)) {
        deepFreeze(prop);
      }
    });
    return obj2;
  }
  deepFreezeEs6.exports = deepFreeze;
  deepFreezeEs6.exports.default = deepFreeze;
  var deepFreeze$1 = deepFreezeEs6.exports;
  class Response {
    constructor(mode) {
      if (mode.data === void 0)
        mode.data = {};
      this.data = mode.data;
      this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  }
  function escapeHTML(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function inherit$1(original, ...objects) {
    const result2 = Object.create(null);
    for (const key in original) {
      result2[key] = original[key];
    }
    objects.forEach(function(obj2) {
      for (const key in obj2) {
        result2[key] = obj2[key];
      }
    });
    return result2;
  }
  const SPAN_CLOSE = "</span>";
  const emitsWrappingTags = (node) => {
    return !!node.kind;
  };
  const expandScopeName = (name, { prefix }) => {
    if (name.includes(".")) {
      const pieces = name.split(".");
      return [
        `${prefix}${pieces.shift()}`,
        ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
      ].join(" ");
    }
    return `${prefix}${name}`;
  };
  class HTMLRenderer {
    constructor(parseTree, options) {
      this.buffer = "";
      this.classPrefix = options.classPrefix;
      parseTree.walk(this);
    }
    addText(text) {
      this.buffer += escapeHTML(text);
    }
    openNode(node) {
      if (!emitsWrappingTags(node))
        return;
      let scope = node.kind;
      if (node.sublanguage) {
        scope = `language-${scope}`;
      } else {
        scope = expandScopeName(scope, { prefix: this.classPrefix });
      }
      this.span(scope);
    }
    closeNode(node) {
      if (!emitsWrappingTags(node))
        return;
      this.buffer += SPAN_CLOSE;
    }
    value() {
      return this.buffer;
    }
    span(className) {
      this.buffer += `<span class="${className}">`;
    }
  }
  class TokenTree {
    constructor() {
      this.rootNode = { children: [] };
      this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    add(node) {
      this.top.children.push(node);
    }
    openNode(kind) {
      const node = { kind, children: [] };
      this.add(node);
      this.stack.push(node);
    }
    closeNode() {
      if (this.stack.length > 1) {
        return this.stack.pop();
      }
      return void 0;
    }
    closeAllNodes() {
      while (this.closeNode())
        ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    walk(builder) {
      return this.constructor._walk(builder, this.rootNode);
    }
    static _walk(builder, node) {
      if (typeof node === "string") {
        builder.addText(node);
      } else if (node.children) {
        builder.openNode(node);
        node.children.forEach((child) => this._walk(builder, child));
        builder.closeNode(node);
      }
      return builder;
    }
    static _collapse(node) {
      if (typeof node === "string")
        return;
      if (!node.children)
        return;
      if (node.children.every((el2) => typeof el2 === "string")) {
        node.children = [node.children.join("")];
      } else {
        node.children.forEach((child) => {
          TokenTree._collapse(child);
        });
      }
    }
  }
  class TokenTreeEmitter extends TokenTree {
    constructor(options) {
      super();
      this.options = options;
    }
    addKeyword(text, kind) {
      if (text === "") {
        return;
      }
      this.openNode(kind);
      this.addText(text);
      this.closeNode();
    }
    addText(text) {
      if (text === "") {
        return;
      }
      this.add(text);
    }
    addSublanguage(emitter, name) {
      const node = emitter.root;
      node.kind = name;
      node.sublanguage = true;
      this.add(node);
    }
    toHTML() {
      const renderer = new HTMLRenderer(this, this.options);
      return renderer.value();
    }
    finalize() {
      return true;
    }
  }
  function source(re2) {
    if (!re2)
      return null;
    if (typeof re2 === "string")
      return re2;
    return re2.source;
  }
  function lookahead(re2) {
    return concat("(?=", re2, ")");
  }
  function anyNumberOfTimes(re2) {
    return concat("(?:", re2, ")*");
  }
  function optional(re2) {
    return concat("(?:", re2, ")?");
  }
  function concat(...args) {
    const joined = args.map((x2) => source(x2)).join("");
    return joined;
  }
  function stripOptionsFromArgs(args) {
    const opts = args[args.length - 1];
    if (typeof opts === "object" && opts.constructor === Object) {
      args.splice(args.length - 1, 1);
      return opts;
    } else {
      return {};
    }
  }
  function either(...args) {
    const opts = stripOptionsFromArgs(args);
    const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source(x2)).join("|") + ")";
    return joined;
  }
  function countMatchGroups(re2) {
    return new RegExp(re2.toString() + "|").exec("").length - 1;
  }
  function startsWith(re2, lexeme) {
    const match2 = re2 && re2.exec(lexeme);
    return match2 && match2.index === 0;
  }
  const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function _rewriteBackreferences(regexps, { joinWith }) {
    let numCaptures = 0;
    return regexps.map((regex) => {
      numCaptures += 1;
      const offset = numCaptures;
      let re2 = source(regex);
      let out = "";
      while (re2.length > 0) {
        const match2 = BACKREF_RE.exec(re2);
        if (!match2) {
          out += re2;
          break;
        }
        out += re2.substring(0, match2.index);
        re2 = re2.substring(match2.index + match2[0].length);
        if (match2[0][0] === "\\" && match2[1]) {
          out += "\\" + String(Number(match2[1]) + offset);
        } else {
          out += match2[0];
          if (match2[0] === "(") {
            numCaptures++;
          }
        }
      }
      return out;
    }).map((re2) => `(${re2})`).join(joinWith);
  }
  const MATCH_NOTHING_RE = /\b\B/;
  const IDENT_RE$1 = "[a-zA-Z]\\w*";
  const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
  const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
  const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
  const BINARY_NUMBER_RE = "\\b(0b[01]+)";
  const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
  const SHEBANG = (opts = {}) => {
    const beginShebang = /^#![ ]*\//;
    if (opts.binary) {
      opts.begin = concat(beginShebang, /.*\b/, opts.binary, /\b.*/);
    }
    return inherit$1({
      scope: "meta",
      begin: beginShebang,
      end: /$/,
      relevance: 0,
      "on:begin": (m2, resp) => {
        if (m2.index !== 0)
          resp.ignoreMatch();
      }
    }, opts);
  };
  const BACKSLASH_ESCAPE = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  };
  const APOS_STRING_MODE = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const QUOTE_STRING_MODE = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  const COMMENT = function(begin, end, modeOptions = {}) {
    const mode = inherit$1({
      scope: "comment",
      begin,
      end,
      contains: []
    }, modeOptions);
    mode.contains.push({
      scope: "doctag",
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: true,
      relevance: 0
    });
    const ENGLISH_WORD = either("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
    mode.contains.push({
      begin: concat(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}")
    });
    return mode;
  };
  const C_LINE_COMMENT_MODE = COMMENT("//", "$");
  const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
  const HASH_COMMENT_MODE = COMMENT("#", "$");
  const NUMBER_MODE = {
    scope: "number",
    begin: NUMBER_RE,
    relevance: 0
  };
  const C_NUMBER_MODE = {
    scope: "number",
    begin: C_NUMBER_RE,
    relevance: 0
  };
  const BINARY_NUMBER_MODE = {
    scope: "number",
    begin: BINARY_NUMBER_RE,
    relevance: 0
  };
  const REGEXP_MODE = {
    begin: /(?=\/[^/\n]*\/)/,
    contains: [{
      scope: "regexp",
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    }]
  };
  const TITLE_MODE = {
    scope: "title",
    begin: IDENT_RE$1,
    relevance: 0
  };
  const UNDERSCORE_TITLE_MODE = {
    scope: "title",
    begin: UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const METHOD_GUARD = {
    begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const END_SAME_AS_BEGIN = function(mode) {
    return Object.assign(mode, {
      "on:begin": (m2, resp) => {
        resp.data._beginMatch = m2[1];
      },
      "on:end": (m2, resp) => {
        if (resp.data._beginMatch !== m2[1])
          resp.ignoreMatch();
      }
    });
  };
  var MODES$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE,
    IDENT_RE: IDENT_RE$1,
    UNDERSCORE_IDENT_RE,
    NUMBER_RE,
    C_NUMBER_RE,
    BINARY_NUMBER_RE,
    RE_STARTERS_RE,
    SHEBANG,
    BACKSLASH_ESCAPE,
    APOS_STRING_MODE,
    QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE,
    COMMENT,
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE,
    NUMBER_MODE,
    C_NUMBER_MODE,
    BINARY_NUMBER_MODE,
    REGEXP_MODE,
    TITLE_MODE,
    UNDERSCORE_TITLE_MODE,
    METHOD_GUARD,
    END_SAME_AS_BEGIN
  });
  function skipIfHasPrecedingDot(match2, response) {
    const before = match2.input[match2.index - 1];
    if (before === ".") {
      response.ignoreMatch();
    }
  }
  function scopeClassName(mode, _parent) {
    if (mode.className !== void 0) {
      mode.scope = mode.className;
      delete mode.className;
    }
  }
  function beginKeywords(mode, parent) {
    if (!parent)
      return;
    if (!mode.beginKeywords)
      return;
    mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
    mode.__beforeBegin = skipIfHasPrecedingDot;
    mode.keywords = mode.keywords || mode.beginKeywords;
    delete mode.beginKeywords;
    if (mode.relevance === void 0)
      mode.relevance = 0;
  }
  function compileIllegal(mode, _parent) {
    if (!Array.isArray(mode.illegal))
      return;
    mode.illegal = either(...mode.illegal);
  }
  function compileMatch(mode, _parent) {
    if (!mode.match)
      return;
    if (mode.begin || mode.end)
      throw new Error("begin & end are not supported with match");
    mode.begin = mode.match;
    delete mode.match;
  }
  function compileRelevance(mode, _parent) {
    if (mode.relevance === void 0)
      mode.relevance = 1;
  }
  const beforeMatchExt = (mode, parent) => {
    if (!mode.beforeMatch)
      return;
    if (mode.starts)
      throw new Error("beforeMatch cannot be used with starts");
    const originalMode = Object.assign({}, mode);
    Object.keys(mode).forEach((key) => {
      delete mode[key];
    });
    mode.keywords = originalMode.keywords;
    mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
    mode.starts = {
      relevance: 0,
      contains: [
        Object.assign(originalMode, { endsParent: true })
      ]
    };
    mode.relevance = 0;
    delete originalMode.beforeMatch;
  };
  const COMMON_KEYWORDS = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    "list",
    "value"
  ];
  const DEFAULT_KEYWORD_SCOPE = "keyword";
  function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
    const compiledKeywords = Object.create(null);
    if (typeof rawKeywords === "string") {
      compileList(scopeName, rawKeywords.split(" "));
    } else if (Array.isArray(rawKeywords)) {
      compileList(scopeName, rawKeywords);
    } else {
      Object.keys(rawKeywords).forEach(function(scopeName2) {
        Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
      });
    }
    return compiledKeywords;
    function compileList(scopeName2, keywordList) {
      if (caseInsensitive) {
        keywordList = keywordList.map((x2) => x2.toLowerCase());
      }
      keywordList.forEach(function(keyword) {
        const pair = keyword.split("|");
        compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }
  function scoreForKeyword(keyword, providedScore) {
    if (providedScore) {
      return Number(providedScore);
    }
    return commonKeyword(keyword) ? 0 : 1;
  }
  function commonKeyword(keyword) {
    return COMMON_KEYWORDS.includes(keyword.toLowerCase());
  }
  const seenDeprecations = {};
  const error = (message) => {
    console.error(message);
  };
  const warn = (message, ...args) => {
    console.log(`WARN: ${message}`, ...args);
  };
  const deprecated = (version2, message) => {
    if (seenDeprecations[`${version2}/${message}`])
      return;
    console.log(`Deprecated as of ${version2}. ${message}`);
    seenDeprecations[`${version2}/${message}`] = true;
  };
  const MultiClassError = new Error();
  function remapScopeNames(mode, regexes, { key }) {
    let offset = 0;
    const scopeNames = mode[key];
    const emit2 = {};
    const positions = {};
    for (let i2 = 1; i2 <= regexes.length; i2++) {
      positions[i2 + offset] = scopeNames[i2];
      emit2[i2 + offset] = true;
      offset += countMatchGroups(regexes[i2 - 1]);
    }
    mode[key] = positions;
    mode[key]._emit = emit2;
    mode[key]._multi = true;
  }
  function beginMultiClass(mode) {
    if (!Array.isArray(mode.begin))
      return;
    if (mode.skip || mode.excludeBegin || mode.returnBegin) {
      error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
      error("beginScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.begin, { key: "beginScope" });
    mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
  }
  function endMultiClass(mode) {
    if (!Array.isArray(mode.end))
      return;
    if (mode.skip || mode.excludeEnd || mode.returnEnd) {
      error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.endScope !== "object" || mode.endScope === null) {
      error("endScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.end, { key: "endScope" });
    mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
  }
  function scopeSugar(mode) {
    if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
      mode.beginScope = mode.scope;
      delete mode.scope;
    }
  }
  function MultiClass(mode) {
    scopeSugar(mode);
    if (typeof mode.beginScope === "string") {
      mode.beginScope = { _wrap: mode.beginScope };
    }
    if (typeof mode.endScope === "string") {
      mode.endScope = { _wrap: mode.endScope };
    }
    beginMultiClass(mode);
    endMultiClass(mode);
  }
  function compileLanguage(language) {
    function langRe(value, global2) {
      return new RegExp(source(value), "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : ""));
    }
    class MultiRegex {
      constructor() {
        this.matchIndexes = {};
        this.regexes = [];
        this.matchAt = 1;
        this.position = 0;
      }
      addRule(re2, opts) {
        opts.position = this.position++;
        this.matchIndexes[this.matchAt] = opts;
        this.regexes.push([opts, re2]);
        this.matchAt += countMatchGroups(re2) + 1;
      }
      compile() {
        if (this.regexes.length === 0) {
          this.exec = () => null;
        }
        const terminators = this.regexes.map((el2) => el2[1]);
        this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
        this.lastIndex = 0;
      }
      exec(s2) {
        this.matcherRe.lastIndex = this.lastIndex;
        const match2 = this.matcherRe.exec(s2);
        if (!match2) {
          return null;
        }
        const i2 = match2.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
        const matchData = this.matchIndexes[i2];
        match2.splice(0, i2);
        return Object.assign(match2, matchData);
      }
    }
    class ResumableMultiRegex {
      constructor() {
        this.rules = [];
        this.multiRegexes = [];
        this.count = 0;
        this.lastIndex = 0;
        this.regexIndex = 0;
      }
      getMatcher(index) {
        if (this.multiRegexes[index])
          return this.multiRegexes[index];
        const matcher = new MultiRegex();
        this.rules.slice(index).forEach(([re2, opts]) => matcher.addRule(re2, opts));
        matcher.compile();
        this.multiRegexes[index] = matcher;
        return matcher;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      addRule(re2, opts) {
        this.rules.push([re2, opts]);
        if (opts.type === "begin")
          this.count++;
      }
      exec(s2) {
        const m2 = this.getMatcher(this.regexIndex);
        m2.lastIndex = this.lastIndex;
        let result2 = m2.exec(s2);
        if (this.resumingScanAtSamePosition()) {
          if (result2 && result2.index === this.lastIndex)
            ;
          else {
            const m22 = this.getMatcher(0);
            m22.lastIndex = this.lastIndex + 1;
            result2 = m22.exec(s2);
          }
        }
        if (result2) {
          this.regexIndex += result2.position + 1;
          if (this.regexIndex === this.count) {
            this.considerAll();
          }
        }
        return result2;
      }
    }
    function buildModeRegex(mode) {
      const mm2 = new ResumableMultiRegex();
      mode.contains.forEach((term) => mm2.addRule(term.begin, { rule: term, type: "begin" }));
      if (mode.terminatorEnd) {
        mm2.addRule(mode.terminatorEnd, { type: "end" });
      }
      if (mode.illegal) {
        mm2.addRule(mode.illegal, { type: "illegal" });
      }
      return mm2;
    }
    function compileMode(mode, parent) {
      const cmode = mode;
      if (mode.isCompiled)
        return cmode;
      [
        scopeClassName,
        compileMatch,
        MultiClass,
        beforeMatchExt
      ].forEach((ext2) => ext2(mode, parent));
      language.compilerExtensions.forEach((ext2) => ext2(mode, parent));
      mode.__beforeBegin = null;
      [
        beginKeywords,
        compileIllegal,
        compileRelevance
      ].forEach((ext2) => ext2(mode, parent));
      mode.isCompiled = true;
      let keywordPattern = null;
      if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
        mode.keywords = Object.assign({}, mode.keywords);
        keywordPattern = mode.keywords.$pattern;
        delete mode.keywords.$pattern;
      }
      keywordPattern = keywordPattern || /\w+/;
      if (mode.keywords) {
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
      }
      cmode.keywordPatternRe = langRe(keywordPattern, true);
      if (parent) {
        if (!mode.begin)
          mode.begin = /\B|\b/;
        cmode.beginRe = langRe(cmode.begin);
        if (!mode.end && !mode.endsWithParent)
          mode.end = /\B|\b/;
        if (mode.end)
          cmode.endRe = langRe(cmode.end);
        cmode.terminatorEnd = source(cmode.end) || "";
        if (mode.endsWithParent && parent.terminatorEnd) {
          cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
        }
      }
      if (mode.illegal)
        cmode.illegalRe = langRe(mode.illegal);
      if (!mode.contains)
        mode.contains = [];
      mode.contains = [].concat(...mode.contains.map(function(c2) {
        return expandOrCloneMode(c2 === "self" ? mode : c2);
      }));
      mode.contains.forEach(function(c2) {
        compileMode(c2, cmode);
      });
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }
      cmode.matcher = buildModeRegex(cmode);
      return cmode;
    }
    if (!language.compilerExtensions)
      language.compilerExtensions = [];
    if (language.contains && language.contains.includes("self")) {
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    }
    language.classNameAliases = inherit$1(language.classNameAliases || {});
    return compileMode(language);
  }
  function dependencyOnParent(mode) {
    if (!mode)
      return false;
    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }
  function expandOrCloneMode(mode) {
    if (mode.variants && !mode.cachedVariants) {
      mode.cachedVariants = mode.variants.map(function(variant) {
        return inherit$1(mode, { variants: null }, variant);
      });
    }
    if (mode.cachedVariants) {
      return mode.cachedVariants;
    }
    if (dependencyOnParent(mode)) {
      return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
    }
    if (Object.isFrozen(mode)) {
      return inherit$1(mode);
    }
    return mode;
  }
  var version = "11.3.1";
  class HTMLInjectionError extends Error {
    constructor(reason, html2) {
      super(reason);
      this.name = "HTMLInjectionError";
      this.html = html2;
    }
  }
  const escape$1 = escapeHTML;
  const inherit = inherit$1;
  const NO_MATCH = Symbol("nomatch");
  const MAX_KEYWORD_HITS = 7;
  const HLJS = function(hljs) {
    const languages = Object.create(null);
    const aliases = Object.create(null);
    const plugins = [];
    let SAFE_MODE = true;
    const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
    const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
    let options = {
      ignoreUnescapedHTML: false,
      throwUnescapedHTML: false,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      __emitter: TokenTreeEmitter
    };
    function shouldNotHighlight(languageName) {
      return options.noHighlightRe.test(languageName);
    }
    function blockLanguage(block) {
      let classes = block.className + " ";
      classes += block.parentNode ? block.parentNode.className : "";
      const match2 = options.languageDetectRe.exec(classes);
      if (match2) {
        const language = getLanguage(match2[1]);
        if (!language) {
          warn(LANGUAGE_NOT_FOUND.replace("{}", match2[1]));
          warn("Falling back to no-highlight mode for this block.", block);
        }
        return language ? match2[1] : "no-highlight";
      }
      return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
    }
    function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
      let code = "";
      let languageName = "";
      if (typeof optionsOrCode === "object") {
        code = codeOrLanguageName;
        ignoreIllegals = optionsOrCode.ignoreIllegals;
        languageName = optionsOrCode.language;
      } else {
        deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
        deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
        languageName = codeOrLanguageName;
        code = optionsOrCode;
      }
      if (ignoreIllegals === void 0) {
        ignoreIllegals = true;
      }
      const context = {
        code,
        language: languageName
      };
      fire("before:highlight", context);
      const result2 = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
      result2.code = context.code;
      fire("after:highlight", result2);
      return result2;
    }
    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
      const keywordHits = Object.create(null);
      function keywordData(mode, matchText) {
        return mode.keywords[matchText];
      }
      function processKeywords() {
        if (!top.keywords) {
          emitter.addText(modeBuffer);
          return;
        }
        let lastIndex = 0;
        top.keywordPatternRe.lastIndex = 0;
        let match2 = top.keywordPatternRe.exec(modeBuffer);
        let buf = "";
        while (match2) {
          buf += modeBuffer.substring(lastIndex, match2.index);
          const word = language.case_insensitive ? match2[0].toLowerCase() : match2[0];
          const data = keywordData(top, word);
          if (data) {
            const [kind, keywordRelevance] = data;
            emitter.addText(buf);
            buf = "";
            keywordHits[word] = (keywordHits[word] || 0) + 1;
            if (keywordHits[word] <= MAX_KEYWORD_HITS)
              relevance += keywordRelevance;
            if (kind.startsWith("_")) {
              buf += match2[0];
            } else {
              const cssClass = language.classNameAliases[kind] || kind;
              emitter.addKeyword(match2[0], cssClass);
            }
          } else {
            buf += match2[0];
          }
          lastIndex = top.keywordPatternRe.lastIndex;
          match2 = top.keywordPatternRe.exec(modeBuffer);
        }
        buf += modeBuffer.substr(lastIndex);
        emitter.addText(buf);
      }
      function processSubLanguage() {
        if (modeBuffer === "")
          return;
        let result3 = null;
        if (typeof top.subLanguage === "string") {
          if (!languages[top.subLanguage]) {
            emitter.addText(modeBuffer);
            return;
          }
          result3 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
          continuations[top.subLanguage] = result3._top;
        } else {
          result3 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
        }
        if (top.relevance > 0) {
          relevance += result3.relevance;
        }
        emitter.addSublanguage(result3._emitter, result3.language);
      }
      function processBuffer() {
        if (top.subLanguage != null) {
          processSubLanguage();
        } else {
          processKeywords();
        }
        modeBuffer = "";
      }
      function emitMultiClass(scope, match2) {
        let i2 = 1;
        while (match2[i2] !== void 0) {
          if (!scope._emit[i2]) {
            i2++;
            continue;
          }
          const klass = language.classNameAliases[scope[i2]] || scope[i2];
          const text = match2[i2];
          if (klass) {
            emitter.addKeyword(text, klass);
          } else {
            modeBuffer = text;
            processKeywords();
            modeBuffer = "";
          }
          i2++;
        }
      }
      function startNewMode(mode, match2) {
        if (mode.scope && typeof mode.scope === "string") {
          emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
        }
        if (mode.beginScope) {
          if (mode.beginScope._wrap) {
            emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
            modeBuffer = "";
          } else if (mode.beginScope._multi) {
            emitMultiClass(mode.beginScope, match2);
            modeBuffer = "";
          }
        }
        top = Object.create(mode, { parent: { value: top } });
        return top;
      }
      function endOfMode(mode, match2, matchPlusRemainder) {
        let matched = startsWith(mode.endRe, matchPlusRemainder);
        if (matched) {
          if (mode["on:end"]) {
            const resp = new Response(mode);
            mode["on:end"](match2, resp);
            if (resp.isMatchIgnored)
              matched = false;
          }
          if (matched) {
            while (mode.endsParent && mode.parent) {
              mode = mode.parent;
            }
            return mode;
          }
        }
        if (mode.endsWithParent) {
          return endOfMode(mode.parent, match2, matchPlusRemainder);
        }
      }
      function doIgnore(lexeme) {
        if (top.matcher.regexIndex === 0) {
          modeBuffer += lexeme[0];
          return 1;
        } else {
          resumeScanAtSamePosition = true;
          return 0;
        }
      }
      function doBeginMatch(match2) {
        const lexeme = match2[0];
        const newMode = match2.rule;
        const resp = new Response(newMode);
        const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
        for (const cb2 of beforeCallbacks) {
          if (!cb2)
            continue;
          cb2(match2, resp);
          if (resp.isMatchIgnored)
            return doIgnore(lexeme);
        }
        if (newMode.skip) {
          modeBuffer += lexeme;
        } else {
          if (newMode.excludeBegin) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (!newMode.returnBegin && !newMode.excludeBegin) {
            modeBuffer = lexeme;
          }
        }
        startNewMode(newMode, match2);
        return newMode.returnBegin ? 0 : lexeme.length;
      }
      function doEndMatch(match2) {
        const lexeme = match2[0];
        const matchPlusRemainder = codeToHighlight.substr(match2.index);
        const endMode = endOfMode(top, match2, matchPlusRemainder);
        if (!endMode) {
          return NO_MATCH;
        }
        const origin = top;
        if (top.endScope && top.endScope._wrap) {
          processBuffer();
          emitter.addKeyword(lexeme, top.endScope._wrap);
        } else if (top.endScope && top.endScope._multi) {
          processBuffer();
          emitMultiClass(top.endScope, match2);
        } else if (origin.skip) {
          modeBuffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            modeBuffer = lexeme;
          }
        }
        do {
          if (top.scope) {
            emitter.closeNode();
          }
          if (!top.skip && !top.subLanguage) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== endMode.parent);
        if (endMode.starts) {
          startNewMode(endMode.starts, match2);
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }
      function processContinuations() {
        const list = [];
        for (let current = top; current !== language; current = current.parent) {
          if (current.scope) {
            list.unshift(current.scope);
          }
        }
        list.forEach((item) => emitter.openNode(item));
      }
      let lastMatch = {};
      function processLexeme(textBeforeMatch, match2) {
        const lexeme = match2 && match2[0];
        modeBuffer += textBeforeMatch;
        if (lexeme == null) {
          processBuffer();
          return 0;
        }
        if (lastMatch.type === "begin" && match2.type === "end" && lastMatch.index === match2.index && lexeme === "") {
          modeBuffer += codeToHighlight.slice(match2.index, match2.index + 1);
          if (!SAFE_MODE) {
            const err = new Error(`0 width match regex (${languageName})`);
            err.languageName = languageName;
            err.badRule = lastMatch.rule;
            throw err;
          }
          return 1;
        }
        lastMatch = match2;
        if (match2.type === "begin") {
          return doBeginMatch(match2);
        } else if (match2.type === "illegal" && !ignoreIllegals) {
          const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
          err.mode = top;
          throw err;
        } else if (match2.type === "end") {
          const processed = doEndMatch(match2);
          if (processed !== NO_MATCH) {
            return processed;
          }
        }
        if (match2.type === "illegal" && lexeme === "") {
          return 1;
        }
        if (iterations > 1e5 && iterations > match2.index * 3) {
          const err = new Error("potential infinite loop, way more iterations than matches");
          throw err;
        }
        modeBuffer += lexeme;
        return lexeme.length;
      }
      const language = getLanguage(languageName);
      if (!language) {
        error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
        throw new Error('Unknown language: "' + languageName + '"');
      }
      const md2 = compileLanguage(language);
      let result2 = "";
      let top = continuation || md2;
      const continuations = {};
      const emitter = new options.__emitter(options);
      processContinuations();
      let modeBuffer = "";
      let relevance = 0;
      let index = 0;
      let iterations = 0;
      let resumeScanAtSamePosition = false;
      try {
        top.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top.matcher.considerAll();
          }
          top.matcher.lastIndex = index;
          const match2 = top.matcher.exec(codeToHighlight);
          if (!match2)
            break;
          const beforeMatch = codeToHighlight.substring(index, match2.index);
          const processedCount = processLexeme(beforeMatch, match2);
          index = match2.index + processedCount;
        }
        processLexeme(codeToHighlight.substr(index));
        emitter.closeAllNodes();
        emitter.finalize();
        result2 = emitter.toHTML();
        return {
          language: languageName,
          value: result2,
          relevance,
          illegal: false,
          _emitter: emitter,
          _top: top
        };
      } catch (err) {
        if (err.message && err.message.includes("Illegal")) {
          return {
            language: languageName,
            value: escape$1(codeToHighlight),
            illegal: true,
            relevance: 0,
            _illegalBy: {
              message: err.message,
              index,
              context: codeToHighlight.slice(index - 100, index + 100),
              mode: err.mode,
              resultSoFar: result2
            },
            _emitter: emitter
          };
        } else if (SAFE_MODE) {
          return {
            language: languageName,
            value: escape$1(codeToHighlight),
            illegal: false,
            relevance: 0,
            errorRaised: err,
            _emitter: emitter,
            _top: top
          };
        } else {
          throw err;
        }
      }
    }
    function justTextHighlightResult(code) {
      const result2 = {
        value: escape$1(code),
        illegal: false,
        relevance: 0,
        _top: PLAINTEXT_LANGUAGE,
        _emitter: new options.__emitter(options)
      };
      result2._emitter.addText(code);
      return result2;
    }
    function highlightAuto(code, languageSubset) {
      languageSubset = languageSubset || options.languages || Object.keys(languages);
      const plaintext = justTextHighlightResult(code);
      const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name) => _highlight(name, code, false));
      results.unshift(plaintext);
      const sorted = results.sort((a2, b2) => {
        if (a2.relevance !== b2.relevance)
          return b2.relevance - a2.relevance;
        if (a2.language && b2.language) {
          if (getLanguage(a2.language).supersetOf === b2.language) {
            return 1;
          } else if (getLanguage(b2.language).supersetOf === a2.language) {
            return -1;
          }
        }
        return 0;
      });
      const [best, secondBest] = sorted;
      const result2 = best;
      result2.secondBest = secondBest;
      return result2;
    }
    function updateClassName(element, currentLang, resultLang) {
      const language = currentLang && aliases[currentLang] || resultLang;
      element.classList.add("hljs");
      element.classList.add(`language-${language}`);
    }
    function highlightElement(element) {
      let node = null;
      const language = blockLanguage(element);
      if (shouldNotHighlight(language))
        return;
      fire("before:highlightElement", { el: element, language });
      if (element.children.length > 0) {
        if (!options.ignoreUnescapedHTML) {
          console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
          console.warn("https://github.com/highlightjs/highlight.js/issues/2886");
          console.warn(element);
        }
        if (options.throwUnescapedHTML) {
          const err = new HTMLInjectionError("One of your code blocks includes unescaped HTML.", element.innerHTML);
          throw err;
        }
      }
      node = element;
      const text = node.textContent;
      const result2 = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
      element.innerHTML = result2.value;
      updateClassName(element, language, result2.language);
      element.result = {
        language: result2.language,
        re: result2.relevance,
        relevance: result2.relevance
      };
      if (result2.secondBest) {
        element.secondBest = {
          language: result2.secondBest.language,
          relevance: result2.secondBest.relevance
        };
      }
      fire("after:highlightElement", { el: element, result: result2, text });
    }
    function configure(userOptions) {
      options = inherit(options, userOptions);
    }
    const initHighlighting = () => {
      highlightAll();
      deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function initHighlightingOnLoad() {
      highlightAll();
      deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let wantsHighlight = false;
    function highlightAll() {
      if (document.readyState === "loading") {
        wantsHighlight = true;
        return;
      }
      const blocks = document.querySelectorAll(options.cssSelector);
      blocks.forEach(highlightElement);
    }
    function boot() {
      if (wantsHighlight)
        highlightAll();
    }
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("DOMContentLoaded", boot, false);
    }
    function registerLanguage(languageName, languageDefinition) {
      let lang = null;
      try {
        lang = languageDefinition(hljs);
      } catch (error$1) {
        error("Language definition for '{}' could not be registered.".replace("{}", languageName));
        if (!SAFE_MODE) {
          throw error$1;
        } else {
          error(error$1);
        }
        lang = PLAINTEXT_LANGUAGE;
      }
      if (!lang.name)
        lang.name = languageName;
      languages[languageName] = lang;
      lang.rawDefinition = languageDefinition.bind(null, hljs);
      if (lang.aliases) {
        registerAliases(lang.aliases, { languageName });
      }
    }
    function unregisterLanguage(languageName) {
      delete languages[languageName];
      for (const alias of Object.keys(aliases)) {
        if (aliases[alias] === languageName) {
          delete aliases[alias];
        }
      }
    }
    function listLanguages() {
      return Object.keys(languages);
    }
    function getLanguage(name) {
      name = (name || "").toLowerCase();
      return languages[name] || languages[aliases[name]];
    }
    function registerAliases(aliasList, { languageName }) {
      if (typeof aliasList === "string") {
        aliasList = [aliasList];
      }
      aliasList.forEach((alias) => {
        aliases[alias.toLowerCase()] = languageName;
      });
    }
    function autoDetection(name) {
      const lang = getLanguage(name);
      return lang && !lang.disableAutodetect;
    }
    function upgradePluginAPI(plugin) {
      if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
        plugin["before:highlightElement"] = (data) => {
          plugin["before:highlightBlock"](Object.assign({ block: data.el }, data));
        };
      }
      if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
        plugin["after:highlightElement"] = (data) => {
          plugin["after:highlightBlock"](Object.assign({ block: data.el }, data));
        };
      }
    }
    function addPlugin(plugin) {
      upgradePluginAPI(plugin);
      plugins.push(plugin);
    }
    function fire(event, args) {
      const cb2 = event;
      plugins.forEach(function(plugin) {
        if (plugin[cb2]) {
          plugin[cb2](args);
        }
      });
    }
    function deprecateHighlightBlock(el2) {
      deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
      deprecated("10.7.0", "Please use highlightElement now.");
      return highlightElement(el2);
    }
    Object.assign(hljs, {
      highlight: highlight2,
      highlightAuto,
      highlightAll,
      highlightElement,
      highlightBlock: deprecateHighlightBlock,
      configure,
      initHighlighting,
      initHighlightingOnLoad,
      registerLanguage,
      unregisterLanguage,
      listLanguages,
      getLanguage,
      registerAliases,
      autoDetection,
      inherit,
      addPlugin
    });
    hljs.debugMode = function() {
      SAFE_MODE = false;
    };
    hljs.safeMode = function() {
      SAFE_MODE = true;
    };
    hljs.versionString = version;
    hljs.regex = {
      concat,
      lookahead,
      either,
      optional,
      anyNumberOfTimes
    };
    for (const key in MODES$1) {
      if (typeof MODES$1[key] === "object") {
        deepFreeze$1(MODES$1[key]);
      }
    }
    Object.assign(hljs, MODES$1);
    return hljs;
  };
  var highlight = HLJS({});
  var core = highlight;
  highlight.HighlightJS = highlight;
  highlight.default = highlight;
  function bash(hljs) {
    const regex = hljs.regex;
    const VAR = {};
    const BRACED_VAR = {
      begin: /\$\{/,
      end: /\}/,
      contains: [
        "self",
        {
          begin: /:-/,
          contains: [VAR]
        }
      ]
    };
    Object.assign(VAR, {
      className: "variable",
      variants: [
        { begin: regex.concat(/\$[\w\d#@][\w\d_]*/, `(?![\\w\\d])(?![$])`) },
        BRACED_VAR
      ]
    });
    const SUBST = {
      className: "subst",
      begin: /\$\(/,
      end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    };
    const HERE_DOC = {
      begin: /<<-?\s*(?=\w+)/,
      starts: {
        contains: [
          hljs.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ]
      }
    };
    const QUOTE_STRING = {
      className: "string",
      begin: /"/,
      end: /"/,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        VAR,
        SUBST
      ]
    };
    SUBST.contains.push(QUOTE_STRING);
    const ESCAPED_QUOTE = {
      className: "",
      begin: /\\"/
    };
    const APOS_STRING = {
      className: "string",
      begin: /'/,
      end: /'/
    };
    const ARITHMETIC = {
      begin: /\$\(\(/,
      end: /\)\)/,
      contains: [
        { begin: /\d+#[0-9a-f]+/, className: "number" },
        hljs.NUMBER_MODE,
        VAR
      ]
    };
    const SH_LIKE_SHELLS = [
      "fish",
      "bash",
      "zsh",
      "sh",
      "csh",
      "ksh",
      "tcsh",
      "dash",
      "scsh"
    ];
    const KNOWN_SHEBANG = hljs.SHEBANG({
      binary: `(${SH_LIKE_SHELLS.join("|")})`,
      relevance: 10
    });
    const FUNCTION = {
      className: "function",
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    };
    const KEYWORDS2 = [
      "if",
      "then",
      "else",
      "elif",
      "fi",
      "for",
      "while",
      "in",
      "do",
      "done",
      "case",
      "esac",
      "function"
    ];
    const LITERALS2 = [
      "true",
      "false"
    ];
    const PATH_MODE = {
      match: /(\/[a-z._-]+)+/
    };
    const SHELL_BUILT_INS = [
      "break",
      "cd",
      "continue",
      "eval",
      "exec",
      "exit",
      "export",
      "getopts",
      "hash",
      "pwd",
      "readonly",
      "return",
      "shift",
      "test",
      "times",
      "trap",
      "umask",
      "unset"
    ];
    const BASH_BUILT_INS = [
      "alias",
      "bind",
      "builtin",
      "caller",
      "command",
      "declare",
      "echo",
      "enable",
      "help",
      "let",
      "local",
      "logout",
      "mapfile",
      "printf",
      "read",
      "readarray",
      "source",
      "type",
      "typeset",
      "ulimit",
      "unalias"
    ];
    const ZSH_BUILT_INS = [
      "autoload",
      "bg",
      "bindkey",
      "bye",
      "cap",
      "chdir",
      "clone",
      "comparguments",
      "compcall",
      "compctl",
      "compdescribe",
      "compfiles",
      "compgroups",
      "compquote",
      "comptags",
      "comptry",
      "compvalues",
      "dirs",
      "disable",
      "disown",
      "echotc",
      "echoti",
      "emulate",
      "fc",
      "fg",
      "float",
      "functions",
      "getcap",
      "getln",
      "history",
      "integer",
      "jobs",
      "kill",
      "limit",
      "log",
      "noglob",
      "popd",
      "print",
      "pushd",
      "pushln",
      "rehash",
      "sched",
      "setcap",
      "setopt",
      "stat",
      "suspend",
      "ttyctl",
      "unfunction",
      "unhash",
      "unlimit",
      "unsetopt",
      "vared",
      "wait",
      "whence",
      "where",
      "which",
      "zcompile",
      "zformat",
      "zftp",
      "zle",
      "zmodload",
      "zparseopts",
      "zprof",
      "zpty",
      "zregexparse",
      "zsocket",
      "zstyle",
      "ztcp"
    ];
    const GNU_CORE_UTILS = [
      "chcon",
      "chgrp",
      "chown",
      "chmod",
      "cp",
      "dd",
      "df",
      "dir",
      "dircolors",
      "ln",
      "ls",
      "mkdir",
      "mkfifo",
      "mknod",
      "mktemp",
      "mv",
      "realpath",
      "rm",
      "rmdir",
      "shred",
      "sync",
      "touch",
      "truncate",
      "vdir",
      "b2sum",
      "base32",
      "base64",
      "cat",
      "cksum",
      "comm",
      "csplit",
      "cut",
      "expand",
      "fmt",
      "fold",
      "head",
      "join",
      "md5sum",
      "nl",
      "numfmt",
      "od",
      "paste",
      "ptx",
      "pr",
      "sha1sum",
      "sha224sum",
      "sha256sum",
      "sha384sum",
      "sha512sum",
      "shuf",
      "sort",
      "split",
      "sum",
      "tac",
      "tail",
      "tr",
      "tsort",
      "unexpand",
      "uniq",
      "wc",
      "arch",
      "basename",
      "chroot",
      "date",
      "dirname",
      "du",
      "echo",
      "env",
      "expr",
      "factor",
      "groups",
      "hostid",
      "id",
      "link",
      "logname",
      "nice",
      "nohup",
      "nproc",
      "pathchk",
      "pinky",
      "printenv",
      "printf",
      "pwd",
      "readlink",
      "runcon",
      "seq",
      "sleep",
      "stat",
      "stdbuf",
      "stty",
      "tee",
      "test",
      "timeout",
      "tty",
      "uname",
      "unlink",
      "uptime",
      "users",
      "who",
      "whoami",
      "yes"
    ];
    return {
      name: "Bash",
      aliases: ["sh"],
      keywords: {
        $pattern: /\b[a-z._-]+\b/,
        keyword: KEYWORDS2,
        literal: LITERALS2,
        built_in: [
          ...SHELL_BUILT_INS,
          ...BASH_BUILT_INS,
          "set",
          "shopt",
          ...ZSH_BUILT_INS,
          ...GNU_CORE_UTILS
        ]
      },
      contains: [
        KNOWN_SHEBANG,
        hljs.SHEBANG(),
        FUNCTION,
        ARITHMETIC,
        hljs.HASH_COMMENT_MODE,
        HERE_DOC,
        PATH_MODE,
        QUOTE_STRING,
        ESCAPED_QUOTE,
        APOS_STRING,
        VAR
      ]
    };
  }
  var knownCssProperties = {};
  const properties = [
    "-epub-caption-side",
    "-epub-hyphens",
    "-epub-text-combine",
    "-epub-text-emphasis",
    "-epub-text-emphasis-color",
    "-epub-text-emphasis-style",
    "-epub-text-orientation",
    "-epub-text-transform",
    "-epub-word-break",
    "-epub-writing-mode",
    "-internal-text-autosizing-status",
    "accelerator",
    "accent-color",
    "-wap-accesskey",
    "additive-symbols",
    "align-content",
    "-webkit-align-content",
    "align-items",
    "-webkit-align-items",
    "align-self",
    "-webkit-align-self",
    "alignment-baseline",
    "all",
    "alt",
    "-webkit-alt",
    "animation",
    "animation-delay",
    "-moz-animation-delay",
    "-ms-animation-delay",
    "-webkit-animation-delay",
    "animation-direction",
    "-moz-animation-direction",
    "-ms-animation-direction",
    "-webkit-animation-direction",
    "animation-duration",
    "-moz-animation-duration",
    "-ms-animation-duration",
    "-webkit-animation-duration",
    "animation-fill-mode",
    "-moz-animation-fill-mode",
    "-ms-animation-fill-mode",
    "-webkit-animation-fill-mode",
    "animation-iteration-count",
    "-moz-animation-iteration-count",
    "-ms-animation-iteration-count",
    "-webkit-animation-iteration-count",
    "-moz-animation",
    "-ms-animation",
    "animation-name",
    "-moz-animation-name",
    "-ms-animation-name",
    "-webkit-animation-name",
    "animation-play-state",
    "-moz-animation-play-state",
    "-ms-animation-play-state",
    "-webkit-animation-play-state",
    "animation-timing-function",
    "-moz-animation-timing-function",
    "-ms-animation-timing-function",
    "-webkit-animation-timing-function",
    "-webkit-animation-trigger",
    "-webkit-animation",
    "app-region",
    "-webkit-app-region",
    "appearance",
    "-moz-appearance",
    "-webkit-appearance",
    "ascent-override",
    "aspect-ratio",
    "-webkit-aspect-ratio",
    "audio-level",
    "azimuth",
    "backdrop-filter",
    "-webkit-backdrop-filter",
    "backface-visibility",
    "-moz-backface-visibility",
    "-ms-backface-visibility",
    "-webkit-backface-visibility",
    "background",
    "background-attachment",
    "-webkit-background-attachment",
    "background-blend-mode",
    "background-clip",
    "-moz-background-clip",
    "-webkit-background-clip",
    "background-color",
    "-webkit-background-color",
    "-webkit-background-composite",
    "background-image",
    "-webkit-background-image",
    "-moz-background-inline-policy",
    "background-origin",
    "-moz-background-origin",
    "-webkit-background-origin",
    "background-position",
    "-webkit-background-position",
    "background-position-x",
    "-webkit-background-position-x",
    "background-position-y",
    "-webkit-background-position-y",
    "background-repeat",
    "-webkit-background-repeat",
    "background-repeat-x",
    "background-repeat-y",
    "background-size",
    "-moz-background-size",
    "-webkit-background-size",
    "-webkit-background",
    "baseline-shift",
    "baseline-source",
    "behavior",
    "-moz-binding",
    "block-ellipsis",
    "-ms-block-progression",
    "block-size",
    "block-step",
    "block-step-align",
    "block-step-insert",
    "block-step-round",
    "block-step-size",
    "bookmark-label",
    "bookmark-level",
    "bookmark-state",
    "border",
    "-webkit-border-after-color",
    "-webkit-border-after-style",
    "-webkit-border-after",
    "-webkit-border-after-width",
    "-webkit-border-before-color",
    "-webkit-border-before-style",
    "-webkit-border-before",
    "-webkit-border-before-width",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "-moz-border-bottom-colors",
    "border-bottom-left-radius",
    "-webkit-border-bottom-left-radius",
    "border-bottom-right-radius",
    "-webkit-border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-boundary",
    "border-collapse",
    "border-color",
    "-moz-border-end-color",
    "-webkit-border-end-color",
    "border-end-end-radius",
    "-moz-border-end",
    "border-end-start-radius",
    "-moz-border-end-style",
    "-webkit-border-end-style",
    "-webkit-border-end",
    "-moz-border-end-width",
    "-webkit-border-end-width",
    "-webkit-border-fit",
    "-webkit-border-horizontal-spacing",
    "border-image",
    "-moz-border-image",
    "-o-border-image",
    "border-image-outset",
    "-webkit-border-image-outset",
    "border-image-repeat",
    "-webkit-border-image-repeat",
    "border-image-slice",
    "-webkit-border-image-slice",
    "border-image-source",
    "-webkit-border-image-source",
    "-webkit-border-image",
    "border-image-width",
    "-webkit-border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "-moz-border-left-colors",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "-moz-border-radius-bottomleft",
    "-moz-border-radius-bottomright",
    "-moz-border-radius",
    "-moz-border-radius-topleft",
    "-moz-border-radius-topright",
    "-webkit-border-radius",
    "border-right",
    "border-right-color",
    "-moz-border-right-colors",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "-moz-border-start-color",
    "-webkit-border-start-color",
    "border-start-end-radius",
    "-moz-border-start",
    "border-start-start-radius",
    "-moz-border-start-style",
    "-webkit-border-start-style",
    "-webkit-border-start",
    "-moz-border-start-width",
    "-webkit-border-start-width",
    "border-style",
    "border-top",
    "border-top-color",
    "-moz-border-top-colors",
    "border-top-left-radius",
    "-webkit-border-top-left-radius",
    "border-top-right-radius",
    "-webkit-border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "-webkit-border-vertical-spacing",
    "border-width",
    "bottom",
    "-moz-box-align",
    "-webkit-box-align",
    "box-decoration-break",
    "-webkit-box-decoration-break",
    "-moz-box-direction",
    "-webkit-box-direction",
    "-webkit-box-flex-group",
    "-moz-box-flex",
    "-webkit-box-flex",
    "-webkit-box-lines",
    "-moz-box-ordinal-group",
    "-webkit-box-ordinal-group",
    "-moz-box-orient",
    "-webkit-box-orient",
    "-moz-box-pack",
    "-webkit-box-pack",
    "-webkit-box-reflect",
    "box-shadow",
    "-moz-box-shadow",
    "-webkit-box-shadow",
    "box-sizing",
    "-moz-box-sizing",
    "-webkit-box-sizing",
    "box-snap",
    "break-after",
    "break-before",
    "break-inside",
    "buffered-rendering",
    "caption-side",
    "caret",
    "caret-color",
    "caret-shape",
    "chains",
    "clear",
    "clip",
    "clip-path",
    "-webkit-clip-path",
    "clip-rule",
    "color",
    "color-adjust",
    "-webkit-color-correction",
    "-apple-color-filter",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "color-scheme",
    "-webkit-column-axis",
    "-webkit-column-break-after",
    "-webkit-column-break-before",
    "-webkit-column-break-inside",
    "column-count",
    "-moz-column-count",
    "-webkit-column-count",
    "column-fill",
    "-moz-column-fill",
    "-webkit-column-fill",
    "column-gap",
    "-moz-column-gap",
    "-webkit-column-gap",
    "column-progression",
    "-webkit-column-progression",
    "column-rule",
    "column-rule-color",
    "-moz-column-rule-color",
    "-webkit-column-rule-color",
    "-moz-column-rule",
    "column-rule-style",
    "-moz-column-rule-style",
    "-webkit-column-rule-style",
    "-webkit-column-rule",
    "column-rule-width",
    "-moz-column-rule-width",
    "-webkit-column-rule-width",
    "column-span",
    "-moz-column-span",
    "-webkit-column-span",
    "column-width",
    "-moz-column-width",
    "-webkit-column-width",
    "columns",
    "-moz-columns",
    "-webkit-columns",
    "-webkit-composition-fill-color",
    "-webkit-composition-frame-color",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "content",
    "content-visibility",
    "-ms-content-zoom-chaining",
    "-ms-content-zoom-limit-max",
    "-ms-content-zoom-limit-min",
    "-ms-content-zoom-limit",
    "-ms-content-zoom-snap",
    "-ms-content-zoom-snap-points",
    "-ms-content-zoom-snap-type",
    "-ms-content-zooming",
    "continue",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "-webkit-cursor-visibility",
    "cx",
    "cy",
    "d",
    "-apple-dashboard-region",
    "-webkit-dashboard-region",
    "descent-override",
    "direction",
    "display",
    "display-align",
    "dominant-baseline",
    "elevation",
    "empty-cells",
    "enable-background",
    "epub-caption-side",
    "epub-hyphens",
    "epub-text-combine",
    "epub-text-emphasis",
    "epub-text-emphasis-color",
    "epub-text-emphasis-style",
    "epub-text-orientation",
    "epub-text-transform",
    "epub-word-break",
    "epub-writing-mode",
    "fallback",
    "fill",
    "fill-break",
    "fill-color",
    "fill-image",
    "fill-opacity",
    "fill-origin",
    "fill-position",
    "fill-repeat",
    "fill-rule",
    "fill-size",
    "filter",
    "-ms-filter",
    "-webkit-filter",
    "flex",
    "-ms-flex-align",
    "-webkit-flex-align",
    "flex-basis",
    "-webkit-flex-basis",
    "flex-direction",
    "-ms-flex-direction",
    "-webkit-flex-direction",
    "flex-flow",
    "-ms-flex-flow",
    "-webkit-flex-flow",
    "flex-grow",
    "-webkit-flex-grow",
    "-ms-flex-item-align",
    "-webkit-flex-item-align",
    "-ms-flex-line-pack",
    "-webkit-flex-line-pack",
    "-ms-flex",
    "-ms-flex-negative",
    "-ms-flex-order",
    "-webkit-flex-order",
    "-ms-flex-pack",
    "-webkit-flex-pack",
    "-ms-flex-positive",
    "-ms-flex-preferred-size",
    "flex-shrink",
    "-webkit-flex-shrink",
    "-webkit-flex",
    "flex-wrap",
    "-ms-flex-wrap",
    "-webkit-flex-wrap",
    "float",
    "float-defer",
    "-moz-float-edge",
    "float-offset",
    "float-reference",
    "flood-color",
    "flood-opacity",
    "flow",
    "flow-from",
    "-ms-flow-from",
    "-webkit-flow-from",
    "flow-into",
    "-ms-flow-into",
    "-webkit-flow-into",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "-moz-font-feature-settings",
    "-ms-font-feature-settings",
    "-webkit-font-feature-settings",
    "font-kerning",
    "-webkit-font-kerning",
    "font-language-override",
    "-moz-font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "-webkit-font-size-delta",
    "-webkit-font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "-webkit-font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "footnote-display",
    "footnote-policy",
    "-moz-force-broken-image-icon",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "grid",
    "-webkit-grid-after",
    "grid-area",
    "grid-auto-columns",
    "-webkit-grid-auto-columns",
    "grid-auto-flow",
    "-webkit-grid-auto-flow",
    "grid-auto-rows",
    "-webkit-grid-auto-rows",
    "-webkit-grid-before",
    "grid-column",
    "-ms-grid-column-align",
    "grid-column-end",
    "grid-column-gap",
    "-ms-grid-column",
    "-ms-grid-column-span",
    "grid-column-start",
    "-webkit-grid-column",
    "-ms-grid-columns",
    "-webkit-grid-columns",
    "-webkit-grid-end",
    "grid-gap",
    "grid-row",
    "-ms-grid-row-align",
    "grid-row-end",
    "grid-row-gap",
    "-ms-grid-row",
    "-ms-grid-row-span",
    "grid-row-start",
    "-webkit-grid-row",
    "-ms-grid-rows",
    "-webkit-grid-rows",
    "-webkit-grid-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "-ms-high-contrast-adjust",
    "-webkit-highlight",
    "hyphenate-character",
    "-webkit-hyphenate-character",
    "-webkit-hyphenate-limit-after",
    "-webkit-hyphenate-limit-before",
    "hyphenate-limit-chars",
    "-ms-hyphenate-limit-chars",
    "hyphenate-limit-last",
    "hyphenate-limit-lines",
    "-ms-hyphenate-limit-lines",
    "-webkit-hyphenate-limit-lines",
    "hyphenate-limit-zone",
    "-ms-hyphenate-limit-zone",
    "hyphens",
    "-moz-hyphens",
    "-ms-hyphens",
    "-webkit-hyphens",
    "image-orientation",
    "-moz-image-region",
    "image-rendering",
    "image-resolution",
    "-ms-ime-align",
    "ime-mode",
    "inherits",
    "initial-letter",
    "initial-letter-align",
    "-webkit-initial-letter",
    "initial-letter-wrap",
    "initial-value",
    "inline-size",
    "inline-sizing",
    "input-format",
    "-wap-input-format",
    "-wap-input-required",
    "input-security",
    "inset",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "-ms-interpolation-mode",
    "isolation",
    "justify-content",
    "-webkit-justify-content",
    "justify-items",
    "-webkit-justify-items",
    "justify-self",
    "-webkit-justify-self",
    "kerning",
    "layout-flow",
    "layout-grid",
    "layout-grid-char",
    "layout-grid-line",
    "layout-grid-mode",
    "layout-grid-type",
    "leading-trim",
    "left",
    "letter-spacing",
    "lighting-color",
    "-webkit-line-align",
    "-webkit-line-box-contain",
    "line-break",
    "-webkit-line-break",
    "line-clamp",
    "-webkit-line-clamp",
    "line-gap-override",
    "line-grid",
    "-webkit-line-grid-snap",
    "-webkit-line-grid",
    "line-height",
    "line-height-step",
    "line-increment",
    "line-padding",
    "line-snap",
    "-webkit-line-snap",
    "-o-link",
    "-o-link-source",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "-webkit-locale",
    "-webkit-logical-height",
    "-webkit-logical-width",
    "margin",
    "-webkit-margin-after-collapse",
    "-webkit-margin-after",
    "-webkit-margin-before-collapse",
    "-webkit-margin-before",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "-webkit-margin-bottom-collapse",
    "margin-break",
    "-webkit-margin-collapse",
    "-moz-margin-end",
    "-webkit-margin-end",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "-moz-margin-start",
    "-webkit-margin-start",
    "margin-top",
    "-webkit-margin-top-collapse",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-knockout-left",
    "marker-knockout-right",
    "marker-mid",
    "marker-offset",
    "marker-pattern",
    "marker-segment",
    "marker-side",
    "marker-start",
    "marks",
    "-wap-marquee-dir",
    "-webkit-marquee-direction",
    "-webkit-marquee-increment",
    "-wap-marquee-loop",
    "-webkit-marquee-repetition",
    "-wap-marquee-speed",
    "-webkit-marquee-speed",
    "-wap-marquee-style",
    "-webkit-marquee-style",
    "-webkit-marquee",
    "mask",
    "-webkit-mask-attachment",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "-webkit-mask-box-image-outset",
    "-webkit-mask-box-image-repeat",
    "-webkit-mask-box-image-slice",
    "-webkit-mask-box-image-source",
    "-webkit-mask-box-image",
    "-webkit-mask-box-image-width",
    "mask-clip",
    "-webkit-mask-clip",
    "mask-composite",
    "-webkit-mask-composite",
    "mask-image",
    "-webkit-mask-image",
    "mask-mode",
    "mask-origin",
    "-webkit-mask-origin",
    "mask-position",
    "-webkit-mask-position",
    "mask-position-x",
    "-webkit-mask-position-x",
    "mask-position-y",
    "-webkit-mask-position-y",
    "mask-repeat",
    "-webkit-mask-repeat",
    "-webkit-mask-repeat-x",
    "-webkit-mask-repeat-y",
    "mask-size",
    "-webkit-mask-size",
    "mask-source-type",
    "-webkit-mask-source-type",
    "mask-type",
    "-webkit-mask",
    "-webkit-match-nearest-mail-blockquote-color",
    "math-style",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-lines",
    "-webkit-max-logical-height",
    "-webkit-max-logical-width",
    "max-width",
    "max-zoom",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-intrinsic-sizing",
    "-webkit-min-logical-height",
    "-webkit-min-logical-width",
    "min-width",
    "min-zoom",
    "mix-blend-mode",
    "motion",
    "motion-offset",
    "motion-path",
    "motion-rotation",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "-webkit-nbsp-mode",
    "negative",
    "object-fit",
    "-o-object-fit",
    "object-position",
    "-o-object-position",
    "offset",
    "offset-anchor",
    "offset-block-end",
    "offset-block-start",
    "offset-distance",
    "offset-inline-end",
    "offset-inline-start",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "offset-rotation",
    "opacity",
    "-moz-opacity",
    "-webkit-opacity",
    "order",
    "-webkit-order",
    "-moz-orient",
    "orientation",
    "orphans",
    "-moz-osx-font-smoothing",
    "outline",
    "outline-color",
    "-moz-outline-color",
    "-moz-outline",
    "outline-offset",
    "-moz-outline-offset",
    "-moz-outline-radius-bottomleft",
    "-moz-outline-radius-bottomright",
    "-moz-outline-radius",
    "-moz-outline-radius-topleft",
    "-moz-outline-radius-topright",
    "outline-style",
    "-moz-outline-style",
    "outline-width",
    "-moz-outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "-webkit-overflow-scrolling",
    "-ms-overflow-style",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "pad",
    "padding",
    "-webkit-padding-after",
    "-webkit-padding-before",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "-moz-padding-end",
    "-webkit-padding-end",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "-moz-padding-start",
    "-webkit-padding-start",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "page-orientation",
    "paint-order",
    "pause",
    "pause-after",
    "pause-before",
    "-apple-pay-button-style",
    "-apple-pay-button-type",
    "pen-action",
    "perspective",
    "-moz-perspective",
    "-ms-perspective",
    "perspective-origin",
    "-moz-perspective-origin",
    "-ms-perspective-origin",
    "-webkit-perspective-origin",
    "perspective-origin-x",
    "-webkit-perspective-origin-x",
    "perspective-origin-y",
    "-webkit-perspective-origin-y",
    "-webkit-perspective",
    "pitch",
    "pitch-range",
    "place-content",
    "place-items",
    "place-self",
    "play-during",
    "pointer-events",
    "position",
    "prefix",
    "print-color-adjust",
    "-webkit-print-color-adjust",
    "property-name",
    "quotes",
    "r",
    "range",
    "-webkit-region-break-after",
    "-webkit-region-break-before",
    "-webkit-region-break-inside",
    "region-fragment",
    "-webkit-region-fragment",
    "-webkit-region-overflow",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "richness",
    "right",
    "rotate",
    "row-gap",
    "-webkit-rtl-ordering",
    "ruby-align",
    "ruby-merge",
    "ruby-overhang",
    "ruby-position",
    "-webkit-ruby-position",
    "running",
    "rx",
    "ry",
    "scale",
    "scroll-behavior",
    "-ms-scroll-chaining",
    "-ms-scroll-limit",
    "-ms-scroll-limit-x-max",
    "-ms-scroll-limit-x-min",
    "-ms-scroll-limit-y-max",
    "-ms-scroll-limit-y-min",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "-ms-scroll-rails",
    "scroll-snap-align",
    "scroll-snap-coordinate",
    "-webkit-scroll-snap-coordinate",
    "scroll-snap-destination",
    "-webkit-scroll-snap-destination",
    "scroll-snap-margin",
    "scroll-snap-margin-bottom",
    "scroll-snap-margin-left",
    "scroll-snap-margin-right",
    "scroll-snap-margin-top",
    "scroll-snap-points-x",
    "-ms-scroll-snap-points-x",
    "-webkit-scroll-snap-points-x",
    "scroll-snap-points-y",
    "-ms-scroll-snap-points-y",
    "-webkit-scroll-snap-points-y",
    "scroll-snap-stop",
    "scroll-snap-type",
    "-ms-scroll-snap-type",
    "-webkit-scroll-snap-type",
    "scroll-snap-type-x",
    "scroll-snap-type-y",
    "-ms-scroll-snap-x",
    "-ms-scroll-snap-y",
    "-ms-scroll-translation",
    "scrollbar-arrow-color",
    "scrollbar-base-color",
    "scrollbar-color",
    "scrollbar-dark-shadow-color",
    "scrollbar-darkshadow-color",
    "scrollbar-face-color",
    "scrollbar-gutter",
    "scrollbar-highlight-color",
    "scrollbar-shadow-color",
    "scrollbar-track-color",
    "scrollbar-width",
    "scrollbar3d-light-color",
    "scrollbar3dlight-color",
    "shape-image-threshold",
    "-webkit-shape-image-threshold",
    "shape-inside",
    "-webkit-shape-inside",
    "shape-margin",
    "-webkit-shape-margin",
    "shape-outside",
    "-webkit-shape-outside",
    "-webkit-shape-padding",
    "shape-rendering",
    "size",
    "size-adjust",
    "snap-height",
    "solid-color",
    "solid-opacity",
    "spatial-navigation-action",
    "spatial-navigation-contain",
    "spatial-navigation-function",
    "speak",
    "speak-as",
    "speak-header",
    "speak-numeral",
    "speak-punctuation",
    "speech-rate",
    "src",
    "-moz-stack-sizing",
    "stop-color",
    "stop-opacity",
    "stress",
    "string-set",
    "stroke",
    "stroke-align",
    "stroke-alignment",
    "stroke-break",
    "stroke-color",
    "stroke-dash-corner",
    "stroke-dash-justify",
    "stroke-dashadjust",
    "stroke-dasharray",
    "stroke-dashcorner",
    "stroke-dashoffset",
    "stroke-image",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-origin",
    "stroke-position",
    "stroke-repeat",
    "stroke-size",
    "stroke-width",
    "suffix",
    "supported-color-schemes",
    "-webkit-svg-shadow",
    "symbols",
    "syntax",
    "system",
    "tab-size",
    "-moz-tab-size",
    "-o-tab-size",
    "-o-table-baseline",
    "table-layout",
    "-webkit-tap-highlight-color",
    "text-align",
    "text-align-all",
    "text-align-last",
    "-moz-text-align-last",
    "text-anchor",
    "text-autospace",
    "-moz-text-blink",
    "-ms-text-combine-horizontal",
    "text-combine-upright",
    "-webkit-text-combine",
    "text-decoration",
    "text-decoration-blink",
    "text-decoration-color",
    "-moz-text-decoration-color",
    "-webkit-text-decoration-color",
    "text-decoration-line",
    "-moz-text-decoration-line",
    "text-decoration-line-through",
    "-webkit-text-decoration-line",
    "text-decoration-none",
    "text-decoration-overline",
    "text-decoration-skip",
    "text-decoration-skip-box",
    "text-decoration-skip-ink",
    "text-decoration-skip-inset",
    "text-decoration-skip-self",
    "text-decoration-skip-spaces",
    "-webkit-text-decoration-skip",
    "text-decoration-style",
    "-moz-text-decoration-style",
    "-webkit-text-decoration-style",
    "text-decoration-thickness",
    "text-decoration-underline",
    "-webkit-text-decoration",
    "-webkit-text-decorations-in-effect",
    "text-edge",
    "text-emphasis",
    "text-emphasis-color",
    "-webkit-text-emphasis-color",
    "text-emphasis-position",
    "-webkit-text-emphasis-position",
    "text-emphasis-skip",
    "text-emphasis-style",
    "-webkit-text-emphasis-style",
    "-webkit-text-emphasis",
    "-webkit-text-fill-color",
    "text-group-align",
    "text-indent",
    "text-justify",
    "text-justify-trim",
    "text-kashida",
    "text-kashida-space",
    "text-line-through",
    "text-line-through-color",
    "text-line-through-mode",
    "text-line-through-style",
    "text-line-through-width",
    "text-orientation",
    "-webkit-text-orientation",
    "text-overflow",
    "text-overline",
    "text-overline-color",
    "text-overline-mode",
    "text-overline-style",
    "text-overline-width",
    "text-rendering",
    "-webkit-text-security",
    "text-shadow",
    "text-size-adjust",
    "-moz-text-size-adjust",
    "-ms-text-size-adjust",
    "-webkit-text-size-adjust",
    "text-space-collapse",
    "text-space-trim",
    "text-spacing",
    "-webkit-text-stroke-color",
    "-webkit-text-stroke",
    "-webkit-text-stroke-width",
    "text-transform",
    "text-underline",
    "text-underline-color",
    "text-underline-mode",
    "text-underline-offset",
    "text-underline-position",
    "-webkit-text-underline-position",
    "text-underline-style",
    "text-underline-width",
    "text-wrap",
    "-webkit-text-zoom",
    "top",
    "touch-action",
    "touch-action-delay",
    "-ms-touch-action",
    "-webkit-touch-callout",
    "-ms-touch-select",
    "-apple-trailing-word",
    "transform",
    "transform-box",
    "-moz-transform",
    "-ms-transform",
    "-o-transform",
    "transform-origin",
    "-moz-transform-origin",
    "-ms-transform-origin",
    "-o-transform-origin",
    "-webkit-transform-origin",
    "transform-origin-x",
    "-webkit-transform-origin-x",
    "transform-origin-y",
    "-webkit-transform-origin-y",
    "transform-origin-z",
    "-webkit-transform-origin-z",
    "transform-style",
    "-moz-transform-style",
    "-ms-transform-style",
    "-webkit-transform-style",
    "-webkit-transform",
    "transition",
    "transition-delay",
    "-moz-transition-delay",
    "-ms-transition-delay",
    "-o-transition-delay",
    "-webkit-transition-delay",
    "transition-duration",
    "-moz-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-webkit-transition-duration",
    "-moz-transition",
    "-ms-transition",
    "-o-transition",
    "transition-property",
    "-moz-transition-property",
    "-ms-transition-property",
    "-o-transition-property",
    "-webkit-transition-property",
    "transition-timing-function",
    "-moz-transition-timing-function",
    "-ms-transition-timing-function",
    "-o-transition-timing-function",
    "-webkit-transition-timing-function",
    "-webkit-transition",
    "translate",
    "uc-alt-skin",
    "uc-skin",
    "unicode-bidi",
    "unicode-range",
    "-webkit-user-drag",
    "-moz-user-focus",
    "-moz-user-input",
    "-moz-user-modify",
    "-webkit-user-modify",
    "user-select",
    "-moz-user-select",
    "-ms-user-select",
    "-webkit-user-select",
    "user-zoom",
    "vector-effect",
    "vertical-align",
    "viewport-fill",
    "viewport-fill-opacity",
    "viewport-fit",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "volume",
    "white-space",
    "-webkit-widget-region",
    "widows",
    "width",
    "will-change",
    "-moz-window-dragging",
    "-moz-window-shadow",
    "word-boundary-detection",
    "word-boundary-expansion",
    "word-break",
    "word-spacing",
    "word-wrap",
    "wrap-after",
    "wrap-before",
    "wrap-flow",
    "-ms-wrap-flow",
    "-webkit-wrap-flow",
    "wrap-inside",
    "-ms-wrap-margin",
    "-webkit-wrap-margin",
    "-webkit-wrap-padding",
    "-webkit-wrap-shape-inside",
    "-webkit-wrap-shape-outside",
    "wrap-through",
    "-ms-wrap-through",
    "-webkit-wrap-through",
    "-webkit-wrap",
    "writing-mode",
    "-webkit-writing-mode",
    "x",
    "y",
    "z-index",
    "zoom"
  ];
  var require$$0$2 = {
    properties
  };
  knownCssProperties.all = require$$0$2.properties;
  var require$$0$1 = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "math",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "slot",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "svg",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
  ];
  var htmlTags = require$$0$1;
  var require$$0 = [
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ];
  var _void = require$$0;
  const MODES = (hljs) => {
    return {
      IMPORTANT: {
        className: "meta",
        begin: "!important"
      },
      HEXCOLOR: {
        className: "number",
        begin: "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"
      },
      ATTRIBUTE_SELECTOR_MODE: {
        className: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      }
    };
  };
  const TAGS = [
    ...htmlTags,
    ..._void
  ];
  const MEDIA_FEATURES = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    "min-width",
    "max-width",
    "min-height",
    "max-height"
  ];
  const PSEUDO_CLASSES = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    "host",
    "host-context",
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    "nth-child",
    "nth-col",
    "nth-last-child",
    "nth-last-col",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where"
  ];
  const PSEUDO_ELEMENTS = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error"
  ];
  const ATTRIBUTES = knownCssProperties.all.reverse();
  function css(hljs) {
    const modes = MODES(hljs);
    const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;
    const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;
    const AT_IDENTIFIER = "@[a-z-.]+";
    const AT_MODIFIERS = "and or not only";
    const IDENT_RE2 = "[a-zA-Z-.][a-zA-Z0-9_.-]*";
    const VARIABLE = {
      className: "variable",
      begin: "(\\$" + IDENT_RE2 + ")\\b"
    };
    const ret = {
      name: "CSS",
      case_insensitive: true,
      illegal: "[=/|']",
      contains: [
        {
          className: "sugar-function",
          begin: "sugar\\.[a-zA-Z0-9-_\\.]+",
          contains: [
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE
          ]
        },
        {
          className: "sugar-mixin",
          begin: "@sugar\\.[a-zA-Z0-9-_\\.]+",
          contains: [
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE
          ]
        },
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        {
          className: "selector-id",
          begin: "#[A-Za-z0-9_-]+",
          relevance: 0
        },
        {
          className: "selector-class",
          begin: "\\.[A-Za-z0-9_-]+",
          relevance: 0
        },
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "selector-tag",
          begin: "\\b(" + TAGS.join("|") + ")\\b",
          relevance: 0
        },
        {
          className: "selector-pseudo",
          begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
        },
        {
          className: "selector-pseudo",
          begin: "::(" + PSEUDO_ELEMENTS$1.join("|") + ")"
        },
        VARIABLE,
        {
          begin: /\(/,
          end: /\)/,
          contains: [hljs.NUMBER_MODE]
        },
        {
          className: "attribute",
          begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
        },
        {
          begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
        },
        {
          begin: "@(page|font-face)",
          lexemes: AT_IDENTIFIER,
          keywords: "@page @font-face"
        },
        {
          begin: "@",
          end: "[{;]",
          returnBegin: true,
          keywords: {
            $pattern: /[a-zA-Z-\.]+/,
            keyword: AT_MODIFIERS,
            attribute: MEDIA_FEATURES.join(" ")
          },
          contains: [
            {
              begin: AT_IDENTIFIER,
              className: "keyword"
            },
            {
              begin: /[a-zA-Z\.-]+(?=:)/,
              className: "attribute"
            },
            VARIABLE,
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE,
            modes.HEXCOLOR,
            hljs.NUMBER_MODE
          ]
        }
      ]
    };
    return ret;
  }
  const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
  const KEYWORDS = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ];
  const LITERALS = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ];
  const TYPES = [
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    "Math",
    "Date",
    "Number",
    "BigInt",
    "String",
    "RegExp",
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    "Reflect",
    "Proxy",
    "Intl",
    "WebAssembly"
  ];
  const ERROR_TYPES = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ];
  const BUILT_IN_GLOBALS = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  const BUILT_IN_VARIABLES = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "module",
    "global"
  ];
  const BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
  function javascript(hljs) {
    const regex = hljs.regex;
    const hasClosingTag = (match2, { after }) => {
      const tag2 = "</" + match2[0].slice(1);
      const pos = match2.input.indexOf(tag2, after);
      return pos !== -1;
    };
    const IDENT_RE$12 = IDENT_RE;
    const FRAGMENT = {
      begin: "<>",
      end: "</>"
    };
    const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (match2, response) => {
        const afterMatchIndex = match2[0].length + match2.index;
        const nextChar = match2.input[afterMatchIndex];
        if (nextChar === "<" || nextChar === ",") {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match2, { after: afterMatchIndex })) {
            response.ignoreMatch();
          }
        }
        let m2;
        const afterMatch = match2.input.substr(afterMatchIndex);
        if (m2 = afterMatch.match(/^\s+extends\s+/)) {
          if (m2.index === 0) {
            response.ignoreMatch();
            return;
          }
        }
      }
    };
    const KEYWORDS$1 = {
      $pattern: IDENT_RE,
      keyword: KEYWORDS,
      literal: LITERALS,
      built_in: BUILT_INS,
      "variable.language": BUILT_IN_VARIABLES
    };
    const decimalDigits = "[0-9](_?[0-9])*";
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER = {
      className: "number",
      variants: [
        { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
        { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
        { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        { begin: "\\b0[0-7]+n?\\b" }
      ],
      relevance: 0
    };
    const SUBST = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: KEYWORDS$1,
      contains: []
    };
    const HTML_TEMPLATE = {
      begin: "html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "xml"
      }
    };
    const CSS_TEMPLATE = {
      begin: "css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "css"
      }
    };
    const TEMPLATE_STRING = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    });
    const COMMENT2 = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      NUMBER
    ];
    SUBST.contains = SUBST_INTERNALS.concat({
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
    const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1,
      contains: PARAMS_CONTAINS
    };
    const CLASS_OR_EXTENDS = {
      variants: [
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$12,
            /\s+/,
            /extends/,
            /\s+/,
            regex.concat(IDENT_RE$12, "(", regex.concat(/\./, IDENT_RE$12), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited"
          }
        },
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$12
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    };
    const CLASS_REFERENCE = {
      relevance: 0,
      match: regex.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]+|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+/),
      className: "title.class",
      keywords: {
        _: [
          ...TYPES,
          ...ERROR_TYPES
        ]
      }
    };
    const USE_STRICT = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    };
    const FUNCTION_DEFINITION = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            IDENT_RE$12,
            /(?=\s*\()/
          ]
        },
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [PARAMS],
      illegal: /%/
    };
    const UPPER_CASE_CONSTANT = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function noneOf(list) {
      return regex.concat("(?!", list.join("|"), ")");
    }
    const FUNCTION_CALL = {
      match: regex.concat(/\b/, noneOf([
        ...BUILT_IN_GLOBALS,
        "super"
      ]), IDENT_RE$12, regex.lookahead(/\(/)),
      className: "title.function",
      relevance: 0
    };
    const PROPERTY_ACCESS = {
      begin: regex.concat(/\./, regex.lookahead(regex.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/))),
      end: IDENT_RE$12,
      excludeBegin: true,
      keywords: "prototype",
      className: "property",
      relevance: 0
    };
    const GETTER_OR_SETTER = {
      match: [
        /get|set/,
        /\s+/,
        IDENT_RE$12,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          begin: /\(\)/
        },
        PARAMS
      ]
    };
    const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
    const FUNCTION_VARIABLE = {
      match: [
        /const|var|let/,
        /\s+/,
        IDENT_RE$12,
        /\s*/,
        /=\s*/,
        regex.lookahead(FUNC_LEAD_IN_RE)
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        PARAMS
      ]
    };
    return {
      name: "Javascript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: KEYWORDS$1,
      exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        USE_STRICT,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT2,
        NUMBER,
        CLASS_REFERENCE,
        {
          className: "attr",
          begin: IDENT_RE$12 + regex.lookahead(":"),
          relevance: 0
        },
        FUNCTION_VARIABLE,
        {
          begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            COMMENT2,
            hljs.REGEXP_MODE,
            {
              className: "function",
              begin: FUNC_LEAD_IN_RE,
              returnBegin: true,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: hljs.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              variants: [
                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                { match: XML_SELF_CLOSING },
                {
                  begin: XML_TAG.begin,
                  "on:begin": XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        FUNCTION_DEFINITION,
        {
          beginKeywords: "while if switch catch for"
        },
        {
          begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          returnBegin: true,
          label: "func.def",
          contains: [
            PARAMS,
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: "title.function" })
          ]
        },
        {
          match: /\.\.\./,
          relevance: 0
        },
        PROPERTY_ACCESS,
        {
          match: "\\$" + IDENT_RE$12,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: { 1: "title.function" },
          contains: [PARAMS]
        },
        FUNCTION_CALL,
        UPPER_CASE_CONSTANT,
        CLASS_OR_EXTENDS,
        GETTER_OR_SETTER,
        {
          match: /\$[(.]/
        }
      ]
    };
  }
  function php(hljs) {
    const VARIABLE = {
      className: "variable",
      begin: `\\$+[a-zA-Z_\x7F-\xFF][a-zA-Z0-9_\x7F-\xFF]*(?![A-Za-z0-9])(?![$])`
    };
    const PREPROCESSOR = {
      className: "meta",
      variants: [
        { begin: /<\?php/, relevance: 10 },
        { begin: /<\?[=]?/ },
        { begin: /\?>/ }
      ]
    };
    const SUBST = {
      className: "subst",
      variants: [
        { begin: /\$\w+/ },
        { begin: /\{\$/, end: /\}/ }
      ]
    };
    const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
      illegal: null
    });
    const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
      illegal: null,
      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
    });
    const HEREDOC = hljs.END_SAME_AS_BEGIN({
      begin: /<<<[ \t]*(\w+)\n/,
      end: /[ \t]*(\w+)\b/,
      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
    });
    const STRING = {
      className: "string",
      contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
      variants: [
        hljs.inherit(SINGLE_QUOTED, {
          begin: "b'",
          end: "'"
        }),
        hljs.inherit(DOUBLE_QUOTED, {
          begin: 'b"',
          end: '"'
        }),
        DOUBLE_QUOTED,
        SINGLE_QUOTED,
        HEREDOC
      ]
    };
    const NUMBER = {
      className: "number",
      variants: [
        { begin: `\\b0b[01]+(?:_[01]+)*\\b` },
        { begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b` },
        { begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b` },
        { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?` }
      ],
      relevance: 0
    };
    const KEYWORDS2 = {
      keyword: "__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ die echo exit include include_once print require require_once array abstract and as binary bool boolean break callable case catch class clone const continue declare default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends final finally float for foreach from global goto if implements instanceof insteadof int integer interface isset iterable list match|0 mixed new object or private protected public real return string switch throw trait try unset use var void while xor yield",
      literal: "false null true",
      built_in: "Error|0 AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass"
    };
    return {
      case_insensitive: true,
      keywords: KEYWORDS2,
      contains: [
        hljs.HASH_COMMENT_MODE,
        hljs.COMMENT("//", "$", { contains: [PREPROCESSOR] }),
        hljs.COMMENT("/\\*", "\\*/", {
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }),
        hljs.COMMENT("__halt_compiler.+?;", false, {
          endsWithParent: true,
          keywords: "__halt_compiler"
        }),
        PREPROCESSOR,
        {
          className: "keyword",
          begin: /\$this\b/
        },
        VARIABLE,
        {
          begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
        },
        {
          className: "function",
          relevance: 0,
          beginKeywords: "fn function",
          end: /[;{]/,
          excludeEnd: true,
          illegal: "[$%\\[]",
          contains: [
            {
              beginKeywords: "use"
            },
            hljs.UNDERSCORE_TITLE_MODE,
            {
              begin: "=>",
              endsParent: true
            },
            {
              className: "params",
              begin: "\\(",
              end: "\\)",
              excludeBegin: true,
              excludeEnd: true,
              keywords: KEYWORDS2,
              contains: [
                "self",
                VARIABLE,
                hljs.C_BLOCK_COMMENT_MODE,
                STRING,
                NUMBER
              ]
            }
          ]
        },
        {
          className: "class",
          variants: [
            { beginKeywords: "enum", illegal: /[($"]/ },
            { beginKeywords: "class interface trait", illegal: /[:($"]/ }
          ],
          relevance: 0,
          end: /\{/,
          excludeEnd: true,
          contains: [
            { beginKeywords: "extends implements" },
            hljs.UNDERSCORE_TITLE_MODE
          ]
        },
        {
          beginKeywords: "namespace",
          relevance: 0,
          end: ";",
          illegal: /[.']/,
          contains: [hljs.UNDERSCORE_TITLE_MODE]
        },
        {
          beginKeywords: "use",
          relevance: 0,
          end: ";",
          contains: [hljs.UNDERSCORE_TITLE_MODE]
        },
        STRING,
        NUMBER
      ]
    };
  }
  function xml(hljs) {
    const regex = hljs.regex;
    const TAG_NAME_RE = regex.concat(/[A-Z_]/, regex.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
    const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
    const XML_ENTITIES = {
      className: "symbol",
      begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
    };
    const XML_META_KEYWORDS = {
      begin: /\s/,
      contains: [
        {
          className: "keyword",
          begin: /#?[a-z_][a-z1-9_-]+/,
          illegal: /\n/
        }
      ]
    };
    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
      begin: /\(/,
      end: /\)/
    });
    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
      className: "string"
    });
    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
      className: "string"
    });
    const TAG_INTERNALS = {
      endsWithParent: true,
      illegal: /</,
      relevance: 0,
      contains: [
        {
          className: "attr",
          begin: XML_IDENT_RE,
          relevance: 0
        },
        {
          begin: /=\s*/,
          relevance: 0,
          contains: [
            {
              className: "string",
              endsParent: true,
              variants: [
                {
                  begin: /"/,
                  end: /"/,
                  contains: [XML_ENTITIES]
                },
                {
                  begin: /'/,
                  end: /'/,
                  contains: [XML_ENTITIES]
                },
                {
                  begin: /[^\s"'=<>`]+/
                }
              ]
            }
          ]
        }
      ]
    };
    return {
      name: "HTML, XML",
      aliases: [
        "html",
        "xhtml",
        "rss",
        "atom",
        "xjb",
        "xsd",
        "xsl",
        "plist",
        "wsf",
        "svg"
      ],
      case_insensitive: true,
      contains: [
        {
          className: "meta",
          begin: /<![a-z]/,
          end: />/,
          relevance: 10,
          contains: [
            XML_META_KEYWORDS,
            QUOTE_META_STRING_MODE,
            APOS_META_STRING_MODE,
            XML_META_PAR_KEYWORDS,
            {
              begin: /\[/,
              end: /\]/,
              contains: [
                {
                  className: "meta",
                  begin: /<![a-z]/,
                  end: />/,
                  contains: [
                    XML_META_KEYWORDS,
                    XML_META_PAR_KEYWORDS,
                    QUOTE_META_STRING_MODE,
                    APOS_META_STRING_MODE
                  ]
                }
              ]
            }
          ]
        },
        hljs.COMMENT(/<!--/, /-->/, {
          relevance: 10
        }),
        {
          begin: /<!\[CDATA\[/,
          end: /\]\]>/,
          relevance: 10
        },
        XML_ENTITIES,
        {
          className: "meta",
          begin: /<\?xml/,
          end: /\?>/,
          relevance: 10
        },
        {
          className: "tag",
          begin: /<style(?=\s|>)/,
          end: />/,
          keywords: {
            name: "style"
          },
          contains: [TAG_INTERNALS],
          starts: {
            end: /<\/style>/,
            returnEnd: true,
            subLanguage: [
              "css",
              "xml"
            ]
          }
        },
        {
          className: "tag",
          begin: /<script(?=\s|>)/,
          end: />/,
          keywords: {
            name: "script"
          },
          contains: [TAG_INTERNALS],
          starts: {
            end: /<\/script>/,
            returnEnd: true,
            subLanguage: [
              "javascript",
              "handlebars",
              "xml"
            ]
          }
        },
        {
          className: "tag",
          begin: /<>|<\/>/
        },
        {
          className: "tag",
          begin: regex.concat(/</, regex.lookahead(regex.concat(TAG_NAME_RE, regex.either(/\/>/, />/, /\s/)))),
          end: /\/?>/,
          contains: [
            {
              className: "name",
              begin: TAG_NAME_RE,
              relevance: 0,
              starts: TAG_INTERNALS
            }
          ]
        },
        {
          className: "tag",
          begin: regex.concat(/<\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))),
          contains: [
            {
              className: "name",
              begin: TAG_NAME_RE,
              relevance: 0
            },
            {
              begin: />/,
              relevance: 0,
              endsParent: true
            }
          ]
        }
      ]
    };
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const PartType = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
  };
  const directive = (c2) => (...values) => ({
    ["_$litDirective$"]: c2,
    values
  });
  class Directive {
    constructor(_partInfo) {
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$initialize(part, parent, attributeIndex) {
      this.__part = part;
      this._$parent = parent;
      this.__attributeIndex = attributeIndex;
    }
    _$resolve(part, props) {
      return this.update(part, props);
    }
    update(_part, props) {
      return this.render(...props);
    }
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const HTML_RESULT = 1;
  class UnsafeHTMLDirective extends Directive {
    constructor(partInfo) {
      super(partInfo);
      this._value = nothing;
      if (partInfo.type !== PartType.CHILD) {
        throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
      }
    }
    render(value) {
      if (value === nothing || value == null) {
        this._templateResult = void 0;
        return this._value = value;
      }
      if (value === noChange) {
        return value;
      }
      if (typeof value != "string") {
        throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
      }
      if (value === this._value) {
        return this._templateResult;
      }
      this._value = value;
      const strings = [value];
      strings.raw = strings;
      return this._templateResult = {
        ["_$litType$"]: this.constructor.resultType,
        strings,
        values: []
      };
    }
  }
  UnsafeHTMLDirective.directiveName = "unsafeHTML";
  UnsafeHTMLDirective.resultType = HTML_RESULT;
  const unsafeHTML = directive(UnsafeHTMLDirective);
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const standardProperty = (options, element) => {
    if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
      return __spreadProps(__spreadValues({}, element), {
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      });
    } else {
      return {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: element.key,
        initializer() {
          if (typeof element.initializer === "function") {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };
  const legacyProperty = (options, proto2, name) => {
    proto2.constructor.createProperty(name, options);
  };
  function property(options) {
    return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const decorateProperty = ({ finisher, descriptor: descriptor2 }) => (protoOrDescriptor, name) => {
    var _a2;
    if (name !== void 0) {
      const ctor = protoOrDescriptor.constructor;
      if (descriptor2 !== void 0) {
        Object.defineProperty(protoOrDescriptor, name, descriptor2(name));
      }
      finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);
    } else {
      const key = (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
      const info = descriptor2 != void 0 ? {
        kind: "method",
        placement: "prototype",
        key,
        descriptor: descriptor2(protoOrDescriptor.key)
      } : __spreadProps(__spreadValues({}, protoOrDescriptor), { key });
      if (finisher != void 0) {
        info.finisher = function(ctor) {
          finisher(ctor, key);
        };
      }
      return info;
    }
  };
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  function query(selector, cache) {
    return decorateProperty({
      descriptor: (name) => {
        const descriptor2 = {
          get() {
            var _a2, _b2;
            return (_b2 = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
          },
          enumerable: true,
          configurable: true
        };
        if (cache) {
          const key = typeof name === "symbol" ? Symbol() : `__${name}`;
          descriptor2.get = function() {
            var _a2, _b2;
            if (this[key] === void 0) {
              this[key] = (_b2 = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
            }
            return this[key];
          };
        }
        return descriptor2;
      }
    });
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  function queryAssignedNodes(slotName = "", flatten = false, selector = "") {
    return decorateProperty({
      descriptor: (_name) => ({
        get() {
          var _a2, _b2, _c2;
          const slotSelector = `slot${slotName ? `[name=${slotName}]` : ":not([name])"}`;
          const slot = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(slotSelector);
          let nodes = (_c2 = (_b2 = slot) === null || _b2 === void 0 ? void 0 : _b2.assignedNodes({ flatten })) !== null && _c2 !== void 0 ? _c2 : [];
          if (selector) {
            nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.matches(selector));
          }
          return nodes;
        },
        enumerable: true,
        configurable: true
      })
    });
  }
  function decodeHtmlEntities(string2) {
    const txt = document.createElement("textarea");
    txt.innerHTML = string2;
    return txt.value;
  }
  var __css = ".hljs {\n    font-size: calc(1rem * var(--s-scale, 1));\n    display: block;\n    overflow: hidden;\n    padding: var(--s-theme-ui-code-paddingBlock, 3rem) var(--s-theme-ui-code-paddingInline, 3rem);\n    background-color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    line-height: 1.5 !important;\n}\n\n    .hljs .hljs-sugar-function {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + 20) * 1%),1);\n        border-bottom: 1px solid hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + 20) * 1%),1);\n        display: inline-block;\n    }\n\n    .hljs .hljs-sugar-mixin {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + 20) * 1%),1);\n        border-bottom: 1px solid hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + 20) * 1%),1);\n        display: inline-block;\n    }\n\n    .hljs,\n    .hljs.hljs-subst {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    }\n\n    .hljs .hljs-selector-tag {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-selector-id {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n        font-weight: bold;\n    }\n\n    .hljs .hljs-selector-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-selector-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-selector-pseudo {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),0.6);\n    }\n\n    .hljs .hljs-addition {\n        background-color: rgba(163, 190, 140, 0.5);\n    }\n\n    .hljs .hljs-deletion {\n        background-color: rgba(191, 97, 106, 0.5);\n    }\n\n    .hljs .hljs-built_in,\n    .hljs .hljs-type {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-function {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-function > .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-keyword,\n    .hljs .hljs-literal,\n    .hljs .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-number {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-regexp {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-params {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-bullet {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-code {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-emphasis {\n        font-style: italic;\n    }\n\n    .hljs .hljs-formula {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-strong {\n        font-weight: bold;\n    }\n\n    .hljs .hljs-link:hover {\n        text-decoration: underline;\n    }\n\n    .hljs .hljs-quote {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-comment {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-doctag {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-meta,\n    .hljs .hljs-meta-keyword {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0) + -40) * 1%),calc((var(--s-theme-color-error-l, 0) + 10) * 1%),1);\n    }\n\n    .hljs .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-complementary-h, 0) + var(--s-theme-color-complementary-spin ,0)),calc((var(--s-theme-color-complementary-s, 0)) * 1%),calc((var(--s-theme-color-complementary-l, 0) + 30) * 1%),1);\n    }\n\n    .hljs .hljs-builtin-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-section {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs .hljs-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-tag {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0) + -20) * 1%),calc((var(--s-theme-color-error-l, 0) + -10) * 1%),1);\n    }\n\n    .hljs.abnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.abnf .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.apache .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.apache .hljs-section {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs.arduino .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.aspectj .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.aspectj > .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.bnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.clojure .hljs-name {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.clojure .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.coq .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.cpp .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.css .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.css .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.diff .hljs-meta {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.ebnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.glsl .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.groovy .hljs-meta:not(:first-child) {\n        color: #D08770;\n    }\n\n    .hljs.haxe .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.java .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.ldif .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.lisp .hljs-name {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.lua .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.moonscript .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.nginx .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.nginx .hljs-section {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0) + -20) * 1%),calc((var(--s-theme-color-error-l, 0) + -10) * 1%),1);\n    }\n\n    .hljs.pf .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.processing .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.scss .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.stylus .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + 20) * 1%),1);\n    }\n\n    .hljs.swift .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.vim .hljs-built_in {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + 20) * 1%),1);\n        font-style: italic;\n    }\n\n    .hljs.yaml .hljs-meta {\n        color: #D08770;\n    }\n\n:host {\n    display: block;\n}\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: block;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example__slot {\n    display: none;\n}\n\n.s-code-example__nav {\n    position: relative;\n    z-index: 1;\n}\n\n.s-code-example__tabs {\n    display: flex;\n    list-style: none;\n}\n\n.s-code-example__tab {\n}\n\n.s-code-example__content {\n    position: relative;\n    --paddingBlock: var(--s-theme-ui-code-paddingBlock, 3rem);\n    overflow: hidden;\n}\n\n.s-code-example[lines] .s-code-example__content {\n        max-height: calc(1.5em * var(--max-lines) + (var(--paddingBlock) * 2));\n    }\n\n.s-code-example--more .s-code-example__content {\n        max-height: 99999px !important;\n    }\n\n:not([bare]) .s-code-example__content {\n    transition: var(--s-theme-ui-code-transition, 0);\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);box-shadow: var(--s-theme-depth-50, 0);\n}\n\n.s-code-example__more-bar {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 50%;\n    width: 100%;\n    opacity: 0;\n    pointer-events: none;\n    display: flex;\n    align-items: flex-end;\n}\n\n.s-code-example[lines] .s-code-example__more-bar {\n        opacity: 1;\n        pointer-events: all;\n    }\n\n:not([bare]) .s-code-example__more-bar {\n    text-align: center;\n    padding-inline: var(--s-theme-ui-default-paddingInline, 1.5em);\n    padding-block: var(--s-theme-ui-default-paddingBlock, 0.75em);\n    justify-content: center;\n}\n\n:not([bare]) .s-code-example__more-bar:before {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));background: linear-gradient(0deg, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1)) 0%, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),0) 100%);\n    }\n\n.s-code-example--more .s-code-example__more-bar:before {\n        height: 0;\n    }\n\n.s-code-example__code {\n    display: none;\n    line-height: 0;\n}\n\n.s-code-example__code[active] {\n        display: block;\n    }\n\n.s-code-example__code > code {\n        line-height: 1;\n    }\n\n.s-code-example__toolbar {\n    position: absolute;\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n}\n\n.s-code-example__toolbar > * {\n        font-size: 20px;\n        opacity: 0.5;\n    }\n\n.s-code-example__toolbar > *:hover {\n            opacity: 1;\n        }\n\n[toolbar-position='nav'] .s-code-example__toolbar {\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n    /* transform: translate(0, -50%); */\n}\n";
  class SCodeExampleComponentInterface extends SInterface {
    static get _definition() {
      return {
        active: {
          description: 'Specify which "tab" is active in case of multiple languages examples',
          type: "String"
        },
        toolbar: {
          description: 'Specify what you want in the toolbar. Currently available item is "copy"',
          type: "Array<String>",
          values: ["copy"],
          default: ["copy"]
        },
        toolbarPosition: {
          description: 'Specify the toolbar position. Can be "content" or "nav"',
          type: "String",
          values: ["content", "nav"],
          default: "nav"
        },
        languages: {
          description: 'Specify some languages that you want to support. Must be "[key]: language" object syntax. See [highlight.js doc](https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md) for supported languages',
          type: "Object",
          default: {}
        },
        lines: {
          description: "Specify how many lines to display at max",
          type: "Number"
        },
        moreLabel: {
          description: 'Specify the "show more" button label',
          type: "String",
          default: "Show more"
        },
        lessLabel: {
          description: 'Specigy the "show less" button label',
          type: "String",
          default: "Show less"
        },
        moreAction: {
          type: "String",
          default: "toggle"
        },
        more: {
          description: "Specify if you want to expand the more feature at start or not",
          type: "Boolean",
          default: false
        },
        scrollOnMore: {
          description: 'Specify if you want to scroll to the code when clicking on the "show more/less" button',
          type: "Boolean",
          default: true
        },
        scrollToSettings: {
          description: "Specify some scrollTo settings",
          type: "IScrollToSettings",
          default: {}
        }
      };
    }
  }
  function ease(t2) {
    return t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;
  }
  var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
  let _isUserScrolling = false, _userScrollingTimeout;
  document.addEventListener("wheel", (e2) => {
    _isUserScrolling = true;
    clearTimeout(_userScrollingTimeout);
    _userScrollingTimeout = setTimeout(() => {
      _isUserScrolling = false;
    }, 200);
  });
  function userScrolling($elm) {
    $elm.addEventListener("mouseover", (e2) => {
      $elm._isMouseover = true;
    });
    $elm.addEventListener("mouseout", (e2) => {
      $elm._isMouseover = false;
    });
    if ($elm._isMouseover && _isUserScrolling) {
      return true;
    }
    return false;
  }
  function scrollTo(target, settings = {}) {
    return new Promise((resolve, reject) => {
      var _a2, _b2, _c2, _d2;
      settings = Object.assign({ $elm: window, duration: 500, easing: ease, offset: 0, offsetX: void 0, offsetY: void 0, align: "start", justify: "start", onFinish: null }, settings);
      if (settings.$elm === document.body)
        settings.$elm = window;
      if (settings.$elm === document)
        settings.$elm = window;
      const $scrollElm = settings.$elm === window ? document.body : settings.$elm;
      let elmHeight = settings.$elm === window ? window.innerHeight : settings.$elm.offsetHeight;
      let elmWidth = settings.$elm === window ? window.innerWidth : settings.$elm.offsetWidth;
      let maxScrollY = $scrollElm.scrollHeight - elmHeight;
      let maxScrollX = $scrollElm.scrollWidth - elmWidth;
      const currentY = settings.$elm === window ? window.pageYOffset : (_a2 = settings.$elm) === null || _a2 === void 0 ? void 0 : _a2.scrollTop;
      const currentX = settings.$elm === window ? window.pageXOffset : (_b2 = settings.$elm) === null || _b2 === void 0 ? void 0 : _b2.scrollLeft;
      if (settings.$elm !== window) {
        const computedScrollStyles = window.getComputedStyle(settings.$elm);
        maxScrollY += parseInt(computedScrollStyles.paddingTop);
        maxScrollY += parseInt(computedScrollStyles.paddingBottom);
        maxScrollX += parseInt(computedScrollStyles.paddingLeft);
        maxScrollX += parseInt(computedScrollStyles.paddingRight);
      }
      let targetY = currentY, targetX = currentX;
      const elementBounds = target.getBoundingClientRect();
      const offsetY = (_c2 = settings.offsetY) !== null && _c2 !== void 0 ? _c2 : settings.offset;
      const offsetX = (_d2 = settings.offsetX) !== null && _d2 !== void 0 ? _d2 : settings.offset;
      if (settings.align === "center") {
        targetY += elementBounds.top + elementBounds.height / 2;
        targetY -= elmHeight / 2;
        targetY -= offsetY;
      } else if (settings.align === "end") {
        targetY += elementBounds.bottom;
        targetY -= elmHeight;
        targetY += offsetY;
      } else {
        targetY += elementBounds.top;
        targetY -= offsetY;
      }
      targetY = Math.max(Math.min(maxScrollY, targetY), 0);
      const deltaY = targetY - currentY;
      if (settings.justify === "center") {
        targetX += elementBounds.left + elementBounds.width / 2;
        targetX -= elmWidth / 2;
        targetX -= offsetX;
      } else if (settings.justify === "end") {
        targetX += elementBounds.right;
        targetX -= elmWidth;
        targetX += offsetX;
      } else {
        targetX += elementBounds.left;
        targetX -= offsetX;
      }
      targetX = Math.max(Math.min(maxScrollX, targetX), 0);
      const deltaX = targetX - currentX;
      const obj2 = {
        targetY,
        targetX,
        deltaY,
        deltaX,
        currentY,
        currentX,
        duration: settings.duration,
        easing: settings.easing,
        $elm: settings.$elm,
        onFinish() {
          settings.onFinish && settings.onFinish();
          resolve();
        },
        startTime: Date.now(),
        step: scrollTo.step
      };
      requestAnimationFrame(obj2.step.bind(obj2));
    });
  }
  scrollTo.step = function() {
    const t2 = Math.min((Date.now() - this.startTime) / this.duration, 1);
    let $scrollElm = this.$elm;
    if (this.$elm === document.body || this.$elm === document) {
      $scrollElm = window;
    }
    const x2 = this.targetX - (1 - this.easing(t2)) * this.deltaX;
    const y2 = this.targetY - (1 - this.easing(t2)) * this.deltaY;
    $scrollElm.scrollTo(x2, y2);
    if (userScrolling(this.$elm))
      return;
    if (t2 !== 1) {
      requestAnimationFrame(this.step.bind(this));
    } else {
      if (this.onFinish)
        this.onFinish();
    }
  };
  var e$3 = { version: "2.4.1" }, t$3 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function n$3(e2) {
    return e2 && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  function r$3(e2) {
    var t2 = { exports: {} };
    return e2(t2, t2.exports), t2.exports;
  }
  var i$3 = r$3(function(e2, t2) {
    function n2() {
    }
    function r2(e3, t3, n3, r3, i3) {
      for (var u2 = 0, o2 = t3.length, s2 = 0, a2 = 0; u2 < o2; u2++) {
        var c2 = t3[u2];
        if (c2.removed) {
          if (c2.value = e3.join(r3.slice(a2, a2 + c2.count)), a2 += c2.count, u2 && t3[u2 - 1].added) {
            var l2 = t3[u2 - 1];
            t3[u2 - 1] = t3[u2], t3[u2] = l2;
          }
        } else {
          if (!c2.added && i3) {
            var p2 = n3.slice(s2, s2 + c2.count);
            p2 = p2.map(function(e4, t4) {
              var n4 = r3[a2 + t4];
              return n4.length > e4.length ? n4 : e4;
            }), c2.value = e3.join(p2);
          } else
            c2.value = e3.join(n3.slice(s2, s2 + c2.count));
          s2 += c2.count, c2.added || (a2 += c2.count);
        }
      }
      var f2 = t3[o2 - 1];
      return o2 > 1 && typeof f2.value == "string" && (f2.added || f2.removed) && e3.equals("", f2.value) && (t3[o2 - 2].value += f2.value, t3.pop()), t3;
    }
    function i2(e3) {
      return { newPos: e3.newPos, components: e3.components.slice(0) };
    }
    Object.defineProperty(t2, "__esModule", { value: true }), t2.default = n2, n2.prototype = { diff: function(e3, t3) {
      var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u2 = n3.callback;
      typeof n3 == "function" && (u2 = n3, n3 = {}), this.options = n3;
      var o2 = this;
      function s2(e4) {
        return u2 ? (setTimeout(function() {
          u2(void 0, e4);
        }, 0), true) : e4;
      }
      e3 = this.castInput(e3), t3 = this.castInput(t3), e3 = this.removeEmpty(this.tokenize(e3));
      var a2 = (t3 = this.removeEmpty(this.tokenize(t3))).length, c2 = e3.length, l2 = 1, p2 = a2 + c2, f2 = [{ newPos: -1, components: [] }], d2 = this.extractCommon(f2[0], t3, e3, 0);
      if (f2[0].newPos + 1 >= a2 && d2 + 1 >= c2)
        return s2([{ value: this.join(t3), count: t3.length }]);
      function h2() {
        for (var n4 = -1 * l2; n4 <= l2; n4 += 2) {
          var u3 = void 0, p3 = f2[n4 - 1], d3 = f2[n4 + 1], h3 = (d3 ? d3.newPos : 0) - n4;
          p3 && (f2[n4 - 1] = void 0);
          var g3 = p3 && p3.newPos + 1 < a2, m2 = d3 && 0 <= h3 && h3 < c2;
          if (g3 || m2) {
            if (!g3 || m2 && p3.newPos < d3.newPos ? (u3 = i2(d3), o2.pushComponent(u3.components, void 0, true)) : ((u3 = p3).newPos++, o2.pushComponent(u3.components, true, void 0)), h3 = o2.extractCommon(u3, t3, e3, n4), u3.newPos + 1 >= a2 && h3 + 1 >= c2)
              return s2(r2(o2, u3.components, t3, e3, o2.useLongestToken));
            f2[n4] = u3;
          } else
            f2[n4] = void 0;
        }
        l2++;
      }
      if (u2)
        !function e4() {
          setTimeout(function() {
            if (l2 > p2)
              return u2();
            h2() || e4();
          }, 0);
        }();
      else
        for (; l2 <= p2; ) {
          var g2 = h2();
          if (g2)
            return g2;
        }
    }, pushComponent: function(e3, t3, n3) {
      var r3 = e3[e3.length - 1];
      r3 && r3.added === t3 && r3.removed === n3 ? e3[e3.length - 1] = { count: r3.count + 1, added: t3, removed: n3 } : e3.push({ count: 1, added: t3, removed: n3 });
    }, extractCommon: function(e3, t3, n3, r3) {
      for (var i3 = t3.length, u2 = n3.length, o2 = e3.newPos, s2 = o2 - r3, a2 = 0; o2 + 1 < i3 && s2 + 1 < u2 && this.equals(t3[o2 + 1], n3[s2 + 1]); )
        o2++, s2++, a2++;
      return a2 && e3.components.push({ count: a2 }), e3.newPos = o2, s2;
    }, equals: function(e3, t3) {
      return this.options.comparator ? this.options.comparator(e3, t3) : e3 === t3 || this.options.ignoreCase && e3.toLowerCase() === t3.toLowerCase();
    }, removeEmpty: function(e3) {
      for (var t3 = [], n3 = 0; n3 < e3.length; n3++)
        e3[n3] && t3.push(e3[n3]);
      return t3;
    }, castInput: function(e3) {
      return e3;
    }, tokenize: function(e3) {
      return e3.split("");
    }, join: function(e3) {
      return e3.join("");
    } };
  }), u$3 = r$3(function(e2, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", { value: true }), t2.diffChars = function(e3, t3, n3) {
      return r2.diff(e3, t3, n3);
    }, t2.characterDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
    t2.characterDiff = r2;
  }), o$3 = function(e2, t2) {
    if (typeof e2 == "function")
      t2.callback = e2;
    else if (e2)
      for (var n2 in e2)
        e2.hasOwnProperty(n2) && (t2[n2] = e2[n2]);
    return t2;
  };
  var s$3, a$3, c$3 = Object.defineProperty({ generateOptions: o$3 }, "__esModule", { value: true }), l$3 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), t2.diffWords = function(e3, t3, n3) {
      return n3 = (0, c$3.generateOptions)(n3, { ignoreWhitespace: true }), s2.diff(e3, t3, n3);
    }, t2.diffWordsWithSpace = function(e3, t3, n3) {
      return s2.diff(e3, t3, n3);
    }, t2.wordDiff = void 0;
    var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : { default: n2 };
    var u2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, o2 = /\S/, s2 = new r2.default();
    t2.wordDiff = s2, s2.equals = function(e3, t3) {
      return this.options.ignoreCase && (e3 = e3.toLowerCase(), t3 = t3.toLowerCase()), e3 === t3 || this.options.ignoreWhitespace && !o2.test(e3) && !o2.test(t3);
    }, s2.tokenize = function(e3) {
      for (var t3 = e3.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n3 = 0; n3 < t3.length - 1; n3++)
        !t3[n3 + 1] && t3[n3 + 2] && u2.test(t3[n3]) && u2.test(t3[n3 + 2]) && (t3[n3] += t3[n3 + 2], t3.splice(n3 + 1, 2), n3--);
      return t3;
    };
  }), p$3 = r$3(function(e2, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", { value: true }), t2.diffLines = function(e3, t3, n3) {
      return r2.diff(e3, t3, n3);
    }, t2.diffTrimmedLines = function(e3, t3, n3) {
      var i2 = (0, c$3.generateOptions)(n3, { ignoreWhitespace: true });
      return r2.diff(e3, t3, i2);
    }, t2.lineDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
    t2.lineDiff = r2, r2.tokenize = function(e3) {
      var t3 = [], n3 = e3.split(/(\n|\r\n)/);
      n3[n3.length - 1] || n3.pop();
      for (var r3 = 0; r3 < n3.length; r3++) {
        var i2 = n3[r3];
        r3 % 2 && !this.options.newlineIsToken ? t3[t3.length - 1] += i2 : (this.options.ignoreWhitespace && (i2 = i2.trim()), t3.push(i2));
      }
      return t3;
    };
  }), f$3 = r$3(function(e2, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", { value: true }), t2.diffSentences = function(e3, t3, n3) {
      return r2.diff(e3, t3, n3);
    }, t2.sentenceDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
    t2.sentenceDiff = r2, r2.tokenize = function(e3) {
      return e3.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
  }), d$3 = r$3(function(e2, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", { value: true }), t2.diffCss = function(e3, t3, n3) {
      return r2.diff(e3, t3, n3);
    }, t2.cssDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
    t2.cssDiff = r2, r2.tokenize = function(e3) {
      return e3.split(/([{}:;,]|\s+)/);
    };
  }), h$3 = function(e2) {
    return e2 && e2.Math == Math && e2;
  }, g$3 = h$3(typeof globalThis == "object" && globalThis) || h$3(typeof window == "object" && window) || h$3(typeof self == "object" && self) || h$3(typeof t$3 == "object" && t$3) || function() {
    return this;
  }() || Function("return this")(), m$3 = function(e2) {
    try {
      return !!e2();
    } catch (e3) {
      return true;
    }
  }, y$3 = !m$3(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  }), D$3 = {}.propertyIsEnumerable, E$3 = Object.getOwnPropertyDescriptor, C$3 = { f: E$3 && !D$3.call({ 1: 2 }, 1) ? function(e2) {
    var t2 = E$3(this, e2);
    return !!t2 && t2.enumerable;
  } : D$3 }, b$3 = function(e2, t2) {
    return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
  }, A$3 = {}.toString, v$3 = function(e2) {
    return A$3.call(e2).slice(8, -1);
  }, F$3 = "".split, S$3 = m$3(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e2) {
    return v$3(e2) == "String" ? F$3.call(e2, "") : Object(e2);
  } : Object, x$3 = function(e2) {
    if (e2 == null)
      throw TypeError("Can't call method on " + e2);
    return e2;
  }, w$3 = function(e2) {
    return S$3(x$3(e2));
  }, T$3 = function(e2) {
    return typeof e2 == "object" ? e2 !== null : typeof e2 == "function";
  }, B$3 = function(e2) {
    return typeof e2 == "function" ? e2 : void 0;
  }, N$3 = function(e2, t2) {
    return arguments.length < 2 ? B$3(g$3[e2]) : g$3[e2] && g$3[e2][t2];
  }, k$3 = N$3("navigator", "userAgent") || "", P$3 = g$3.process, O$3 = g$3.Deno, I$3 = P$3 && P$3.versions || O$3 && O$3.version, L$3 = I$3 && I$3.v8;
  L$3 ? a$3 = (s$3 = L$3.split("."))[0] < 4 ? 1 : s$3[0] + s$3[1] : k$3 && (!(s$3 = k$3.match(/Edge\/(\d+)/)) || s$3[1] >= 74) && (s$3 = k$3.match(/Chrome\/(\d+)/)) && (a$3 = s$3[1]);
  var j$4 = a$3 && +a$3, _$3 = !!Object.getOwnPropertySymbols && !m$3(function() {
    var e2 = Symbol();
    return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && j$4 && j$4 < 41;
  }), M$3 = _$3 && !Symbol.sham && typeof Symbol.iterator == "symbol", R$3 = M$3 ? function(e2) {
    return typeof e2 == "symbol";
  } : function(e2) {
    var t2 = N$3("Symbol");
    return typeof t2 == "function" && Object(e2) instanceof t2;
  }, $$3 = function(e2, t2) {
    try {
      Object.defineProperty(g$3, e2, { value: t2, configurable: true, writable: true });
    } catch (n2) {
      g$3[e2] = t2;
    }
    return t2;
  }, V$3 = g$3["__core-js_shared__"] || $$3("__core-js_shared__", {}), W$3 = r$3(function(e2) {
    (e2.exports = function(e3, t2) {
      return V$3[e3] || (V$3[e3] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({ version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
  }), q$3 = function(e2) {
    return Object(x$3(e2));
  }, U$3 = {}.hasOwnProperty, z$3 = Object.hasOwn || function(e2, t2) {
    return U$3.call(q$3(e2), t2);
  }, G$3 = 0, H$3 = Math.random(), J$3 = function(e2) {
    return "Symbol(" + String(e2 === void 0 ? "" : e2) + ")_" + (++G$3 + H$3).toString(36);
  }, X$3 = W$3("wks"), Y$3 = g$3.Symbol, K$3 = M$3 ? Y$3 : Y$3 && Y$3.withoutSetter || J$3, Q$3 = function(e2) {
    return z$3(X$3, e2) && (_$3 || typeof X$3[e2] == "string") || (_$3 && z$3(Y$3, e2) ? X$3[e2] = Y$3[e2] : X$3[e2] = K$3("Symbol." + e2)), X$3[e2];
  }, Z$3 = Q$3("toPrimitive"), ee$3 = function(e2, t2) {
    if (!T$3(e2) || R$3(e2))
      return e2;
    var n2, r2 = e2[Z$3];
    if (r2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), n2 = r2.call(e2, t2), !T$3(n2) || R$3(n2))
        return n2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e3, t3) {
      var n3, r3;
      if (t3 === "string" && typeof (n3 = e3.toString) == "function" && !T$3(r3 = n3.call(e3)))
        return r3;
      if (typeof (n3 = e3.valueOf) == "function" && !T$3(r3 = n3.call(e3)))
        return r3;
      if (t3 !== "string" && typeof (n3 = e3.toString) == "function" && !T$3(r3 = n3.call(e3)))
        return r3;
      throw TypeError("Can't convert object to primitive value");
    }(e2, t2);
  }, te$3 = function(e2) {
    var t2 = ee$3(e2, "string");
    return R$3(t2) ? t2 : String(t2);
  }, ne$3 = g$3.document, re$3 = T$3(ne$3) && T$3(ne$3.createElement), ie$3 = !y$3 && !m$3(function() {
    return Object.defineProperty((e2 = "div", re$3 ? ne$3.createElement(e2) : {}), "a", { get: function() {
      return 7;
    } }).a != 7;
    var e2;
  }), ue$3 = Object.getOwnPropertyDescriptor, oe$3 = { f: y$3 ? ue$3 : function(e2, t2) {
    if (e2 = w$3(e2), t2 = te$3(t2), ie$3)
      try {
        return ue$3(e2, t2);
      } catch (e3) {
      }
    if (z$3(e2, t2))
      return b$3(!C$3.f.call(e2, t2), e2[t2]);
  } }, se$3 = function(e2) {
    if (!T$3(e2))
      throw TypeError(String(e2) + " is not an object");
    return e2;
  }, ae$3 = Object.defineProperty, ce$3 = { f: y$3 ? ae$3 : function(e2, t2, n2) {
    if (se$3(e2), t2 = te$3(t2), se$3(n2), ie$3)
      try {
        return ae$3(e2, t2, n2);
      } catch (e3) {
      }
    if ("get" in n2 || "set" in n2)
      throw TypeError("Accessors not supported");
    return "value" in n2 && (e2[t2] = n2.value), e2;
  } }, le$3 = y$3 ? function(e2, t2, n2) {
    return ce$3.f(e2, t2, b$3(1, n2));
  } : function(e2, t2, n2) {
    return e2[t2] = n2, e2;
  }, pe$3 = Function.toString;
  typeof V$3.inspectSource != "function" && (V$3.inspectSource = function(e2) {
    return pe$3.call(e2);
  });
  var fe$3, de$3, he$3, ge$3, me$3 = V$3.inspectSource, ye$3 = g$3.WeakMap, De$3 = typeof ye$3 == "function" && /native code/.test(me$3(ye$3)), Ee$3 = W$3("keys"), Ce$3 = {}, be$3 = g$3.WeakMap;
  if (De$3 || V$3.state) {
    var Ae$3 = V$3.state || (V$3.state = new be$3()), ve$3 = Ae$3.get, Fe$3 = Ae$3.has, Se$3 = Ae$3.set;
    fe$3 = function(e2, t2) {
      if (Fe$3.call(Ae$3, e2))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, Se$3.call(Ae$3, e2, t2), t2;
    }, de$3 = function(e2) {
      return ve$3.call(Ae$3, e2) || {};
    }, he$3 = function(e2) {
      return Fe$3.call(Ae$3, e2);
    };
  } else {
    var xe$3 = Ee$3[ge$3 = "state"] || (Ee$3[ge$3] = J$3(ge$3));
    Ce$3[xe$3] = true, fe$3 = function(e2, t2) {
      if (z$3(e2, xe$3))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, le$3(e2, xe$3, t2), t2;
    }, de$3 = function(e2) {
      return z$3(e2, xe$3) ? e2[xe$3] : {};
    }, he$3 = function(e2) {
      return z$3(e2, xe$3);
    };
  }
  var we$3, Te$3, Be$3 = { set: fe$3, get: de$3, has: he$3, enforce: function(e2) {
    return he$3(e2) ? de$3(e2) : fe$3(e2, {});
  }, getterFor: function(e2) {
    return function(t2) {
      var n2;
      if (!T$3(t2) || (n2 = de$3(t2)).type !== e2)
        throw TypeError("Incompatible receiver, " + e2 + " required");
      return n2;
    };
  } }, Ne$3 = r$3(function(e2) {
    var t2 = Be$3.get, n2 = Be$3.enforce, r2 = String(String).split("String");
    (e2.exports = function(e3, t3, i2, u2) {
      var o2, s2 = !!u2 && !!u2.unsafe, a2 = !!u2 && !!u2.enumerable, c2 = !!u2 && !!u2.noTargetGet;
      typeof i2 == "function" && (typeof t3 != "string" || z$3(i2, "name") || le$3(i2, "name", t3), (o2 = n2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e3 !== g$3 ? (s2 ? !c2 && e3[t3] && (a2 = true) : delete e3[t3], a2 ? e3[t3] = i2 : le$3(e3, t3, i2)) : a2 ? e3[t3] = i2 : $$3(t3, i2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || me$3(this);
    });
  }), ke$3 = Math.ceil, Pe$3 = Math.floor, Oe$3 = function(e2) {
    return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? Pe$3 : ke$3)(e2);
  }, Ie$3 = Math.min, Le$3 = function(e2) {
    return e2 > 0 ? Ie$3(Oe$3(e2), 9007199254740991) : 0;
  }, je$3 = Math.max, _e$3 = Math.min, Me$3 = function(e2) {
    return function(t2, n2, r2) {
      var i2, u2 = w$3(t2), o2 = Le$3(u2.length), s2 = function(e3, t3) {
        var n3 = Oe$3(e3);
        return n3 < 0 ? je$3(n3 + t3, 0) : _e$3(n3, t3);
      }(r2, o2);
      if (e2 && n2 != n2) {
        for (; o2 > s2; )
          if ((i2 = u2[s2++]) != i2)
            return true;
      } else
        for (; o2 > s2; s2++)
          if ((e2 || s2 in u2) && u2[s2] === n2)
            return e2 || s2 || 0;
      return !e2 && -1;
    };
  }, Re$3 = { includes: Me$3(true), indexOf: Me$3(false) }.indexOf, $e$3 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ve$3 = { f: Object.getOwnPropertyNames || function(e2) {
    return function(e3, t2) {
      var n2, r2 = w$3(e3), i2 = 0, u2 = [];
      for (n2 in r2)
        !z$3(Ce$3, n2) && z$3(r2, n2) && u2.push(n2);
      for (; t2.length > i2; )
        z$3(r2, n2 = t2[i2++]) && (~Re$3(u2, n2) || u2.push(n2));
      return u2;
    }(e2, $e$3);
  } }, We$3 = { f: Object.getOwnPropertySymbols }, qe$3 = N$3("Reflect", "ownKeys") || function(e2) {
    var t2 = Ve$3.f(se$3(e2)), n2 = We$3.f;
    return n2 ? t2.concat(n2(e2)) : t2;
  }, Ue$3 = function(e2, t2) {
    for (var n2 = qe$3(t2), r2 = ce$3.f, i2 = oe$3.f, u2 = 0; u2 < n2.length; u2++) {
      var o2 = n2[u2];
      z$3(e2, o2) || r2(e2, o2, i2(t2, o2));
    }
  }, ze$3 = /#|\.prototype\./, Ge$3 = function(e2, t2) {
    var n2 = Je$3[He$3(e2)];
    return n2 == Ye$3 || n2 != Xe$3 && (typeof t2 == "function" ? m$3(t2) : !!t2);
  }, He$3 = Ge$3.normalize = function(e2) {
    return String(e2).replace(ze$3, ".").toLowerCase();
  }, Je$3 = Ge$3.data = {}, Xe$3 = Ge$3.NATIVE = "N", Ye$3 = Ge$3.POLYFILL = "P", Ke$3 = Ge$3, Qe$3 = oe$3.f, Ze$3 = function(e2, t2) {
    var n2, r2, i2, u2, o2, s2 = e2.target, a2 = e2.global, c2 = e2.stat;
    if (n2 = a2 ? g$3 : c2 ? g$3[s2] || $$3(s2, {}) : (g$3[s2] || {}).prototype)
      for (r2 in t2) {
        if (u2 = t2[r2], i2 = e2.noTargetGet ? (o2 = Qe$3(n2, r2)) && o2.value : n2[r2], !Ke$3(a2 ? r2 : s2 + (c2 ? "." : "#") + r2, e2.forced) && i2 !== void 0) {
          if (typeof u2 == typeof i2)
            continue;
          Ue$3(u2, i2);
        }
        (e2.sham || i2 && i2.sham) && le$3(u2, "sham", true), Ne$3(n2, r2, u2, e2);
      }
  }, et$3 = function(e2) {
    if (typeof e2 != "function")
      throw TypeError(String(e2) + " is not a function");
    return e2;
  }, tt$3 = function(e2) {
    if (R$3(e2))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e2);
  }, nt$3 = Math.floor, rt$3 = function(e2, t2) {
    var n2 = e2.length, r2 = nt$3(n2 / 2);
    return n2 < 8 ? it$3(e2, t2) : ut$3(rt$3(e2.slice(0, r2), t2), rt$3(e2.slice(r2), t2), t2);
  }, it$3 = function(e2, t2) {
    for (var n2, r2, i2 = e2.length, u2 = 1; u2 < i2; ) {
      for (r2 = u2, n2 = e2[u2]; r2 && t2(e2[r2 - 1], n2) > 0; )
        e2[r2] = e2[--r2];
      r2 !== u2++ && (e2[r2] = n2);
    }
    return e2;
  }, ut$3 = function(e2, t2, n2) {
    for (var r2 = e2.length, i2 = t2.length, u2 = 0, o2 = 0, s2 = []; u2 < r2 || o2 < i2; )
      u2 < r2 && o2 < i2 ? s2.push(n2(e2[u2], t2[o2]) <= 0 ? e2[u2++] : t2[o2++]) : s2.push(u2 < r2 ? e2[u2++] : t2[o2++]);
    return s2;
  }, ot$3 = rt$3, st$3 = k$3.match(/firefox\/(\d+)/i), at$3 = !!st$3 && +st$3[1], ct$3 = /MSIE|Trident/.test(k$3), lt$3 = k$3.match(/AppleWebKit\/(\d+)\./), pt$3 = !!lt$3 && +lt$3[1], ft$3 = [], dt$3 = ft$3.sort, ht$3 = m$3(function() {
    ft$3.sort(void 0);
  }), gt$3 = m$3(function() {
    ft$3.sort(null);
  }), mt$3 = !!(Te$3 = []["sort"]) && m$3(function() {
    Te$3.call(null, we$3 || function() {
      throw 1;
    }, 1);
  }), yt$3 = !m$3(function() {
    if (j$4)
      return j$4 < 70;
    if (!(at$3 && at$3 > 3)) {
      if (ct$3)
        return true;
      if (pt$3)
        return pt$3 < 603;
      var e2, t2, n2, r2, i2 = "";
      for (e2 = 65; e2 < 76; e2++) {
        switch (t2 = String.fromCharCode(e2), e2) {
          case 66:
          case 69:
          case 70:
          case 72:
            n2 = 3;
            break;
          case 68:
          case 71:
            n2 = 4;
            break;
          default:
            n2 = 2;
        }
        for (r2 = 0; r2 < 47; r2++)
          ft$3.push({ k: t2 + r2, v: n2 });
      }
      for (ft$3.sort(function(e3, t3) {
        return t3.v - e3.v;
      }), r2 = 0; r2 < ft$3.length; r2++)
        t2 = ft$3[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
      return i2 !== "DGBEFHACIJK";
    }
  });
  Ze$3({ target: "Array", proto: true, forced: ht$3 || !gt$3 || !mt$3 || !yt$3 }, { sort: function(e2) {
    e2 !== void 0 && et$3(e2);
    var t2 = q$3(this);
    if (yt$3)
      return e2 === void 0 ? dt$3.call(t2) : dt$3.call(t2, e2);
    var n2, r2, i2 = [], u2 = Le$3(t2.length);
    for (r2 = 0; r2 < u2; r2++)
      r2 in t2 && i2.push(t2[r2]);
    for (n2 = (i2 = ot$3(i2, function(e3) {
      return function(t3, n3) {
        return n3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, n3) || 0 : tt$3(t3) > tt$3(n3) ? 1 : -1;
      };
    }(e2))).length, r2 = 0; r2 < n2; )
      t2[r2] = i2[r2++];
    for (; r2 < u2; )
      delete t2[r2++];
    return t2;
  } });
  var Dt$3 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), t2.diffJson = function(e3, t3, n3) {
      return s2.diff(e3, t3, n3);
    }, t2.canonicalize = a2, t2.jsonDiff = void 0;
    var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : { default: n2 };
    function u2(e3) {
      return (u2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
        return typeof e4;
      } : function(e4) {
        return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
      })(e3);
    }
    var o2 = Object.prototype.toString, s2 = new r2.default();
    function a2(e3, t3, n3, r3, i2) {
      var s3, c2;
      for (t3 = t3 || [], n3 = n3 || [], r3 && (e3 = r3(i2, e3)), s3 = 0; s3 < t3.length; s3 += 1)
        if (t3[s3] === e3)
          return n3[s3];
      if (o2.call(e3) === "[object Array]") {
        for (t3.push(e3), c2 = new Array(e3.length), n3.push(c2), s3 = 0; s3 < e3.length; s3 += 1)
          c2[s3] = a2(e3[s3], t3, n3, r3, i2);
        return t3.pop(), n3.pop(), c2;
      }
      if (e3 && e3.toJSON && (e3 = e3.toJSON()), u2(e3) === "object" && e3 !== null) {
        t3.push(e3), c2 = {}, n3.push(c2);
        var l2, p2 = [];
        for (l2 in e3)
          e3.hasOwnProperty(l2) && p2.push(l2);
        for (p2.sort(), s3 = 0; s3 < p2.length; s3 += 1)
          c2[l2 = p2[s3]] = a2(e3[l2], t3, n3, r3, l2);
        t3.pop(), n3.pop();
      } else
        c2 = e3;
      return c2;
    }
    t2.jsonDiff = s2, s2.useLongestToken = true, s2.tokenize = p$3.lineDiff.tokenize, s2.castInput = function(e3) {
      var t3 = this.options, n3 = t3.undefinedReplacement, r3 = t3.stringifyReplacer, i2 = r3 === void 0 ? function(e4, t4) {
        return t4 === void 0 ? n3 : t4;
      } : r3;
      return typeof e3 == "string" ? e3 : JSON.stringify(a2(e3, null, null, i2), i2, "  ");
    }, s2.equals = function(e3, t3) {
      return r2.default.prototype.equals.call(s2, e3.replace(/,([\r\n])/g, "$1"), t3.replace(/,([\r\n])/g, "$1"));
    };
  }), Et$3 = r$3(function(e2, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", { value: true }), t2.diffArrays = function(e3, t3, n3) {
      return r2.diff(e3, t3, n3);
    }, t2.arrayDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
    t2.arrayDiff = r2, r2.tokenize = function(e3) {
      return e3.slice();
    }, r2.join = r2.removeEmpty = function(e3) {
      return e3;
    };
  }), Ct$3 = function(e2) {
    var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e2.split(/\r\n|[\n\v\f\r\x85]/), r2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], i2 = [], u2 = 0;
    function o2() {
      var e3 = {};
      for (i2.push(e3); u2 < n2.length; ) {
        var r3 = n2[u2];
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
          break;
        var o3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
        o3 && (e3.index = o3[1]), u2++;
      }
      for (s2(e3), s2(e3), e3.hunks = []; u2 < n2.length; ) {
        var c2 = n2[u2];
        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c2))
          break;
        if (/^@@/.test(c2))
          e3.hunks.push(a2());
        else {
          if (c2 && t2.strict)
            throw new Error("Unknown line " + (u2 + 1) + " " + JSON.stringify(c2));
          u2++;
        }
      }
    }
    function s2(e3) {
      var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[u2]);
      if (t3) {
        var r3 = t3[1] === "---" ? "old" : "new", i3 = t3[2].split("	", 2), o3 = i3[0].replace(/\\\\/g, "\\");
        /^".*"$/.test(o3) && (o3 = o3.substr(1, o3.length - 2)), e3[r3 + "FileName"] = o3, e3[r3 + "Header"] = (i3[1] || "").trim(), u2++;
      }
    }
    function a2() {
      var e3 = u2, i3 = n2[u2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), o3 = { oldStart: +i3[1], oldLines: i3[2] === void 0 ? 1 : +i3[2], newStart: +i3[3], newLines: i3[4] === void 0 ? 1 : +i3[4], lines: [], linedelimiters: [] };
      o3.oldLines === 0 && (o3.oldStart += 1), o3.newLines === 0 && (o3.newStart += 1);
      for (var s3 = 0, a3 = 0; u2 < n2.length && !(n2[u2].indexOf("--- ") === 0 && u2 + 2 < n2.length && n2[u2 + 1].indexOf("+++ ") === 0 && n2[u2 + 2].indexOf("@@") === 0); u2++) {
        var c2 = n2[u2].length == 0 && u2 != n2.length - 1 ? " " : n2[u2][0];
        if (c2 !== "+" && c2 !== "-" && c2 !== " " && c2 !== "\\")
          break;
        o3.lines.push(n2[u2]), o3.linedelimiters.push(r2[u2] || "\n"), c2 === "+" ? s3++ : c2 === "-" ? a3++ : c2 === " " && (s3++, a3++);
      }
      if (s3 || o3.newLines !== 1 || (o3.newLines = 0), a3 || o3.oldLines !== 1 || (o3.oldLines = 0), t2.strict) {
        if (s3 !== o3.newLines)
          throw new Error("Added line count did not match for hunk at line " + (e3 + 1));
        if (a3 !== o3.oldLines)
          throw new Error("Removed line count did not match for hunk at line " + (e3 + 1));
      }
      return o3;
    }
    for (; u2 < n2.length; )
      o2();
    return i2;
  };
  var bt$3, At$3 = Object.defineProperty({ parsePatch: Ct$3 }, "__esModule", { value: true }), vt$3 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n2) {
      var r2 = true, i2 = false, u2 = false, o2 = 1;
      return function s2() {
        if (r2 && !u2) {
          if (i2 ? o2++ : r2 = false, e3 + o2 <= n2)
            return o2;
          u2 = true;
        }
        if (!i2)
          return u2 || (r2 = true), t3 <= e3 - o2 ? -o2++ : (i2 = true, s2());
      };
    };
  }), Ft$3 = wt$3, St$2 = function(e2, t2) {
    typeof e2 == "string" && (e2 = (0, At$3.parsePatch)(e2));
    var n2 = 0;
    !function r2() {
      var i2 = e2[n2++];
      if (!i2)
        return t2.complete();
      t2.loadFile(i2, function(e3, n3) {
        if (e3)
          return t2.complete(e3);
        var u2 = wt$3(n3, i2, t2);
        t2.patched(i2, u2, function(e4) {
          if (e4)
            return t2.complete(e4);
          r2();
        });
      });
    }();
  }, xt$3 = (bt$3 = vt$3) && bt$3.__esModule ? bt$3 : { default: bt$3 };
  function wt$3(e2, t2) {
    var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof t2 == "string" && (t2 = (0, At$3.parsePatch)(t2)), Array.isArray(t2)) {
      if (t2.length > 1)
        throw new Error("applyPatch only works with a single input.");
      t2 = t2[0];
    }
    var r2, i2, u2 = e2.split(/\r\n|[\n\v\f\r\x85]/), o2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], s2 = t2.hunks, a2 = n2.compareLine || function(e3, t3, n3, r3) {
      return t3 === r3;
    }, c2 = 0, l2 = n2.fuzzFactor || 0, p2 = 0, f2 = 0;
    function d2(e3, t3) {
      for (var n3 = 0; n3 < e3.lines.length; n3++) {
        var r3 = e3.lines[n3], i3 = r3.length > 0 ? r3[0] : " ", o3 = r3.length > 0 ? r3.substr(1) : r3;
        if (i3 === " " || i3 === "-") {
          if (!a2(t3 + 1, u2[t3], i3, o3) && ++c2 > l2)
            return false;
          t3++;
        }
      }
      return true;
    }
    for (var h2 = 0; h2 < s2.length; h2++) {
      for (var g2 = s2[h2], m2 = u2.length - g2.oldLines, y2 = 0, D2 = f2 + g2.oldStart - 1, E2 = (0, xt$3.default)(D2, p2, m2); y2 !== void 0; y2 = E2())
        if (d2(g2, D2 + y2)) {
          g2.offset = f2 += y2;
          break;
        }
      if (y2 === void 0)
        return false;
      p2 = g2.offset + g2.oldStart + g2.oldLines;
    }
    for (var C2 = 0, b2 = 0; b2 < s2.length; b2++) {
      var A2 = s2[b2], v2 = A2.oldStart + A2.offset + C2 - 1;
      C2 += A2.newLines - A2.oldLines;
      for (var F2 = 0; F2 < A2.lines.length; F2++) {
        var S2 = A2.lines[F2], x2 = S2.length > 0 ? S2[0] : " ", w2 = S2.length > 0 ? S2.substr(1) : S2, T2 = A2.linedelimiters[F2];
        if (x2 === " ")
          v2++;
        else if (x2 === "-")
          u2.splice(v2, 1), o2.splice(v2, 1);
        else if (x2 === "+")
          u2.splice(v2, 0, w2), o2.splice(v2, 0, T2), v2++;
        else if (x2 === "\\") {
          var B2 = A2.lines[F2 - 1] ? A2.lines[F2 - 1][0] : null;
          B2 === "+" ? r2 = true : B2 === "-" && (i2 = true);
        }
      }
    }
    if (r2)
      for (; !u2[u2.length - 1]; )
        u2.pop(), o2.pop();
    else
      i2 && (u2.push(""), o2.push("\n"));
    for (var N2 = 0; N2 < u2.length - 1; N2++)
      u2[N2] = u2[N2] + o2[N2];
    return u2.join("");
  }
  var Tt$2 = Object.defineProperty({ applyPatch: Ft$3, applyPatches: St$2 }, "__esModule", { value: true }), Bt$2 = Lt$2, Nt$2 = jt$2, kt$3 = _t$2, Pt$2 = function(e2, t2, n2, r2, i2, u2) {
    return _t$2(e2, e2, t2, n2, r2, i2, u2);
  };
  function Ot$3(e2) {
    return function(e3) {
      if (Array.isArray(e3))
        return It$2(e3);
    }(e2) || function(e3) {
      if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
        return Array.from(e3);
    }(e2) || function(e3, t2) {
      if (!e3)
        return;
      if (typeof e3 == "string")
        return It$2(e3, t2);
      var n2 = Object.prototype.toString.call(e3).slice(8, -1);
      n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
      if (n2 === "Map" || n2 === "Set")
        return Array.from(e3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return It$2(e3, t2);
    }(e2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function It$2(e2, t2) {
    (t2 == null || t2 > e2.length) && (t2 = e2.length);
    for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
      r2[n2] = e2[n2];
    return r2;
  }
  function Lt$2(e2, t2, n2, r2, i2, u2, o2) {
    o2 || (o2 = {}), o2.context === void 0 && (o2.context = 4);
    var s2 = (0, p$3.diffLines)(n2, r2, o2);
    function a2(e3) {
      return e3.map(function(e4) {
        return " " + e4;
      });
    }
    s2.push({ value: "", lines: [] });
    for (var c2 = [], l2 = 0, f2 = 0, d2 = [], h2 = 1, g2 = 1, m2 = function(e3) {
      var t3 = s2[e3], i3 = t3.lines || t3.value.replace(/\n$/, "").split("\n");
      if (t3.lines = i3, t3.added || t3.removed) {
        var u3;
        if (!l2) {
          var p2 = s2[e3 - 1];
          l2 = h2, f2 = g2, p2 && (d2 = o2.context > 0 ? a2(p2.lines.slice(-o2.context)) : [], l2 -= d2.length, f2 -= d2.length);
        }
        (u3 = d2).push.apply(u3, Ot$3(i3.map(function(e4) {
          return (t3.added ? "+" : "-") + e4;
        }))), t3.added ? g2 += i3.length : h2 += i3.length;
      } else {
        if (l2)
          if (i3.length <= 2 * o2.context && e3 < s2.length - 2) {
            var m3;
            (m3 = d2).push.apply(m3, Ot$3(a2(i3)));
          } else {
            var y3, D2 = Math.min(i3.length, o2.context);
            (y3 = d2).push.apply(y3, Ot$3(a2(i3.slice(0, D2))));
            var E2 = { oldStart: l2, oldLines: h2 - l2 + D2, newStart: f2, newLines: g2 - f2 + D2, lines: d2 };
            if (e3 >= s2.length - 2 && i3.length <= o2.context) {
              var C2 = /\n$/.test(n2), b2 = /\n$/.test(r2), A2 = i3.length == 0 && d2.length > E2.oldLines;
              !C2 && A2 && n2.length > 0 && d2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C2 || A2) && b2 || d2.push("\\ No newline at end of file");
            }
            c2.push(E2), l2 = 0, f2 = 0, d2 = [];
          }
        h2 += i3.length, g2 += i3.length;
      }
    }, y2 = 0; y2 < s2.length; y2++)
      m2(y2);
    return { oldFileName: e2, newFileName: t2, oldHeader: i2, newHeader: u2, hunks: c2 };
  }
  function jt$2(e2) {
    var t2 = [];
    e2.oldFileName == e2.newFileName && t2.push("Index: " + e2.oldFileName), t2.push("==================================================================="), t2.push("--- " + e2.oldFileName + (e2.oldHeader === void 0 ? "" : "	" + e2.oldHeader)), t2.push("+++ " + e2.newFileName + (e2.newHeader === void 0 ? "" : "	" + e2.newHeader));
    for (var n2 = 0; n2 < e2.hunks.length; n2++) {
      var r2 = e2.hunks[n2];
      r2.oldLines === 0 && (r2.oldStart -= 1), r2.newLines === 0 && (r2.newStart -= 1), t2.push("@@ -" + r2.oldStart + "," + r2.oldLines + " +" + r2.newStart + "," + r2.newLines + " @@"), t2.push.apply(t2, r2.lines);
    }
    return t2.join("\n") + "\n";
  }
  function _t$2(e2, t2, n2, r2, i2, u2, o2) {
    return jt$2(Lt$2(e2, t2, n2, r2, i2, u2, o2));
  }
  var Mt$2 = Object.defineProperty({ structuredPatch: Bt$2, formatPatch: Nt$2, createTwoFilesPatch: kt$3, createPatch: Pt$2 }, "__esModule", { value: true }), Rt$2 = function(e2, t2) {
    if (e2.length !== t2.length)
      return false;
    return Vt$2(e2, t2);
  }, $t$2 = Vt$2;
  function Vt$2(e2, t2) {
    if (t2.length > e2.length)
      return false;
    for (var n2 = 0; n2 < t2.length; n2++)
      if (t2[n2] !== e2[n2])
        return false;
    return true;
  }
  var Wt$2 = Object.defineProperty({ arrayEqual: Rt$2, arrayStartsWith: $t$2 }, "__esModule", { value: true }), qt$2 = Ht$2, Ut$2 = function(e2, t2, n2) {
    e2 = Jt$2(e2, n2), t2 = Jt$2(t2, n2);
    var r2 = {};
    (e2.index || t2.index) && (r2.index = e2.index || t2.index);
    (e2.newFileName || t2.newFileName) && (Xt$2(e2) ? Xt$2(t2) ? (r2.oldFileName = Yt$2(r2, e2.oldFileName, t2.oldFileName), r2.newFileName = Yt$2(r2, e2.newFileName, t2.newFileName), r2.oldHeader = Yt$2(r2, e2.oldHeader, t2.oldHeader), r2.newHeader = Yt$2(r2, e2.newHeader, t2.newHeader)) : (r2.oldFileName = e2.oldFileName, r2.newFileName = e2.newFileName, r2.oldHeader = e2.oldHeader, r2.newHeader = e2.newHeader) : (r2.oldFileName = t2.oldFileName || e2.oldFileName, r2.newFileName = t2.newFileName || e2.newFileName, r2.oldHeader = t2.oldHeader || e2.oldHeader, r2.newHeader = t2.newHeader || e2.newHeader));
    r2.hunks = [];
    var i2 = 0, u2 = 0, o2 = 0, s2 = 0;
    for (; i2 < e2.hunks.length || u2 < t2.hunks.length; ) {
      var a2 = e2.hunks[i2] || { oldStart: 1 / 0 }, c2 = t2.hunks[u2] || { oldStart: 1 / 0 };
      if (Kt$2(a2, c2))
        r2.hunks.push(Qt$2(a2, o2)), i2++, s2 += a2.newLines - a2.oldLines;
      else if (Kt$2(c2, a2))
        r2.hunks.push(Qt$2(c2, s2)), u2++, o2 += c2.newLines - c2.oldLines;
      else {
        var l2 = { oldStart: Math.min(a2.oldStart, c2.oldStart), oldLines: 0, newStart: Math.min(a2.newStart + o2, c2.oldStart + s2), newLines: 0, lines: [] };
        Zt$2(l2, a2.oldStart, a2.lines, c2.oldStart, c2.lines), u2++, i2++, r2.hunks.push(l2);
      }
    }
    return r2;
  };
  function zt$2(e2) {
    return function(e3) {
      if (Array.isArray(e3))
        return Gt$2(e3);
    }(e2) || function(e3) {
      if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
        return Array.from(e3);
    }(e2) || function(e3, t2) {
      if (!e3)
        return;
      if (typeof e3 == "string")
        return Gt$2(e3, t2);
      var n2 = Object.prototype.toString.call(e3).slice(8, -1);
      n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
      if (n2 === "Map" || n2 === "Set")
        return Array.from(e3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return Gt$2(e3, t2);
    }(e2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function Gt$2(e2, t2) {
    (t2 == null || t2 > e2.length) && (t2 = e2.length);
    for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
      r2[n2] = e2[n2];
    return r2;
  }
  function Ht$2(e2) {
    var t2 = cn$2(e2.lines), n2 = t2.oldLines, r2 = t2.newLines;
    n2 !== void 0 ? e2.oldLines = n2 : delete e2.oldLines, r2 !== void 0 ? e2.newLines = r2 : delete e2.newLines;
  }
  function Jt$2(e2, t2) {
    if (typeof e2 == "string") {
      if (/^@@/m.test(e2) || /^Index:/m.test(e2))
        return (0, At$3.parsePatch)(e2)[0];
      if (!t2)
        throw new Error("Must provide a base reference or pass in a patch");
      return (0, Mt$2.structuredPatch)(void 0, void 0, t2, e2);
    }
    return e2;
  }
  function Xt$2(e2) {
    return e2.newFileName && e2.newFileName !== e2.oldFileName;
  }
  function Yt$2(e2, t2, n2) {
    return t2 === n2 ? t2 : (e2.conflict = true, { mine: t2, theirs: n2 });
  }
  function Kt$2(e2, t2) {
    return e2.oldStart < t2.oldStart && e2.oldStart + e2.oldLines < t2.oldStart;
  }
  function Qt$2(e2, t2) {
    return { oldStart: e2.oldStart, oldLines: e2.oldLines, newStart: e2.newStart + t2, newLines: e2.newLines, lines: e2.lines };
  }
  function Zt$2(e2, t2, n2, r2, i2) {
    var u2 = { offset: t2, lines: n2, index: 0 }, o2 = { offset: r2, lines: i2, index: 0 };
    for (rn$2(e2, u2, o2), rn$2(e2, o2, u2); u2.index < u2.lines.length && o2.index < o2.lines.length; ) {
      var s2 = u2.lines[u2.index], a2 = o2.lines[o2.index];
      if (s2[0] !== "-" && s2[0] !== "+" || a2[0] !== "-" && a2[0] !== "+")
        if (s2[0] === "+" && a2[0] === " ") {
          var c2;
          (c2 = e2.lines).push.apply(c2, zt$2(on$2(u2)));
        } else if (a2[0] === "+" && s2[0] === " ") {
          var l2;
          (l2 = e2.lines).push.apply(l2, zt$2(on$2(o2)));
        } else
          s2[0] === "-" && a2[0] === " " ? tn$2(e2, u2, o2) : a2[0] === "-" && s2[0] === " " ? tn$2(e2, o2, u2, true) : s2 === a2 ? (e2.lines.push(s2), u2.index++, o2.index++) : nn$2(e2, on$2(u2), on$2(o2));
      else
        en$2(e2, u2, o2);
    }
    un$2(e2, u2), un$2(e2, o2), Ht$2(e2);
  }
  function en$2(e2, t2, n2) {
    var r2 = on$2(t2), i2 = on$2(n2);
    if (sn$2(r2) && sn$2(i2)) {
      var u2, o2;
      if ((0, Wt$2.arrayStartsWith)(r2, i2) && an$2(n2, r2, r2.length - i2.length))
        return void (u2 = e2.lines).push.apply(u2, zt$2(r2));
      if ((0, Wt$2.arrayStartsWith)(i2, r2) && an$2(t2, i2, i2.length - r2.length))
        return void (o2 = e2.lines).push.apply(o2, zt$2(i2));
    } else if ((0, Wt$2.arrayEqual)(r2, i2)) {
      var s2;
      return void (s2 = e2.lines).push.apply(s2, zt$2(r2));
    }
    nn$2(e2, r2, i2);
  }
  function tn$2(e2, t2, n2, r2) {
    var i2, u2 = on$2(t2), o2 = function(e3, t3) {
      var n3 = [], r3 = [], i3 = 0, u3 = false, o3 = false;
      for (; i3 < t3.length && e3.index < e3.lines.length; ) {
        var s2 = e3.lines[e3.index], a2 = t3[i3];
        if (a2[0] === "+")
          break;
        if (u3 = u3 || s2[0] !== " ", r3.push(a2), i3++, s2[0] === "+")
          for (o3 = true; s2[0] === "+"; )
            n3.push(s2), s2 = e3.lines[++e3.index];
        a2.substr(1) === s2.substr(1) ? (n3.push(s2), e3.index++) : o3 = true;
      }
      (t3[i3] || "")[0] === "+" && u3 && (o3 = true);
      if (o3)
        return n3;
      for (; i3 < t3.length; )
        r3.push(t3[i3++]);
      return { merged: r3, changes: n3 };
    }(n2, u2);
    o2.merged ? (i2 = e2.lines).push.apply(i2, zt$2(o2.merged)) : nn$2(e2, r2 ? o2 : u2, r2 ? u2 : o2);
  }
  function nn$2(e2, t2, n2) {
    e2.conflict = true, e2.lines.push({ conflict: true, mine: t2, theirs: n2 });
  }
  function rn$2(e2, t2, n2) {
    for (; t2.offset < n2.offset && t2.index < t2.lines.length; ) {
      var r2 = t2.lines[t2.index++];
      e2.lines.push(r2), t2.offset++;
    }
  }
  function un$2(e2, t2) {
    for (; t2.index < t2.lines.length; ) {
      var n2 = t2.lines[t2.index++];
      e2.lines.push(n2);
    }
  }
  function on$2(e2) {
    for (var t2 = [], n2 = e2.lines[e2.index][0]; e2.index < e2.lines.length; ) {
      var r2 = e2.lines[e2.index];
      if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
        break;
      t2.push(r2), e2.index++;
    }
    return t2;
  }
  function sn$2(e2) {
    return e2.reduce(function(e3, t2) {
      return e3 && t2[0] === "-";
    }, true);
  }
  function an$2(e2, t2, n2) {
    for (var r2 = 0; r2 < n2; r2++) {
      var i2 = t2[t2.length - n2 + r2].substr(1);
      if (e2.lines[e2.index + r2] !== " " + i2)
        return false;
    }
    return e2.index += n2, true;
  }
  function cn$2(e2) {
    var t2 = 0, n2 = 0;
    return e2.forEach(function(e3) {
      if (typeof e3 != "string") {
        var r2 = cn$2(e3.mine), i2 = cn$2(e3.theirs);
        t2 !== void 0 && (r2.oldLines === i2.oldLines ? t2 += r2.oldLines : t2 = void 0), n2 !== void 0 && (r2.newLines === i2.newLines ? n2 += r2.newLines : n2 = void 0);
      } else
        n2 === void 0 || e3[0] !== "+" && e3[0] !== " " || n2++, t2 === void 0 || e3[0] !== "-" && e3[0] !== " " || t2++;
    }), { oldLines: t2, newLines: n2 };
  }
  var ln$2 = Object.defineProperty({ calcLineCount: qt$2, merge: Ut$2 }, "__esModule", { value: true }), pn$2 = function(e2) {
    for (var t2, n2, r2 = [], i2 = 0; i2 < e2.length; i2++)
      t2 = e2[i2], n2 = t2.added ? 1 : t2.removed ? -1 : 0, r2.push([n2, t2.value]);
    return r2;
  };
  var fn$2 = Object.defineProperty({ convertChangesToDMP: pn$2 }, "__esModule", { value: true }), dn$2 = function(e2) {
    for (var t2 = [], n2 = 0; n2 < e2.length; n2++) {
      var r2 = e2[n2];
      r2.added ? t2.push("<ins>") : r2.removed && t2.push("<del>"), t2.push(hn$2(r2.value)), r2.added ? t2.push("</ins>") : r2.removed && t2.push("</del>");
    }
    return t2.join("");
  };
  function hn$2(e2) {
    var t2 = e2;
    return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
  }
  var gn$2 = Object.defineProperty({ convertChangesToXML: dn$2 }, "__esModule", { value: true }), mn$2 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Diff", { enumerable: true, get: function() {
      return n2.default;
    } }), Object.defineProperty(t2, "diffChars", { enumerable: true, get: function() {
      return u$3.diffChars;
    } }), Object.defineProperty(t2, "diffWords", { enumerable: true, get: function() {
      return l$3.diffWords;
    } }), Object.defineProperty(t2, "diffWordsWithSpace", { enumerable: true, get: function() {
      return l$3.diffWordsWithSpace;
    } }), Object.defineProperty(t2, "diffLines", { enumerable: true, get: function() {
      return p$3.diffLines;
    } }), Object.defineProperty(t2, "diffTrimmedLines", { enumerable: true, get: function() {
      return p$3.diffTrimmedLines;
    } }), Object.defineProperty(t2, "diffSentences", { enumerable: true, get: function() {
      return f$3.diffSentences;
    } }), Object.defineProperty(t2, "diffCss", { enumerable: true, get: function() {
      return d$3.diffCss;
    } }), Object.defineProperty(t2, "diffJson", { enumerable: true, get: function() {
      return Dt$3.diffJson;
    } }), Object.defineProperty(t2, "canonicalize", { enumerable: true, get: function() {
      return Dt$3.canonicalize;
    } }), Object.defineProperty(t2, "diffArrays", { enumerable: true, get: function() {
      return Et$3.diffArrays;
    } }), Object.defineProperty(t2, "applyPatch", { enumerable: true, get: function() {
      return Tt$2.applyPatch;
    } }), Object.defineProperty(t2, "applyPatches", { enumerable: true, get: function() {
      return Tt$2.applyPatches;
    } }), Object.defineProperty(t2, "parsePatch", { enumerable: true, get: function() {
      return At$3.parsePatch;
    } }), Object.defineProperty(t2, "merge", { enumerable: true, get: function() {
      return ln$2.merge;
    } }), Object.defineProperty(t2, "structuredPatch", { enumerable: true, get: function() {
      return Mt$2.structuredPatch;
    } }), Object.defineProperty(t2, "createTwoFilesPatch", { enumerable: true, get: function() {
      return Mt$2.createTwoFilesPatch;
    } }), Object.defineProperty(t2, "createPatch", { enumerable: true, get: function() {
      return Mt$2.createPatch;
    } }), Object.defineProperty(t2, "convertChangesToDMP", { enumerable: true, get: function() {
      return fn$2.convertChangesToDMP;
    } }), Object.defineProperty(t2, "convertChangesToXML", { enumerable: true, get: function() {
      return gn$2.convertChangesToXML;
    } });
    var n2 = function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    }(i$3);
  });
  function yn$2(e2) {
    return { type: "concat", parts: e2 };
  }
  function Dn$2(e2) {
    return { type: "indent", contents: e2 };
  }
  function En$2(e2, t2) {
    return { type: "align", contents: t2, n: e2 };
  }
  function Cn$2(e2, t2 = {}) {
    return { type: "group", id: t2.id, contents: e2, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates };
  }
  const bn$2 = { type: "break-parent" }, An$2 = { type: "line", hard: true }, vn$2 = { type: "line", hard: true, literal: true }, Fn$2 = yn$2([An$2, bn$2]), Sn$2 = yn$2([vn$2, bn$2]);
  var xn$2 = { concat: yn$2, join: function(e2, t2) {
    const n2 = [];
    for (let r2 = 0; r2 < t2.length; r2++)
      r2 !== 0 && n2.push(e2), n2.push(t2[r2]);
    return yn$2(n2);
  }, line: { type: "line" }, softline: { type: "line", soft: true }, hardline: Fn$2, literalline: Sn$2, group: Cn$2, conditionalGroup: function(e2, t2) {
    return Cn$2(e2[0], Object.assign(Object.assign({}, t2), {}, { expandedStates: e2 }));
  }, fill: function(e2) {
    return { type: "fill", parts: e2 };
  }, lineSuffix: function(e2) {
    return { type: "line-suffix", contents: e2 };
  }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: bn$2, ifBreak: function(e2, t2, n2 = {}) {
    return { type: "if-break", breakContents: e2, flatContents: t2, groupId: n2.groupId };
  }, trim: { type: "trim" }, indent: Dn$2, indentIfBreak: function(e2, t2) {
    return { type: "indent-if-break", contents: e2, groupId: t2.groupId, negate: t2.negate };
  }, align: En$2, addAlignmentToDoc: function(e2, t2, n2) {
    let r2 = e2;
    if (t2 > 0) {
      for (let e3 = 0; e3 < Math.floor(t2 / n2); ++e3)
        r2 = Dn$2(r2);
      r2 = En$2(t2 % n2, r2), r2 = En$2(Number.NEGATIVE_INFINITY, r2);
    }
    return r2;
  }, markAsRoot: function(e2) {
    return En$2({ type: "root" }, e2);
  }, dedentToRoot: function(e2) {
    return En$2(Number.NEGATIVE_INFINITY, e2);
  }, dedent: function(e2) {
    return En$2(-1, e2);
  }, hardlineWithoutBreakParent: An$2, literallineWithoutBreakParent: vn$2, label: function(e2, t2) {
    return { type: "label", label: e2, contents: t2 };
  } }, wn$2 = (e2) => typeof e2 == "string" ? e2.replace((({ onlyFirst: e3 = false } = {}) => {
    const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(t2, e3 ? void 0 : "g");
  })(), "") : e2;
  const Tn$2 = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
  var Bn$2 = Tn$2, Nn$2 = Tn$2;
  Bn$2.default = Nn$2;
  const kn$2 = (e2) => {
    if (typeof e2 != "string" || e2.length === 0)
      return 0;
    if ((e2 = wn$2(e2)).length === 0)
      return 0;
    e2 = e2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
    let t2 = 0;
    for (let n2 = 0; n2 < e2.length; n2++) {
      const r2 = e2.codePointAt(n2);
      r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t2 += Bn$2(r2) ? 2 : 1));
    }
    return t2;
  };
  var Pn$2 = kn$2, On$2 = kn$2;
  Pn$2.default = On$2;
  var In$2 = (e2) => {
    if (typeof e2 != "string")
      throw new TypeError("Expected a string");
    return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  var Ln$2 = (e2) => e2[e2.length - 1];
  function jn$2(e2, t2) {
    if (e2 == null)
      return {};
    var n2, r2, i2 = function(e3, t3) {
      if (e3 == null)
        return {};
      var n3, r3, i3 = {}, u3 = Object.keys(e3);
      for (r3 = 0; r3 < u3.length; r3++)
        n3 = u3[r3], t3.indexOf(n3) >= 0 || (i3[n3] = e3[n3]);
      return i3;
    }(e2, t2);
    if (Object.getOwnPropertySymbols) {
      var u2 = Object.getOwnPropertySymbols(e2);
      for (r2 = 0; r2 < u2.length; r2++)
        n2 = u2[r2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, n2) && (i2[n2] = e2[n2]);
    }
    return i2;
  }
  var _n$2 = Array.isArray || function(e2) {
    return v$3(e2) == "Array";
  }, Mn$2 = function(e2, t2, n2) {
    if (et$3(e2), t2 === void 0)
      return e2;
    switch (n2) {
      case 0:
        return function() {
          return e2.call(t2);
        };
      case 1:
        return function(n3) {
          return e2.call(t2, n3);
        };
      case 2:
        return function(n3, r2) {
          return e2.call(t2, n3, r2);
        };
      case 3:
        return function(n3, r2, i2) {
          return e2.call(t2, n3, r2, i2);
        };
    }
    return function() {
      return e2.apply(t2, arguments);
    };
  }, Rn$2 = function(e2, t2, n2, r2, i2, u2, o2, s2) {
    for (var a2, c2 = i2, l2 = 0, p2 = !!o2 && Mn$2(o2, s2, 3); l2 < r2; ) {
      if (l2 in n2) {
        if (a2 = p2 ? p2(n2[l2], l2, t2) : n2[l2], u2 > 0 && _n$2(a2))
          c2 = Rn$2(e2, t2, a2, Le$3(a2.length), c2, u2 - 1) - 1;
        else {
          if (c2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e2[c2] = a2;
        }
        c2++;
      }
      l2++;
    }
    return c2;
  }, $n$2 = Rn$2, Vn$2 = Q$3("species"), Wn$2 = function(e2, t2) {
    return new (function(e3) {
      var t3;
      return _n$2(e3) && (typeof (t3 = e3.constructor) != "function" || t3 !== Array && !_n$2(t3.prototype) ? T$3(t3) && (t3 = t3[Vn$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e2))(t2 === 0 ? 0 : t2);
  };
  Ze$3({ target: "Array", proto: true }, { flatMap: function(e2) {
    var t2, n2 = q$3(this), r2 = Le$3(n2.length);
    return et$3(e2), (t2 = Wn$2(n2, 0)).length = $n$2(t2, n2, n2, r2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t2;
  } });
  var qn$2 = {}, Un$2 = Q$3("iterator"), zn$2 = Array.prototype, Gn$2 = {};
  Gn$2[Q$3("toStringTag")] = "z";
  var Hn$2 = String(Gn$2) === "[object z]", Jn$2 = Q$3("toStringTag"), Xn$2 = v$3(function() {
    return arguments;
  }()) == "Arguments", Yn$2 = Hn$2 ? v$3 : function(e2) {
    var t2, n2, r2;
    return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (n2 = function(e3, t3) {
      try {
        return e3[t3];
      } catch (e4) {
      }
    }(t2 = Object(e2), Jn$2)) == "string" ? n2 : Xn$2 ? v$3(t2) : (r2 = v$3(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
  }, Kn$2 = Q$3("iterator"), Qn$2 = function(e2) {
    if (e2 != null)
      return e2[Kn$2] || e2["@@iterator"] || qn$2[Yn$2(e2)];
  }, Zn$2 = function(e2, t2, n2) {
    var r2, i2;
    se$3(e2);
    try {
      if ((r2 = e2.return) === void 0) {
        if (t2 === "throw")
          throw n2;
        return n2;
      }
      r2 = r2.call(e2);
    } catch (e3) {
      i2 = true, r2 = e3;
    }
    if (t2 === "throw")
      throw n2;
    if (i2)
      throw r2;
    return se$3(r2), n2;
  }, er$2 = function(e2, t2) {
    this.stopped = e2, this.result = t2;
  }, tr$2 = function(e2, t2, n2) {
    var r2, i2, u2, o2, s2, a2, c2, l2, p2 = n2 && n2.that, f2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), h2 = !(!n2 || !n2.INTERRUPTED), g2 = Mn$2(t2, p2, 1 + f2 + h2), m2 = function(e3) {
      return r2 && Zn$2(r2, "normal", e3), new er$2(true, e3);
    }, y2 = function(e3) {
      return f2 ? (se$3(e3), h2 ? g2(e3[0], e3[1], m2) : g2(e3[0], e3[1])) : h2 ? g2(e3, m2) : g2(e3);
    };
    if (d2)
      r2 = e2;
    else {
      if (typeof (i2 = Qn$2(e2)) != "function")
        throw TypeError("Target is not iterable");
      if ((l2 = i2) !== void 0 && (qn$2.Array === l2 || zn$2[Un$2] === l2)) {
        for (u2 = 0, o2 = Le$3(e2.length); o2 > u2; u2++)
          if ((s2 = y2(e2[u2])) && s2 instanceof er$2)
            return s2;
        return new er$2(false);
      }
      r2 = function(e3, t3) {
        var n3 = arguments.length < 2 ? Qn$2(e3) : t3;
        if (typeof n3 != "function")
          throw TypeError(String(e3) + " is not iterable");
        return se$3(n3.call(e3));
      }(e2, i2);
    }
    for (a2 = r2.next; !(c2 = a2.call(r2)).done; ) {
      try {
        s2 = y2(c2.value);
      } catch (e3) {
        Zn$2(r2, "throw", e3);
      }
      if (typeof s2 == "object" && s2 && s2 instanceof er$2)
        return s2;
    }
    return new er$2(false);
  };
  Ze$3({ target: "Object", stat: true }, { fromEntries: function(e2) {
    var t2 = {};
    return tr$2(e2, function(e3, n2) {
      !function(e4, t3, n3) {
        var r2 = te$3(t3);
        r2 in e4 ? ce$3.f(e4, r2, b$3(0, n3)) : e4[r2] = n3;
      }(t2, e3, n2);
    }, { AS_ENTRIES: true }), t2;
  } });
  var nr$2 = nr$2 !== void 0 ? nr$2 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
  function rr$2() {
    throw new Error("setTimeout has not been defined");
  }
  function ir$2() {
    throw new Error("clearTimeout has not been defined");
  }
  var ur$2 = rr$2, or$2 = ir$2;
  function sr$2(e2) {
    if (ur$2 === setTimeout)
      return setTimeout(e2, 0);
    if ((ur$2 === rr$2 || !ur$2) && setTimeout)
      return ur$2 = setTimeout, setTimeout(e2, 0);
    try {
      return ur$2(e2, 0);
    } catch (t2) {
      try {
        return ur$2.call(null, e2, 0);
      } catch (t3) {
        return ur$2.call(this, e2, 0);
      }
    }
  }
  typeof nr$2.setTimeout == "function" && (ur$2 = setTimeout), typeof nr$2.clearTimeout == "function" && (or$2 = clearTimeout);
  var ar$2, cr$2 = [], lr$2 = false, pr$2 = -1;
  function fr$2() {
    lr$2 && ar$2 && (lr$2 = false, ar$2.length ? cr$2 = ar$2.concat(cr$2) : pr$2 = -1, cr$2.length && dr$2());
  }
  function dr$2() {
    if (!lr$2) {
      var e2 = sr$2(fr$2);
      lr$2 = true;
      for (var t2 = cr$2.length; t2; ) {
        for (ar$2 = cr$2, cr$2 = []; ++pr$2 < t2; )
          ar$2 && ar$2[pr$2].run();
        pr$2 = -1, t2 = cr$2.length;
      }
      ar$2 = null, lr$2 = false, function(e3) {
        if (or$2 === clearTimeout)
          return clearTimeout(e3);
        if ((or$2 === ir$2 || !or$2) && clearTimeout)
          return or$2 = clearTimeout, clearTimeout(e3);
        try {
          or$2(e3);
        } catch (t3) {
          try {
            return or$2.call(null, e3);
          } catch (t4) {
            return or$2.call(this, e3);
          }
        }
      }(e2);
    }
  }
  function hr$2(e2, t2) {
    this.fun = e2, this.array = t2;
  }
  hr$2.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  function gr$2() {
  }
  var mr$2 = gr$2, yr$2 = gr$2, Dr$2 = gr$2, Er$2 = gr$2, Cr$2 = gr$2, br$2 = gr$2, Ar$2 = gr$2;
  var vr$2 = nr$2.performance || {}, Fr$2 = vr$2.now || vr$2.mozNow || vr$2.msNow || vr$2.oNow || vr$2.webkitNow || function() {
    return new Date().getTime();
  };
  var Sr$2 = new Date();
  var xr$2 = { nextTick: function(e2) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n2 = 1; n2 < arguments.length; n2++)
        t2[n2 - 1] = arguments[n2];
    cr$2.push(new hr$2(e2, t2)), cr$2.length !== 1 || lr$2 || sr$2(dr$2);
  }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: mr$2, addListener: yr$2, once: Dr$2, off: Er$2, removeListener: Cr$2, removeAllListeners: br$2, emit: Ar$2, binding: function(e2) {
    throw new Error("process.binding is not supported");
  }, cwd: function() {
    return "/";
  }, chdir: function(e2) {
    throw new Error("process.chdir is not supported");
  }, umask: function() {
    return 0;
  }, hrtime: function(e2) {
    var t2 = 1e-3 * Fr$2.call(vr$2), n2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
    return e2 && (n2 -= e2[0], (r2 -= e2[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
  }, platform: "browser", release: {}, config: {}, uptime: function() {
    return (new Date() - Sr$2) / 1e3;
  } };
  var wr$2 = typeof xr$2 == "object" && xr$2.env && xr$2.env.NODE_DEBUG && /\bsemver\b/i.test(xr$2.env.NODE_DEBUG) ? (...e2) => console.error("SEMVER", ...e2) : () => {
  };
  var Tr$2 = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, Br$2 = r$3(function(e2, t2) {
    const { MAX_SAFE_COMPONENT_LENGTH: n2 } = Tr$2, r2 = (t2 = e2.exports = {}).re = [], i2 = t2.src = [], u2 = t2.t = {};
    let o2 = 0;
    const s2 = (e3, t3, n3) => {
      const s3 = o2++;
      wr$2(s3, t3), u2[e3] = s3, i2[s3] = t3, r2[s3] = new RegExp(t3, n3 ? "g" : void 0);
    };
    s2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s2("MAINVERSION", `(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})`), s2("MAINVERSIONLOOSE", `(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})`), s2("PRERELEASEIDENTIFIER", `(?:${i2[u2.NUMERICIDENTIFIER]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[u2.NUMERICIDENTIFIERLOOSE]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASE", `(?:-(${i2[u2.PRERELEASEIDENTIFIER]}(?:\\.${i2[u2.PRERELEASEIDENTIFIER]})*))`), s2("PRERELEASELOOSE", `(?:-?(${i2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), s2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s2("BUILD", `(?:\\+(${i2[u2.BUILDIDENTIFIER]}(?:\\.${i2[u2.BUILDIDENTIFIER]})*))`), s2("FULLPLAIN", `v?${i2[u2.MAINVERSION]}${i2[u2.PRERELEASE]}?${i2[u2.BUILD]}?`), s2("FULL", `^${i2[u2.FULLPLAIN]}$`), s2("LOOSEPLAIN", `[v=\\s]*${i2[u2.MAINVERSIONLOOSE]}${i2[u2.PRERELEASELOOSE]}?${i2[u2.BUILD]}?`), s2("LOOSE", `^${i2[u2.LOOSEPLAIN]}$`), s2("GTLT", "((?:<|>)?=?)"), s2("XRANGEIDENTIFIERLOOSE", `${i2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s2("XRANGEIDENTIFIER", `${i2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), s2("XRANGEPLAIN", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:${i2[u2.PRERELEASE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:${i2[u2.PRERELEASELOOSE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAIN]}$`), s2("XRANGELOOSE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), s2("COERCERTL", i2[u2.COERCE], true), s2("LONETILDE", "(?:~>?)"), s2("TILDETRIM", `(\\s*)${i2[u2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", s2("TILDE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAIN]}$`), s2("TILDELOOSE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("LONECARET", "(?:\\^)"), s2("CARETTRIM", `(\\s*)${i2[u2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", s2("CARET", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAIN]}$`), s2("CARETLOOSE", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COMPARATORLOOSE", `^${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]})$|^$`), s2("COMPARATOR", `^${i2[u2.GTLT]}\\s*(${i2[u2.FULLPLAIN]})$|^$`), s2("COMPARATORTRIM", `(\\s*)${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]}|${i2[u2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", s2("HYPHENRANGE", `^\\s*(${i2[u2.XRANGEPLAIN]})\\s+-\\s+(${i2[u2.XRANGEPLAIN]})\\s*$`), s2("HYPHENRANGELOOSE", `^\\s*(${i2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[u2.XRANGEPLAINLOOSE]})\\s*$`), s2("STAR", "(<|>)?=?\\s*\\*"), s2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), s2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });
  const Nr$2 = ["includePrerelease", "loose", "rtl"];
  var kr$2 = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : Nr$2.filter((t2) => e2[t2]).reduce((e3, t2) => (e3[t2] = true, e3), {}) : {};
  const Pr$2 = /^[0-9]+$/, Or$2 = (e2, t2) => {
    const n2 = Pr$2.test(e2), r2 = Pr$2.test(t2);
    return n2 && r2 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e2 < t2 ? -1 : 1;
  };
  var Ir$2 = { compareIdentifiers: Or$2, rcompareIdentifiers: (e2, t2) => Or$2(t2, e2) };
  const { MAX_LENGTH: Lr$2, MAX_SAFE_INTEGER: jr$2 } = Tr$2, { re: _r$2, t: Mr$2 } = Br$2, { compareIdentifiers: Rr$2 } = Ir$2;
  class $r$2 {
    constructor(e2, t2) {
      if (t2 = kr$2(t2), e2 instanceof $r$2) {
        if (e2.loose === !!t2.loose && e2.includePrerelease === !!t2.includePrerelease)
          return e2;
        e2 = e2.version;
      } else if (typeof e2 != "string")
        throw new TypeError(`Invalid Version: ${e2}`);
      if (e2.length > Lr$2)
        throw new TypeError(`version is longer than ${Lr$2} characters`);
      wr$2("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
      const n2 = e2.trim().match(t2.loose ? _r$2[Mr$2.LOOSE] : _r$2[Mr$2.FULL]);
      if (!n2)
        throw new TypeError(`Invalid Version: ${e2}`);
      if (this.raw = e2, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > jr$2 || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > jr$2 || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > jr$2 || this.patch < 0)
        throw new TypeError("Invalid patch version");
      n2[4] ? this.prerelease = n2[4].split(".").map((e3) => {
        if (/^[0-9]+$/.test(e3)) {
          const t3 = +e3;
          if (t3 >= 0 && t3 < jr$2)
            return t3;
        }
        return e3;
      }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e2) {
      if (wr$2("SemVer.compare", this.version, this.options, e2), !(e2 instanceof $r$2)) {
        if (typeof e2 == "string" && e2 === this.version)
          return 0;
        e2 = new $r$2(e2, this.options);
      }
      return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
    }
    compareMain(e2) {
      return e2 instanceof $r$2 || (e2 = new $r$2(e2, this.options)), Rr$2(this.major, e2.major) || Rr$2(this.minor, e2.minor) || Rr$2(this.patch, e2.patch);
    }
    comparePre(e2) {
      if (e2 instanceof $r$2 || (e2 = new $r$2(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
        return -1;
      if (!this.prerelease.length && e2.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e2.prerelease.length)
        return 0;
      let t2 = 0;
      do {
        const n2 = this.prerelease[t2], r2 = e2.prerelease[t2];
        if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (n2 === void 0)
          return -1;
        if (n2 !== r2)
          return Rr$2(n2, r2);
      } while (++t2);
    }
    compareBuild(e2) {
      e2 instanceof $r$2 || (e2 = new $r$2(e2, this.options));
      let t2 = 0;
      do {
        const n2 = this.build[t2], r2 = e2.build[t2];
        if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (n2 === void 0)
          return -1;
        if (n2 !== r2)
          return Rr$2(n2, r2);
      } while (++t2);
    }
    inc(e2, t2) {
      switch (e2) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "major":
          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let e3 = this.prerelease.length;
            for (; --e3 >= 0; )
              typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
            e3 === -1 && this.prerelease.push(0);
          }
          t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${e2}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  var Vr$2 = $r$2;
  var Wr$2 = (e2, t2, n2) => new Vr$2(e2, n2).compare(new Vr$2(t2, n2));
  var qr$2 = (e2, t2, n2) => Wr$2(e2, t2, n2) < 0;
  var Ur$2 = (e2, t2, n2) => Wr$2(e2, t2, n2) >= 0, zr$2 = r$3(function(e2, t2) {
    function n2() {
      for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
        e3[t3] = arguments[t3];
    }
    function r2() {
      return typeof WeakMap != "undefined" ? new WeakMap() : { add: n2, delete: n2, get: n2, set: n2, has: function(e3) {
        return false;
      } };
    }
    Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
    var i2 = Object.prototype.hasOwnProperty, u2 = function(e3, t3) {
      return i2.call(e3, t3);
    };
    function o2(e3, t3) {
      for (var n3 in t3)
        u2(t3, n3) && (e3[n3] = t3[n3]);
      return e3;
    }
    var s2 = /^[ \t]*(?:\r\n|\r|\n)/, a2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function f2(e3, t3, n3) {
      var r3 = 0, i3 = e3[0].match(l2);
      i3 && (r3 = i3[1].length);
      var u3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
      t3 && (e3 = e3.slice(1));
      var o3 = n3.newline, c3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, f3 = typeof o3 == "string", d3 = e3.length;
      return e3.map(function(e4, t4) {
        return e4 = e4.replace(u3, "$1"), t4 === 0 && c3 && (e4 = e4.replace(s2, "")), t4 === d3 - 1 && p3 && (e4 = e4.replace(a2, "")), f3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
          return o3;
        })), e4;
      });
    }
    function d2(e3, t3) {
      for (var n3 = "", r3 = 0, i3 = e3.length; r3 < i3; r3++)
        n3 += e3[r3], r3 < i3 - 1 && (n3 += t3[r3]);
      return n3;
    }
    function h2(e3) {
      return u2(e3, "raw") && u2(e3, "length");
    }
    var g2 = function e3(t3) {
      var n3 = r2(), i3 = r2();
      return o2(function r3(u3) {
        for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
          s3[a3 - 1] = arguments[a3];
        if (h2(u3)) {
          var l3 = u3, m2 = (s3[0] === r3 || s3[0] === g2) && p2.test(l3[0]) && c2.test(l3[1]), y2 = m2 ? i3 : n3, D2 = y2.get(l3);
          if (D2 || (D2 = f2(l3, m2, t3), y2.set(l3, D2)), s3.length === 0)
            return D2[0];
          var E2 = d2(D2, m2 ? s3.slice(1) : s3);
          return E2;
        }
        return e3(o2(o2({}, t3), u3 || {}));
      }, { string: function(e4) {
        return f2([e4], false, t3)[0];
      } });
    }({ trimLeadingNewline: true, trimTrailingNewline: true });
    t2.outdent = g2, t2.default = g2;
    try {
      e2.exports = g2, Object.defineProperty(g2, "__esModule", { value: true }), g2.default = g2, g2.outdent = g2;
    } catch (e3) {
    }
  });
  const { outdent: Gr$2 } = zr$2, Hr$2 = { cursorOffset: { since: "1.4.0", category: "Special", type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Gr$2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor" }, endOfLine: { since: "1.15.0", category: "Global", type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Gr$2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { since: "0.0.10", category: "Global", type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: Gr$2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: "Config" }, printWidth: { since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Gr$2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, rangeStart: { since: "1.4.0", category: "Special", type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Gr$2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, requirePragma: { since: "1.7.0", category: "Special", type: "boolean", default: false, description: Gr$2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: "Global", type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  const Jr$2 = ["cliName", "cliCategory", "cliDescription"], Xr$2 = { compare: Wr$2, lt: qr$2, gte: Ur$2 }, Yr$2 = e$3.version, Kr$2 = { CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: Hr$2 }.options;
  var Qr$2 = { getSupportInfo: function({ plugins: e2 = [], showUnreleased: t2 = false, showDeprecated: n2 = false, showInternal: r2 = false } = {}) {
    const i2 = Yr$2.split("-", 1)[0], u2 = e2.flatMap((e3) => e3.languages || []).filter(s2), o2 = ((e3, t3) => Object.entries(e3).map(([e4, n3]) => Object.assign({ [t3]: e4 }, n3)))(Object.assign({}, ...e2.map(({ options: e3 }) => e3), Kr$2), "name").filter((e3) => s2(e3) && a2(e3)).sort((e3, t3) => e3.name === t3.name ? 0 : e3.name < t3.name ? -1 : 1).map(function(e3) {
      if (r2)
        return e3;
      return jn$2(e3, Jr$2);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(s2).sort((e3, t4) => Xr$2.compare(t4.since, e3.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e3) => s2(e3) && a2(e3)), t3.name === "parser" && function(e3, t4, n4) {
        const r3 = new Set(e3.choices.map((e4) => e4.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!r3.has(t5)) {
                r3.add(t5);
                const u3 = n4.find((e4) => e4.parsers && e4.parsers[t5]);
                let o3 = i3.name;
                u3 && u3.name && (o3 += ` (plugin: ${u3.name})`), e3.choices.push({ value: t5, description: o3 });
              }
          }
      }(t3, u2, e2));
      const n3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t3.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: n3 });
    });
    return { languages: u2, options: o2 };
    function s2(e3) {
      return t2 || !("since" in e3) || e3.since && Xr$2.gte(i2, e3.since);
    }
    function a2(e3) {
      return n2 || !("deprecated" in e3) || e3.deprecated && Xr$2.lt(i2, e3.deprecated);
    }
  } };
  const { getSupportInfo: Zr$2 } = Qr$2, ei$2 = /[^\x20-\x7F]/;
  function ti$2(e2) {
    return (t2, n2, r2) => {
      const i2 = r2 && r2.backwards;
      if (n2 === false)
        return false;
      const { length: u2 } = t2;
      let o2 = n2;
      for (; o2 >= 0 && o2 < u2; ) {
        const n3 = t2.charAt(o2);
        if (e2 instanceof RegExp) {
          if (!e2.test(n3))
            return o2;
        } else if (!e2.includes(n3))
          return o2;
        i2 ? o2-- : o2++;
      }
      return (o2 === -1 || o2 === u2) && o2;
    };
  }
  const ni$2 = ti$2(/\s/), ri$2 = ti$2(" 	"), ii$2 = ti$2(",; 	"), ui$2 = ti$2(/[^\n\r]/);
  function oi$2(e2, t2) {
    if (t2 === false)
      return false;
    if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
      for (let n2 = t2 + 2; n2 < e2.length; ++n2)
        if (e2.charAt(n2) === "*" && e2.charAt(n2 + 1) === "/")
          return n2 + 2;
    }
    return t2;
  }
  function si$2(e2, t2) {
    return t2 !== false && (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? ui$2(e2, t2) : t2);
  }
  function ai$2(e2, t2, n2) {
    const r2 = n2 && n2.backwards;
    if (t2 === false)
      return false;
    const i2 = e2.charAt(t2);
    if (r2) {
      if (e2.charAt(t2 - 1) === "\r" && i2 === "\n")
        return t2 - 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 - 1;
    } else {
      if (i2 === "\r" && e2.charAt(t2 + 1) === "\n")
        return t2 + 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 + 1;
    }
    return t2;
  }
  function ci$2(e2, t2, n2 = {}) {
    const r2 = ri$2(e2, n2.backwards ? t2 - 1 : t2, n2);
    return r2 !== ai$2(e2, r2, n2);
  }
  function li$2(e2, t2) {
    let n2 = null, r2 = t2;
    for (; r2 !== n2; )
      n2 = r2, r2 = ii$2(e2, r2), r2 = oi$2(e2, r2), r2 = ri$2(e2, r2);
    return r2 = si$2(e2, r2), r2 = ai$2(e2, r2), r2 !== false && ci$2(e2, r2);
  }
  function pi$2(e2, t2) {
    let n2 = null, r2 = t2;
    for (; r2 !== n2; )
      n2 = r2, r2 = ri$2(e2, r2), r2 = oi$2(e2, r2), r2 = si$2(e2, r2), r2 = ai$2(e2, r2);
    return r2;
  }
  function fi$2(e2, t2, n2) {
    return pi$2(e2, n2(t2));
  }
  function di$2(e2, t2, n2 = 0) {
    let r2 = 0;
    for (let i2 = n2; i2 < e2.length; ++i2)
      e2[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
    return r2;
  }
  function hi$2(e2, t2) {
    const n2 = e2.slice(1, -1), r2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, u2 = t2 === "'" ? i2 : r2, o2 = u2 === i2 ? r2 : i2;
    let s2 = u2.quote;
    if (n2.includes(u2.quote) || n2.includes(o2.quote)) {
      s2 = (n2.match(u2.regex) || []).length > (n2.match(o2.regex) || []).length ? o2.quote : u2.quote;
    }
    return s2;
  }
  function gi$2(e2, t2, n2) {
    const r2 = t2 === '"' ? "'" : '"', i2 = e2.replace(/\\(.)|(["'])/gs, (e3, i3, u2) => i3 === r2 ? i3 : u2 === t2 ? "\\" + u2 : u2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
    return t2 + i2 + t2;
  }
  function mi$2(e2, t2) {
    (e2.comments || (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e3) {
      const t3 = e3.type || e3.kind || "(unknown type)";
      let n2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
      n2.length > 20 && (n2 = n2.slice(0, 19) + "\u2026");
      return t3 + (n2 ? " " + n2 : "");
    }(e2);
  }
  var yi$2 = { inferParserByLanguage: function(e2, t2) {
    const { languages: n2 } = Zr$2({ plugins: t2.plugins }), r2 = n2.find(({ name: t3 }) => t3.toLowerCase() === e2) || n2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e2)) || n2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e2}`));
    return r2 && r2.parsers[0];
  }, getStringWidth: function(e2) {
    return e2 ? ei$2.test(e2) ? Pn$2(e2) : e2.length : 0;
  }, getMaxContinuousCount: function(e2, t2) {
    const n2 = e2.match(new RegExp(`(${In$2(t2)})+`, "g"));
    return n2 === null ? 0 : n2.reduce((e3, n3) => Math.max(e3, n3.length / t2.length), 0);
  }, getMinNotPresentContinuousCount: function(e2, t2) {
    const n2 = e2.match(new RegExp(`(${In$2(t2)})+`, "g"));
    if (n2 === null)
      return 0;
    const r2 = new Map();
    let i2 = 0;
    for (const e3 of n2) {
      const n3 = e3.length / t2.length;
      r2.set(n3, true), n3 > i2 && (i2 = n3);
    }
    for (let e3 = 1; e3 < i2; e3++)
      if (!r2.get(e3))
        return e3;
    return i2 + 1;
  }, getPenultimate: (e2) => e2[e2.length - 2], getLast: Ln$2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: pi$2, getNextNonSpaceNonCommentCharacterIndex: fi$2, getNextNonSpaceNonCommentCharacter: function(e2, t2, n2) {
    return e2.charAt(fi$2(e2, t2, n2));
  }, skip: ti$2, skipWhitespace: ni$2, skipSpaces: ri$2, skipToLineEnd: ii$2, skipEverythingButNewLine: ui$2, skipInlineComment: oi$2, skipTrailingComment: si$2, skipNewline: ai$2, isNextLineEmptyAfterIndex: li$2, isNextLineEmpty: function(e2, t2, n2) {
    return li$2(e2, n2(t2));
  }, isPreviousLineEmpty: function(e2, t2, n2) {
    let r2 = n2(t2) - 1;
    return r2 = ri$2(e2, r2, { backwards: true }), r2 = ai$2(e2, r2, { backwards: true }), r2 = ri$2(e2, r2, { backwards: true }), r2 !== ai$2(e2, r2, { backwards: true });
  }, hasNewline: ci$2, hasNewlineInRange: function(e2, t2, n2) {
    for (let r2 = t2; r2 < n2; ++r2)
      if (e2.charAt(r2) === "\n")
        return true;
    return false;
  }, hasSpaces: function(e2, t2, n2 = {}) {
    return ri$2(e2, n2.backwards ? t2 - 1 : t2, n2) !== t2;
  }, getAlignmentSize: di$2, getIndentSize: function(e2, t2) {
    const n2 = e2.lastIndexOf("\n");
    return n2 === -1 ? 0 : di$2(e2.slice(n2 + 1).match(/^[\t ]*/)[0], t2);
  }, getPreferredQuote: hi$2, printString: function(e2, t2) {
    return gi$2(e2.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : hi$2(e2, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  }, printNumber: function(e2) {
    return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }, makeString: gi$2, addLeadingComment: function(e2, t2) {
    t2.leading = true, t2.trailing = false, mi$2(e2, t2);
  }, addDanglingComment: function(e2, t2, n2) {
    t2.leading = false, t2.trailing = false, n2 && (t2.marker = n2), mi$2(e2, t2);
  }, addTrailingComment: function(e2, t2) {
    t2.leading = false, t2.trailing = true, mi$2(e2, t2);
  }, isFrontMatterNode: function(e2) {
    return e2 && e2.type === "front-matter";
  }, getShebang: function(e2) {
    if (!e2.startsWith("#!"))
      return "";
    const t2 = e2.indexOf("\n");
    return t2 === -1 ? e2 : e2.slice(0, t2);
  }, isNonEmptyArray: function(e2) {
    return Array.isArray(e2) && e2.length > 0;
  }, createGroupIdMapper: function(e2) {
    const t2 = new WeakMap();
    return function(n2) {
      return t2.has(n2) || t2.set(n2, Symbol(e2)), t2.get(n2);
    };
  } };
  var Di$2 = { guessEndOfLine: function(e2) {
    const t2 = e2.indexOf("\r");
    return t2 >= 0 ? e2.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  }, convertEndOfLineToChars: function(e2) {
    switch (e2) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  }, countEndOfLineChars: function(e2, t2) {
    let n2;
    if (t2 === "\n")
      n2 = /\n/g;
    else if (t2 === "\r")
      n2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      n2 = /\r\n/g;
    }
    const r2 = e2.match(n2);
    return r2 ? r2.length : 0;
  }, normalizeEndOfLine: function(e2) {
    return e2.replace(/\r\n?/g, "\n");
  } };
  const { literalline: Ei$2, join: Ci$2 } = xn$2, bi$2 = (e2) => Array.isArray(e2) || e2 && e2.type === "concat", Ai$2 = (e2) => {
    if (Array.isArray(e2))
      return e2;
    if (e2.type !== "concat" && e2.type !== "fill")
      throw new Error("Expect doc type to be `concat` or `fill`.");
    return e2.parts;
  }, vi$2 = {};
  function Fi$2(e2, t2, n2, r2) {
    const i2 = [e2];
    for (; i2.length > 0; ) {
      const e3 = i2.pop();
      if (e3 !== vi$2) {
        if (n2 && i2.push(e3, vi$2), !t2 || t2(e3) !== false)
          if (bi$2(e3) || e3.type === "fill") {
            const t3 = Ai$2(e3);
            for (let e4 = t3.length - 1; e4 >= 0; --e4)
              i2.push(t3[e4]);
          } else if (e3.type === "if-break")
            e3.flatContents && i2.push(e3.flatContents), e3.breakContents && i2.push(e3.breakContents);
          else if (e3.type === "group" && e3.expandedStates)
            if (r2)
              for (let t3 = e3.expandedStates.length - 1; t3 >= 0; --t3)
                i2.push(e3.expandedStates[t3]);
            else
              i2.push(e3.contents);
          else
            e3.contents && i2.push(e3.contents);
      } else
        n2(i2.pop());
    }
  }
  function Si$2(e2, t2) {
    const n2 = new Map();
    return r2(e2);
    function r2(e3) {
      if (n2.has(e3))
        return n2.get(e3);
      const i2 = function(e4) {
        if (Array.isArray(e4))
          return t2(e4.map(r2));
        if (e4.type === "concat" || e4.type === "fill") {
          const n3 = e4.parts.map(r2);
          return t2(Object.assign(Object.assign({}, e4), {}, { parts: n3 }));
        }
        if (e4.type === "if-break") {
          const n3 = e4.breakContents && r2(e4.breakContents), i3 = e4.flatContents && r2(e4.flatContents);
          return t2(Object.assign(Object.assign({}, e4), {}, { breakContents: n3, flatContents: i3 }));
        }
        if (e4.type === "group" && e4.expandedStates) {
          const n3 = e4.expandedStates.map(r2), i3 = n3[0];
          return t2(Object.assign(Object.assign({}, e4), {}, { contents: i3, expandedStates: n3 }));
        }
        if (e4.contents) {
          const n3 = r2(e4.contents);
          return t2(Object.assign(Object.assign({}, e4), {}, { contents: n3 }));
        }
        return t2(e4);
      }(e3);
      return n2.set(e3, i2), i2;
    }
  }
  function xi$2(e2, t2, n2) {
    let r2 = n2, i2 = false;
    return Fi$2(e2, function(e3) {
      const n3 = t2(e3);
      if (n3 !== void 0 && (i2 = true, r2 = n3), i2)
        return false;
    }), r2;
  }
  function wi$2(e2) {
    return !(e2.type !== "group" || !e2.break) || (!(e2.type !== "line" || !e2.hard) || (e2.type === "break-parent" || void 0));
  }
  function Ti$2(e2) {
    if (e2.length > 0) {
      const t2 = Ln$2(e2);
      t2.expandedStates || t2.break || (t2.break = "propagated");
    }
    return null;
  }
  function Bi$2(e2) {
    return e2.type !== "line" || e2.hard ? e2.type === "if-break" ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
  }
  const Ni$2 = (e2, t2) => e2 && e2.type === "line" && e2.hard && t2 && t2.type === "break-parent";
  function ki$2(e2) {
    if (!e2)
      return e2;
    if (bi$2(e2) || e2.type === "fill") {
      const t2 = Ai$2(e2);
      for (; t2.length > 1 && Ni$2(...t2.slice(-2)); )
        t2.length -= 2;
      if (t2.length > 0) {
        const e3 = ki$2(Ln$2(t2));
        t2[t2.length - 1] = e3;
      }
      return Array.isArray(e2) ? t2 : Object.assign(Object.assign({}, e2), {}, { parts: t2 });
    }
    switch (e2.type) {
      case "align":
      case "indent":
      case "indent-if-break":
      case "group":
      case "line-suffix":
      case "label": {
        const t2 = ki$2(e2.contents);
        return Object.assign(Object.assign({}, e2), {}, { contents: t2 });
      }
      case "if-break": {
        const t2 = ki$2(e2.breakContents), n2 = ki$2(e2.flatContents);
        return Object.assign(Object.assign({}, e2), {}, { breakContents: t2, flatContents: n2 });
      }
    }
    return e2;
  }
  function Pi$2(e2) {
    return Si$2(e2, (e3) => function(e4) {
      switch (e4.type) {
        case "fill":
          if (e4.parts.length === 0 || e4.parts.every((e5) => e5 === ""))
            return "";
          break;
        case "group":
          if (!(e4.contents || e4.id || e4.break || e4.expandedStates))
            return "";
          if (e4.contents.type === "group" && e4.contents.id === e4.id && e4.contents.break === e4.break && e4.contents.expandedStates === e4.expandedStates)
            return e4.contents;
          break;
        case "align":
        case "indent":
        case "indent-if-break":
        case "line-suffix":
          if (!e4.contents)
            return "";
          break;
        case "if-break":
          if (!e4.flatContents && !e4.breakContents)
            return "";
      }
      if (!bi$2(e4))
        return e4;
      const t2 = [];
      for (const n2 of Ai$2(e4)) {
        if (!n2)
          continue;
        const [e5, ...r2] = bi$2(n2) ? Ai$2(n2) : [n2];
        typeof e5 == "string" && typeof Ln$2(t2) == "string" ? t2[t2.length - 1] += e5 : t2.push(e5), t2.push(...r2);
      }
      return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e4) ? t2 : Object.assign(Object.assign({}, e4), {}, { parts: t2 });
    }(e3));
  }
  function Oi$2(e2) {
    const t2 = [], n2 = e2.filter(Boolean);
    for (; n2.length > 0; ) {
      const e3 = n2.shift();
      e3 && (bi$2(e3) ? n2.unshift(...Ai$2(e3)) : t2.length > 0 && typeof Ln$2(t2) == "string" && typeof e3 == "string" ? t2[t2.length - 1] += e3 : t2.push(e3));
    }
    return t2;
  }
  function Ii$2(e2, t2 = Ei$2) {
    return Ci$2(t2, e2.split("\n")).parts;
  }
  var Li$2 = { isConcat: bi$2, getDocParts: Ai$2, willBreak: function(e2) {
    return xi$2(e2, wi$2, false);
  }, traverseDoc: Fi$2, findInDoc: xi$2, mapDoc: Si$2, propagateBreaks: function(e2) {
    const t2 = new Set(), n2 = [];
    Fi$2(e2, function(e3) {
      if (e3.type === "break-parent" && Ti$2(n2), e3.type === "group") {
        if (n2.push(e3), t2.has(e3))
          return false;
        t2.add(e3);
      }
    }, function(e3) {
      if (e3.type === "group") {
        n2.pop().break && Ti$2(n2);
      }
    }, true);
  }, removeLines: function(e2) {
    return Si$2(e2, Bi$2);
  }, stripTrailingHardline: function(e2) {
    return ki$2(Pi$2(e2));
  }, normalizeParts: Oi$2, normalizeDoc: function(e2) {
    return Si$2(e2, (e3) => Array.isArray(e3) ? Oi$2(e3) : e3.parts ? Object.assign(Object.assign({}, e3), {}, { parts: Oi$2(e3.parts) }) : e3);
  }, cleanDoc: Pi$2, replaceTextEndOfLine: Ii$2, replaceEndOfLine: function(e2) {
    return Si$2(e2, (e3) => typeof e3 == "string" && e3.includes("\n") ? Ii$2(e3) : e3);
  } };
  const { getStringWidth: ji$2, getLast: _i$2 } = yi$2, { convertEndOfLineToChars: Mi$2 } = Di$2, { fill: Ri$2, cursor: $i$2, indent: Vi$2 } = xn$2, { isConcat: Wi$2, getDocParts: qi$2 } = Li$2;
  let Ui$2;
  function zi$2(e2, t2) {
    return Hi$2(e2, { type: "indent" }, t2);
  }
  function Gi$2(e2, t2, n2) {
    if (t2 === Number.NEGATIVE_INFINITY)
      return e2.root || { value: "", length: 0, queue: [] };
    if (t2 < 0)
      return Hi$2(e2, { type: "dedent" }, n2);
    if (!t2)
      return e2;
    if (t2.type === "root")
      return Object.assign(Object.assign({}, e2), {}, { root: e2 });
    return Hi$2(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, n2);
  }
  function Hi$2(e2, t2, n2) {
    const r2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2];
    let i2 = "", u2 = 0, o2 = 0, s2 = 0;
    for (const e3 of r2)
      switch (e3.type) {
        case "indent":
          l2(), n2.useTabs ? a2(1) : c2(n2.tabWidth);
          break;
        case "stringAlign":
          l2(), i2 += e3.n, u2 += e3.n.length;
          break;
        case "numberAlign":
          o2 += 1, s2 += e3.n;
          break;
        default:
          throw new Error(`Unexpected type '${e3.type}'`);
      }
    return p2(), Object.assign(Object.assign({}, e2), {}, { value: i2, length: u2, queue: r2 });
    function a2(e3) {
      i2 += "	".repeat(e3), u2 += n2.tabWidth * e3;
    }
    function c2(e3) {
      i2 += " ".repeat(e3), u2 += e3;
    }
    function l2() {
      n2.useTabs ? function() {
        o2 > 0 && a2(o2);
        f2();
      }() : p2();
    }
    function p2() {
      s2 > 0 && c2(s2), f2();
    }
    function f2() {
      o2 = 0, s2 = 0;
    }
  }
  function Ji$2(e2) {
    if (e2.length === 0)
      return 0;
    let t2 = 0;
    for (; e2.length > 0 && typeof _i$2(e2) == "string" && /^[\t ]*$/.test(_i$2(e2)); )
      t2 += e2.pop().length;
    if (e2.length > 0 && typeof _i$2(e2) == "string") {
      const n2 = _i$2(e2).replace(/[\t ]*$/, "");
      t2 += _i$2(e2).length - n2.length, e2[e2.length - 1] = n2;
    }
    return t2;
  }
  function Xi$2(e2, t2, n2, r2, i2, u2) {
    let o2 = t2.length;
    const s2 = [e2], a2 = [];
    for (; n2 >= 0; ) {
      if (s2.length === 0) {
        if (o2 === 0)
          return true;
        s2.push(t2[o2 - 1]), o2--;
        continue;
      }
      const [e3, c2, l2] = s2.pop();
      if (typeof l2 == "string")
        a2.push(l2), n2 -= ji$2(l2);
      else if (Wi$2(l2)) {
        const t3 = qi$2(l2);
        for (let n3 = t3.length - 1; n3 >= 0; n3--)
          s2.push([e3, c2, t3[n3]]);
      } else
        switch (l2.type) {
          case "indent":
            s2.push([zi$2(e3, r2), c2, l2.contents]);
            break;
          case "align":
            s2.push([Gi$2(e3, l2.n, r2), c2, l2.contents]);
            break;
          case "trim":
            n2 += Ji$2(a2);
            break;
          case "group": {
            if (u2 && l2.break)
              return false;
            const t3 = l2.break ? 1 : c2;
            s2.push([e3, t3, l2.expandedStates && t3 === 1 ? _i$2(l2.expandedStates) : l2.contents]), l2.id && (Ui$2[l2.id] = t3);
            break;
          }
          case "fill":
            for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
              s2.push([e3, c2, l2.parts[t3]]);
            break;
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Ui$2[l2.groupId] : c2;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
              t4 && s2.push([e3, c2, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
              t4 && s2.push([e3, c2, t4]);
            }
            break;
          }
          case "line":
            switch (c2) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (a2.push(" "), n2 -= 1);
                  break;
                }
                return true;
              case 1:
                return true;
            }
            break;
          case "line-suffix":
            i2 = true;
            break;
          case "line-suffix-boundary":
            if (i2)
              return false;
            break;
          case "label":
            s2.push([e3, c2, l2.contents]);
        }
    }
    return false;
  }
  var Yi$2 = { printDocToString: function(e2, t2) {
    Ui$2 = {};
    const n2 = t2.printWidth, r2 = Mi$2(t2.endOfLine);
    let i2 = 0;
    const u2 = [[{ value: "", length: 0, queue: [] }, 1, e2]], o2 = [];
    let s2 = false, a2 = [];
    for (; u2.length > 0; ) {
      const [e3, c3, l2] = u2.pop();
      if (typeof l2 == "string") {
        const e4 = r2 !== "\n" ? l2.replace(/\n/g, r2) : l2;
        o2.push(e4), i2 += ji$2(e4);
      } else if (Wi$2(l2)) {
        const t3 = qi$2(l2);
        for (let n3 = t3.length - 1; n3 >= 0; n3--)
          u2.push([e3, c3, t3[n3]]);
      } else
        switch (l2.type) {
          case "cursor":
            o2.push($i$2.placeholder);
            break;
          case "indent":
            u2.push([zi$2(e3, t2), c3, l2.contents]);
            break;
          case "align":
            u2.push([Gi$2(e3, l2.n, t2), c3, l2.contents]);
            break;
          case "trim":
            i2 -= Ji$2(o2);
            break;
          case "group":
            switch (c3) {
              case 2:
                if (!s2) {
                  u2.push([e3, l2.break ? 1 : 2, l2.contents]);
                  break;
                }
              case 1: {
                s2 = false;
                const r3 = [e3, 2, l2.contents], o3 = n2 - i2, c4 = a2.length > 0;
                if (!l2.break && Xi$2(r3, u2, o3, t2, c4))
                  u2.push(r3);
                else if (l2.expandedStates) {
                  const n3 = _i$2(l2.expandedStates);
                  if (l2.break) {
                    u2.push([e3, 1, n3]);
                    break;
                  }
                  for (let r4 = 1; r4 < l2.expandedStates.length + 1; r4++) {
                    if (r4 >= l2.expandedStates.length) {
                      u2.push([e3, 1, n3]);
                      break;
                    }
                    {
                      const n4 = [e3, 2, l2.expandedStates[r4]];
                      if (Xi$2(n4, u2, o3, t2, c4)) {
                        u2.push(n4);
                        break;
                      }
                    }
                  }
                } else
                  u2.push([e3, 1, l2.contents]);
                break;
              }
            }
            l2.id && (Ui$2[l2.id] = _i$2(u2)[1]);
            break;
          case "fill": {
            const r3 = n2 - i2, { parts: o3 } = l2;
            if (o3.length === 0)
              break;
            const [s3, p2] = o3, f2 = [e3, 2, s3], d2 = [e3, 1, s3], h2 = Xi$2(f2, [], r3, t2, a2.length > 0, true);
            if (o3.length === 1) {
              h2 ? u2.push(f2) : u2.push(d2);
              break;
            }
            const g2 = [e3, 2, p2], m2 = [e3, 1, p2];
            if (o3.length === 2) {
              h2 ? u2.push(g2, f2) : u2.push(m2, d2);
              break;
            }
            o3.splice(0, 2);
            const y2 = [e3, c3, Ri$2(o3)];
            Xi$2([e3, 2, [s3, p2, o3[0]]], [], r3, t2, a2.length > 0, true) ? u2.push(y2, g2, f2) : h2 ? u2.push(y2, m2, f2) : u2.push(y2, m2, d2);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Ui$2[l2.groupId] : c3;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
              t4 && u2.push([e3, c3, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
              t4 && u2.push([e3, c3, t4]);
            }
            break;
          }
          case "line-suffix":
            a2.push([e3, c3, l2.contents]);
            break;
          case "line-suffix-boundary":
            a2.length > 0 && u2.push([e3, c3, { type: "line", hard: true }]);
            break;
          case "line":
            switch (c3) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (o2.push(" "), i2 += 1);
                  break;
                }
                s2 = true;
              case 1:
                if (a2.length > 0) {
                  u2.push([e3, c3, l2], ...a2.reverse()), a2 = [];
                  break;
                }
                l2.literal ? e3.root ? (o2.push(r2, e3.root.value), i2 = e3.root.length) : (o2.push(r2), i2 = 0) : (i2 -= Ji$2(o2), o2.push(r2 + e3.value), i2 = e3.length);
            }
            break;
          case "label":
            u2.push([e3, c3, l2.contents]);
        }
      u2.length === 0 && a2.length > 0 && (u2.push(...a2.reverse()), a2 = []);
    }
    const c2 = o2.indexOf($i$2.placeholder);
    if (c2 !== -1) {
      const e3 = o2.indexOf($i$2.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), n3 = o2.slice(c2 + 1, e3).join("");
      return { formatted: t3 + n3 + o2.slice(e3 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: n3 };
    }
    return { formatted: o2.join("") };
  } };
  const { isConcat: Ki$2, getDocParts: Qi$2 } = Li$2;
  function Zi$2(e2) {
    if (!e2)
      return "";
    if (Ki$2(e2)) {
      const t2 = [];
      for (const n2 of Qi$2(e2))
        if (Ki$2(n2))
          t2.push(...Zi$2(n2).parts);
        else {
          const e3 = Zi$2(n2);
          e3 !== "" && t2.push(e3);
        }
      return { type: "concat", parts: t2 };
    }
    return e2.type === "if-break" ? Object.assign(Object.assign({}, e2), {}, { breakContents: Zi$2(e2.breakContents), flatContents: Zi$2(e2.flatContents) }) : e2.type === "group" ? Object.assign(Object.assign({}, e2), {}, { contents: Zi$2(e2.contents), expandedStates: e2.expandedStates && e2.expandedStates.map(Zi$2) }) : e2.type === "fill" ? { type: "fill", parts: e2.parts.map(Zi$2) } : e2.contents ? Object.assign(Object.assign({}, e2), {}, { contents: Zi$2(e2.contents) }) : e2;
  }
  var eu$1 = { builders: xn$2, printer: Yi$2, utils: Li$2, debug: { printDocToDebug: function(e2) {
    const t2 = Object.create(null), n2 = new Set();
    return function e3(t3, n3, i2) {
      if (typeof t3 == "string")
        return JSON.stringify(t3);
      if (Ki$2(t3)) {
        const n4 = Qi$2(t3).map(e3).filter(Boolean);
        return n4.length === 1 ? n4[0] : `[${n4.join(", ")}]`;
      }
      if (t3.type === "line") {
        const e4 = Array.isArray(i2) && i2[n3 + 1] && i2[n3 + 1].type === "break-parent";
        return t3.literal ? e4 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e4 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
      }
      if (t3.type === "break-parent") {
        return Array.isArray(i2) && i2[n3 - 1] && i2[n3 - 1].type === "line" && i2[n3 - 1].hard ? void 0 : "breakParent";
      }
      if (t3.type === "trim")
        return "trim";
      if (t3.type === "indent")
        return "indent(" + e3(t3.contents) + ")";
      if (t3.type === "align")
        return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e3(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e3(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e3(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e3(t3.contents) + ")";
      if (t3.type === "if-break")
        return "ifBreak(" + e3(t3.breakContents) + (t3.flatContents ? ", " + e3(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${r2(t3.groupId)} }` : "") + ")";
      if (t3.type === "indent-if-break") {
        const n4 = [];
        t3.negate && n4.push("negate: true"), t3.groupId && n4.push(`groupId: ${r2(t3.groupId)}`);
        const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
        return `indentIfBreak(${e3(t3.contents)}${i3})`;
      }
      if (t3.type === "group") {
        const n4 = [];
        t3.break && t3.break !== "propagated" && n4.push("shouldBreak: true"), t3.id && n4.push(`id: ${r2(t3.id)}`);
        const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
        return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e3(t4)).join(",")}]${i3})` : `group(${e3(t3.contents)}${i3})`;
      }
      if (t3.type === "fill")
        return `fill([${t3.parts.map((t4) => e3(t4)).join(", ")}])`;
      if (t3.type === "line-suffix")
        return "lineSuffix(" + e3(t3.contents) + ")";
      if (t3.type === "line-suffix-boundary")
        return "lineSuffixBoundary";
      if (t3.type === "label")
        return `label(${JSON.stringify(t3.label)}, ${e3(t3.contents)})`;
      throw new Error("Unknown doc type " + t3.type);
    }(Zi$2(e2));
    function r2(e3) {
      if (typeof e3 != "symbol")
        return JSON.stringify(String(e3));
      if (e3 in t2)
        return t2[e3];
      const r3 = String(e3).slice(7, -1) || "symbol";
      for (let i2 = 0; ; i2++) {
        const u2 = r3 + (i2 > 0 ? ` #${i2}` : "");
        if (!n2.has(u2))
          return n2.add(u2), t2[e3] = `Symbol.for(${JSON.stringify(u2)})`;
      }
    }
  } } }, tu$1 = Object.freeze({ __proto__: null, default: {} });
  function nu$1(e2, t2) {
    for (var n2 = 0, r2 = e2.length - 1; r2 >= 0; r2--) {
      var i2 = e2[r2];
      i2 === "." ? e2.splice(r2, 1) : i2 === ".." ? (e2.splice(r2, 1), n2++) : n2 && (e2.splice(r2, 1), n2--);
    }
    if (t2)
      for (; n2--; n2)
        e2.unshift("..");
    return e2;
  }
  var ru$1 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, iu$1 = function(e2) {
    return ru$1.exec(e2).slice(1);
  };
  function uu$1() {
    for (var e2 = "", t2 = false, n2 = arguments.length - 1; n2 >= -1 && !t2; n2--) {
      var r2 = n2 >= 0 ? arguments[n2] : "/";
      if (typeof r2 != "string")
        throw new TypeError("Arguments to path.resolve must be strings");
      r2 && (e2 = r2 + "/" + e2, t2 = r2.charAt(0) === "/");
    }
    return (t2 ? "/" : "") + (e2 = nu$1(hu$1(e2.split("/"), function(e3) {
      return !!e3;
    }), !t2).join("/")) || ".";
  }
  function ou$1(e2) {
    var t2 = su$1(e2), n2 = gu$1(e2, -1) === "/";
    return (e2 = nu$1(hu$1(e2.split("/"), function(e3) {
      return !!e3;
    }), !t2).join("/")) || t2 || (e2 = "."), e2 && n2 && (e2 += "/"), (t2 ? "/" : "") + e2;
  }
  function su$1(e2) {
    return e2.charAt(0) === "/";
  }
  function au$1() {
    var e2 = Array.prototype.slice.call(arguments, 0);
    return ou$1(hu$1(e2, function(e3, t2) {
      if (typeof e3 != "string")
        throw new TypeError("Arguments to path.join must be strings");
      return e3;
    }).join("/"));
  }
  function cu$1(e2, t2) {
    function n2(e3) {
      for (var t3 = 0; t3 < e3.length && e3[t3] === ""; t3++)
        ;
      for (var n3 = e3.length - 1; n3 >= 0 && e3[n3] === ""; n3--)
        ;
      return t3 > n3 ? [] : e3.slice(t3, n3 - t3 + 1);
    }
    e2 = uu$1(e2).substr(1), t2 = uu$1(t2).substr(1);
    for (var r2 = n2(e2.split("/")), i2 = n2(t2.split("/")), u2 = Math.min(r2.length, i2.length), o2 = u2, s2 = 0; s2 < u2; s2++)
      if (r2[s2] !== i2[s2]) {
        o2 = s2;
        break;
      }
    var a2 = [];
    for (s2 = o2; s2 < r2.length; s2++)
      a2.push("..");
    return (a2 = a2.concat(i2.slice(o2))).join("/");
  }
  function lu$1(e2) {
    var t2 = iu$1(e2), n2 = t2[0], r2 = t2[1];
    return n2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), n2 + r2) : ".";
  }
  function pu$1(e2, t2) {
    var n2 = iu$1(e2)[2];
    return t2 && n2.substr(-1 * t2.length) === t2 && (n2 = n2.substr(0, n2.length - t2.length)), n2;
  }
  function fu$1(e2) {
    return iu$1(e2)[3];
  }
  var du$1 = { extname: fu$1, basename: pu$1, dirname: lu$1, sep: "/", delimiter: ":", relative: cu$1, join: au$1, isAbsolute: su$1, normalize: ou$1, resolve: uu$1 };
  function hu$1(e2, t2) {
    if (e2.filter)
      return e2.filter(t2);
    for (var n2 = [], r2 = 0; r2 < e2.length; r2++)
      t2(e2[r2], r2, e2) && n2.push(e2[r2]);
    return n2;
  }
  var gu$1 = "ab".substr(-1) === "b" ? function(e2, t2, n2) {
    return e2.substr(t2, n2);
  } : function(e2, t2, n2) {
    return t2 < 0 && (t2 = e2.length + t2), e2.substr(t2, n2);
  }, mu$1 = Object.freeze({ __proto__: null, resolve: uu$1, normalize: ou$1, isAbsolute: su$1, join: au$1, relative: cu$1, sep: "/", delimiter: ":", dirname: lu$1, basename: pu$1, extname: fu$1, default: du$1 }), yu$1 = [], Du$1 = [], Eu$1 = typeof Uint8Array != "undefined" ? Uint8Array : Array, Cu$1 = false;
  function bu$1() {
    Cu$1 = true;
    for (var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, n2 = e2.length; t2 < n2; ++t2)
      yu$1[t2] = e2[t2], Du$1[e2.charCodeAt(t2)] = t2;
    Du$1["-".charCodeAt(0)] = 62, Du$1["_".charCodeAt(0)] = 63;
  }
  function Au$1(e2, t2, n2) {
    for (var r2, i2, u2 = [], o2 = t2; o2 < n2; o2 += 3)
      r2 = (e2[o2] << 16) + (e2[o2 + 1] << 8) + e2[o2 + 2], u2.push(yu$1[(i2 = r2) >> 18 & 63] + yu$1[i2 >> 12 & 63] + yu$1[i2 >> 6 & 63] + yu$1[63 & i2]);
    return u2.join("");
  }
  function vu$1(e2) {
    var t2;
    Cu$1 || bu$1();
    for (var n2 = e2.length, r2 = n2 % 3, i2 = "", u2 = [], o2 = 16383, s2 = 0, a2 = n2 - r2; s2 < a2; s2 += o2)
      u2.push(Au$1(e2, s2, s2 + o2 > a2 ? a2 : s2 + o2));
    return r2 === 1 ? (t2 = e2[n2 - 1], i2 += yu$1[t2 >> 2], i2 += yu$1[t2 << 4 & 63], i2 += "==") : r2 === 2 && (t2 = (e2[n2 - 2] << 8) + e2[n2 - 1], i2 += yu$1[t2 >> 10], i2 += yu$1[t2 >> 4 & 63], i2 += yu$1[t2 << 2 & 63], i2 += "="), u2.push(i2), u2.join("");
  }
  function Fu$1(e2, t2, n2, r2, i2) {
    var u2, o2, s2 = 8 * i2 - r2 - 1, a2 = (1 << s2) - 1, c2 = a2 >> 1, l2 = -7, p2 = n2 ? i2 - 1 : 0, f2 = n2 ? -1 : 1, d2 = e2[t2 + p2];
    for (p2 += f2, u2 = d2 & (1 << -l2) - 1, d2 >>= -l2, l2 += s2; l2 > 0; u2 = 256 * u2 + e2[t2 + p2], p2 += f2, l2 -= 8)
      ;
    for (o2 = u2 & (1 << -l2) - 1, u2 >>= -l2, l2 += r2; l2 > 0; o2 = 256 * o2 + e2[t2 + p2], p2 += f2, l2 -= 8)
      ;
    if (u2 === 0)
      u2 = 1 - c2;
    else {
      if (u2 === a2)
        return o2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
      o2 += Math.pow(2, r2), u2 -= c2;
    }
    return (d2 ? -1 : 1) * o2 * Math.pow(2, u2 - r2);
  }
  function Su$1(e2, t2, n2, r2, i2, u2) {
    var o2, s2, a2, c2 = 8 * u2 - i2 - 1, l2 = (1 << c2) - 1, p2 = l2 >> 1, f2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : u2 - 1, h2 = r2 ? 1 : -1, g2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
    for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = l2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (a2 = Math.pow(2, -o2)) < 1 && (o2--, a2 *= 2), (t2 += o2 + p2 >= 1 ? f2 / a2 : f2 * Math.pow(2, 1 - p2)) * a2 >= 2 && (o2++, a2 /= 2), o2 + p2 >= l2 ? (s2 = 0, o2 = l2) : o2 + p2 >= 1 ? (s2 = (t2 * a2 - 1) * Math.pow(2, i2), o2 += p2) : (s2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; e2[n2 + d2] = 255 & s2, d2 += h2, s2 /= 256, i2 -= 8)
      ;
    for (o2 = o2 << i2 | s2, c2 += i2; c2 > 0; e2[n2 + d2] = 255 & o2, d2 += h2, o2 /= 256, c2 -= 8)
      ;
    e2[n2 + d2 - h2] |= 128 * g2;
  }
  var xu$1 = {}.toString, wu$1 = Array.isArray || function(e2) {
    return xu$1.call(e2) == "[object Array]";
  };
  function Tu$1() {
    return Nu$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function Bu$1(e2, t2) {
    if (Tu$1() < t2)
      throw new RangeError("Invalid typed array length");
    return Nu$1.TYPED_ARRAY_SUPPORT ? (e2 = new Uint8Array(t2)).__proto__ = Nu$1.prototype : (e2 === null && (e2 = new Nu$1(t2)), e2.length = t2), e2;
  }
  function Nu$1(e2, t2, n2) {
    if (!(Nu$1.TYPED_ARRAY_SUPPORT || this instanceof Nu$1))
      return new Nu$1(e2, t2, n2);
    if (typeof e2 == "number") {
      if (typeof t2 == "string")
        throw new Error("If encoding is specified then the first argument must be a string");
      return Ou$1(this, e2);
    }
    return ku$1(this, e2, t2, n2);
  }
  function ku$1(e2, t2, n2, r2) {
    if (typeof t2 == "number")
      throw new TypeError('"value" argument must not be a number');
    return typeof ArrayBuffer != "undefined" && t2 instanceof ArrayBuffer ? function(e3, t3, n3, r3) {
      if (t3.byteLength, n3 < 0 || t3.byteLength < n3)
        throw new RangeError("'offset' is out of bounds");
      if (t3.byteLength < n3 + (r3 || 0))
        throw new RangeError("'length' is out of bounds");
      t3 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t3) : r3 === void 0 ? new Uint8Array(t3, n3) : new Uint8Array(t3, n3, r3);
      Nu$1.TYPED_ARRAY_SUPPORT ? (e3 = t3).__proto__ = Nu$1.prototype : e3 = Iu$1(e3, t3);
      return e3;
    }(e2, t2, n2, r2) : typeof t2 == "string" ? function(e3, t3, n3) {
      typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
      if (!Nu$1.isEncoding(n3))
        throw new TypeError('"encoding" must be a valid string encoding');
      var r3 = 0 | _u$1(t3, n3), i2 = (e3 = Bu$1(e3, r3)).write(t3, n3);
      i2 !== r3 && (e3 = e3.slice(0, i2));
      return e3;
    }(e2, t2, n2) : function(e3, t3) {
      if (ju$1(t3)) {
        var n3 = 0 | Lu$1(t3.length);
        return (e3 = Bu$1(e3, n3)).length === 0 || t3.copy(e3, 0, 0, n3), e3;
      }
      if (t3) {
        if (typeof ArrayBuffer != "undefined" && t3.buffer instanceof ArrayBuffer || "length" in t3)
          return typeof t3.length != "number" || (r3 = t3.length) != r3 ? Bu$1(e3, 0) : Iu$1(e3, t3);
        if (t3.type === "Buffer" && wu$1(t3.data))
          return Iu$1(e3, t3.data);
      }
      var r3;
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }(e2, t2);
  }
  function Pu$1(e2) {
    if (typeof e2 != "number")
      throw new TypeError('"size" argument must be a number');
    if (e2 < 0)
      throw new RangeError('"size" argument must not be negative');
  }
  function Ou$1(e2, t2) {
    if (Pu$1(t2), e2 = Bu$1(e2, t2 < 0 ? 0 : 0 | Lu$1(t2)), !Nu$1.TYPED_ARRAY_SUPPORT)
      for (var n2 = 0; n2 < t2; ++n2)
        e2[n2] = 0;
    return e2;
  }
  function Iu$1(e2, t2) {
    var n2 = t2.length < 0 ? 0 : 0 | Lu$1(t2.length);
    e2 = Bu$1(e2, n2);
    for (var r2 = 0; r2 < n2; r2 += 1)
      e2[r2] = 255 & t2[r2];
    return e2;
  }
  function Lu$1(e2) {
    if (e2 >= Tu$1())
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Tu$1().toString(16) + " bytes");
    return 0 | e2;
  }
  function ju$1(e2) {
    return !(e2 == null || !e2._isBuffer);
  }
  function _u$1(e2, t2) {
    if (ju$1(e2))
      return e2.length;
    if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer))
      return e2.byteLength;
    typeof e2 != "string" && (e2 = "" + e2);
    var n2 = e2.length;
    if (n2 === 0)
      return 0;
    for (var r2 = false; ; )
      switch (t2) {
        case "ascii":
        case "latin1":
        case "binary":
          return n2;
        case "utf8":
        case "utf-8":
        case void 0:
          return co$2(e2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * n2;
        case "hex":
          return n2 >>> 1;
        case "base64":
          return lo$2(e2).length;
        default:
          if (r2)
            return co$2(e2).length;
          t2 = ("" + t2).toLowerCase(), r2 = true;
      }
  }
  function Mu$1(e2, t2, n2) {
    var r2 = false;
    if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length)
      return "";
    if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
      return "";
    if ((n2 >>>= 0) <= (t2 >>>= 0))
      return "";
    for (e2 || (e2 = "utf8"); ; )
      switch (e2) {
        case "hex":
          return Qu(this, t2, n2);
        case "utf8":
        case "utf-8":
          return Xu(this, t2, n2);
        case "ascii":
          return Yu(this, t2, n2);
        case "latin1":
        case "binary":
          return Ku(this, t2, n2);
        case "base64":
          return Ju(this, t2, n2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Zu(this, t2, n2);
        default:
          if (r2)
            throw new TypeError("Unknown encoding: " + e2);
          e2 = (e2 + "").toLowerCase(), r2 = true;
      }
  }
  function Ru$1(e2, t2, n2) {
    var r2 = e2[t2];
    e2[t2] = e2[n2], e2[n2] = r2;
  }
  function $u(e2, t2, n2, r2, i2) {
    if (e2.length === 0)
      return -1;
    if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = i2 ? 0 : e2.length - 1), n2 < 0 && (n2 = e2.length + n2), n2 >= e2.length) {
      if (i2)
        return -1;
      n2 = e2.length - 1;
    } else if (n2 < 0) {
      if (!i2)
        return -1;
      n2 = 0;
    }
    if (typeof t2 == "string" && (t2 = Nu$1.from(t2, r2)), ju$1(t2))
      return t2.length === 0 ? -1 : Vu(e2, t2, n2, r2, i2);
    if (typeof t2 == "number")
      return t2 &= 255, Nu$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e2, t2, n2) : Uint8Array.prototype.lastIndexOf.call(e2, t2, n2) : Vu(e2, [t2], n2, r2, i2);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Vu(e2, t2, n2, r2, i2) {
    var u2, o2 = 1, s2 = e2.length, a2 = t2.length;
    if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
      if (e2.length < 2 || t2.length < 2)
        return -1;
      o2 = 2, s2 /= 2, a2 /= 2, n2 /= 2;
    }
    function c2(e3, t3) {
      return o2 === 1 ? e3[t3] : e3.readUInt16BE(t3 * o2);
    }
    if (i2) {
      var l2 = -1;
      for (u2 = n2; u2 < s2; u2++)
        if (c2(e2, u2) === c2(t2, l2 === -1 ? 0 : u2 - l2)) {
          if (l2 === -1 && (l2 = u2), u2 - l2 + 1 === a2)
            return l2 * o2;
        } else
          l2 !== -1 && (u2 -= u2 - l2), l2 = -1;
    } else
      for (n2 + a2 > s2 && (n2 = s2 - a2), u2 = n2; u2 >= 0; u2--) {
        for (var p2 = true, f2 = 0; f2 < a2; f2++)
          if (c2(e2, u2 + f2) !== c2(t2, f2)) {
            p2 = false;
            break;
          }
        if (p2)
          return u2;
      }
    return -1;
  }
  function Wu(e2, t2, n2, r2) {
    n2 = Number(n2) || 0;
    var i2 = e2.length - n2;
    r2 ? (r2 = Number(r2)) > i2 && (r2 = i2) : r2 = i2;
    var u2 = t2.length;
    if (u2 % 2 != 0)
      throw new TypeError("Invalid hex string");
    r2 > u2 / 2 && (r2 = u2 / 2);
    for (var o2 = 0; o2 < r2; ++o2) {
      var s2 = parseInt(t2.substr(2 * o2, 2), 16);
      if (isNaN(s2))
        return o2;
      e2[n2 + o2] = s2;
    }
    return o2;
  }
  function qu(e2, t2, n2, r2) {
    return po$2(co$2(t2, e2.length - n2), e2, n2, r2);
  }
  function Uu$1(e2, t2, n2, r2) {
    return po$2(function(e3) {
      for (var t3 = [], n3 = 0; n3 < e3.length; ++n3)
        t3.push(255 & e3.charCodeAt(n3));
      return t3;
    }(t2), e2, n2, r2);
  }
  function zu(e2, t2, n2, r2) {
    return Uu$1(e2, t2, n2, r2);
  }
  function Gu(e2, t2, n2, r2) {
    return po$2(lo$2(t2), e2, n2, r2);
  }
  function Hu(e2, t2, n2, r2) {
    return po$2(function(e3, t3) {
      for (var n3, r3, i2, u2 = [], o2 = 0; o2 < e3.length && !((t3 -= 2) < 0); ++o2)
        r3 = (n3 = e3.charCodeAt(o2)) >> 8, i2 = n3 % 256, u2.push(i2), u2.push(r3);
      return u2;
    }(t2, e2.length - n2), e2, n2, r2);
  }
  function Ju(e2, t2, n2) {
    return t2 === 0 && n2 === e2.length ? vu$1(e2) : vu$1(e2.slice(t2, n2));
  }
  function Xu(e2, t2, n2) {
    n2 = Math.min(e2.length, n2);
    for (var r2 = [], i2 = t2; i2 < n2; ) {
      var u2, o2, s2, a2, c2 = e2[i2], l2 = null, p2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
      if (i2 + p2 <= n2)
        switch (p2) {
          case 1:
            c2 < 128 && (l2 = c2);
            break;
          case 2:
            (192 & (u2 = e2[i2 + 1])) == 128 && (a2 = (31 & c2) << 6 | 63 & u2) > 127 && (l2 = a2);
            break;
          case 3:
            u2 = e2[i2 + 1], o2 = e2[i2 + 2], (192 & u2) == 128 && (192 & o2) == 128 && (a2 = (15 & c2) << 12 | (63 & u2) << 6 | 63 & o2) > 2047 && (a2 < 55296 || a2 > 57343) && (l2 = a2);
            break;
          case 4:
            u2 = e2[i2 + 1], o2 = e2[i2 + 2], s2 = e2[i2 + 3], (192 & u2) == 128 && (192 & o2) == 128 && (192 & s2) == 128 && (a2 = (15 & c2) << 18 | (63 & u2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && a2 < 1114112 && (l2 = a2);
        }
      l2 === null ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, r2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), r2.push(l2), i2 += p2;
    }
    return function(e3) {
      var t3 = e3.length;
      if (t3 <= 4096)
        return String.fromCharCode.apply(String, e3);
      var n3 = "", r3 = 0;
      for (; r3 < t3; )
        n3 += String.fromCharCode.apply(String, e3.slice(r3, r3 += 4096));
      return n3;
    }(r2);
  }
  Nu$1.TYPED_ARRAY_SUPPORT = nr$2.TYPED_ARRAY_SUPPORT === void 0 || nr$2.TYPED_ARRAY_SUPPORT, Nu$1.poolSize = 8192, Nu$1._augment = function(e2) {
    return e2.__proto__ = Nu$1.prototype, e2;
  }, Nu$1.from = function(e2, t2, n2) {
    return ku$1(null, e2, t2, n2);
  }, Nu$1.TYPED_ARRAY_SUPPORT && (Nu$1.prototype.__proto__ = Uint8Array.prototype, Nu$1.__proto__ = Uint8Array), Nu$1.alloc = function(e2, t2, n2) {
    return function(e3, t3, n3, r2) {
      return Pu$1(t3), t3 <= 0 ? Bu$1(e3, t3) : n3 !== void 0 ? typeof r2 == "string" ? Bu$1(e3, t3).fill(n3, r2) : Bu$1(e3, t3).fill(n3) : Bu$1(e3, t3);
    }(null, e2, t2, n2);
  }, Nu$1.allocUnsafe = function(e2) {
    return Ou$1(null, e2);
  }, Nu$1.allocUnsafeSlow = function(e2) {
    return Ou$1(null, e2);
  }, Nu$1.isBuffer = fo$2, Nu$1.compare = function(e2, t2) {
    if (!ju$1(e2) || !ju$1(t2))
      throw new TypeError("Arguments must be Buffers");
    if (e2 === t2)
      return 0;
    for (var n2 = e2.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
      if (e2[i2] !== t2[i2]) {
        n2 = e2[i2], r2 = t2[i2];
        break;
      }
    return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
  }, Nu$1.isEncoding = function(e2) {
    switch (String(e2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, Nu$1.concat = function(e2, t2) {
    if (!wu$1(e2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e2.length === 0)
      return Nu$1.alloc(0);
    var n2;
    if (t2 === void 0)
      for (t2 = 0, n2 = 0; n2 < e2.length; ++n2)
        t2 += e2[n2].length;
    var r2 = Nu$1.allocUnsafe(t2), i2 = 0;
    for (n2 = 0; n2 < e2.length; ++n2) {
      var u2 = e2[n2];
      if (!ju$1(u2))
        throw new TypeError('"list" argument must be an Array of Buffers');
      u2.copy(r2, i2), i2 += u2.length;
    }
    return r2;
  }, Nu$1.byteLength = _u$1, Nu$1.prototype._isBuffer = true, Nu$1.prototype.swap16 = function() {
    var e2 = this.length;
    if (e2 % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t2 = 0; t2 < e2; t2 += 2)
      Ru$1(this, t2, t2 + 1);
    return this;
  }, Nu$1.prototype.swap32 = function() {
    var e2 = this.length;
    if (e2 % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t2 = 0; t2 < e2; t2 += 4)
      Ru$1(this, t2, t2 + 3), Ru$1(this, t2 + 1, t2 + 2);
    return this;
  }, Nu$1.prototype.swap64 = function() {
    var e2 = this.length;
    if (e2 % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t2 = 0; t2 < e2; t2 += 8)
      Ru$1(this, t2, t2 + 7), Ru$1(this, t2 + 1, t2 + 6), Ru$1(this, t2 + 2, t2 + 5), Ru$1(this, t2 + 3, t2 + 4);
    return this;
  }, Nu$1.prototype.toString = function() {
    var e2 = 0 | this.length;
    return e2 === 0 ? "" : arguments.length === 0 ? Xu(this, 0, e2) : Mu$1.apply(this, arguments);
  }, Nu$1.prototype.equals = function(e2) {
    if (!ju$1(e2))
      throw new TypeError("Argument must be a Buffer");
    return this === e2 || Nu$1.compare(this, e2) === 0;
  }, Nu$1.prototype.inspect = function() {
    var e2 = "";
    return this.length > 0 && (e2 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e2 += " ... ")), "<Buffer " + e2 + ">";
  }, Nu$1.prototype.compare = function(e2, t2, n2, r2, i2) {
    if (!ju$1(e2))
      throw new TypeError("Argument must be a Buffer");
    if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e2 ? e2.length : 0), r2 === void 0 && (r2 = 0), i2 === void 0 && (i2 = this.length), t2 < 0 || n2 > e2.length || r2 < 0 || i2 > this.length)
      throw new RangeError("out of range index");
    if (r2 >= i2 && t2 >= n2)
      return 0;
    if (r2 >= i2)
      return -1;
    if (t2 >= n2)
      return 1;
    if (this === e2)
      return 0;
    for (var u2 = (i2 >>>= 0) - (r2 >>>= 0), o2 = (n2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(u2, o2), a2 = this.slice(r2, i2), c2 = e2.slice(t2, n2), l2 = 0; l2 < s2; ++l2)
      if (a2[l2] !== c2[l2]) {
        u2 = a2[l2], o2 = c2[l2];
        break;
      }
    return u2 < o2 ? -1 : o2 < u2 ? 1 : 0;
  }, Nu$1.prototype.includes = function(e2, t2, n2) {
    return this.indexOf(e2, t2, n2) !== -1;
  }, Nu$1.prototype.indexOf = function(e2, t2, n2) {
    return $u(this, e2, t2, n2, true);
  }, Nu$1.prototype.lastIndexOf = function(e2, t2, n2) {
    return $u(this, e2, t2, n2, false);
  }, Nu$1.prototype.write = function(e2, t2, n2, r2) {
    if (t2 === void 0)
      r2 = "utf8", n2 = this.length, t2 = 0;
    else if (n2 === void 0 && typeof t2 == "string")
      r2 = t2, n2 = this.length, t2 = 0;
    else {
      if (!isFinite(t2))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      t2 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
    }
    var i2 = this.length - t2;
    if ((n2 === void 0 || n2 > i2) && (n2 = i2), e2.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    r2 || (r2 = "utf8");
    for (var u2 = false; ; )
      switch (r2) {
        case "hex":
          return Wu(this, e2, t2, n2);
        case "utf8":
        case "utf-8":
          return qu(this, e2, t2, n2);
        case "ascii":
          return Uu$1(this, e2, t2, n2);
        case "latin1":
        case "binary":
          return zu(this, e2, t2, n2);
        case "base64":
          return Gu(this, e2, t2, n2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Hu(this, e2, t2, n2);
        default:
          if (u2)
            throw new TypeError("Unknown encoding: " + r2);
          r2 = ("" + r2).toLowerCase(), u2 = true;
      }
  }, Nu$1.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Yu(e2, t2, n2) {
    var r2 = "";
    n2 = Math.min(e2.length, n2);
    for (var i2 = t2; i2 < n2; ++i2)
      r2 += String.fromCharCode(127 & e2[i2]);
    return r2;
  }
  function Ku(e2, t2, n2) {
    var r2 = "";
    n2 = Math.min(e2.length, n2);
    for (var i2 = t2; i2 < n2; ++i2)
      r2 += String.fromCharCode(e2[i2]);
    return r2;
  }
  function Qu(e2, t2, n2) {
    var r2 = e2.length;
    (!t2 || t2 < 0) && (t2 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
    for (var i2 = "", u2 = t2; u2 < n2; ++u2)
      i2 += ao$2(e2[u2]);
    return i2;
  }
  function Zu(e2, t2, n2) {
    for (var r2 = e2.slice(t2, n2), i2 = "", u2 = 0; u2 < r2.length; u2 += 2)
      i2 += String.fromCharCode(r2[u2] + 256 * r2[u2 + 1]);
    return i2;
  }
  function eo$2(e2, t2, n2) {
    if (e2 % 1 != 0 || e2 < 0)
      throw new RangeError("offset is not uint");
    if (e2 + t2 > n2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function to$2(e2, t2, n2, r2, i2, u2) {
    if (!ju$1(e2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t2 > i2 || t2 < u2)
      throw new RangeError('"value" argument is out of bounds');
    if (n2 + r2 > e2.length)
      throw new RangeError("Index out of range");
  }
  function no$2(e2, t2, n2, r2) {
    t2 < 0 && (t2 = 65535 + t2 + 1);
    for (var i2 = 0, u2 = Math.min(e2.length - n2, 2); i2 < u2; ++i2)
      e2[n2 + i2] = (t2 & 255 << 8 * (r2 ? i2 : 1 - i2)) >>> 8 * (r2 ? i2 : 1 - i2);
  }
  function ro$2(e2, t2, n2, r2) {
    t2 < 0 && (t2 = 4294967295 + t2 + 1);
    for (var i2 = 0, u2 = Math.min(e2.length - n2, 4); i2 < u2; ++i2)
      e2[n2 + i2] = t2 >>> 8 * (r2 ? i2 : 3 - i2) & 255;
  }
  function io$2(e2, t2, n2, r2, i2, u2) {
    if (n2 + r2 > e2.length)
      throw new RangeError("Index out of range");
    if (n2 < 0)
      throw new RangeError("Index out of range");
  }
  function uo$2(e2, t2, n2, r2, i2) {
    return i2 || io$2(e2, 0, n2, 4), Su$1(e2, t2, n2, r2, 23, 4), n2 + 4;
  }
  function oo$2(e2, t2, n2, r2, i2) {
    return i2 || io$2(e2, 0, n2, 8), Su$1(e2, t2, n2, r2, 52, 8), n2 + 8;
  }
  Nu$1.prototype.slice = function(e2, t2) {
    var n2, r2 = this.length;
    if ((e2 = ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), (t2 = t2 === void 0 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e2 && (t2 = e2), Nu$1.TYPED_ARRAY_SUPPORT)
      (n2 = this.subarray(e2, t2)).__proto__ = Nu$1.prototype;
    else {
      var i2 = t2 - e2;
      n2 = new Nu$1(i2, void 0);
      for (var u2 = 0; u2 < i2; ++u2)
        n2[u2] = this[u2 + e2];
    }
    return n2;
  }, Nu$1.prototype.readUIntLE = function(e2, t2, n2) {
    e2 |= 0, t2 |= 0, n2 || eo$2(e2, t2, this.length);
    for (var r2 = this[e2], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
      r2 += this[e2 + u2] * i2;
    return r2;
  }, Nu$1.prototype.readUIntBE = function(e2, t2, n2) {
    e2 |= 0, t2 |= 0, n2 || eo$2(e2, t2, this.length);
    for (var r2 = this[e2 + --t2], i2 = 1; t2 > 0 && (i2 *= 256); )
      r2 += this[e2 + --t2] * i2;
    return r2;
  }, Nu$1.prototype.readUInt8 = function(e2, t2) {
    return t2 || eo$2(e2, 1, this.length), this[e2];
  }, Nu$1.prototype.readUInt16LE = function(e2, t2) {
    return t2 || eo$2(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
  }, Nu$1.prototype.readUInt16BE = function(e2, t2) {
    return t2 || eo$2(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
  }, Nu$1.prototype.readUInt32LE = function(e2, t2) {
    return t2 || eo$2(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
  }, Nu$1.prototype.readUInt32BE = function(e2, t2) {
    return t2 || eo$2(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
  }, Nu$1.prototype.readIntLE = function(e2, t2, n2) {
    e2 |= 0, t2 |= 0, n2 || eo$2(e2, t2, this.length);
    for (var r2 = this[e2], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
      r2 += this[e2 + u2] * i2;
    return r2 >= (i2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
  }, Nu$1.prototype.readIntBE = function(e2, t2, n2) {
    e2 |= 0, t2 |= 0, n2 || eo$2(e2, t2, this.length);
    for (var r2 = t2, i2 = 1, u2 = this[e2 + --r2]; r2 > 0 && (i2 *= 256); )
      u2 += this[e2 + --r2] * i2;
    return u2 >= (i2 *= 128) && (u2 -= Math.pow(2, 8 * t2)), u2;
  }, Nu$1.prototype.readInt8 = function(e2, t2) {
    return t2 || eo$2(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
  }, Nu$1.prototype.readInt16LE = function(e2, t2) {
    t2 || eo$2(e2, 2, this.length);
    var n2 = this[e2] | this[e2 + 1] << 8;
    return 32768 & n2 ? 4294901760 | n2 : n2;
  }, Nu$1.prototype.readInt16BE = function(e2, t2) {
    t2 || eo$2(e2, 2, this.length);
    var n2 = this[e2 + 1] | this[e2] << 8;
    return 32768 & n2 ? 4294901760 | n2 : n2;
  }, Nu$1.prototype.readInt32LE = function(e2, t2) {
    return t2 || eo$2(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
  }, Nu$1.prototype.readInt32BE = function(e2, t2) {
    return t2 || eo$2(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
  }, Nu$1.prototype.readFloatLE = function(e2, t2) {
    return t2 || eo$2(e2, 4, this.length), Fu$1(this, e2, true, 23, 4);
  }, Nu$1.prototype.readFloatBE = function(e2, t2) {
    return t2 || eo$2(e2, 4, this.length), Fu$1(this, e2, false, 23, 4);
  }, Nu$1.prototype.readDoubleLE = function(e2, t2) {
    return t2 || eo$2(e2, 8, this.length), Fu$1(this, e2, true, 52, 8);
  }, Nu$1.prototype.readDoubleBE = function(e2, t2) {
    return t2 || eo$2(e2, 8, this.length), Fu$1(this, e2, false, 52, 8);
  }, Nu$1.prototype.writeUIntLE = function(e2, t2, n2, r2) {
    (e2 = +e2, t2 |= 0, n2 |= 0, r2) || to$2(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
    var i2 = 1, u2 = 0;
    for (this[t2] = 255 & e2; ++u2 < n2 && (i2 *= 256); )
      this[t2 + u2] = e2 / i2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeUIntBE = function(e2, t2, n2, r2) {
    (e2 = +e2, t2 |= 0, n2 |= 0, r2) || to$2(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
    var i2 = n2 - 1, u2 = 1;
    for (this[t2 + i2] = 255 & e2; --i2 >= 0 && (u2 *= 256); )
      this[t2 + i2] = e2 / u2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeUInt8 = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 1, 255, 0), Nu$1.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t2] = 255 & e2, t2 + 1;
  }, Nu$1.prototype.writeUInt16LE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : no$2(this, e2, t2, true), t2 + 2;
  }, Nu$1.prototype.writeUInt16BE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : no$2(this, e2, t2, false), t2 + 2;
  }, Nu$1.prototype.writeUInt32LE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e2 >>> 24, this[t2 + 2] = e2 >>> 16, this[t2 + 1] = e2 >>> 8, this[t2] = 255 & e2) : ro$2(this, e2, t2, true), t2 + 4;
  }, Nu$1.prototype.writeUInt32BE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : ro$2(this, e2, t2, false), t2 + 4;
  }, Nu$1.prototype.writeIntLE = function(e2, t2, n2, r2) {
    if (e2 = +e2, t2 |= 0, !r2) {
      var i2 = Math.pow(2, 8 * n2 - 1);
      to$2(this, e2, t2, n2, i2 - 1, -i2);
    }
    var u2 = 0, o2 = 1, s2 = 0;
    for (this[t2] = 255 & e2; ++u2 < n2 && (o2 *= 256); )
      e2 < 0 && s2 === 0 && this[t2 + u2 - 1] !== 0 && (s2 = 1), this[t2 + u2] = (e2 / o2 >> 0) - s2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeIntBE = function(e2, t2, n2, r2) {
    if (e2 = +e2, t2 |= 0, !r2) {
      var i2 = Math.pow(2, 8 * n2 - 1);
      to$2(this, e2, t2, n2, i2 - 1, -i2);
    }
    var u2 = n2 - 1, o2 = 1, s2 = 0;
    for (this[t2 + u2] = 255 & e2; --u2 >= 0 && (o2 *= 256); )
      e2 < 0 && s2 === 0 && this[t2 + u2 + 1] !== 0 && (s2 = 1), this[t2 + u2] = (e2 / o2 >> 0) - s2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeInt8 = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 1, 127, -128), Nu$1.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t2] = 255 & e2, t2 + 1;
  }, Nu$1.prototype.writeInt16LE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : no$2(this, e2, t2, true), t2 + 2;
  }, Nu$1.prototype.writeInt16BE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : no$2(this, e2, t2, false), t2 + 2;
  }, Nu$1.prototype.writeInt32LE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 4, 2147483647, -2147483648), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8, this[t2 + 2] = e2 >>> 16, this[t2 + 3] = e2 >>> 24) : ro$2(this, e2, t2, true), t2 + 4;
  }, Nu$1.prototype.writeInt32BE = function(e2, t2, n2) {
    return e2 = +e2, t2 |= 0, n2 || to$2(this, e2, t2, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : ro$2(this, e2, t2, false), t2 + 4;
  }, Nu$1.prototype.writeFloatLE = function(e2, t2, n2) {
    return uo$2(this, e2, t2, true, n2);
  }, Nu$1.prototype.writeFloatBE = function(e2, t2, n2) {
    return uo$2(this, e2, t2, false, n2);
  }, Nu$1.prototype.writeDoubleLE = function(e2, t2, n2) {
    return oo$2(this, e2, t2, true, n2);
  }, Nu$1.prototype.writeDoubleBE = function(e2, t2, n2) {
    return oo$2(this, e2, t2, false, n2);
  }, Nu$1.prototype.copy = function(e2, t2, n2, r2) {
    if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t2 >= e2.length && (t2 = e2.length), t2 || (t2 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
      return 0;
    if (e2.length === 0 || this.length === 0)
      return 0;
    if (t2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (n2 < 0 || n2 >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (r2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    r2 > this.length && (r2 = this.length), e2.length - t2 < r2 - n2 && (r2 = e2.length - t2 + n2);
    var i2, u2 = r2 - n2;
    if (this === e2 && n2 < t2 && t2 < r2)
      for (i2 = u2 - 1; i2 >= 0; --i2)
        e2[i2 + t2] = this[i2 + n2];
    else if (u2 < 1e3 || !Nu$1.TYPED_ARRAY_SUPPORT)
      for (i2 = 0; i2 < u2; ++i2)
        e2[i2 + t2] = this[i2 + n2];
    else
      Uint8Array.prototype.set.call(e2, this.subarray(n2, n2 + u2), t2);
    return u2;
  }, Nu$1.prototype.fill = function(e2, t2, n2, r2) {
    if (typeof e2 == "string") {
      if (typeof t2 == "string" ? (r2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e2.length === 1) {
        var i2 = e2.charCodeAt(0);
        i2 < 256 && (e2 = i2);
      }
      if (r2 !== void 0 && typeof r2 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof r2 == "string" && !Nu$1.isEncoding(r2))
        throw new TypeError("Unknown encoding: " + r2);
    } else
      typeof e2 == "number" && (e2 &= 255);
    if (t2 < 0 || this.length < t2 || this.length < n2)
      throw new RangeError("Out of range index");
    if (n2 <= t2)
      return this;
    var u2;
    if (t2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e2 || (e2 = 0), typeof e2 == "number")
      for (u2 = t2; u2 < n2; ++u2)
        this[u2] = e2;
    else {
      var o2 = ju$1(e2) ? e2 : co$2(new Nu$1(e2, r2).toString()), s2 = o2.length;
      for (u2 = 0; u2 < n2 - t2; ++u2)
        this[u2 + t2] = o2[u2 % s2];
    }
    return this;
  };
  var so$2 = /[^+\/0-9A-Za-z-_]/g;
  function ao$2(e2) {
    return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
  }
  function co$2(e2, t2) {
    var n2;
    t2 = t2 || 1 / 0;
    for (var r2 = e2.length, i2 = null, u2 = [], o2 = 0; o2 < r2; ++o2) {
      if ((n2 = e2.charCodeAt(o2)) > 55295 && n2 < 57344) {
        if (!i2) {
          if (n2 > 56319) {
            (t2 -= 3) > -1 && u2.push(239, 191, 189);
            continue;
          }
          if (o2 + 1 === r2) {
            (t2 -= 3) > -1 && u2.push(239, 191, 189);
            continue;
          }
          i2 = n2;
          continue;
        }
        if (n2 < 56320) {
          (t2 -= 3) > -1 && u2.push(239, 191, 189), i2 = n2;
          continue;
        }
        n2 = 65536 + (i2 - 55296 << 10 | n2 - 56320);
      } else
        i2 && (t2 -= 3) > -1 && u2.push(239, 191, 189);
      if (i2 = null, n2 < 128) {
        if ((t2 -= 1) < 0)
          break;
        u2.push(n2);
      } else if (n2 < 2048) {
        if ((t2 -= 2) < 0)
          break;
        u2.push(n2 >> 6 | 192, 63 & n2 | 128);
      } else if (n2 < 65536) {
        if ((t2 -= 3) < 0)
          break;
        u2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
      } else {
        if (!(n2 < 1114112))
          throw new Error("Invalid code point");
        if ((t2 -= 4) < 0)
          break;
        u2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
      }
    }
    return u2;
  }
  function lo$2(e2) {
    return function(e3) {
      var t2, n2, r2, i2, u2, o2;
      Cu$1 || bu$1();
      var s2 = e3.length;
      if (s2 % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      u2 = e3[s2 - 2] === "=" ? 2 : e3[s2 - 1] === "=" ? 1 : 0, o2 = new Eu$1(3 * s2 / 4 - u2), r2 = u2 > 0 ? s2 - 4 : s2;
      var a2 = 0;
      for (t2 = 0, n2 = 0; t2 < r2; t2 += 4, n2 += 3)
        i2 = Du$1[e3.charCodeAt(t2)] << 18 | Du$1[e3.charCodeAt(t2 + 1)] << 12 | Du$1[e3.charCodeAt(t2 + 2)] << 6 | Du$1[e3.charCodeAt(t2 + 3)], o2[a2++] = i2 >> 16 & 255, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2;
      return u2 === 2 ? (i2 = Du$1[e3.charCodeAt(t2)] << 2 | Du$1[e3.charCodeAt(t2 + 1)] >> 4, o2[a2++] = 255 & i2) : u2 === 1 && (i2 = Du$1[e3.charCodeAt(t2)] << 10 | Du$1[e3.charCodeAt(t2 + 1)] << 4 | Du$1[e3.charCodeAt(t2 + 2)] >> 2, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2), o2;
    }(function(e3) {
      if ((e3 = function(e4) {
        return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
      }(e3).replace(so$2, "")).length < 2)
        return "";
      for (; e3.length % 4 != 0; )
        e3 += "=";
      return e3;
    }(e2));
  }
  function po$2(e2, t2, n2, r2) {
    for (var i2 = 0; i2 < r2 && !(i2 + n2 >= t2.length || i2 >= e2.length); ++i2)
      t2[i2 + n2] = e2[i2];
    return i2;
  }
  function fo$2(e2) {
    return e2 != null && (!!e2._isBuffer || ho$2(e2) || function(e3) {
      return typeof e3.readFloatLE == "function" && typeof e3.slice == "function" && ho$2(e3.slice(0, 0));
    }(e2));
  }
  function ho$2(e2) {
    return !!e2.constructor && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
  }
  var go$2 = n$3(tu$1);
  var mo$2 = class {
    constructor(e2, t2) {
      (t2 = t2 || {}).readChunk || (t2.readChunk = 1024), t2.newLineCharacter ? t2.newLineCharacter = t2.newLineCharacter.charCodeAt(0) : t2.newLineCharacter = 10, this.fd = typeof e2 == "number" ? e2 : go$2.openSync(e2, "r"), this.options = t2, this.newLineCharacter = t2.newLineCharacter, this.reset();
    }
    _searchInBuffer(e2, t2) {
      let n2 = -1;
      for (let r2 = 0; r2 <= e2.length; r2++) {
        if (e2[r2] === t2) {
          n2 = r2;
          break;
        }
      }
      return n2;
    }
    reset() {
      this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
    }
    close() {
      go$2.closeSync(this.fd), this.fd = null;
    }
    _extractLines(e2) {
      let t2;
      const n2 = [];
      let r2 = 0, i2 = 0;
      for (; ; ) {
        let u3 = e2[r2++];
        if (u3 === this.newLineCharacter)
          t2 = e2.slice(i2, r2), n2.push(t2), i2 = r2;
        else if (u3 === void 0)
          break;
      }
      let u2 = e2.slice(i2, r2);
      return u2.length && n2.push(u2), n2;
    }
    _readChunk(e2) {
      let t2, n2 = 0;
      const r2 = [];
      do {
        const e3 = new Nu$1(this.options.readChunk);
        t2 = go$2.readSync(this.fd, e3, 0, this.options.readChunk, this.fdPosition), n2 += t2, this.fdPosition = this.fdPosition + t2, r2.push(e3);
      } while (t2 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
      let i2 = Nu$1.concat(r2);
      return t2 < this.options.readChunk && (this.eofReached = true, i2 = i2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(i2), e2 && (this.linesCache[0] = Nu$1.concat([e2, this.linesCache[0]]))), n2;
    }
    next() {
      if (!this.fd)
        return false;
      let e2, t2 = false;
      if (this.eofReached && this.linesCache.length === 0)
        return t2;
      if (this.linesCache.length || (e2 = this._readChunk()), this.linesCache.length) {
        t2 = this.linesCache.shift();
        t2[t2.length - 1] !== this.newLineCharacter && (e2 = this._readChunk(t2), e2 && (t2 = this.linesCache.shift()));
      }
      return this.eofReached && this.linesCache.length === 0 && this.close(), t2 && t2[t2.length - 1] === this.newLineCharacter && (t2 = t2.slice(0, t2.length - 1)), t2;
    }
  };
  class yo$2 extends Error {
  }
  class Do$2 extends Error {
  }
  class Eo$2 extends Error {
  }
  class Co$2 extends Error {
  }
  var bo$2 = { ConfigError: yo$2, DebugError: Do$2, UndefinedParserError: Eo$2, ArgExpansionBailout: Co$2 }, Ao$2 = function(e2, t2) {
    return (Ao$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
      e3.__proto__ = t3;
    } || function(e3, t3) {
      for (var n2 in t3)
        t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
    })(e2, t2);
  };
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var vo$2 = function() {
    return (vo$2 = Object.assign || function(e2) {
      for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
        for (var i2 in t2 = arguments[n2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function Fo$2(e2) {
    var t2 = typeof Symbol == "function" && Symbol.iterator, n2 = t2 && e2[t2], r2 = 0;
    if (n2)
      return n2.call(e2);
    if (e2 && typeof e2.length == "number")
      return { next: function() {
        return e2 && r2 >= e2.length && (e2 = void 0), { value: e2 && e2[r2++], done: !e2 };
      } };
    throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function So$2(e2, t2) {
    var n2 = typeof Symbol == "function" && e2[Symbol.iterator];
    if (!n2)
      return e2;
    var r2, i2, u2 = n2.call(e2), o2 = [];
    try {
      for (; (t2 === void 0 || t2-- > 0) && !(r2 = u2.next()).done; )
        o2.push(r2.value);
    } catch (e3) {
      i2 = { error: e3 };
    } finally {
      try {
        r2 && !r2.done && (n2 = u2.return) && n2.call(u2);
      } finally {
        if (i2)
          throw i2.error;
      }
    }
    return o2;
  }
  function xo$2(e2) {
    return this instanceof xo$2 ? (this.v = e2, this) : new xo$2(e2);
  }
  var wo$2 = Object.freeze({ __proto__: null, __extends: function(e2, t2) {
    function n2() {
      this.constructor = e2;
    }
    Ao$2(e2, t2), e2.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
  }, get __assign() {
    return vo$2;
  }, __rest: function(e2, t2) {
    var n2 = {};
    for (var r2 in e2)
      Object.prototype.hasOwnProperty.call(e2, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
    if (e2 != null && typeof Object.getOwnPropertySymbols == "function") {
      var i2 = 0;
      for (r2 = Object.getOwnPropertySymbols(e2); i2 < r2.length; i2++)
        t2.indexOf(r2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[i2]) && (n2[r2[i2]] = e2[r2[i2]]);
    }
    return n2;
  }, __decorate: function(e2, t2, n2, r2) {
    var i2, u2 = arguments.length, o2 = u2 < 3 ? t2 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var s2 = e2.length - 1; s2 >= 0; s2--)
        (i2 = e2[s2]) && (o2 = (u2 < 3 ? i2(o2) : u2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return u2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }, __param: function(e2, t2) {
    return function(n2, r2) {
      t2(n2, r2, e2);
    };
  }, __metadata: function(e2, t2) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(e2, t2);
  }, __awaiter: function(e2, t2, n2, r2) {
    return new (n2 || (n2 = Promise))(function(i2, u2) {
      function o2(e3) {
        try {
          a2(r2.next(e3));
        } catch (e4) {
          u2(e4);
        }
      }
      function s2(e3) {
        try {
          a2(r2.throw(e3));
        } catch (e4) {
          u2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? i2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
          e4(t3);
        })).then(o2, s2);
      }
      a2((r2 = r2.apply(e2, t2 || [])).next());
    });
  }, __generator: function(e2, t2) {
    var n2, r2, i2, u2, o2 = { label: 0, sent: function() {
      if (1 & i2[0])
        throw i2[1];
      return i2[1];
    }, trys: [], ops: [] };
    return u2 = { next: s2(0), throw: s2(1), return: s2(2) }, typeof Symbol == "function" && (u2[Symbol.iterator] = function() {
      return this;
    }), u2;
    function s2(u3) {
      return function(s3) {
        return function(u4) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; o2; )
            try {
              if (n2 = 1, r2 && (i2 = 2 & u4[0] ? r2.return : u4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, u4[1])).done)
                return i2;
              switch (r2 = 0, i2 && (u4 = [2 & u4[0], i2.value]), u4[0]) {
                case 0:
                case 1:
                  i2 = u4;
                  break;
                case 4:
                  return o2.label++, { value: u4[1], done: false };
                case 5:
                  o2.label++, r2 = u4[1], u4 = [0];
                  continue;
                case 7:
                  u4 = o2.ops.pop(), o2.trys.pop();
                  continue;
                default:
                  if (!(i2 = o2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || u4[0] !== 6 && u4[0] !== 2)) {
                    o2 = 0;
                    continue;
                  }
                  if (u4[0] === 3 && (!i2 || u4[1] > i2[0] && u4[1] < i2[3])) {
                    o2.label = u4[1];
                    break;
                  }
                  if (u4[0] === 6 && o2.label < i2[1]) {
                    o2.label = i2[1], i2 = u4;
                    break;
                  }
                  if (i2 && o2.label < i2[2]) {
                    o2.label = i2[2], o2.ops.push(u4);
                    break;
                  }
                  i2[2] && o2.ops.pop(), o2.trys.pop();
                  continue;
              }
              u4 = t2.call(e2, o2);
            } catch (e3) {
              u4 = [6, e3], r2 = 0;
            } finally {
              n2 = i2 = 0;
            }
          if (5 & u4[0])
            throw u4[1];
          return { value: u4[0] ? u4[1] : void 0, done: true };
        }([u3, s3]);
      };
    }
  }, __createBinding: function(e2, t2, n2, r2) {
    r2 === void 0 && (r2 = n2), e2[r2] = t2[n2];
  }, __exportStar: function(e2, t2) {
    for (var n2 in e2)
      n2 === "default" || t2.hasOwnProperty(n2) || (t2[n2] = e2[n2]);
  }, __values: Fo$2, __read: So$2, __spread: function() {
    for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
      e2 = e2.concat(So$2(arguments[t2]));
    return e2;
  }, __spreadArrays: function() {
    for (var e2 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
      e2 += arguments[t2].length;
    var r2 = Array(e2), i2 = 0;
    for (t2 = 0; t2 < n2; t2++)
      for (var u2 = arguments[t2], o2 = 0, s2 = u2.length; o2 < s2; o2++, i2++)
        r2[i2] = u2[o2];
    return r2;
  }, __await: xo$2, __asyncGenerator: function(e2, t2, n2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var r2, i2 = n2.apply(e2, t2 || []), u2 = [];
    return r2 = {}, o2("next"), o2("throw"), o2("return"), r2[Symbol.asyncIterator] = function() {
      return this;
    }, r2;
    function o2(e3) {
      i2[e3] && (r2[e3] = function(t3) {
        return new Promise(function(n3, r3) {
          u2.push([e3, t3, n3, r3]) > 1 || s2(e3, t3);
        });
      });
    }
    function s2(e3, t3) {
      try {
        (n3 = i2[e3](t3)).value instanceof xo$2 ? Promise.resolve(n3.value.v).then(a2, c2) : l2(u2[0][2], n3);
      } catch (e4) {
        l2(u2[0][3], e4);
      }
      var n3;
    }
    function a2(e3) {
      s2("next", e3);
    }
    function c2(e3) {
      s2("throw", e3);
    }
    function l2(e3, t3) {
      e3(t3), u2.shift(), u2.length && s2(u2[0][0], u2[0][1]);
    }
  }, __asyncDelegator: function(e2) {
    var t2, n2;
    return t2 = {}, r2("next"), r2("throw", function(e3) {
      throw e3;
    }), r2("return"), t2[Symbol.iterator] = function() {
      return this;
    }, t2;
    function r2(r3, i2) {
      t2[r3] = e2[r3] ? function(t3) {
        return (n2 = !n2) ? { value: xo$2(e2[r3](t3)), done: r3 === "return" } : i2 ? i2(t3) : t3;
      } : i2;
    }
  }, __asyncValues: function(e2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var t2, n2 = e2[Symbol.asyncIterator];
    return n2 ? n2.call(e2) : (e2 = Fo$2(e2), t2 = {}, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
      return this;
    }, t2);
    function r2(n3) {
      t2[n3] = e2[n3] && function(t3) {
        return new Promise(function(r3, i2) {
          (function(e3, t4, n4, r4) {
            Promise.resolve(r4).then(function(t5) {
              e3({ value: t5, done: n4 });
            }, t4);
          })(r3, i2, (t3 = e2[n3](t3)).done, t3.value);
        });
      };
    }
  }, __makeTemplateObject: function(e2, t2) {
    return Object.defineProperty ? Object.defineProperty(e2, "raw", { value: t2 }) : e2.raw = t2, e2;
  }, __importStar: function(e2) {
    if (e2 && e2.__esModule)
      return e2;
    var t2 = {};
    if (e2 != null)
      for (var n2 in e2)
        Object.hasOwnProperty.call(e2, n2) && (t2[n2] = e2[n2]);
    return t2.default = e2, t2;
  }, __importDefault: function(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }, __classPrivateFieldGet: function(e2, t2) {
    if (!t2.has(e2))
      throw new TypeError("attempted to get private field on non-instance");
    return t2.get(e2);
  }, __classPrivateFieldSet: function(e2, t2, n2) {
    if (!t2.has(e2))
      throw new TypeError("attempted to set private field on non-instance");
    return t2.set(e2, n2), n2;
  } }), To$2 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), t2.apiDescriptor = { key: (e3) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e3) ? e3 : JSON.stringify(e3), value(e3) {
      if (e3 === null || typeof e3 != "object")
        return JSON.stringify(e3);
      if (Array.isArray(e3))
        return `[${e3.map((e4) => t2.apiDescriptor.value(e4)).join(", ")}]`;
      const n2 = Object.keys(e3);
      return n2.length === 0 ? "{}" : `{ ${n2.map((n3) => `${t2.apiDescriptor.key(n3)}: ${t2.apiDescriptor.value(e3[n3])}`).join(", ")} }`;
    }, pair: ({ key: e3, value: n2 }) => t2.apiDescriptor.value({ [e3]: n2 }) };
  }), Bo$2 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(To$2, t2);
  }), No$2 = /[|\\{}()[\]^$+*?.]/g, ko$2 = function(e2) {
    if (typeof e2 != "string")
      throw new TypeError("Expected a string");
    return e2.replace(No$2, "\\$&");
  }, Po$2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Oo$2 = r$3(function(e2) {
    var t2 = {};
    for (var n2 in Po$2)
      Po$2.hasOwnProperty(n2) && (t2[Po$2[n2]] = n2);
    var r2 = e2.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
    for (var i2 in r2)
      if (r2.hasOwnProperty(i2)) {
        if (!("channels" in r2[i2]))
          throw new Error("missing channels property: " + i2);
        if (!("labels" in r2[i2]))
          throw new Error("missing channel labels property: " + i2);
        if (r2[i2].labels.length !== r2[i2].channels)
          throw new Error("channel and label counts mismatch: " + i2);
        var u2 = r2[i2].channels, o2 = r2[i2].labels;
        delete r2[i2].channels, delete r2[i2].labels, Object.defineProperty(r2[i2], "channels", { value: u2 }), Object.defineProperty(r2[i2], "labels", { value: o2 });
      }
    r2.rgb.hsl = function(e3) {
      var t3, n3, r3 = e3[0] / 255, i3 = e3[1] / 255, u3 = e3[2] / 255, o3 = Math.min(r3, i3, u3), s2 = Math.max(r3, i3, u3), a2 = s2 - o3;
      return s2 === o3 ? t3 = 0 : r3 === s2 ? t3 = (i3 - u3) / a2 : i3 === s2 ? t3 = 2 + (u3 - r3) / a2 : u3 === s2 && (t3 = 4 + (r3 - i3) / a2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (o3 + s2) / 2, [t3, 100 * (s2 === o3 ? 0 : n3 <= 0.5 ? a2 / (s2 + o3) : a2 / (2 - s2 - o3)), 100 * n3];
    }, r2.rgb.hsv = function(e3) {
      var t3, n3, r3, i3, u3, o3 = e3[0] / 255, s2 = e3[1] / 255, a2 = e3[2] / 255, c2 = Math.max(o3, s2, a2), l2 = c2 - Math.min(o3, s2, a2), p2 = function(e4) {
        return (c2 - e4) / 6 / l2 + 0.5;
      };
      return l2 === 0 ? i3 = u3 = 0 : (u3 = l2 / c2, t3 = p2(o3), n3 = p2(s2), r3 = p2(a2), o3 === c2 ? i3 = r3 - n3 : s2 === c2 ? i3 = 1 / 3 + t3 - r3 : a2 === c2 && (i3 = 2 / 3 + n3 - t3), i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1)), [360 * i3, 100 * u3, 100 * c2];
    }, r2.rgb.hwb = function(e3) {
      var t3 = e3[0], n3 = e3[1], i3 = e3[2];
      return [r2.rgb.hsl(e3)[0], 100 * (1 / 255 * Math.min(t3, Math.min(n3, i3))), 100 * (i3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, i3)))];
    }, r2.rgb.cmyk = function(e3) {
      var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, i3 = e3[2] / 255;
      return [100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - i3))) / (1 - t3) || 0), 100 * ((1 - r3 - t3) / (1 - t3) || 0), 100 * ((1 - i3 - t3) / (1 - t3) || 0), 100 * t3];
    }, r2.rgb.keyword = function(e3) {
      var n3 = t2[e3];
      if (n3)
        return n3;
      var r3, i3, u3, o3 = 1 / 0;
      for (var s2 in Po$2)
        if (Po$2.hasOwnProperty(s2)) {
          var a2 = Po$2[s2], c2 = (i3 = e3, u3 = a2, Math.pow(i3[0] - u3[0], 2) + Math.pow(i3[1] - u3[1], 2) + Math.pow(i3[2] - u3[2], 2));
          c2 < o3 && (o3 = c2, r3 = s2);
        }
      return r3;
    }, r2.keyword.rgb = function(e3) {
      return Po$2[e3];
    }, r2.rgb.xyz = function(e3) {
      var t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255;
      return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
    }, r2.rgb.lab = function(e3) {
      var t3 = r2.rgb.xyz(e3), n3 = t3[0], i3 = t3[1], u3 = t3[2];
      return i3 /= 100, u3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (i3 = i3 > 8856e-6 ? Math.pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116) - 16, 500 * (n3 - i3), 200 * (i3 - (u3 = u3 > 8856e-6 ? Math.pow(u3, 1 / 3) : 7.787 * u3 + 16 / 116))];
    }, r2.hsl.rgb = function(e3) {
      var t3, n3, r3, i3, u3, o3 = e3[0] / 360, s2 = e3[1] / 100, a2 = e3[2] / 100;
      if (s2 === 0)
        return [u3 = 255 * a2, u3, u3];
      t3 = 2 * a2 - (n3 = a2 < 0.5 ? a2 * (1 + s2) : a2 + s2 - a2 * s2), i3 = [0, 0, 0];
      for (var c2 = 0; c2 < 3; c2++)
        (r3 = o3 + 1 / 3 * -(c2 - 1)) < 0 && r3++, r3 > 1 && r3--, u3 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, i3[c2] = 255 * u3;
      return i3;
    }, r2.hsl.hsv = function(e3) {
      var t3 = e3[0], n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = n3, u3 = Math.max(r3, 0.01);
      return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, i3 *= u3 <= 1 ? u3 : 2 - u3, [t3, 100 * (r3 === 0 ? 2 * i3 / (u3 + i3) : 2 * n3 / (r3 + n3)), 100 * ((r3 + n3) / 2)];
    }, r2.hsv.rgb = function(e3) {
      var t3 = e3[0] / 60, n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = Math.floor(t3) % 6, u3 = t3 - Math.floor(t3), o3 = 255 * r3 * (1 - n3), s2 = 255 * r3 * (1 - n3 * u3), a2 = 255 * r3 * (1 - n3 * (1 - u3));
      switch (r3 *= 255, i3) {
        case 0:
          return [r3, a2, o3];
        case 1:
          return [s2, r3, o3];
        case 2:
          return [o3, r3, a2];
        case 3:
          return [o3, s2, r3];
        case 4:
          return [a2, o3, r3];
        case 5:
          return [r3, o3, s2];
      }
    }, r2.hsv.hsl = function(e3) {
      var t3, n3, r3, i3 = e3[0], u3 = e3[1] / 100, o3 = e3[2] / 100, s2 = Math.max(o3, 0.01);
      return r3 = (2 - u3) * o3, n3 = u3 * s2, [i3, 100 * (n3 = (n3 /= (t3 = (2 - u3) * s2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r3 /= 2)];
    }, r2.hwb.rgb = function(e3) {
      var t3, n3, r3, i3, u3, o3, s2, a2 = e3[0] / 360, c2 = e3[1] / 100, l2 = e3[2] / 100, p2 = c2 + l2;
      switch (p2 > 1 && (c2 /= p2, l2 /= p2), r3 = 6 * a2 - (t3 = Math.floor(6 * a2)), (1 & t3) != 0 && (r3 = 1 - r3), i3 = c2 + r3 * ((n3 = 1 - l2) - c2), t3) {
        default:
        case 6:
        case 0:
          u3 = n3, o3 = i3, s2 = c2;
          break;
        case 1:
          u3 = i3, o3 = n3, s2 = c2;
          break;
        case 2:
          u3 = c2, o3 = n3, s2 = i3;
          break;
        case 3:
          u3 = c2, o3 = i3, s2 = n3;
          break;
        case 4:
          u3 = i3, o3 = c2, s2 = n3;
          break;
        case 5:
          u3 = n3, o3 = c2, s2 = i3;
      }
      return [255 * u3, 255 * o3, 255 * s2];
    }, r2.cmyk.rgb = function(e3) {
      var t3 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = e3[3] / 100;
      return [255 * (1 - Math.min(1, t3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, n3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, r3 * (1 - i3) + i3))];
    }, r2.xyz.rgb = function(e3) {
      var t3, n3, r3, i3 = e3[0] / 100, u3 = e3[1] / 100, o3 = e3[2] / 100;
      return n3 = -0.9689 * i3 + 1.8758 * u3 + 0.0415 * o3, r3 = 0.0557 * i3 + -0.204 * u3 + 1.057 * o3, t3 = (t3 = 3.2406 * i3 + -1.5372 * u3 + -0.4986 * o3) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (r3 = Math.min(Math.max(0, r3), 1))];
    }, r2.xyz.lab = function(e3) {
      var t3 = e3[0], n3 = e3[1], r3 = e3[2];
      return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (t3 - n3), 200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
    }, r2.lab.xyz = function(e3) {
      var t3, n3, r3, i3 = e3[0];
      t3 = e3[1] / 500 + (n3 = (i3 + 16) / 116), r3 = n3 - e3[2] / 200;
      var u3 = Math.pow(n3, 3), o3 = Math.pow(t3, 3), s2 = Math.pow(r3, 3);
      return n3 = u3 > 8856e-6 ? u3 : (n3 - 16 / 116) / 7.787, t3 = o3 > 8856e-6 ? o3 : (t3 - 16 / 116) / 7.787, r3 = s2 > 8856e-6 ? s2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
    }, r2.lab.lch = function(e3) {
      var t3, n3 = e3[0], r3 = e3[1], i3 = e3[2];
      return (t3 = 360 * Math.atan2(i3, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + i3 * i3), t3];
    }, r2.lch.lab = function(e3) {
      var t3, n3 = e3[0], r3 = e3[1];
      return t3 = e3[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
    }, r2.rgb.ansi16 = function(e3) {
      var t3 = e3[0], n3 = e3[1], i3 = e3[2], u3 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e3)[2];
      if ((u3 = Math.round(u3 / 50)) === 0)
        return 30;
      var o3 = 30 + (Math.round(i3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
      return u3 === 2 && (o3 += 60), o3;
    }, r2.hsv.ansi16 = function(e3) {
      return r2.rgb.ansi16(r2.hsv.rgb(e3), e3[2]);
    }, r2.rgb.ansi256 = function(e3) {
      var t3 = e3[0], n3 = e3[1], r3 = e3[2];
      return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
    }, r2.ansi16.rgb = function(e3) {
      var t3 = e3 % 10;
      if (t3 === 0 || t3 === 7)
        return e3 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
      var n3 = 0.5 * (1 + ~~(e3 > 50));
      return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
    }, r2.ansi256.rgb = function(e3) {
      if (e3 >= 232) {
        var t3 = 10 * (e3 - 232) + 8;
        return [t3, t3, t3];
      }
      var n3;
      return e3 -= 16, [Math.floor(e3 / 36) / 5 * 255, Math.floor((n3 = e3 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
    }, r2.rgb.hex = function(e3) {
      var t3 = (((255 & Math.round(e3[0])) << 16) + ((255 & Math.round(e3[1])) << 8) + (255 & Math.round(e3[2]))).toString(16).toUpperCase();
      return "000000".substring(t3.length) + t3;
    }, r2.hex.rgb = function(e3) {
      var t3 = e3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!t3)
        return [0, 0, 0];
      var n3 = t3[0];
      t3[0].length === 3 && (n3 = n3.split("").map(function(e4) {
        return e4 + e4;
      }).join(""));
      var r3 = parseInt(n3, 16);
      return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
    }, r2.rgb.hcg = function(e3) {
      var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, i3 = e3[2] / 255, u3 = Math.max(Math.max(n3, r3), i3), o3 = Math.min(Math.min(n3, r3), i3), s2 = u3 - o3;
      return t3 = s2 <= 0 ? 0 : u3 === n3 ? (r3 - i3) / s2 % 6 : u3 === r3 ? 2 + (i3 - n3) / s2 : 4 + (n3 - r3) / s2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * s2, 100 * (s2 < 1 ? o3 / (1 - s2) : 0)];
    }, r2.hsl.hcg = function(e3) {
      var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = 1, i3 = 0;
      return (r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3)) < 1 && (i3 = (n3 - 0.5 * r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
    }, r2.hsv.hcg = function(e3) {
      var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = t3 * n3, i3 = 0;
      return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
    }, r2.hcg.rgb = function(e3) {
      var t3 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
      if (n3 === 0)
        return [255 * r3, 255 * r3, 255 * r3];
      var i3, u3 = [0, 0, 0], o3 = t3 % 1 * 6, s2 = o3 % 1, a2 = 1 - s2;
      switch (Math.floor(o3)) {
        case 0:
          u3[0] = 1, u3[1] = s2, u3[2] = 0;
          break;
        case 1:
          u3[0] = a2, u3[1] = 1, u3[2] = 0;
          break;
        case 2:
          u3[0] = 0, u3[1] = 1, u3[2] = s2;
          break;
        case 3:
          u3[0] = 0, u3[1] = a2, u3[2] = 1;
          break;
        case 4:
          u3[0] = s2, u3[1] = 0, u3[2] = 1;
          break;
        default:
          u3[0] = 1, u3[1] = 0, u3[2] = a2;
      }
      return i3 = (1 - n3) * r3, [255 * (n3 * u3[0] + i3), 255 * (n3 * u3[1] + i3), 255 * (n3 * u3[2] + i3)];
    }, r2.hcg.hsv = function(e3) {
      var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3), r3 = 0;
      return n3 > 0 && (r3 = t3 / n3), [e3[0], 100 * r3, 100 * n3];
    }, r2.hcg.hsl = function(e3) {
      var t3 = e3[1] / 100, n3 = e3[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
      return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e3[0], 100 * r3, 100 * n3];
    }, r2.hcg.hwb = function(e3) {
      var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3);
      return [e3[0], 100 * (n3 - t3), 100 * (1 - n3)];
    }, r2.hwb.hcg = function(e3) {
      var t3 = e3[1] / 100, n3 = 1 - e3[2] / 100, r3 = n3 - t3, i3 = 0;
      return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
    }, r2.apple.rgb = function(e3) {
      return [e3[0] / 65535 * 255, e3[1] / 65535 * 255, e3[2] / 65535 * 255];
    }, r2.rgb.apple = function(e3) {
      return [e3[0] / 255 * 65535, e3[1] / 255 * 65535, e3[2] / 255 * 65535];
    }, r2.gray.rgb = function(e3) {
      return [e3[0] / 100 * 255, e3[0] / 100 * 255, e3[0] / 100 * 255];
    }, r2.gray.hsl = r2.gray.hsv = function(e3) {
      return [0, 0, e3[0]];
    }, r2.gray.hwb = function(e3) {
      return [0, 100, e3[0]];
    }, r2.gray.cmyk = function(e3) {
      return [0, 0, 0, e3[0]];
    }, r2.gray.lab = function(e3) {
      return [e3[0], 0, 0];
    }, r2.gray.hex = function(e3) {
      var t3 = 255 & Math.round(e3[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
      return "000000".substring(n3.length) + n3;
    }, r2.rgb.gray = function(e3) {
      return [(e3[0] + e3[1] + e3[2]) / 3 / 255 * 100];
    };
  });
  function Io$2(e2) {
    var t2 = function() {
      for (var e3 = {}, t3 = Object.keys(Oo$2), n3 = t3.length, r3 = 0; r3 < n3; r3++)
        e3[t3[r3]] = { distance: -1, parent: null };
      return e3;
    }(), n2 = [e2];
    for (t2[e2].distance = 0; n2.length; )
      for (var r2 = n2.pop(), i2 = Object.keys(Oo$2[r2]), u2 = i2.length, o2 = 0; o2 < u2; o2++) {
        var s2 = i2[o2], a2 = t2[s2];
        a2.distance === -1 && (a2.distance = t2[r2].distance + 1, a2.parent = r2, n2.unshift(s2));
      }
    return t2;
  }
  function Lo$2(e2, t2) {
    return function(n2) {
      return t2(e2(n2));
    };
  }
  function jo$1(e2, t2) {
    for (var n2 = [t2[e2].parent, e2], r2 = Oo$2[t2[e2].parent][e2], i2 = t2[e2].parent; t2[i2].parent; )
      n2.unshift(t2[i2].parent), r2 = Lo$2(Oo$2[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
    return r2.conversion = n2, r2;
  }
  var _o$2 = {};
  Object.keys(Oo$2).forEach(function(e2) {
    _o$2[e2] = {}, Object.defineProperty(_o$2[e2], "channels", { value: Oo$2[e2].channels }), Object.defineProperty(_o$2[e2], "labels", { value: Oo$2[e2].labels });
    var t2 = function(e3) {
      for (var t3 = Io$2(e3), n2 = {}, r2 = Object.keys(t3), i2 = r2.length, u2 = 0; u2 < i2; u2++) {
        var o2 = r2[u2];
        t3[o2].parent !== null && (n2[o2] = jo$1(o2, t3));
      }
      return n2;
    }(e2);
    Object.keys(t2).forEach(function(n2) {
      var r2 = t2[n2];
      _o$2[e2][n2] = function(e3) {
        var t3 = function(t4) {
          if (t4 == null)
            return t4;
          arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
          var n3 = e3(t4);
          if (typeof n3 == "object")
            for (var r3 = n3.length, i2 = 0; i2 < r3; i2++)
              n3[i2] = Math.round(n3[i2]);
          return n3;
        };
        return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
      }(r2), _o$2[e2][n2].raw = function(e3) {
        var t3 = function(t4) {
          return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e3(t4));
        };
        return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
      }(r2);
    });
  });
  var Mo$1, Ro$2 = _o$2, $o$1 = r$3(function(e2) {
    const t2 = (e3, t3) => function() {
      const n3 = e3.apply(Ro$2, arguments);
      return `[${n3 + t3}m`;
    }, n2 = (e3, t3) => function() {
      const n3 = e3.apply(Ro$2, arguments);
      return `[${38 + t3};5;${n3}m`;
    }, r2 = (e3, t3) => function() {
      const n3 = e3.apply(Ro$2, arguments);
      return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
    };
    Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
      const e3 = new Map(), i2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
      i2.color.grey = i2.color.gray;
      for (const t3 of Object.keys(i2)) {
        const n3 = i2[t3];
        for (const t4 of Object.keys(n3)) {
          const r3 = n3[t4];
          i2[t4] = { open: `[${r3[0]}m`, close: `[${r3[1]}m` }, n3[t4] = i2[t4], e3.set(r3[0], r3[1]);
        }
        Object.defineProperty(i2, t3, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", { value: e3, enumerable: false });
      }
      const u2 = (e4) => e4, o2 = (e4, t3, n3) => [e4, t3, n3];
      i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = { ansi: t2(u2, 0) }, i2.color.ansi256 = { ansi256: n2(u2, 0) }, i2.color.ansi16m = { rgb: r2(o2, 0) }, i2.bgColor.ansi = { ansi: t2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: n2(u2, 10) }, i2.bgColor.ansi16m = { rgb: r2(o2, 10) };
      for (let e4 of Object.keys(Ro$2)) {
        if (typeof Ro$2[e4] != "object")
          continue;
        const u3 = Ro$2[e4];
        e4 === "ansi16" && (e4 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e4] = t2(u3.ansi16, 0), i2.bgColor.ansi[e4] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e4] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e4] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e4] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e4] = r2(u3.rgb, 10));
      }
      return i2;
    } });
  });
  function Vo$1() {
    if (Mo$1 === void 0) {
      var e2 = new ArrayBuffer(2), t2 = new Uint8Array(e2), n2 = new Uint16Array(e2);
      if (t2[0] = 1, t2[1] = 2, n2[0] === 258)
        Mo$1 = "BE";
      else {
        if (n2[0] !== 513)
          throw new Error("unable to figure out endianess");
        Mo$1 = "LE";
      }
    }
    return Mo$1;
  }
  function Wo$1() {
    return nr$2.location !== void 0 ? nr$2.location.hostname : "";
  }
  function qo$1() {
    return [];
  }
  function Uo$1() {
    return 0;
  }
  function zo$1() {
    return Number.MAX_VALUE;
  }
  function Go$1() {
    return Number.MAX_VALUE;
  }
  function Ho$1() {
    return [];
  }
  function Jo$1() {
    return "Browser";
  }
  function Xo$1() {
    return nr$2.navigator !== void 0 ? nr$2.navigator.appVersion : "";
  }
  function Yo$1() {
  }
  function Ko$1() {
  }
  function Qo$1() {
    return "javascript";
  }
  function Zo$1() {
    return "browser";
  }
  function es$2() {
    return "/tmp";
  }
  var ts$2 = es$2, ns$2 = { EOL: "\n", arch: Qo$1, platform: Zo$1, tmpdir: ts$2, tmpDir: es$2, networkInterfaces: Yo$1, getNetworkInterfaces: Ko$1, release: Xo$1, type: Jo$1, cpus: Ho$1, totalmem: Go$1, freemem: zo$1, uptime: Uo$1, loadavg: qo$1, hostname: Wo$1, endianness: Vo$1 }, rs$2 = (e2, t2) => {
    t2 = t2 || xr$2.argv;
    const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), i2 = t2.indexOf("--");
    return r2 !== -1 && (i2 === -1 || r2 < i2);
  }, is$3 = n$3(Object.freeze({ __proto__: null, endianness: Vo$1, hostname: Wo$1, loadavg: qo$1, uptime: Uo$1, freemem: zo$1, totalmem: Go$1, cpus: Ho$1, type: Jo$1, release: Xo$1, networkInterfaces: Yo$1, getNetworkInterfaces: Ko$1, arch: Qo$1, platform: Zo$1, tmpDir: es$2, tmpdir: ts$2, EOL: "\n", default: ns$2 }));
  const us$2 = xr$2.env;
  let os$3;
  function ss$2(e2) {
    return function(e3) {
      return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
    }(function(e3) {
      if (os$3 === false)
        return 0;
      if (rs$2("color=16m") || rs$2("color=full") || rs$2("color=truecolor"))
        return 3;
      if (rs$2("color=256"))
        return 2;
      if (e3 && !e3.isTTY && os$3 !== true)
        return 0;
      const t2 = os$3 ? 1 : 0;
      if ("CI" in us$2)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in us$2) || us$2.CI_NAME === "codeship" ? 1 : t2;
      if ("TEAMCITY_VERSION" in us$2)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(us$2.TEAMCITY_VERSION) ? 1 : 0;
      if (us$2.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in us$2) {
        const e4 = parseInt((us$2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (us$2.TERM_PROGRAM) {
          case "iTerm.app":
            return e4 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(us$2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(us$2.TERM) || "COLORTERM" in us$2 ? 1 : (us$2.TERM, t2);
    }(e2));
  }
  rs$2("no-color") || rs$2("no-colors") || rs$2("color=false") ? os$3 = false : (rs$2("color") || rs$2("colors") || rs$2("color=true") || rs$2("color=always")) && (os$3 = true), "FORCE_COLOR" in us$2 && (os$3 = us$2.FORCE_COLOR.length === 0 || parseInt(us$2.FORCE_COLOR, 10) !== 0);
  var as$2 = { supportsColor: ss$2, stdout: ss$2(xr$2.stdout), stderr: ss$2(xr$2.stderr) };
  const cs$2 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, ls$2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, ps$2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, fs$3 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, ds$2 = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
  function hs$2(e2) {
    return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : ds$2.get(e2) || e2;
  }
  function gs$2(e2, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let i2;
    for (const t3 of r2)
      if (isNaN(t3)) {
        if (!(i2 = t3.match(ps$2)))
          throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e2}')`);
        n2.push(i2[2].replace(fs$3, (e3, t4, n3) => t4 ? hs$2(t4) : n3));
      } else
        n2.push(Number(t3));
    return n2;
  }
  function ms$2(e2) {
    ls$2.lastIndex = 0;
    const t2 = [];
    let n2;
    for (; (n2 = ls$2.exec(e2)) !== null; ) {
      const e3 = n2[1];
      if (n2[2]) {
        const r2 = gs$2(e3, n2[2]);
        t2.push([e3].concat(r2));
      } else
        t2.push([e3]);
    }
    return t2;
  }
  function ys$2(e2, t2) {
    const n2 = {};
    for (const e3 of t2)
      for (const t3 of e3.styles)
        n2[t3[0]] = e3.inverse ? null : t3.slice(1);
    let r2 = e2;
    for (const e3 of Object.keys(n2))
      if (Array.isArray(n2[e3])) {
        if (!(e3 in r2))
          throw new Error(`Unknown Chalk style: ${e3}`);
        r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
      }
    return r2;
  }
  var Ds$2 = (e2, t2) => {
    const n2 = [], r2 = [];
    let i2 = [];
    if (t2.replace(cs$2, (t3, u2, o2, s2, a2, c2) => {
      if (u2)
        i2.push(hs$2(u2));
      else if (s2) {
        const t4 = i2.join("");
        i2 = [], r2.push(n2.length === 0 ? t4 : ys$2(e2, n2)(t4)), n2.push({ inverse: o2, styles: ms$2(s2) });
      } else if (a2) {
        if (n2.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        r2.push(ys$2(e2, n2)(i2.join(""))), i2 = [], n2.pop();
      } else
        i2.push(c2);
    }), r2.push(i2.join("")), n2.length > 0) {
      const e3 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(e3);
    }
    return r2.join("");
  }, Es$2 = r$3(function(e2) {
    const t2 = as$2.stdout, r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
    function o2(e3, n2) {
      n2 = n2 || {};
      const r3 = t2 ? t2.level : 0;
      e3.level = n2.level === void 0 ? r3 : n2.level, e3.enabled = "enabled" in n2 ? n2.enabled : e3.level > 0;
    }
    function s2(e3) {
      if (!this || !(this instanceof s2) || this.template) {
        const t3 = {};
        return o2(t3, e3), t3.template = function() {
          const e4 = [].slice.call(arguments);
          return p2.apply(null, [t3.template].concat(e4));
        }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
      }
      o2(this, e3);
    }
    for (const e3 of Object.keys($o$1))
      $o$1[e3].closeRe = new RegExp(ko$2($o$1[e3].close), "g"), u2[e3] = { get() {
        const t3 = $o$1[e3];
        return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
      } };
    u2.visible = { get() {
      return c2.call(this, this._styles || [], true, "visible");
    } }, $o$1.color.closeRe = new RegExp(ko$2($o$1.color.close), "g");
    for (const e3 of Object.keys($o$1.color.ansi))
      i2.has(e3) || (u2[e3] = { get() {
        const t3 = this.level;
        return function() {
          const n2 = $o$1.color[r2[t3]][e3].apply(null, arguments), i3 = { open: n2, close: $o$1.color.close, closeRe: $o$1.color.closeRe };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
        };
      } });
    $o$1.bgColor.closeRe = new RegExp(ko$2($o$1.bgColor.close), "g");
    for (const e3 of Object.keys($o$1.bgColor.ansi)) {
      if (i2.has(e3))
        continue;
      u2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
        const t3 = this.level;
        return function() {
          const n2 = $o$1.bgColor[r2[t3]][e3].apply(null, arguments), i3 = { open: n2, close: $o$1.bgColor.close, closeRe: $o$1.bgColor.closeRe };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
        };
      } };
    }
    const a2 = Object.defineProperties(() => {
    }, u2);
    function c2(e3, t3, n2) {
      const r3 = function() {
        return l2.apply(r3, arguments);
      };
      r3._styles = e3, r3._empty = t3;
      const i3 = this;
      return Object.defineProperty(r3, "level", { enumerable: true, get: () => i3.level, set(e4) {
        i3.level = e4;
      } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => i3.enabled, set(e4) {
        i3.enabled = e4;
      } }), r3.hasGrey = this.hasGrey || n2 === "gray" || n2 === "grey", r3.__proto__ = a2, r3;
    }
    function l2() {
      const e3 = arguments, t3 = e3.length;
      let r3 = String(arguments[0]);
      if (t3 === 0)
        return "";
      if (t3 > 1)
        for (let n2 = 1; n2 < t3; n2++)
          r3 += " " + e3[n2];
      if (!this.enabled || this.level <= 0 || !r3)
        return this._empty ? "" : r3;
      const i3 = $o$1.dim.open;
      for (const e4 of this._styles.slice().reverse())
        r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, `${e4.close}$&${e4.open}`);
      return $o$1.dim.open = i3, r3;
    }
    function p2(e3, t3) {
      if (!Array.isArray(t3))
        return [].slice.call(arguments, 1).join(" ");
      const n2 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
      for (let e4 = 1; e4 < t3.length; e4++)
        r3.push(String(n2[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
      return Ds$2(e3, r3.join(""));
    }
    Object.defineProperties(s2.prototype, u2), e2.exports = s2(), e2.exports.supportsColor = t2, e2.exports.default = e2.exports;
  }), Cs$2 = Object.defineProperty({ commonDeprecatedHandler: (e2, t2, { descriptor: n2 }) => {
    const r2 = [`${Es$2.default.yellow(typeof e2 == "string" ? n2.key(e2) : n2.pair(e2))} is deprecated`];
    return t2 && r2.push(`we now treat it as ${Es$2.default.blue(typeof t2 == "string" ? n2.key(t2) : n2.pair(t2))}`), r2.join("; ") + ".";
  } }, "__esModule", { value: true }), bs$2 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(Cs$2, t2);
  }), As$2 = Object.defineProperty({ commonInvalidHandler: (e2, t2, n2) => [`Invalid ${Es$2.default.red(n2.descriptor.key(e2))} value.`, `Expected ${Es$2.default.blue(n2.schemas[e2].expected(n2))},`, `but received ${Es$2.default.red(n2.descriptor.value(t2))}.`].join(" ") }, "__esModule", { value: true }), vs$2 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(As$2, t2);
  }), Fs$2 = [], Ss$2 = [], xs$2 = Object.defineProperty({ levenUnknownHandler: (e2, t2, { descriptor: n2, logger: r2, schemas: i2 }) => {
    const u2 = [`Ignored unknown option ${Es$2.default.yellow(n2.pair({ key: e2, value: t2 }))}.`], o2 = Object.keys(i2).sort().find((t3) => function(e3, t4) {
      if (e3 === t4)
        return 0;
      var n3 = e3;
      e3.length > t4.length && (e3 = t4, t4 = n3);
      var r3 = e3.length, i3 = t4.length;
      if (r3 === 0)
        return i3;
      if (i3 === 0)
        return r3;
      for (; r3 > 0 && e3.charCodeAt(~-r3) === t4.charCodeAt(~-i3); )
        r3--, i3--;
      if (r3 === 0)
        return i3;
      for (var u3, o3, s2, a2, c2 = 0; c2 < r3 && e3.charCodeAt(c2) === t4.charCodeAt(c2); )
        c2++;
      if (i3 -= c2, (r3 -= c2) == 0)
        return i3;
      for (var l2 = 0, p2 = 0; l2 < r3; )
        Ss$2[c2 + l2] = e3.charCodeAt(c2 + l2), Fs$2[l2] = ++l2;
      for (; p2 < i3; )
        for (u3 = t4.charCodeAt(c2 + p2), s2 = p2++, o3 = p2, l2 = 0; l2 < r3; l2++)
          a2 = u3 === Ss$2[c2 + l2] ? s2 : s2 + 1, s2 = Fs$2[l2], o3 = Fs$2[l2] = s2 > o3 ? a2 > o3 ? o3 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
      return o3;
    }(e2, t3) < 3);
    o2 && u2.push(`Did you mean ${Es$2.default.blue(n2.key(o2))}?`), r2.warn(u2.join(" "));
  } }, "__esModule", { value: true }), ws$2 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(xs$2, t2);
  }), Ts$2 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(bs$2, t2), wo$2.__exportStar(vs$2, t2), wo$2.__exportStar(ws$2, t2);
  });
  const Bs$2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
  function Ns$2(e2, t2) {
    const n2 = new e2(t2), r2 = Object.create(n2);
    for (const e3 of Bs$2)
      e3 in t2 && (r2[e3] = Is$3(t2[e3], n2, Ps$2.prototype[e3].length));
    return r2;
  }
  var ks$2 = Ns$2;
  class Ps$2 {
    constructor(e2) {
      this.name = e2.name;
    }
    static create(e2) {
      return Ns$2(this, e2);
    }
    default(e2) {
    }
    expected(e2) {
      return "nothing";
    }
    validate(e2, t2) {
      return false;
    }
    deprecated(e2, t2) {
      return false;
    }
    forward(e2, t2) {
    }
    redirect(e2, t2) {
    }
    overlap(e2, t2, n2) {
      return e2;
    }
    preprocess(e2, t2) {
      return e2;
    }
    postprocess(e2, t2) {
      return e2;
    }
  }
  var Os$2 = Ps$2;
  function Is$3(e2, t2, n2) {
    return typeof e2 == "function" ? (...r2) => e2(...r2.slice(0, n2 - 1), t2, ...r2.slice(n2 - 1)) : () => e2;
  }
  var Ls$2 = Object.defineProperty({ createSchema: ks$2, Schema: Os$2 }, "__esModule", { value: true });
  class js$2 extends Ls$2.Schema {
    constructor(e2) {
      super(e2), this._sourceName = e2.sourceName;
    }
    expected(e2) {
      return e2.schemas[this._sourceName].expected(e2);
    }
    validate(e2, t2) {
      return t2.schemas[this._sourceName].validate(e2, t2);
    }
    redirect(e2, t2) {
      return this._sourceName;
    }
  }
  var _s$2 = js$2, Ms$2 = Object.defineProperty({ AliasSchema: _s$2 }, "__esModule", { value: true });
  class Rs$2 extends Ls$2.Schema {
    expected() {
      return "anything";
    }
    validate() {
      return true;
    }
  }
  var $s$2 = Rs$2, Vs$2 = Object.defineProperty({ AnySchema: $s$2 }, "__esModule", { value: true });
  class Ws$2 extends Ls$2.Schema {
    constructor(e2) {
      var { valueSchema: t2, name: n2 = t2.name } = e2, r2 = wo$2.__rest(e2, ["valueSchema", "name"]);
      super(Object.assign({}, r2, { name: n2 })), this._valueSchema = t2;
    }
    expected(e2) {
      return `an array of ${this._valueSchema.expected(e2)}`;
    }
    validate(e2, t2) {
      if (!Array.isArray(e2))
        return false;
      const n2 = [];
      for (const r2 of e2) {
        const e3 = t2.normalizeValidateResult(this._valueSchema.validate(r2, t2), r2);
        e3 !== true && n2.push(e3.value);
      }
      return n2.length === 0 || { value: n2 };
    }
    deprecated(e2, t2) {
      const n2 = [];
      for (const r2 of e2) {
        const e3 = t2.normalizeDeprecatedResult(this._valueSchema.deprecated(r2, t2), r2);
        e3 !== false && n2.push(...e3.map(({ value: e4 }) => ({ value: [e4] })));
      }
      return n2;
    }
    forward(e2, t2) {
      const n2 = [];
      for (const r2 of e2) {
        const e3 = t2.normalizeForwardResult(this._valueSchema.forward(r2, t2), r2);
        n2.push(...e3.map(Us$2));
      }
      return n2;
    }
    redirect(e2, t2) {
      const n2 = [], r2 = [];
      for (const i2 of e2) {
        const e3 = t2.normalizeRedirectResult(this._valueSchema.redirect(i2, t2), i2);
        "remain" in e3 && n2.push(e3.remain), r2.push(...e3.redirect.map(Us$2));
      }
      return n2.length === 0 ? { redirect: r2 } : { redirect: r2, remain: n2 };
    }
    overlap(e2, t2) {
      return e2.concat(t2);
    }
  }
  var qs$2 = Ws$2;
  function Us$2({ from: e2, to: t2 }) {
    return { from: [e2], to: t2 };
  }
  var zs$2 = Object.defineProperty({ ArraySchema: qs$2 }, "__esModule", { value: true });
  class Gs$2 extends Ls$2.Schema {
    expected() {
      return "true or false";
    }
    validate(e2) {
      return typeof e2 == "boolean";
    }
  }
  var Hs$2 = Gs$2, Js$2 = Object.defineProperty({ BooleanSchema: Hs$2 }, "__esModule", { value: true });
  var Xs$2 = function(e2, t2) {
    const n2 = Object.create(null);
    for (const r2 of e2) {
      const e3 = r2[t2];
      if (n2[e3])
        throw new Error(`Duplicate ${t2} ${JSON.stringify(e3)}`);
      n2[e3] = r2;
    }
    return n2;
  };
  var Ys$2 = function(e2, t2) {
    const n2 = new Map();
    for (const r2 of e2) {
      const e3 = r2[t2];
      if (n2.has(e3))
        throw new Error(`Duplicate ${t2} ${JSON.stringify(e3)}`);
      n2.set(e3, r2);
    }
    return n2;
  };
  var Ks$2 = function() {
    const e2 = Object.create(null);
    return (t2) => {
      const n2 = JSON.stringify(t2);
      return !!e2[n2] || (e2[n2] = true, false);
    };
  };
  var Qs$2 = function(e2, t2) {
    const n2 = [], r2 = [];
    for (const i2 of e2)
      t2(i2) ? n2.push(i2) : r2.push(i2);
    return [n2, r2];
  };
  var Zs$2 = function(e2) {
    return e2 === Math.floor(e2);
  };
  var ea$1 = function(e2, t2) {
    if (e2 === t2)
      return 0;
    const n2 = typeof e2, r2 = typeof t2, i2 = ["undefined", "object", "boolean", "number", "string"];
    return n2 !== r2 ? i2.indexOf(n2) - i2.indexOf(r2) : n2 !== "string" ? Number(e2) - Number(t2) : e2.localeCompare(t2);
  };
  var ta$1 = function(e2) {
    return e2 === void 0 ? {} : e2;
  };
  var na$1 = function(e2, t2) {
    return e2 === true || (e2 === false ? { value: t2 } : e2);
  };
  var ra$1 = function(e2, t2, n2 = false) {
    return e2 !== false && (e2 === true ? !!n2 || [{ value: t2 }] : "value" in e2 ? [e2] : e2.length !== 0 && e2);
  };
  function ia$1(e2, t2) {
    return typeof e2 == "string" || "key" in e2 ? { from: t2, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t2, to: e2.to };
  }
  var ua$1 = ia$1;
  function oa$1(e2, t2) {
    return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((e3) => ia$1(e3, t2)) : [ia$1(e2, t2)];
  }
  var sa$1 = oa$1;
  var aa$1 = function(e2, t2) {
    const n2 = oa$1(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t2);
    return n2.length === 0 ? { remain: t2, redirect: n2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: n2 } : { redirect: n2 };
  }, ca$1 = Object.defineProperty({ recordFromArray: Xs$2, mapFromArray: Ys$2, createAutoChecklist: Ks$2, partition: Qs$2, isInt: Zs$2, comparePrimitive: ea$1, normalizeDefaultResult: ta$1, normalizeValidateResult: na$1, normalizeDeprecatedResult: ra$1, normalizeTransferResult: ua$1, normalizeForwardResult: sa$1, normalizeRedirectResult: aa$1 }, "__esModule", { value: true });
  class la$1 extends Ls$2.Schema {
    constructor(e2) {
      super(e2), this._choices = ca$1.mapFromArray(e2.choices.map((e3) => e3 && typeof e3 == "object" ? e3 : { value: e3 }), "value");
    }
    expected({ descriptor: e2 }) {
      const t2 = Array.from(this._choices.keys()).map((e3) => this._choices.get(e3)).filter((e3) => !e3.deprecated).map((e3) => e3.value).sort(ca$1.comparePrimitive).map(e2.value), n2 = t2.slice(0, -2), r2 = t2.slice(-2);
      return n2.concat(r2.join(" or ")).join(", ");
    }
    validate(e2) {
      return this._choices.has(e2);
    }
    deprecated(e2) {
      const t2 = this._choices.get(e2);
      return !(!t2 || !t2.deprecated) && { value: e2 };
    }
    forward(e2) {
      const t2 = this._choices.get(e2);
      return t2 ? t2.forward : void 0;
    }
    redirect(e2) {
      const t2 = this._choices.get(e2);
      return t2 ? t2.redirect : void 0;
    }
  }
  var pa$1 = la$1, fa$1 = Object.defineProperty({ ChoiceSchema: pa$1 }, "__esModule", { value: true });
  class da$1 extends Ls$2.Schema {
    expected() {
      return "a number";
    }
    validate(e2, t2) {
      return typeof e2 == "number";
    }
  }
  var ha$1 = da$1, ga$1 = Object.defineProperty({ NumberSchema: ha$1 }, "__esModule", { value: true });
  class ma$1 extends ga$1.NumberSchema {
    expected() {
      return "an integer";
    }
    validate(e2, t2) {
      return t2.normalizeValidateResult(super.validate(e2, t2), e2) === true && ca$1.isInt(e2);
    }
  }
  var ya$1 = ma$1, Da$1 = Object.defineProperty({ IntegerSchema: ya$1 }, "__esModule", { value: true });
  class Ea$1 extends Ls$2.Schema {
    expected() {
      return "a string";
    }
    validate(e2) {
      return typeof e2 == "string";
    }
  }
  var Ca$1 = Ea$1, ba$1 = Object.defineProperty({ StringSchema: Ca$1 }, "__esModule", { value: true }), Aa$1 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(Ms$2, t2), wo$2.__exportStar(Vs$2, t2), wo$2.__exportStar(zs$2, t2), wo$2.__exportStar(Js$2, t2), wo$2.__exportStar(fa$1, t2), wo$2.__exportStar(Da$1, t2), wo$2.__exportStar(ga$1, t2), wo$2.__exportStar(ba$1, t2);
  }), va$1 = To$2.apiDescriptor, Fa$1 = xs$2.levenUnknownHandler, Sa$1 = vs$2.commonInvalidHandler, xa$1 = Cs$2.commonDeprecatedHandler, wa$1 = Object.defineProperty({ defaultDescriptor: va$1, defaultUnknownHandler: Fa$1, defaultInvalidHandler: Sa$1, defaultDeprecatedHandler: xa$1 }, "__esModule", { value: true });
  class Ta$1 {
    constructor(e2, t2) {
      const { logger: n2 = console, descriptor: r2 = wa$1.defaultDescriptor, unknown: i2 = wa$1.defaultUnknownHandler, invalid: u2 = wa$1.defaultInvalidHandler, deprecated: o2 = wa$1.defaultDeprecatedHandler } = t2 || {};
      this._utils = { descriptor: r2, logger: n2 || { warn: () => {
      } }, schemas: ca$1.recordFromArray(e2, "name"), normalizeDefaultResult: ca$1.normalizeDefaultResult, normalizeDeprecatedResult: ca$1.normalizeDeprecatedResult, normalizeForwardResult: ca$1.normalizeForwardResult, normalizeRedirectResult: ca$1.normalizeRedirectResult, normalizeValidateResult: ca$1.normalizeValidateResult }, this._unknownHandler = i2, this._invalidHandler = u2, this._deprecatedHandler = o2, this.cleanHistory();
    }
    cleanHistory() {
      this._hasDeprecationWarned = ca$1.createAutoChecklist();
    }
    normalize(e2) {
      const t2 = {}, n2 = [e2], r2 = () => {
        for (; n2.length !== 0; ) {
          const e3 = n2.shift(), r3 = this._applyNormalization(e3, t2);
          n2.push(...r3);
        }
      };
      r2();
      for (const e3 of Object.keys(this._utils.schemas)) {
        const r3 = this._utils.schemas[e3];
        if (!(e3 in t2)) {
          const t3 = ca$1.normalizeDefaultResult(r3.default(this._utils));
          "value" in t3 && n2.push({ [e3]: t3.value });
        }
      }
      r2();
      for (const e3 of Object.keys(this._utils.schemas)) {
        const n3 = this._utils.schemas[e3];
        e3 in t2 && (t2[e3] = n3.postprocess(t2[e3], this._utils));
      }
      return t2;
    }
    _applyNormalization(e2, t2) {
      const n2 = [], [r2, i2] = ca$1.partition(Object.keys(e2), (e3) => e3 in this._utils.schemas);
      for (const i3 of r2) {
        const r3 = this._utils.schemas[i3], u2 = r3.preprocess(e2[i3], this._utils), o2 = ca$1.normalizeValidateResult(r3.validate(u2, this._utils), u2);
        if (o2 !== true) {
          const { value: e3 } = o2, t3 = this._invalidHandler(i3, e3, this._utils);
          throw typeof t3 == "string" ? new Error(t3) : t3;
        }
        const s2 = ({ from: e3, to: t3 }) => {
          n2.push(typeof t3 == "string" ? { [t3]: e3 } : { [t3.key]: t3.value });
        }, a2 = ({ value: e3, redirectTo: t3 }) => {
          const n3 = ca$1.normalizeDeprecatedResult(r3.deprecated(e3, this._utils), u2, true);
          if (n3 !== false)
            if (n3 === true)
              this._hasDeprecationWarned(i3) || this._utils.logger.warn(this._deprecatedHandler(i3, t3, this._utils));
            else
              for (const { value: e4 } of n3) {
                const n4 = { key: i3, value: e4 };
                if (!this._hasDeprecationWarned(n4)) {
                  const r4 = typeof t3 == "string" ? { key: t3, value: e4 } : t3;
                  this._utils.logger.warn(this._deprecatedHandler(n4, r4, this._utils));
                }
              }
        };
        ca$1.normalizeForwardResult(r3.forward(u2, this._utils), u2).forEach(s2);
        const c2 = ca$1.normalizeRedirectResult(r3.redirect(u2, this._utils), u2);
        if (c2.redirect.forEach(s2), "remain" in c2) {
          const e3 = c2.remain;
          t2[i3] = i3 in t2 ? r3.overlap(t2[i3], e3, this._utils) : e3, a2({ value: e3 });
        }
        for (const { from: e3, to: t3 } of c2.redirect)
          a2({ value: e3, redirectTo: t3 });
      }
      for (const r3 of i2) {
        const i3 = e2[r3], u2 = this._unknownHandler(r3, i3, this._utils);
        if (u2)
          for (const e3 of Object.keys(u2)) {
            const r4 = { [e3]: u2[e3] };
            e3 in this._utils.schemas ? n2.push(r4) : Object.assign(t2, r4);
          }
      }
      return n2;
    }
  }
  var Ba$1 = Ta$1, Na$1 = Object.defineProperty({ normalize: (e2, t2, n2) => new Ta$1(t2, n2).normalize(e2), Normalizer: Ba$1 }, "__esModule", { value: true }), ka$1 = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(Bo$2, t2), wo$2.__exportStar(Ts$2, t2), wo$2.__exportStar(Aa$1, t2), wo$2.__exportStar(Na$1, t2), wo$2.__exportStar(Ls$2, t2);
  });
  const Pa$1 = [], Oa$1 = [], Ia$1 = (e2, t2) => {
    if (e2 === t2)
      return 0;
    const n2 = e2;
    e2.length > t2.length && (e2 = t2, t2 = n2);
    let r2 = e2.length, i2 = t2.length;
    for (; r2 > 0 && e2.charCodeAt(~-r2) === t2.charCodeAt(~-i2); )
      r2--, i2--;
    let u2, o2, s2, a2, c2 = 0;
    for (; c2 < r2 && e2.charCodeAt(c2) === t2.charCodeAt(c2); )
      c2++;
    if (r2 -= c2, i2 -= c2, r2 === 0)
      return i2;
    let l2 = 0, p2 = 0;
    for (; l2 < r2; )
      Oa$1[l2] = e2.charCodeAt(c2 + l2), Pa$1[l2] = ++l2;
    for (; p2 < i2; )
      for (u2 = t2.charCodeAt(c2 + p2), s2 = p2++, o2 = p2, l2 = 0; l2 < r2; l2++)
        a2 = u2 === Oa$1[l2] ? s2 : s2 + 1, s2 = Pa$1[l2], o2 = Pa$1[l2] = s2 > o2 ? a2 > o2 ? o2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
    return o2;
  };
  var La$1 = Ia$1, ja$1 = Ia$1;
  La$1.default = ja$1;
  var _a$1 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
  const Ma$1 = {};
  for (const e2 of Object.keys(_a$1))
    Ma$1[_a$1[e2]] = e2;
  const Ra$1 = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
  var $a$1 = Ra$1;
  for (const e2 of Object.keys(Ra$1)) {
    if (!("channels" in Ra$1[e2]))
      throw new Error("missing channels property: " + e2);
    if (!("labels" in Ra$1[e2]))
      throw new Error("missing channel labels property: " + e2);
    if (Ra$1[e2].labels.length !== Ra$1[e2].channels)
      throw new Error("channel and label counts mismatch: " + e2);
    const { channels: t2, labels: n2 } = Ra$1[e2];
    delete Ra$1[e2].channels, delete Ra$1[e2].labels, Object.defineProperty(Ra$1[e2], "channels", { value: t2 }), Object.defineProperty(Ra$1[e2], "labels", { value: n2 });
  }
  function Va$1(e2) {
    const t2 = function() {
      const e3 = {}, t3 = Object.keys($a$1);
      for (let n3 = t3.length, r2 = 0; r2 < n3; r2++)
        e3[t3[r2]] = { distance: -1, parent: null };
      return e3;
    }(), n2 = [e2];
    for (t2[e2].distance = 0; n2.length; ) {
      const e3 = n2.pop(), r2 = Object.keys($a$1[e3]);
      for (let i2 = r2.length, u2 = 0; u2 < i2; u2++) {
        const i3 = r2[u2], o2 = t2[i3];
        o2.distance === -1 && (o2.distance = t2[e3].distance + 1, o2.parent = e3, n2.unshift(i3));
      }
    }
    return t2;
  }
  function Wa$1(e2, t2) {
    return function(n2) {
      return t2(e2(n2));
    };
  }
  function qa$1(e2, t2) {
    const n2 = [t2[e2].parent, e2];
    let r2 = $a$1[t2[e2].parent][e2], i2 = t2[e2].parent;
    for (; t2[i2].parent; )
      n2.unshift(t2[i2].parent), r2 = Wa$1($a$1[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
    return r2.conversion = n2, r2;
  }
  Ra$1.rgb.hsl = function(e2) {
    const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, i2 = Math.min(t2, n2, r2), u2 = Math.max(t2, n2, r2), o2 = u2 - i2;
    let s2, a2;
    u2 === i2 ? s2 = 0 : t2 === u2 ? s2 = (n2 - r2) / o2 : n2 === u2 ? s2 = 2 + (r2 - t2) / o2 : r2 === u2 && (s2 = 4 + (t2 - n2) / o2), s2 = Math.min(60 * s2, 360), s2 < 0 && (s2 += 360);
    const c2 = (i2 + u2) / 2;
    return a2 = u2 === i2 ? 0 : c2 <= 0.5 ? o2 / (u2 + i2) : o2 / (2 - u2 - i2), [s2, 100 * a2, 100 * c2];
  }, Ra$1.rgb.hsv = function(e2) {
    let t2, n2, r2, i2, u2;
    const o2 = e2[0] / 255, s2 = e2[1] / 255, a2 = e2[2] / 255, c2 = Math.max(o2, s2, a2), l2 = c2 - Math.min(o2, s2, a2), p2 = function(e3) {
      return (c2 - e3) / 6 / l2 + 0.5;
    };
    return l2 === 0 ? (i2 = 0, u2 = 0) : (u2 = l2 / c2, t2 = p2(o2), n2 = p2(s2), r2 = p2(a2), o2 === c2 ? i2 = r2 - n2 : s2 === c2 ? i2 = 1 / 3 + t2 - r2 : a2 === c2 && (i2 = 2 / 3 + n2 - t2), i2 < 0 ? i2 += 1 : i2 > 1 && (i2 -= 1)), [360 * i2, 100 * u2, 100 * c2];
  }, Ra$1.rgb.hwb = function(e2) {
    const t2 = e2[0], n2 = e2[1];
    let r2 = e2[2];
    const i2 = Ra$1.rgb.hsl(e2)[0], u2 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
    return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [i2, 100 * u2, 100 * r2];
  }, Ra$1.rgb.cmyk = function(e2) {
    const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, i2 = Math.min(1 - t2, 1 - n2, 1 - r2);
    return [100 * ((1 - t2 - i2) / (1 - i2) || 0), 100 * ((1 - n2 - i2) / (1 - i2) || 0), 100 * ((1 - r2 - i2) / (1 - i2) || 0), 100 * i2];
  }, Ra$1.rgb.keyword = function(e2) {
    const t2 = Ma$1[e2];
    if (t2)
      return t2;
    let n2, r2 = 1 / 0;
    for (const t3 of Object.keys(_a$1)) {
      const o2 = (u2 = _a$1[t3], __pow((i2 = e2)[0] - u2[0], 2) + __pow(i2[1] - u2[1], 2) + __pow(i2[2] - u2[2], 2));
      o2 < r2 && (r2 = o2, n2 = t3);
    }
    var i2, u2;
    return n2;
  }, Ra$1.keyword.rgb = function(e2) {
    return _a$1[e2];
  }, Ra$1.rgb.xyz = function(e2) {
    let t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255;
    t2 = t2 > 0.04045 ? __pow((t2 + 0.055) / 1.055, 2.4) : t2 / 12.92, n2 = n2 > 0.04045 ? __pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92, r2 = r2 > 0.04045 ? __pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
    return [100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2), 100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)];
  }, Ra$1.rgb.lab = function(e2) {
    const t2 = Ra$1.rgb.xyz(e2);
    let n2 = t2[0], r2 = t2[1], i2 = t2[2];
    n2 /= 95.047, r2 /= 100, i2 /= 108.883, n2 = n2 > 8856e-6 ? __pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? __pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116, i2 = i2 > 8856e-6 ? __pow(i2, 1 / 3) : 7.787 * i2 + 16 / 116;
    return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - i2)];
  }, Ra$1.hsl.rgb = function(e2) {
    const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
    let i2, u2, o2;
    if (n2 === 0)
      return o2 = 255 * r2, [o2, o2, o2];
    i2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
    const s2 = 2 * r2 - i2, a2 = [0, 0, 0];
    for (let e3 = 0; e3 < 3; e3++)
      u2 = t2 + 1 / 3 * -(e3 - 1), u2 < 0 && u2++, u2 > 1 && u2--, o2 = 6 * u2 < 1 ? s2 + 6 * (i2 - s2) * u2 : 2 * u2 < 1 ? i2 : 3 * u2 < 2 ? s2 + (i2 - s2) * (2 / 3 - u2) * 6 : s2, a2[e3] = 255 * o2;
    return a2;
  }, Ra$1.hsl.hsv = function(e2) {
    const t2 = e2[0];
    let n2 = e2[1] / 100, r2 = e2[2] / 100, i2 = n2;
    const u2 = Math.max(r2, 0.01);
    r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, i2 *= u2 <= 1 ? u2 : 2 - u2;
    return [t2, 100 * (r2 === 0 ? 2 * i2 / (u2 + i2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
  }, Ra$1.hsv.rgb = function(e2) {
    const t2 = e2[0] / 60, n2 = e2[1] / 100;
    let r2 = e2[2] / 100;
    const i2 = Math.floor(t2) % 6, u2 = t2 - Math.floor(t2), o2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * u2), a2 = 255 * r2 * (1 - n2 * (1 - u2));
    switch (r2 *= 255, i2) {
      case 0:
        return [r2, a2, o2];
      case 1:
        return [s2, r2, o2];
      case 2:
        return [o2, r2, a2];
      case 3:
        return [o2, s2, r2];
      case 4:
        return [a2, o2, r2];
      case 5:
        return [r2, o2, s2];
    }
  }, Ra$1.hsv.hsl = function(e2) {
    const t2 = e2[0], n2 = e2[1] / 100, r2 = e2[2] / 100, i2 = Math.max(r2, 0.01);
    let u2, o2;
    o2 = (2 - n2) * r2;
    const s2 = (2 - n2) * i2;
    return u2 = n2 * i2, u2 /= s2 <= 1 ? s2 : 2 - s2, u2 = u2 || 0, o2 /= 2, [t2, 100 * u2, 100 * o2];
  }, Ra$1.hwb.rgb = function(e2) {
    const t2 = e2[0] / 360;
    let n2 = e2[1] / 100, r2 = e2[2] / 100;
    const i2 = n2 + r2;
    let u2;
    i2 > 1 && (n2 /= i2, r2 /= i2);
    const o2 = Math.floor(6 * t2), s2 = 1 - r2;
    u2 = 6 * t2 - o2, (1 & o2) != 0 && (u2 = 1 - u2);
    const a2 = n2 + u2 * (s2 - n2);
    let c2, l2, p2;
    switch (o2) {
      default:
      case 6:
      case 0:
        c2 = s2, l2 = a2, p2 = n2;
        break;
      case 1:
        c2 = a2, l2 = s2, p2 = n2;
        break;
      case 2:
        c2 = n2, l2 = s2, p2 = a2;
        break;
      case 3:
        c2 = n2, l2 = a2, p2 = s2;
        break;
      case 4:
        c2 = a2, l2 = n2, p2 = s2;
        break;
      case 5:
        c2 = s2, l2 = n2, p2 = a2;
    }
    return [255 * c2, 255 * l2, 255 * p2];
  }, Ra$1.cmyk.rgb = function(e2) {
    const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100, i2 = e2[3] / 100;
    return [255 * (1 - Math.min(1, t2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, n2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, r2 * (1 - i2) + i2))];
  }, Ra$1.xyz.rgb = function(e2) {
    const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100;
    let i2, u2, o2;
    return i2 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, u2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, o2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, i2 = i2 > 31308e-7 ? 1.055 * __pow(i2, 1 / 2.4) - 0.055 : 12.92 * i2, u2 = u2 > 31308e-7 ? 1.055 * __pow(u2, 1 / 2.4) - 0.055 : 12.92 * u2, o2 = o2 > 31308e-7 ? 1.055 * __pow(o2, 1 / 2.4) - 0.055 : 12.92 * o2, i2 = Math.min(Math.max(0, i2), 1), u2 = Math.min(Math.max(0, u2), 1), o2 = Math.min(Math.max(0, o2), 1), [255 * i2, 255 * u2, 255 * o2];
  }, Ra$1.xyz.lab = function(e2) {
    let t2 = e2[0], n2 = e2[1], r2 = e2[2];
    t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 8856e-6 ? __pow(t2, 1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 8856e-6 ? __pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? __pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116;
    return [116 * n2 - 16, 500 * (t2 - n2), 200 * (n2 - r2)];
  }, Ra$1.lab.xyz = function(e2) {
    let t2, n2, r2;
    n2 = (e2[0] + 16) / 116, t2 = e2[1] / 500 + n2, r2 = n2 - e2[2] / 200;
    const i2 = __pow(n2, 3), u2 = __pow(t2, 3), o2 = __pow(r2, 3);
    return n2 = i2 > 8856e-6 ? i2 : (n2 - 16 / 116) / 7.787, t2 = u2 > 8856e-6 ? u2 : (t2 - 16 / 116) / 7.787, r2 = o2 > 8856e-6 ? o2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [t2, n2, r2];
  }, Ra$1.lab.lch = function(e2) {
    const t2 = e2[0], n2 = e2[1], r2 = e2[2];
    let i2;
    i2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, i2 < 0 && (i2 += 360);
    return [t2, Math.sqrt(n2 * n2 + r2 * r2), i2];
  }, Ra$1.lch.lab = function(e2) {
    const t2 = e2[0], n2 = e2[1], r2 = e2[2] / 360 * 2 * Math.PI;
    return [t2, n2 * Math.cos(r2), n2 * Math.sin(r2)];
  }, Ra$1.rgb.ansi16 = function(e2, t2 = null) {
    const [n2, r2, i2] = e2;
    let u2 = t2 === null ? Ra$1.rgb.hsv(e2)[2] : t2;
    if (u2 = Math.round(u2 / 50), u2 === 0)
      return 30;
    let o2 = 30 + (Math.round(i2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
    return u2 === 2 && (o2 += 60), o2;
  }, Ra$1.hsv.ansi16 = function(e2) {
    return Ra$1.rgb.ansi16(Ra$1.hsv.rgb(e2), e2[2]);
  }, Ra$1.rgb.ansi256 = function(e2) {
    const t2 = e2[0], n2 = e2[1], r2 = e2[2];
    if (t2 === n2 && n2 === r2)
      return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
    return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
  }, Ra$1.ansi16.rgb = function(e2) {
    let t2 = e2 % 10;
    if (t2 === 0 || t2 === 7)
      return e2 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
    const n2 = 0.5 * (1 + ~~(e2 > 50));
    return [(1 & t2) * n2 * 255, (t2 >> 1 & 1) * n2 * 255, (t2 >> 2 & 1) * n2 * 255];
  }, Ra$1.ansi256.rgb = function(e2) {
    if (e2 >= 232) {
      const t3 = 10 * (e2 - 232) + 8;
      return [t3, t3, t3];
    }
    let t2;
    e2 -= 16;
    return [Math.floor(e2 / 36) / 5 * 255, Math.floor((t2 = e2 % 36) / 6) / 5 * 255, t2 % 6 / 5 * 255];
  }, Ra$1.rgb.hex = function(e2) {
    const t2 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
    return "000000".substring(t2.length) + t2;
  }, Ra$1.hex.rgb = function(e2) {
    const t2 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t2)
      return [0, 0, 0];
    let n2 = t2[0];
    t2[0].length === 3 && (n2 = n2.split("").map((e3) => e3 + e3).join(""));
    const r2 = parseInt(n2, 16);
    return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
  }, Ra$1.rgb.hcg = function(e2) {
    const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, i2 = Math.max(Math.max(t2, n2), r2), u2 = Math.min(Math.min(t2, n2), r2), o2 = i2 - u2;
    let s2, a2;
    return s2 = o2 < 1 ? u2 / (1 - o2) : 0, a2 = o2 <= 0 ? 0 : i2 === t2 ? (n2 - r2) / o2 % 6 : i2 === n2 ? 2 + (r2 - t2) / o2 : 4 + (t2 - n2) / o2, a2 /= 6, a2 %= 1, [360 * a2, 100 * o2, 100 * s2];
  }, Ra$1.hsl.hcg = function(e2) {
    const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
    let i2 = 0;
    return r2 < 1 && (i2 = (n2 - 0.5 * r2) / (1 - r2)), [e2[0], 100 * r2, 100 * i2];
  }, Ra$1.hsv.hcg = function(e2) {
    const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = t2 * n2;
    let i2 = 0;
    return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * i2];
  }, Ra$1.hcg.rgb = function(e2) {
    const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
    if (n2 === 0)
      return [255 * r2, 255 * r2, 255 * r2];
    const i2 = [0, 0, 0], u2 = t2 % 1 * 6, o2 = u2 % 1, s2 = 1 - o2;
    let a2 = 0;
    switch (Math.floor(u2)) {
      case 0:
        i2[0] = 1, i2[1] = o2, i2[2] = 0;
        break;
      case 1:
        i2[0] = s2, i2[1] = 1, i2[2] = 0;
        break;
      case 2:
        i2[0] = 0, i2[1] = 1, i2[2] = o2;
        break;
      case 3:
        i2[0] = 0, i2[1] = s2, i2[2] = 1;
        break;
      case 4:
        i2[0] = o2, i2[1] = 0, i2[2] = 1;
        break;
      default:
        i2[0] = 1, i2[1] = 0, i2[2] = s2;
    }
    return a2 = (1 - n2) * r2, [255 * (n2 * i2[0] + a2), 255 * (n2 * i2[1] + a2), 255 * (n2 * i2[2] + a2)];
  }, Ra$1.hcg.hsv = function(e2) {
    const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
    let r2 = 0;
    return n2 > 0 && (r2 = t2 / n2), [e2[0], 100 * r2, 100 * n2];
  }, Ra$1.hcg.hsl = function(e2) {
    const t2 = e2[1] / 100, n2 = e2[2] / 100 * (1 - t2) + 0.5 * t2;
    let r2 = 0;
    return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e2[0], 100 * r2, 100 * n2];
  }, Ra$1.hcg.hwb = function(e2) {
    const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
    return [e2[0], 100 * (n2 - t2), 100 * (1 - n2)];
  }, Ra$1.hwb.hcg = function(e2) {
    const t2 = e2[1] / 100, n2 = 1 - e2[2] / 100, r2 = n2 - t2;
    let i2 = 0;
    return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * i2];
  }, Ra$1.apple.rgb = function(e2) {
    return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
  }, Ra$1.rgb.apple = function(e2) {
    return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
  }, Ra$1.gray.rgb = function(e2) {
    return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
  }, Ra$1.gray.hsl = function(e2) {
    return [0, 0, e2[0]];
  }, Ra$1.gray.hsv = Ra$1.gray.hsl, Ra$1.gray.hwb = function(e2) {
    return [0, 100, e2[0]];
  }, Ra$1.gray.cmyk = function(e2) {
    return [0, 0, 0, e2[0]];
  }, Ra$1.gray.lab = function(e2) {
    return [e2[0], 0, 0];
  }, Ra$1.gray.hex = function(e2) {
    const t2 = 255 & Math.round(e2[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
    return "000000".substring(n2.length) + n2;
  }, Ra$1.rgb.gray = function(e2) {
    return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
  };
  const Ua$1 = {};
  Object.keys($a$1).forEach((e2) => {
    Ua$1[e2] = {}, Object.defineProperty(Ua$1[e2], "channels", { value: $a$1[e2].channels }), Object.defineProperty(Ua$1[e2], "labels", { value: $a$1[e2].labels });
    const t2 = function(e3) {
      const t3 = Va$1(e3), n2 = {}, r2 = Object.keys(t3);
      for (let e4 = r2.length, i2 = 0; i2 < e4; i2++) {
        const e5 = r2[i2];
        t3[e5].parent !== null && (n2[e5] = qa$1(e5, t3));
      }
      return n2;
    }(e2);
    Object.keys(t2).forEach((n2) => {
      const r2 = t2[n2];
      Ua$1[e2][n2] = function(e3) {
        const t3 = function(...t4) {
          const n3 = t4[0];
          if (n3 == null)
            return n3;
          n3.length > 1 && (t4 = n3);
          const r3 = e3(t4);
          if (typeof r3 == "object")
            for (let e4 = r3.length, t5 = 0; t5 < e4; t5++)
              r3[t5] = Math.round(r3[t5]);
          return r3;
        };
        return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
      }(r2), Ua$1[e2][n2].raw = function(e3) {
        const t3 = function(...t4) {
          const n3 = t4[0];
          return n3 == null ? n3 : (n3.length > 1 && (t4 = n3), e3(t4));
        };
        return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
      }(r2);
    });
  });
  var za$1 = Ua$1, Ga$1 = r$3(function(e2) {
    const t2 = (e3, t3) => (...n3) => `[${e3(...n3) + t3}m`, n2 = (e3, t3) => (...n3) => {
      const r3 = e3(...n3);
      return `[${38 + t3};5;${r3}m`;
    }, r2 = (e3, t3) => (...n3) => {
      const r3 = e3(...n3);
      return `[${38 + t3};2;${r3[0]};${r3[1]};${r3[2]}m`;
    }, i2 = (e3) => e3, u2 = (e3, t3, n3) => [e3, t3, n3], o2 = (e3, t3, n3) => {
      Object.defineProperty(e3, t3, { get: () => {
        const r3 = n3();
        return Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true }), r3;
      }, enumerable: true, configurable: true });
    };
    let s2;
    const a2 = (e3, t3, n3, r3) => {
      s2 === void 0 && (s2 = za$1);
      const i3 = r3 ? 10 : 0, u3 = {};
      for (const [r4, o3] of Object.entries(s2)) {
        const s3 = r4 === "ansi16" ? "ansi" : r4;
        r4 === t3 ? u3[s3] = e3(n3, i3) : typeof o3 == "object" && (u3[s3] = e3(o3[t3], i3));
      }
      return u3;
    };
    Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
      const e3 = new Map(), s3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
      s3.color.gray = s3.color.blackBright, s3.bgColor.bgGray = s3.bgColor.bgBlackBright, s3.color.grey = s3.color.blackBright, s3.bgColor.bgGrey = s3.bgColor.bgBlackBright;
      for (const [t3, n3] of Object.entries(s3)) {
        for (const [t4, r3] of Object.entries(n3))
          s3[t4] = { open: `[${r3[0]}m`, close: `[${r3[1]}m` }, n3[t4] = s3[t4], e3.set(r3[0], r3[1]);
        Object.defineProperty(s3, t3, { value: n3, enumerable: false });
      }
      return Object.defineProperty(s3, "codes", { value: e3, enumerable: false }), s3.color.close = "[39m", s3.bgColor.close = "[49m", o2(s3.color, "ansi", () => a2(t2, "ansi16", i2, false)), o2(s3.color, "ansi256", () => a2(n2, "ansi256", i2, false)), o2(s3.color, "ansi16m", () => a2(r2, "rgb", u2, false)), o2(s3.bgColor, "ansi", () => a2(t2, "ansi16", i2, true)), o2(s3.bgColor, "ansi256", () => a2(n2, "ansi256", i2, true)), o2(s3.bgColor, "ansi16m", () => a2(r2, "rgb", u2, true)), s3;
    } });
  });
  function Ha$1() {
    return false;
  }
  function Ja$1() {
    throw new Error("tty.ReadStream is not implemented");
  }
  function Xa$1() {
    throw new Error("tty.ReadStream is not implemented");
  }
  var Ya$1 = { isatty: Ha$1, ReadStream: Ja$1, WriteStream: Xa$1 }, Ka$1 = (e2, t2 = xr$2.argv) => {
    const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), i2 = t2.indexOf("--");
    return r2 !== -1 && (i2 === -1 || r2 < i2);
  }, Qa$1 = n$3(Object.freeze({ __proto__: null, isatty: Ha$1, ReadStream: Ja$1, WriteStream: Xa$1, default: Ya$1 }));
  const { env: Za$1 } = xr$2;
  let ec;
  function tc(e2) {
    return e2 !== 0 && { level: e2, hasBasic: true, has256: e2 >= 2, has16m: e2 >= 3 };
  }
  function nc(e2, t2) {
    if (ec === 0)
      return 0;
    if (Ka$1("color=16m") || Ka$1("color=full") || Ka$1("color=truecolor"))
      return 3;
    if (Ka$1("color=256"))
      return 2;
    if (e2 && !t2 && ec === void 0)
      return 0;
    const n2 = ec || 0;
    if (Za$1.TERM === "dumb")
      return n2;
    if ("CI" in Za$1)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e3) => e3 in Za$1) || Za$1.CI_NAME === "codeship" ? 1 : n2;
    if ("TEAMCITY_VERSION" in Za$1)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Za$1.TEAMCITY_VERSION) ? 1 : 0;
    if (Za$1.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Za$1) {
      const e3 = parseInt((Za$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Za$1.TERM_PROGRAM) {
        case "iTerm.app":
          return e3 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Za$1.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Za$1.TERM) || "COLORTERM" in Za$1 ? 1 : n2;
  }
  Ka$1("no-color") || Ka$1("no-colors") || Ka$1("color=false") || Ka$1("color=never") ? ec = 0 : (Ka$1("color") || Ka$1("colors") || Ka$1("color=true") || Ka$1("color=always")) && (ec = 1), "FORCE_COLOR" in Za$1 && (ec = Za$1.FORCE_COLOR === "true" ? 1 : Za$1.FORCE_COLOR === "false" ? 0 : Za$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(Za$1.FORCE_COLOR, 10), 3));
  var rc = { supportsColor: function(e2) {
    return tc(nc(e2, e2 && e2.isTTY));
  }, stdout: tc(nc(true, Qa$1.isatty(1))), stderr: tc(nc(true, Qa$1.isatty(2))) };
  var ic = { stringReplaceAll: (e2, t2, n2) => {
    let r2 = e2.indexOf(t2);
    if (r2 === -1)
      return e2;
    const i2 = t2.length;
    let u2 = 0, o2 = "";
    do {
      o2 += e2.substr(u2, r2 - u2) + t2 + n2, u2 = r2 + i2, r2 = e2.indexOf(t2, u2);
    } while (r2 !== -1);
    return o2 += e2.substr(u2), o2;
  }, stringEncaseCRLFWithFirstIndex: (e2, t2, n2, r2) => {
    let i2 = 0, u2 = "";
    do {
      const o2 = e2[r2 - 1] === "\r";
      u2 += e2.substr(i2, (o2 ? r2 - 1 : r2) - i2) + t2 + (o2 ? "\r\n" : "\n") + n2, i2 = r2 + 1, r2 = e2.indexOf("\n", i2);
    } while (r2 !== -1);
    return u2 += e2.substr(i2), u2;
  } };
  const uc = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, oc = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, sc = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ac = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, cc = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
  function lc(e2) {
    const t2 = e2[0] === "u", n2 = e2[1] === "{";
    return t2 && !n2 && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e2.slice(2, -1), 16)) : cc.get(e2) || e2;
  }
  function pc(e2, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let i2;
    for (const t3 of r2) {
      const r3 = Number(t3);
      if (Number.isNaN(r3)) {
        if (!(i2 = t3.match(sc)))
          throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e2}')`);
        n2.push(i2[2].replace(ac, (e3, t4, n3) => t4 ? lc(t4) : n3));
      } else
        n2.push(r3);
    }
    return n2;
  }
  function fc(e2) {
    oc.lastIndex = 0;
    const t2 = [];
    let n2;
    for (; (n2 = oc.exec(e2)) !== null; ) {
      const e3 = n2[1];
      if (n2[2]) {
        const r2 = pc(e3, n2[2]);
        t2.push([e3].concat(r2));
      } else
        t2.push([e3]);
    }
    return t2;
  }
  function dc(e2, t2) {
    const n2 = {};
    for (const e3 of t2)
      for (const t3 of e3.styles)
        n2[t3[0]] = e3.inverse ? null : t3.slice(1);
    let r2 = e2;
    for (const [e3, t3] of Object.entries(n2))
      if (Array.isArray(t3)) {
        if (!(e3 in r2))
          throw new Error(`Unknown Chalk style: ${e3}`);
        r2 = t3.length > 0 ? r2[e3](...t3) : r2[e3];
      }
    return r2;
  }
  var hc = (e2, t2) => {
    const n2 = [], r2 = [];
    let i2 = [];
    if (t2.replace(uc, (t3, u2, o2, s2, a2, c2) => {
      if (u2)
        i2.push(lc(u2));
      else if (s2) {
        const t4 = i2.join("");
        i2 = [], r2.push(n2.length === 0 ? t4 : dc(e2, n2)(t4)), n2.push({ inverse: o2, styles: fc(s2) });
      } else if (a2) {
        if (n2.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        r2.push(dc(e2, n2)(i2.join(""))), i2 = [], n2.pop();
      } else
        i2.push(c2);
    }), r2.push(i2.join("")), n2.length > 0) {
      const e3 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(e3);
    }
    return r2.join("");
  };
  const { stdout: gc, stderr: mc } = rc, { stringReplaceAll: yc, stringEncaseCRLFWithFirstIndex: Dc } = ic, { isArray: Ec } = Array, Cc = ["ansi", "ansi", "ansi256", "ansi16m"], bc = Object.create(null);
  class Ac {
    constructor(e2) {
      return vc(e2);
    }
  }
  const vc = (e2) => {
    const t2 = {};
    return ((e3, t3 = {}) => {
      if (t3.level && !(Number.isInteger(t3.level) && t3.level >= 0 && t3.level <= 3))
        throw new Error("The `level` option should be an integer from 0 to 3");
      const n2 = gc ? gc.level : 0;
      e3.level = t3.level === void 0 ? n2 : t3.level;
    })(t2, e2), t2.template = (...e3) => kc(t2.template, ...e3), Object.setPrototypeOf(t2, Fc.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, t2.template.Instance = Ac, t2.template;
  };
  function Fc(e2) {
    return vc(e2);
  }
  for (const [e2, t2] of Object.entries(Ga$1))
    bc[e2] = { get() {
      const n2 = Tc(this, wc(t2.open, t2.close, this._styler), this._isEmpty);
      return Object.defineProperty(this, e2, { value: n2 }), n2;
    } };
  bc.visible = { get() {
    const e2 = Tc(this, this._styler, true);
    return Object.defineProperty(this, "visible", { value: e2 }), e2;
  } };
  const Sc = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const e2 of Sc)
    bc[e2] = { get() {
      const { level: t2 } = this;
      return function(...n2) {
        const r2 = wc(Ga$1.color[Cc[t2]][e2](...n2), Ga$1.color.close, this._styler);
        return Tc(this, r2, this._isEmpty);
      };
    } };
  for (const e2 of Sc) {
    bc["bg" + e2[0].toUpperCase() + e2.slice(1)] = { get() {
      const { level: t2 } = this;
      return function(...n2) {
        const r2 = wc(Ga$1.bgColor[Cc[t2]][e2](...n2), Ga$1.bgColor.close, this._styler);
        return Tc(this, r2, this._isEmpty);
      };
    } };
  }
  const xc = Object.defineProperties(() => {
  }, Object.assign(Object.assign({}, bc), {}, { level: { enumerable: true, get() {
    return this._generator.level;
  }, set(e2) {
    this._generator.level = e2;
  } } })), wc = (e2, t2, n2) => {
    let r2, i2;
    return n2 === void 0 ? (r2 = e2, i2 = t2) : (r2 = n2.openAll + e2, i2 = t2 + n2.closeAll), { open: e2, close: t2, openAll: r2, closeAll: i2, parent: n2 };
  }, Tc = (e2, t2, n2) => {
    const r2 = (...e3) => Ec(e3[0]) && Ec(e3[0].raw) ? Bc(r2, kc(r2, ...e3)) : Bc(r2, e3.length === 1 ? "" + e3[0] : e3.join(" "));
    return Object.setPrototypeOf(r2, xc), r2._generator = e2, r2._styler = t2, r2._isEmpty = n2, r2;
  }, Bc = (e2, t2) => {
    if (e2.level <= 0 || !t2)
      return e2._isEmpty ? "" : t2;
    let n2 = e2._styler;
    if (n2 === void 0)
      return t2;
    const { openAll: r2, closeAll: i2 } = n2;
    if (t2.indexOf("") !== -1)
      for (; n2 !== void 0; )
        t2 = yc(t2, n2.close, n2.open), n2 = n2.parent;
    const u2 = t2.indexOf("\n");
    return u2 !== -1 && (t2 = Dc(t2, i2, r2, u2)), r2 + t2 + i2;
  };
  let Nc;
  const kc = (e2, ...t2) => {
    const [n2] = t2;
    if (!Ec(n2) || !Ec(n2.raw))
      return t2.join(" ");
    const r2 = t2.slice(1), i2 = [n2.raw[0]];
    for (let e3 = 1; e3 < n2.length; e3++)
      i2.push(String(r2[e3 - 1]).replace(/[{}\\]/g, "\\$&"), String(n2.raw[e3]));
    return Nc === void 0 && (Nc = hc), Nc(e2, i2.join(""));
  };
  Object.defineProperties(Fc.prototype, bc);
  const Pc = Fc();
  Pc.supportsColor = gc, Pc.stderr = Fc({ level: mc ? mc.level : 0 }), Pc.stderr.supportsColor = mc;
  var Oc = Pc;
  const Ic = ["_"], Lc = { key: (e2) => e2.length === 1 ? `-${e2}` : `--${e2}`, value: (e2) => ka$1.apiDescriptor.value(e2), pair: ({ key: e2, value: t2 }) => t2 === false ? `--no-${e2}` : t2 === true ? Lc.key(e2) : t2 === "" ? `${Lc.key(e2)} without an argument` : `${Lc.key(e2)}=${t2}` };
  class jc extends ka$1.ChoiceSchema {
    constructor({ name: e2, flags: t2 }) {
      super({ name: e2, choices: t2 }), this._flags = [...t2].sort();
    }
    preprocess(e2, t2) {
      if (typeof e2 == "string" && e2.length > 0 && !this._flags.includes(e2)) {
        const n2 = this._flags.find((t3) => La$1(t3, e2) < 3);
        if (n2)
          return t2.logger.warn([`Unknown flag ${Oc.yellow(t2.descriptor.value(e2))},`, `did you mean ${Oc.blue(t2.descriptor.value(n2))}?`].join(" ")), n2;
      }
      return e2;
    }
    expected() {
      return "a flag";
    }
  }
  let _c;
  function Mc(e2, t2, { logger: n2, isCLI: r2 = false, passThrough: i2 = false } = {}) {
    const u2 = i2 ? Array.isArray(i2) ? (e3, t3) => i2.includes(e3) ? { [e3]: t3 } : void 0 : (e3, t3) => ({ [e3]: t3 }) : (e3, t3, n3) => {
      const r3 = jn$2(n3.schemas, Ic);
      return ka$1.levenUnknownHandler(e3, t3, Object.assign(Object.assign({}, n3), {}, { schemas: r3 }));
    }, o2 = r2 ? Lc : ka$1.apiDescriptor, s2 = function(e3, { isCLI: t3 }) {
      const n3 = [];
      t3 && n3.push(ka$1.AnySchema.create({ name: "_" }));
      for (const r3 of e3)
        n3.push(Rc(r3, { isCLI: t3, optionInfos: e3 })), r3.alias && t3 && n3.push(ka$1.AliasSchema.create({ name: r3.alias, sourceName: r3.name }));
      return n3;
    }(t2, { isCLI: r2 }), a2 = new ka$1.Normalizer(s2, { logger: n2, unknown: u2, descriptor: o2 }), c2 = n2 !== false;
    c2 && _c && (a2._hasDeprecationWarned = _c);
    const l2 = a2.normalize(e2);
    return c2 && (_c = a2._hasDeprecationWarned), l2;
  }
  function Rc(e2, { isCLI: t2, optionInfos: n2 }) {
    let r2;
    const i2 = { name: e2.name }, u2 = {};
    switch (e2.type) {
      case "int":
        r2 = ka$1.IntegerSchema, t2 && (i2.preprocess = (e3) => Number(e3));
        break;
      case "string":
        r2 = ka$1.StringSchema;
        break;
      case "choice":
        r2 = ka$1.ChoiceSchema, i2.choices = e2.choices.map((t3) => typeof t3 == "object" && t3.redirect ? Object.assign(Object.assign({}, t3), {}, { redirect: { to: { key: e2.name, value: t3.redirect } } }) : t3);
        break;
      case "boolean":
        r2 = ka$1.BooleanSchema;
        break;
      case "flag":
        r2 = jc, i2.flags = n2.flatMap((e3) => [e3.alias, e3.description && e3.name, e3.oppositeDescription && `no-${e3.name}`].filter(Boolean));
        break;
      case "path":
        r2 = ka$1.StringSchema;
        break;
      default:
        throw new Error(`Unexpected type ${e2.type}`);
    }
    if (e2.exception ? i2.validate = (t3, n3, r3) => e2.exception(t3) || n3.validate(t3, r3) : i2.validate = (e3, t3, n3) => e3 === void 0 || t3.validate(e3, n3), e2.redirect && (u2.redirect = (t3) => t3 ? { to: { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (u2.deprecated = true), t2 && !e2.array) {
      const e3 = i2.preprocess || ((e4) => e4);
      i2.preprocess = (t3, n3, r3) => n3.preprocess(e3(Array.isArray(t3) ? Ln$2(t3) : t3), r3);
    }
    return e2.array ? ka$1.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, t2 ? { preprocess: (e3) => Array.isArray(e3) ? e3 : [e3] } : {}), u2), {}, { valueSchema: r2.create(i2) })) : r2.create(Object.assign(Object.assign({}, i2), u2));
  }
  var $c = { normalizeApiOptions: function(e2, t2, n2) {
    return Mc(e2, t2, n2);
  }, normalizeCliOptions: function(e2, t2, n2) {
    return Mc(e2, t2, Object.assign({ isCLI: true }, n2));
  } };
  const { isNonEmptyArray: Vc } = yi$2;
  function Wc(e2, t2) {
    const { ignoreDecorators: n2 } = t2 || {};
    if (!n2) {
      const t3 = e2.declaration && e2.declaration.decorators || e2.decorators;
      if (Vc(t3))
        return Wc(t3[0]);
    }
    return e2.range ? e2.range[0] : e2.start;
  }
  function qc(e2) {
    return e2.range ? e2.range[1] : e2.end;
  }
  function Uc(e2, t2) {
    return Wc(e2) === Wc(t2);
  }
  var zc = { locStart: Wc, locEnd: qc, hasSameLocStart: Uc, hasSameLoc: function(e2, t2) {
    return Uc(e2, t2) && function(e3, t3) {
      return qc(e3) === qc(t3);
    }(e2, t2);
  } }, Gc = Object.defineProperty({ default: /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, matchToToken: function(e2) {
    var t2 = { type: "invalid", value: e2[0], closed: void 0 };
    return e2[1] ? (t2.type = "string", t2.closed = !(!e2[3] && !e2[4])) : e2[5] ? t2.type = "comment" : e2[6] ? (t2.type = "comment", t2.closed = !!e2[7]) : e2[8] ? t2.type = "regex" : e2[9] ? t2.type = "number" : e2[10] ? t2.type = "name" : e2[11] ? t2.type = "punctuator" : e2[12] && (t2.type = "whitespace"), t2;
  } }, "__esModule", { value: true }), Hc = rl, Jc = il, Xc = function(e2) {
    let t2 = true;
    for (let n2 = 0; n2 < e2.length; n2++) {
      let r2 = e2.charCodeAt(n2);
      if ((64512 & r2) == 55296 && n2 + 1 < e2.length) {
        const t3 = e2.charCodeAt(++n2);
        (64512 & t3) == 56320 && (r2 = 65536 + ((1023 & r2) << 10) + (1023 & t3));
      }
      if (t2) {
        if (t2 = false, !rl(r2))
          return false;
      } else if (!il(r2))
        return false;
    }
    return !t2;
  };
  let Yc = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Kc = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  const Qc = new RegExp("[" + Yc + "]"), Zc = new RegExp("[" + Yc + Kc + "]");
  Yc = Kc = null;
  const el = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], tl = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function nl(e2, t2) {
    let n2 = 65536;
    for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
      if (n2 += t2[r2], n2 > e2)
        return false;
      if (n2 += t2[r2 + 1], n2 >= e2)
        return true;
    }
    return false;
  }
  function rl(e2) {
    return e2 < 65 ? e2 === 36 : e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && Qc.test(String.fromCharCode(e2)) : nl(e2, el)));
  }
  function il(e2) {
    return e2 < 48 ? e2 === 36 : e2 < 58 || !(e2 < 65) && (e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && Zc.test(String.fromCharCode(e2)) : nl(e2, el) || nl(e2, tl))));
  }
  var ul = Object.defineProperty({ isIdentifierStart: Hc, isIdentifierChar: Jc, isIdentifierName: Xc }, "__esModule", { value: true }), ol = ml, sl = yl, al = Dl, cl = function(e2, t2) {
    return yl(e2, t2) || Dl(e2);
  }, ll = function(e2) {
    return dl.has(e2);
  };
  const pl = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], fl = ["eval", "arguments"], dl = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), hl = new Set(pl), gl = new Set(fl);
  function ml(e2, t2) {
    return t2 && e2 === "await" || e2 === "enum";
  }
  function yl(e2, t2) {
    return ml(e2, t2) || hl.has(e2);
  }
  function Dl(e2) {
    return gl.has(e2);
  }
  var El = Object.defineProperty({ isReservedWord: ol, isStrictReservedWord: sl, isStrictBindOnlyReservedWord: al, isStrictBindReservedWord: cl, isKeyword: ll }, "__esModule", { value: true }), Cl = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierName", { enumerable: true, get: function() {
      return ul.isIdentifierName;
    } }), Object.defineProperty(t2, "isIdentifierChar", { enumerable: true, get: function() {
      return ul.isIdentifierChar;
    } }), Object.defineProperty(t2, "isIdentifierStart", { enumerable: true, get: function() {
      return ul.isIdentifierStart;
    } }), Object.defineProperty(t2, "isReservedWord", { enumerable: true, get: function() {
      return El.isReservedWord;
    } }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
      return El.isStrictBindOnlyReservedWord;
    } }), Object.defineProperty(t2, "isStrictBindReservedWord", { enumerable: true, get: function() {
      return El.isStrictBindReservedWord;
    } }), Object.defineProperty(t2, "isStrictReservedWord", { enumerable: true, get: function() {
      return El.isStrictReservedWord;
    } }), Object.defineProperty(t2, "isKeyword", { enumerable: true, get: function() {
      return El.isKeyword;
    } });
  }), bl = /[|\\{}()[\]^$+*?.]/g, Al = function(e2) {
    if (typeof e2 != "string")
      throw new TypeError("Expected a string");
    return e2.replace(bl, "\\$&");
  }, vl = r$3(function(e2) {
    const t2 = (e3, t3) => function() {
      const n3 = e3.apply(Ro$2, arguments);
      return `[${n3 + t3}m`;
    }, n2 = (e3, t3) => function() {
      const n3 = e3.apply(Ro$2, arguments);
      return `[${38 + t3};5;${n3}m`;
    }, r2 = (e3, t3) => function() {
      const n3 = e3.apply(Ro$2, arguments);
      return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
    };
    Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
      const e3 = new Map(), i2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
      i2.color.grey = i2.color.gray;
      for (const t3 of Object.keys(i2)) {
        const n3 = i2[t3];
        for (const t4 of Object.keys(n3)) {
          const r3 = n3[t4];
          i2[t4] = { open: `[${r3[0]}m`, close: `[${r3[1]}m` }, n3[t4] = i2[t4], e3.set(r3[0], r3[1]);
        }
        Object.defineProperty(i2, t3, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", { value: e3, enumerable: false });
      }
      const u2 = (e4) => e4, o2 = (e4, t3, n3) => [e4, t3, n3];
      i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = { ansi: t2(u2, 0) }, i2.color.ansi256 = { ansi256: n2(u2, 0) }, i2.color.ansi16m = { rgb: r2(o2, 0) }, i2.bgColor.ansi = { ansi: t2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: n2(u2, 10) }, i2.bgColor.ansi16m = { rgb: r2(o2, 10) };
      for (let e4 of Object.keys(Ro$2)) {
        if (typeof Ro$2[e4] != "object")
          continue;
        const u3 = Ro$2[e4];
        e4 === "ansi16" && (e4 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e4] = t2(u3.ansi16, 0), i2.bgColor.ansi[e4] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e4] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e4] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e4] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e4] = r2(u3.rgb, 10));
      }
      return i2;
    } });
  }), Fl = (e2, t2) => {
    t2 = t2 || xr$2.argv;
    const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), i2 = t2.indexOf("--");
    return r2 !== -1 && (i2 === -1 || r2 < i2);
  };
  const Sl = xr$2.env;
  let xl;
  function wl(e2) {
    return function(e3) {
      return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
    }(function(e3) {
      if (xl === false)
        return 0;
      if (Fl("color=16m") || Fl("color=full") || Fl("color=truecolor"))
        return 3;
      if (Fl("color=256"))
        return 2;
      if (e3 && !e3.isTTY && xl !== true)
        return 0;
      const t2 = xl ? 1 : 0;
      if ("CI" in Sl)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Sl) || Sl.CI_NAME === "codeship" ? 1 : t2;
      if ("TEAMCITY_VERSION" in Sl)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Sl.TEAMCITY_VERSION) ? 1 : 0;
      if (Sl.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in Sl) {
        const e4 = parseInt((Sl.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (Sl.TERM_PROGRAM) {
          case "iTerm.app":
            return e4 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(Sl.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Sl.TERM) || "COLORTERM" in Sl ? 1 : (Sl.TERM, t2);
    }(e2));
  }
  Fl("no-color") || Fl("no-colors") || Fl("color=false") ? xl = false : (Fl("color") || Fl("colors") || Fl("color=true") || Fl("color=always")) && (xl = true), "FORCE_COLOR" in Sl && (xl = Sl.FORCE_COLOR.length === 0 || parseInt(Sl.FORCE_COLOR, 10) !== 0);
  var Tl = { supportsColor: wl, stdout: wl(xr$2.stdout), stderr: wl(xr$2.stderr) };
  const Bl = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Nl = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, kl = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Pl = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Ol = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
  function Il(e2) {
    return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : Ol.get(e2) || e2;
  }
  function Ll(e2, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let i2;
    for (const t3 of r2)
      if (isNaN(t3)) {
        if (!(i2 = t3.match(kl)))
          throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e2}')`);
        n2.push(i2[2].replace(Pl, (e3, t4, n3) => t4 ? Il(t4) : n3));
      } else
        n2.push(Number(t3));
    return n2;
  }
  function jl(e2) {
    Nl.lastIndex = 0;
    const t2 = [];
    let n2;
    for (; (n2 = Nl.exec(e2)) !== null; ) {
      const e3 = n2[1];
      if (n2[2]) {
        const r2 = Ll(e3, n2[2]);
        t2.push([e3].concat(r2));
      } else
        t2.push([e3]);
    }
    return t2;
  }
  function _l(e2, t2) {
    const n2 = {};
    for (const e3 of t2)
      for (const t3 of e3.styles)
        n2[t3[0]] = e3.inverse ? null : t3.slice(1);
    let r2 = e2;
    for (const e3 of Object.keys(n2))
      if (Array.isArray(n2[e3])) {
        if (!(e3 in r2))
          throw new Error(`Unknown Chalk style: ${e3}`);
        r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
      }
    return r2;
  }
  var Ml = (e2, t2) => {
    const n2 = [], r2 = [];
    let i2 = [];
    if (t2.replace(Bl, (t3, u2, o2, s2, a2, c2) => {
      if (u2)
        i2.push(Il(u2));
      else if (s2) {
        const t4 = i2.join("");
        i2 = [], r2.push(n2.length === 0 ? t4 : _l(e2, n2)(t4)), n2.push({ inverse: o2, styles: jl(s2) });
      } else if (a2) {
        if (n2.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        r2.push(_l(e2, n2)(i2.join(""))), i2 = [], n2.pop();
      } else
        i2.push(c2);
    }), r2.push(i2.join("")), n2.length > 0) {
      const e3 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(e3);
    }
    return r2.join("");
  }, Rl = r$3(function(e2) {
    const t2 = Tl.stdout, r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
    function o2(e3, n2) {
      n2 = n2 || {};
      const r3 = t2 ? t2.level : 0;
      e3.level = n2.level === void 0 ? r3 : n2.level, e3.enabled = "enabled" in n2 ? n2.enabled : e3.level > 0;
    }
    function s2(e3) {
      if (!this || !(this instanceof s2) || this.template) {
        const t3 = {};
        return o2(t3, e3), t3.template = function() {
          const e4 = [].slice.call(arguments);
          return p2.apply(null, [t3.template].concat(e4));
        }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
      }
      o2(this, e3);
    }
    for (const e3 of Object.keys(vl))
      vl[e3].closeRe = new RegExp(Al(vl[e3].close), "g"), u2[e3] = { get() {
        const t3 = vl[e3];
        return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
      } };
    u2.visible = { get() {
      return c2.call(this, this._styles || [], true, "visible");
    } }, vl.color.closeRe = new RegExp(Al(vl.color.close), "g");
    for (const e3 of Object.keys(vl.color.ansi))
      i2.has(e3) || (u2[e3] = { get() {
        const t3 = this.level;
        return function() {
          const n2 = vl.color[r2[t3]][e3].apply(null, arguments), i3 = { open: n2, close: vl.color.close, closeRe: vl.color.closeRe };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
        };
      } });
    vl.bgColor.closeRe = new RegExp(Al(vl.bgColor.close), "g");
    for (const e3 of Object.keys(vl.bgColor.ansi)) {
      if (i2.has(e3))
        continue;
      u2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
        const t3 = this.level;
        return function() {
          const n2 = vl.bgColor[r2[t3]][e3].apply(null, arguments), i3 = { open: n2, close: vl.bgColor.close, closeRe: vl.bgColor.closeRe };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
        };
      } };
    }
    const a2 = Object.defineProperties(() => {
    }, u2);
    function c2(e3, t3, n2) {
      const r3 = function() {
        return l2.apply(r3, arguments);
      };
      r3._styles = e3, r3._empty = t3;
      const i3 = this;
      return Object.defineProperty(r3, "level", { enumerable: true, get: () => i3.level, set(e4) {
        i3.level = e4;
      } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => i3.enabled, set(e4) {
        i3.enabled = e4;
      } }), r3.hasGrey = this.hasGrey || n2 === "gray" || n2 === "grey", r3.__proto__ = a2, r3;
    }
    function l2() {
      const e3 = arguments, t3 = e3.length;
      let r3 = String(arguments[0]);
      if (t3 === 0)
        return "";
      if (t3 > 1)
        for (let n2 = 1; n2 < t3; n2++)
          r3 += " " + e3[n2];
      if (!this.enabled || this.level <= 0 || !r3)
        return this._empty ? "" : r3;
      const i3 = vl.dim.open;
      for (const e4 of this._styles.slice().reverse())
        r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, `${e4.close}$&${e4.open}`);
      return vl.dim.open = i3, r3;
    }
    function p2(e3, t3) {
      if (!Array.isArray(t3))
        return [].slice.call(arguments, 1).join(" ");
      const n2 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
      for (let e4 = 1; e4 < t3.length; e4++)
        r3.push(String(n2[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
      return Ml(e3, r3.join(""));
    }
    Object.defineProperties(s2.prototype, u2), e2.exports = s2(), e2.exports.supportsColor = t2, e2.exports.default = e2.exports;
  }), $l = Hl, Vl = Jl, Wl = function(e2, t2 = {}) {
    if (Hl(t2)) {
      const n2 = Jl(t2);
      return function(e3, t3) {
        let n3 = "";
        for (const { type: r2, value: i2 } of Gl(t3)) {
          const t4 = e3[r2];
          n3 += t4 ? i2.split(Ul).map((e4) => t4(e4)).join("\n") : i2;
        }
        return n3;
      }(function(e3) {
        return { keyword: e3.cyan, capitalized: e3.yellow, jsxIdentifier: e3.yellow, punctuator: e3.yellow, number: e3.magenta, string: e3.green, regex: e3.magenta, comment: e3.grey, invalid: e3.white.bgRed.bold };
      }(n2), e2);
    }
    return e2;
  };
  const ql = new Set(["as", "async", "from", "get", "of", "set"]);
  const Ul = /\r\n|[\n\r\u2028\u2029]/, zl = /^[()[\]{}]$/;
  let Gl;
  {
    const e2 = /^[a-z][\w-]*$/i, t2 = function(t3, n2, r2) {
      if (t3.type === "name") {
        if ((0, Cl.isKeyword)(t3.value) || (0, Cl.isStrictReservedWord)(t3.value, true) || ql.has(t3.value))
          return "keyword";
        if (e2.test(t3.value) && (r2[n2 - 1] === "<" || r2.substr(n2 - 2, 2) == "</"))
          return "jsxIdentifier";
        if (t3.value[0] !== t3.value[0].toLowerCase())
          return "capitalized";
      }
      return t3.type === "punctuator" && zl.test(t3.value) ? "bracket" : t3.type !== "invalid" || t3.value !== "@" && t3.value !== "#" ? t3.type : "punctuator";
    };
    Gl = function* (e3) {
      let n2;
      for (; n2 = Gc.default.exec(e3); ) {
        const r2 = Gc.matchToToken(n2);
        yield { type: t2(r2, n2.index, e3), value: r2.value };
      }
    };
  }
  function Hl(e2) {
    return !!Rl.supportsColor || e2.forceColor;
  }
  function Jl(e2) {
    return e2.forceColor ? new Rl.constructor({ enabled: true, level: 1 }) : Rl;
  }
  var Xl = Object.defineProperty({ shouldHighlight: $l, getChalk: Vl, default: Wl }, "__esModule", { value: true }), Yl = ep, Kl = function(e2, t2, n2, r2 = {}) {
    if (!Ql) {
      Ql = true;
      const e3 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        new Error(e3).name = "DeprecationWarning", console.warn(new Error(e3));
      }
    }
    n2 = Math.max(n2, 0);
    return ep(e2, { start: { column: n2, line: t2 } }, r2);
  };
  let Ql = false;
  const Zl = /\r\n|[\n\r\u2028\u2029]/;
  function ep(e2, t2, n2 = {}) {
    const r2 = (n2.highlightCode || n2.forceColor) && (0, Xl.shouldHighlight)(n2), i2 = (0, Xl.getChalk)(n2), u2 = function(e3) {
      return { gutter: e3.grey, marker: e3.red.bold, message: e3.red.bold };
    }(i2), o2 = (e3, t3) => r2 ? e3(t3) : t3, s2 = e2.split(Zl), { start: a2, end: c2, markerLines: l2 } = function(e3, t3, n3) {
      const r3 = Object.assign({ column: 0, line: -1 }, e3.start), i3 = Object.assign({}, r3, e3.end), { linesAbove: u3 = 2, linesBelow: o3 = 3 } = n3 || {}, s3 = r3.line, a3 = r3.column, c3 = i3.line, l3 = i3.column;
      let p3 = Math.max(s3 - (u3 + 1), 0), f3 = Math.min(t3.length, c3 + o3);
      s3 === -1 && (p3 = 0), c3 === -1 && (f3 = t3.length);
      const d3 = c3 - s3, h2 = {};
      if (d3)
        for (let e4 = 0; e4 <= d3; e4++) {
          const n4 = e4 + s3;
          if (a3)
            if (e4 === 0) {
              const e5 = t3[n4 - 1].length;
              h2[n4] = [a3, e5 - a3 + 1];
            } else if (e4 === d3)
              h2[n4] = [0, l3];
            else {
              const r4 = t3[n4 - e4].length;
              h2[n4] = [0, r4];
            }
          else
            h2[n4] = true;
        }
      else
        h2[s3] = a3 === l3 ? !a3 || [a3, 0] : [a3, l3 - a3];
      return { start: p3, end: f3, markerLines: h2 };
    }(t2, s2, n2), p2 = t2.start && typeof t2.start.column == "number", f2 = String(c2).length;
    let d2 = (r2 ? (0, Xl.default)(e2, n2) : e2).split(Zl).slice(a2, c2).map((e3, t3) => {
      const r3 = a2 + 1 + t3, i3 = ` ${` ${r3}`.slice(-f2)} |`, s3 = l2[r3], c3 = !l2[r3 + 1];
      if (s3) {
        let t4 = "";
        if (Array.isArray(s3)) {
          const r4 = e3.slice(0, Math.max(s3[0] - 1, 0)).replace(/[^\t]/g, " "), a3 = s3[1] || 1;
          t4 = ["\n ", o2(u2.gutter, i3.replace(/\d/g, " ")), " ", r4, o2(u2.marker, "^").repeat(a3)].join(""), c3 && n2.message && (t4 += " " + o2(u2.message, n2.message));
        }
        return [o2(u2.marker, ">"), o2(u2.gutter, i3), e3.length > 0 ? ` ${e3}` : "", t4].join("");
      }
      return ` ${o2(u2.gutter, i3)}${e3.length > 0 ? ` ${e3}` : ""}`;
    }).join("\n");
    return n2.message && !p2 && (d2 = `${" ".repeat(f2 + 1)}${n2.message}
${d2}`), r2 ? i2.reset(d2) : d2;
  }
  var tp = Object.defineProperty({ codeFrameColumns: Yl, default: Kl }, "__esModule", { value: true }), np = n$3(mu$1);
  const { ConfigError: rp } = bo$2, { locStart: ip, locEnd: up } = zc, op = Object.getOwnPropertyNames, sp = Object.getOwnPropertyDescriptor;
  function ap(e2) {
    const t2 = {};
    for (const n2 of e2.plugins)
      if (n2.parsers)
        for (const e3 of op(n2.parsers))
          Object.defineProperty(t2, e3, sp(n2.parsers, e3));
    return t2;
  }
  function cp(e2, t2 = ap(e2)) {
    if (typeof e2.parser == "function")
      return { parse: e2.parser, astFormat: "estree", locStart: ip, locEnd: up };
    if (typeof e2.parser == "string") {
      if (Object.prototype.hasOwnProperty.call(t2, e2.parser))
        return t2[e2.parser];
      throw new rp(`Couldn't resolve parser "${e2.parser}". Parsers must be explicitly added to the standalone bundle.`);
    }
  }
  var lp = { parse: function(e2, t2) {
    const n2 = ap(t2), r2 = Object.defineProperties({}, Object.fromEntries(Object.keys(n2).map((e3) => [e3, { enumerable: true, get: () => n2[e3].parse }]))), i2 = cp(t2, n2);
    try {
      return i2.preprocess && (e2 = i2.preprocess(e2, t2)), { text: e2, ast: i2.parse(e2, r2, t2) };
    } catch (t3) {
      const { loc: n3 } = t3;
      if (n3) {
        const { codeFrameColumns: r3 } = tp;
        throw t3.codeFrame = r3(e2, n3, { highlightCode: true }), t3.message += "\n" + t3.codeFrame, t3;
      }
      throw t3.stack;
    }
  }, resolveParser: cp };
  const { UndefinedParserError: pp } = bo$2, { getSupportInfo: fp } = Qr$2, { resolveParser: dp } = lp, hp = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
  function gp(e2, t2) {
    const n2 = np.basename(e2).toLowerCase(), r2 = fp({ plugins: t2 }).languages.filter((e3) => e3.since !== null);
    let i2 = r2.find((e3) => e3.extensions && e3.extensions.some((e4) => n2.endsWith(e4)) || e3.filenames && e3.filenames.some((e4) => e4.toLowerCase() === n2));
    if (!i2 && !n2.includes(".")) {
      const t3 = function(e3) {
        if (typeof e3 != "string")
          return "";
        let t4;
        try {
          t4 = go$2.openSync(e3, "r");
        } catch (e4) {
          return "";
        }
        try {
          const e4 = new mo$2(t4).next().toString("utf8"), n3 = e4.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
          if (n3)
            return n3[1];
          const r3 = e4.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
          return r3 ? r3[1] : "";
        } catch (e4) {
          return "";
        } finally {
          try {
            go$2.closeSync(t4);
          } catch (e4) {
          }
        }
      }(e2);
      i2 = r2.find((e3) => e3.interpreters && e3.interpreters.includes(t3));
    }
    return i2 && i2.parsers[0];
  }
  var mp = { normalize: function(e2, t2 = {}) {
    const n2 = Object.assign({}, e2), r2 = fp({ plugins: e2.plugins, showUnreleased: true, showDeprecated: true }).options, i2 = Object.assign(Object.assign({}, hp), Object.fromEntries(r2.filter((e3) => e3.default !== void 0).map((e3) => [e3.name, e3.default])));
    if (!n2.parser)
      if (n2.filepath) {
        if (n2.parser = gp(n2.filepath, n2.plugins), !n2.parser)
          throw new pp(`No parser could be inferred for file: ${n2.filepath}`);
      } else {
        (t2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
      }
    const u2 = dp($c.normalizeApiOptions(n2, [r2.find((e3) => e3.name === "parser")], { passThrough: true, logger: false }));
    n2.astFormat = u2.astFormat, n2.locEnd = u2.locEnd, n2.locStart = u2.locStart;
    const o2 = function(e3) {
      const { astFormat: t3 } = e3;
      if (!t3)
        throw new Error("getPlugin() requires astFormat to be set");
      const n3 = e3.plugins.find((e4) => e4.printers && e4.printers[t3]);
      if (!n3)
        throw new Error(`Couldn't find plugin for AST format "${t3}"`);
      return n3;
    }(n2);
    n2.printer = o2.printers[n2.astFormat];
    const s2 = Object.fromEntries(r2.filter((e3) => e3.pluginDefaults && e3.pluginDefaults[o2.name] !== void 0).map((e3) => [e3.name, e3.pluginDefaults[o2.name]])), a2 = Object.assign(Object.assign({}, i2), s2);
    for (const [e3, t3] of Object.entries(a2))
      n2[e3] !== null && n2[e3] !== void 0 || (n2[e3] = t3);
    return n2.parser === "json" && (n2.trailingComma = "none"), $c.normalizeApiOptions(n2, r2, Object.assign({ passThrough: Object.keys(hp) }, t2));
  }, hiddenDefaults: hp, inferParser: gp };
  var yp = function e2(t2, n2, r2) {
    if (Array.isArray(t2))
      return t2.map((t3) => e2(t3, n2, r2)).filter(Boolean);
    if (!t2 || typeof t2 != "object")
      return t2;
    const i2 = n2.printer.massageAstNode;
    let u2;
    u2 = i2 && i2.ignoredProperties ? i2.ignoredProperties : new Set();
    const o2 = {};
    for (const [r3, i3] of Object.entries(t2))
      u2.has(r3) || typeof i3 == "function" || (o2[r3] = e2(i3, n2, t2));
    if (i2) {
      const e3 = i2(t2, o2, r2);
      if (e3 === null)
        return;
      if (e3)
        return e3;
    }
    return o2;
  }, Dp = typeof Object.create == "function" ? function(e2, t2) {
    e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
  } : function(e2, t2) {
    e2.super_ = t2;
    var n2 = function() {
    };
    n2.prototype = t2.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
  };
  function Ep(e2, t2) {
    var n2 = { seen: [], stylize: bp };
    return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Sp(t2) ? n2.showHidden = t2 : t2 && jp(n2, t2), Tp(n2.showHidden) && (n2.showHidden = false), Tp(n2.depth) && (n2.depth = 2), Tp(n2.colors) && (n2.colors = false), Tp(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = Cp), Ap(n2, e2, n2.depth);
  }
  function Cp(e2, t2) {
    var n2 = Ep.styles[t2];
    return n2 ? "[" + Ep.colors[n2][0] + "m" + e2 + "[" + Ep.colors[n2][1] + "m" : e2;
  }
  function bp(e2, t2) {
    return e2;
  }
  function Ap(e2, t2, n2) {
    if (e2.customInspect && t2 && Op(t2.inspect) && t2.inspect !== Ep && (!t2.constructor || t2.constructor.prototype !== t2)) {
      var r2 = t2.inspect(n2, e2);
      return wp(r2) || (r2 = Ap(e2, r2, n2)), r2;
    }
    var i2 = function(e3, t3) {
      if (Tp(t3))
        return e3.stylize("undefined", "undefined");
      if (wp(t3)) {
        var n3 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e3.stylize(n3, "string");
      }
      if (r3 = t3, typeof r3 == "number")
        return e3.stylize("" + t3, "number");
      var r3;
      if (Sp(t3))
        return e3.stylize("" + t3, "boolean");
      if (xp(t3))
        return e3.stylize("null", "null");
    }(e2, t2);
    if (i2)
      return i2;
    var u2 = Object.keys(t2), o2 = function(e3) {
      var t3 = {};
      return e3.forEach(function(e4, n3) {
        t3[e4] = true;
      }), t3;
    }(u2);
    if (e2.showHidden && (u2 = Object.getOwnPropertyNames(t2)), Pp(t2) && (u2.indexOf("message") >= 0 || u2.indexOf("description") >= 0))
      return vp(t2);
    if (u2.length === 0) {
      if (Op(t2)) {
        var s2 = t2.name ? ": " + t2.name : "";
        return e2.stylize("[Function" + s2 + "]", "special");
      }
      if (Bp(t2))
        return e2.stylize(RegExp.prototype.toString.call(t2), "regexp");
      if (kp(t2))
        return e2.stylize(Date.prototype.toString.call(t2), "date");
      if (Pp(t2))
        return vp(t2);
    }
    var a2, c2, l2 = "", p2 = false, f2 = ["{", "}"];
    (a2 = t2, Array.isArray(a2) && (p2 = true, f2 = ["[", "]"]), Op(t2)) && (l2 = " [Function" + (t2.name ? ": " + t2.name : "") + "]");
    return Bp(t2) && (l2 = " " + RegExp.prototype.toString.call(t2)), kp(t2) && (l2 = " " + Date.prototype.toUTCString.call(t2)), Pp(t2) && (l2 = " " + vp(t2)), u2.length !== 0 || p2 && t2.length != 0 ? n2 < 0 ? Bp(t2) ? e2.stylize(RegExp.prototype.toString.call(t2), "regexp") : e2.stylize("[Object]", "special") : (e2.seen.push(t2), c2 = p2 ? function(e3, t3, n3, r3, i3) {
      for (var u3 = [], o3 = 0, s3 = t3.length; o3 < s3; ++o3)
        _p(t3, String(o3)) ? u3.push(Fp(e3, t3, n3, r3, String(o3), true)) : u3.push("");
      return i3.forEach(function(i4) {
        i4.match(/^\d+$/) || u3.push(Fp(e3, t3, n3, r3, i4, true));
      }), u3;
    }(e2, t2, n2, o2, u2) : u2.map(function(r3) {
      return Fp(e2, t2, n2, o2, r3, p2);
    }), e2.seen.pop(), function(e3, t3, n3) {
      if (e3.reduce(function(e4, t4) {
        return t4.indexOf("\n"), e4 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return n3[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e3.join(",\n  ") + " " + n3[1];
      return n3[0] + t3 + " " + e3.join(", ") + " " + n3[1];
    }(c2, l2, f2)) : f2[0] + l2 + f2[1];
  }
  function vp(e2) {
    return "[" + Error.prototype.toString.call(e2) + "]";
  }
  function Fp(e2, t2, n2, r2, i2, u2) {
    var o2, s2, a2;
    if ((a2 = Object.getOwnPropertyDescriptor(t2, i2) || { value: t2[i2] }).get ? s2 = a2.set ? e2.stylize("[Getter/Setter]", "special") : e2.stylize("[Getter]", "special") : a2.set && (s2 = e2.stylize("[Setter]", "special")), _p(r2, i2) || (o2 = "[" + i2 + "]"), s2 || (e2.seen.indexOf(a2.value) < 0 ? (s2 = xp(n2) ? Ap(e2, a2.value, null) : Ap(e2, a2.value, n2 - 1)).indexOf("\n") > -1 && (s2 = u2 ? s2.split("\n").map(function(e3) {
      return "  " + e3;
    }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e3) {
      return "   " + e3;
    }).join("\n")) : s2 = e2.stylize("[Circular]", "special")), Tp(o2)) {
      if (u2 && i2.match(/^\d+$/))
        return s2;
      (o2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e2.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e2.stylize(o2, "string"));
    }
    return o2 + ": " + s2;
  }
  function Sp(e2) {
    return typeof e2 == "boolean";
  }
  function xp(e2) {
    return e2 === null;
  }
  function wp(e2) {
    return typeof e2 == "string";
  }
  function Tp(e2) {
    return e2 === void 0;
  }
  function Bp(e2) {
    return Np(e2) && Lp(e2) === "[object RegExp]";
  }
  function Np(e2) {
    return typeof e2 == "object" && e2 !== null;
  }
  function kp(e2) {
    return Np(e2) && Lp(e2) === "[object Date]";
  }
  function Pp(e2) {
    return Np(e2) && (Lp(e2) === "[object Error]" || e2 instanceof Error);
  }
  function Op(e2) {
    return typeof e2 == "function";
  }
  function Ip(e2) {
    return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || e2 === void 0;
  }
  function Lp(e2) {
    return Object.prototype.toString.call(e2);
  }
  function jp(e2, t2) {
    if (!t2 || !Np(t2))
      return e2;
    for (var n2 = Object.keys(t2), r2 = n2.length; r2--; )
      e2[n2[r2]] = t2[n2[r2]];
    return e2;
  }
  function _p(e2, t2) {
    return Object.prototype.hasOwnProperty.call(e2, t2);
  }
  function Mp(e2, t2) {
    if (e2 === t2)
      return 0;
    for (var n2 = e2.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
      if (e2[i2] !== t2[i2]) {
        n2 = e2[i2], r2 = t2[i2];
        break;
      }
    return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
  }
  Ep.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, Ep.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
  var Rp, $p = Object.prototype.hasOwnProperty, Vp = Object.keys || function(e2) {
    var t2 = [];
    for (var n2 in e2)
      $p.call(e2, n2) && t2.push(n2);
    return t2;
  }, Wp = Array.prototype.slice;
  function qp() {
    return Rp !== void 0 ? Rp : Rp = function() {
    }.name === "foo";
  }
  function Up(e2) {
    return Object.prototype.toString.call(e2);
  }
  function zp(e2) {
    return !fo$2(e2) && (typeof nr$2.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e2) : !!e2 && (e2 instanceof DataView || !!(e2.buffer && e2.buffer instanceof ArrayBuffer))));
  }
  function Gp(e2, t2) {
    e2 || Qp(e2, true, t2, "==", Zp);
  }
  var Hp = /\s*function\s+([^\(\s]*)\s*/;
  function Jp(e2) {
    if (Op(e2)) {
      if (qp())
        return e2.name;
      var t2 = e2.toString().match(Hp);
      return t2 && t2[1];
    }
  }
  function Xp(e2) {
    this.name = "AssertionError", this.actual = e2.actual, this.expected = e2.expected, this.operator = e2.operator, e2.message ? (this.message = e2.message, this.generatedMessage = false) : (this.message = function(e3) {
      return Yp(Kp(e3.actual), 128) + " " + e3.operator + " " + Yp(Kp(e3.expected), 128);
    }(this), this.generatedMessage = true);
    var t2 = e2.stackStartFunction || Qp;
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, t2);
    else {
      var n2 = new Error();
      if (n2.stack) {
        var r2 = n2.stack, i2 = Jp(t2), u2 = r2.indexOf("\n" + i2);
        if (u2 >= 0) {
          var o2 = r2.indexOf("\n", u2 + 1);
          r2 = r2.substring(o2 + 1);
        }
        this.stack = r2;
      }
    }
  }
  function Yp(e2, t2) {
    return typeof e2 == "string" ? e2.length < t2 ? e2 : e2.slice(0, t2) : e2;
  }
  function Kp(e2) {
    if (qp() || !Op(e2))
      return Ep(e2);
    var t2 = Jp(e2);
    return "[Function" + (t2 ? ": " + t2 : "") + "]";
  }
  function Qp(e2, t2, n2, r2, i2) {
    throw new Xp({ message: n2, actual: e2, expected: t2, operator: r2, stackStartFunction: i2 });
  }
  function Zp(e2, t2) {
    e2 || Qp(e2, true, t2, "==", Zp);
  }
  function ef(e2, t2, n2) {
    e2 != t2 && Qp(e2, t2, n2, "==", ef);
  }
  function tf(e2, t2, n2) {
    e2 == t2 && Qp(e2, t2, n2, "!=", tf);
  }
  function nf(e2, t2, n2) {
    uf(e2, t2, false) || Qp(e2, t2, n2, "deepEqual", nf);
  }
  function rf(e2, t2, n2) {
    uf(e2, t2, true) || Qp(e2, t2, n2, "deepStrictEqual", rf);
  }
  function uf(e2, t2, n2, r2) {
    if (e2 === t2)
      return true;
    if (fo$2(e2) && fo$2(t2))
      return Mp(e2, t2) === 0;
    if (kp(e2) && kp(t2))
      return e2.getTime() === t2.getTime();
    if (Bp(e2) && Bp(t2))
      return e2.source === t2.source && e2.global === t2.global && e2.multiline === t2.multiline && e2.lastIndex === t2.lastIndex && e2.ignoreCase === t2.ignoreCase;
    if (e2 !== null && typeof e2 == "object" || t2 !== null && typeof t2 == "object") {
      if (zp(e2) && zp(t2) && Up(e2) === Up(t2) && !(e2 instanceof Float32Array || e2 instanceof Float64Array))
        return Mp(new Uint8Array(e2.buffer), new Uint8Array(t2.buffer)) === 0;
      if (fo$2(e2) !== fo$2(t2))
        return false;
      var i2 = (r2 = r2 || { actual: [], expected: [] }).actual.indexOf(e2);
      return i2 !== -1 && i2 === r2.expected.indexOf(t2) || (r2.actual.push(e2), r2.expected.push(t2), function(e3, t3, n3, r3) {
        if (e3 == null || t3 == null)
          return false;
        if (Ip(e3) || Ip(t3))
          return e3 === t3;
        if (n3 && Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3))
          return false;
        var i3 = of(e3), u2 = of(t3);
        if (i3 && !u2 || !i3 && u2)
          return false;
        if (i3)
          return uf(e3 = Wp.call(e3), t3 = Wp.call(t3), n3);
        var o2, s2, a2 = Vp(e3), c2 = Vp(t3);
        if (a2.length !== c2.length)
          return false;
        for (a2.sort(), c2.sort(), s2 = a2.length - 1; s2 >= 0; s2--)
          if (a2[s2] !== c2[s2])
            return false;
        for (s2 = a2.length - 1; s2 >= 0; s2--)
          if (!uf(e3[o2 = a2[s2]], t3[o2], n3, r3))
            return false;
        return true;
      }(e2, t2, n2, r2));
    }
    return n2 ? e2 === t2 : e2 == t2;
  }
  function of(e2) {
    return Object.prototype.toString.call(e2) == "[object Arguments]";
  }
  function sf(e2, t2, n2) {
    uf(e2, t2, false) && Qp(e2, t2, n2, "notDeepEqual", sf);
  }
  function af(e2, t2, n2) {
    uf(e2, t2, true) && Qp(e2, t2, n2, "notDeepStrictEqual", af);
  }
  function cf(e2, t2, n2) {
    e2 !== t2 && Qp(e2, t2, n2, "===", cf);
  }
  function lf(e2, t2, n2) {
    e2 === t2 && Qp(e2, t2, n2, "!==", lf);
  }
  function pf(e2, t2) {
    if (!e2 || !t2)
      return false;
    if (Object.prototype.toString.call(t2) == "[object RegExp]")
      return t2.test(e2);
    try {
      if (e2 instanceof t2)
        return true;
    } catch (e3) {
    }
    return !Error.isPrototypeOf(t2) && t2.call({}, e2) === true;
  }
  function ff(e2, t2, n2, r2) {
    var i2;
    if (typeof t2 != "function")
      throw new TypeError('"block" argument must be a function');
    typeof n2 == "string" && (r2 = n2, n2 = null), i2 = function(e3) {
      var t3;
      try {
        e3();
      } catch (e4) {
        t3 = e4;
      }
      return t3;
    }(t2), r2 = (n2 && n2.name ? " (" + n2.name + ")." : ".") + (r2 ? " " + r2 : "."), e2 && !i2 && Qp(i2, n2, "Missing expected exception" + r2);
    var u2 = typeof r2 == "string", o2 = !e2 && i2 && !n2;
    if ((!e2 && Pp(i2) && u2 && pf(i2, n2) || o2) && Qp(i2, n2, "Got unwanted exception" + r2), e2 && i2 && n2 && !pf(i2, n2) || !e2 && i2)
      throw i2;
  }
  function df(e2, t2, n2) {
    ff(true, e2, t2, n2);
  }
  function hf(e2, t2, n2) {
    ff(false, e2, t2, n2);
  }
  function gf(e2) {
    if (e2)
      throw e2;
  }
  Gp.AssertionError = Xp, Dp(Xp, Error), Gp.fail = Qp, Gp.ok = Zp, Gp.equal = ef, Gp.notEqual = tf, Gp.deepEqual = nf, Gp.deepStrictEqual = rf, Gp.notDeepEqual = sf, Gp.notDeepStrictEqual = af, Gp.strictEqual = cf, Gp.notStrictEqual = lf, Gp.throws = df, Gp.doesNotThrow = hf, Gp.ifError = gf;
  var mf = n$3(Object.freeze({ __proto__: null, default: Gp, AssertionError: Xp, fail: Qp, ok: Zp, assert: Zp, equal: ef, notEqual: tf, deepEqual: nf, deepStrictEqual: rf, notDeepEqual: sf, notDeepStrictEqual: af, strictEqual: cf, notStrictEqual: lf, throws: df, doesNotThrow: hf, ifError: gf }));
  const { builders: { line: yf, hardline: Df, breakParent: Ef, indent: Cf, lineSuffix: bf, join: Af, cursor: vf } } = eu$1, { hasNewline: Ff, skipNewline: Sf, skipSpaces: xf, isPreviousLineEmpty: wf, addLeadingComment: Tf, addDanglingComment: Bf, addTrailingComment: Nf } = yi$2, kf = new WeakMap();
  function Pf(e2, t2, n2) {
    if (!e2)
      return;
    const { printer: r2, locStart: i2, locEnd: u2 } = t2;
    if (n2) {
      if (r2.canAttachComment && r2.canAttachComment(e2)) {
        let t3;
        for (t3 = n2.length - 1; t3 >= 0 && !(i2(n2[t3]) <= i2(e2) && u2(n2[t3]) <= u2(e2)); --t3)
          ;
        return void n2.splice(t3 + 1, 0, e2);
      }
    } else if (kf.has(e2))
      return kf.get(e2);
    const o2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e2, t2) || typeof e2 == "object" && Object.entries(e2).filter(([e3]) => e3 !== "enclosingNode" && e3 !== "precedingNode" && e3 !== "followingNode" && e3 !== "tokens" && e3 !== "comments").map(([, e3]) => e3);
    if (o2) {
      n2 || (n2 = [], kf.set(e2, n2));
      for (const e3 of o2)
        Pf(e3, t2, n2);
      return n2;
    }
  }
  function Of(e2, t2, n2, r2) {
    const { locStart: i2, locEnd: u2 } = n2, o2 = i2(t2), s2 = u2(t2), a2 = Pf(e2, n2);
    let c2, l2, p2 = 0, f2 = a2.length;
    for (; p2 < f2; ) {
      const e3 = p2 + f2 >> 1, r3 = a2[e3], d2 = i2(r3), h2 = u2(r3);
      if (d2 <= o2 && s2 <= h2)
        return Of(r3, t2, n2, r3);
      if (h2 <= o2)
        c2 = r3, p2 = e3 + 1;
      else {
        if (!(s2 <= d2))
          throw new Error("Comment location overlaps with node location");
        l2 = r3, f2 = e3;
      }
    }
    if (r2 && r2.type === "TemplateLiteral") {
      const { quasis: e3 } = r2, i3 = $f(e3, t2, n2);
      c2 && $f(e3, c2, n2) !== i3 && (c2 = null), l2 && $f(e3, l2, n2) !== i3 && (l2 = null);
    }
    return { enclosingNode: r2, precedingNode: c2, followingNode: l2 };
  }
  const If = () => false;
  const Lf = (e2) => !/[\S\n\u2028\u2029]/.test(e2);
  function jf(e2, t2, n2, r2) {
    const { comment: i2, precedingNode: u2 } = n2[r2], { locStart: o2, locEnd: s2 } = t2;
    let a2 = o2(i2);
    if (u2)
      for (let t3 = r2 - 1; t3 >= 0; t3--) {
        const { comment: r3, precedingNode: i3 } = n2[t3];
        if (i3 !== u2 || !Lf(e2.slice(s2(r3), a2)))
          break;
        a2 = o2(r3);
      }
    return Ff(e2, a2, { backwards: true });
  }
  function _f(e2, t2, n2, r2) {
    const { comment: i2, followingNode: u2 } = n2[r2], { locStart: o2, locEnd: s2 } = t2;
    let a2 = s2(i2);
    if (u2)
      for (let t3 = r2 + 1; t3 < n2.length; t3++) {
        const { comment: r3, followingNode: i3 } = n2[t3];
        if (i3 !== u2 || !Lf(e2.slice(a2, o2(r3))))
          break;
        a2 = s2(r3);
      }
    return Ff(e2, a2);
  }
  function Mf(e2, t2, n2) {
    const r2 = e2.length;
    if (r2 === 0)
      return;
    const { precedingNode: i2, followingNode: u2, enclosingNode: o2 } = e2[0], s2 = n2.printer.getGapRegex && n2.printer.getGapRegex(o2) || /^[\s(]*$/;
    let a2, c2 = n2.locStart(u2);
    for (a2 = r2; a2 > 0; --a2) {
      const { comment: r3, precedingNode: o3, followingNode: l2 } = e2[a2 - 1];
      mf.strictEqual(o3, i2), mf.strictEqual(l2, u2);
      const p2 = t2.slice(n2.locEnd(r3), c2);
      if (!s2.test(p2))
        break;
      c2 = n2.locStart(r3);
    }
    for (const [t3, { comment: n3 }] of e2.entries())
      t3 < a2 ? Nf(i2, n3) : Tf(u2, n3);
    for (const e3 of [i2, u2])
      e3.comments && e3.comments.length > 1 && e3.comments.sort((e4, t3) => n2.locStart(e4) - n2.locStart(t3));
    e2.length = 0;
  }
  function Rf(e2, t2) {
    return e2.getValue().printed = true, t2.printer.printComment(e2, t2);
  }
  function $f(e2, t2, n2) {
    const r2 = n2.locStart(t2) - 1;
    for (let t3 = 1; t3 < e2.length; ++t3)
      if (r2 < n2.locStart(e2[t3]))
        return t3 - 1;
    return 0;
  }
  function Vf(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!r2)
      return {};
    let i2 = r2.comments || [];
    n2 && (i2 = i2.filter((e3) => !n2.has(e3)));
    const u2 = r2 === t2.cursorNode;
    if (i2.length === 0) {
      const e3 = u2 ? vf : "";
      return { leading: e3, trailing: e3 };
    }
    const o2 = [], s2 = [];
    return e2.each(() => {
      const r3 = e2.getValue();
      if (n2 && n2.has(r3))
        return;
      const { leading: i3, trailing: u3 } = r3;
      i3 ? o2.push(function(e3, t3) {
        const n3 = e3.getValue(), r4 = [Rf(e3, t3)], { printer: i4, originalText: u4, locStart: o3, locEnd: s3 } = t3;
        if (i4.isBlockComment && i4.isBlockComment(n3)) {
          const e4 = Ff(u4, s3(n3)) ? Ff(u4, o3(n3), { backwards: true }) ? Df : yf : " ";
          r4.push(e4);
        } else
          r4.push(Df);
        const a2 = Sf(u4, xf(u4, s3(n3)));
        return a2 !== false && Ff(u4, a2) && r4.push(Df), r4;
      }(e2, t2)) : u3 && s2.push(function(e3, t3) {
        const n3 = e3.getValue(), r4 = Rf(e3, t3), { printer: i4, originalText: u4, locStart: o3 } = t3, s3 = i4.isBlockComment && i4.isBlockComment(n3);
        if (Ff(u4, o3(n3), { backwards: true })) {
          const e4 = wf(u4, n3, o3);
          return bf([Df, e4 ? Df : "", r4]);
        }
        let a2 = [" ", r4];
        return s3 || (a2 = [bf(a2), Ef]), a2;
      }(e2, t2));
    }, "comments"), u2 && (o2.unshift(vf), s2.push(vf)), { leading: o2, trailing: s2 };
  }
  var Wf = { attach: function(e2, t2, n2, r2) {
    if (!Array.isArray(e2))
      return;
    const i2 = [], { locStart: u2, locEnd: o2, printer: { handleComments: s2 = {} } } = r2, { avoidAstMutation: a2, ownLine: c2 = If, endOfLine: l2 = If, remaining: p2 = If } = s2, f2 = e2.map((i3, u3) => Object.assign(Object.assign({}, Of(t2, i3, r2)), {}, { comment: i3, text: n2, options: r2, ast: t2, isLastComment: e2.length - 1 === u3 }));
    for (const [e3, t3] of f2.entries()) {
      const { comment: n3, precedingNode: r3, enclosingNode: s3, followingNode: d2, text: h2, options: g2, ast: m2, isLastComment: y2 } = t3;
      if (g2.parser === "json" || g2.parser === "json5" || g2.parser === "__js_expression" || g2.parser === "__vue_expression") {
        if (u2(n3) - u2(m2) <= 0) {
          Tf(m2, n3);
          continue;
        }
        if (o2(n3) - o2(m2) >= 0) {
          Nf(m2, n3);
          continue;
        }
      }
      let D2;
      if (a2 ? D2 = [t3] : (n3.enclosingNode = s3, n3.precedingNode = r3, n3.followingNode = d2, D2 = [n3, h2, g2, m2, y2]), jf(h2, g2, f2, e3))
        n3.placement = "ownLine", c2(...D2) || (d2 ? Tf(d2, n3) : r3 ? Nf(r3, n3) : Bf(s3 || m2, n3));
      else if (_f(h2, g2, f2, e3))
        n3.placement = "endOfLine", l2(...D2) || (r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3));
      else if (n3.placement = "remaining", p2(...D2))
        ;
      else if (r3 && d2) {
        const e4 = i2.length;
        if (e4 > 0) {
          i2[e4 - 1].followingNode !== d2 && Mf(i2, h2, g2);
        }
        i2.push(t3);
      } else
        r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3);
    }
    if (Mf(i2, n2, r2), !a2)
      for (const t3 of e2)
        delete t3.precedingNode, delete t3.enclosingNode, delete t3.followingNode;
  }, printComments: function(e2, t2, n2, r2) {
    const { leading: i2, trailing: u2 } = Vf(e2, n2, r2);
    return i2 || u2 ? [i2, t2, u2] : t2;
  }, printCommentsSeparately: Vf, printDanglingComments: function(e2, t2, n2, r2) {
    const i2 = [], u2 = e2.getValue();
    return u2 && u2.comments ? (e2.each(() => {
      const n3 = e2.getValue();
      n3.leading || n3.trailing || r2 && !r2(n3) || i2.push(Rf(e2, t2));
    }, "comments"), i2.length === 0 ? "" : n2 ? Af(Df, i2) : Cf([Df, Af(Df, i2)])) : "";
  }, getSortedChildNodes: Pf, ensureAllCommentsPrinted: function(e2) {
    if (e2)
      for (const t2 of e2) {
        if (!t2.printed)
          throw new Error('Comment "' + t2.value.trim() + '" was not printed. Please report this error!');
        delete t2.printed;
      }
  } };
  function qf(e2, t2) {
    const n2 = Uf(e2.stack, t2);
    return n2 === -1 ? null : e2.stack[n2];
  }
  function Uf(e2, t2) {
    for (let n2 = e2.length - 1; n2 >= 0; n2 -= 2) {
      const r2 = e2[n2];
      if (r2 && !Array.isArray(r2) && --t2 < 0)
        return n2;
    }
    return -1;
  }
  var zf = class {
    constructor(e2) {
      this.stack = [e2];
    }
    getName() {
      const { stack: e2 } = this, { length: t2 } = e2;
      return t2 > 1 ? e2[t2 - 2] : null;
    }
    getValue() {
      return Ln$2(this.stack);
    }
    getNode(e2 = 0) {
      return qf(this, e2);
    }
    getParentNode(e2 = 0) {
      return qf(this, e2 + 1);
    }
    call(e2, ...t2) {
      const { stack: n2 } = this, { length: r2 } = n2;
      let i2 = Ln$2(n2);
      for (const e3 of t2)
        i2 = i2[e3], n2.push(e3, i2);
      const u2 = e2(this);
      return n2.length = r2, u2;
    }
    callParent(e2, t2 = 0) {
      const n2 = Uf(this.stack, t2 + 1), r2 = this.stack.splice(n2 + 1), i2 = e2(this);
      return this.stack.push(...r2), i2;
    }
    each(e2, ...t2) {
      const { stack: n2 } = this, { length: r2 } = n2;
      let i2 = Ln$2(n2);
      for (const e3 of t2)
        i2 = i2[e3], n2.push(e3, i2);
      for (let t3 = 0; t3 < i2.length; ++t3)
        n2.push(t3, i2[t3]), e2(this, t3, i2), n2.length -= 2;
      n2.length = r2;
    }
    map(e2, ...t2) {
      const n2 = [];
      return this.each((t3, r2, i2) => {
        n2[r2] = e2(t3, r2, i2);
      }, ...t2), n2;
    }
    try(e2) {
      const { stack: t2 } = this, n2 = [...t2];
      try {
        return e2();
      } finally {
        t2.length = 0, t2.push(...n2);
      }
    }
    match(...e2) {
      let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
      for (const i2 of e2) {
        if (r2 === void 0)
          return false;
        let e3 = null;
        if (typeof n2 == "number" && (e3 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), i2 && !i2(r2, n2, e3))
          return false;
        n2 = this.stack[t2--], r2 = this.stack[t2--];
      }
      return true;
    }
    findAncestor(e2) {
      let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
      for (; r2; ) {
        let i2 = null;
        if (typeof n2 == "number" && (i2 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), n2 !== null && e2(r2, n2, i2))
          return r2;
        n2 = this.stack[t2--], r2 = this.stack[t2--];
      }
    }
  };
  const { utils: { stripTrailingHardline: Gf } } = eu$1, { normalize: Hf } = mp;
  var Jf = { printSubtree: function(e2, t2, n2, r2) {
    if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
      return n2.printer.embed(e2, t2, (e3, t3, i2) => function(e4, t4, n3, r3, { stripTrailingHardline: i3 = false } = {}) {
        const u2 = Hf(Object.assign(Object.assign(Object.assign({}, n3), t4), {}, { parentParser: n3.parser, originalText: e4 }), { passThrough: true }), o2 = lp.parse(e4, u2), { ast: s2 } = o2;
        e4 = o2.text;
        const a2 = s2.comments;
        delete s2.comments, Wf.attach(a2, s2, e4, u2), u2[Symbol.for("comments")] = a2 || [], u2[Symbol.for("tokens")] = s2.tokens || [];
        const c2 = r3(s2, u2);
        if (Wf.ensureAllCommentsPrinted(a2), i3)
          return typeof c2 == "string" ? c2.replace(/(?:\r?\n)*$/, "") : Gf(c2);
        return c2;
      }(e3, t3, n2, r2, i2), n2);
  } };
  const { builders: { hardline: Xf, addAlignmentToDoc: Yf }, utils: { propagateBreaks: Kf } } = eu$1, { printComments: Qf } = Wf;
  function Zf(e2, n2, r2 = 0) {
    const { printer: i2 } = n2;
    i2.preprocess && (e2 = i2.preprocess(e2, n2));
    const u2 = new Map(), o2 = new zf(e2);
    let s2 = a2();
    return r2 > 0 && (s2 = Yf([Xf, s2], r2, n2.tabWidth)), Kf(s2), s2;
    function a2(e3, t2) {
      return e3 === void 0 || e3 === o2 ? c2(t2) : Array.isArray(e3) ? o2.call(() => c2(t2), ...e3) : o2.call(() => c2(t2), e3);
    }
    function c2(e3) {
      const r3 = o2.getValue(), i3 = r3 && typeof r3 == "object" && e3 === void 0;
      if (i3 && u2.has(r3))
        return u2.get(r3);
      const s3 = function(e4, n3, r4, i4) {
        const u3 = e4.getValue(), { printer: o3 } = n3;
        let s4, a3;
        if (o3.hasPrettierIgnore && o3.hasPrettierIgnore(e4))
          ({ doc: s4, printedComments: a3 } = function(e5, t2) {
            const { originalText: n4, [Symbol.for("comments")]: r5, locStart: i5, locEnd: u4 } = t2, o4 = i5(e5), s5 = u4(e5), a4 = new Set();
            for (const e6 of r5)
              i5(e6) >= o4 && u4(e6) <= s5 && (e6.printed = true, a4.add(e6));
            return { doc: n4.slice(o4, s5), printedComments: a4 };
          }(u3, n3));
        else {
          if (u3)
            try {
              s4 = Jf.printSubtree(e4, r4, n3, Zf);
            } catch (e5) {
              if (t$3.PRETTIER_DEBUG)
                throw e5;
            }
          s4 || (s4 = o3.print(e4, n3, r4, i4));
        }
        o3.willPrintOwnComments && o3.willPrintOwnComments(e4, n3) || (s4 = Qf(e4, s4, n3, a3));
        return s4;
      }(o2, n2, a2, e3);
      return i3 && u2.set(r3, s3), s3;
    }
  }
  var ed = Zf;
  function td(e2) {
    let t2 = e2.length - 1;
    for (; ; ) {
      const n2 = e2[t2];
      if (!n2 || n2.type !== "Program" && n2.type !== "File")
        break;
      t2--;
    }
    return e2.slice(0, t2 + 1);
  }
  function nd(e2, t2, n2, r2, i2 = [], u2) {
    const { locStart: o2, locEnd: s2 } = n2, a2 = o2(e2), c2 = s2(e2);
    if (!(t2 > c2 || t2 < a2 || u2 === "rangeEnd" && t2 === a2 || u2 === "rangeStart" && t2 === c2)) {
      for (const o3 of Wf.getSortedChildNodes(e2, n2)) {
        const s3 = nd(o3, t2, n2, r2, [e2, ...i2], u2);
        if (s3)
          return s3;
      }
      return !r2 || r2(e2, i2[0]) ? { node: e2, parentNodes: i2 } : void 0;
    }
  }
  const rd = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), id = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
  function ud(e2, t2, n2) {
    if (!t2)
      return false;
    switch (e2.parser) {
      case "flow":
      case "babel":
      case "babel-flow":
      case "babel-ts":
      case "typescript":
      case "espree":
      case "meriyah":
      case "__babel_estree":
        return function(e3, t3) {
          return t3 !== "DeclareExportDeclaration" && e3 !== "TypeParameterDeclaration" && (e3 === "Directive" || e3 === "TypeAlias" || e3 === "TSExportAssignment" || e3.startsWith("Declare") || e3.startsWith("TSDeclare") || e3.endsWith("Statement") || e3.endsWith("Declaration"));
        }(t2.type, n2 && n2.type);
      case "json":
      case "json5":
      case "json-stringify":
        return rd.has(t2.type);
      case "graphql":
        return id.has(t2.kind);
      case "vue":
        return t2.tag !== "root";
    }
    return false;
  }
  var od = { calculateRange: function(e2, t2, n2) {
    let { rangeStart: r2, rangeEnd: i2, locStart: u2, locEnd: o2 } = t2;
    mf.ok(i2 > r2);
    const s2 = e2.slice(r2, i2).search(/\S/), a2 = s2 === -1;
    if (!a2)
      for (r2 += s2; i2 > r2 && !/\S/.test(e2[i2 - 1]); --i2)
        ;
    const c2 = nd(n2, r2, t2, (e3, n3) => ud(t2, e3, n3), [], "rangeStart"), l2 = a2 ? c2 : nd(n2, i2, t2, (e3) => ud(t2, e3), [], "rangeEnd");
    if (!c2 || !l2)
      return { rangeStart: 0, rangeEnd: 0 };
    let p2, f2;
    if ((({ parser: e3 }) => e3 === "json" || e3 === "json5" || e3 === "json-stringify")(t2)) {
      const e3 = function(e4, t3) {
        const n3 = [e4.node, ...e4.parentNodes], r3 = new Set([t3.node, ...t3.parentNodes]);
        return n3.find((e5) => rd.has(e5.type) && r3.has(e5));
      }(c2, l2);
      p2 = e3, f2 = e3;
    } else
      ({ startNode: p2, endNode: f2 } = function(e3, t3, { locStart: n3, locEnd: r3 }) {
        let i3 = e3.node, u3 = t3.node;
        if (i3 === u3)
          return { startNode: i3, endNode: u3 };
        const o3 = n3(e3.node);
        for (const e4 of td(t3.parentNodes)) {
          if (!(n3(e4) >= o3))
            break;
          u3 = e4;
        }
        const s3 = r3(t3.node);
        for (const t4 of td(e3.parentNodes)) {
          if (!(r3(t4) <= s3))
            break;
          i3 = t4;
        }
        return { startNode: i3, endNode: u3 };
      }(c2, l2, t2));
    return { rangeStart: Math.min(u2(p2), u2(f2)), rangeEnd: Math.max(o2(p2), o2(f2)) };
  }, findNodeAtOffset: nd };
  const { printer: { printDocToString: sd }, debug: { printDocToDebug: ad } } = eu$1, { getAlignmentSize: cd } = yi$2, { guessEndOfLine: ld, convertEndOfLineToChars: pd, countEndOfLineChars: fd, normalizeEndOfLine: dd } = Di$2, hd = mp.normalize, gd = Symbol("cursor");
  function md(e2, t2, n2) {
    const r2 = t2.comments;
    return r2 && (delete t2.comments, Wf.attach(r2, t2, e2, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t2.tokens || [], n2.originalText = e2, r2;
  }
  function yd(e2, t2, n2 = 0) {
    if (!e2 || e2.trim().length === 0)
      return { formatted: "", cursorOffset: -1, comments: [] };
    const { ast: r2, text: i2 } = lp.parse(e2, t2);
    if (t2.cursorOffset >= 0) {
      const e3 = od.findNodeAtOffset(r2, t2.cursorOffset, t2);
      e3 && e3.node && (t2.cursorNode = e3.node);
    }
    const u2 = md(i2, r2, t2), o2 = ed(r2, t2, n2), s2 = sd(o2, t2);
    if (Wf.ensureAllCommentsPrinted(u2), n2 > 0) {
      const e3 = s2.formatted.trim();
      s2.cursorNodeStart !== void 0 && (s2.cursorNodeStart -= s2.formatted.indexOf(e3)), s2.formatted = e3 + pd(t2.endOfLine);
    }
    if (t2.cursorOffset >= 0) {
      let e3, n3, r3, o3, a2;
      if (t2.cursorNode && s2.cursorNodeText ? (e3 = t2.locStart(t2.cursorNode), n3 = i2.slice(e3, t2.locEnd(t2.cursorNode)), r3 = t2.cursorOffset - e3, o3 = s2.cursorNodeStart, a2 = s2.cursorNodeText) : (e3 = 0, n3 = i2, r3 = t2.cursorOffset, o3 = 0, a2 = s2.formatted), n3 === a2)
        return { formatted: s2.formatted, cursorOffset: o3 + r3, comments: u2 };
      const c2 = [...n3];
      c2.splice(r3, 0, gd);
      const l2 = [...a2], p2 = mn$2.diffArrays(c2, l2);
      let f2 = o3;
      for (const e4 of p2)
        if (e4.removed) {
          if (e4.value.includes(gd))
            break;
        } else
          f2 += e4.count;
      return { formatted: s2.formatted, cursorOffset: f2, comments: u2 };
    }
    return { formatted: s2.formatted, cursorOffset: -1, comments: u2 };
  }
  function Dd(e2, t2, n2) {
    return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e2.length ? n2 : t2;
  }
  function Ed(e2, t2) {
    let { cursorOffset: n2, rangeStart: r2, rangeEnd: i2 } = t2;
    return n2 = Dd(e2, n2, -1), r2 = Dd(e2, r2, 0), i2 = Dd(e2, i2, e2.length), Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: i2 });
  }
  function Cd(e2, t2) {
    let { cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2 } = Ed(e2, t2);
    const o2 = e2.charAt(0) === "\uFEFF";
    if (o2 && (e2 = e2.slice(1), n2--, r2--, i2--), u2 === "auto" && (u2 = ld(e2)), e2.includes("\r")) {
      const t3 = (t4) => fd(e2.slice(0, Math.max(t4, 0)), "\r\n");
      n2 -= t3(n2), r2 -= t3(r2), i2 -= t3(i2), e2 = dd(e2);
    }
    return { hasBOM: o2, text: e2, options: Ed(e2, Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2 })) };
  }
  function bd(e2, t2) {
    const n2 = lp.resolveParser(t2);
    return !n2.hasPragma || n2.hasPragma(e2);
  }
  function Ad(e2, t2) {
    let n2, { hasBOM: r2, text: i2, options: u2 } = Cd(e2, hd(t2));
    return u2.rangeStart >= u2.rangeEnd && i2 !== "" || u2.requirePragma && !bd(i2, u2) ? { formatted: e2, cursorOffset: t2.cursorOffset, comments: [] } : (u2.rangeStart > 0 || u2.rangeEnd < i2.length ? n2 = function(e3, t3) {
      const { ast: n3, text: r3 } = lp.parse(e3, t3), { rangeStart: i3, rangeEnd: u3 } = od.calculateRange(r3, t3, n3), o2 = r3.slice(i3, u3), s2 = Math.min(i3, r3.lastIndexOf("\n", i3) + 1), a2 = r3.slice(s2, i3).match(/^\s*/)[0], c2 = cd(a2, t3.tabWidth), l2 = yd(o2, Object.assign(Object.assign({}, t3), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t3.cursorOffset > i3 && t3.cursorOffset <= u3 ? t3.cursorOffset - i3 : -1, endOfLine: "lf" }), c2), p2 = l2.formatted.trimEnd();
      let { cursorOffset: f2 } = t3;
      f2 > u3 ? f2 += p2.length - o2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + i3);
      let d2 = r3.slice(0, i3) + p2 + r3.slice(u3);
      if (t3.endOfLine !== "lf") {
        const e4 = pd(t3.endOfLine);
        f2 >= 0 && e4 === "\r\n" && (f2 += fd(d2.slice(0, f2), "\n")), d2 = d2.replace(/\n/g, e4);
      }
      return { formatted: d2, cursorOffset: f2, comments: l2.comments };
    }(i2, u2) : (!u2.requirePragma && u2.insertPragma && u2.printer.insertPragma && !bd(i2, u2) && (i2 = u2.printer.insertPragma(i2)), n2 = yd(i2, u2)), r2 && (n2.formatted = "\uFEFF" + n2.formatted, n2.cursorOffset >= 0 && n2.cursorOffset++), n2);
  }
  var vd = { formatWithCursor: Ad, parse(e2, t2, n2) {
    const { text: r2, options: i2 } = Cd(e2, hd(t2)), u2 = lp.parse(r2, i2);
    return n2 && (u2.ast = yp(u2.ast, i2)), u2;
  }, formatAST(e2, t2) {
    t2 = hd(t2);
    const n2 = ed(e2, t2);
    return sd(n2, t2);
  }, formatDoc: (e2, t2) => Ad(ad(e2), Object.assign(Object.assign({}, t2), {}, { parser: "__js_expression" })).formatted, printToDoc(e2, t2) {
    t2 = hd(t2);
    const { ast: n2, text: r2 } = lp.parse(e2, t2);
    return md(r2, n2, t2), ed(n2, t2);
  }, printDocToString: (e2, t2) => sd(e2, hd(t2)) };
  const { getMaxContinuousCount: Fd, getStringWidth: Sd, getAlignmentSize: xd, getIndentSize: wd, skip: Td, skipWhitespace: Bd, skipSpaces: Nd, skipNewline: kd, skipToLineEnd: Pd, skipEverythingButNewLine: Od, skipInlineComment: Id, skipTrailingComment: Ld, hasNewline: jd, hasNewlineInRange: _d, hasSpaces: Md, isNextLineEmpty: Rd, isNextLineEmptyAfterIndex: $d, isPreviousLineEmpty: Vd, getNextNonSpaceNonCommentCharacterIndex: Wd, makeString: qd, addLeadingComment: Ud, addDanglingComment: zd, addTrailingComment: Gd } = yi$2;
  var Hd = { getMaxContinuousCount: Fd, getStringWidth: Sd, getAlignmentSize: xd, getIndentSize: wd, skip: Td, skipWhitespace: Bd, skipSpaces: Nd, skipNewline: kd, skipToLineEnd: Pd, skipEverythingButNewLine: Od, skipInlineComment: Id, skipTrailingComment: Ld, hasNewline: jd, hasNewlineInRange: _d, hasSpaces: Md, isNextLineEmpty: Rd, isNextLineEmptyAfterIndex: $d, isPreviousLineEmpty: Vd, getNextNonSpaceNonCommentCharacterIndex: Wd, makeString: qd, addLeadingComment: Ud, addDanglingComment: zd, addTrailingComment: Gd };
  const Jd = ["languageId"];
  var Xd = function(e2, t2) {
    const { languageId: n2 } = e2, r2 = jn$2(e2, Jd);
    return Object.assign(Object.assign({ linguistLanguageId: n2 }, r2), t2(e2));
  }, Yd = r$3(function(e2) {
    !function() {
      function t2(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function n2(e3) {
        switch (e3.type) {
          case "IfStatement":
            return e3.alternate != null ? e3.alternate : e3.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return e3.body;
        }
        return null;
      }
      e2.exports = { isExpression: function(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }, isStatement: t2, isIterationStatement: function(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }, isSourceElement: function(e3) {
        return t2(e3) || e3 != null && e3.type === "FunctionDeclaration";
      }, isProblematicIfStatement: function(e3) {
        var t3;
        if (e3.type !== "IfStatement")
          return false;
        if (e3.alternate == null)
          return false;
        t3 = e3.consequent;
        do {
          if (t3.type === "IfStatement" && t3.alternate == null)
            return true;
          t3 = n2(t3);
        } while (t3);
        return false;
      }, trailingStatement: n2 };
    }();
  }), Kd = r$3(function(e2) {
    !function() {
      var t2, n2, r2, i2, u2, o2;
      function s2(e3) {
        return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode(Math.floor((e3 - 65536) / 1024) + 55296) + String.fromCharCode((e3 - 65536) % 1024 + 56320);
      }
      for (n2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), o2 = 0; o2 < 128; ++o2)
        i2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 === 36 || o2 === 95;
      for (u2 = new Array(128), o2 = 0; o2 < 128; ++o2)
        u2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 >= 48 && o2 <= 57 || o2 === 36 || o2 === 95;
      e2.exports = { isDecimalDigit: function(e3) {
        return 48 <= e3 && e3 <= 57;
      }, isHexDigit: function(e3) {
        return 48 <= e3 && e3 <= 57 || 97 <= e3 && e3 <= 102 || 65 <= e3 && e3 <= 70;
      }, isOctalDigit: function(e3) {
        return e3 >= 48 && e3 <= 55;
      }, isWhiteSpace: function(e3) {
        return e3 === 32 || e3 === 9 || e3 === 11 || e3 === 12 || e3 === 160 || e3 >= 5760 && r2.indexOf(e3) >= 0;
      }, isLineTerminator: function(e3) {
        return e3 === 10 || e3 === 13 || e3 === 8232 || e3 === 8233;
      }, isIdentifierStartES5: function(e3) {
        return e3 < 128 ? i2[e3] : n2.NonAsciiIdentifierStart.test(s2(e3));
      }, isIdentifierPartES5: function(e3) {
        return e3 < 128 ? u2[e3] : n2.NonAsciiIdentifierPart.test(s2(e3));
      }, isIdentifierStartES6: function(e3) {
        return e3 < 128 ? i2[e3] : t2.NonAsciiIdentifierStart.test(s2(e3));
      }, isIdentifierPartES6: function(e3) {
        return e3 < 128 ? u2[e3] : t2.NonAsciiIdentifierPart.test(s2(e3));
      } };
    }();
  }), Qd = r$3(function(e2) {
    !function() {
      var t2 = Kd;
      function n2(e3, t3) {
        return !(!t3 && e3 === "yield") && r2(e3, t3);
      }
      function r2(e3, t3) {
        if (t3 && function(e4) {
          switch (e4) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "let":
              return true;
            default:
              return false;
          }
        }(e3))
          return true;
        switch (e3.length) {
          case 2:
            return e3 === "if" || e3 === "in" || e3 === "do";
          case 3:
            return e3 === "var" || e3 === "for" || e3 === "new" || e3 === "try";
          case 4:
            return e3 === "this" || e3 === "else" || e3 === "case" || e3 === "void" || e3 === "with" || e3 === "enum";
          case 5:
            return e3 === "while" || e3 === "break" || e3 === "catch" || e3 === "throw" || e3 === "const" || e3 === "yield" || e3 === "class" || e3 === "super";
          case 6:
            return e3 === "return" || e3 === "typeof" || e3 === "delete" || e3 === "switch" || e3 === "export" || e3 === "import";
          case 7:
            return e3 === "default" || e3 === "finally" || e3 === "extends";
          case 8:
            return e3 === "function" || e3 === "continue" || e3 === "debugger";
          case 10:
            return e3 === "instanceof";
          default:
            return false;
        }
      }
      function i2(e3, t3) {
        return e3 === "null" || e3 === "true" || e3 === "false" || n2(e3, t3);
      }
      function u2(e3, t3) {
        return e3 === "null" || e3 === "true" || e3 === "false" || r2(e3, t3);
      }
      function o2(e3) {
        var n3, r3, i3;
        if (e3.length === 0)
          return false;
        if (i3 = e3.charCodeAt(0), !t2.isIdentifierStartES5(i3))
          return false;
        for (n3 = 1, r3 = e3.length; n3 < r3; ++n3)
          if (i3 = e3.charCodeAt(n3), !t2.isIdentifierPartES5(i3))
            return false;
        return true;
      }
      function s2(e3) {
        var n3, r3, i3, u3, o3;
        if (e3.length === 0)
          return false;
        for (o3 = t2.isIdentifierStartES6, n3 = 0, r3 = e3.length; n3 < r3; ++n3) {
          if (55296 <= (i3 = e3.charCodeAt(n3)) && i3 <= 56319) {
            if (++n3 >= r3)
              return false;
            if (!(56320 <= (u3 = e3.charCodeAt(n3)) && u3 <= 57343))
              return false;
            i3 = 1024 * (i3 - 55296) + (u3 - 56320) + 65536;
          }
          if (!o3(i3))
            return false;
          o3 = t2.isIdentifierPartES6;
        }
        return true;
      }
      e2.exports = { isKeywordES5: n2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: u2, isRestrictedWord: function(e3) {
        return e3 === "eval" || e3 === "arguments";
      }, isIdentifierNameES5: o2, isIdentifierNameES6: s2, isIdentifierES5: function(e3, t3) {
        return o2(e3) && !i2(e3, t3);
      }, isIdentifierES6: function(e3, t3) {
        return s2(e3) && !u2(e3, t3);
      } };
    }();
  });
  const Zd = r$3(function(e2, t2) {
    t2.ast = Yd, t2.code = Kd, t2.keyword = Qd;
  }).keyword.isIdentifierNameES5, { getLast: eh, hasNewline: th, skipWhitespace: nh, isNonEmptyArray: rh, isNextLineEmptyAfterIndex: ih, getStringWidth: uh } = yi$2, { locStart: oh, locEnd: sh, hasSameLocStart: ah } = zc, ch = new RegExp("^(?:(?=.)\\s)*:"), lh = new RegExp("^(?:(?=.)\\s)*::");
  function ph(e2) {
    return e2.type === "Block" || e2.type === "CommentBlock" || e2.type === "MultiLine";
  }
  function fh(e2) {
    return e2.type === "Line" || e2.type === "CommentLine" || e2.type === "SingleLine" || e2.type === "HashbangComment" || e2.type === "HTMLOpen" || e2.type === "HTMLClose";
  }
  const dh = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
  function hh(e2) {
    return e2 && dh.has(e2.type);
  }
  function gh(e2) {
    return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
  }
  function mh(e2) {
    return e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string";
  }
  function yh(e2) {
    return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression";
  }
  function Dh(e2) {
    return Sh(e2) && e2.callee.type === "Identifier" && (e2.callee.name === "async" || e2.callee.name === "inject" || e2.callee.name === "fakeAsync");
  }
  function Eh(e2) {
    return e2.type === "JSXElement" || e2.type === "JSXFragment";
  }
  function Ch(e2) {
    return e2.kind === "get" || e2.kind === "set";
  }
  function bh(e2) {
    return Ch(e2) || ah(e2, e2.value);
  }
  const Ah = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
  const vh = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
  const Fh = /^(?:skip|[fx]?(?:it|describe|test))$/;
  function Sh(e2) {
    return e2 && (e2.type === "CallExpression" || e2.type === "OptionalCallExpression");
  }
  function xh(e2) {
    return e2 && (e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression");
  }
  function wh(e2) {
    return /^(?:\d+|\d+\.\d+)$/.test(e2);
  }
  function Th(e2) {
    return e2.quasis.some((e3) => e3.value.raw.includes("\n"));
  }
  function Bh(e2) {
    return e2.extra ? e2.extra.raw : e2.raw;
  }
  const Nh = { "==": true, "!=": true, "===": true, "!==": true }, kh = { "*": true, "/": true, "%": true }, Ph = { ">>": true, ">>>": true, "<<": true };
  const Oh = {};
  for (const [e2, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
    for (const n2 of t2)
      Oh[n2] = e2;
  function Ih(e2) {
    return Oh[e2];
  }
  const Lh = new WeakMap();
  function jh(e2) {
    if (Lh.has(e2))
      return Lh.get(e2);
    const t2 = [];
    return e2.this && t2.push(e2.this), Array.isArray(e2.parameters) ? t2.push(...e2.parameters) : Array.isArray(e2.params) && t2.push(...e2.params), e2.rest && t2.push(e2.rest), Lh.set(e2, t2), t2;
  }
  const _h = new WeakMap();
  function Mh(e2) {
    if (_h.has(e2))
      return _h.get(e2);
    let t2 = e2.arguments;
    return e2.type === "ImportExpression" && (t2 = [e2.source], e2.attributes && t2.push(e2.attributes)), _h.set(e2, t2), t2;
  }
  function Rh(e2) {
    return e2.value.trim() === "prettier-ignore" && !e2.unignore;
  }
  function $h(e2) {
    return e2 && (e2.prettierIgnore || qh(e2, Vh.PrettierIgnore));
  }
  const Vh = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Wh = (e2, t2) => {
    if (typeof e2 == "function" && (t2 = e2, e2 = 0), e2 || t2)
      return (n2, r2, i2) => !(e2 & Vh.Leading && !n2.leading || e2 & Vh.Trailing && !n2.trailing || e2 & Vh.Dangling && (n2.leading || n2.trailing) || e2 & Vh.Block && !ph(n2) || e2 & Vh.Line && !fh(n2) || e2 & Vh.First && r2 !== 0 || e2 & Vh.Last && r2 !== i2.length - 1 || e2 & Vh.PrettierIgnore && !Rh(n2) || t2 && !t2(n2));
  };
  function qh(e2, t2, n2) {
    if (!e2 || !rh(e2.comments))
      return false;
    const r2 = Wh(t2, n2);
    return !r2 || e2.comments.some(r2);
  }
  function Uh(e2, t2, n2) {
    if (!e2 || !Array.isArray(e2.comments))
      return [];
    const r2 = Wh(t2, n2);
    return r2 ? e2.comments.filter(r2) : e2.comments;
  }
  function zh(e2) {
    return Sh(e2) || e2.type === "NewExpression" || e2.type === "ImportExpression";
  }
  var Gh = { getFunctionParameters: jh, iterateFunctionParametersPath: function(e2, t2) {
    const n2 = e2.getValue();
    let r2 = 0;
    const i2 = (e3) => t2(e3, r2++);
    n2.this && e2.call(i2, "this"), Array.isArray(n2.parameters) ? e2.each(i2, "parameters") : Array.isArray(n2.params) && e2.each(i2, "params"), n2.rest && e2.call(i2, "rest");
  }, getCallArguments: Mh, iterateCallArgumentsPath: function(e2, t2) {
    const n2 = e2.getValue();
    n2.type === "ImportExpression" ? (e2.call((e3) => t2(e3, 0), "source"), n2.attributes && e2.call((e3) => t2(e3, 1), "attributes")) : e2.each(t2, "arguments");
  }, hasRestParameter: function(e2) {
    if (e2.rest)
      return true;
    const t2 = jh(e2);
    return t2.length > 0 && eh(t2).type === "RestElement";
  }, getLeftSide: function(e2) {
    return e2.expressions ? e2.expressions[0] : e2.left || e2.test || e2.callee || e2.object || e2.tag || e2.argument || e2.expression;
  }, getLeftSidePathName: function(e2, t2) {
    if (t2.expressions)
      return ["expressions", 0];
    if (t2.left)
      return ["left"];
    if (t2.test)
      return ["test"];
    if (t2.object)
      return ["object"];
    if (t2.callee)
      return ["callee"];
    if (t2.tag)
      return ["tag"];
    if (t2.argument)
      return ["argument"];
    if (t2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  }, getParentExportDeclaration: function(e2) {
    const t2 = e2.getParentNode();
    return e2.getName() === "declaration" && hh(t2) ? t2 : null;
  }, getTypeScriptMappedTypeModifier: function(e2, t2) {
    return e2 === "+" ? "+" + t2 : e2 === "-" ? "-" + t2 : t2;
  }, hasFlowAnnotationComment: function(e2) {
    return rh(e2) && ph(e2[0]) && lh.test(e2[0].value);
  }, hasFlowShorthandAnnotationComment: function(e2) {
    return e2.extra && e2.extra.parenthesized && rh(e2.trailingComments) && ph(e2.trailingComments[0]) && ch.test(e2.trailingComments[0].value);
  }, hasLeadingOwnLineComment: function(e2, t2) {
    return Eh(t2) ? $h(t2) : qh(t2, Vh.Leading, (t3) => th(e2, sh(t3)));
  }, hasNakedLeftSide: function(e2) {
    return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || Sh(e2) || xh(e2) || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || e2.type === "TSAsExpression" || e2.type === "TSNonNullExpression";
  }, hasNode: function e2(t2, n2) {
    if (!t2 || typeof t2 != "object")
      return false;
    if (Array.isArray(t2))
      return t2.some((t3) => e2(t3, n2));
    const r2 = n2(t2);
    return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e2(t3, n2));
  }, hasIgnoreComment: function(e2) {
    return $h(e2.getValue());
  }, hasNodeIgnoreComment: $h, identity: function(e2) {
    return e2;
  }, isBinaryish: function(e2) {
    return Ah.has(e2.type);
  }, isBlockComment: ph, isCallLikeExpression: zh, isLineComment: fh, isPrettierIgnoreComment: Rh, isCallExpression: Sh, isMemberExpression: xh, isExportDeclaration: hh, isFlowAnnotationComment: function(e2, t2) {
    const n2 = oh(t2), r2 = nh(e2, sh(t2));
    return r2 !== false && e2.slice(n2, n2 + 2) === "/*" && e2.slice(r2, r2 + 2) === "*/";
  }, isFunctionCompositionArgs: function(e2) {
    if (e2.length <= 1)
      return false;
    let t2 = 0;
    for (const n2 of e2)
      if (yh(n2)) {
        if (t2 += 1, t2 > 1)
          return true;
      } else if (Sh(n2)) {
        for (const e3 of n2.arguments)
          if (yh(e3))
            return true;
      }
    return false;
  }, isFunctionNotation: bh, isFunctionOrArrowExpression: yh, isGetterOrSetter: Ch, isJestEachTemplateLiteral: function(e2, t2) {
    const n2 = /^[fx]?(?:describe|it|test)$/;
    return t2.type === "TaggedTemplateExpression" && t2.quasi === e2 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && n2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && n2.test(t2.tag.object.object.name));
  }, isJsxNode: Eh, isLiteral: function(e2) {
    return e2.type === "BooleanLiteral" || e2.type === "DirectiveLiteral" || e2.type === "Literal" || e2.type === "NullLiteral" || e2.type === "NumericLiteral" || e2.type === "BigIntLiteral" || e2.type === "DecimalLiteral" || e2.type === "RegExpLiteral" || e2.type === "StringLiteral" || e2.type === "TemplateLiteral" || e2.type === "TSTypeLiteral" || e2.type === "JSXText";
  }, isLongCurriedCallExpression: function(e2) {
    const t2 = e2.getValue(), n2 = e2.getParentNode();
    return Sh(t2) && Sh(n2) && n2.callee === t2 && t2.arguments.length > n2.arguments.length && n2.arguments.length > 0;
  }, isSimpleCallArgument: function e2(t2, n2) {
    if (n2 >= 2)
      return false;
    const r2 = (t3) => e2(t3, n2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
    return !(i2 && uh(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e3) => !e3.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e3) => !e3.computed && (e3.shorthand || e3.value && r2(e3.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e3) => e3 === null || r2(e3)) : zh(t2) ? (t2.type === "ImportExpression" || e2(t2.callee, n2)) && Mh(t2).every(r2) : xh(t2) ? e2(t2.object, n2) && e2(t2.property, n2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e2(t2.expression, n2) : e2(t2.argument, n2)));
  }, isMemberish: function(e2) {
    return xh(e2) || e2.type === "BindExpression" && Boolean(e2.object);
  }, isNumericLiteral: gh, isSignedNumericLiteral: function(e2) {
    return e2.type === "UnaryExpression" && (e2.operator === "+" || e2.operator === "-") && gh(e2.argument);
  }, isObjectProperty: function(e2) {
    return e2 && (e2.type === "ObjectProperty" || e2.type === "Property" && !e2.method && e2.kind === "init");
  }, isObjectType: function(e2) {
    return e2.type === "ObjectTypeAnnotation" || e2.type === "TSTypeLiteral" || e2.type === "TSMappedType";
  }, isObjectTypePropertyAFunction: function(e2) {
    return !(e2.type !== "ObjectTypeProperty" && e2.type !== "ObjectTypeInternalSlot" || e2.value.type !== "FunctionTypeAnnotation" || e2.static || bh(e2));
  }, isSimpleType: function(e2) {
    return !!e2 && (!(e2.type !== "GenericTypeAnnotation" && e2.type !== "TSTypeReference" || e2.typeParameters) || !!vh.has(e2.type));
  }, isSimpleNumber: wh, isSimpleTemplateLiteral: function(e2) {
    let t2 = "expressions";
    e2.type === "TSTemplateLiteralType" && (t2 = "types");
    const n2 = e2[t2];
    return n2.length !== 0 && n2.every((e3) => {
      if (qh(e3))
        return false;
      if (e3.type === "Identifier" || e3.type === "ThisExpression")
        return true;
      if (xh(e3)) {
        let t3 = e3;
        for (; xh(t3); ) {
          if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
            return false;
          if (t3 = t3.object, qh(t3))
            return false;
        }
        return t3.type === "Identifier" || t3.type === "ThisExpression";
      }
      return false;
    });
  }, isStringLiteral: mh, isStringPropSafeToUnquote: function(e2, t2) {
    return t2.parser !== "json" && mh(e2.key) && Bh(e2.key).slice(1, -1) === e2.key.value && (Zd(e2.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e2.type === "ClassProperty") || wh(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
  }, isTemplateOnItsOwnLine: function(e2, t2) {
    return (e2.type === "TemplateLiteral" && Th(e2) || e2.type === "TaggedTemplateExpression" && Th(e2.quasi)) && !th(t2, oh(e2), { backwards: true });
  }, isTestCall: function e2(t2, n2) {
    if (t2.type !== "CallExpression")
      return false;
    if (t2.arguments.length === 1) {
      if (Dh(t2) && n2 && e2(n2))
        return yh(t2.arguments[0]);
      if (function(e3) {
        return e3.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e3.callee.name) && e3.arguments.length === 1;
      }(t2))
        return Dh(t2.arguments[0]);
    } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Fh.test(t2.callee.name) || function(e3) {
      return xh(e3.callee) && e3.callee.object.type === "Identifier" && e3.callee.property.type === "Identifier" && Fh.test(e3.callee.object.name) && (e3.callee.property.name === "only" || e3.callee.property.name === "skip");
    }(t2)) && (function(e3) {
      return e3.type === "TemplateLiteral";
    }(t2.arguments[0]) || mh(t2.arguments[0])))
      return !(t2.arguments[2] && !gh(t2.arguments[2])) && ((t2.arguments.length === 2 ? yh(t2.arguments[1]) : function(e3) {
        return e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression" && e3.body.type === "BlockStatement";
      }(t2.arguments[1]) && jh(t2.arguments[1]).length <= 1) || Dh(t2.arguments[1]));
    return false;
  }, isTheOnlyJsxElementInMarkdown: function(e2, t2) {
    if (e2.parentParser !== "markdown" && e2.parentParser !== "mdx")
      return false;
    const n2 = t2.getNode();
    if (!n2.expression || !Eh(n2.expression))
      return false;
    const r2 = t2.getParentNode();
    return r2.type === "Program" && r2.body.length === 1;
  }, isTSXFile: function(e2) {
    return e2.filepath && /\.tsx$/i.test(e2.filepath);
  }, isTypeAnnotationAFunction: function(e2) {
    return !(e2.type !== "TypeAnnotation" && e2.type !== "TSTypeAnnotation" || e2.typeAnnotation.type !== "FunctionTypeAnnotation" || e2.static || ah(e2, e2.typeAnnotation));
  }, isNextLineEmpty: (e2, { originalText: t2 }) => ih(t2, sh(e2)), needsHardlineAfterDanglingComment: function(e2) {
    if (!qh(e2))
      return false;
    const t2 = eh(Uh(e2, Vh.Dangling));
    return t2 && !ph(t2);
  }, rawText: Bh, shouldPrintComma: function(e2, t2 = "es5") {
    return e2.trailingComma === "es5" && t2 === "es5" || e2.trailingComma === "all" && (t2 === "all" || t2 === "es5");
  }, isBitwiseOperator: function(e2) {
    return Boolean(Ph[e2]) || e2 === "|" || e2 === "^" || e2 === "&";
  }, shouldFlatten: function(e2, t2) {
    return Ih(t2) === Ih(e2) && (e2 !== "**" && ((!Nh[e2] || !Nh[t2]) && (!(t2 === "%" && kh[e2] || e2 === "%" && kh[t2]) && ((t2 === e2 || !kh[t2] || !kh[e2]) && (!Ph[e2] || !Ph[t2])))));
  }, startsWithNoLookaheadToken: function e2(t2, n2) {
    switch ((t2 = function(e3) {
      for (; e3.left; )
        e3 = e3.left;
      return e3;
    }(t2)).type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return n2;
      case "ObjectExpression":
        return true;
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e2(t2.object, n2);
      case "TaggedTemplateExpression":
        return t2.tag.type !== "FunctionExpression" && e2(t2.tag, n2);
      case "CallExpression":
      case "OptionalCallExpression":
        return t2.callee.type !== "FunctionExpression" && e2(t2.callee, n2);
      case "ConditionalExpression":
        return e2(t2.test, n2);
      case "UpdateExpression":
        return !t2.prefix && e2(t2.argument, n2);
      case "BindExpression":
        return t2.object && e2(t2.object, n2);
      case "SequenceExpression":
        return e2(t2.expressions[0], n2);
      case "TSAsExpression":
      case "TSNonNullExpression":
        return e2(t2.expression, n2);
      default:
        return false;
    }
  }, getPrecedence: Ih, hasComment: qh, getComments: Uh, CommentCheckFlags: Vh };
  const { getStringWidth: Hh, getIndentSize: Jh } = yi$2, { builders: { join: Xh, hardline: Yh, softline: Kh, group: Qh, indent: Zh, align: eg, lineSuffixBoundary: tg, addAlignmentToDoc: ng }, printer: { printDocToString: rg }, utils: { mapDoc: ig } } = eu$1, { isBinaryish: ug, isJestEachTemplateLiteral: og, isSimpleTemplateLiteral: sg, hasComment: ag, isMemberExpression: cg } = Gh;
  function lg(e2) {
    return e2.replace(/([\\`]|\${)/g, "\\$1");
  }
  var pg = { printTemplateLiteral: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (r2.type === "TemplateLiteral" && og(r2, e2.getParentNode())) {
      const r3 = function(e3, t3, n3) {
        const r4 = e3.getNode(), i3 = r4.quasis[0].value.raw.trim().split(/\s*\|\s*/);
        if (i3.length > 1 || i3.some((e4) => e4.length > 0)) {
          t3.__inJestEach = true;
          const u3 = e3.map(n3, "expressions");
          t3.__inJestEach = false;
          const o3 = [], s3 = u3.map((e4) => "${" + rg(e4, Object.assign(Object.assign({}, t3), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), a2 = [{ hasLineBreak: false, cells: [] }];
          for (let e4 = 1; e4 < r4.quasis.length; e4++) {
            const t4 = Ln$2(a2), n4 = s3[e4 - 1];
            t4.cells.push(n4), n4.includes("\n") && (t4.hasLineBreak = true), r4.quasis[e4].value.raw.includes("\n") && a2.push({ hasLineBreak: false, cells: [] });
          }
          const c2 = Math.max(i3.length, ...a2.map((e4) => e4.cells.length)), l2 = Array.from({ length: c2 }).fill(0), p2 = [{ cells: i3 }, ...a2.filter((e4) => e4.cells.length > 0)];
          for (const { cells: e4 } of p2.filter((e5) => !e5.hasLineBreak))
            for (const [t4, n4] of e4.entries())
              l2[t4] = Math.max(l2[t4], Hh(n4));
          return o3.push(tg, "`", Zh([Yh, Xh(Yh, p2.map((e4) => Xh(" | ", e4.cells.map((t4, n4) => e4.hasLineBreak ? t4 : t4 + " ".repeat(l2[n4] - Hh(t4))))))]), Yh, "`"), o3;
        }
      }(e2, n2, t2);
      if (r3)
        return r3;
    }
    let i2 = "expressions";
    r2.type === "TSTemplateLiteralType" && (i2 = "types");
    const u2 = [];
    let o2 = e2.map(t2, i2);
    const s2 = sg(r2);
    return s2 && (o2 = o2.map((e3) => rg(e3, Object.assign(Object.assign({}, n2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), u2.push(tg, "`"), e2.each((e3) => {
      const a2 = e3.getName();
      if (u2.push(t2()), a2 < o2.length) {
        const { tabWidth: t3 } = n2, c2 = e3.getValue(), l2 = Jh(c2.value.raw, t3);
        let p2 = o2[a2];
        if (!s2) {
          const e4 = r2[i2][a2];
          (ag(e4) || cg(e4) || e4.type === "ConditionalExpression" || e4.type === "SequenceExpression" || e4.type === "TSAsExpression" || ug(e4)) && (p2 = [Zh([Kh, p2]), Kh]);
        }
        const f2 = l2 === 0 && c2.value.raw.endsWith("\n") ? eg(Number.NEGATIVE_INFINITY, p2) : ng(p2, l2, t3);
        u2.push(Qh(["${", f2, tg, "}"]));
      }
    }, "quasis"), u2.push("`"), u2;
  }, printTemplateExpressions: function(e2, t2) {
    return e2.map((e3) => function(e4, t3) {
      const n2 = e4.getValue();
      let r2 = t3();
      return ag(n2) && (r2 = Qh([Zh([Kh, r2]), Kh])), ["${", r2, tg, "}"];
    }(e3, t2), "expressions");
  }, escapeTemplateCharacters: function(e2, t2) {
    return ig(e2, (e3) => typeof e3 == "string" ? t2 ? e3.replace(/(\\*)`/g, "$1$1\\`") : lg(e3) : e3);
  }, uncookTemplateElementValue: lg };
  const { builders: { indent: fg, softline: dg, literalline: hg, dedentToRoot: gg } } = eu$1, { escapeTemplateCharacters: mg } = pg;
  var yg = function(e2, t2, n2) {
    let r2 = e2.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e3, t3) => "\\".repeat(t3.length / 2) + "`");
    const i2 = function(e3) {
      const t3 = e3.match(/^([^\S\n]*)\S/m);
      return t3 === null ? "" : t3[1];
    }(r2), u2 = i2 !== "";
    u2 && (r2 = r2.replace(new RegExp(`^${i2}`, "gm"), ""));
    const o2 = mg(n2(r2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
    return ["`", u2 ? fg([dg, o2]) : [hg, gg(o2)], dg, "`"];
  };
  const { isNonEmptyArray: Dg } = yi$2, { builders: { indent: Eg, hardline: Cg, softline: bg }, utils: { mapDoc: Ag, replaceEndOfLine: vg, cleanDoc: Fg } } = eu$1, { printTemplateExpressions: Sg } = pg;
  var xg = function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.quasis.map((e3) => e3.value.raw);
    let u2 = 0;
    return function(e3, t3, n3) {
      if (t3.quasis.length === 1 && !t3.quasis[0].value.raw.trim())
        return "``";
      const r3 = function(e4, t4) {
        if (!Dg(t4))
          return e4;
        let n4 = 0;
        const r4 = Ag(Fg(e4), (e5) => typeof e5 == "string" && e5.includes("@prettier-placeholder") ? e5.split(/@prettier-placeholder-(\d+)-id/).map((e6, r5) => r5 % 2 == 0 ? vg(e6) : (n4++, t4[e6])) : e5);
        return t4.length === n4 ? r4 : null;
      }(e3, n3);
      if (!r3)
        throw new Error("Couldn't insert all the expressions");
      return ["`", Eg([Cg, r3]), bg, "`"];
    }(n2(i2.reduce((e3, t3, n3) => n3 === 0 ? t3 : e3 + "@prettier-placeholder-" + u2++ + "-id" + t3, ""), { parser: "scss" }, { stripTrailingHardline: true }), r2, Sg(e2, t2));
  };
  const { builders: { indent: wg, join: Tg, hardline: Bg } } = eu$1, { escapeTemplateCharacters: Ng, printTemplateExpressions: kg } = pg;
  function Pg(e2) {
    const t2 = [];
    let n2 = false;
    const r2 = e2.map((e3) => e3.trim());
    for (const [e3, i2] of r2.entries())
      i2 !== "" && (r2[e3 - 1] === "" && n2 ? t2.push([Bg, i2]) : t2.push(i2), n2 = true);
    return t2.length === 0 ? null : Tg(Bg, t2);
  }
  var Og = function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.quasis.length;
    if (i2 === 1 && r2.quasis[0].value.raw.trim() === "")
      return "``";
    const u2 = kg(e2, t2), o2 = [];
    for (let e3 = 0; e3 < i2; e3++) {
      const t3 = e3 === 0, s2 = e3 === i2 - 1, a2 = r2.quasis[e3].value.cooked, c2 = a2.split("\n"), l2 = c2.length, p2 = u2[e3], f2 = l2 > 2 && c2[0].trim() === "" && c2[1].trim() === "", d2 = l2 > 2 && c2[l2 - 1].trim() === "" && c2[l2 - 2].trim() === "", h2 = c2.every((e4) => /^\s*(?:#[^\n\r]*)?$/.test(e4));
      if (!s2 && /#[^\n\r]*$/.test(c2[l2 - 1]))
        return null;
      let g2 = null;
      g2 = h2 ? Pg(c2) : n2(a2, { parser: "graphql" }, { stripTrailingHardline: true }), g2 ? (g2 = Ng(g2, false), !t3 && f2 && o2.push(""), o2.push(g2), !s2 && d2 && o2.push("")) : t3 || s2 || !f2 || o2.push(""), p2 && o2.push(p2);
    }
    return ["`", wg([Bg, Tg(Bg, o2)]), Bg, "`"];
  };
  const { builders: { indent: Ig, line: Lg, hardline: jg, group: _g }, utils: { mapDoc: Mg } } = eu$1, { printTemplateExpressions: Rg, uncookTemplateElementValue: $g } = pg;
  let Vg = 0;
  var Wg = function(e2, t2, n2, r2, { parser: i2 }) {
    const u2 = e2.getValue(), o2 = Vg;
    Vg = Vg + 1 >>> 0;
    const s2 = (e3) => `PRETTIER_HTML_PLACEHOLDER_${e3}_${o2}_IN_JS`, a2 = u2.quasis.map((e3, t3, n3) => t3 === n3.length - 1 ? e3.value.cooked : e3.value.cooked + s2(t3)).join(""), c2 = Rg(e2, t2);
    if (c2.length === 0 && a2.trim().length === 0)
      return "``";
    const l2 = new RegExp(s2("(\\d+)"), "g");
    let p2 = 0;
    const f2 = n2(a2, { parser: i2, __onHtmlRoot(e3) {
      p2 = e3.children.length;
    } }, { stripTrailingHardline: true }), d2 = Mg(f2, (e3) => {
      if (typeof e3 != "string")
        return e3;
      const t3 = [], n3 = e3.split(l2);
      for (let e4 = 0; e4 < n3.length; e4++) {
        let i3 = n3[e4];
        if (e4 % 2 == 0) {
          i3 && (i3 = $g(i3), r2.__embeddedInHtml && (i3 = i3.replace(/<\/(script)\b/gi, "<\\/$1")), t3.push(i3));
          continue;
        }
        const u3 = Number(i3);
        t3.push(c2[u3]);
      }
      return t3;
    }), h2 = /^\s/.test(a2) ? " " : "", g2 = /\s$/.test(a2) ? " " : "", m2 = r2.htmlWhitespaceSensitivity === "ignore" ? jg : h2 && g2 ? Lg : null;
    return _g(m2 ? ["`", Ig([m2, _g(d2)]), m2, "`"] : ["`", h2, p2 > 1 ? Ig(_g(d2)) : _g(d2), g2, "`"]);
  };
  const { hasComment: qg, CommentCheckFlags: Ug, isObjectProperty: zg } = Gh;
  function Gg(e2) {
    return function(e3) {
      const t2 = e3.getValue(), n2 = e3.getParentNode(), r2 = e3.getParentNode(1);
      return r2 && t2.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e4) => e4.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
    }(e2) || function(e3) {
      const t2 = e3.getParentNode();
      if (!t2 || t2.type !== "TaggedTemplateExpression")
        return false;
      const n2 = t2.tag.type === "ParenthesizedExpression" ? t2.tag.expression : t2.tag;
      switch (n2.type) {
        case "MemberExpression":
          return Jg(n2.object) || Xg(n2);
        case "CallExpression":
          return Jg(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (Jg(n2.callee.object.object) || Xg(n2.callee.object)) || n2.callee.object.type === "CallExpression" && Jg(n2.callee.object.callee));
        case "Identifier":
          return n2.name === "css";
        default:
          return false;
      }
    }(e2) || function(e3) {
      const t2 = e3.getParentNode(), n2 = e3.getParentNode(1);
      return n2 && t2.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
    }(e2) || function(e3) {
      return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => e4.type === "ArrayExpression" && t2 === "elements", (e4, t2) => zg(e4) && e4.key.type === "Identifier" && e4.key.name === "styles" && t2 === "value", ...Hg);
    }(e2) ? "css" : function(e3) {
      const t2 = e3.getValue(), n2 = e3.getParentNode();
      return Yg(t2, "GraphQL") || n2 && (n2.type === "TaggedTemplateExpression" && (n2.tag.type === "MemberExpression" && n2.tag.object.name === "graphql" && n2.tag.property.name === "experimental" || n2.tag.type === "Identifier" && (n2.tag.name === "gql" || n2.tag.name === "graphql")) || n2.type === "CallExpression" && n2.callee.type === "Identifier" && n2.callee.name === "graphql");
    }(e2) ? "graphql" : function(e3) {
      return Yg(e3.getValue(), "HTML") || e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => e4.type === "TaggedTemplateExpression" && e4.tag.type === "Identifier" && e4.tag.name === "html" && t2 === "quasi");
    }(e2) ? "html" : function(e3) {
      return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => zg(e4) && e4.key.type === "Identifier" && e4.key.name === "template" && t2 === "value", ...Hg);
    }(e2) ? "angular" : function(e3) {
      const t2 = e3.getValue(), n2 = e3.getParentNode();
      return n2 && n2.type === "TaggedTemplateExpression" && t2.quasis.length === 1 && n2.tag.type === "Identifier" && (n2.tag.name === "md" || n2.tag.name === "markdown");
    }(e2) ? "markdown" : void 0;
  }
  const Hg = [(e2, t2) => e2.type === "ObjectExpression" && t2 === "properties", (e2, t2) => e2.type === "CallExpression" && e2.callee.type === "Identifier" && e2.callee.name === "Component" && t2 === "arguments", (e2, t2) => e2.type === "Decorator" && t2 === "expression"];
  function Jg(e2) {
    return e2.type === "Identifier" && e2.name === "styled";
  }
  function Xg(e2) {
    return /^[A-Z]/.test(e2.object.name) && e2.property.name === "extend";
  }
  function Yg(e2, t2) {
    return qg(e2, Ug.Block | Ug.Leading, ({ value: e3 }) => e3 === ` ${t2} `);
  }
  var Kg = function(e2, t2, n2, r2) {
    const i2 = e2.getValue();
    if (i2.type !== "TemplateLiteral" || function({ quasis: e3 }) {
      return e3.some(({ value: { cooked: e4 } }) => e4 === null);
    }(i2))
      return;
    const u2 = Gg(e2);
    return u2 ? u2 === "markdown" ? yg(e2, t2, n2) : u2 === "css" ? xg(e2, t2, n2) : u2 === "graphql" ? Og(e2, t2, n2) : u2 === "html" || u2 === "angular" ? Wg(e2, t2, n2, r2, { parser: u2 }) : void 0 : void 0;
  };
  const { isBlockComment: Qg } = Gh, Zg = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), em = (e2) => {
    for (const t2 of e2.quasis)
      delete t2.value;
  };
  function tm(e2, t2, n2) {
    if (e2.type === "Program" && delete t2.sourceType, e2.type !== "BigIntLiteral" && e2.type !== "BigIntLiteralTypeAnnotation" || t2.value && (t2.value = t2.value.toLowerCase()), e2.type !== "BigIntLiteral" && e2.type !== "Literal" || t2.bigint && (t2.bigint = t2.bigint.toLowerCase()), e2.type === "DecimalLiteral" && (t2.value = Number(t2.value)), e2.type === "Literal" && t2.decimal && (t2.decimal = Number(t2.decimal)), e2.type === "EmptyStatement")
      return null;
    if (e2.type === "JSXText")
      return null;
    if (e2.type === "JSXExpressionContainer" && (e2.expression.type === "Literal" || e2.expression.type === "StringLiteral") && e2.expression.value === " ")
      return null;
    if (e2.type !== "Property" && e2.type !== "ObjectProperty" && e2.type !== "MethodDefinition" && e2.type !== "ClassProperty" && e2.type !== "ClassMethod" && e2.type !== "PropertyDefinition" && e2.type !== "TSDeclareMethod" && e2.type !== "TSPropertySignature" && e2.type !== "ObjectTypeProperty" || typeof e2.key != "object" || !e2.key || e2.key.type !== "Literal" && e2.key.type !== "NumericLiteral" && e2.key.type !== "StringLiteral" && e2.key.type !== "Identifier" || delete t2.key, e2.type === "JSXElement" && e2.openingElement.name.name === "style" && e2.openingElement.attributes.some((e3) => e3.name.name === "jsx"))
      for (const { type: e3, expression: n3 } of t2.children)
        e3 === "JSXExpressionContainer" && n3.type === "TemplateLiteral" && em(n3);
    e2.type === "JSXAttribute" && e2.name.name === "css" && e2.value.type === "JSXExpressionContainer" && e2.value.expression.type === "TemplateLiteral" && em(t2.value.expression), e2.type === "JSXAttribute" && e2.value && e2.value.type === "Literal" && /["']|&quot;|&apos;/.test(e2.value.value) && (t2.value.value = t2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
    const r2 = e2.expression || e2.callee;
    if (e2.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
      const n3 = e2.expression.arguments[0].properties;
      for (const [e3, r3] of t2.expression.arguments[0].properties.entries())
        switch (n3[e3].key.name) {
          case "styles":
            r3.value.type === "ArrayExpression" && em(r3.value.elements[0]);
            break;
          case "template":
            r3.value.type === "TemplateLiteral" && em(r3.value);
        }
    }
    if (e2.type !== "TaggedTemplateExpression" || e2.tag.type !== "MemberExpression" && (e2.tag.type !== "Identifier" || e2.tag.name !== "gql" && e2.tag.name !== "graphql" && e2.tag.name !== "css" && e2.tag.name !== "md" && e2.tag.name !== "markdown" && e2.tag.name !== "html") && e2.tag.type !== "CallExpression" || em(t2.quasi), e2.type === "TemplateLiteral") {
      (e2.leadingComments && e2.leadingComments.some((e3) => Qg(e3) && ["GraphQL", "HTML"].some((t3) => e3.value === ` ${t3} `)) || n2.type === "CallExpression" && n2.callee.name === "graphql" || !e2.leadingComments) && em(t2);
    }
    return e2.type === "InterpreterDirective" && (t2.value = t2.value.trimEnd()), e2.type !== "TSIntersectionType" && e2.type !== "TSUnionType" || e2.types.length !== 1 ? void 0 : t2.types[0];
  }
  tm.ignoredProperties = Zg;
  var nm = tm;
  const rm = (e2) => {
    if (typeof e2 != "string")
      throw new TypeError("Expected a string");
    const t2 = e2.match(/(?:\r?\n)/g) || [];
    if (t2.length === 0)
      return;
    const n2 = t2.filter((e3) => e3 === "\r\n").length;
    return n2 > t2.length - n2 ? "\r\n" : "\n";
  };
  var im = rm;
  im.graceful = (e2) => typeof e2 == "string" && rm(e2) || "\n";
  var um = function(e2) {
    const t2 = e2.match(hm);
    return t2 ? t2[0].trimLeft() : "";
  }, om = function(e2) {
    const t2 = e2.match(hm);
    return t2 && t2[0] ? e2.substring(t2[0].length) : e2;
  }, sm = function(e2) {
    return bm(e2).pragmas;
  }, am = bm, cm = function({ comments: e2 = "", pragmas: t2 = {} }) {
    const n2 = (0, pm().default)(e2) || lm().EOL, r2 = " *", i2 = Object.keys(t2), u2 = i2.map((e3) => Am(e3, t2[e3])).reduce((e3, t3) => e3.concat(t3), []).map((e3) => " * " + e3 + n2).join("");
    if (!e2) {
      if (i2.length === 0)
        return "";
      if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
        const e3 = t2[i2[0]];
        return `/** ${Am(i2[0], e3)[0]} */`;
      }
    }
    const o2 = e2.split(n2).map((e3) => ` * ${e3}`).join(n2) + n2;
    return "/**" + n2 + (e2 ? o2 : "") + (e2 && i2.length ? r2 + n2 : "") + u2 + " */";
  };
  function lm() {
    const e2 = is$3;
    return lm = function() {
      return e2;
    }, e2;
  }
  function pm() {
    const e2 = function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    }(im);
    return pm = function() {
      return e2;
    }, e2;
  }
  const fm = /\*\/$/, dm = /^\/\*\*/, hm = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, gm = /(^|\s+)\/\/([^\r\n]*)/g, mm = /^(\r?\n)+/, ym = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Dm = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Em = /(\r?\n|^) *\* ?/g, Cm = [];
  function bm(e2) {
    const t2 = (0, pm().default)(e2) || lm().EOL;
    e2 = e2.replace(dm, "").replace(fm, "").replace(Em, "$1");
    let n2 = "";
    for (; n2 !== e2; )
      n2 = e2, e2 = e2.replace(ym, `${t2}$1 $2${t2}`);
    e2 = e2.replace(mm, "").trimRight();
    const r2 = Object.create(null), i2 = e2.replace(Dm, "").replace(mm, "").trimRight();
    let u2;
    for (; u2 = Dm.exec(e2); ) {
      const e3 = u2[2].replace(gm, "");
      typeof r2[u2[1]] == "string" || Array.isArray(r2[u2[1]]) ? r2[u2[1]] = Cm.concat(r2[u2[1]], e3) : r2[u2[1]] = e3;
    }
    return { comments: i2, pragmas: r2 };
  }
  function Am(e2, t2) {
    return Cm.concat(t2).map((t3) => `@${e2} ${t3}`.trim());
  }
  var vm = Object.defineProperty({ extract: um, strip: om, parse: sm, parseWithComments: am, print: cm }, "__esModule", { value: true });
  const { parseWithComments: Fm, strip: Sm, extract: xm, print: wm } = vm, { getShebang: Tm } = yi$2, { normalizeEndOfLine: Bm } = Di$2;
  function Nm(e2) {
    const t2 = Tm(e2);
    t2 && (e2 = e2.slice(t2.length + 1));
    const n2 = xm(e2), { pragmas: r2, comments: i2 } = Fm(n2);
    return { shebang: t2, text: e2, pragmas: r2, comments: i2 };
  }
  var km = { hasPragma: function(e2) {
    const t2 = Object.keys(Nm(e2).pragmas);
    return t2.includes("prettier") || t2.includes("format");
  }, insertPragma: function(e2) {
    const { shebang: t2, text: n2, pragmas: r2, comments: i2 } = Nm(e2), u2 = Sm(n2), o2 = wm({ pragmas: Object.assign({ format: "" }, r2), comments: i2.trimStart() });
    return (t2 ? `${t2}
` : "") + Bm(o2) + (u2.startsWith("\n") ? "\n" : "\n\n") + u2;
  } };
  const { getLast: Pm, hasNewline: Om, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Im, getNextNonSpaceNonCommentCharacter: Lm, hasNewlineInRange: jm, addLeadingComment: _m, addTrailingComment: Mm, addDanglingComment: Rm, getNextNonSpaceNonCommentCharacterIndex: $m, isNonEmptyArray: Vm } = yi$2, { isBlockComment: Wm, getFunctionParameters: qm, isPrettierIgnoreComment: Um, isJsxNode: zm, hasFlowShorthandAnnotationComment: Gm, hasFlowAnnotationComment: Hm, hasIgnoreComment: Jm, isCallLikeExpression: Xm, getCallArguments: Ym, isCallExpression: Km, isMemberExpression: Qm, isObjectProperty: Zm, getComments: ey, CommentCheckFlags: ty } = Gh, { locStart: ny, locEnd: ry } = zc;
  function iy(e2, t2) {
    const n2 = (e2.body || e2.properties).find(({ type: e3 }) => e3 !== "EmptyStatement");
    n2 ? _m(n2, t2) : Rm(e2, t2);
  }
  function uy(e2, t2) {
    e2.type === "BlockStatement" ? iy(e2, t2) : _m(e2, t2);
  }
  function oy({ comment: e2, followingNode: t2 }) {
    return !(!t2 || !Ly(e2)) && (_m(t2, e2), true);
  }
  function sy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
    if (!n2 || n2.type !== "IfStatement" || !r2)
      return false;
    return Lm(i2, e2, ry) === ")" ? (Mm(t2, e2), true) : t2 === n2.consequent && r2 === n2.alternate ? (t2.type === "BlockStatement" ? Mm(t2, e2) : Rm(n2, e2), true) : r2.type === "BlockStatement" ? (iy(r2, e2), true) : r2.type === "IfStatement" ? (uy(r2.consequent, e2), true) : n2.consequent === r2 && (_m(r2, e2), true);
  }
  function ay({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
    if (!n2 || n2.type !== "WhileStatement" || !r2)
      return false;
    return Lm(i2, e2, ry) === ")" ? (Mm(t2, e2), true) : r2.type === "BlockStatement" ? (iy(r2, e2), true) : n2.body === r2 && (_m(r2, e2), true);
  }
  function cy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
    return !(!n2 || n2.type !== "TryStatement" && n2.type !== "CatchClause" || !r2) && (n2.type === "CatchClause" && t2 ? (Mm(t2, e2), true) : r2.type === "BlockStatement" ? (iy(r2, e2), true) : r2.type === "TryStatement" ? (uy(r2.finalizer, e2), true) : r2.type === "CatchClause" && (uy(r2.body, e2), true));
  }
  function ly({ comment: e2, enclosingNode: t2, followingNode: n2 }) {
    return !(!Qm(t2) || !n2 || n2.type !== "Identifier") && (_m(t2, e2), true);
  }
  function py({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
    const u2 = t2 && !jm(i2, ry(t2), ny(e2));
    return !(t2 && u2 || !n2 || n2.type !== "ConditionalExpression" && n2.type !== "TSConditionalType" || !r2) && (_m(r2, e2), true);
  }
  function fy({ comment: e2, precedingNode: t2, enclosingNode: n2 }) {
    return !(!Zm(n2) || !n2.shorthand || n2.key !== t2 || n2.value.type !== "AssignmentPattern") && (Mm(n2.value.left, e2), true);
  }
  function dy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
    if (n2 && (n2.type === "ClassDeclaration" || n2.type === "ClassExpression" || n2.type === "DeclareClass" || n2.type === "DeclareInterface" || n2.type === "InterfaceDeclaration" || n2.type === "TSInterfaceDeclaration")) {
      if (Vm(n2.decorators) && (!r2 || r2.type !== "Decorator"))
        return Mm(Pm(n2.decorators), e2), true;
      if (n2.body && r2 === n2.body)
        return iy(n2.body, e2), true;
      if (r2) {
        for (const i2 of ["implements", "extends", "mixins"])
          if (n2[i2] && r2 === n2[i2][0])
            return !t2 || t2 !== n2.id && t2 !== n2.typeParameters && t2 !== n2.superClass ? Rm(n2, e2, i2) : Mm(t2, e2), true;
      }
    }
    return false;
  }
  function hy({ comment: e2, precedingNode: t2, enclosingNode: n2, text: r2 }) {
    return (n2 && t2 && (n2.type === "Property" || n2.type === "TSDeclareMethod" || n2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && n2.key === t2 && Lm(r2, t2, ry) !== ":" || !(!t2 || !n2 || t2.type !== "Decorator" || n2.type !== "ClassMethod" && n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" && n2.type !== "TSAbstractClassProperty" && n2.type !== "TSAbstractMethodDefinition" && n2.type !== "TSDeclareMethod" && n2.type !== "MethodDefinition")) && (Mm(t2, e2), true);
  }
  function gy({ comment: e2, precedingNode: t2, enclosingNode: n2, text: r2 }) {
    return Lm(r2, e2, ry) === "(" && (!(!t2 || !n2 || n2.type !== "FunctionDeclaration" && n2.type !== "FunctionExpression" && n2.type !== "ClassMethod" && n2.type !== "MethodDefinition" && n2.type !== "ObjectMethod") && (Mm(t2, e2), true));
  }
  function my({ comment: e2, enclosingNode: t2, text: n2 }) {
    if (!t2 || t2.type !== "ArrowFunctionExpression")
      return false;
    const r2 = $m(n2, e2, ry);
    return r2 !== false && n2.slice(r2, r2 + 2) === "=>" && (Rm(t2, e2), true);
  }
  function yy({ comment: e2, enclosingNode: t2, text: n2 }) {
    return Lm(n2, e2, ry) === ")" && (t2 && (Iy(t2) && qm(t2).length === 0 || Xm(t2) && Ym(t2).length === 0) ? (Rm(t2, e2), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || qm(t2.value).length !== 0) && (Rm(t2.value, e2), true));
  }
  function Dy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
    if (t2 && t2.type === "FunctionTypeParam" && n2 && n2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
      return Mm(t2, e2), true;
    if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && n2 && Iy(n2) && Lm(i2, e2, ry) === ")")
      return Mm(t2, e2), true;
    if (n2 && n2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
      const t3 = (() => {
        const e3 = qm(n2);
        if (e3.length > 0)
          return Im(i2, ry(Pm(e3)));
        const t4 = Im(i2, ry(n2.id));
        return t4 !== false && Im(i2, t4 + 1);
      })();
      if (ny(e2) > t3)
        return iy(r2, e2), true;
    }
    return false;
  }
  function Ey({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "ImportSpecifier") && (_m(t2, e2), true);
  }
  function Cy({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "LabeledStatement") && (_m(t2, e2), true);
  }
  function by({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (Mm(t2, e2), true);
  }
  function Ay({ comment: e2, precedingNode: t2, enclosingNode: n2 }) {
    return !!(Km(n2) && t2 && n2.callee === t2 && n2.arguments.length > 0) && (_m(n2.arguments[0], e2), true);
  }
  function vy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
    return !n2 || n2.type !== "UnionTypeAnnotation" && n2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && Um(e2) && (r2.types[0].prettierIgnore = true, e2.unignore = true), false) : (Um(e2) && (r2.prettierIgnore = true, e2.unignore = true), !!t2 && (Mm(t2, e2), true));
  }
  function Fy({ comment: e2, enclosingNode: t2 }) {
    return !!Zm(t2) && (_m(t2, e2), true);
  }
  function Sy({ comment: e2, enclosingNode: t2, followingNode: n2, ast: r2, isLastComment: i2 }) {
    return r2 && r2.body && r2.body.length === 0 ? (i2 ? Rm(r2, e2) : _m(r2, e2), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !Vm(t2.directives) ? (i2 ? Rm(t2, e2) : _m(t2, e2), true) : !(!n2 || n2.type !== "Program" || n2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (Rm(n2, e2), true);
  }
  function xy({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (_m(t2, e2), true);
  }
  function wy({ comment: e2, precedingNode: t2, enclosingNode: n2, text: r2 }) {
    return !!(t2 && t2.type === "ImportSpecifier" && n2 && n2.type === "ImportDeclaration" && Om(r2, ry(e2))) && (Mm(t2, e2), true);
  }
  function Ty({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "AssignmentPattern") && (_m(t2, e2), true);
  }
  function By({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "TypeAlias") && (_m(t2, e2), true);
  }
  function Ny({ comment: e2, enclosingNode: t2, followingNode: n2 }) {
    return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !n2 || n2.type !== "ObjectExpression" && n2.type !== "ArrayExpression" && n2.type !== "TemplateLiteral" && n2.type !== "TaggedTemplateExpression" && !Wm(e2)) && (_m(n2, e2), true);
  }
  function ky({ comment: e2, enclosingNode: t2, followingNode: n2, text: r2 }) {
    return !(n2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || Lm(r2, e2, ry) !== ";") && (Mm(t2, e2), true);
  }
  function Py({ comment: e2, enclosingNode: t2, followingNode: n2 }) {
    if (Um(e2) && t2 && t2.type === "TSMappedType" && n2 && n2.type === "TSTypeParameter" && n2.constraint)
      return t2.prettierIgnore = true, e2.unignore = true, true;
  }
  function Oy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
    return !(!n2 || n2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (_m(r2.name, e2), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (Mm(t2.constraint, e2), true));
  }
  function Iy(e2) {
    return e2.type === "ArrowFunctionExpression" || e2.type === "FunctionExpression" || e2.type === "FunctionDeclaration" || e2.type === "ObjectMethod" || e2.type === "ClassMethod" || e2.type === "TSDeclareFunction" || e2.type === "TSCallSignatureDeclaration" || e2.type === "TSConstructSignatureDeclaration" || e2.type === "TSMethodSignature" || e2.type === "TSConstructorType" || e2.type === "TSFunctionType" || e2.type === "TSDeclareMethod";
  }
  function Ly(e2) {
    return Wm(e2) && e2.value[0] === "*" && /@type\b/.test(e2.value);
  }
  var jy = { handleOwnLineComment: function(e2) {
    return [Py, Dy, ly, sy, ay, cy, dy, Ey, xy, vy, Sy, wy, Ty, hy, Cy].some((t2) => t2(e2));
  }, handleEndOfLineComment: function(e2) {
    return [oy, Dy, py, Ey, sy, ay, cy, dy, Cy, Ay, Fy, Sy, By, Ny].some((t2) => t2(e2));
  }, handleRemainingComment: function(e2) {
    return [Py, sy, ay, fy, yy, hy, Sy, my, gy, Oy, by, ky].some((t2) => t2(e2));
  }, isTypeCastComment: Ly, getCommentChildNodes: function(e2, t2) {
    if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e2.type === "MethodDefinition" && e2.value && e2.value.type === "FunctionExpression" && qm(e2.value).length === 0 && !e2.value.returnType && !Vm(e2.value.typeParameters) && e2.value.body)
      return [...e2.decorators || [], e2.key, e2.value.body];
  }, willPrintOwnComments: function(e2) {
    const t2 = e2.getValue(), n2 = e2.getParentNode();
    return (t2 && (zm(t2) || Gm(t2) || Km(n2) && ((e3) => Hm(ey(e3, ty.Leading)) || Hm(ey(e3, ty.Trailing)))(t2)) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t2)) && (!Jm(e2) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
  } };
  const { getFunctionParameters: _y, getLeftSidePathName: My, hasFlowShorthandAnnotationComment: Ry, hasNakedLeftSide: $y, hasNode: Vy, isBitwiseOperator: Wy, startsWithNoLookaheadToken: qy, shouldFlatten: Uy, getPrecedence: zy, isCallExpression: Gy, isMemberExpression: Hy, isObjectProperty: Jy } = Gh;
  function Xy(e2, t2) {
    const n2 = e2.getParentNode();
    if (!n2)
      return false;
    const r2 = e2.getName(), i2 = e2.getNode();
    if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && function(e3) {
      switch (e3.type) {
        case "ObjectExpression":
          return true;
        default:
          return false;
      }
    }(i2) && Yy(e2))
      return true;
    if (function(e3) {
      return e3.type === "BlockStatement" || e3.type === "BreakStatement" || e3.type === "ClassBody" || e3.type === "ClassDeclaration" || e3.type === "ClassMethod" || e3.type === "ClassProperty" || e3.type === "PropertyDefinition" || e3.type === "ClassPrivateProperty" || e3.type === "ContinueStatement" || e3.type === "DebuggerStatement" || e3.type === "DeclareClass" || e3.type === "DeclareExportAllDeclaration" || e3.type === "DeclareExportDeclaration" || e3.type === "DeclareFunction" || e3.type === "DeclareInterface" || e3.type === "DeclareModule" || e3.type === "DeclareModuleExports" || e3.type === "DeclareVariable" || e3.type === "DoWhileStatement" || e3.type === "EnumDeclaration" || e3.type === "ExportAllDeclaration" || e3.type === "ExportDefaultDeclaration" || e3.type === "ExportNamedDeclaration" || e3.type === "ExpressionStatement" || e3.type === "ForInStatement" || e3.type === "ForOfStatement" || e3.type === "ForStatement" || e3.type === "FunctionDeclaration" || e3.type === "IfStatement" || e3.type === "ImportDeclaration" || e3.type === "InterfaceDeclaration" || e3.type === "LabeledStatement" || e3.type === "MethodDefinition" || e3.type === "ReturnStatement" || e3.type === "SwitchStatement" || e3.type === "ThrowStatement" || e3.type === "TryStatement" || e3.type === "TSDeclareFunction" || e3.type === "TSEnumDeclaration" || e3.type === "TSImportEqualsDeclaration" || e3.type === "TSInterfaceDeclaration" || e3.type === "TSModuleDeclaration" || e3.type === "TSNamespaceExportDeclaration" || e3.type === "TypeAlias" || e3.type === "VariableDeclaration" || e3.type === "WhileStatement" || e3.type === "WithStatement";
    }(i2))
      return false;
    if (t2.parser !== "flow" && Ry(e2.getValue()))
      return true;
    if (i2.type === "Identifier")
      return !!(i2.extra && i2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(i2.name)) || r2 === "left" && i2.name === "async" && n2.type === "ForOfStatement" && !n2.await;
    switch (n2.type) {
      case "ParenthesizedExpression":
        return false;
      case "ClassDeclaration":
      case "ClassExpression":
        if (r2 === "superClass" && (i2.type === "ArrowFunctionExpression" || i2.type === "AssignmentExpression" || i2.type === "AwaitExpression" || i2.type === "BinaryExpression" || i2.type === "ConditionalExpression" || i2.type === "LogicalExpression" || i2.type === "NewExpression" || i2.type === "ObjectExpression" || i2.type === "ParenthesizedExpression" || i2.type === "SequenceExpression" || i2.type === "TaggedTemplateExpression" || i2.type === "UnaryExpression" || i2.type === "UpdateExpression" || i2.type === "YieldExpression" || i2.type === "TSNonNullExpression"))
          return true;
        break;
      case "ExportDefaultDeclaration":
        return Ky(e2, t2) || i2.type === "SequenceExpression";
      case "Decorator":
        if (r2 === "expression") {
          let e3 = false, t3 = false, n3 = i2;
          for (; n3; )
            switch (n3.type) {
              case "MemberExpression":
                t3 = true, n3 = n3.object;
                break;
              case "CallExpression":
                if (t3 || e3)
                  return true;
                e3 = true, n3 = n3.callee;
                break;
              case "Identifier":
                return false;
              default:
                return true;
            }
          return true;
        }
        break;
      case "ExpressionStatement":
        if (qy(i2, true))
          return true;
        break;
      case "ArrowFunctionExpression":
        if (r2 === "body" && i2.type !== "SequenceExpression" && qy(i2, false))
          return true;
    }
    switch (i2.type) {
      case "UpdateExpression":
        if (n2.type === "UnaryExpression")
          return i2.prefix && (i2.operator === "++" && n2.operator === "+" || i2.operator === "--" && n2.operator === "-");
      case "UnaryExpression":
        switch (n2.type) {
          case "UnaryExpression":
            return i2.operator === n2.operator && (i2.operator === "+" || i2.operator === "-");
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "TaggedTemplateExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "BinaryExpression":
            return r2 === "left" && n2.operator === "**";
          case "TSNonNullExpression":
            return true;
          default:
            return false;
        }
      case "BinaryExpression":
        if (n2.type === "UpdateExpression" || n2.type === "PipelineTopicExpression" && i2.operator === "|>")
          return true;
        if (i2.operator === "in" && function(e3) {
          let t3 = 0, n3 = e3.getValue();
          for (; n3; ) {
            const r3 = e3.getParentNode(t3++);
            if (r3 && r3.type === "ForStatement" && r3.init === n3)
              return true;
            n3 = r3;
          }
          return false;
        }(e2))
          return true;
        if (i2.operator === "|>" && i2.extra && i2.extra.parenthesized) {
          const t3 = e2.getParentNode(1);
          if (t3.type === "BinaryExpression" && t3.operator === "|>")
            return true;
        }
      case "TSTypeAssertion":
      case "TSAsExpression":
      case "LogicalExpression":
        switch (n2.type) {
          case "TSAsExpression":
            return i2.type !== "TSAsExpression";
          case "ConditionalExpression":
            return i2.type === "TSAsExpression";
          case "CallExpression":
          case "NewExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "ClassExpression":
          case "ClassDeclaration":
            return r2 === "superClass";
          case "TSTypeAssertion":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "JSXSpreadAttribute":
          case "SpreadElement":
          case "SpreadProperty":
          case "BindExpression":
          case "AwaitExpression":
          case "TSNonNullExpression":
          case "UpdateExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "AssignmentExpression":
          case "AssignmentPattern":
            return r2 === "left" && (i2.type === "TSTypeAssertion" || i2.type === "TSAsExpression");
          case "LogicalExpression":
            if (i2.type === "LogicalExpression")
              return n2.operator !== i2.operator;
          case "BinaryExpression": {
            const { operator: e3, type: t3 } = i2;
            if (!e3 && t3 !== "TSTypeAssertion")
              return true;
            const u2 = zy(e3), o2 = n2.operator, s2 = zy(o2);
            return s2 > u2 || (r2 === "right" && s2 === u2 || (s2 === u2 && !Uy(o2, e3) || (s2 < u2 && e3 === "%" ? o2 === "+" || o2 === "-" : !!Wy(o2))));
          }
          default:
            return false;
        }
      case "SequenceExpression":
        switch (n2.type) {
          case "ReturnStatement":
          case "ForStatement":
            return false;
          case "ExpressionStatement":
            return r2 !== "expression";
          case "ArrowFunctionExpression":
            return r2 !== "body";
          default:
            return true;
        }
      case "YieldExpression":
        if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
          return true;
        if (r2 === "expression" && i2.argument && i2.argument.type === "PipelinePrimaryTopicReference" && n2.type === "PipelineTopicExpression")
          return true;
      case "AwaitExpression":
        switch (n2.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "ConditionalExpression":
            return r2 === "test";
          case "BinaryExpression":
            return !(!i2.argument && n2.operator === "|>");
          default:
            return false;
        }
      case "TSConditionalType":
        if (r2 === "extendsType" && n2.type === "TSConditionalType")
          return true;
      case "TSFunctionType":
      case "TSConstructorType":
        if (r2 === "checkType" && n2.type === "TSConditionalType")
          return true;
      case "TSUnionType":
      case "TSIntersectionType":
        if ((n2.type === "TSUnionType" || n2.type === "TSIntersectionType") && n2.types.length > 1 && (!i2.types || i2.types.length > 1))
          return true;
      case "TSInferType":
        if (i2.type === "TSInferType" && n2.type === "TSRestType")
          return false;
      case "TSTypeOperator":
        return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || r2 === "objectType" && n2.type === "TSIndexedAccessType" || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && /^TSJSDoc/.test(e2.getParentNode(1).type);
      case "ArrayTypeAnnotation":
        return n2.type === "NullableTypeAnnotation";
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
      case "NullableTypeAnnotation":
        return n2.type === "ArrayTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
      case "FunctionTypeAnnotation": {
        const t3 = n2.type === "NullableTypeAnnotation" ? e2.getParentNode(1) : n2;
        return t3.type === "UnionTypeAnnotation" || t3.type === "IntersectionTypeAnnotation" || t3.type === "ArrayTypeAnnotation" || r2 === "objectType" && (t3.type === "IndexedAccessType" || t3.type === "OptionalIndexedAccessType") || t3.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && _y(i2).some((e3) => e3.typeAnnotation && e3.typeAnnotation.type === "NullableTypeAnnotation");
      }
      case "OptionalIndexedAccessType":
        return r2 === "objectType" && n2.type === "IndexedAccessType";
      case "TypeofTypeAnnotation":
        return r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
      case "StringLiteral":
      case "NumericLiteral":
      case "Literal":
        if (typeof i2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
          const t3 = e2.getParentNode(1);
          return t3.type === "Program" || t3.type === "BlockStatement";
        }
        return r2 === "object" && n2.type === "MemberExpression" && typeof i2.value == "number";
      case "AssignmentExpression": {
        const t3 = e2.getParentNode(1);
        return r2 === "body" && n2.type === "ArrowFunctionExpression" || (r2 !== "key" || n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" || !n2.computed) && ((r2 !== "init" && r2 !== "update" || n2.type !== "ForStatement") && (n2.type === "ExpressionStatement" ? i2.left.type === "ObjectPattern" : (r2 !== "key" || n2.type !== "TSPropertySignature") && (n2.type !== "AssignmentExpression" && ((n2.type !== "SequenceExpression" || !t3 || t3.type !== "ForStatement" || t3.init !== n2 && t3.update !== n2) && ((r2 !== "value" || n2.type !== "Property" || !t3 || t3.type !== "ObjectPattern" || !t3.properties.includes(n2)) && n2.type !== "NGChainedExpression")))));
      }
      case "ConditionalExpression":
        switch (n2.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
          case "NGPipeExpression":
          case "ExportDefaultDeclaration":
          case "AwaitExpression":
          case "JSXSpreadAttribute":
          case "TSTypeAssertion":
          case "TypeCastExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "ConditionalExpression":
            return r2 === "test";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          default:
            return false;
        }
      case "FunctionExpression":
        switch (n2.type) {
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "TaggedTemplateExpression":
            return true;
          default:
            return false;
        }
      case "ArrowFunctionExpression":
        switch (n2.type) {
          case "PipelineTopicExpression":
            return Boolean(i2.extra && i2.extra.parenthesized);
          case "BinaryExpression":
            return n2.operator !== "|>" || i2.extra && i2.extra.parenthesized;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "AwaitExpression":
          case "TSTypeAssertion":
            return true;
          case "ConditionalExpression":
            return r2 === "test";
          default:
            return false;
        }
      case "ClassExpression":
        switch (n2.type) {
          case "NewExpression":
            return r2 === "callee";
          default:
            return false;
        }
      case "OptionalMemberExpression":
      case "OptionalCallExpression": {
        const t3 = e2.getParentNode(1);
        if (r2 === "object" && n2.type === "MemberExpression" || r2 === "callee" && (n2.type === "CallExpression" || n2.type === "NewExpression") || n2.type === "TSNonNullExpression" && t3.type === "MemberExpression" && t3.object === n2)
          return true;
      }
      case "CallExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "TSNonNullExpression":
        if (r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression")) {
          let e3 = i2;
          for (; e3; )
            switch (e3.type) {
              case "CallExpression":
              case "OptionalCallExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
              case "BindExpression":
                e3 = e3.object;
                break;
              case "TaggedTemplateExpression":
                e3 = e3.tag;
                break;
              case "TSNonNullExpression":
                e3 = e3.expression;
                break;
              default:
                return false;
            }
        }
        return false;
      case "BindExpression":
        return r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression") || r2 === "object" && Hy(n2);
      case "NGPipeExpression":
        return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || n2.type === "ObjectProperty" && (!i2.extra || !i2.extra.parenthesized) || n2.type === "ArrayExpression" || Gy(n2) && n2.arguments[r2] === i2 || r2 === "right" && n2.type === "NGPipeExpression" || r2 === "property" && n2.type === "MemberExpression" || n2.type === "AssignmentExpression");
      case "JSXFragment":
      case "JSXElement":
        return r2 === "callee" || r2 === "left" && n2.type === "BinaryExpression" && n2.operator === "<" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && !Gy(n2) && !Jy(n2) && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator" && n2.type !== "YieldExpression";
      case "TypeAnnotation":
        return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e3) {
          return Vy(e3, (e4) => e4.type === "ObjectTypeAnnotation" && Vy(e4, (e5) => e5.type === "FunctionTypeAnnotation" || void 0) || void 0);
        }(i2);
    }
    return false;
  }
  function Yy(e2) {
    const t2 = e2.getValue(), n2 = e2.getParentNode(), r2 = e2.getName();
    switch (n2.type) {
      case "NGPipeExpression":
        if (typeof r2 == "number" && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2)
          return e2.callParent(Yy);
        break;
      case "ObjectProperty":
        if (r2 === "value") {
          const t3 = e2.getParentNode(1);
          return Ln$2(t3.properties) === n2;
        }
        break;
      case "BinaryExpression":
      case "LogicalExpression":
        if (r2 === "right")
          return e2.callParent(Yy);
        break;
      case "ConditionalExpression":
        if (r2 === "alternate")
          return e2.callParent(Yy);
        break;
      case "UnaryExpression":
        if (n2.prefix)
          return e2.callParent(Yy);
    }
    return false;
  }
  function Ky(e2, t2) {
    const n2 = e2.getValue(), r2 = e2.getParentNode();
    return n2.type === "FunctionExpression" || n2.type === "ClassExpression" ? r2.type === "ExportDefaultDeclaration" || !Xy(e2, t2) : !(!$y(n2) || r2.type !== "ExportDefaultDeclaration" && Xy(e2, t2)) && e2.call((e3) => Ky(e3, t2), ...My(e2, n2));
  }
  var Qy = Xy;
  var Zy = function(e2, t2) {
    switch (t2.parser) {
      case "json":
      case "json5":
      case "json-stringify":
      case "__js_expression":
      case "__vue_expression":
        return Object.assign(Object.assign({}, e2), {}, { type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e2, comments: [], rootMarker: t2.rootMarker });
      default:
        return e2;
    }
  };
  const { builders: { join: eD, line: tD, group: nD, softline: rD, indent: iD } } = eu$1;
  var uD = { isVueEventBindingExpression: function e2(t2) {
    switch (t2.type) {
      case "MemberExpression":
        switch (t2.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return e2(t2.object);
        }
        return false;
      case "Identifier":
        return true;
      default:
        return false;
    }
  }, printHtmlBinding: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (t2.__onHtmlBindingRoot && e2.getName() === null && t2.__onHtmlBindingRoot(r2, t2), r2.type === "File")
      return t2.__isVueForBindingLeft ? e2.call((e3) => {
        const t3 = eD([",", tD], e3.map(n2, "params")), { params: r3 } = e3.getValue();
        return r3.length === 1 ? t3 : ["(", iD([rD, nD(t3)]), rD, ")"];
      }, "program", "body", 0) : t2.__isVueBindings ? e2.call((e3) => eD([",", tD], e3.map(n2, "params")), "program", "body", 0) : void 0;
  } };
  const { printComments: oD } = Wf, { getLast: sD } = yi$2, { builders: { join: aD, line: cD, softline: lD, group: pD, indent: fD, align: dD, ifBreak: hD, indentIfBreak: gD }, utils: { cleanDoc: mD, getDocParts: yD, isConcat: DD } } = eu$1, { hasLeadingOwnLineComment: ED, isBinaryish: CD, isJsxNode: bD, shouldFlatten: AD, hasComment: vD, CommentCheckFlags: FD, isCallExpression: SD, isMemberExpression: xD, isObjectProperty: wD } = Gh;
  let TD = 0;
  function BD(e2, t2, n2, r2, i2) {
    let u2 = [];
    const o2 = e2.getValue();
    if (CD(o2)) {
      AD(o2.operator, o2.left.operator) ? u2 = [...u2, ...e2.call((e3) => BD(e3, t2, n2, true, i2), "left")] : u2.push(pD(t2("left")));
      const s2 = ND(o2), a2 = (o2.operator === "|>" || o2.type === "NGPipeExpression" || o2.operator === "|" && n2.parser === "__vue_expression") && !ED(n2.originalText, o2.right), c2 = o2.type === "NGPipeExpression" ? "|" : o2.operator, l2 = o2.type === "NGPipeExpression" && o2.arguments.length > 0 ? pD(fD([lD, ": ", aD([lD, ":", hD(" ")], e2.map(t2, "arguments").map((e3) => dD(2, pD(e3))))])) : "", p2 = s2 ? [c2, " ", t2("right"), l2] : [a2 ? cD : "", c2, a2 ? " " : cD, t2("right"), l2], f2 = e2.getParentNode(), d2 = vD(o2.left, FD.Trailing | FD.Line), h2 = d2 || !(i2 && o2.type === "LogicalExpression") && f2.type !== o2.type && o2.left.type !== o2.type && o2.right.type !== o2.type;
      if (u2.push(a2 ? "" : " ", h2 ? pD(p2, { shouldBreak: d2 }) : p2), r2 && vD(o2)) {
        const t3 = mD(oD(e2, u2, n2));
        u2 = DD(t3) || t3.type === "fill" ? yD(t3) : [t3];
      }
    } else
      u2.push(pD(t2()));
    return u2;
  }
  function ND(e2) {
    return e2.type === "LogicalExpression" && (e2.right.type === "ObjectExpression" && e2.right.properties.length > 0 || (e2.right.type === "ArrayExpression" && e2.right.elements.length > 0 || !!bD(e2.right)));
  }
  var kD = { printBinaryishExpression: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = e2.getParentNode(), u2 = e2.getParentNode(1), o2 = r2 !== i2.body && (i2.type === "IfStatement" || i2.type === "WhileStatement" || i2.type === "SwitchStatement" || i2.type === "DoWhileStatement"), s2 = BD(e2, n2, t2, false, o2);
    if (o2)
      return s2;
    if (SD(i2) && i2.callee === r2 || i2.type === "UnaryExpression" || xD(i2) && !i2.computed)
      return pD([fD([lD, ...s2]), lD]);
    const a2 = i2.type === "ReturnStatement" || i2.type === "ThrowStatement" || i2.type === "JSXExpressionContainer" && u2.type === "JSXAttribute" || r2.operator !== "|" && i2.type === "JsExpressionRoot" || r2.type !== "NGPipeExpression" && (i2.type === "NGRoot" && t2.parser === "__ng_binding" || i2.type === "NGMicrosyntaxExpression" && u2.type === "NGMicrosyntax" && u2.body.length === 1) || r2 === i2.body && i2.type === "ArrowFunctionExpression" || r2 !== i2.body && i2.type === "ForStatement" || i2.type === "ConditionalExpression" && u2.type !== "ReturnStatement" && u2.type !== "ThrowStatement" && !SD(u2) || i2.type === "TemplateLiteral", c2 = i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator" || i2.type === "ClassProperty" || i2.type === "PropertyDefinition" || i2.type === "TSAbstractClassProperty" || i2.type === "ClassPrivateProperty" || wD(i2), l2 = CD(r2.left) && AD(r2.operator, r2.left.operator);
    if (a2 || ND(r2) && !l2 || !ND(r2) && c2)
      return pD(s2);
    if (s2.length === 0)
      return "";
    const p2 = bD(r2.right), f2 = s2.findIndex((e3) => typeof e3 != "string" && !Array.isArray(e3) && e3.type === "group"), d2 = s2.slice(0, f2 === -1 ? 1 : f2 + 1), h2 = s2.slice(d2.length, p2 ? -1 : void 0), g2 = Symbol("logicalChain-" + ++TD), m2 = pD([...d2, fD(h2)], { id: g2 });
    if (!p2)
      return m2;
    const y2 = sD(s2);
    return pD([m2, gD(y2, { groupId: g2 })]);
  }, shouldInlineLogicalExpression: ND };
  const { builders: { join: PD, line: OD, group: ID } } = eu$1, { hasNode: LD, hasComment: jD, getComments: _D } = Gh, { printBinaryishExpression: MD } = kD;
  function RD(e2, t2, n2) {
    return e2.type === "NGMicrosyntaxKeyedExpression" && e2.key.name === "of" && t2 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
  }
  var $D = { printAngular: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (r2.type.startsWith("NG"))
      switch (r2.type) {
        case "NGRoot":
          return [n2("node"), jD(r2.node) ? " //" + _D(r2.node)[0].value.trimEnd() : ""];
        case "NGPipeExpression":
          return MD(e2, t2, n2);
        case "NGChainedExpression":
          return ID(PD([";", OD], e2.map((e3) => function(e4) {
            return LD(e4.getValue(), (e5) => {
              switch (e5.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }(e3) ? n2() : ["(", n2(), ")"], "expressions")));
        case "NGEmptyExpression":
          return "";
        case "NGQuotedExpression":
          return [r2.prefix, ": ", r2.value.trim()];
        case "NGMicrosyntax":
          return e2.map((e3, t3) => [t3 === 0 ? "" : RD(e3.getValue(), t3, r2) ? " " : [";", OD], n2()], "body");
        case "NGMicrosyntaxKey":
          return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r2.name) ? r2.name : JSON.stringify(r2.name);
        case "NGMicrosyntaxExpression":
          return [n2("expression"), r2.alias === null ? "" : [" as ", n2("alias")]];
        case "NGMicrosyntaxKeyedExpression": {
          const t3 = e2.getName(), i2 = e2.getParentNode(), u2 = RD(r2, t3, i2) || (t3 === 1 && (r2.key.name === "then" || r2.key.name === "else") || t3 === 2 && r2.key.name === "else" && i2.body[t3 - 1].type === "NGMicrosyntaxKeyedExpression" && i2.body[t3 - 1].key.name === "then") && i2.body[0].type === "NGMicrosyntaxExpression";
          return [n2("key"), u2 ? " " : ": ", n2("expression")];
        }
        case "NGMicrosyntaxLet":
          return ["let ", n2("key"), r2.value === null ? "" : [" = ", n2("value")]];
        case "NGMicrosyntaxAs":
          return [n2("key"), " as ", n2("alias")];
        default:
          throw new Error(`Unknown Angular node type: ${JSON.stringify(r2.type)}.`);
      }
  } };
  const { printComments: VD, printDanglingComments: WD } = Wf, { builders: { line: qD, hardline: UD, softline: zD, group: GD, indent: HD, conditionalGroup: JD, fill: XD, ifBreak: YD, lineSuffixBoundary: KD, join: QD }, utils: { willBreak: ZD } } = eu$1, { getLast: eE, getPreferredQuote: tE } = yi$2, { isJsxNode: nE, rawText: rE, isLiteral: iE, isCallExpression: uE, isStringLiteral: oE, isBinaryish: sE, hasComment: aE, CommentCheckFlags: cE, hasNodeIgnoreComment: lE } = Gh, { willPrintOwnComments: pE } = jy, fE = (e2) => e2 === "" || e2 === qD || e2 === UD || e2 === zD;
  function dE(e2, t2, n2) {
    const r2 = e2.getValue();
    if (r2.type === "JSXElement" && function(e3) {
      if (e3.children.length === 0)
        return true;
      if (e3.children.length > 1)
        return false;
      const t3 = e3.children[0];
      return iE(t3) && !bE(t3);
    }(r2))
      return [n2("openingElement"), n2("closingElement")];
    const i2 = r2.type === "JSXElement" ? n2("openingElement") : n2("openingFragment"), u2 = r2.type === "JSXElement" ? n2("closingElement") : n2("closingFragment");
    if (r2.children.length === 1 && r2.children[0].type === "JSXExpressionContainer" && (r2.children[0].expression.type === "TemplateLiteral" || r2.children[0].expression.type === "TaggedTemplateExpression"))
      return [i2, ...e2.map(n2, "children"), u2];
    r2.children = r2.children.map((e3) => function(e4) {
      return e4.type === "JSXExpressionContainer" && iE(e4.expression) && e4.expression.value === " " && !aE(e4.expression);
    }(e3) ? { type: "JSXText", value: " ", raw: " " } : e3);
    const o2 = r2.children.filter(nE).length > 0, s2 = r2.children.filter((e3) => e3.type === "JSXExpressionContainer").length > 1, a2 = r2.type === "JSXElement" && r2.openingElement.attributes.length > 1;
    let c2 = ZD(i2) || o2 || a2 || s2;
    const l2 = e2.getParentNode().rootMarker === "mdx", p2 = t2.singleQuote ? "{' '}" : '{" "}', f2 = l2 ? " " : YD([p2, zD], " "), d2 = function(e3, t3, n3, r3, i3) {
      const u3 = [];
      return e3.each((e4, t4, o3) => {
        const s3 = e4.getValue();
        if (iE(s3)) {
          const e5 = rE(s3);
          if (bE(s3)) {
            const n4 = e5.split(DE);
            if (n4[0] === "") {
              if (u3.push(""), n4.shift(), /\n/.test(n4[0])) {
                const e6 = o3[t4 + 1];
                u3.push(gE(i3, n4[1], s3, e6));
              } else
                u3.push(r3);
              n4.shift();
            }
            let a3;
            if (eE(n4) === "" && (n4.pop(), a3 = n4.pop()), n4.length === 0)
              return;
            for (const [e6, t5] of n4.entries())
              e6 % 2 == 1 ? u3.push(qD) : u3.push(t5);
            if (a3 !== void 0)
              if (/\n/.test(a3)) {
                const e6 = o3[t4 + 1];
                u3.push(gE(i3, eE(u3), s3, e6));
              } else
                u3.push(r3);
            else {
              const e6 = o3[t4 + 1];
              u3.push(hE(i3, eE(u3), s3, e6));
            }
          } else
            /\n/.test(e5) ? e5.match(/\n/g).length > 1 && u3.push("", UD) : u3.push("", r3);
        } else {
          const e5 = n3();
          u3.push(e5);
          const r4 = o3[t4 + 1];
          if (r4 && bE(r4)) {
            const e6 = CE(rE(r4)).split(DE)[0];
            u3.push(hE(i3, e6, s3, r4));
          } else
            u3.push(UD);
        }
      }, "children"), u3;
    }(e2, 0, n2, f2, r2.openingElement && r2.openingElement.name && r2.openingElement.name.name === "fbt"), h2 = r2.children.some((e3) => bE(e3));
    for (let e3 = d2.length - 2; e3 >= 0; e3--) {
      const t3 = d2[e3] === "" && d2[e3 + 1] === "", n3 = d2[e3] === UD && d2[e3 + 1] === "" && d2[e3 + 2] === UD, r3 = (d2[e3] === zD || d2[e3] === UD) && d2[e3 + 1] === "" && d2[e3 + 2] === f2, i3 = d2[e3] === f2 && d2[e3 + 1] === "" && (d2[e3 + 2] === zD || d2[e3 + 2] === UD), u3 = d2[e3] === f2 && d2[e3 + 1] === "" && d2[e3 + 2] === f2, o3 = d2[e3] === zD && d2[e3 + 1] === "" && d2[e3 + 2] === UD || d2[e3] === UD && d2[e3 + 1] === "" && d2[e3 + 2] === zD;
      n3 && h2 || t3 || r3 || u3 || o3 ? d2.splice(e3, 2) : i3 && d2.splice(e3 + 1, 2);
    }
    for (; d2.length > 0 && fE(eE(d2)); )
      d2.pop();
    for (; d2.length > 1 && fE(d2[0]) && fE(d2[1]); )
      d2.shift(), d2.shift();
    const g2 = [];
    for (const [e3, t3] of d2.entries()) {
      if (t3 === f2) {
        if (e3 === 1 && d2[e3 - 1] === "") {
          if (d2.length === 2) {
            g2.push(p2);
            continue;
          }
          g2.push([p2, UD]);
          continue;
        }
        if (e3 === d2.length - 1) {
          g2.push(p2);
          continue;
        }
        if (d2[e3 - 1] === "" && d2[e3 - 2] === UD) {
          g2.push(p2);
          continue;
        }
      }
      g2.push(t3), ZD(t3) && (c2 = true);
    }
    const m2 = h2 ? XD(g2) : GD(g2, { shouldBreak: true });
    if (l2)
      return m2;
    const y2 = GD([i2, HD([UD, m2]), UD, u2]);
    return c2 ? y2 : JD([GD([i2, ...d2, u2]), y2]);
  }
  function hE(e2, t2, n2, r2) {
    return e2 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t2.length === 1 ? zD : UD : zD;
  }
  function gE(e2, t2, n2, r2) {
    return e2 ? UD : t2.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? UD : zD : UD;
  }
  function mE(e2, t2, n2) {
    return function(e3, t3, n3) {
      const r2 = e3.getParentNode();
      if (!r2)
        return t3;
      if ({ ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[r2.type])
        return t3;
      const i2 = e3.match(void 0, (e4) => e4.type === "ArrowFunctionExpression", uE, (e4) => e4.type === "JSXExpressionContainer"), u2 = Qy(e3, n3);
      return GD([u2 ? "" : YD("("), HD([zD, t3]), zD, u2 ? "" : YD(")")], { shouldBreak: i2 });
    }(e2, VD(e2, dE(e2, t2, n2), t2), t2);
  }
  function yE(e2, t2, n2) {
    const r2 = e2.getValue();
    return ["{", e2.call((e3) => {
      const r3 = ["...", n2()], i2 = e3.getValue();
      return aE(i2) && pE(e3) ? [HD([zD, VD(e3, r3, t2)]), zD] : r3;
    }, r2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
  }
  const DE = new RegExp("([ \n\r	]+)"), EE = new RegExp("[^ \n\r	]"), CE = (e2) => e2.replace(new RegExp("(?:^" + DE.source + "|" + DE.source + "$)"), "");
  function bE(e2) {
    return iE(e2) && (EE.test(rE(e2)) || !/\n/.test(rE(e2)));
  }
  var AE = { hasJsxIgnoreComment: function(e2) {
    const t2 = e2.getValue(), n2 = e2.getParentNode();
    if (!(n2 && t2 && nE(t2) && nE(n2)))
      return false;
    let r2 = null;
    for (let e3 = n2.children.indexOf(t2); e3 > 0; e3--) {
      const t3 = n2.children[e3 - 1];
      if (t3.type !== "JSXText" || bE(t3)) {
        r2 = t3;
        break;
      }
    }
    return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && lE(r2.expression);
  }, printJsx: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (r2.type.startsWith("JSX"))
      switch (r2.type) {
        case "JSXAttribute":
          return function(e3, t3, n3) {
            const r3 = e3.getValue(), i2 = [];
            if (i2.push(n3("name")), r3.value) {
              let e4;
              if (oE(r3.value)) {
                let n4 = rE(r3.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                const i3 = tE(n4, t3.jsxSingleQuote ? "'" : '"'), u2 = i3 === "'" ? "&apos;" : "&quot;";
                n4 = n4.slice(1, -1).replace(new RegExp(i3, "g"), u2), e4 = [i3, n4, i3];
              } else
                e4 = n3("value");
              i2.push("=", e4);
            }
            return i2;
          }(e2, t2, n2);
        case "JSXIdentifier":
          return String(r2.name);
        case "JSXNamespacedName":
          return QD(":", [n2("namespace"), n2("name")]);
        case "JSXMemberExpression":
          return QD(".", [n2("object"), n2("property")]);
        case "JSXSpreadAttribute":
          return yE(e2, t2, n2);
        case "JSXSpreadChild":
          return yE(e2, t2, n2);
        case "JSXExpressionContainer":
          return function(e3, t3, n3) {
            const r3 = e3.getValue(), i2 = e3.getParentNode(0), u2 = r3.expression.type === "JSXEmptyExpression" || !aE(r3.expression) && (r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression" || r3.expression.type === "ArrowFunctionExpression" || uE(r3.expression) || r3.expression.type === "FunctionExpression" || r3.expression.type === "TemplateLiteral" || r3.expression.type === "TaggedTemplateExpression" || r3.expression.type === "DoExpression" || nE(i2) && (r3.expression.type === "ConditionalExpression" || sE(r3.expression)));
            return GD(u2 ? ["{", n3("expression"), KD, "}"] : ["{", HD([zD, n3("expression")]), zD, KD, "}"]);
          }(e2, 0, n2);
        case "JSXFragment":
        case "JSXElement":
          return mE(e2, t2, n2);
        case "JSXOpeningElement":
          return function(e3, t3, n3) {
            const r3 = e3.getValue(), i2 = r3.name && aE(r3.name) || r3.typeParameters && aE(r3.typeParameters);
            if (r3.selfClosing && r3.attributes.length === 0 && !i2)
              return ["<", n3("name"), n3("typeParameters"), " />"];
            if (r3.attributes && r3.attributes.length === 1 && r3.attributes[0].value && oE(r3.attributes[0].value) && !r3.attributes[0].value.value.includes("\n") && !i2 && !aE(r3.attributes[0]))
              return GD(["<", n3("name"), n3("typeParameters"), " ", ...e3.map(n3, "attributes"), r3.selfClosing ? " />" : ">"]);
            const u2 = r3.attributes.length > 0 && aE(eE(r3.attributes), cE.Trailing), o2 = r3.attributes.length === 0 && !i2 || (t3.bracketSameLine || t3.jsxBracketSameLine) && (!i2 || r3.attributes.length > 0) && !u2, s2 = r3.attributes && r3.attributes.some((e4) => e4.value && oE(e4.value) && e4.value.value.includes("\n"));
            return GD(["<", n3("name"), n3("typeParameters"), HD(e3.map(() => [qD, n3()], "attributes")), r3.selfClosing ? qD : o2 ? ">" : zD, r3.selfClosing ? "/>" : o2 ? "" : ">"], { shouldBreak: s2 });
          }(e2, t2, n2);
        case "JSXClosingElement":
          return function(e3, t3, n3) {
            const r3 = e3.getValue(), i2 = [];
            i2.push("</");
            const u2 = n3("name");
            return aE(r3.name, cE.Leading | cE.Line) ? i2.push(HD([UD, u2]), UD) : aE(r3.name, cE.Leading | cE.Block) ? i2.push(" ", u2) : i2.push(u2), i2.push(">"), i2;
          }(e2, 0, n2);
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          return function(e3, t3) {
            const n3 = e3.getValue(), r3 = aE(n3), i2 = aE(n3, cE.Line), u2 = n3.type === "JSXOpeningFragment";
            return [u2 ? "<" : "</", HD([i2 ? UD : r3 && !u2 ? " " : "", WD(e3, t3, true)]), i2 ? UD : "", ">"];
          }(e2, t2);
        case "JSXEmptyExpression":
          return function(e3, t3) {
            const n3 = e3.getValue(), r3 = aE(n3, cE.Line);
            return [WD(e3, t3, !r3), r3 ? UD : ""];
          }(e2, t2);
        case "JSXText":
          throw new Error("JSXTest should be handled by JSXElement");
        default:
          throw new Error(`Unknown JSX node type: ${JSON.stringify(r2.type)}.`);
      }
  } };
  Ze$3({ target: "Array", proto: true }, { flat: function() {
    var e2 = arguments.length ? arguments[0] : void 0, t2 = q$3(this), n2 = Le$3(t2.length), r2 = Wn$2(t2, 0);
    return r2.length = $n$2(r2, t2, t2, n2, 0, e2 === void 0 ? 1 : Oe$3(e2)), r2;
  } });
  const { isNonEmptyArray: vE } = yi$2, { builders: { indent: FE, join: SE, line: xE } } = eu$1, { isFlowAnnotationComment: wE } = Gh;
  function TE(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!r2.typeAnnotation)
      return "";
    const i2 = e2.getParentNode(), u2 = r2.definite || i2 && i2.type === "VariableDeclarator" && i2.definite, o2 = i2.type === "DeclareFunction" && i2.id === r2;
    return wE(t2.originalText, r2.typeAnnotation) ? [" /*: ", n2("typeAnnotation"), " */"] : [o2 ? "" : u2 ? "!: " : ": ", n2("typeAnnotation")];
  }
  var BE = { printOptionalToken: function(e2) {
    const t2 = e2.getValue();
    return !t2.optional || t2.type === "Identifier" && t2 === e2.getParentNode().key ? "" : t2.type === "OptionalCallExpression" || t2.type === "OptionalMemberExpression" && t2.computed ? "?." : "?";
  }, printFunctionTypeParameters: function(e2, t2, n2) {
    const r2 = e2.getValue();
    return r2.typeArguments ? n2("typeArguments") : r2.typeParameters ? n2("typeParameters") : "";
  }, printBindExpressionCallee: function(e2, t2, n2) {
    return ["::", n2("callee")];
  }, printTypeScriptModifiers: function(e2, t2, n2) {
    const r2 = e2.getValue();
    return vE(r2.modifiers) ? [SE(" ", e2.map(n2, "modifiers")), " "] : "";
  }, printTypeAnnotation: TE, printRestSpread: function(e2, t2, n2) {
    return ["...", n2("argument"), TE(e2, t2, n2)];
  }, adjustClause: function(e2, t2, n2) {
    return e2.type === "EmptyStatement" ? ";" : e2.type === "BlockStatement" || n2 ? [" ", t2] : FE([xE, t2]);
  } };
  const { printDanglingComments: NE } = Wf, { builders: { line: kE, softline: PE, hardline: OE, group: IE, indent: LE, ifBreak: jE, fill: _E } } = eu$1, { getLast: ME, hasNewline: RE } = yi$2, { shouldPrintComma: $E, hasComment: VE, CommentCheckFlags: WE, isNextLineEmpty: qE, isNumericLiteral: UE, isSignedNumericLiteral: zE } = Gh, { locStart: GE } = zc, { printOptionalToken: HE, printTypeAnnotation: JE } = BE;
  function XE(e2, t2) {
    return e2.elements.length > 1 && e2.elements.every((e3) => e3 && (UE(e3) || zE(e3) && !VE(e3.argument)) && !VE(e3, WE.Trailing | WE.Line, (e4) => !RE(t2.originalText, GE(e4), { backwards: true })));
  }
  function YE(e2, t2, n2, r2) {
    const i2 = [];
    let u2 = [];
    return e2.each((e3) => {
      i2.push(u2, IE(r2())), u2 = [",", kE], e3.getValue() && qE(e3.getValue(), t2) && u2.push(PE);
    }, n2), i2;
  }
  function KE(e2, t2, n2, r2) {
    const i2 = [];
    return e2.each((e3, u2, o2) => {
      const s2 = u2 === o2.length - 1;
      i2.push([n2(), s2 ? r2 : ","]), s2 || i2.push(qE(e3.getValue(), t2) ? [OE, OE] : VE(o2[u2 + 1], WE.Leading | WE.Line) ? OE : kE);
    }, "elements"), _E(i2);
  }
  var QE = { printArray: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [], u2 = r2.type === "TupleExpression" ? "#[" : "[";
    if (r2.elements.length === 0)
      VE(r2, WE.Dangling) ? i2.push(IE([u2, NE(e2, t2), PE, "]"])) : i2.push(u2, "]");
    else {
      const o2 = ME(r2.elements), s2 = !(o2 && o2.type === "RestElement"), a2 = o2 === null, c2 = Symbol("array"), l2 = !t2.__inJestEach && r2.elements.length > 1 && r2.elements.every((e3, t3, n3) => {
        const r3 = e3 && e3.type;
        if (r3 !== "ArrayExpression" && r3 !== "ObjectExpression")
          return false;
        const i3 = n3[t3 + 1];
        if (i3 && r3 !== i3.type)
          return false;
        const u3 = r3 === "ArrayExpression" ? "elements" : "properties";
        return e3[u3] && e3[u3].length > 1;
      }), p2 = XE(r2, t2), f2 = s2 ? a2 ? "," : $E(t2) ? p2 ? jE(",", "", { groupId: c2 }) : jE(",") : "" : "";
      i2.push(IE([u2, LE([PE, p2 ? KE(e2, t2, n2, f2) : [YE(e2, t2, "elements", n2), f2], NE(e2, t2, true)]), PE, "]"], { shouldBreak: l2, id: c2 }));
    }
    return i2.push(HE(e2), JE(e2, t2, n2)), i2;
  }, printArrayItems: YE, isConciselyPrintedArray: XE };
  const { printDanglingComments: ZE } = Wf, { getLast: eC, getPenultimate: tC } = yi$2, { getFunctionParameters: nC, hasComment: rC, CommentCheckFlags: iC, isFunctionCompositionArgs: uC, isJsxNode: oC, isLongCurriedCallExpression: sC, shouldPrintComma: aC, getCallArguments: cC, iterateCallArgumentsPath: lC, isNextLineEmpty: pC, isCallExpression: fC, isStringLiteral: dC, isObjectProperty: hC } = Gh, { builders: { line: gC, hardline: mC, softline: yC, group: DC, indent: EC, conditionalGroup: CC, ifBreak: bC, breakParent: AC }, utils: { willBreak: vC } } = eu$1, { ArgExpansionBailout: FC } = bo$2, { isConciselyPrintedArray: SC } = QE;
  function xC(e2, t2 = false) {
    return e2.type === "ObjectExpression" && (e2.properties.length > 0 || rC(e2)) || e2.type === "ArrayExpression" && (e2.elements.length > 0 || rC(e2)) || e2.type === "TSTypeAssertion" && xC(e2.expression) || e2.type === "TSAsExpression" && xC(e2.expression) || e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && (!e2.returnType || !e2.returnType.typeAnnotation || e2.returnType.typeAnnotation.type !== "TSTypeReference" || (n2 = e2.body).type === "BlockStatement" && (n2.body.some((e3) => e3.type !== "EmptyStatement") || rC(n2, iC.Dangling))) && (e2.body.type === "BlockStatement" || e2.body.type === "ArrowFunctionExpression" && xC(e2.body, true) || e2.body.type === "ObjectExpression" || e2.body.type === "ArrayExpression" || !t2 && (fC(e2.body) || e2.body.type === "ConditionalExpression") || oC(e2.body)) || e2.type === "DoExpression" || e2.type === "ModuleExpression";
    var n2;
  }
  var wC = function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.type === "ImportExpression", u2 = cC(r2);
    if (u2.length === 0)
      return ["(", ZE(e2, t2, true), ")"];
    if (function(e3) {
      return e3.length === 2 && e3[0].type === "ArrowFunctionExpression" && nC(e3[0]).length === 0 && e3[0].body.type === "BlockStatement" && e3[1].type === "ArrayExpression" && !e3.some((e4) => rC(e4));
    }(u2))
      return ["(", n2(["arguments", 0]), ", ", n2(["arguments", 1]), ")"];
    let o2 = false, s2 = false;
    const a2 = u2.length - 1, c2 = [];
    lC(e2, (e3, r3) => {
      const i3 = e3.getNode(), u3 = [n2()];
      r3 === a2 || (pC(i3, t2) ? (r3 === 0 && (s2 = true), o2 = true, u3.push(",", mC, mC)) : u3.push(",", gC)), c2.push(u3);
    });
    const l2 = i2 || r2.callee && r2.callee.type === "Import" || !aC(t2, "all") ? "" : ",";
    function p2() {
      return DC(["(", EC([gC, ...c2]), l2, gC, ")"], { shouldBreak: true });
    }
    if (o2 || e2.getParentNode().type !== "Decorator" && uC(u2))
      return p2();
    const f2 = function(e3) {
      if (e3.length !== 2)
        return false;
      const [t3, n3] = e3;
      if (t3.type === "ModuleExpression" && function(e4) {
        return e4.type === "ObjectExpression" && e4.properties.length === 1 && hC(e4.properties[0]) && e4.properties[0].key.type === "Identifier" && e4.properties[0].key.name === "type" && dC(e4.properties[0].value) && e4.properties[0].value.value === "module";
      }(n3))
        return true;
      return !rC(t3) && (t3.type === "FunctionExpression" || t3.type === "ArrowFunctionExpression" && t3.body.type === "BlockStatement") && n3.type !== "FunctionExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "ConditionalExpression" && !xC(n3);
    }(u2), d2 = function(e3, t3) {
      const n3 = eC(e3), r3 = tC(e3);
      return !rC(n3, iC.Leading) && !rC(n3, iC.Trailing) && xC(n3) && (!r3 || r3.type !== n3.type) && (e3.length !== 2 || r3.type !== "ArrowFunctionExpression" || n3.type !== "ArrayExpression") && !(e3.length > 1 && n3.type === "ArrayExpression" && SC(n3, t3));
    }(u2, t2);
    if (f2 || d2) {
      if (f2 ? c2.slice(1).some(vC) : c2.slice(0, -1).some(vC))
        return p2();
      let t3 = [];
      try {
        e2.try(() => {
          lC(e2, (e3, r3) => {
            f2 && r3 === 0 && (t3 = [[n2([], { expandFirstArg: true }), c2.length > 1 ? "," : "", s2 ? mC : gC, s2 ? mC : ""], ...c2.slice(1)]), d2 && r3 === a2 && (t3 = [...c2.slice(0, -1), n2([], { expandLastArg: true })]);
          });
        });
      } catch (e3) {
        if (e3 instanceof FC)
          return p2();
        throw e3;
      }
      return [c2.some(vC) ? AC : "", CC([["(", ...t3, ")"], f2 ? ["(", DC(t3[0], { shouldBreak: true }), ...t3.slice(1), ")"] : ["(", ...c2.slice(0, -1), DC(eC(t3), { shouldBreak: true }), ")"], p2()])];
    }
    const h2 = ["(", EC([yC, ...c2]), bC(l2), yC, ")"];
    return sC(e2) ? h2 : DC(h2, { shouldBreak: c2.some(vC) || o2 });
  };
  const { builders: { softline: TC, group: BC, indent: NC, label: kC } } = eu$1, { isNumericLiteral: PC, isMemberExpression: OC, isCallExpression: IC } = Gh, { printOptionalToken: LC } = BE;
  function jC(e2, t2, n2) {
    const r2 = n2("property"), i2 = e2.getValue(), u2 = LC(e2);
    return i2.computed ? !i2.property || PC(i2.property) ? [u2, "[", r2, "]"] : BC([u2, "[", NC([TC, r2]), TC, "]"]) : [u2, ".", r2];
  }
  var _C = { printMemberExpression: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = e2.getParentNode();
    let u2, o2 = 0;
    do {
      u2 = e2.getParentNode(o2), o2++;
    } while (u2 && (OC(u2) || u2.type === "TSNonNullExpression"));
    const s2 = n2("object"), a2 = jC(e2, t2, n2), c2 = u2 && (u2.type === "NewExpression" || u2.type === "BindExpression" || u2.type === "AssignmentExpression" && u2.left.type !== "Identifier") || r2.computed || r2.object.type === "Identifier" && r2.property.type === "Identifier" && !OC(i2) || (i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator") && (IC(r2.object) && r2.object.arguments.length > 0 || r2.object.type === "TSNonNullExpression" && IC(r2.object.expression) && r2.object.expression.arguments.length > 0 || s2.label === "member-chain");
    return kC(s2.label === "member-chain" ? "member-chain" : "member", [s2, c2 ? a2 : BC(NC([TC, a2]))]);
  }, printMemberLookup: jC };
  const { printComments: MC } = Wf, { getLast: RC, isNextLineEmptyAfterIndex: $C, getNextNonSpaceNonCommentCharacterIndex: VC } = yi$2, { isCallExpression: WC, isMemberExpression: qC, isFunctionOrArrowExpression: UC, isLongCurriedCallExpression: zC, isMemberish: GC, isNumericLiteral: HC, isSimpleCallArgument: JC, hasComment: XC, CommentCheckFlags: YC, isNextLineEmpty: KC } = Gh, { locEnd: QC } = zc, { builders: { join: ZC, hardline: eb, group: tb, indent: nb, conditionalGroup: rb, breakParent: ib, label: ub }, utils: { willBreak: ob } } = eu$1, { printMemberLookup: sb } = _C, { printOptionalToken: ab, printFunctionTypeParameters: cb, printBindExpressionCallee: lb } = BE;
  var pb = function(e2, t2, n2) {
    const r2 = e2.getParentNode(), i2 = !r2 || r2.type === "ExpressionStatement", u2 = [];
    function o2(e3) {
      const { originalText: n3 } = t2, r3 = VC(n3, e3, QC);
      return n3.charAt(r3) === ")" ? r3 !== false && $C(n3, r3 + 1) : KC(e3, t2);
    }
    function s2(e3) {
      const r3 = e3.getValue();
      WC(r3) && (GC(r3.callee) || WC(r3.callee)) ? (u2.unshift({ node: r3, printed: [MC(e3, [ab(e3), cb(e3, t2, n2), wC(e3, t2, n2)], t2), o2(r3) ? eb : ""] }), e3.call((e4) => s2(e4), "callee")) : GC(r3) ? (u2.unshift({ node: r3, needsParens: Qy(e3, t2), printed: MC(e3, qC(r3) ? sb(e3, t2, n2) : lb(e3, t2, n2), t2) }), e3.call((e4) => s2(e4), "object")) : r3.type === "TSNonNullExpression" ? (u2.unshift({ node: r3, printed: MC(e3, "!", t2) }), e3.call((e4) => s2(e4), "expression")) : u2.unshift({ node: r3, printed: n2() });
    }
    const a2 = e2.getValue();
    u2.unshift({ node: a2, printed: [ab(e2), cb(e2, t2, n2), wC(e2, t2, n2)] }), a2.callee && e2.call((e3) => s2(e3), "callee");
    const c2 = [];
    let l2 = [u2[0]], p2 = 1;
    for (; p2 < u2.length && (u2[p2].node.type === "TSNonNullExpression" || WC(u2[p2].node) || qC(u2[p2].node) && u2[p2].node.computed && HC(u2[p2].node.property)); ++p2)
      l2.push(u2[p2]);
    if (!WC(u2[0].node))
      for (; p2 + 1 < u2.length && (GC(u2[p2].node) && GC(u2[p2 + 1].node)); ++p2)
        l2.push(u2[p2]);
    c2.push(l2), l2 = [];
    let f2 = false;
    for (; p2 < u2.length; ++p2) {
      if (f2 && GC(u2[p2].node)) {
        if (u2[p2].node.computed && HC(u2[p2].node.property)) {
          l2.push(u2[p2]);
          continue;
        }
        c2.push(l2), l2 = [], f2 = false;
      }
      (WC(u2[p2].node) || u2[p2].node.type === "ImportExpression") && (f2 = true), l2.push(u2[p2]), XC(u2[p2].node, YC.Trailing) && (c2.push(l2), l2 = [], f2 = false);
    }
    function d2(e3) {
      return /^[A-Z]|^[$_]+$/.test(e3);
    }
    l2.length > 0 && c2.push(l2);
    const h2 = c2.length >= 2 && !XC(c2[1][0].node) && function(e3) {
      const n3 = e3[1].length > 0 && e3[1][0].node.computed;
      if (e3[0].length === 1) {
        const r4 = e3[0][0].node;
        return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || i2 && function(e4) {
          return e4.length <= t2.tabWidth;
        }(r4.name) || n3);
      }
      const r3 = RC(e3[0]).node;
      return qC(r3) && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
    }(c2);
    function g2(e3) {
      const t3 = e3.map((e4) => e4.printed);
      return e3.length > 0 && RC(e3).needsParens ? ["(", ...t3, ")"] : t3;
    }
    const m2 = c2.map(g2), y2 = m2, D2 = h2 ? 3 : 2, E2 = c2.flat(), C2 = E2.slice(1, -1).some((e3) => XC(e3.node, YC.Leading)) || E2.slice(0, -1).some((e3) => XC(e3.node, YC.Trailing)) || c2[D2] && XC(c2[D2][0].node, YC.Leading);
    if (c2.length <= D2 && !C2)
      return zC(e2) ? y2 : tb(y2);
    const b2 = RC(c2[h2 ? 1 : 0]).node, A2 = !WC(b2) && o2(b2), v2 = [g2(c2[0]), h2 ? c2.slice(1, 2).map(g2) : "", A2 ? eb : "", function(e3) {
      return e3.length === 0 ? "" : nb(tb([eb, ZC(eb, e3.map(g2))]));
    }(c2.slice(h2 ? 2 : 1))], F2 = u2.map(({ node: e3 }) => e3).filter(WC);
    let S2;
    return S2 = C2 || F2.length > 2 && F2.some((e3) => !e3.arguments.every((e4) => JC(e4, 0))) || m2.slice(0, -1).some(ob) || function() {
      const e3 = RC(RC(c2)).node, t3 = RC(m2);
      return WC(e3) && ob(t3) && F2.slice(0, -1).some((e4) => e4.arguments.some(UC));
    }() ? tb(v2) : [ob(y2) || A2 ? ib : "", rb([y2, v2])], ub("member-chain", S2);
  };
  const { builders: { join: fb, group: db } } = eu$1, { getCallArguments: hb, hasFlowAnnotationComment: gb, isCallExpression: mb, isMemberish: yb, isStringLiteral: Db, isTemplateOnItsOwnLine: Eb, isTestCall: Cb, iterateCallArgumentsPath: bb } = Gh, { printOptionalToken: Ab, printFunctionTypeParameters: vb } = BE;
  var Fb = { printCallExpression: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = e2.getParentNode(), u2 = r2.type === "NewExpression", o2 = r2.type === "ImportExpression", s2 = Ab(e2), a2 = hb(r2);
    if (a2.length > 0 && (!o2 && !u2 && function(e3, t3) {
      if (e3.callee.type !== "Identifier")
        return false;
      if (e3.callee.name === "require")
        return true;
      if (e3.callee.name === "define") {
        const n3 = hb(e3);
        return t3.type === "ExpressionStatement" && (n3.length === 1 || n3.length === 2 && n3[0].type === "ArrayExpression" || n3.length === 3 && Db(n3[0]) && n3[1].type === "ArrayExpression");
      }
      return false;
    }(r2, i2) || a2.length === 1 && Eb(a2[0], t2.originalText) || !u2 && Cb(r2, i2))) {
      const r3 = [];
      return bb(e2, () => {
        r3.push(n2());
      }), [u2 ? "new " : "", n2("callee"), s2, vb(e2, t2, n2), "(", fb(", ", r3), ")"];
    }
    const c2 = (t2.parser === "babel" || t2.parser === "babel-flow") && r2.callee && r2.callee.type === "Identifier" && gb(r2.callee.trailingComments);
    if (c2 && (r2.callee.trailingComments[0].printed = true), !o2 && !u2 && yb(r2.callee) && !e2.call((e3) => Qy(e3, t2), "callee"))
      return pb(e2, t2, n2);
    const l2 = [u2 ? "new " : "", o2 ? "import" : n2("callee"), s2, c2 ? `/*:: ${r2.callee.trailingComments[0].value.slice(2).trim()} */` : "", vb(e2, t2, n2), wC(e2, t2, n2)];
    return o2 || mb(r2.callee) ? db(l2) : l2;
  } };
  const { isNonEmptyArray: Sb, getStringWidth: xb } = yi$2, { builders: { line: wb, group: Tb, indent: Bb, indentIfBreak: Nb }, utils: { cleanDoc: kb, willBreak: Pb } } = eu$1, { hasLeadingOwnLineComment: Ob, isBinaryish: Ib, isStringLiteral: Lb, isLiteral: jb, isNumericLiteral: _b, isCallExpression: Mb, isMemberExpression: Rb, getCallArguments: $b, rawText: Vb, hasComment: Wb, isSignedNumericLiteral: qb, isObjectProperty: Ub } = Gh, { shouldInlineLogicalExpression: zb } = kD, { printCallExpression: Gb } = Fb;
  function Hb(e2, t2, n2, r2, i2, u2) {
    const o2 = function(e3, t3, n3, r3, i3) {
      const u3 = e3.getValue(), o3 = u3[i3];
      if (!o3)
        return "only-left";
      const s3 = !Jb(o3);
      if (e3.match(Jb, Xb, (e4) => !s3 || e4.type !== "ExpressionStatement" && e4.type !== "VariableDeclaration"))
        return s3 ? o3.type === "ArrowFunctionExpression" && o3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
      if (!s3 && Jb(o3.right) || Ob(t3.originalText, o3))
        return "break-after-operator";
      if (o3.type === "CallExpression" && o3.callee.name === "require" || t3.parser === "json5" || t3.parser === "json")
        return "never-break-after-operator";
      if (function(e4) {
        if (Xb(e4)) {
          const t4 = e4.left || e4.id;
          return t4.type === "ObjectPattern" && t4.properties.length > 2 && t4.properties.some((e5) => Ub(e5) && (!e5.shorthand || e5.value && e5.value.type === "AssignmentPattern"));
        }
        return false;
      }(u3) || function(e4) {
        const t4 = function(e5) {
          if (function(e6) {
            return e6.type === "TSTypeAliasDeclaration" || e6.type === "TypeAlias";
          }(e5) && e5.typeParameters && e5.typeParameters.params)
            return e5.typeParameters.params;
          return null;
        }(e4);
        if (Sb(t4)) {
          const n4 = e4.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
          if (t4.length > 1 && t4.some((e5) => e5[n4] || e5.default))
            return true;
        }
        return false;
      }(u3) || function(e4) {
        if (e4.type !== "VariableDeclarator")
          return false;
        const { typeAnnotation: t4 } = e4.id;
        if (!t4 || !t4.typeAnnotation)
          return false;
        const n4 = Yb(t4.typeAnnotation);
        return Sb(n4) && n4.length > 1 && n4.some((e5) => Sb(Yb(e5)) || e5.type === "TSConditionalType");
      }(u3))
        return "break-lhs";
      const a2 = function(e4, t4, n4) {
        if (!Ub(e4))
          return false;
        t4 = kb(t4);
        const r4 = 3;
        return typeof t4 == "string" && xb(t4) < n4.tabWidth + r4;
      }(u3, r3, t3);
      if (e3.call(() => function(e4, t4, n4, r4) {
        const i4 = e4.getValue();
        if (Ib(i4) && !zb(i4))
          return true;
        switch (i4.type) {
          case "StringLiteralTypeAnnotation":
          case "SequenceExpression":
            return true;
          case "ConditionalExpression": {
            const { test: e5 } = i4;
            return Ib(e5) && !zb(e5);
          }
          case "ClassExpression":
            return Sb(i4.decorators);
        }
        if (r4)
          return false;
        let u4 = i4;
        const o4 = [];
        for (; ; )
          if (u4.type === "UnaryExpression")
            u4 = u4.argument, o4.push("argument");
          else {
            if (u4.type !== "TSNonNullExpression")
              break;
            u4 = u4.expression, o4.push("expression");
          }
        if (Lb(u4) || e4.call(() => Kb(e4, t4, n4), ...o4))
          return true;
        return false;
      }(e3, t3, n3, a2), i3))
        return "break-after-operator";
      if (a2 || o3.type === "TemplateLiteral" || o3.type === "TaggedTemplateExpression" || o3.type === "BooleanLiteral" || _b(o3) || o3.type === "ClassExpression")
        return "never-break-after-operator";
      return "fluid";
    }(e2, t2, n2, r2, u2), s2 = n2(u2, { assignmentLayout: o2 });
    switch (o2) {
      case "break-after-operator":
        return Tb([Tb(r2), i2, Tb(Bb([wb, s2]))]);
      case "never-break-after-operator":
        return Tb([Tb(r2), i2, " ", s2]);
      case "fluid": {
        const e3 = Symbol("assignment");
        return Tb([Tb(r2), i2, Tb(Bb(wb), { id: e3 }), Nb(s2, { groupId: e3 })]);
      }
      case "break-lhs":
        return Tb([r2, i2, " ", Tb(s2)]);
      case "chain":
        return [Tb(r2), i2, wb, s2];
      case "chain-tail":
        return [Tb(r2), i2, Bb([wb, s2])];
      case "chain-tail-arrow-chain":
        return [Tb(r2), i2, s2];
      case "only-left":
        return r2;
    }
  }
  function Jb(e2) {
    return e2.type === "AssignmentExpression";
  }
  function Xb(e2) {
    return Jb(e2) || e2.type === "VariableDeclarator";
  }
  function Yb(e2) {
    return function(e3) {
      return e3.type === "TSTypeReference" || e3.type === "GenericTypeAnnotation";
    }(e2) && e2.typeParameters && e2.typeParameters.params ? e2.typeParameters.params : null;
  }
  function Kb(e2, t2, n2, r2 = false) {
    const i2 = e2.getValue(), u2 = () => Kb(e2, t2, n2, true);
    if (i2.type === "TSNonNullExpression")
      return e2.call(u2, "expression");
    if (Mb(i2)) {
      if (Gb(e2, t2, n2).label === "member-chain")
        return false;
      const r3 = $b(i2);
      return !!(r3.length === 0 || r3.length === 1 && function(e3, { printWidth: t3 }) {
        if (Wb(e3))
          return false;
        const n3 = 0.25 * t3;
        if (e3.type === "ThisExpression" || e3.type === "Identifier" && e3.name.length <= n3 || qb(e3) && !Wb(e3.argument))
          return true;
        const r4 = e3.type === "Literal" && "regex" in e3 && e3.regex.pattern || e3.type === "RegExpLiteral" && e3.pattern;
        if (r4)
          return r4.length <= n3;
        if (Lb(e3))
          return Vb(e3).length <= n3;
        if (e3.type === "TemplateLiteral")
          return e3.expressions.length === 0 && e3.quasis[0].value.raw.length <= n3 && !e3.quasis[0].value.raw.includes("\n");
        return jb(e3);
      }(r3[0], t2)) && (!function(e3, t3) {
        const n3 = function(e4) {
          return e4.typeParameters && e4.typeParameters.params || e4.typeArguments && e4.typeArguments.params;
        }(e3);
        if (Sb(n3)) {
          if (n3.length > 1)
            return true;
          if (n3.length === 1) {
            const e4 = n3[0];
            if (e4.type === "TSUnionType" || e4.type === "UnionTypeAnnotation" || e4.type === "TSIntersectionType" || e4.type === "IntersectionTypeAnnotation")
              return true;
          }
          const r4 = e3.typeParameters ? "typeParameters" : "typeArguments";
          if (Pb(t3(r4)))
            return true;
        }
        return false;
      }(i2, n2) && e2.call(u2, "callee"));
    }
    return Rb(i2) ? e2.call(u2, "object") : r2 && (i2.type === "Identifier" || i2.type === "ThisExpression");
  }
  var Qb = { printVariableDeclarator: function(e2, t2, n2) {
    return Hb(e2, t2, n2, n2("id"), " =", "init");
  }, printAssignmentExpression: function(e2, t2, n2) {
    const r2 = e2.getValue();
    return Hb(e2, t2, n2, n2("left"), [" ", r2.operator], "right");
  }, printAssignment: Hb };
  const { getNextNonSpaceNonCommentCharacter: Zb } = yi$2, { printDanglingComments: eA } = Wf, { builders: { line: tA, hardline: nA, softline: rA, group: iA, indent: uA, ifBreak: oA }, utils: { removeLines: sA, willBreak: aA } } = eu$1, { getFunctionParameters: cA, iterateFunctionParametersPath: lA, isSimpleType: pA, isTestCall: fA, isTypeAnnotationAFunction: dA, isObjectType: hA, isObjectTypePropertyAFunction: gA, hasRestParameter: mA, shouldPrintComma: yA, hasComment: DA, isNextLineEmpty: EA } = Gh, { locEnd: CA } = zc, { ArgExpansionBailout: bA } = bo$2, { printFunctionTypeParameters: AA } = BE;
  function vA(e2) {
    if (!e2)
      return false;
    const t2 = cA(e2);
    if (t2.length !== 1)
      return false;
    const [n2] = t2;
    return !DA(n2) && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && hA(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && hA(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
  }
  var FA = { printFunctionParameters: function(e2, t2, n2, r2, i2) {
    const u2 = e2.getValue(), o2 = cA(u2), s2 = i2 ? AA(e2, n2, t2) : "";
    if (o2.length === 0)
      return [s2, "(", eA(e2, n2, true, (e3) => Zb(n2.originalText, e3, CA) === ")"), ")"];
    const a2 = e2.getParentNode(), c2 = fA(a2), l2 = vA(u2), p2 = [];
    if (lA(e2, (e3, r3) => {
      const i3 = r3 === o2.length - 1;
      i3 && u2.rest && p2.push("..."), p2.push(t2()), i3 || (p2.push(","), c2 || l2 ? p2.push(" ") : EA(o2[r3], n2) ? p2.push(nA, nA) : p2.push(tA));
    }), r2) {
      if (aA(s2) || aA(p2))
        throw new bA();
      return iA([sA(s2), "(", sA(p2), ")"]);
    }
    const f2 = o2.every((e3) => !e3.decorators);
    return l2 && f2 || c2 ? [s2, "(", ...p2, ")"] : (gA(a2) || dA(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === u2) && o2.length === 1 && o2[0].name === null && u2.this !== o2[0] && o2[0].typeAnnotation && u2.typeParameters === null && pA(o2[0].typeAnnotation) && !u2.rest ? n2.arrowParens === "always" ? ["(", ...p2, ")"] : p2 : [s2, "(", uA([rA, ...p2]), oA(!mA(u2) && yA(n2, "all") ? "," : ""), rA, ")"];
  }, shouldHugFunctionParameters: vA, shouldGroupFunctionParameters: function(e2, t2) {
    const n2 = function(e3) {
      let t3;
      return e3.returnType ? (t3 = e3.returnType, t3.typeAnnotation && (t3 = t3.typeAnnotation)) : e3.typeAnnotation && (t3 = e3.typeAnnotation), t3;
    }(e2);
    if (!n2)
      return false;
    const r2 = e2.typeParameters && e2.typeParameters.params;
    if (r2) {
      if (r2.length > 1)
        return false;
      if (r2.length === 1) {
        const e3 = r2[0];
        if (e3.constraint || e3.default)
          return false;
      }
    }
    return cA(e2).length === 1 && (hA(n2) || aA(t2));
  } };
  const { printComments: SA, printDanglingComments: xA } = Wf, { getLast: wA } = yi$2, { builders: { group: TA, join: BA, line: NA, softline: kA, indent: PA, align: OA, ifBreak: IA } } = eu$1, { locStart: LA } = zc, { isSimpleType: jA, isObjectType: _A, hasLeadingOwnLineComment: MA, isObjectTypePropertyAFunction: RA, shouldPrintComma: $A } = Gh, { printAssignment: VA } = Qb, { printFunctionParameters: WA, shouldGroupFunctionParameters: qA } = FA, { printArrayItems: UA } = QE;
  function zA(e2) {
    if (jA(e2) || _A(e2))
      return true;
    if (e2.type === "UnionTypeAnnotation" || e2.type === "TSUnionType") {
      const t2 = e2.types.filter((e3) => e3.type === "VoidTypeAnnotation" || e3.type === "TSVoidKeyword" || e3.type === "NullLiteralTypeAnnotation" || e3.type === "TSNullKeyword").length, n2 = e2.types.some((e3) => e3.type === "ObjectTypeAnnotation" || e3.type === "TSTypeLiteral" || e3.type === "GenericTypeAnnotation" || e3.type === "TSTypeReference");
      if (e2.types.length - 1 === t2 && n2)
        return true;
    }
    return false;
  }
  var GA = { printOpaqueType: function(e2, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e2.getValue(), u2 = [];
    return u2.push("opaque type ", n2("id"), n2("typeParameters")), i2.supertype && u2.push(": ", n2("supertype")), i2.impltype && u2.push(" = ", n2("impltype")), u2.push(r2), u2;
  }, printTypeAlias: function(e2, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e2.getValue(), u2 = [];
    i2.declare && u2.push("declare "), u2.push("type ", n2("id"), n2("typeParameters"));
    const o2 = i2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
    return [VA(e2, t2, n2, u2, " =", o2), r2];
  }, printIntersectionType: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = e2.map(n2, "types"), u2 = [];
    let o2 = false;
    for (let e3 = 0; e3 < i2.length; ++e3)
      e3 === 0 ? u2.push(i2[e3]) : _A(r2.types[e3 - 1]) && _A(r2.types[e3]) ? u2.push([" & ", o2 ? PA(i2[e3]) : i2[e3]]) : _A(r2.types[e3 - 1]) || _A(r2.types[e3]) ? (e3 > 1 && (o2 = true), u2.push(" & ", e3 > 1 ? PA(i2[e3]) : i2[e3])) : u2.push(PA([" &", NA, i2[e3]]));
    return TA(u2);
  }, printUnionType: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = e2.getParentNode(), u2 = !(i2.type === "TypeParameterInstantiation" || i2.type === "TSTypeParameterInstantiation" || i2.type === "GenericTypeAnnotation" || i2.type === "TSTypeReference" || i2.type === "TSTypeAssertion" || i2.type === "TupleTypeAnnotation" || i2.type === "TSTupleType" || i2.type === "FunctionTypeParam" && !i2.name && e2.getParentNode(1).this !== i2 || (i2.type === "TypeAlias" || i2.type === "VariableDeclarator" || i2.type === "TSTypeAliasDeclaration") && MA(t2.originalText, r2)), o2 = zA(r2), s2 = e2.map((e3) => {
      let r3 = n2();
      return o2 || (r3 = OA(2, r3)), SA(e3, r3, t2);
    }, "types");
    if (o2)
      return BA(" | ", s2);
    const a2 = u2 && !MA(t2.originalText, r2), c2 = [IA([a2 ? NA : "", "| "]), BA([NA, "| "], s2)];
    return Qy(e2, t2) ? TA([PA(c2), kA]) : i2.type === "TupleTypeAnnotation" && i2.types.length > 1 || i2.type === "TSTupleType" && i2.elementTypes.length > 1 ? TA([PA([IA(["(", kA]), c2]), kA, IA(")")]) : TA(u2 ? PA(c2) : c2);
  }, printFunctionType: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [], u2 = e2.getParentNode(0), o2 = e2.getParentNode(1), s2 = e2.getParentNode(2);
    let a2 = r2.type === "TSFunctionType" || !((u2.type === "ObjectTypeProperty" || u2.type === "ObjectTypeInternalSlot") && !u2.variance && !u2.optional && LA(u2) === LA(r2) || u2.type === "ObjectTypeCallProperty" || s2 && s2.type === "DeclareFunction"), c2 = a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation");
    const l2 = c2 && a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation") && o2.type === "ArrowFunctionExpression";
    RA(u2) && (a2 = true, c2 = true), l2 && i2.push("(");
    const p2 = WA(e2, n2, t2, false, true), f2 = r2.returnType || r2.predicate || r2.typeAnnotation ? [a2 ? " => " : ": ", n2("returnType"), n2("predicate"), n2("typeAnnotation")] : "", d2 = qA(r2, f2);
    return i2.push(d2 ? TA(p2) : p2), f2 && i2.push(f2), l2 && i2.push(")"), TA(i2);
  }, printTupleType: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.type === "TSTupleType" ? "elementTypes" : "types", u2 = r2[i2].length > 0 && wA(r2[i2]).type === "TSRestType";
    return TA(["[", PA([kA, UA(e2, t2, i2, n2)]), IA($A(t2, "all") && !u2 ? "," : ""), xA(e2, t2, true), kA, "]"]);
  }, printIndexedAccessType: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.type === "OptionalIndexedAccessType" && r2.optional ? "?.[" : "[";
    return [n2("objectType"), i2, n2("indexType"), "]"];
  }, shouldHugType: zA };
  const { printDanglingComments: HA } = Wf, { builders: { join: JA, line: XA, hardline: YA, softline: KA, group: QA, indent: ZA, ifBreak: ev } } = eu$1, { isTestCall: tv, hasComment: nv, CommentCheckFlags: rv, isTSXFile: iv, shouldPrintComma: uv, getFunctionParameters: ov } = Gh, { createGroupIdMapper: sv } = yi$2, { shouldHugType: av } = GA, cv = sv("typeParameters");
  function lv(e2, t2) {
    const n2 = e2.getValue();
    if (!nv(n2, rv.Dangling))
      return "";
    const r2 = !nv(n2, rv.Line), i2 = HA(e2, t2, r2);
    return r2 ? i2 : [i2, YA];
  }
  var pv = { printTypeParameter: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [], u2 = e2.getParentNode();
    return u2.type === "TSMappedType" ? (i2.push("[", n2("name")), r2.constraint && i2.push(" in ", n2("constraint")), u2.nameType && i2.push(" as ", e2.callParent(() => n2("nameType"))), i2.push("]"), i2) : (r2.variance && i2.push(n2("variance")), i2.push(n2("name")), r2.bound && i2.push(": ", n2("bound")), r2.constraint && i2.push(" extends ", n2("constraint")), r2.default && i2.push(" = ", n2("default")), i2);
  }, printTypeParameters: function(e2, t2, n2, r2) {
    const i2 = e2.getValue();
    if (!i2[r2])
      return "";
    if (!Array.isArray(i2[r2]))
      return n2(r2);
    const u2 = e2.getNode(2);
    if (u2 && tv(u2) || i2[r2].length === 0 || i2[r2].length === 1 && (av(i2[r2][0]) || i2[r2][0].type === "NullableTypeAnnotation"))
      return ["<", JA(", ", e2.map(n2, r2)), lv(e2, t2), ">"];
    const o2 = i2.type === "TSTypeParameterInstantiation" ? "" : ov(i2).length === 1 && iv(t2) && !i2[r2][0].constraint && e2.getParentNode().type === "ArrowFunctionExpression" ? "," : uv(t2, "all") ? ev(",") : "";
    return QA(["<", ZA([KA, JA([",", XA], e2.map(n2, r2))]), o2, KA, ">"], { id: cv(i2) });
  }, getTypeParametersGroupId: cv };
  const { printComments: fv } = Wf, { printString: dv, printNumber: hv } = yi$2, { isNumericLiteral: gv, isSimpleNumber: mv, isStringLiteral: yv, isStringPropSafeToUnquote: Dv, rawText: Ev } = Gh, { printAssignment: Cv } = Qb, bv = new WeakMap();
  function Av(e2, t2, n2) {
    const r2 = e2.getNode();
    if (r2.computed)
      return ["[", n2("key"), "]"];
    const i2 = e2.getParentNode(), { key: u2 } = r2;
    if (r2.type === "ClassPrivateProperty" && u2.type === "Identifier")
      return ["#", n2("key")];
    if (t2.quoteProps === "consistent" && !bv.has(i2)) {
      const e3 = (i2.properties || i2.body || i2.members).some((e4) => !e4.computed && e4.key && yv(e4.key) && !Dv(e4, t2));
      bv.set(i2, e3);
    }
    if ((u2.type === "Identifier" || gv(u2) && mv(hv(Ev(u2))) && String(u2.value) === hv(Ev(u2)) && t2.parser !== "typescript" && t2.parser !== "babel-ts") && (t2.parser === "json" || t2.quoteProps === "consistent" && bv.get(i2))) {
      const n3 = dv(JSON.stringify(u2.type === "Identifier" ? u2.name : u2.value.toString()), t2);
      return e2.call((e3) => fv(e3, n3, t2), "key");
    }
    return Dv(r2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !bv.get(i2)) ? e2.call((e3) => fv(e3, /^\d/.test(u2.value) ? hv(u2.value) : u2.value, t2), "key") : n2("key");
  }
  var vv = { printProperty: function(e2, t2, n2) {
    return e2.getValue().shorthand ? n2("value") : Cv(e2, t2, n2, Av(e2, t2, n2), ":", "value");
  }, printPropertyKey: Av };
  const { printDanglingComments: Fv, printCommentsSeparately: Sv } = Wf, { getNextNonSpaceNonCommentCharacterIndex: xv } = yi$2, { builders: { line: wv, softline: Tv, group: Bv, indent: Nv, ifBreak: kv, hardline: Pv, join: Ov, indentIfBreak: Iv }, utils: { removeLines: Lv, willBreak: jv } } = eu$1, { ArgExpansionBailout: _v } = bo$2, { getFunctionParameters: Mv, hasLeadingOwnLineComment: Rv, isFlowAnnotationComment: $v, isJsxNode: Vv, isTemplateOnItsOwnLine: Wv, shouldPrintComma: qv, startsWithNoLookaheadToken: Uv, isBinaryish: zv, isLineComment: Gv, hasComment: Hv, getComments: Jv, CommentCheckFlags: Xv, isCallLikeExpression: Yv, isCallExpression: Kv, getCallArguments: Qv, hasNakedLeftSide: Zv, getLeftSide: eF } = Gh, { locEnd: tF } = zc, { printFunctionParameters: nF, shouldGroupFunctionParameters: rF } = FA, { printPropertyKey: iF } = vv, { printFunctionTypeParameters: uF } = BE;
  function oF(e2, t2, n2) {
    const r2 = e2.getNode(), i2 = nF(e2, n2, t2), u2 = aF(e2, n2, t2), o2 = rF(r2, u2), s2 = [uF(e2, t2, n2), Bv([o2 ? Bv(i2) : i2, u2])];
    return r2.body ? s2.push(" ", n2("body")) : s2.push(t2.semi ? ";" : ""), s2;
  }
  function sF(e2, t2) {
    if (t2.arrowParens === "always")
      return false;
    if (t2.arrowParens === "avoid") {
      return function(e3) {
        const t3 = Mv(e3);
        return !(t3.length !== 1 || e3.typeParameters || Hv(e3, Xv.Dangling) || t3[0].type !== "Identifier" || t3[0].typeAnnotation || Hv(t3[0]) || t3[0].optional || e3.predicate || e3.returnType);
      }(e2.getValue());
    }
    return false;
  }
  function aF(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = t2("returnType");
    if (r2.returnType && $v(n2.originalText, r2.returnType))
      return [" /*: ", i2, " */"];
    const u2 = [i2];
    return r2.returnType && r2.returnType.typeAnnotation && u2.unshift(": "), r2.predicate && u2.push(r2.returnType ? " " : ": ", t2("predicate")), u2;
  }
  function cF(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
    r2.argument && (!function(e3, t3) {
      if (Rv(e3.originalText, t3))
        return true;
      if (Zv(t3)) {
        let n3, r3 = t3;
        for (; n3 = eF(r3); )
          if (r3 = n3, Rv(e3.originalText, r3))
            return true;
      }
      return false;
    }(t2, r2.argument) ? zv(r2.argument) || r2.argument.type === "SequenceExpression" ? u2.push(Bv([kv(" (", " "), Nv([Tv, n2("argument")]), Tv, kv(")")])) : u2.push(" ", n2("argument")) : u2.push([" (", Nv([Pv, n2("argument")]), Pv, ")"]));
    const o2 = Jv(r2), s2 = Ln$2(o2), a2 = s2 && Gv(s2);
    return a2 && u2.push(i2), Hv(r2, Xv.Dangling) && u2.push(" ", Fv(e2, t2, true)), a2 || u2.push(i2), u2;
  }
  var lF = { printFunction: function(e2, t2, n2, r2) {
    const i2 = e2.getValue();
    let u2 = false;
    if ((i2.type === "FunctionDeclaration" || i2.type === "FunctionExpression") && r2 && r2.expandLastArg) {
      const t3 = e2.getParentNode();
      Kv(t3) && Qv(t3).length > 1 && (u2 = true);
    }
    const o2 = [];
    i2.type === "TSDeclareFunction" && i2.declare && o2.push("declare "), i2.async && o2.push("async "), i2.generator ? o2.push("function* ") : o2.push("function "), i2.id && o2.push(t2("id"));
    const s2 = nF(e2, t2, n2, u2), a2 = aF(e2, t2, n2), c2 = rF(i2, a2);
    return o2.push(uF(e2, n2, t2), Bv([c2 ? Bv(s2) : s2, a2]), i2.body ? " " : "", t2("body")), !n2.semi || !i2.declare && i2.body || o2.push(";"), o2;
  }, printArrowFunction: function(e2, t2, n2, r2) {
    let i2 = e2.getValue();
    const u2 = [], o2 = [];
    let s2 = false;
    if (function a3() {
      const c3 = function(e3, t3, n3, r3) {
        const i3 = [];
        if (e3.getValue().async && i3.push("async "), sF(e3, t3))
          i3.push(n3(["params", 0]));
        else {
          const u4 = r3 && (r3.expandLastArg || r3.expandFirstArg);
          let o3 = aF(e3, n3, t3);
          if (u4) {
            if (jv(o3))
              throw new _v();
            o3 = Bv(Lv(o3));
          }
          i3.push(Bv([nF(e3, n3, t3, u4, true), o3]));
        }
        const u3 = Fv(e3, t3, true, (e4) => {
          const n4 = xv(t3.originalText, e4, tF);
          return n4 !== false && t3.originalText.slice(n4, n4 + 2) === "=>";
        });
        return u3 && i3.push(" ", u3), i3;
      }(e2, t2, n2, r2);
      if (u2.length === 0)
        u2.push(c3);
      else {
        const { leading: n3, trailing: r3 } = Sv(e2, t2);
        u2.push([n3, c3]), o2.unshift(r3);
      }
      s2 = s2 || i2.returnType && Mv(i2).length > 0 || i2.typeParameters || Mv(i2).some((e3) => e3.type !== "Identifier"), i2.body.type !== "ArrowFunctionExpression" || r2 && r2.expandLastArg ? o2.unshift(n2("body", r2)) : (i2 = i2.body, e2.call(a3, "body"));
    }(), u2.length > 1)
      return function(e3, t3, n3, r3, i3, u3) {
        const o3 = e3.getName(), s3 = e3.getParentNode(), a3 = Yv(s3) && o3 === "callee", c3 = Boolean(t3 && t3.assignmentLayout), l3 = u3.body.type !== "BlockStatement" && u3.body.type !== "ObjectExpression", p3 = a3 && l3 || t3 && t3.assignmentLayout === "chain-tail-arrow-chain", f2 = Symbol("arrow-chain");
        return Bv([Bv(Nv([a3 || c3 ? Tv : "", Bv(Ov([" =>", wv], n3), { shouldBreak: r3 })]), { id: f2, shouldBreak: p3 }), " =>", Iv(l3 ? Nv([wv, i3]) : [" ", i3], { groupId: f2 }), a3 ? kv(Tv, "", { groupId: f2 }) : ""]);
      }(e2, r2, u2, s2, o2, i2);
    const a2 = u2;
    if (a2.push(" =>"), !Rv(t2.originalText, i2.body) && (i2.body.type === "ArrayExpression" || i2.body.type === "ObjectExpression" || i2.body.type === "BlockStatement" || Vv(i2.body) || Wv(i2.body, t2.originalText) || i2.body.type === "ArrowFunctionExpression" || i2.body.type === "DoExpression"))
      return Bv([...a2, " ", o2]);
    if (i2.body.type === "SequenceExpression")
      return Bv([...a2, Bv([" (", Nv([Tv, o2]), Tv, ")"])]);
    const c2 = (r2 && r2.expandLastArg || e2.getParentNode().type === "JSXExpressionContainer") && !Hv(i2), l2 = r2 && r2.expandLastArg && qv(t2, "all"), p2 = i2.body.type === "ConditionalExpression" && !Uv(i2.body, false);
    return Bv([...a2, Bv([Nv([wv, p2 ? kv("", "(") : "", o2, p2 ? kv("", ")") : ""]), c2 ? [kv(l2 ? "," : ""), Tv] : ""])]);
  }, printMethod: function(e2, t2, n2) {
    const r2 = e2.getNode(), { kind: i2 } = r2, u2 = r2.value || r2, o2 = [];
    return i2 && i2 !== "init" && i2 !== "method" && i2 !== "constructor" ? (mf.ok(i2 === "get" || i2 === "set"), o2.push(i2, " ")) : u2.async && o2.push("async "), u2.generator && o2.push("*"), o2.push(iF(e2, t2, n2), r2.optional || r2.key.optional ? "?" : ""), r2 === u2 ? o2.push(oF(e2, t2, n2)) : u2.type === "FunctionExpression" ? o2.push(e2.call((e3) => oF(e3, t2, n2), "value")) : o2.push(n2("value")), o2;
  }, printReturnStatement: function(e2, t2, n2) {
    return ["return", cF(e2, t2, n2)];
  }, printThrowStatement: function(e2, t2, n2) {
    return ["throw", cF(e2, t2, n2)];
  }, printMethodInternal: oF, shouldPrintParamsWithoutParens: sF };
  const { isNonEmptyArray: pF, hasNewline: fF } = yi$2, { builders: { line: dF, hardline: hF, join: gF, breakParent: mF, group: yF } } = eu$1, { locStart: DF, locEnd: EF } = zc, { getParentExportDeclaration: CF } = Gh;
  function bF(e2, t2) {
    return e2.decorators.some((e3) => fF(t2.originalText, EF(e3)));
  }
  function AF(e2) {
    if (e2.type !== "ExportDefaultDeclaration" && e2.type !== "ExportNamedDeclaration" && e2.type !== "DeclareExportDeclaration")
      return false;
    const t2 = e2.declaration && e2.declaration.decorators;
    return pF(t2) && DF(e2, { ignoreDecorators: true }) > DF(t2[0]);
  }
  var vF = { printDecorators: function(e2, t2, n2) {
    const r2 = e2.getValue(), { decorators: i2 } = r2;
    if (!pF(i2) || AF(e2.getParentNode()))
      return;
    const u2 = r2.type === "ClassExpression" || r2.type === "ClassDeclaration" || bF(r2, t2);
    return [CF(e2) ? hF : u2 ? mF : "", gF(dF, e2.map(n2, "decorators")), dF];
  }, printClassMemberDecorators: function(e2, t2, n2) {
    const r2 = e2.getValue();
    return yF([gF(dF, e2.map(n2, "decorators")), bF(r2, t2) ? hF : dF]);
  }, printDecoratorsBeforeExport: function(e2, t2, n2) {
    return [gF(hF, e2.map(n2, "declaration", "decorators")), hF];
  }, hasDecoratorsBeforeExport: AF };
  const { isNonEmptyArray: FF, createGroupIdMapper: SF } = yi$2, { printComments: xF, printDanglingComments: wF } = Wf, { builders: { join: TF, line: BF, hardline: NF, softline: kF, group: PF, indent: OF, ifBreak: IF } } = eu$1, { hasComment: LF, CommentCheckFlags: jF } = Gh, { getTypeParametersGroupId: _F } = pv, { printMethod: MF } = lF, { printOptionalToken: RF, printTypeAnnotation: $F } = BE, { printPropertyKey: VF } = vv, { printAssignment: WF } = Qb, { printClassMemberDecorators: qF } = vF;
  const UF = SF("heritageGroup");
  function zF(e2) {
    return e2.typeParameters && !LF(e2.typeParameters, jF.Trailing | jF.Line) && !function(e3) {
      return ["superClass", "extends", "mixins", "implements"].filter((t2) => Boolean(e3[t2])).length > 1;
    }(e2);
  }
  function GF(e2, t2, n2, r2) {
    const i2 = e2.getValue();
    if (!FF(i2[r2]))
      return "";
    const u2 = wF(e2, t2, true, ({ marker: e3 }) => e3 === r2);
    return [zF(i2) ? IF(" ", BF, { groupId: _F(i2.typeParameters) }) : BF, u2, u2 && NF, r2, PF(OF([BF, TF([",", BF], e2.map(n2, r2))]))];
  }
  function HF(e2, t2, n2) {
    const r2 = n2("superClass");
    return e2.getParentNode().type === "AssignmentExpression" ? PF(IF(["(", OF([kF, r2]), kF, ")"], r2)) : r2;
  }
  var JF = { printClass: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [];
    r2.declare && i2.push("declare "), r2.abstract && i2.push("abstract "), i2.push("class");
    const u2 = r2.id && LF(r2.id, jF.Trailing) || r2.superClass && LF(r2.superClass) || FF(r2.extends) || FF(r2.mixins) || FF(r2.implements), o2 = [], s2 = [];
    if (r2.id && o2.push(" ", n2("id")), o2.push(n2("typeParameters")), r2.superClass) {
      const r3 = ["extends ", HF(e2, t2, n2), n2("superTypeParameters")], i3 = e2.call((e3) => xF(e3, r3, t2), "superClass");
      u2 ? s2.push(BF, PF(i3)) : s2.push(" ", i3);
    } else
      s2.push(GF(e2, t2, n2, "extends"));
    if (s2.push(GF(e2, t2, n2, "mixins"), GF(e2, t2, n2, "implements")), u2) {
      let e3;
      e3 = zF(r2) ? [...o2, OF(s2)] : OF([...o2, s2]), i2.push(PF(e3, { id: UF(r2) }));
    } else
      i2.push(...o2, ...s2);
    return i2.push(" ", n2("body")), i2;
  }, printClassMethod: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [];
    return FF(r2.decorators) && i2.push(qF(e2, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.readonly && i2.push("readonly "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractMethodDefinition" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), i2.push(MF(e2, t2, n2)), i2;
  }, printClassProperty: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [], u2 = t2.semi ? ";" : "";
    return FF(r2.decorators) && i2.push(qF(e2, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractClassProperty" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), r2.readonly && i2.push("readonly "), r2.variance && i2.push(n2("variance")), i2.push(VF(e2, t2, n2), RF(e2), $F(e2, t2, n2)), [WF(e2, t2, n2, i2, " =", "value"), u2];
  }, printHardlineAfterHeritage: function(e2) {
    return IF(NF, "", { groupId: UF(e2) });
  } };
  const { isNonEmptyArray: XF } = yi$2, { builders: { join: YF, line: KF, group: QF, indent: ZF, ifBreak: eS } } = eu$1, { hasComment: tS, identity: nS, CommentCheckFlags: rS } = Gh, { getTypeParametersGroupId: iS } = pv, { printTypeScriptModifiers: uS } = BE;
  var oS = { printInterface: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [];
    r2.declare && i2.push("declare "), r2.type === "TSInterfaceDeclaration" && i2.push(r2.abstract ? "abstract " : "", uS(e2, t2, n2)), i2.push("interface");
    const u2 = [], o2 = [];
    r2.type !== "InterfaceTypeAnnotation" && u2.push(" ", n2("id"), n2("typeParameters"));
    const s2 = r2.typeParameters && !tS(r2.typeParameters, rS.Trailing | rS.Line);
    return XF(r2.extends) && o2.push(s2 ? eS(" ", KF, { groupId: iS(r2.typeParameters) }) : KF, "extends ", (r2.extends.length === 1 ? nS : ZF)(YF([",", KF], e2.map(n2, "extends")))), r2.id && tS(r2.id, rS.Trailing) || XF(r2.extends) ? s2 ? i2.push(QF([...u2, ZF(o2)])) : i2.push(QF(ZF([...u2, ...o2]))) : i2.push(...u2, ...o2), i2.push(" ", n2("body")), QF(i2);
  } };
  const { isNonEmptyArray: sS } = yi$2, { builders: { softline: aS, group: cS, indent: lS, join: pS, line: fS, ifBreak: dS, hardline: hS } } = eu$1, { printDanglingComments: gS } = Wf, { hasComment: mS, CommentCheckFlags: yS, shouldPrintComma: DS, needsHardlineAfterDanglingComment: ES } = Gh, { locStart: CS, hasSameLoc: bS } = zc, { hasDecoratorsBeforeExport: AS, printDecoratorsBeforeExport: vS } = vF;
  function FS(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!r2.source)
      return "";
    const i2 = [];
    return xS(r2, t2) || i2.push(" from"), i2.push(" ", n2("source")), i2;
  }
  function SS(e2, t2, n2) {
    const r2 = e2.getValue();
    if (xS(r2, t2))
      return "";
    const i2 = [" "];
    if (sS(r2.specifiers)) {
      const u2 = [], o2 = [];
      if (e2.each(() => {
        const t3 = e2.getValue().type;
        if (t3 === "ExportNamespaceSpecifier" || t3 === "ExportDefaultSpecifier" || t3 === "ImportNamespaceSpecifier" || t3 === "ImportDefaultSpecifier")
          u2.push(n2());
        else {
          if (t3 !== "ExportSpecifier" && t3 !== "ImportSpecifier")
            throw new Error(`Unknown specifier type ${JSON.stringify(t3)}`);
          o2.push(n2());
        }
      }, "specifiers"), i2.push(pS(", ", u2)), o2.length > 0) {
        u2.length > 0 && i2.push(", ");
        o2.length > 1 || u2.length > 0 || r2.specifiers.some((e3) => mS(e3)) ? i2.push(cS(["{", lS([t2.bracketSpacing ? fS : aS, pS([",", fS], o2)]), dS(DS(t2) ? "," : ""), t2.bracketSpacing ? fS : aS, "}"])) : i2.push(["{", t2.bracketSpacing ? " " : "", ...o2, t2.bracketSpacing ? " " : "", "}"]);
      }
    } else
      i2.push("{}");
    return i2;
  }
  function xS(e2, t2) {
    const { type: n2, importKind: r2, source: i2, specifiers: u2 } = e2;
    return n2 === "ImportDeclaration" && !sS(u2) && r2 !== "type" && !/{\s*}/.test(t2.originalText.slice(CS(e2), CS(i2)));
  }
  function wS(e2, t2, n2) {
    const r2 = e2.getNode();
    return sS(r2.assertions) ? [" assert {", t2.bracketSpacing ? " " : "", pS(", ", e2.map(n2, "assertions")), t2.bracketSpacing ? " " : "", "}"] : "";
  }
  var TS = { printImportDeclaration: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [], { importKind: o2 } = r2;
    return u2.push("import"), o2 && o2 !== "value" && u2.push(" ", o2), u2.push(SS(e2, t2, n2), FS(e2, t2, n2), wS(e2, t2, n2), i2), u2;
  }, printExportDeclaration: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [];
    AS(r2) && i2.push(vS(e2, t2, n2));
    const { type: u2, exportKind: o2, declaration: s2 } = r2;
    return i2.push("export"), (r2.default || u2 === "ExportDefaultDeclaration") && i2.push(" default"), mS(r2, yS.Dangling) && (i2.push(" ", gS(e2, t2, true)), ES(r2) && i2.push(hS)), s2 ? i2.push(" ", n2("declaration")) : i2.push(o2 === "type" ? " type" : "", SS(e2, t2, n2), FS(e2, t2, n2), wS(e2, t2, n2)), function(e3, t3) {
      if (!t3.semi)
        return false;
      const { type: n3, declaration: r3 } = e3, i3 = e3.default || n3 === "ExportDefaultDeclaration";
      if (!r3)
        return true;
      const { type: u3 } = r3;
      if (i3 && u3 !== "ClassDeclaration" && u3 !== "FunctionDeclaration" && u3 !== "TSInterfaceDeclaration" && u3 !== "DeclareClass" && u3 !== "DeclareFunction" && u3 !== "TSDeclareFunction" && u3 !== "EnumDeclaration")
        return true;
      return false;
    }(r2, t2) && i2.push(";"), i2;
  }, printExportAllDeclaration: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [], { exportKind: o2, exported: s2 } = r2;
    return u2.push("export"), o2 === "type" && u2.push(" type"), u2.push(" *"), s2 && u2.push(" as ", n2("exported")), u2.push(FS(e2, t2, n2), wS(e2, t2, n2), i2), u2;
  }, printModuleSpecifier: function(e2, t2, n2) {
    const r2 = e2.getNode(), { type: i2, importKind: u2 } = r2, o2 = [];
    i2 === "ImportSpecifier" && u2 && o2.push(u2, " ");
    const s2 = i2.startsWith("Import"), a2 = s2 ? "imported" : "local", c2 = s2 ? "local" : "exported";
    let l2 = "", p2 = "";
    return i2 === "ExportNamespaceSpecifier" || i2 === "ImportNamespaceSpecifier" ? l2 = "*" : r2[a2] && (l2 = n2(a2)), !r2[c2] || r2[a2] && bS(r2[a2], r2[c2]) || (p2 = n2(c2)), o2.push(l2, l2 && p2 ? " as " : "", p2), o2;
  } };
  const { printDanglingComments: BS } = Wf, { builders: { line: NS, softline: kS, group: PS, indent: OS, ifBreak: IS, hardline: LS } } = eu$1, { getLast: jS, hasNewlineInRange: _S, hasNewline: MS, isNonEmptyArray: RS } = yi$2, { shouldPrintComma: $S, hasComment: VS, getComments: WS, CommentCheckFlags: qS, isNextLineEmpty: US } = Gh, { locStart: zS, locEnd: GS } = zc, { printOptionalToken: HS, printTypeAnnotation: JS } = BE, { shouldHugFunctionParameters: XS } = FA, { shouldHugType: YS } = GA, { printHardlineAfterHeritage: KS } = JF;
  var QS = { printObject: function(e2, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e2.getValue();
    let u2;
    u2 = i2.type === "TSTypeLiteral" ? "members" : i2.type === "TSInterfaceBody" ? "body" : "properties";
    const o2 = i2.type === "ObjectTypeAnnotation", s2 = [u2];
    o2 && s2.push("indexers", "callProperties", "internalSlots");
    const a2 = s2.map((e3) => i2[e3][0]).sort((e3, t3) => zS(e3) - zS(t3))[0], c2 = e2.getParentNode(0), l2 = o2 && c2 && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass") && e2.getName() === "body", p2 = i2.type === "TSInterfaceBody" || l2 || i2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && i2.properties.some((e3) => e3.value && (e3.value.type === "ObjectPattern" || e3.value.type === "ArrayPattern")) || i2.type !== "ObjectPattern" && a2 && _S(t2.originalText, zS(i2), zS(a2)), f2 = l2 ? ";" : i2.type === "TSInterfaceBody" || i2.type === "TSTypeLiteral" ? IS(r2, ";") : ",", d2 = i2.type === "RecordExpression" ? "#{" : i2.exact ? "{|" : "{", h2 = i2.exact ? "|}" : "}", g2 = [];
    for (const t3 of s2)
      e2.each((e3) => {
        const t4 = e3.getValue();
        g2.push({ node: t4, printed: n2(), loc: zS(t4) });
      }, t3);
    s2.length > 1 && g2.sort((e3, t3) => e3.loc - t3.loc);
    let m2 = [];
    const y2 = g2.map((e3) => {
      const n3 = [...m2, PS(e3.printed)];
      return m2 = [f2, NS], e3.node.type !== "TSPropertySignature" && e3.node.type !== "TSMethodSignature" && e3.node.type !== "TSConstructSignatureDeclaration" || !VS(e3.node, qS.PrettierIgnore) || m2.shift(), US(e3.node, t2) && m2.push(LS), n3;
    });
    if (i2.inexact) {
      let n3;
      if (VS(i2, qS.Dangling)) {
        const r3 = VS(i2, qS.Line);
        n3 = [BS(e2, t2, true), r3 || MS(t2.originalText, GS(jS(WS(i2)))) ? LS : NS, "..."];
      } else
        n3 = ["..."];
      y2.push([...m2, ...n3]);
    }
    const D2 = jS(i2[u2]), E2 = !(i2.inexact || D2 && D2.type === "RestElement" || D2 && (D2.type === "TSPropertySignature" || D2.type === "TSCallSignatureDeclaration" || D2.type === "TSMethodSignature" || D2.type === "TSConstructSignatureDeclaration") && VS(D2, qS.PrettierIgnore));
    let C2;
    if (y2.length === 0) {
      if (!VS(i2, qS.Dangling))
        return [d2, h2, JS(e2, t2, n2)];
      C2 = PS([d2, BS(e2, t2), kS, h2, HS(e2), JS(e2, t2, n2)]);
    } else
      C2 = [l2 && RS(i2.properties) ? KS(c2) : "", d2, OS([t2.bracketSpacing ? NS : kS, ...y2]), IS(E2 && (f2 !== "," || $S(t2)) ? f2 : ""), t2.bracketSpacing ? NS : kS, h2, HS(e2), JS(e2, t2, n2)];
    return e2.match((e3) => e3.type === "ObjectPattern" && !e3.decorators, (e3, t3, n3) => XS(e3) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || e2.match(YS, (e3, t3) => t3 === "typeAnnotation", (e3, t3) => t3 === "typeAnnotation", (e3, t3, n3) => XS(e3) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || !p2 && e2.match((e3) => e3.type === "ObjectPattern", (e3) => e3.type === "AssignmentExpression" || e3.type === "VariableDeclarator") ? C2 : PS(C2, { shouldBreak: p2 });
  } };
  const { printDanglingComments: ZS } = Wf, { printString: ex, printNumber: tx } = yi$2, { builders: { hardline: nx, softline: rx, group: ix, indent: ux } } = eu$1, { getParentExportDeclaration: ox, isFunctionNotation: sx, isGetterOrSetter: ax, rawText: cx, shouldPrintComma: lx } = Gh, { locStart: px, locEnd: fx } = zc, { printClass: dx } = JF, { printOpaqueType: hx, printTypeAlias: gx, printIntersectionType: mx, printUnionType: yx, printFunctionType: Dx, printTupleType: Ex, printIndexedAccessType: Cx } = GA, { printInterface: bx } = oS, { printTypeParameter: Ax, printTypeParameters: vx } = pv, { printExportDeclaration: Fx, printExportAllDeclaration: Sx } = TS, { printArrayItems: xx } = QE, { printObject: wx } = QS, { printPropertyKey: Tx } = vv, { printOptionalToken: Bx, printTypeAnnotation: Nx, printRestSpread: kx } = BE;
  function Px(e2, t2) {
    const n2 = ox(e2);
    return n2 ? (mf.strictEqual(n2.type, "DeclareExportDeclaration"), t2) : ["declare ", t2];
  }
  var Ox = { printFlow: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
    switch (r2.type) {
      case "DeclareClass":
        return Px(e2, dx(e2, t2, n2));
      case "DeclareFunction":
        return Px(e2, ["function ", n2("id"), r2.predicate ? " " : "", n2("predicate"), i2]);
      case "DeclareModule":
        return Px(e2, ["module ", n2("id"), " ", n2("body")]);
      case "DeclareModuleExports":
        return Px(e2, ["module.exports", ": ", n2("typeAnnotation"), i2]);
      case "DeclareVariable":
        return Px(e2, ["var ", n2("id"), i2]);
      case "DeclareOpaqueType":
        return Px(e2, hx(e2, t2, n2));
      case "DeclareInterface":
        return Px(e2, bx(e2, t2, n2));
      case "DeclareTypeAlias":
        return Px(e2, gx(e2, t2, n2));
      case "DeclareExportDeclaration":
        return Px(e2, Fx(e2, t2, n2));
      case "DeclareExportAllDeclaration":
        return Px(e2, Sx(e2, t2, n2));
      case "OpaqueType":
        return hx(e2, t2, n2);
      case "TypeAlias":
        return gx(e2, t2, n2);
      case "IntersectionTypeAnnotation":
        return mx(e2, t2, n2);
      case "UnionTypeAnnotation":
        return yx(e2, t2, n2);
      case "FunctionTypeAnnotation":
        return Dx(e2, t2, n2);
      case "TupleTypeAnnotation":
        return Ex(e2, t2, n2);
      case "GenericTypeAnnotation":
        return [n2("id"), vx(e2, t2, n2, "typeParameters")];
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return Cx(e2, t2, n2);
      case "TypeAnnotation":
        return n2("typeAnnotation");
      case "TypeParameter":
        return Ax(e2, t2, n2);
      case "TypeofTypeAnnotation":
        return ["typeof ", n2("argument")];
      case "ExistsTypeAnnotation":
        return "*";
      case "EmptyTypeAnnotation":
        return "empty";
      case "MixedTypeAnnotation":
        return "mixed";
      case "ArrayTypeAnnotation":
        return [n2("elementType"), "[]"];
      case "BooleanLiteralTypeAnnotation":
        return String(r2.value);
      case "EnumDeclaration":
        return ["enum ", n2("id"), " ", n2("body")];
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        if (r2.type === "EnumSymbolBody" || r2.explicitType) {
          let e3 = null;
          switch (r2.type) {
            case "EnumBooleanBody":
              e3 = "boolean";
              break;
            case "EnumNumberBody":
              e3 = "number";
              break;
            case "EnumStringBody":
              e3 = "string";
              break;
            case "EnumSymbolBody":
              e3 = "symbol";
          }
          u2.push("of ", e3, " ");
        }
        if (r2.members.length !== 0 || r2.hasUnknownMembers) {
          const i3 = r2.members.length > 0 ? [nx, xx(e2, t2, "members", n2), r2.hasUnknownMembers || lx(t2) ? "," : ""] : [];
          u2.push(ix(["{", ux([...i3, ...r2.hasUnknownMembers ? [nx, "..."] : []]), ZS(e2, t2, true), nx, "}"]));
        } else
          u2.push(ix(["{", ZS(e2, t2), rx, "}"]));
        return u2;
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return [n2("id"), " = ", typeof r2.init == "object" ? n2("init") : String(r2.init)];
      case "EnumDefaultedMember":
        return n2("id");
      case "FunctionTypeParam": {
        const t3 = r2.name ? n2("name") : e2.getParentNode().this === r2 ? "this" : "";
        return [t3, Bx(e2), t3 ? ": " : "", n2("typeAnnotation")];
      }
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        return bx(e2, t2, n2);
      case "ClassImplements":
      case "InterfaceExtends":
        return [n2("id"), n2("typeParameters")];
      case "NullableTypeAnnotation":
        return ["?", n2("typeAnnotation")];
      case "Variance": {
        const { kind: e3 } = r2;
        return mf.ok(e3 === "plus" || e3 === "minus"), e3 === "plus" ? "+" : "-";
      }
      case "ObjectTypeCallProperty":
        return r2.static && u2.push("static "), u2.push(n2("value")), u2;
      case "ObjectTypeIndexer":
        return [r2.variance ? n2("variance") : "", "[", n2("id"), r2.id ? ": " : "", n2("key"), "]: ", n2("value")];
      case "ObjectTypeProperty": {
        let i3 = "";
        return r2.proto ? i3 = "proto " : r2.static && (i3 = "static "), [i3, ax(r2) ? r2.kind + " " : "", r2.variance ? n2("variance") : "", Tx(e2, t2, n2), Bx(e2), sx(r2) ? "" : ": ", n2("value")];
      }
      case "ObjectTypeAnnotation":
        return wx(e2, t2, n2);
      case "ObjectTypeInternalSlot":
        return [r2.static ? "static " : "", "[[", n2("id"), "]]", Bx(e2), r2.method ? "" : ": ", n2("value")];
      case "ObjectTypeSpreadProperty":
        return kx(e2, t2, n2);
      case "QualifiedTypeIdentifier":
        return [n2("qualification"), ".", n2("id")];
      case "StringLiteralTypeAnnotation":
        return ex(cx(r2), t2);
      case "NumberLiteralTypeAnnotation":
        mf.strictEqual(typeof r2.value, "number");
      case "BigIntLiteralTypeAnnotation":
        return r2.extra ? tx(r2.extra.raw) : tx(r2.raw);
      case "TypeCastExpression":
        return ["(", n2("expression"), Nx(e2, t2, n2), ")"];
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation": {
        const i3 = vx(e2, t2, n2, "params");
        if (t2.parser === "flow") {
          const e3 = px(r2), n3 = fx(r2), u3 = t2.originalText.lastIndexOf("/*", e3), o2 = t2.originalText.indexOf("*/", n3);
          if (u3 !== -1 && o2 !== -1) {
            const e4 = t2.originalText.slice(u3 + 2, o2).trim();
            if (e4.startsWith("::") && !e4.includes("/*") && !e4.includes("*/"))
              return ["/*:: ", i3, " */"];
          }
        }
        return i3;
      }
      case "InferredPredicate":
        return "%checks";
      case "DeclaredPredicate":
        return ["%checks(", n2("value"), ")"];
      case "AnyTypeAnnotation":
        return "any";
      case "BooleanTypeAnnotation":
        return "boolean";
      case "BigIntTypeAnnotation":
        return "bigint";
      case "NullLiteralTypeAnnotation":
        return "null";
      case "NumberTypeAnnotation":
        return "number";
      case "SymbolTypeAnnotation":
        return "symbol";
      case "StringTypeAnnotation":
        return "string";
      case "VoidTypeAnnotation":
        return "void";
      case "ThisTypeAnnotation":
        return "this";
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation":
      case "Type":
        throw new Error("unprintable type: " + JSON.stringify(r2.type));
    }
  } };
  const { hasNewlineInRange: Ix } = yi$2, { isJsxNode: Lx, isBlockComment: jx, getComments: _x, isCallExpression: Mx, isMemberExpression: Rx } = Gh, { locStart: $x, locEnd: Vx } = zc, { builders: { line: Wx, softline: qx, group: Ux, indent: zx, align: Gx, ifBreak: Hx, dedent: Jx, breakParent: Xx } } = eu$1;
  function Yx(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "alternate" : "falseType", o2 = e2.getParentNode(), s2 = i2 ? n2("test") : [n2("checkType"), " ", "extends", " ", n2("extendsType")];
    return o2.type === r2.type && o2[u2] === r2 ? Gx(2, s2) : s2;
  }
  const Kx = new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
  var Qx = { printTernary: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "consequent" : "trueType", o2 = i2 ? "alternate" : "falseType", s2 = i2 ? ["test"] : ["checkType", "extendsType"], a2 = r2[u2], c2 = r2[o2], l2 = [];
    let p2 = false;
    const f2 = e2.getParentNode(), d2 = f2.type === r2.type && s2.some((e3) => f2[e3] === r2);
    let h2, g2, m2 = f2.type === r2.type && !d2, y2 = 0;
    do {
      g2 = h2 || r2, h2 = e2.getParentNode(y2), y2++;
    } while (h2 && h2.type === r2.type && s2.every((e3) => h2[e3] !== g2));
    const D2 = h2 || f2, E2 = g2;
    if (i2 && (Lx(r2[s2[0]]) || Lx(a2) || Lx(c2) || function(e3) {
      const t3 = [e3];
      for (let e4 = 0; e4 < t3.length; e4++) {
        const n3 = t3[e4];
        for (const e5 of ["test", "consequent", "alternate"]) {
          const r3 = n3[e5];
          if (Lx(r3))
            return true;
          r3.type === "ConditionalExpression" && t3.push(r3);
        }
      }
      return false;
    }(E2))) {
      p2 = true, m2 = true;
      const e3 = (e4) => [Hx("("), zx([qx, e4]), qx, Hx(")")], t3 = (e4) => e4.type === "NullLiteral" || e4.type === "Literal" && e4.value === null || e4.type === "Identifier" && e4.name === "undefined";
      l2.push(" ? ", t3(a2) ? n2(u2) : e3(n2(u2)), " : ", c2.type === r2.type || t3(c2) ? n2(o2) : e3(n2(o2)));
    } else {
      const e3 = [Wx, "? ", a2.type === r2.type ? Hx("", "(") : "", Gx(2, n2(u2)), a2.type === r2.type ? Hx("", ")") : "", Wx, ": ", c2.type === r2.type ? n2(o2) : Gx(2, n2(o2))];
      l2.push(f2.type !== r2.type || f2[o2] === r2 || d2 ? e3 : t2.useTabs ? Jx(zx(e3)) : Gx(Math.max(0, t2.tabWidth - 2), e3));
    }
    const C2 = [...s2.map((e3) => _x(r2[e3])), _x(a2), _x(c2)].flat().some((e3) => jx(e3) && Ix(t2.originalText, $x(e3), Vx(e3))), b2 = !p2 && (Rx(f2) || f2.type === "NGPipeExpression" && f2.left === r2) && !f2.computed, A2 = function(e3) {
      const t3 = e3.getValue();
      if (t3.type !== "ConditionalExpression")
        return false;
      let n3, r3 = t3;
      for (let t4 = 0; !n3; t4++) {
        const i3 = e3.getParentNode(t4);
        Mx(i3) && i3.callee === r3 || Rx(i3) && i3.object === r3 || i3.type === "TSNonNullExpression" && i3.expression === r3 ? r3 = i3 : i3.type === "NewExpression" && i3.callee === r3 || i3.type === "TSAsExpression" && i3.expression === r3 ? (n3 = e3.getParentNode(t4 + 1), r3 = i3) : n3 = i3;
      }
      return r3 !== t3 && n3[Kx.get(n3.type)] === r3;
    }(e2), v2 = (F2 = [Yx(e2, 0, n2), m2 ? l2 : zx(l2), i2 && b2 && !A2 ? qx : ""], f2 === D2 ? Ux(F2, { shouldBreak: C2 }) : C2 ? [F2, Xx] : F2);
    var F2;
    return d2 || A2 ? Ux([zx([qx, v2]), qx]) : v2;
  } };
  const { builders: { hardline: Zx } } = eu$1, { getLeftSidePathName: ew, hasNakedLeftSide: tw, isJsxNode: nw, isTheOnlyJsxElementInMarkdown: rw, hasComment: iw, CommentCheckFlags: uw, isNextLineEmpty: ow } = Gh, { shouldPrintParamsWithoutParens: sw } = lF;
  function aw(e2, t2, n2, r2) {
    const i2 = e2.getValue(), u2 = [], o2 = i2.type === "ClassBody", s2 = function(e3) {
      for (let t3 = e3.length - 1; t3 >= 0; t3--) {
        const n3 = e3[t3];
        if (n3.type !== "EmptyStatement")
          return n3;
      }
    }(i2[r2]);
    return e2.each((e3, r3, i3) => {
      const a2 = e3.getValue();
      if (a2.type === "EmptyStatement")
        return;
      const c2 = n2();
      t2.semi || o2 || rw(t2, e3) || !function(e4, t3) {
        if (e4.getNode().type !== "ExpressionStatement")
          return false;
        return e4.call((e5) => cw(e5, t3), "expression");
      }(e3, t2) ? u2.push(c2) : iw(a2, uw.Leading) ? u2.push(n2([], { needsSemi: true })) : u2.push(";", c2), !t2.semi && o2 && lw(a2) && function(e4, t3) {
        const n3 = e4.key && e4.key.name;
        if (!(n3 !== "static" && n3 !== "get" && n3 !== "set" || e4.value || e4.typeAnnotation))
          return true;
        if (!t3)
          return false;
        if (t3.static || t3.accessibility)
          return false;
        if (!t3.computed) {
          const e5 = t3.key && t3.key.name;
          if (e5 === "in" || e5 === "instanceof")
            return true;
        }
        if (lw(t3) && t3.variance && !t3.static && !t3.declare)
          return true;
        switch (t3.type) {
          case "ClassProperty":
          case "PropertyDefinition":
          case "TSAbstractClassProperty":
            return t3.computed;
          case "MethodDefinition":
          case "TSAbstractMethodDefinition":
          case "ClassMethod":
          case "ClassPrivateMethod": {
            if ((t3.value ? t3.value.async : t3.async) || t3.kind === "get" || t3.kind === "set")
              return false;
            const e5 = t3.value ? t3.value.generator : t3.generator;
            return !(!t3.computed && !e5);
          }
          case "TSIndexSignature":
            return true;
        }
        return false;
      }(a2, i3[r3 + 1]) && u2.push(";"), a2 !== s2 && (u2.push(Zx), ow(a2, t2) && u2.push(Zx));
    }, r2), u2;
  }
  function cw(e2, t2) {
    const n2 = e2.getValue();
    switch (n2.type) {
      case "ParenthesizedExpression":
      case "TypeCastExpression":
      case "ArrayExpression":
      case "ArrayPattern":
      case "TemplateLiteral":
      case "TemplateElement":
      case "RegExpLiteral":
        return true;
      case "ArrowFunctionExpression":
        if (!sw(e2, t2))
          return true;
        break;
      case "UnaryExpression": {
        const { prefix: e3, operator: t3 } = n2;
        if (e3 && (t3 === "+" || t3 === "-"))
          return true;
        break;
      }
      case "BindExpression":
        if (!n2.object)
          return true;
        break;
      case "Literal":
        if (n2.regex)
          return true;
        break;
      default:
        if (nw(n2))
          return true;
    }
    return !!Qy(e2, t2) || !!tw(n2) && e2.call((e3) => cw(e3, t2), ...ew(e2, n2));
  }
  const lw = ({ type: e2 }) => e2 === "ClassProperty" || e2 === "PropertyDefinition" || e2 === "ClassPrivateProperty";
  var pw = { printBody: function(e2, t2, n2) {
    return aw(e2, t2, n2, "body");
  }, printSwitchCaseConsequent: function(e2, t2, n2) {
    return aw(e2, t2, n2, "consequent");
  } };
  const { printDanglingComments: fw } = Wf, { isNonEmptyArray: dw } = yi$2, { builders: { hardline: hw, indent: gw } } = eu$1, { hasComment: mw, CommentCheckFlags: yw, isNextLineEmpty: Dw } = Gh, { printHardlineAfterHeritage: Ew } = JF, { printBody: Cw } = pw;
  function bw(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = dw(r2.directives), u2 = r2.body.some((e3) => e3.type !== "EmptyStatement"), o2 = mw(r2, yw.Dangling);
    if (!i2 && !u2 && !o2)
      return "";
    const s2 = [];
    if (i2 && e2.each((e3, r3, i3) => {
      s2.push(n2()), (r3 < i3.length - 1 || u2 || o2) && (s2.push(hw), Dw(e3.getValue(), t2) && s2.push(hw));
    }, "directives"), u2 && s2.push(Cw(e2, t2, n2)), o2 && s2.push(fw(e2, t2, true)), r2.type === "Program") {
      const t3 = e2.getParentNode();
      t3 && t3.type === "ModuleExpression" || s2.push(hw);
    }
    return s2;
  }
  var Aw = { printBlock: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [];
    if (r2.type === "StaticBlock" && i2.push("static "), r2.type === "ClassBody" && dw(r2.body)) {
      const t3 = e2.getParentNode();
      i2.push(Ew(t3));
    }
    i2.push("{");
    const u2 = bw(e2, t2, n2);
    if (u2)
      i2.push(gw([hw, u2]), hw);
    else {
      const t3 = e2.getParentNode(), n3 = e2.getParentNode(1);
      t3.type === "ArrowFunctionExpression" || t3.type === "FunctionExpression" || t3.type === "FunctionDeclaration" || t3.type === "ObjectMethod" || t3.type === "ClassMethod" || t3.type === "ClassPrivateMethod" || t3.type === "ForStatement" || t3.type === "WhileStatement" || t3.type === "DoWhileStatement" || t3.type === "DoExpression" || t3.type === "CatchClause" && !n3.finalizer || t3.type === "TSModuleDeclaration" || t3.type === "TSDeclareFunction" || r2.type === "StaticBlock" || r2.type === "ClassBody" || i2.push(hw);
    }
    return i2.push("}"), i2;
  }, printBlockBody: bw };
  const { printDanglingComments: vw } = Wf, { hasNewlineInRange: Fw } = yi$2, { builders: { join: Sw, line: xw, hardline: ww, softline: Tw, group: Bw, indent: Nw, conditionalGroup: kw, ifBreak: Pw } } = eu$1, { isLiteral: Ow, getTypeScriptMappedTypeModifier: Iw, shouldPrintComma: Lw, isCallExpression: jw, isMemberExpression: _w } = Gh, { locStart: Mw, locEnd: Rw } = zc, { printOptionalToken: $w, printTypeScriptModifiers: Vw } = BE, { printTernary: Ww } = Qx, { printFunctionParameters: qw, shouldGroupFunctionParameters: Uw } = FA, { printTemplateLiteral: zw } = pg, { printArrayItems: Gw } = QE, { printObject: Hw } = QS, { printClassProperty: Jw, printClassMethod: Xw } = JF, { printTypeParameter: Yw, printTypeParameters: Kw } = pv, { printPropertyKey: Qw } = vv, { printFunction: Zw, printMethodInternal: eT } = lF, { printInterface: tT } = oS, { printBlock: nT } = Aw, { printTypeAlias: rT, printIntersectionType: iT, printUnionType: uT, printFunctionType: oT, printTupleType: sT, printIndexedAccessType: aT } = GA;
  var cT = { printTypescript: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!r2.type.startsWith("TS"))
      return;
    if (r2.type.endsWith("Keyword"))
      return r2.type.slice(2, -7).toLowerCase();
    const i2 = t2.semi ? ";" : "", u2 = [];
    switch (r2.type) {
      case "TSThisType":
        return "this";
      case "TSTypeAssertion": {
        const e3 = !(r2.expression.type === "ArrayExpression" || r2.expression.type === "ObjectExpression"), t3 = Bw(["<", Nw([Tw, n2("typeAnnotation")]), Tw, ">"]), i3 = [Pw("("), Nw([Tw, n2("expression")]), Tw, Pw(")")];
        return e3 ? kw([[t3, n2("expression")], [t3, Bw(i3, { shouldBreak: true })], [t3, n2("expression")]]) : Bw([t3, n2("expression")]);
      }
      case "TSDeclareFunction":
        return Zw(e2, n2, t2);
      case "TSExportAssignment":
        return ["export = ", n2("expression"), i2];
      case "TSModuleBlock":
        return nT(e2, t2, n2);
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        return Hw(e2, t2, n2);
      case "TSTypeAliasDeclaration":
        return rT(e2, t2, n2);
      case "TSQualifiedName":
        return Sw(".", [n2("left"), n2("right")]);
      case "TSAbstractMethodDefinition":
      case "TSDeclareMethod":
        return Xw(e2, t2, n2);
      case "TSAbstractClassProperty":
        return Jw(e2, t2, n2);
      case "TSInterfaceHeritage":
      case "TSExpressionWithTypeArguments":
        return u2.push(n2("expression")), r2.typeParameters && u2.push(n2("typeParameters")), u2;
      case "TSTemplateLiteralType":
        return zw(e2, n2, t2);
      case "TSNamedTupleMember":
        return [n2("label"), r2.optional ? "?" : "", ": ", n2("elementType")];
      case "TSRestType":
        return ["...", n2("typeAnnotation")];
      case "TSOptionalType":
        return [n2("typeAnnotation"), "?"];
      case "TSInterfaceDeclaration":
        return tT(e2, t2, n2);
      case "TSClassImplements":
        return [n2("expression"), n2("typeParameters")];
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return Kw(e2, t2, n2, "params");
      case "TSTypeParameter":
        return Yw(e2, t2, n2);
      case "TSAsExpression": {
        u2.push(n2("expression"), " as ", n2("typeAnnotation"));
        const t3 = e2.getParentNode();
        return jw(t3) && t3.callee === r2 || _w(t3) && t3.object === r2 ? Bw([Nw([Tw, ...u2]), Tw]) : u2;
      }
      case "TSArrayType":
        return [n2("elementType"), "[]"];
      case "TSPropertySignature":
        return r2.readonly && u2.push("readonly "), u2.push(Qw(e2, t2, n2), $w(e2)), r2.typeAnnotation && u2.push(": ", n2("typeAnnotation")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
      case "TSParameterProperty":
        return r2.accessibility && u2.push(r2.accessibility + " "), r2.export && u2.push("export "), r2.static && u2.push("static "), r2.override && u2.push("override "), r2.readonly && u2.push("readonly "), u2.push(n2("parameter")), u2;
      case "TSTypeQuery":
        return ["typeof ", n2("exprName")];
      case "TSIndexSignature": {
        const u3 = e2.getParentNode(), o2 = r2.parameters.length > 1 ? Pw(Lw(t2) ? "," : "") : "", s2 = Bw([Nw([Tw, Sw([", ", Tw], e2.map(n2, "parameters"))]), o2, Tw]);
        return [r2.export ? "export " : "", r2.accessibility ? [r2.accessibility, " "] : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.declare ? "declare " : "", "[", r2.parameters ? s2 : "", r2.typeAnnotation ? "]: " : "]", r2.typeAnnotation ? n2("typeAnnotation") : "", u3.type === "ClassBody" ? i2 : ""];
      }
      case "TSTypePredicate":
        return [r2.asserts ? "asserts " : "", n2("parameterName"), r2.typeAnnotation ? [" is ", n2("typeAnnotation")] : ""];
      case "TSNonNullExpression":
        return [n2("expression"), "!"];
      case "TSImportType":
        return [r2.isTypeOf ? "typeof " : "", "import(", n2(r2.parameter ? "parameter" : "argument"), ")", r2.qualifier ? [".", n2("qualifier")] : "", Kw(e2, t2, n2, "typeParameters")];
      case "TSLiteralType":
        return n2("literal");
      case "TSIndexedAccessType":
        return aT(e2, t2, n2);
      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType":
        if (r2.type === "TSConstructorType" && r2.abstract && u2.push("abstract "), r2.type !== "TSCallSignatureDeclaration" && u2.push("new "), u2.push(Bw(qw(e2, n2, t2, false, true))), r2.returnType || r2.typeAnnotation) {
          const e3 = r2.type === "TSConstructorType";
          u2.push(e3 ? " => " : ": ", n2("returnType"), n2("typeAnnotation"));
        }
        return u2;
      case "TSTypeOperator":
        return [r2.operator, " ", n2("typeAnnotation")];
      case "TSMappedType": {
        const u3 = Fw(t2.originalText, Mw(r2), Rw(r2));
        return Bw(["{", Nw([t2.bracketSpacing ? xw : Tw, r2.readonly ? [Iw(r2.readonly, "readonly"), " "] : "", Vw(e2, t2, n2), n2("typeParameter"), r2.optional ? Iw(r2.optional, "?") : "", r2.typeAnnotation ? ": " : "", n2("typeAnnotation"), Pw(i2)]), vw(e2, t2, true), t2.bracketSpacing ? xw : Tw, "}"], { shouldBreak: u3 });
      }
      case "TSMethodSignature": {
        const i3 = r2.kind && r2.kind !== "method" ? `${r2.kind} ` : "";
        u2.push(r2.accessibility ? [r2.accessibility, " "] : "", i3, r2.export ? "export " : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.abstract ? "abstract " : "", r2.declare ? "declare " : "", r2.computed ? "[" : "", n2("key"), r2.computed ? "]" : "", $w(e2));
        const o2 = qw(e2, n2, t2, false, true), s2 = r2.returnType ? "returnType" : "typeAnnotation", a2 = r2[s2], c2 = a2 ? n2(s2) : "", l2 = Uw(r2, c2);
        return u2.push(l2 ? Bw(o2) : o2), a2 && u2.push(": ", Bw(c2)), Bw(u2);
      }
      case "TSNamespaceExportDeclaration":
        return u2.push("export as namespace ", n2("id")), t2.semi && u2.push(";"), Bw(u2);
      case "TSEnumDeclaration":
        return r2.declare && u2.push("declare "), r2.modifiers && u2.push(Vw(e2, t2, n2)), r2.const && u2.push("const "), u2.push("enum ", n2("id"), " "), r2.members.length === 0 ? u2.push(Bw(["{", vw(e2, t2), Tw, "}"])) : u2.push(Bw(["{", Nw([ww, Gw(e2, t2, "members", n2), Lw(t2, "es5") ? "," : ""]), vw(e2, t2, true), ww, "}"])), u2;
      case "TSEnumMember":
        return u2.push(n2("id")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
      case "TSImportEqualsDeclaration":
        return r2.isExport && u2.push("export "), u2.push("import "), r2.importKind && r2.importKind !== "value" && u2.push(r2.importKind, " "), u2.push(n2("id"), " = ", n2("moduleReference")), t2.semi && u2.push(";"), Bw(u2);
      case "TSExternalModuleReference":
        return ["require(", n2("expression"), ")"];
      case "TSModuleDeclaration": {
        const o2 = e2.getParentNode(), s2 = Ow(r2.id), a2 = o2.type === "TSModuleDeclaration", c2 = r2.body && r2.body.type === "TSModuleDeclaration";
        if (a2)
          u2.push(".");
        else {
          r2.declare && u2.push("declare "), u2.push(Vw(e2, t2, n2));
          const i3 = t2.originalText.slice(Mw(r2), Mw(r2.id));
          r2.id.type === "Identifier" && r2.id.name === "global" && !/namespace|module/.test(i3) || u2.push(s2 || /(?:^|\s)module(?:\s|$)/.test(i3) ? "module " : "namespace ");
        }
        return u2.push(n2("id")), c2 ? u2.push(n2("body")) : r2.body ? u2.push(" ", Bw(n2("body"))) : u2.push(i2), u2;
      }
      case "TSPrivateIdentifier":
        return r2.escapedText;
      case "TSConditionalType":
        return Ww(e2, t2, n2);
      case "TSInferType":
        return ["infer", " ", n2("typeParameter")];
      case "TSIntersectionType":
        return iT(e2, t2, n2);
      case "TSUnionType":
        return uT(e2, t2, n2);
      case "TSFunctionType":
        return oT(e2, t2, n2);
      case "TSTupleType":
        return sT(e2, t2, n2);
      case "TSTypeReference":
        return [n2("typeName"), Kw(e2, t2, n2, "typeParameters")];
      case "TSTypeAnnotation":
        return n2("typeAnnotation");
      case "TSEmptyBodyFunctionExpression":
        return eT(e2, t2, n2);
      case "TSJSDocAllType":
        return "*";
      case "TSJSDocUnknownType":
        return "?";
      case "TSJSDocNullableType":
        return ["?", n2("typeAnnotation")];
      case "TSJSDocNonNullableType":
        return ["!", n2("typeAnnotation")];
      default:
        throw new Error(`Unknown TypeScript node type: ${JSON.stringify(r2.type)}.`);
    }
  } };
  const { hasNewline: lT } = yi$2, { builders: { join: pT, hardline: fT }, utils: { replaceTextEndOfLine: dT } } = eu$1, { isLineComment: hT, isBlockComment: gT } = Gh, { locStart: mT, locEnd: yT } = zc;
  var DT = { printComment: function(e2, t2) {
    const n2 = e2.getValue();
    if (hT(n2))
      return t2.originalText.slice(mT(n2), yT(n2)).trimEnd();
    if (gT(n2)) {
      if (function(e4) {
        const t3 = `*${e4.value}*`.split("\n");
        return t3.length > 1 && t3.every((e5) => e5.trim()[0] === "*");
      }(n2)) {
        const e4 = function(e5) {
          const t3 = e5.value.split("\n");
          return ["/*", pT(fT, t3.map((e6, n3) => n3 === 0 ? e6.trimEnd() : " " + (n3 < t3.length - 1 ? e6.trim() : e6.trimStart()))), "*/"];
        }(n2);
        return n2.trailing && !lT(t2.originalText, mT(n2), { backwards: true }) ? [fT, e4] : e4;
      }
      const e3 = yT(n2), r2 = t2.originalText.slice(e3 - 3, e3) === "*-/";
      return ["/*", dT(n2.value), r2 ? "*-/" : "*/"];
    }
    throw new Error("Not a comment: " + JSON.stringify(n2));
  } };
  const { printString: ET, printNumber: CT } = yi$2;
  function bT(e2) {
    return e2.toLowerCase();
  }
  function AT({ pattern: e2, flags: t2 }) {
    return `/${e2}/${t2 = [...t2].sort().join("")}`;
  }
  var vT = { printLiteral: function(e2, t2) {
    const n2 = e2.getNode();
    switch (n2.type) {
      case "RegExpLiteral":
        return AT(n2);
      case "BigIntLiteral":
        return bT(n2.bigint || n2.extra.raw);
      case "NumericLiteral":
        return CT(n2.extra.raw);
      case "StringLiteral":
        return ET(n2.extra.raw, t2);
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return String(n2.value);
      case "DecimalLiteral":
        return CT(n2.value) + "m";
      case "Literal": {
        if (n2.regex)
          return AT(n2.regex);
        if (n2.bigint)
          return bT(n2.raw);
        if (n2.decimal)
          return CT(n2.decimal) + "m";
        const { value: e3 } = n2;
        return typeof e3 == "number" ? CT(n2.raw) : typeof e3 == "string" ? ET(n2.raw, t2) : String(e3);
      }
    }
  } };
  const { printDanglingComments: FT } = Wf, { hasNewline: ST } = yi$2, { builders: { join: xT, line: wT, hardline: TT, softline: BT, group: NT, indent: kT }, utils: { replaceTextEndOfLine: PT } } = eu$1, { insertPragma: OT } = km, { hasFlowShorthandAnnotationComment: IT, hasComment: LT, CommentCheckFlags: jT, isTheOnlyJsxElementInMarkdown: _T, isBlockComment: MT, isLineComment: RT, isNextLineEmpty: $T, needsHardlineAfterDanglingComment: VT, rawText: WT, hasIgnoreComment: qT, isCallExpression: UT, isMemberExpression: zT } = Gh, { locStart: GT, locEnd: HT } = zc, { printHtmlBinding: JT, isVueEventBindingExpression: XT } = uD, { printAngular: YT } = $D, { printJsx: KT, hasJsxIgnoreComment: QT } = AE, { printFlow: ZT } = Ox, { printTypescript: eB } = cT, { printOptionalToken: tB, printBindExpressionCallee: nB, printTypeAnnotation: rB, adjustClause: iB, printRestSpread: uB } = BE, { printImportDeclaration: oB, printExportDeclaration: sB, printExportAllDeclaration: aB, printModuleSpecifier: cB } = TS, { printTernary: lB } = Qx, { printTemplateLiteral: pB } = pg, { printArray: fB } = QE, { printObject: dB } = QS, { printClass: hB, printClassMethod: gB, printClassProperty: mB } = JF, { printProperty: yB } = vv, { printFunction: DB, printArrowFunction: EB, printMethod: CB, printReturnStatement: bB, printThrowStatement: AB } = lF, { printCallExpression: vB } = Fb, { printVariableDeclarator: FB, printAssignmentExpression: SB } = Qb, { printBinaryishExpression: xB } = kD, { printSwitchCaseConsequent: wB } = pw, { printMemberExpression: TB } = _C, { printBlock: BB, printBlockBody: NB } = Aw, { printComment: kB } = DT, { printLiteral: PB } = vT, { printDecorators: OB } = vF;
  function IB(e2, t2) {
    const n2 = WT(e2), r2 = n2.slice(1, -1);
    if (r2.includes('"') || r2.includes("'"))
      return n2;
    const i2 = t2.singleQuote ? "'" : '"';
    return i2 + r2 + i2;
  }
  var LB = { preprocess: Zy, print: function(e2, t2, n2, r2) {
    const i2 = function(e3, t3, n3, r3) {
      const i3 = e3.getValue(), u3 = t3.semi ? ";" : "";
      if (!i3)
        return "";
      if (typeof i3 == "string")
        return i3;
      for (const r4 of [PB, JT, YT, KT, ZT, eB]) {
        const i4 = r4(e3, t3, n3);
        if (i4 !== void 0)
          return i4;
      }
      let o3 = [];
      switch (i3.type) {
        case "JsExpressionRoot":
          return n3("node");
        case "JsonRoot":
          return [n3("node"), TT];
        case "File":
          return i3.program && i3.program.interpreter && o3.push(n3(["program", "interpreter"])), o3.push(n3("program")), o3;
        case "Program":
          return NB(e3, t3, n3);
        case "EmptyStatement":
          return "";
        case "ExpressionStatement":
          if (i3.directive)
            return [IB(i3.expression, t3), u3];
          if (t3.parser === "__vue_event_binding") {
            const t4 = e3.getParentNode();
            if (t4.type === "Program" && t4.body.length === 1 && t4.body[0] === i3)
              return [n3("expression"), XT(i3.expression) ? ";" : ""];
          }
          return [n3("expression"), _T(t3, e3) ? "" : u3];
        case "ParenthesizedExpression":
          return !LT(i3.expression) && (i3.expression.type === "ObjectExpression" || i3.expression.type === "ArrayExpression") ? ["(", n3("expression"), ")"] : NT(["(", kT([BT, n3("expression")]), BT, ")"]);
        case "AssignmentExpression":
          return SB(e3, t3, n3);
        case "VariableDeclarator":
          return FB(e3, t3, n3);
        case "BinaryExpression":
        case "LogicalExpression":
          return xB(e3, t3, n3);
        case "AssignmentPattern":
          return [n3("left"), " = ", n3("right")];
        case "OptionalMemberExpression":
        case "MemberExpression":
          return TB(e3, t3, n3);
        case "MetaProperty":
          return [n3("meta"), ".", n3("property")];
        case "BindExpression":
          return i3.object && o3.push(n3("object")), o3.push(NT(kT([BT, nB(e3, t3, n3)]))), o3;
        case "Identifier":
          return [i3.name, tB(e3), rB(e3, t3, n3)];
        case "V8IntrinsicIdentifier":
          return ["%", i3.name];
        case "SpreadElement":
        case "SpreadElementPattern":
        case "SpreadProperty":
        case "SpreadPropertyPattern":
        case "RestElement":
          return uB(e3, t3, n3);
        case "FunctionDeclaration":
        case "FunctionExpression":
          return DB(e3, n3, t3, r3);
        case "ArrowFunctionExpression":
          return EB(e3, t3, n3, r3);
        case "YieldExpression":
          return o3.push("yield"), i3.delegate && o3.push("*"), i3.argument && o3.push(" ", n3("argument")), o3;
        case "AwaitExpression":
          if (o3.push("await"), i3.argument) {
            o3.push(" ", n3("argument"));
            const t4 = e3.getParentNode();
            if (UT(t4) && t4.callee === i3 || zT(t4) && t4.object === i3) {
              o3 = [kT([BT, ...o3]), BT];
              const t5 = e3.findAncestor((e4) => e4.type === "AwaitExpression" || e4.type === "BlockStatement");
              if (!t5 || t5.type !== "AwaitExpression")
                return NT(o3);
            }
          }
          return o3;
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          return sB(e3, t3, n3);
        case "ExportAllDeclaration":
          return aB(e3, t3, n3);
        case "ImportDeclaration":
          return oB(e3, t3, n3);
        case "ImportSpecifier":
        case "ExportSpecifier":
        case "ImportNamespaceSpecifier":
        case "ExportNamespaceSpecifier":
        case "ImportDefaultSpecifier":
        case "ExportDefaultSpecifier":
          return cB(e3, t3, n3);
        case "ImportAttribute":
          return [n3("key"), ": ", n3("value")];
        case "Import":
          return "import";
        case "BlockStatement":
        case "StaticBlock":
        case "ClassBody":
          return BB(e3, t3, n3);
        case "ThrowStatement":
          return AB(e3, t3, n3);
        case "ReturnStatement":
          return bB(e3, t3, n3);
        case "NewExpression":
        case "ImportExpression":
        case "OptionalCallExpression":
        case "CallExpression":
          return vB(e3, t3, n3);
        case "ObjectExpression":
        case "ObjectPattern":
        case "RecordExpression":
          return dB(e3, t3, n3);
        case "ObjectProperty":
        case "Property":
          return i3.method || i3.kind === "get" || i3.kind === "set" ? CB(e3, t3, n3) : yB(e3, t3, n3);
        case "ObjectMethod":
          return CB(e3, t3, n3);
        case "Decorator":
          return ["@", n3("expression")];
        case "ArrayExpression":
        case "ArrayPattern":
        case "TupleExpression":
          return fB(e3, t3, n3);
        case "SequenceExpression": {
          const t4 = e3.getParentNode(0);
          if (t4.type === "ExpressionStatement" || t4.type === "ForStatement") {
            const t5 = [];
            return e3.each((e4, r4) => {
              r4 === 0 ? t5.push(n3()) : t5.push(",", kT([wT, n3()]));
            }, "expressions"), NT(t5);
          }
          return NT(xT([",", wT], e3.map(n3, "expressions")));
        }
        case "ThisExpression":
          return "this";
        case "Super":
          return "super";
        case "Directive":
          return [n3("value"), u3];
        case "DirectiveLiteral":
          return IB(i3, t3);
        case "UnaryExpression":
          return o3.push(i3.operator), /[a-z]$/.test(i3.operator) && o3.push(" "), LT(i3.argument) ? o3.push(NT(["(", kT([BT, n3("argument")]), BT, ")"])) : o3.push(n3("argument")), o3;
        case "UpdateExpression":
          return o3.push(n3("argument"), i3.operator), i3.prefix && o3.reverse(), o3;
        case "ConditionalExpression":
          return lB(e3, t3, n3);
        case "VariableDeclaration": {
          const t4 = e3.map(n3, "declarations"), r4 = e3.getParentNode(), s3 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", a3 = i3.declarations.some((e4) => e4.init);
          let c2;
          return t4.length !== 1 || LT(i3.declarations[0]) ? t4.length > 0 && (c2 = kT(t4[0])) : c2 = t4[0], o3 = [i3.declare ? "declare " : "", i3.kind, c2 ? [" ", c2] : "", kT(t4.slice(1).map((e4) => [",", a3 && !s3 ? TT : wT, e4]))], s3 && r4.body !== i3 || o3.push(u3), NT(o3);
        }
        case "WithStatement":
          return NT(["with (", n3("object"), ")", iB(i3.body, n3("body"))]);
        case "IfStatement": {
          const r4 = iB(i3.consequent, n3("consequent")), u4 = NT(["if (", NT([kT([BT, n3("test")]), BT]), ")", r4]);
          if (o3.push(u4), i3.alternate) {
            const r5 = LT(i3.consequent, jT.Trailing | jT.Line) || VT(i3), u5 = i3.consequent.type === "BlockStatement" && !r5;
            o3.push(u5 ? " " : TT), LT(i3, jT.Dangling) && o3.push(FT(e3, t3, true), r5 ? TT : " "), o3.push("else", NT(iB(i3.alternate, n3("alternate"), i3.alternate.type === "IfStatement")));
          }
          return o3;
        }
        case "ForStatement": {
          const r4 = iB(i3.body, n3("body")), u4 = FT(e3, t3, true), o4 = u4 ? [u4, BT] : "";
          return i3.init || i3.test || i3.update ? [o4, NT(["for (", NT([kT([BT, n3("init"), ";", wT, n3("test"), ";", wT, n3("update")]), BT]), ")", r4])] : [o4, NT(["for (;;)", r4])];
        }
        case "WhileStatement":
          return NT(["while (", NT([kT([BT, n3("test")]), BT]), ")", iB(i3.body, n3("body"))]);
        case "ForInStatement":
          return NT(["for (", n3("left"), " in ", n3("right"), ")", iB(i3.body, n3("body"))]);
        case "ForOfStatement":
          return NT(["for", i3.await ? " await" : "", " (", n3("left"), " of ", n3("right"), ")", iB(i3.body, n3("body"))]);
        case "DoWhileStatement": {
          const e4 = iB(i3.body, n3("body"));
          return o3 = [NT(["do", e4])], i3.body.type === "BlockStatement" ? o3.push(" ") : o3.push(TT), o3.push("while (", NT([kT([BT, n3("test")]), BT]), ")", u3), o3;
        }
        case "DoExpression":
          return [i3.async ? "async " : "", "do ", n3("body")];
        case "BreakStatement":
          return o3.push("break"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
        case "ContinueStatement":
          return o3.push("continue"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
        case "LabeledStatement":
          return i3.body.type === "EmptyStatement" ? [n3("label"), ":;"] : [n3("label"), ": ", n3("body")];
        case "TryStatement":
          return ["try ", n3("block"), i3.handler ? [" ", n3("handler")] : "", i3.finalizer ? [" finally ", n3("finalizer")] : ""];
        case "CatchClause":
          if (i3.param) {
            const e4 = LT(i3.param, (e5) => !MT(e5) || e5.leading && ST(t3.originalText, HT(e5)) || e5.trailing && ST(t3.originalText, GT(e5), { backwards: true })), r4 = n3("param");
            return ["catch ", e4 ? ["(", kT([BT, r4]), BT, ") "] : ["(", r4, ") "], n3("body")];
          }
          return ["catch ", n3("body")];
        case "SwitchStatement":
          return [NT(["switch (", kT([BT, n3("discriminant")]), BT, ")"]), " {", i3.cases.length > 0 ? kT([TT, xT(TT, e3.map((e4, r4, i4) => {
            const u4 = e4.getValue();
            return [n3(), r4 !== i4.length - 1 && $T(u4, t3) ? TT : ""];
          }, "cases"))]) : "", TT, "}"];
        case "SwitchCase": {
          i3.test ? o3.push("case ", n3("test"), ":") : o3.push("default:");
          const r4 = i3.consequent.filter((e4) => e4.type !== "EmptyStatement");
          if (r4.length > 0) {
            const i4 = wB(e3, t3, n3);
            o3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? [" ", i4] : kT([TT, i4]));
          }
          return o3;
        }
        case "DebuggerStatement":
          return ["debugger", u3];
        case "ClassDeclaration":
        case "ClassExpression":
          return hB(e3, t3, n3);
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "MethodDefinition":
          return gB(e3, t3, n3);
        case "ClassProperty":
        case "PropertyDefinition":
        case "ClassPrivateProperty":
          return mB(e3, t3, n3);
        case "TemplateElement":
          return PT(i3.value.raw);
        case "TemplateLiteral":
          return pB(e3, n3, t3);
        case "TaggedTemplateExpression":
          return [n3("tag"), n3("typeParameters"), n3("quasi")];
        case "PrivateIdentifier":
          return ["#", n3("name")];
        case "PrivateName":
          return ["#", n3("id")];
        case "InterpreterDirective":
          return o3.push("#!", i3.value, TT), $T(i3, t3) && o3.push(TT), o3;
        case "TopicReference":
          return "%";
        case "ArgumentPlaceholder":
          return "?";
        case "ModuleExpression": {
          o3.push("module {");
          const e4 = n3("body");
          return e4 && o3.push(kT([TT, e4]), TT), o3.push("}"), o3;
        }
        default:
          throw new Error("unknown type: " + JSON.stringify(i3.type));
      }
    }(e2, t2, n2, r2);
    if (!i2)
      return "";
    const u2 = e2.getValue(), { type: o2 } = u2;
    if (o2 === "ClassMethod" || o2 === "ClassPrivateMethod" || o2 === "ClassProperty" || o2 === "PropertyDefinition" || o2 === "TSAbstractClassProperty" || o2 === "ClassPrivateProperty" || o2 === "MethodDefinition" || o2 === "TSAbstractMethodDefinition" || o2 === "TSDeclareMethod")
      return i2;
    const s2 = OB(e2, t2, n2);
    if (s2)
      return NT([...s2, i2]);
    if (!Qy(e2, t2))
      return r2 && r2.needsSemi ? [";", i2] : i2;
    const a2 = [r2 && r2.needsSemi ? ";(" : "(", i2];
    if (IT(u2)) {
      const [e3] = u2.trailingComments;
      a2.push(" /*", e3.value.trimStart(), "*/"), e3.printed = true;
    }
    return a2.push(")"), a2;
  }, embed: Kg, insertPragma: OT, massageAstNode: nm, hasPrettierIgnore: (e2) => qT(e2) || QT(e2), willPrintOwnComments: jy.willPrintOwnComments, canAttachComment: function(e2) {
    return e2.type && !MT(e2) && !RT(e2) && e2.type !== "EmptyStatement" && e2.type !== "TemplateElement" && e2.type !== "Import" && e2.type !== "TSEmptyBodyFunctionExpression";
  }, printComment: kB, isBlockComment: MT, handleComments: { avoidAstMutation: true, ownLine: jy.handleOwnLineComment, endOfLine: jy.handleEndOfLineComment, remaining: jy.handleRemainingComment }, getCommentChildNodes: jy.getCommentChildNodes };
  const { builders: { hardline: jB, indent: _B, join: MB } } = eu$1;
  const RB = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
  function $B(e2, t2) {
    const { type: n2 } = e2;
    if (n2 !== "ObjectProperty" || e2.key.type !== "Identifier") {
      if (n2 === "UnaryExpression" && e2.operator === "+")
        return t2.argument;
      if (n2 !== "ArrayExpression")
        return n2 === "TemplateLiteral" ? { type: "StringLiteral", value: e2.quasis[0].value.cooked } : void 0;
      for (const [n3, r2] of e2.elements.entries())
        r2 === null && t2.elements.splice(n3, 0, { type: "NullLiteral" });
    } else
      t2.key = { type: "StringLiteral", value: e2.key.name };
  }
  $B.ignoredProperties = RB;
  var VB = { preprocess: Zy, print: function(e2, t2, n2) {
    const r2 = e2.getValue();
    switch (r2.type) {
      case "JsonRoot":
        return [n2("node"), jB];
      case "ArrayExpression": {
        if (r2.elements.length === 0)
          return "[]";
        const t3 = e2.map(() => e2.getValue() === null ? "null" : n2(), "elements");
        return ["[", _B([jB, MB([",", jB], t3)]), jB, "]"];
      }
      case "ObjectExpression":
        return r2.properties.length === 0 ? "{}" : ["{", _B([jB, MB([",", jB], e2.map(n2, "properties"))]), jB, "}"];
      case "ObjectProperty":
        return [n2("key"), ": ", n2("value")];
      case "UnaryExpression":
        return [r2.operator === "+" ? "" : r2.operator, n2("argument")];
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return r2.value ? "true" : "false";
      case "StringLiteral":
      case "NumericLiteral":
        return JSON.stringify(r2.value);
      case "Identifier": {
        const t3 = e2.getParentNode();
        return t3 && t3.type === "ObjectProperty" && t3.key === r2 ? JSON.stringify(r2.name) : r2.name;
      }
      case "TemplateLiteral":
        return n2(["quasis", 0]);
      case "TemplateElement":
        return JSON.stringify(r2.value.cooked);
      default:
        throw new Error("unknown type: " + JSON.stringify(r2.type));
    }
  }, massageAstNode: $B };
  var WB = { bracketSpacing: { since: "0.0.0", category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: "Common", type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." } };
  var qB = { arrowParens: { since: "1.9.0", category: "JavaScript", type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: WB.bracketSameLine, bracketSpacing: WB.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: "JavaScript", type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: "JavaScript", type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: WB.singleQuote, jsxSingleQuote: { since: "1.15.0", category: "JavaScript", type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: "JavaScript", type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: "JavaScript", type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] } }, UB = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 }, zB = { name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 }, GB = { name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 }, HB = { name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 }, JB = { name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 }, XB = { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
  var YB = { languages: [Xd(UB, (e2) => ({ since: "0.0.0", parsers: ["babel", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e2.interpreters, "zx"], extensions: [...e2.extensions.filter((e3) => e3 !== ".jsx"), ".wxs"] })), Xd(UB, () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), Xd(UB, () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), Xd(zB, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), Xd(GB, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), Xd(HB, () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] })), Xd(HB, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e2.extensions.filter((e3) => e3 !== ".jsonl") })), Xd(JB, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e2.filenames, ".eslintrc"] })), Xd(XB, () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], options: qB, printers: { estree: LB, "estree-json": VB }, parsers: void 0 };
  const { isFrontMatterNode: KB } = yi$2, QB = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
  function ZB(e2, t2, n2) {
    if (KB(e2) && e2.lang === "yaml" && delete t2.value, e2.type === "css-comment" && n2.type === "css-root" && n2.nodes.length > 0) {
      if ((n2.nodes[0] === e2 || KB(n2.nodes[0]) && n2.nodes[1] === e2) && (delete t2.text, /^\*\s*@(?:format|prettier)\s*$/.test(e2.text)))
        return null;
      if (n2.type === "css-root" && Ln$2(n2.nodes) === e2)
        return null;
    }
    if (e2.type === "value-root" && delete t2.text, e2.type !== "media-query" && e2.type !== "media-query-list" && e2.type !== "media-feature-expression" || delete t2.value, e2.type === "css-rule" && delete t2.params, e2.type === "selector-combinator" && (t2.value = t2.value.replace(/\s+/g, " ")), e2.type === "media-feature" && (t2.value = t2.value.replace(/ /g, "")), (e2.type === "value-word" && (e2.isColor && e2.isHex || ["initial", "inherit", "unset", "revert"].includes(t2.value.replace().toLowerCase())) || e2.type === "media-feature" || e2.type === "selector-root-invalid" || e2.type === "selector-pseudo") && (t2.value = t2.value.toLowerCase()), e2.type === "css-decl" && (t2.prop = t2.prop.toLowerCase()), e2.type !== "css-atrule" && e2.type !== "css-import" || (t2.name = t2.name.toLowerCase()), e2.type === "value-number" && (t2.unit = t2.unit.toLowerCase()), e2.type !== "media-feature" && e2.type !== "media-keyword" && e2.type !== "media-type" && e2.type !== "media-unknown" && e2.type !== "media-url" && e2.type !== "media-value" && e2.type !== "selector-attribute" && e2.type !== "selector-string" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "value-string" || !t2.value || (t2.value = t2.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e2.type === "selector-attribute" && (t2.attribute = t2.attribute.trim(), t2.namespace && typeof t2.namespace == "string" && (t2.namespace = t2.namespace.trim(), t2.namespace.length === 0 && (t2.namespace = true)), t2.value && (t2.value = t2.value.trim().replace(/^["']|["']$/g, ""), delete t2.quoted)), e2.type !== "media-value" && e2.type !== "media-type" && e2.type !== "value-number" && e2.type !== "selector-root-invalid" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "selector-tag" || !t2.value || (t2.value = t2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e3, t3, n3) => {
      const r2 = Number(t3);
      return Number.isNaN(r2) ? e3 : r2 + n3.toLowerCase();
    })), e2.type === "selector-tag") {
      const n3 = e2.value.toLowerCase();
      ["from", "to"].includes(n3) && (t2.value = n3);
    }
    e2.type === "css-atrule" && e2.name.toLowerCase() === "supports" && delete t2.value, e2.type === "selector-unknown" && delete t2.value;
  }
  ZB.ignoredProperties = QB;
  var eN = ZB;
  const { builders: { hardline: tN, markAsRoot: nN } } = eu$1;
  var rN = function(e2, t2) {
    if (e2.lang === "yaml") {
      const n2 = e2.value.trim(), r2 = n2 ? t2(n2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
      return nN([e2.startDelimiter, tN, r2, r2 ? tN : "", e2.endDelimiter]);
    }
  };
  const { builders: { hardline: iN } } = eu$1;
  var uN = function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (r2.type === "front-matter") {
      const e3 = rN(r2, n2);
      return e3 ? [e3, iN] : "";
    }
  };
  const oN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  var sN = function(e2) {
    const t2 = e2.match(oN);
    if (!t2)
      return { content: e2 };
    const { startDelimiter: n2, language: r2, value: i2 = "", endDelimiter: u2 } = t2.groups;
    let o2 = r2.trim() || "yaml";
    if (n2 === "+++" && (o2 = "toml"), o2 !== "yaml" && n2 !== u2)
      return { content: e2 };
    const [s2] = t2;
    return { frontMatter: { type: "front-matter", lang: o2, value: i2, startDelimiter: n2, endDelimiter: u2, raw: s2.replace(/\n$/, "") }, content: s2.replace(/[^\n]/g, " ") + e2.slice(s2.length) };
  };
  var aN = { hasPragma: function(e2) {
    return km.hasPragma(sN(e2).content);
  }, insertPragma: function(e2) {
    const { frontMatter: t2, content: n2 } = sN(e2);
    return (t2 ? t2.raw + "\n\n" : "") + km.insertPragma(n2);
  } };
  const { isNonEmptyArray: cN } = yi$2, lN = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), pN = new Set(["import", "use", "forward"]);
  function fN(e2, t2) {
    const n2 = Array.isArray(t2) ? t2 : [t2];
    let r2, i2 = -1;
    for (; r2 = e2.getParentNode(++i2); )
      if (n2.includes(r2.type))
        return i2;
    return -1;
  }
  function dN(e2, t2) {
    const n2 = fN(e2, t2);
    return n2 === -1 ? null : e2.getParentNode(n2);
  }
  function hN(e2) {
    return e2.type === "value-operator" && e2.value === "*";
  }
  function gN(e2) {
    return e2.type === "value-operator" && e2.value === "/";
  }
  function mN(e2) {
    return e2.type === "value-operator" && e2.value === "+";
  }
  function yN(e2) {
    return e2.type === "value-operator" && e2.value === "-";
  }
  function DN(e2) {
    return e2.type === "value-operator" && e2.value === "%";
  }
  function EN(e2) {
    return e2.type === "value-comma_group" && e2.groups && e2.groups[1] && e2.groups[1].type === "value-colon";
  }
  function CN(e2) {
    return e2.type === "value-paren_group" && e2.groups && e2.groups[0] && EN(e2.groups[0]);
  }
  function bN(e2) {
    return e2 && e2.type === "value-colon";
  }
  var AN = { getAncestorCounter: fN, getAncestorNode: dN, getPropOfDeclNode: function(e2) {
    const t2 = dN(e2, "css-decl");
    return t2 && t2.prop && t2.prop.toLowerCase();
  }, hasSCSSInterpolation: function(e2) {
    if (cN(e2)) {
      for (let t2 = e2.length - 1; t2 > 0; t2--)
        if (e2[t2].type === "word" && e2[t2].value === "{" && e2[t2 - 1].type === "word" && e2[t2 - 1].value.endsWith("#"))
          return true;
    }
    return false;
  }, hasStringOrFunction: function(e2) {
    if (cN(e2)) {
      for (let t2 = 0; t2 < e2.length; t2++)
        if (e2[t2].type === "string" || e2[t2].type === "func")
          return true;
    }
    return false;
  }, maybeToLowerCase: function(e2) {
    return e2.includes("$") || e2.includes("@") || e2.includes("#") || e2.startsWith("%") || e2.startsWith("--") || e2.startsWith(":--") || e2.includes("(") && e2.includes(")") ? e2 : e2.toLowerCase();
  }, insideValueFunctionNode: function(e2, t2) {
    const n2 = dN(e2, "value-func");
    return n2 && n2.value && n2.value.toLowerCase() === t2;
  }, insideICSSRuleNode: function(e2) {
    const t2 = dN(e2, "css-rule");
    return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
  }, insideAtRuleNode: function(e2, t2) {
    const n2 = Array.isArray(t2) ? t2 : [t2], r2 = dN(e2, "css-atrule");
    return r2 && n2.includes(r2.name.toLowerCase());
  }, insideURLFunctionInImportAtRuleNode: function(e2) {
    const t2 = e2.getValue(), n2 = dN(e2, "css-atrule");
    return n2 && n2.name === "import" && t2.groups[0].value === "url" && t2.groups.length === 2;
  }, isKeyframeAtRuleKeywords: function(e2, t2) {
    const n2 = dN(e2, "css-atrule");
    return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t2.toLowerCase());
  }, isWideKeywords: function(e2) {
    return ["initial", "inherit", "unset", "revert"].includes(e2.toLowerCase());
  }, isSCSS: function(e2, t2) {
    return e2 === "less" || e2 === "scss" ? e2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
  }, isSCSSVariable: function(e2) {
    return Boolean(e2 && e2.type === "word" && e2.value.startsWith("$"));
  }, isLastNode: function(e2, t2) {
    const n2 = e2.getParentNode();
    if (!n2)
      return false;
    const { nodes: r2 } = n2;
    return r2 && r2.indexOf(t2) === r2.length - 1;
  }, isLessParser: function(e2) {
    return e2.parser === "css" || e2.parser === "less";
  }, isSCSSControlDirectiveNode: function(e2) {
    return e2.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e2.name);
  }, isDetachedRulesetDeclarationNode: function(e2) {
    return !!e2.selector && (typeof e2.selector == "string" && /^@.+:.*$/.test(e2.selector) || e2.selector.value && /^@.+:.*$/.test(e2.selector.value));
  }, isRelationalOperatorNode: function(e2) {
    return e2.type === "value-word" && ["<", ">", "<=", ">="].includes(e2.value);
  }, isEqualityOperatorNode: function(e2) {
    return e2.type === "value-word" && ["==", "!="].includes(e2.value);
  }, isMultiplicationNode: hN, isDivisionNode: gN, isAdditionNode: mN, isSubtractionNode: yN, isModuloNode: DN, isMathOperatorNode: function(e2) {
    return hN(e2) || gN(e2) || mN(e2) || yN(e2) || DN(e2);
  }, isEachKeywordNode: function(e2) {
    return e2.type === "value-word" && e2.value === "in";
  }, isForKeywordNode: function(e2) {
    return e2.type === "value-word" && ["from", "through", "end"].includes(e2.value);
  }, isURLFunctionNode: function(e2) {
    return e2.type === "value-func" && e2.value.toLowerCase() === "url";
  }, isIfElseKeywordNode: function(e2) {
    return e2.type === "value-word" && ["and", "or", "not"].includes(e2.value);
  }, hasComposesNode: function(e2) {
    return e2.value && e2.value.type === "value-root" && e2.value.group && e2.value.group.type === "value-value" && e2.prop.toLowerCase() === "composes";
  }, hasParensAroundNode: function(e2) {
    return e2.value && e2.value.group && e2.value.group.group && e2.value.group.group.type === "value-paren_group" && e2.value.group.group.open !== null && e2.value.group.group.close !== null;
  }, hasEmptyRawBefore: function(e2) {
    return e2.raws && e2.raws.before === "";
  }, isSCSSNestedPropertyNode: function(e2) {
    return !!e2.selector && e2.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
  }, isDetachedRulesetCallNode: function(e2) {
    return e2.raws && e2.raws.params && /^\(\s*\)$/.test(e2.raws.params);
  }, isTemplatePlaceholderNode: function(e2) {
    return e2.name.startsWith("prettier-placeholder");
  }, isTemplatePropNode: function(e2) {
    return e2.prop.startsWith("@prettier-placeholder");
  }, isPostcssSimpleVarNode: function(e2, t2) {
    return e2.value === "$$" && e2.type === "value-func" && t2 && t2.type === "value-word" && !t2.raws.before;
  }, isKeyValuePairNode: EN, isKeyValuePairInParenGroupNode: CN, isKeyInValuePairNode: function(e2, t2) {
    if (!EN(t2))
      return false;
    const { groups: n2 } = t2, r2 = n2.indexOf(e2);
    return r2 !== -1 && bN(n2[r2 + 1]);
  }, isSCSSMapItemNode: function(e2) {
    const t2 = e2.getValue();
    if (t2.groups.length === 0)
      return false;
    const n2 = e2.getParentNode(1);
    if (!(CN(t2) || n2 && CN(n2)))
      return false;
    const r2 = dN(e2, "css-decl");
    return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!CN(n2) || n2.type === "value-func");
  }, isInlineValueCommentNode: function(e2) {
    return e2.type === "value-comment" && e2.inline;
  }, isHashNode: function(e2) {
    return e2.type === "value-word" && e2.value === "#";
  }, isLeftCurlyBraceNode: function(e2) {
    return e2.type === "value-word" && e2.value === "{";
  }, isRightCurlyBraceNode: function(e2) {
    return e2.type === "value-word" && e2.value === "}";
  }, isWordNode: function(e2) {
    return ["value-word", "value-atword"].includes(e2.type);
  }, isColonNode: bN, isMediaAndSupportsKeywords: function(e2) {
    return e2.value && ["not", "and", "or"].includes(e2.value.toLowerCase());
  }, isColorAdjusterFuncNode: function(e2) {
    return e2.type === "value-func" && lN.has(e2.value.toLowerCase());
  }, lastLineHasInlineComment: function(e2) {
    return /\/\//.test(e2.split(/[\n\r]/).pop());
  }, stringifyNode: function e2(t2) {
    if (t2.groups) {
      return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n3, r3, i2) => n3 + e2(r3) + (t2.groups[0].type === "comma_group" && i2 !== t2.groups.length - 1 ? "," : ""), "") + (t2.close && t2.close.value ? t2.close.value : "");
    }
    const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
    return n2 + r2 + (t2.type === "atword" ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e2(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
  }, isAtWordPlaceholderNode: function(e2) {
    return e2 && e2.type === "value-atword" && e2.value.startsWith("prettier-placeholder-");
  }, isModuleRuleName: function(e2) {
    return pN.has(e2);
  } }, vN = function(e2, t2) {
    let n2 = 0;
    for (let r2 = 0; r2 < e2.line - 1; ++r2)
      n2 = t2.indexOf("\n", n2) + 1;
    return n2 + e2.column;
  };
  const { getLast: FN, skipEverythingButNewLine: SN } = yi$2;
  function xN(e2, t2) {
    return typeof e2.sourceIndex == "number" ? e2.sourceIndex : e2.source ? vN(e2.source.start, t2) - 1 : null;
  }
  function wN(e2, t2) {
    if (e2.type === "css-comment" && e2.inline)
      return SN(t2, e2.source.startOffset);
    const n2 = e2.nodes && FN(e2.nodes);
    return n2 && e2.source && !e2.source.end && (e2 = n2), e2.source && e2.source.end ? vN(e2.source.end, t2) : null;
  }
  function TN(e2, t2, n2) {
    e2.source && (e2.source.startOffset = xN(e2, n2) + t2, e2.source.endOffset = wN(e2, n2) + t2);
    for (const r2 in e2) {
      const i2 = e2[r2];
      r2 !== "source" && i2 && typeof i2 == "object" && TN(i2, t2, n2);
    }
  }
  function BN(e2) {
    let t2 = e2.source.startOffset;
    return typeof e2.prop == "string" && (t2 += e2.prop.length), e2.type === "css-atrule" && typeof e2.name == "string" && (t2 += 1 + e2.name.length + e2.raws.afterName.match(/^\s*:?\s*/)[0].length), e2.type !== "css-atrule" && e2.raws && typeof e2.raws.between == "string" && (t2 += e2.raws.between.length), t2;
  }
  var NN = { locStart: function(e2) {
    return e2.source.startOffset;
  }, locEnd: function(e2) {
    return e2.source.endOffset;
  }, calculateLoc: function e2(t2, n2) {
    t2.source && (t2.source.startOffset = xN(t2, n2), t2.source.endOffset = wN(t2, n2));
    for (const r2 in t2) {
      const i2 = t2[r2];
      r2 !== "source" && i2 && typeof i2 == "object" && (i2.type === "value-root" || i2.type === "value-unknown" ? TN(i2, BN(t2), i2.text || i2.value) : e2(i2, n2));
    }
  }, replaceQuotesInInlineComments: function(e2) {
    let t2, n2 = "initial", r2 = "initial", i2 = false;
    const u2 = [];
    for (let o2 = 0; o2 < e2.length; o2++) {
      const s2 = e2[o2];
      switch (n2) {
        case "initial":
          if (s2 === "'") {
            n2 = "single-quotes";
            continue;
          }
          if (s2 === '"') {
            n2 = "double-quotes";
            continue;
          }
          if ((s2 === "u" || s2 === "U") && e2.slice(o2, o2 + 4).toLowerCase() === "url(") {
            n2 = "url", o2 += 3;
            continue;
          }
          if (s2 === "*" && e2[o2 - 1] === "/") {
            n2 = "comment-block";
            continue;
          }
          if (s2 === "/" && e2[o2 - 1] === "/") {
            n2 = "comment-inline", t2 = o2 - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (s2 === "'" && e2[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
            return e2;
          continue;
        case "double-quotes":
          if (s2 === '"' && e2[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
            return e2;
          continue;
        case "url":
          if (s2 === ")" && (n2 = "initial"), s2 === "\n" || s2 === "\r")
            return e2;
          if (s2 === "'") {
            n2 = "single-quotes", r2 = "url";
            continue;
          }
          if (s2 === '"') {
            n2 = "double-quotes", r2 = "url";
            continue;
          }
          continue;
        case "comment-block":
          s2 === "/" && e2[o2 - 1] === "*" && (n2 = "initial");
          continue;
        case "comment-inline":
          s2 !== '"' && s2 !== "'" && s2 !== "*" || (i2 = true), s2 !== "\n" && s2 !== "\r" || (i2 && u2.push([t2, o2]), n2 = "initial", i2 = false);
          continue;
      }
    }
    for (const [t3, n3] of u2)
      e2 = e2.slice(0, t3) + e2.slice(t3, n3).replace(/["'*]/g, " ") + e2.slice(n3);
    return e2;
  } };
  const { printNumber: kN, printString: PN, hasNewline: ON, isFrontMatterNode: IN, isNextLineEmpty: LN, isNonEmptyArray: jN } = yi$2, { builders: { join: _N, line: MN, hardline: RN, softline: $N, group: VN, fill: WN, indent: qN, dedent: UN, ifBreak: zN, breakParent: GN }, utils: { removeLines: HN, getDocParts: JN } } = eu$1, { insertPragma: XN } = aN, { getAncestorNode: YN, getPropOfDeclNode: KN, maybeToLowerCase: QN, insideValueFunctionNode: ZN, insideICSSRuleNode: ek, insideAtRuleNode: tk, insideURLFunctionInImportAtRuleNode: nk, isKeyframeAtRuleKeywords: rk, isWideKeywords: ik, isSCSS: uk, isLastNode: ok, isLessParser: sk, isSCSSControlDirectiveNode: ak, isDetachedRulesetDeclarationNode: ck, isRelationalOperatorNode: lk, isEqualityOperatorNode: pk, isMultiplicationNode: fk, isDivisionNode: dk, isAdditionNode: hk, isSubtractionNode: gk, isMathOperatorNode: mk, isEachKeywordNode: yk, isForKeywordNode: Dk, isURLFunctionNode: Ek, isIfElseKeywordNode: Ck, hasComposesNode: bk, hasParensAroundNode: Ak, hasEmptyRawBefore: vk, isKeyValuePairNode: Fk, isKeyInValuePairNode: Sk, isDetachedRulesetCallNode: xk, isTemplatePlaceholderNode: wk, isTemplatePropNode: Tk, isPostcssSimpleVarNode: Bk, isSCSSMapItemNode: Nk, isInlineValueCommentNode: kk, isHashNode: Pk, isLeftCurlyBraceNode: Ok, isRightCurlyBraceNode: Ik, isWordNode: Lk, isColonNode: jk, isMediaAndSupportsKeywords: _k, isColorAdjusterFuncNode: Mk, lastLineHasInlineComment: Rk, isAtWordPlaceholderNode: $k } = AN, { locStart: Vk, locEnd: Wk } = NN;
  function qk(e2) {
    return e2.trailingComma === "es5" || e2.trailingComma === "all";
  }
  function Uk(e2, t2, n2) {
    const r2 = [];
    return e2.each((e3, i2, u2) => {
      const o2 = u2[i2 - 1];
      if (o2 && o2.type === "css-comment" && o2.text.trim() === "prettier-ignore") {
        const n3 = e3.getValue();
        r2.push(t2.originalText.slice(Vk(n3), Wk(n3)));
      } else
        r2.push(n2());
      i2 !== u2.length - 1 && (u2[i2 + 1].type === "css-comment" && !ON(t2.originalText, Vk(u2[i2 + 1]), { backwards: true }) && !IN(u2[i2]) || u2[i2 + 1].type === "css-atrule" && u2[i2 + 1].name === "else" && u2[i2].type !== "css-comment" ? r2.push(" ") : (r2.push(t2.__isHTMLStyleAttribute ? MN : RN), LN(t2.originalText, e3.getValue(), Wk) && !IN(u2[i2]) && r2.push(RN)));
    }, "nodes"), r2;
  }
  const zk = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Gk = new RegExp(zk.source + `|(${/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source})?(${/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source})(${/[A-Za-z]+/g.source})?`, "g");
  function Hk(e2, t2) {
    return e2.replace(zk, (e3) => PN(e3, t2));
  }
  function Jk(e2, t2) {
    const n2 = t2.singleQuote ? "'" : '"';
    return e2.includes('"') || e2.includes("'") ? e2 : n2 + e2 + n2;
  }
  function Xk(e2) {
    return e2.replace(Gk, (e3, t2, n2, r2, i2) => !n2 && r2 ? Yk(r2) + QN(i2 || "") : e3);
  }
  function Yk(e2) {
    return kN(e2).replace(/\.0(?=$|e)/, "");
  }
  var Kk = { print: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!r2)
      return "";
    if (typeof r2 == "string")
      return r2;
    switch (r2.type) {
      case "front-matter":
        return [r2.raw, RN];
      case "css-root": {
        const i2 = Uk(e2, t2, n2), u2 = r2.raws.after.trim();
        return [i2, u2 ? ` ${u2}` : "", JN(i2).length > 0 ? RN : ""];
      }
      case "css-comment": {
        const e3 = r2.inline || r2.raws.inline, n3 = t2.originalText.slice(Vk(r2), Wk(r2));
        return e3 ? n3.trimEnd() : n3;
      }
      case "css-rule":
        return [n2("selector"), r2.important ? " !important" : "", r2.nodes ? [r2.selector && r2.selector.type === "selector-unknown" && Rk(r2.selector.value) ? MN : " ", "{", r2.nodes.length > 0 ? qN([RN, Uk(e2, t2, n2)]) : "", RN, "}", ck(r2) ? ";" : ""] : ";"];
      case "css-decl": {
        const i2 = e2.getParentNode(), { between: u2 } = r2.raws, o2 = u2.trim(), s2 = o2 === ":";
        let a2 = bk(r2) ? HN(n2("value")) : n2("value");
        return !s2 && Rk(o2) && (a2 = qN([RN, UN(a2)])), [r2.raws.before.replace(/[\s;]/g, ""), ek(e2) ? r2.prop : QN(r2.prop), o2.startsWith("//") ? " " : "", o2, r2.extend ? "" : " ", sk(t2) && r2.extend && r2.selector ? ["extend(", n2("selector"), ")"] : "", a2, r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "", r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "", r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "", r2.nodes ? [" {", qN([$N, Uk(e2, t2, n2)]), $N, "}"] : Tk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";" ? "" : t2.__isHTMLStyleAttribute && ok(e2, r2) ? zN(";") : ";"];
      }
      case "css-atrule": {
        const i2 = e2.getParentNode(), u2 = wk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";";
        if (sk(t2)) {
          if (r2.mixin)
            return [n2("selector"), r2.important ? " !important" : "", u2 ? "" : ";"];
          if (r2.function)
            return [r2.name, n2("params"), u2 ? "" : ";"];
          if (r2.variable)
            return ["@", r2.name, ": ", r2.value ? n2("value") : "", r2.raws.between.trim() ? r2.raws.between.trim() + " " : "", r2.nodes ? ["{", qN([r2.nodes.length > 0 ? $N : "", Uk(e2, t2, n2)]), $N, "}"] : "", u2 ? "" : ";"];
        }
        return ["@", xk(r2) || r2.name.endsWith(":") ? r2.name : QN(r2.name), r2.params ? [xk(r2) ? "" : wk(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? [RN, RN] : /^\s*\n/.test(r2.raws.afterName) ? RN : " " : " ", n2("params")] : "", r2.selector ? qN([" ", n2("selector")]) : "", r2.value ? VN([" ", n2("value"), ak(r2) ? Ak(r2) ? " " : MN : ""]) : r2.name === "else" ? " " : "", r2.nodes ? [ak(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && Rk(r2.selector.value) || !r2.selector && typeof r2.params == "string" && Rk(r2.params) ? MN : " ", "{", qN([r2.nodes.length > 0 ? $N : "", Uk(e2, t2, n2)]), $N, "}"] : u2 ? "" : ";"];
      }
      case "media-query-list": {
        const t3 = [];
        return e2.each((e3) => {
          const r3 = e3.getValue();
          r3.type === "media-query" && r3.value === "" || t3.push(n2());
        }, "nodes"), VN(qN(_N(MN, t3)));
      }
      case "media-query":
        return [_N(" ", e2.map(n2, "nodes")), ok(e2, r2) ? "" : ","];
      case "media-type":
        return Xk(Hk(r2.value, t2));
      case "media-feature-expression":
        return r2.nodes ? ["(", ...e2.map(n2, "nodes"), ")"] : r2.value;
      case "media-feature":
        return QN(Hk(r2.value.replace(/ +/g, " "), t2));
      case "media-colon":
        return [r2.value, " "];
      case "media-value":
        return Xk(Hk(r2.value, t2));
      case "media-keyword":
        return Hk(r2.value, t2);
      case "media-url":
        return Hk(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t2);
      case "media-unknown":
        return r2.value;
      case "selector-root":
        return VN([tk(e2, "custom-selector") ? [YN(e2, "css-atrule").customSelector, MN] : "", _N([",", tk(e2, ["extend", "custom-selector", "nest"]) ? MN : RN], e2.map(n2, "nodes"))]);
      case "selector-selector":
        return VN(qN(e2.map(n2, "nodes")));
      case "selector-comment":
        return r2.value;
      case "selector-string":
        return Hk(r2.value, t2);
      case "selector-tag": {
        const t3 = e2.getParentNode(), n3 = t3 && t3.nodes.indexOf(r2), i2 = n3 && t3.nodes[n3 - 1];
        return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", i2.type === "selector-nesting" ? r2.value : Xk(rk(e2, r2.value) ? r2.value.toLowerCase() : r2.value)];
      }
      case "selector-id":
        return ["#", r2.value];
      case "selector-class":
        return [".", Xk(Hk(r2.value, t2))];
      case "selector-attribute":
        return ["[", r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.attribute.trim(), r2.operator ? r2.operator : "", r2.value ? Jk(Hk(r2.value.trim(), t2), t2) : "", r2.insensitive ? " i" : "", "]"];
      case "selector-combinator":
        if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
          const t3 = e2.getParentNode();
          return [t3.type === "selector-selector" && t3.nodes[0] === r2 ? "" : MN, r2.value, ok(e2, r2) ? "" : " "];
        }
        return [r2.value.trim().startsWith("(") ? MN : "", Xk(Hk(r2.value.trim(), t2)) || MN];
      case "selector-universal":
        return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.value];
      case "selector-pseudo":
        return [QN(r2.value), jN(r2.nodes) ? ["(", _N(", ", e2.map(n2, "nodes")), ")"] : ""];
      case "selector-nesting":
        return r2.value;
      case "selector-unknown": {
        const n3 = YN(e2, "css-rule");
        if (n3 && n3.isSCSSNesterProperty)
          return Xk(Hk(QN(r2.value), t2));
        const i2 = e2.getParentNode();
        if (i2.raws && i2.raws.selector) {
          const e3 = Vk(i2), n4 = e3 + i2.raws.selector.length;
          return t2.originalText.slice(e3, n4).trim();
        }
        const u2 = e2.getParentNode(1);
        if (i2.type === "value-paren_group" && u2 && u2.type === "value-func" && u2.value === "selector") {
          const e3 = Vk(i2.open) + 1, n4 = Wk(i2.close) - 1, r3 = t2.originalText.slice(e3, n4).trim();
          return Rk(r3) ? [GN, r3] : r3;
        }
        return r2.value;
      }
      case "value-value":
      case "value-root":
        return n2("group");
      case "value-comment":
        return t2.originalText.slice(Vk(r2), Wk(r2));
      case "value-comma_group": {
        const t3 = e2.getParentNode(), i2 = e2.getParentNode(1), u2 = KN(e2), o2 = u2 && t3.type === "value-value" && (u2 === "grid" || u2.startsWith("grid-template")), s2 = YN(e2, "css-atrule"), a2 = s2 && ak(s2), c2 = r2.groups.some((e3) => kk(e3)), l2 = e2.map(n2, "groups"), p2 = [], f2 = ZN(e2, "url");
        let d2 = false, h2 = false;
        for (let n3 = 0; n3 < r2.groups.length; ++n3) {
          p2.push(l2[n3]);
          const u3 = r2.groups[n3 - 1], c3 = r2.groups[n3], g2 = r2.groups[n3 + 1], m2 = r2.groups[n3 + 2];
          if (f2) {
            (g2 && hk(g2) || hk(c3)) && p2.push(" ");
            continue;
          }
          if (tk(e2, "forward") && c3.type === "value-word" && c3.value && u3.type === "value-word" && u3.value === "as" && g2.type === "value-operator" && g2.value === "*")
            continue;
          if (!g2)
            continue;
          if (c3.type === "value-word" && c3.value.endsWith("-") && $k(g2))
            continue;
          const y2 = c3.type === "value-string" && c3.value.startsWith("#{"), D2 = d2 && g2.type === "value-string" && g2.value.endsWith("}");
          if (y2 || D2) {
            d2 = !d2;
            continue;
          }
          if (d2)
            continue;
          if (jk(c3) || jk(g2))
            continue;
          if (c3.type === "value-atword" && c3.value === "")
            continue;
          if (c3.value === "~")
            continue;
          if (c3.value && c3.value.includes("\\") && g2 && g2.type !== "value-comment")
            continue;
          if (u3 && u3.value && u3.value.indexOf("\\") === u3.value.length - 1 && c3.type === "value-operator" && c3.value === "/")
            continue;
          if (c3.value === "\\")
            continue;
          if (Bk(c3, g2))
            continue;
          if (Pk(c3) || Ok(c3) || Ik(g2) || Ok(g2) && vk(g2) || Ik(c3) && vk(g2))
            continue;
          if (c3.value === "--" && Pk(g2))
            continue;
          const E2 = mk(c3), C2 = mk(g2);
          if ((E2 && Pk(g2) || C2 && Ik(c3)) && vk(g2))
            continue;
          if (!u3 && dk(c3))
            continue;
          if (ZN(e2, "calc") && (hk(c3) || hk(g2) || gk(c3) || gk(g2)) && vk(g2))
            continue;
          const b2 = (hk(c3) || gk(c3)) && n3 === 0 && (g2.type === "value-number" || g2.isHex) && i2 && Mk(i2) && !vk(g2), A2 = m2 && m2.type === "value-func" || m2 && Lk(m2) || c3.type === "value-func" || Lk(c3), v2 = g2.type === "value-func" || Lk(g2) || u3 && u3.type === "value-func" || u3 && Lk(u3);
          if (fk(g2) || fk(c3) || ZN(e2, "calc") || b2 || !(dk(g2) && !A2 || dk(c3) && !v2 || hk(g2) && !A2 || hk(c3) && !v2 || gk(g2) || gk(c3)) || !(vk(g2) || E2 && (!u3 || u3 && mk(u3))))
            if (kk(c3)) {
              if (t3.type === "value-paren_group") {
                p2.push(UN(RN));
                continue;
              }
              p2.push(RN);
            } else
              a2 && (pk(g2) || lk(g2) || Ck(g2) || yk(c3) || Dk(c3)) || s2 && s2.name.toLowerCase() === "namespace" ? p2.push(" ") : o2 ? c3.source && g2.source && c3.source.start.line !== g2.source.start.line ? (p2.push(RN), h2 = true) : p2.push(" ") : C2 ? p2.push(" ") : g2 && g2.value === "..." || $k(c3) && $k(g2) && Wk(c3) === Vk(g2) || p2.push(MN);
        }
        return c2 && p2.push(GN), h2 && p2.unshift(RN), a2 ? VN(qN(p2)) : nk(e2) ? VN(WN(p2)) : VN(qN(WN(p2)));
      }
      case "value-paren_group": {
        const i2 = e2.getParentNode();
        if (i2 && Ek(i2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
          return [r2.open ? n2("open") : "", _N(",", e2.map(n2, "groups")), r2.close ? n2("close") : ""];
        if (!r2.open) {
          const t3 = e2.map(n2, "groups"), r3 = [];
          for (let e3 = 0; e3 < t3.length; e3++)
            e3 !== 0 && r3.push([",", MN]), r3.push(t3[e3]);
          return VN(qN(WN(r3)));
        }
        const u2 = Nk(e2), o2 = Ln$2(r2.groups), s2 = o2 && o2.type === "value-comment", a2 = Sk(r2, i2), c2 = VN([r2.open ? n2("open") : "", qN([$N, _N([",", MN], e2.map((e3) => {
          const t3 = e3.getValue(), r3 = n2();
          if (Fk(t3) && t3.type === "value-comma_group" && t3.groups && t3.groups[0].type !== "value-paren_group" && t3.groups[2] && t3.groups[2].type === "value-paren_group") {
            const e4 = JN(r3.contents.contents);
            return e4[1] = VN(e4[1]), VN(UN(r3));
          }
          return r3;
        }, "groups"))]), zN(!s2 && uk(t2.parser, t2.originalText) && u2 && qk(t2) ? "," : ""), $N, r2.close ? n2("close") : ""], { shouldBreak: u2 && !a2 });
        return a2 ? UN(c2) : c2;
      }
      case "value-func":
        return [r2.value, tk(e2, "supports") && _k(r2) ? " " : "", n2("group")];
      case "value-paren":
        return r2.value;
      case "value-number":
        return [Yk(r2.value), QN(r2.unit)];
      case "value-operator":
        return r2.value;
      case "value-word":
        return r2.isColor && r2.isHex || ik(r2.value) ? r2.value.toLowerCase() : r2.value;
      case "value-colon": {
        const t3 = e2.getParentNode(), n3 = t3 && t3.groups.indexOf(r2), i2 = n3 && t3.groups[n3 - 1];
        return [r2.value, i2 && typeof i2.value == "string" && Ln$2(i2.value) === "\\" || ZN(e2, "url") ? "" : MN];
      }
      case "value-comma":
        return [r2.value, " "];
      case "value-string":
        return PN(r2.raws.quote + r2.value + r2.raws.quote, t2);
      case "value-atword":
        return ["@", r2.value];
      case "value-unicode-range":
      case "value-unknown":
        return r2.value;
      default:
        throw new Error(`Unknown postcss type ${JSON.stringify(r2.type)}`);
    }
  }, embed: uN, insertPragma: XN, massageAstNode: eN }, Qk = { singleQuote: WB.singleQuote }, Zk = { name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 }, eP = { name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 }, tP = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
  var nP = { languages: [Xd({ name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 }, (e2) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e2.extensions, ".wxss"] })), Xd(Zk, () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), Xd(eP, () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), Xd(tP, () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], options: Qk, printers: { postcss: Kk }, parsers: void 0 };
  var rP = { locStart: function(e2) {
    return e2.loc.start.offset;
  }, locEnd: function(e2) {
    return e2.loc.end.offset;
  } };
  function iP(e2, t2) {
    if (e2.type === "TextNode") {
      const n2 = e2.chars.trim();
      if (!n2)
        return null;
      t2.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
    }
    e2.type === "AttrNode" && e2.name.toLowerCase() === "class" && delete t2.value;
  }
  iP.ignoredProperties = new Set(["loc", "selfClosing"]);
  var uP = iP;
  const oP = new Set(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
  function sP(e2) {
    return aP(e2, ["TextNode"]) && !/\S/.test(e2.chars);
  }
  function aP(e2, t2) {
    return e2 && t2.includes(e2.type);
  }
  function cP(e2, t2) {
    return aP(e2.getParentNode(0), t2);
  }
  function lP(e2, t2) {
    const n2 = e2.getValue(), r2 = e2.getParentNode(0) || {}, i2 = r2.children || r2.body || r2.parts || [], u2 = i2.indexOf(n2);
    return u2 !== -1 && i2[u2 + t2];
  }
  function pP(e2, t2 = 1) {
    return lP(e2, -t2);
  }
  function fP(e2) {
    return lP(e2, 1);
  }
  function dP(e2) {
    return aP(e2, ["MustacheCommentStatement"]) && typeof e2.value == "string" && e2.value.trim() === "prettier-ignore";
  }
  var hP = { getNextNode: fP, getPreviousNode: pP, hasPrettierIgnore: function(e2) {
    const t2 = e2.getValue(), n2 = pP(e2, 2);
    return dP(t2) || dP(n2);
  }, isLastNodeOfSiblings: function(e2) {
    const t2 = e2.getValue(), n2 = e2.getParentNode(0);
    return !(!cP(e2, ["ElementNode"]) || Ln$2(n2.children) !== t2) || !(!cP(e2, ["Block"]) || Ln$2(n2.body) !== t2);
  }, isNextNodeOfSomeType: function(e2, t2) {
    return aP(fP(e2), t2);
  }, isNodeOfSomeType: aP, isParentOfSomeType: cP, isPreviousNodeOfSomeType: function(e2, t2) {
    return aP(pP(e2), t2);
  }, isVoid: function(e2) {
    return function(e3) {
      return aP(e3, ["ElementNode"]) && typeof e3.tag == "string" && (function(e4) {
        return e4.toUpperCase() === e4;
      }(e3.tag[0]) || e3.tag.includes("."));
    }(e2) && e2.children.every((e3) => sP(e3)) || oP.has(e2.tag);
  }, isWhitespaceNode: sP };
  const { builders: { dedent: gP, fill: mP, group: yP, hardline: DP, ifBreak: EP, indent: CP, join: bP, line: AP, softline: vP }, utils: { getDocParts: FP, replaceTextEndOfLine: SP } } = eu$1, { isNonEmptyArray: xP } = yi$2, { locStart: wP, locEnd: TP } = rP, { getNextNode: BP, getPreviousNode: NP, hasPrettierIgnore: kP, isLastNodeOfSiblings: PP, isNextNodeOfSomeType: OP, isNodeOfSomeType: IP, isParentOfSomeType: LP, isPreviousNodeOfSomeType: jP, isVoid: _P, isWhitespaceNode: MP } = hP;
  function RP(e2, t2) {
    return wP(e2) - wP(t2);
  }
  function $P(e2, t2, n2) {
    const r2 = e2.getValue().children.every((e3) => MP(e3));
    return t2.htmlWhitespaceSensitivity === "ignore" && r2 ? "" : e2.map((e3, r3) => {
      const i2 = n2();
      return r3 === 0 && t2.htmlWhitespaceSensitivity === "ignore" ? [vP, i2] : i2;
    }, "children");
  }
  function VP(e2) {
    return _P(e2) ? EP([vP, "/>"], [" />", vP]) : EP([vP, ">"], ">");
  }
  function WP(e2) {
    return [e2.escaped === false ? "{{{" : "{{", e2.strip && e2.strip.open ? "~" : ""];
  }
  function qP(e2) {
    const t2 = e2.escaped === false ? "}}}" : "}}";
    return [e2.strip && e2.strip.close ? "~" : "", t2];
  }
  function UP(e2) {
    return [WP(e2), e2.closeStrip.open ? "~" : "", "/"];
  }
  function zP(e2) {
    const t2 = qP(e2);
    return [e2.closeStrip.close ? "~" : "", t2];
  }
  function GP(e2) {
    return [WP(e2), e2.inverseStrip.open ? "~" : ""];
  }
  function HP(e2) {
    const t2 = qP(e2);
    return [e2.inverseStrip.close ? "~" : "", t2];
  }
  function JP(e2, t2) {
    const n2 = e2.getValue(), r2 = function(e3) {
      return [WP(e3), e3.openStrip.open ? "~" : "", "#"];
    }(n2), i2 = function(e3) {
      const t3 = qP(e3);
      return [e3.openStrip.close ? "~" : "", t3];
    }(n2), u2 = [aO(e2, t2)], o2 = cO(e2, t2);
    if (o2 && u2.push(AP, o2), xP(n2.program.blockParams)) {
      const e3 = lO(n2.program);
      u2.push(AP, e3);
    }
    return yP([r2, CP(u2), vP, i2]);
  }
  function XP(e2, t2) {
    return [t2.htmlWhitespaceSensitivity === "ignore" ? DP : "", GP(e2), "else", HP(e2)];
  }
  function YP(e2, t2) {
    const n2 = e2.getParentNode(1);
    return [GP(n2), "else if ", cO(e2, t2), HP(n2)];
  }
  function KP(e2, t2, n2) {
    const r2 = e2.getValue();
    if (n2.htmlWhitespaceSensitivity === "ignore") {
      return [QP(r2) ? vP : DP, UP(r2), t2("path"), zP(r2)];
    }
    return [UP(r2), t2("path"), zP(r2)];
  }
  function QP(e2) {
    return IP(e2, ["BlockStatement"]) && e2.program.body.every((e3) => MP(e3));
  }
  function ZP(e2) {
    return IP(e2, ["BlockStatement"]) && e2.inverse;
  }
  function eO(e2, t2, n2) {
    if (QP(e2.getValue()))
      return "";
    const r2 = t2("program");
    return n2.htmlWhitespaceSensitivity === "ignore" ? CP([DP, r2]) : CP(r2);
  }
  function tO(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = t2("inverse"), u2 = n2.htmlWhitespaceSensitivity === "ignore" ? [DP, i2] : i2;
    return function(e3) {
      return ZP(e3) && e3.inverse.body.length === 1 && IP(e3.inverse.body[0], ["BlockStatement"]) && e3.inverse.body[0].path.parts[0] === "if";
    }(r2) ? u2 : ZP(r2) ? [XP(r2, n2), CP(u2)] : "";
  }
  function nO(e2) {
    return FP(bP(AP, function(e3) {
      return e3.split(/[\t\n\f\r ]+/);
    }(e2)));
  }
  function rO(e2) {
    return (e2 = typeof e2 == "string" ? e2 : "").split("\n").length - 1;
  }
  function iO(e2 = 0) {
    return new Array(Math.min(e2, 2)).fill(DP);
  }
  function uO(e2, t2) {
    const n2 = { quote: '"', regex: /"/g }, r2 = { quote: "'", regex: /'/g }, i2 = e2.singleQuote ? r2 : n2, u2 = i2 === r2 ? n2 : r2;
    let o2 = false;
    if (t2.includes(i2.quote) || t2.includes(u2.quote)) {
      o2 = (t2.match(i2.regex) || []).length > (t2.match(u2.regex) || []).length;
    }
    return o2 ? u2 : i2;
  }
  function oO(e2, t2) {
    const n2 = aO(e2, t2), r2 = cO(e2, t2);
    return r2 ? CP([n2, AP, yP(r2)]) : n2;
  }
  function sO(e2, t2) {
    const n2 = aO(e2, t2), r2 = cO(e2, t2);
    return r2 ? [CP([n2, AP, r2]), vP] : n2;
  }
  function aO(e2, t2) {
    return t2("path");
  }
  function cO(e2, t2) {
    const n2 = e2.getValue(), r2 = [];
    if (n2.params.length > 0) {
      const n3 = e2.map(t2, "params");
      r2.push(...n3);
    }
    if (n2.hash && n2.hash.pairs.length > 0) {
      const e3 = t2("hash");
      r2.push(e3);
    }
    return r2.length === 0 ? "" : bP(AP, r2);
  }
  function lO(e2) {
    return ["as |", e2.blockParams.join(" "), "|"];
  }
  var pO = { print: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!r2)
      return "";
    if (kP(e2))
      return t2.originalText.slice(wP(r2), TP(r2));
    switch (r2.type) {
      case "Block":
      case "Program":
      case "Template":
        return yP(e2.map(n2, "body"));
      case "ElementNode": {
        const i2 = yP(function(e3, t3) {
          const n3 = e3.getValue(), r3 = ["attributes", "modifiers", "comments"].filter((e4) => xP(n3[e4])), i3 = r3.flatMap((e4) => n3[e4]).sort(RP);
          for (const n4 of r3)
            e3.each((e4) => {
              const n5 = i3.indexOf(e4.getValue());
              i3.splice(n5, 1, [AP, t3()]);
            }, n4);
          xP(n3.blockParams) && i3.push(AP, lO(n3));
          return ["<", n3.tag, CP(i3), VP(n3)];
        }(e2, n2)), u2 = t2.htmlWhitespaceSensitivity === "ignore" && OP(e2, ["ElementNode"]) ? vP : "";
        if (_P(r2))
          return [i2, u2];
        const o2 = ["</", r2.tag, ">"];
        return r2.children.length === 0 ? [i2, CP(o2), u2] : t2.htmlWhitespaceSensitivity === "ignore" ? [i2, CP($P(e2, t2, n2)), DP, CP(o2), u2] : [i2, CP(yP($P(e2, t2, n2))), CP(o2), u2];
      }
      case "BlockStatement": {
        const i2 = e2.getParentNode(1);
        return i2 && i2.inverse && i2.inverse.body.length === 1 && i2.inverse.body[0] === r2 && i2.inverse.body[0].path.parts[0] === "if" ? [YP(e2, n2), eO(e2, n2, t2), tO(e2, n2, t2)] : [JP(e2, n2), yP([eO(e2, n2, t2), tO(e2, n2, t2), KP(e2, n2, t2)])];
      }
      case "ElementModifierStatement":
        return yP(["{{", sO(e2, n2), "}}"]);
      case "MustacheStatement":
        return yP([WP(r2), sO(e2, n2), qP(r2)]);
      case "SubExpression":
        return yP(["(", oO(e2, n2), vP, ")"]);
      case "AttrNode": {
        const e3 = r2.value.type === "TextNode";
        if (e3 && r2.value.chars === "" && wP(r2.value) === TP(r2.value))
          return r2.name;
        const i2 = e3 ? uO(t2, r2.value.chars).quote : r2.value.type === "ConcatStatement" ? uO(t2, r2.value.parts.filter((e4) => e4.type === "TextNode").map((e4) => e4.chars).join("")).quote : "", u2 = n2("value");
        return [r2.name, "=", i2, r2.name === "class" && i2 ? yP(CP(u2)) : u2, i2];
      }
      case "ConcatStatement":
        return e2.map(n2, "parts");
      case "Hash":
        return bP(AP, e2.map(n2, "pairs"));
      case "HashPair":
        return [r2.key, "=", n2("value")];
      case "TextNode": {
        let n3 = r2.chars.replace(/{{/g, "\\{{");
        const i2 = function(e3) {
          for (let t3 = 0; t3 < 2; t3++) {
            const n4 = e3.getParentNode(t3);
            if (n4 && n4.type === "AttrNode")
              return n4.name.toLowerCase();
          }
        }(e2);
        if (i2) {
          if (i2 === "class") {
            const t3 = n3.trim().split(/\s+/).join(" ");
            let r3 = false, i3 = false;
            return LP(e2, ["ConcatStatement"]) && (jP(e2, ["MustacheStatement"]) && /^\s/.test(n3) && (r3 = true), OP(e2, ["MustacheStatement"]) && /\s$/.test(n3) && t3 !== "" && (i3 = true)), [r3 ? AP : "", t3, i3 ? AP : ""];
          }
          return SP(n3);
        }
        const u2 = /^[\t\n\f\r ]*$/.test(n3), o2 = !NP(e2), s2 = !BP(e2);
        if (t2.htmlWhitespaceSensitivity !== "ignore") {
          const t3 = /^[\t\n\f\r ]*/, r3 = /[\t\n\f\r ]*$/, i3 = s2 && LP(e2, ["Template"]), a3 = o2 && LP(e2, ["Template"]);
          if (u2) {
            if (a3 || i3)
              return "";
            let t4 = [AP];
            const r4 = rO(n3);
            return r4 && (t4 = iO(r4)), PP(e2) && (t4 = t4.map((e3) => gP(e3))), t4;
          }
          const [c3] = n3.match(t3), [l3] = n3.match(r3);
          let p3 = [];
          if (c3) {
            p3 = [AP];
            const e3 = rO(c3);
            e3 && (p3 = iO(e3)), n3 = n3.replace(t3, "");
          }
          let f3 = [];
          if (l3) {
            if (!i3) {
              f3 = [AP];
              const t4 = rO(l3);
              t4 && (f3 = iO(t4)), PP(e2) && (f3 = f3.map((e3) => gP(e3)));
            }
            n3 = n3.replace(r3, "");
          }
          return [...p3, mP(nO(n3)), ...f3];
        }
        const a2 = rO(n3);
        let c2 = function(e3) {
          return rO(((e3 = typeof e3 == "string" ? e3 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
        }(n3), l2 = function(e3) {
          return rO(((e3 = typeof e3 == "string" ? e3 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
        }(n3);
        if ((o2 || s2) && u2 && LP(e2, ["Block", "ElementNode", "Template"]))
          return "";
        u2 && a2 ? (c2 = Math.min(a2, 2), l2 = 0) : (OP(e2, ["BlockStatement", "ElementNode"]) && (l2 = Math.max(l2, 1)), jP(e2, ["BlockStatement", "ElementNode"]) && (c2 = Math.max(c2, 1)));
        let p2 = "", f2 = "";
        return l2 === 0 && OP(e2, ["MustacheStatement"]) && (f2 = " "), c2 === 0 && jP(e2, ["MustacheStatement"]) && (p2 = " "), o2 && (c2 = 0, p2 = ""), s2 && (l2 = 0, f2 = ""), n3 = n3.replace(/^[\t\n\f\r ]+/g, p2).replace(/[\t\n\f\r ]+$/, f2), [...iO(c2), mP(nO(n3)), ...iO(l2)];
      }
      case "MustacheCommentStatement": {
        const e3 = wP(r2), n3 = TP(r2), i2 = t2.originalText.charAt(e3 + 2) === "~", u2 = t2.originalText.charAt(n3 - 3) === "~", o2 = r2.value.includes("}}") ? "--" : "";
        return ["{{", i2 ? "~" : "", "!", o2, r2.value, o2, u2 ? "~" : "", "}}"];
      }
      case "PathExpression":
        return r2.original;
      case "BooleanLiteral":
        return String(r2.value);
      case "CommentStatement":
        return ["<!--", r2.value, "-->"];
      case "StringLiteral":
        return function(e3, t3) {
          const { quote: n3, regex: r3 } = uO(t3, e3);
          return [n3, e3.replace(r3, `\\${n3}`), n3];
        }(r2.value, t2);
      case "NumberLiteral":
        return String(r2.value);
      case "UndefinedLiteral":
        return "undefined";
      case "NullLiteral":
        return "null";
      default:
        throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
    }
  }, massageAstNode: uP };
  var fO = { languages: [Xd({ name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 }, () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], printers: { glimmer: pO }, parsers: void 0 };
  var dO = { hasPragma: function(e2) {
    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e2);
  }, insertPragma: function(e2) {
    return "# @format\n\n" + e2;
  } };
  var hO = { locStart: function(e2) {
    return typeof e2.start == "number" ? e2.start : e2.loc && e2.loc.start;
  }, locEnd: function(e2) {
    return typeof e2.end == "number" ? e2.end : e2.loc && e2.loc.end;
  } };
  const { builders: { join: gO, hardline: mO, line: yO, softline: DO, group: EO, indent: CO, ifBreak: bO } } = eu$1, { isNextLineEmpty: AO, isNonEmptyArray: vO } = yi$2, { insertPragma: FO } = dO, { locStart: SO, locEnd: xO } = hO;
  function wO(e2, t2, n2) {
    if (n2.directives.length === 0)
      return "";
    const r2 = gO(yO, e2.map(t2, "directives"));
    return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? EO([yO, r2]) : [" ", EO(CO([DO, r2]))];
  }
  function TO(e2, t2, n2) {
    const r2 = e2.getValue().length;
    return e2.map((e3, i2) => {
      const u2 = n2();
      return AO(t2.originalText, e3.getValue(), xO) && i2 < r2 - 1 ? [u2, mO] : u2;
    });
  }
  function BO(e2, t2, n2) {
    const r2 = e2.getNode(), i2 = [], { interfaces: u2 } = r2, o2 = e2.map((e3) => n2(e3), "interfaces");
    for (let e3 = 0; e3 < u2.length; e3++) {
      const n3 = u2[e3];
      i2.push(o2[e3]);
      const r3 = u2[e3 + 1];
      if (r3) {
        const e4 = t2.originalText.slice(n3.loc.end, r3.loc.start), u3 = e4.includes("#"), o3 = e4.replace(/#.*/g, "").trim();
        i2.push(o3 === "," ? "," : " &", u3 ? yO : " ");
      }
    }
    return i2;
  }
  function NO() {
  }
  NO.ignoredProperties = new Set(["loc", "comments"]);
  var kO = { print: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!r2)
      return "";
    if (typeof r2 == "string")
      return r2;
    switch (r2.kind) {
      case "Document": {
        const r3 = [];
        return e2.each((e3, i2, u2) => {
          r3.push(n2()), i2 !== u2.length - 1 && (r3.push(mO), AO(t2.originalText, e3.getValue(), xO) && r3.push(mO));
        }, "definitions"), [...r3, mO];
      }
      case "OperationDefinition": {
        const i2 = t2.originalText[SO(r2)] !== "{", u2 = Boolean(r2.name);
        return [i2 ? r2.operation : "", i2 && u2 ? [" ", n2("name")] : "", i2 && !u2 && vO(r2.variableDefinitions) ? " " : "", vO(r2.variableDefinitions) ? EO(["(", CO([DO, gO([bO("", ", "), DO], e2.map(n2, "variableDefinitions"))]), DO, ")"]) : "", wO(e2, n2, r2), r2.selectionSet && (i2 || u2) ? " " : "", n2("selectionSet")];
      }
      case "FragmentDefinition":
        return ["fragment ", n2("name"), vO(r2.variableDefinitions) ? EO(["(", CO([DO, gO([bO("", ", "), DO], e2.map(n2, "variableDefinitions"))]), DO, ")"]) : "", " on ", n2("typeCondition"), wO(e2, n2, r2), " ", n2("selectionSet")];
      case "SelectionSet":
        return ["{", CO([mO, gO(mO, e2.call((e3) => TO(e3, t2, n2), "selections"))]), mO, "}"];
      case "Field":
        return EO([r2.alias ? [n2("alias"), ": "] : "", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e2.call((e3) => TO(e3, t2, n2), "arguments"))]), DO, ")"]) : "", wO(e2, n2, r2), r2.selectionSet ? " " : "", n2("selectionSet")]);
      case "Name":
        return r2.value;
      case "StringValue":
        return r2.block ? ['"""', mO, gO(mO, r2.value.replace(/"""/g, "\\$&").split("\n")), mO, '"""'] : ['"', r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        return r2.value;
      case "BooleanValue":
        return r2.value ? "true" : "false";
      case "NullValue":
        return "null";
      case "Variable":
        return ["$", n2("name")];
      case "ListValue":
        return EO(["[", CO([DO, gO([bO("", ", "), DO], e2.map(n2, "values"))]), DO, "]"]);
      case "ObjectValue":
        return EO(["{", t2.bracketSpacing && r2.fields.length > 0 ? " " : "", CO([DO, gO([bO("", ", "), DO], e2.map(n2, "fields"))]), DO, bO("", t2.bracketSpacing && r2.fields.length > 0 ? " " : ""), "}"]);
      case "ObjectField":
      case "Argument":
        return [n2("name"), ": ", n2("value")];
      case "Directive":
        return ["@", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e2.call((e3) => TO(e3, t2, n2), "arguments"))]), DO, ")"]) : ""];
      case "NamedType":
        return n2("name");
      case "VariableDefinition":
        return [n2("variable"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wO(e2, n2, r2)];
      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BO(e2, t2, n2)] : "", wO(e2, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e2.call((e3) => TO(e3, t2, n2), "fields"))]), mO, "}"] : ""];
      case "FieldDefinition":
        return [n2("description"), r2.description ? mO : "", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e2.call((e3) => TO(e3, t2, n2), "arguments"))]), DO, ")"]) : "", ": ", n2("type"), wO(e2, n2, r2)];
      case "DirectiveDefinition":
        return [n2("description"), r2.description ? mO : "", "directive ", "@", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e2.call((e3) => TO(e3, t2, n2), "arguments"))]), DO, ")"]) : "", r2.repeatable ? " repeatable" : "", " on ", gO(" | ", e2.map(n2, "locations"))];
      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n2("name"), wO(e2, n2, r2), r2.values.length > 0 ? [" {", CO([mO, gO(mO, e2.call((e3) => TO(e3, t2, n2), "values"))]), mO, "}"] : ""];
      case "EnumValueDefinition":
        return [n2("description"), r2.description ? mO : "", n2("name"), wO(e2, n2, r2)];
      case "InputValueDefinition":
        return [n2("description"), r2.description ? r2.description.block ? mO : yO : "", n2("name"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wO(e2, n2, r2)];
      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", n2("name"), wO(e2, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e2.call((e3) => TO(e3, t2, n2), "fields"))]), mO, "}"] : ""];
      case "SchemaDefinition":
        return ["schema", wO(e2, n2, r2), " {", r2.operationTypes.length > 0 ? CO([mO, gO(mO, e2.call((e3) => TO(e3, t2, n2), "operationTypes"))]) : "", mO, "}"];
      case "OperationTypeDefinition":
        return [n2("operation"), ": ", n2("type")];
      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BO(e2, t2, n2)] : "", wO(e2, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e2.call((e3) => TO(e3, t2, n2), "fields"))]), mO, "}"] : ""];
      case "FragmentSpread":
        return ["...", n2("name"), wO(e2, n2, r2)];
      case "InlineFragment":
        return ["...", r2.typeCondition ? [" on ", n2("typeCondition")] : "", wO(e2, n2, r2), " ", n2("selectionSet")];
      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        return EO([n2("description"), r2.description ? mO : "", EO([r2.kind === "UnionTypeExtension" ? "extend " : "", "union ", n2("name"), wO(e2, n2, r2), r2.types.length > 0 ? [" =", bO("", " "), CO([bO([yO, "  "]), gO([yO, "| "], e2.map(n2, "types"))])] : ""])]);
      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n2("name"), wO(e2, n2, r2)];
      case "NonNullType":
        return [n2("type"), "!"];
      case "ListType":
        return ["[", n2("type"), "]"];
      default:
        throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
    }
  }, massageAstNode: NO, hasPrettierIgnore: function(e2) {
    const t2 = e2.getValue();
    return t2 && Array.isArray(t2.comments) && t2.comments.some((e3) => e3.value.trim() === "prettier-ignore");
  }, insertPragma: FO, printComment: function(e2) {
    const t2 = e2.getValue();
    if (t2.kind === "Comment")
      return "#" + t2.value.trimEnd();
    throw new Error("Not a comment: " + JSON.stringify(t2));
  }, canAttachComment: function(e2) {
    return e2.kind && e2.kind !== "Comment";
  } }, PO = { bracketSpacing: WB.bracketSpacing };
  var OO = { languages: [Xd({ name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 }, () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], options: PO, printers: { graphql: kO }, parsers: void 0 };
  var IO = { locStart: function(e2) {
    return e2.position.start.offset;
  }, locEnd: function(e2) {
    return e2.position.end.offset;
  } };
  const { getLast: LO } = yi$2, { locStart: jO, locEnd: _O } = IO, { cjkPattern: MO, kPattern: RO, punctuationPattern: $O } = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" }, VO = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], WO = [...VO, "tableCell", "paragraph", "heading"], qO = new RegExp(RO), UO = new RegExp($O);
  function zO(e2, t2) {
    const [, n2, r2, i2] = t2.slice(e2.position.start.offset, e2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
    return { numberText: n2, marker: r2, leadingSpaces: i2 };
  }
  var GO = { mapAst: function(e2, t2) {
    return function e3(n2, r2, i2) {
      const u2 = Object.assign({}, t2(n2, r2, i2));
      return u2.children && (u2.children = u2.children.map((t3, n3) => e3(t3, n3, [u2, ...i2]))), u2;
    }(e2, null, []);
  }, splitText: function(e2, t2) {
    const n2 = "non-cjk", r2 = "cj-letter", i2 = "cjk-punctuation", u2 = [], o2 = (t2.proseWrap === "preserve" ? e2 : e2.replace(new RegExp(`(${MO})
(${MO})`, "g"), "$1$2")).split(/([\t\n ]+)/);
    for (const [e3, t3] of o2.entries()) {
      if (e3 % 2 == 1) {
        u2.push({ type: "whitespace", value: /\n/.test(t3) ? "\n" : " " });
        continue;
      }
      if ((e3 === 0 || e3 === o2.length - 1) && t3 === "")
        continue;
      const a2 = t3.split(new RegExp(`(${MO})`));
      for (const [e4, t4] of a2.entries())
        (e4 !== 0 && e4 !== a2.length - 1 || t4 !== "") && (e4 % 2 != 0 ? s2(UO.test(t4) ? { type: "word", value: t4, kind: i2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: t4, kind: qO.test(t4) ? "k-letter" : r2, hasLeadingPunctuation: false, hasTrailingPunctuation: false }) : t4 !== "" && s2({ type: "word", value: t4, kind: n2, hasLeadingPunctuation: UO.test(t4[0]), hasTrailingPunctuation: UO.test(LO(t4)) }));
    }
    return u2;
    function s2(e3) {
      const t3 = LO(u2);
      var o3, s3;
      t3 && t3.type === "word" && (t3.kind === n2 && e3.kind === r2 && !t3.hasTrailingPunctuation || t3.kind === r2 && e3.kind === n2 && !e3.hasLeadingPunctuation ? u2.push({ type: "whitespace", value: " " }) : (o3 = n2, s3 = i2, t3.kind === o3 && e3.kind === s3 || t3.kind === s3 && e3.kind === o3 || [t3.value, e3.value].some((e4) => /\u3000/.test(e4)) || u2.push({ type: "whitespace", value: "" }))), u2.push(e3);
    }
  }, punctuationPattern: $O, getFencedCodeBlockValue: function(e2, t2) {
    const { value: n2 } = e2;
    return e2.position.end.offset === t2.length && n2.endsWith("\n") && t2.endsWith("\n") ? n2.slice(0, -1) : n2;
  }, getOrderedListItemInfo: zO, hasGitDiffFriendlyOrderedList: function(e2, t2) {
    if (!e2.ordered)
      return false;
    if (e2.children.length < 2)
      return false;
    const n2 = Number(zO(e2.children[0], t2.originalText).numberText), r2 = Number(zO(e2.children[1], t2.originalText).numberText);
    if (n2 === 0 && e2.children.length > 2) {
      const n3 = Number(zO(e2.children[2], t2.originalText).numberText);
      return r2 === 1 && n3 === 1;
    }
    return r2 === 1;
  }, INLINE_NODE_TYPES: VO, INLINE_NODE_WRAPPER_TYPES: WO, isAutolink: function(e2) {
    if (!e2 || e2.type !== "link" || e2.children.length !== 1)
      return false;
    const t2 = e2.children[0];
    return t2 && jO(e2) === jO(t2) && _O(e2) === _O(t2);
  } };
  const { inferParserByLanguage: HO, getMaxContinuousCount: JO } = yi$2, { builders: { hardline: XO, markAsRoot: YO }, utils: { replaceEndOfLine: KO } } = eu$1, { getFencedCodeBlockValue: QO } = GO;
  var ZO = function(e2, t2, n2, r2) {
    const i2 = e2.getValue();
    if (i2.type === "code" && i2.lang !== null) {
      const e3 = HO(i2.lang, r2);
      if (e3) {
        const t3 = r2.__inJsTemplate ? "~" : "`", u2 = t3.repeat(Math.max(3, JO(i2.value, t3) + 1)), o2 = n2(QO(i2, r2.originalText), { parser: e3 }, { stripTrailingHardline: true });
        return YO([u2, i2.lang, i2.meta ? " " + i2.meta : "", XO, KO(o2), XO, u2]);
      }
    }
    switch (i2.type) {
      case "front-matter":
        return rN(i2, n2);
      case "importExport":
        return [n2(i2.value, { parser: "babel" }, { stripTrailingHardline: true }), XO];
      case "jsx":
        return n2(`<$>${i2.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
    }
    return null;
  };
  const eI = ["format", "prettier"];
  function tI(e2) {
    const t2 = `@(${eI.join("|")})`, n2 = new RegExp([`<!--\\s*${t2}\\s*-->`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${t2}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), r2 = e2.match(n2);
    return r2 && r2.index === 0;
  }
  var nI = { startWithPragma: tI, hasPragma: (e2) => tI(sN(e2).content.trimStart()), insertPragma: (e2) => {
    const t2 = sN(e2), n2 = `<!-- @${eI[0]} -->`;
    return t2.frontMatter ? `${t2.frontMatter.raw}

${n2}

${t2.content}` : `${n2}

${t2.content}`;
  } };
  const { getOrderedListItemInfo: rI, mapAst: iI, splitText: uI } = GO, oI = /^.$/us;
  function sI(e2, t2, n2) {
    return iI(e2, (e3) => {
      if (!e3.children)
        return e3;
      const r2 = e3.children.reduce((e4, r3) => {
        const i2 = Ln$2(e4);
        return i2 && t2(i2, r3) ? e4.splice(-1, 1, n2(i2, r3)) : e4.push(r3), e4;
      }, []);
      return Object.assign(Object.assign({}, e3), {}, { children: r2 });
    });
  }
  var aI = function(e2, t2) {
    return e2 = function(e3) {
      return sI(e3, (e4, t3) => e4.type === "importExport" && t3.type === "importExport", (e4, t3) => ({ type: "importExport", value: e4.value + "\n\n" + t3.value, position: { start: e4.position.start, end: t3.position.end } }));
    }(e2 = function(e3) {
      return iI(e3, (e4) => e4.type !== "import" && e4.type !== "export" ? e4 : Object.assign(Object.assign({}, e4), {}, { type: "importExport" }));
    }(e2 = function(e3, t3) {
      return iI(e3, (e4, n2, [r2]) => {
        if (e4.type !== "text")
          return e4;
        let { value: i2 } = e4;
        return r2.type === "paragraph" && (n2 === 0 && (i2 = i2.trimStart()), n2 === r2.children.length - 1 && (i2 = i2.trimEnd())), { type: "sentence", position: e4.position, children: uI(i2, t3) };
      });
    }(e2 = function(e3, t3) {
      return iI(e3, (e4, t4, n3) => {
        if (e4.type === "list" && e4.children.length > 0) {
          for (let t5 = 0; t5 < n3.length; t5++) {
            const r3 = n3[t5];
            if (r3.type === "list" && !r3.isAligned)
              return e4.isAligned = false, e4;
          }
          e4.isAligned = r2(e4);
        }
        return e4;
      });
      function n2(e4) {
        return e4.children.length === 0 ? -1 : e4.children[0].position.start.column - 1;
      }
      function r2(e4) {
        if (!e4.ordered)
          return true;
        const [r3, i2] = e4.children;
        if (rI(r3, t3.originalText).leadingSpaces.length > 1)
          return true;
        const u2 = n2(r3);
        if (u2 === -1)
          return false;
        if (e4.children.length === 1)
          return u2 % t3.tabWidth == 0;
        if (u2 !== n2(i2))
          return false;
        if (u2 % t3.tabWidth == 0)
          return true;
        return rI(i2, t3.originalText).leadingSpaces.length > 1;
      }
    }(e2 = function(e3, t3) {
      return iI(e3, (e4, n2, r2) => {
        if (e4.type === "code") {
          const n3 = /^\n?(?: {4,}|\t)/.test(t3.originalText.slice(e4.position.start.offset, e4.position.end.offset));
          if (e4.isIndented = n3, n3)
            for (let e5 = 0; e5 < r2.length; e5++) {
              const t4 = r2[e5];
              if (t4.hasIndentedCodeblock)
                break;
              t4.type === "list" && (t4.hasIndentedCodeblock = true);
            }
        }
        return e4;
      });
    }(e2 = function(e3) {
      return iI(e3, (e4) => e4.type !== "inlineCode" ? e4 : Object.assign(Object.assign({}, e4), {}, { value: e4.value.replace(/\s+/g, " ") }));
    }(e2 = function(e3) {
      return sI(e3, (e4, t3) => e4.type === "text" && t3.type === "text", (e4, t3) => ({ type: "text", value: e4.value + t3.value, position: { start: e4.position.start, end: t3.position.end } }));
    }(e2 = function(e3, t3) {
      return iI(e3, (e4) => e4.type === "text" && e4.value !== "*" && e4.value !== "_" && oI.test(e4.value) && e4.position.end.offset - e4.position.start.offset !== e4.value.length ? Object.assign(Object.assign({}, e4), {}, { value: t3.originalText.slice(e4.position.start.offset, e4.position.end.offset) }) : e4);
    }(e2, t2))), t2), t2), t2)));
  };
  const { isFrontMatterNode: cI } = yi$2, { startWithPragma: lI } = nI, pI = new Set(["position", "raw"]);
  function fI(e2, t2, n2) {
    return e2.type !== "front-matter" && e2.type !== "code" && e2.type !== "yaml" && e2.type !== "import" && e2.type !== "export" && e2.type !== "jsx" || delete t2.value, e2.type === "list" && delete t2.isAligned, e2.type !== "list" && e2.type !== "listItem" || (delete t2.spread, delete t2.loose), e2.type === "text" ? null : (e2.type === "inlineCode" && (t2.value = e2.value.replace(/[\t\n ]+/g, " ")), e2.type === "wikiLink" && (t2.value = e2.value.trim().replace(/[\t\n]+/g, " ")), e2.type !== "definition" && e2.type !== "linkReference" || (t2.label = e2.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e2.type !== "definition" && e2.type !== "link" && e2.type !== "image" || !e2.title || (t2.title = e2.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e2 || cI(n2.children[0]) && n2.children[1] === e2) && e2.type === "html" && lI(e2.value) ? null : void 0);
  }
  fI.ignoredProperties = pI;
  var dI = fI;
  const { getLast: hI, getMinNotPresentContinuousCount: gI, getMaxContinuousCount: mI, getStringWidth: yI, isNonEmptyArray: DI } = yi$2, { builders: { breakParent: EI, join: CI, line: bI, literalline: AI, markAsRoot: vI, hardline: FI, softline: SI, ifBreak: xI, fill: wI, align: TI, indent: BI, group: NI, hardlineWithoutBreakParent: kI }, utils: { normalizeDoc: PI, replaceTextEndOfLine: OI }, printer: { printDocToString: II } } = eu$1, { insertPragma: LI } = nI, { locStart: jI, locEnd: _I } = IO, { getFencedCodeBlockValue: MI, hasGitDiffFriendlyOrderedList: RI, splitText: $I, punctuationPattern: VI, INLINE_NODE_TYPES: WI, INLINE_NODE_WRAPPER_TYPES: qI, isAutolink: UI } = GO, zI = new Set(["importExport"]), GI = ["heading", "tableCell", "link", "wikiLink"], HI = new Set(["listItem", "definition", "footnoteDefinition"]);
  function JI(e2, t2, n2, r2) {
    const i2 = e2.getValue(), u2 = i2.checked === null ? "" : i2.checked ? "[x] " : "[ ] ";
    return [u2, eL(e2, t2, n2, { processor: (e3, i3) => {
      if (i3 === 0 && e3.getValue().type !== "list")
        return TI(" ".repeat(u2.length), n2());
      const o2 = " ".repeat(function(e4, t3, n3) {
        return e4 < t3 ? t3 : e4 > n3 ? n3 : e4;
      }(t2.tabWidth - r2.length, 0, 3));
      return [o2, TI(o2, n2())];
    } })];
  }
  function XI(e2, t2) {
    return function(e3, t3, n2) {
      let r2 = -1;
      for (const i2 of t3.children)
        if (i2.type === e3.type && n2(i2) ? r2++ : r2 = -1, i2 === e3)
          return r2;
    }(e2, t2, (t3) => t3.ordered === e2.ordered);
  }
  function YI(e2, t2) {
    const n2 = Array.isArray(t2) ? t2 : [t2];
    let r2, i2 = -1;
    for (; r2 = e2.getParentNode(++i2); )
      if (n2.includes(r2.type))
        return i2;
    return -1;
  }
  function KI(e2, t2) {
    const n2 = YI(e2, t2);
    return n2 === -1 ? null : e2.getParentNode(n2);
  }
  function QI(e2, t2, n2) {
    if (n2.proseWrap === "preserve" && t2 === "\n")
      return FI;
    const r2 = n2.proseWrap === "always" && !KI(e2, GI);
    return t2 !== "" ? r2 ? bI : " " : r2 ? SI : "";
  }
  function ZI(e2, t2, n2) {
    const r2 = [];
    let i2 = null;
    const { children: u2 } = e2.getValue();
    for (const [e3, t3] of u2.entries())
      switch (nL(t3)) {
        case "start":
          i2 === null && (i2 = { index: e3, offset: t3.position.end.offset });
          break;
        case "end":
          i2 !== null && (r2.push({ start: i2, end: { index: e3, offset: t3.position.start.offset } }), i2 = null);
      }
    return eL(e2, t2, n2, { processor: (e3, i3) => {
      if (r2.length > 0) {
        const e4 = r2[0];
        if (i3 === e4.start.index)
          return [u2[e4.start.index].value, t2.originalText.slice(e4.start.offset, e4.end.offset), u2[e4.end.index].value];
        if (e4.start.index < i3 && i3 < e4.end.index)
          return false;
        if (i3 === e4.end.index)
          return r2.shift(), false;
      }
      return n2();
    } });
  }
  function eL(e2, t2, n2, r2 = {}) {
    const { postprocessor: i2 } = r2, u2 = r2.processor || (() => n2()), o2 = e2.getValue(), s2 = [];
    let a2;
    return e2.each((e3, n3) => {
      const r3 = e3.getValue(), i3 = u2(e3, n3);
      if (i3 !== false) {
        const e4 = { parts: s2, prevNode: a2, parentNode: o2, options: t2 };
        (function(e5, t3) {
          const n4 = t3.parts.length === 0, r4 = WI.includes(e5.type), i4 = e5.type === "html" && qI.includes(t3.parentNode.type);
          return !n4 && !r4 && !i4;
        })(r3, e4) && (s2.push(FI), a2 && zI.has(a2.type) || (function(e5, t3) {
          const n4 = (t3.prevNode && t3.prevNode.type) === e5.type && HI.has(e5.type), r4 = t3.parentNode.type === "listItem" && !t3.parentNode.loose, i4 = t3.prevNode && t3.prevNode.type === "listItem" && t3.prevNode.loose, u3 = nL(t3.prevNode) === "next", o3 = e5.type === "html" && t3.prevNode && t3.prevNode.type === "html" && t3.prevNode.position.end.line + 1 === e5.position.start.line, s3 = e5.type === "html" && t3.parentNode.type === "listItem" && t3.prevNode && t3.prevNode.type === "paragraph" && t3.prevNode.position.end.line + 1 === e5.position.start.line;
          return i4 || !(n4 || r4 || u3 || o3 || s3);
        }(r3, e4) || rL(r3, e4)) && s2.push(FI), rL(r3, e4) && s2.push(FI)), s2.push(i3), a2 = r3;
      }
    }, "children"), i2 ? i2(s2) : s2;
  }
  function tL(e2) {
    let t2 = e2;
    for (; DI(t2.children); )
      t2 = hI(t2.children);
    return t2;
  }
  function nL(e2) {
    if (e2.type !== "html")
      return false;
    const t2 = e2.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    return t2 !== null && (t2[1] ? t2[1] : "next");
  }
  function rL(e2, t2) {
    const n2 = t2.prevNode && t2.prevNode.type === "list", r2 = e2.type === "code" && e2.isIndented;
    return n2 && r2;
  }
  function iL(e2, t2 = []) {
    const n2 = [" ", ...Array.isArray(t2) ? t2 : [t2]];
    return new RegExp(n2.map((e3) => `\\${e3}`).join("|")).test(e2) ? `<${e2}>` : e2;
  }
  function uL(e2, t2, n2 = true) {
    if (!e2)
      return "";
    if (n2)
      return " " + uL(e2, t2, false);
    if ((e2 = e2.replace(/\\(["')])/g, "$1")).includes('"') && e2.includes("'") && !e2.includes(")"))
      return `(${e2})`;
    const r2 = e2.split("'").length - 1, i2 = e2.split('"').length - 1, u2 = r2 > i2 ? '"' : i2 > r2 || t2.singleQuote ? "'" : '"';
    return `${u2}${e2 = (e2 = e2.replace(/\\/, "\\\\")).replace(new RegExp(`(${u2})`, "g"), "\\$1")}${u2}`;
  }
  var oL = { preprocess: aI, print: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (function(e3) {
      const t3 = KI(e3, ["linkReference", "imageReference"]);
      return t3 && (t3.type !== "linkReference" || t3.referenceType !== "full");
    }(e2))
      return $I(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset), t2).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : QI(e2, n3.value, t2));
    switch (r2.type) {
      case "front-matter":
        return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
      case "root":
        return r2.children.length === 0 ? "" : [PI(ZI(e2, t2, n2)), zI.has(tL(r2).type) ? "" : FI];
      case "paragraph":
        return eL(e2, t2, n2, { postprocessor: wI });
      case "sentence":
        return eL(e2, t2, n2);
      case "word": {
        let t3 = r2.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${VI})(_+)`, `(_+)(${VI}|$)`].join("|"), "g"), (e3, t4, n4, r3, i3) => (n4 ? `${t4}${n4}` : `${r3}${i3}`).replace(/_/g, "\\_"));
        const n3 = (e3, t4, n4) => e3.type === "sentence" && n4 === 0, i2 = (e3, t4, n4) => UI(e3.children[n4 - 1]);
        return t3 !== r2.value && (e2.match(void 0, n3, i2) || e2.match(void 0, n3, (e3, t4, n4) => e3.type === "emphasis" && n4 === 0, i2)) && (t3 = t3.replace(/^(\\?[*_])+/, (e3) => e3.replace(/\\/g, ""))), t3;
      }
      case "whitespace": {
        const n3 = e2.getParentNode(), i2 = n3.children.indexOf(r2), u2 = n3.children[i2 + 1], o2 = u2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(u2.value) ? "never" : t2.proseWrap;
        return QI(e2, r2.value, { proseWrap: o2 });
      }
      case "emphasis": {
        let i2;
        if (UI(r2.children[0]))
          i2 = t2.originalText[r2.position.start.offset];
        else {
          const t3 = e2.getParentNode(), n3 = t3.children.indexOf(r2), u2 = t3.children[n3 - 1], o2 = t3.children[n3 + 1];
          i2 = u2 && u2.type === "sentence" && u2.children.length > 0 && hI(u2.children).type === "word" && !hI(u2.children).hasTrailingPunctuation || o2 && o2.type === "sentence" && o2.children.length > 0 && o2.children[0].type === "word" && !o2.children[0].hasLeadingPunctuation || KI(e2, "emphasis") ? "*" : "_";
        }
        return [i2, eL(e2, t2, n2), i2];
      }
      case "strong":
        return ["**", eL(e2, t2, n2), "**"];
      case "delete":
        return ["~~", eL(e2, t2, n2), "~~"];
      case "inlineCode": {
        const e3 = gI(r2.value, "`"), t3 = "`".repeat(e3 || 1), n3 = e3 && !/^\s/.test(r2.value) ? " " : "";
        return [t3, n3, r2.value, n3, t3];
      }
      case "wikiLink": {
        let e3 = "";
        return e3 = t2.proseWrap === "preserve" ? r2.value : r2.value.replace(/[\t\n]+/g, " "), ["[[", e3, "]]"];
      }
      case "link":
        switch (t2.originalText[r2.position.start.offset]) {
          case "<": {
            const e3 = "mailto:";
            return ["<", r2.url.startsWith(e3) && t2.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e3.length) !== e3 ? r2.url.slice(e3.length) : r2.url, ">"];
          }
          case "[":
            return ["[", eL(e2, t2, n2), "](", iL(r2.url, ")"), uL(r2.title, t2), ")"];
          default:
            return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
        }
      case "image":
        return ["![", r2.alt || "", "](", iL(r2.url, ")"), uL(r2.title, t2), ")"];
      case "blockquote":
        return ["> ", TI("> ", eL(e2, t2, n2))];
      case "heading":
        return ["#".repeat(r2.depth) + " ", eL(e2, t2, n2)];
      case "code": {
        if (r2.isIndented) {
          const e4 = " ".repeat(4);
          return TI(e4, [e4, ...OI(r2.value, FI)]);
        }
        const e3 = t2.__inJsTemplate ? "~" : "`", n3 = e3.repeat(Math.max(3, mI(r2.value, e3) + 1));
        return [n3, r2.lang || "", r2.meta ? " " + r2.meta : "", FI, ...OI(MI(r2, t2.originalText), FI), FI, n3];
      }
      case "html": {
        const t3 = e2.getParentNode(), n3 = t3.type === "root" && hI(t3.children) === r2 ? r2.value.trimEnd() : r2.value, i2 = /^<!--.*-->$/s.test(n3);
        return OI(n3, i2 ? FI : vI(AI));
      }
      case "list": {
        const i2 = XI(r2, e2.getParentNode()), u2 = RI(r2, t2);
        return eL(e2, t2, n2, { processor: (e3, o2) => {
          const s2 = function() {
            const e4 = r2.ordered ? (o2 === 0 ? r2.start : u2 ? 1 : r2.start + o2) + (i2 % 2 == 0 ? ". " : ") ") : i2 % 2 == 0 ? "- " : "* ";
            return r2.isAligned || r2.hasIndentedCodeblock ? function(e5, t3) {
              const n3 = r3();
              return e5 + " ".repeat(n3 >= 4 ? 0 : n3);
              function r3() {
                const n4 = e5.length % t3.tabWidth;
                return n4 === 0 ? 0 : t3.tabWidth - n4;
              }
            }(e4, t2) : e4;
          }(), a2 = e3.getValue();
          return a2.children.length === 2 && a2.children[1].type === "html" && a2.children[0].position.start.column !== a2.children[1].position.start.column ? [s2, JI(e3, t2, n2, s2)] : [s2, TI(" ".repeat(s2.length), JI(e3, t2, n2, s2))];
        } });
      }
      case "thematicBreak": {
        const t3 = YI(e2, "list");
        if (t3 === -1)
          return "---";
        return XI(e2.getParentNode(t3), e2.getParentNode(t3 + 1)) % 2 == 0 ? "***" : "---";
      }
      case "linkReference":
        return ["[", eL(e2, t2, n2), "]", r2.referenceType === "full" ? ["[", r2.identifier, "]"] : r2.referenceType === "collapsed" ? "[]" : ""];
      case "imageReference":
        switch (r2.referenceType) {
          case "full":
            return ["![", r2.alt || "", "][", r2.identifier, "]"];
          default:
            return ["![", r2.alt, "]", r2.referenceType === "collapsed" ? "[]" : ""];
        }
      case "definition": {
        const e3 = t2.proseWrap === "always" ? bI : " ";
        return NI(["[", r2.identifier, "]:", BI([e3, iL(r2.url), r2.title === null ? "" : [e3, uL(r2.title, t2, false)]])]);
      }
      case "footnote":
        return ["[^", eL(e2, t2, n2), "]"];
      case "footnoteReference":
        return ["[^", r2.identifier, "]"];
      case "footnoteDefinition": {
        const i2 = e2.getParentNode().children[e2.getName() + 1], u2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t2.proseWrap === "never" || t2.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
        return ["[^", r2.identifier, "]: ", u2 ? eL(e2, t2, n2) : NI([TI(" ".repeat(4), eL(e2, t2, n2, { processor: (e3, t3) => t3 === 0 ? NI([SI, n2()]) : n2() })), i2 && i2.type === "footnoteDefinition" ? SI : ""])];
      }
      case "table":
        return function(e3, t3, n3) {
          const r3 = e3.getValue(), i2 = [], u2 = e3.map((e4) => e4.map((e5, r4) => {
            const u3 = II(n3(), t3).formatted, o3 = yI(u3);
            return i2[r4] = Math.max(i2[r4] || 3, o3), { text: u3, width: o3 };
          }, "children"), "children"), o2 = a2(false);
          if (t3.proseWrap !== "never")
            return [EI, o2];
          const s2 = a2(true);
          return [EI, NI(xI(s2, o2))];
          function a2(e4) {
            const t4 = [l2(u2[0], e4), c2(e4)];
            return u2.length > 1 && t4.push(CI(kI, u2.slice(1).map((t5) => l2(t5, e4)))), CI(kI, t4);
          }
          function c2(e4) {
            return `| ${i2.map((t4, n4) => {
              const i3 = r3.align[n4], u3 = i3 === "center" || i3 === "right" ? ":" : "-";
              return `${i3 === "center" || i3 === "left" ? ":" : "-"}${e4 ? "-" : "-".repeat(t4 - 2)}${u3}`;
            }).join(" | ")} |`;
          }
          function l2(e4, t4) {
            return `| ${e4.map(({ text: e5, width: n4 }, u3) => {
              if (t4)
                return e5;
              const o3 = i2[u3] - n4, s3 = r3.align[u3];
              let a3 = 0;
              s3 === "right" ? a3 = o3 : s3 === "center" && (a3 = Math.floor(o3 / 2));
              const c3 = o3 - a3;
              return `${" ".repeat(a3)}${e5}${" ".repeat(c3)}`;
            }).join(" | ")} |`;
          }
        }(e2, t2, n2);
      case "tableCell":
        return eL(e2, t2, n2);
      case "break":
        return /\s/.test(t2.originalText[r2.position.start.offset]) ? ["  ", vI(AI)] : ["\\", FI];
      case "liquidNode":
        return OI(r2.value, FI);
      case "importExport":
        return [r2.value, FI];
      case "jsx":
        return r2.value;
      case "math":
        return ["$$", FI, r2.value ? [...OI(r2.value, FI), FI] : "", "$$"];
      case "inlineMath":
        return t2.originalText.slice(jI(r2), _I(r2));
      case "tableRow":
      case "listItem":
      default:
        throw new Error(`Unknown markdown type ${JSON.stringify(r2.type)}`);
    }
  }, embed: ZO, massageAstNode: dI, hasPrettierIgnore: function(e2) {
    const t2 = Number(e2.getName());
    return t2 !== 0 && nL(e2.getParentNode().children[t2 - 1]) === "next";
  }, insertPragma: LI }, sL = { proseWrap: WB.proseWrap, singleQuote: WB.singleQuote }, aL = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
  var cL = { languages: [Xd(aL, (e2) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e2.filenames, "README"], extensions: e2.extensions.filter((e3) => e3 !== ".mdx") })), Xd(aL, () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], options: sL, printers: { mdast: oL }, parsers: void 0 };
  const { isFrontMatterNode: lL } = yi$2, pL = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
  function fL(e2, t2) {
    return e2.type === "text" || e2.type === "comment" || lL(e2) || e2.type === "yaml" || e2.type === "toml" ? null : (e2.type === "attribute" && delete t2.value, void (e2.type === "docType" && delete t2.value));
  }
  fL.ignoredProperties = pL;
  var dL = fL, hL = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] };
  const { inferParserByLanguage: gL, isFrontMatterNode: mL } = yi$2, { builders: { line: yL, hardline: DL, join: EL }, utils: { getDocParts: CL, replaceTextEndOfLine: bL } } = eu$1, { CSS_DISPLAY_TAGS: AL, CSS_DISPLAY_DEFAULT: vL, CSS_WHITE_SPACE_TAGS: FL, CSS_WHITE_SPACE_DEFAULT: SL } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, xL = PL(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), wL = function(e2, t2) {
    const n2 = Object.create(null);
    for (const [r2, i2] of Object.entries(e2))
      n2[r2] = t2(i2, r2);
    return n2;
  }(hL, PL), TL = new Set(["	", "\n", "\f", "\r", " "]), BL = (e2) => e2.replace(/[\t\n\f\r ]+$/, ""), NL = (e2) => ((e3) => e3.replace(/^[\t\f\r ]*?\n/g, ""))(BL(e2)), kL = (e2) => e2.match(/^[\t\n\f\r ]*/)[0];
  function PL(e2) {
    const t2 = Object.create(null);
    for (const n2 of e2)
      t2[n2] = true;
    return t2;
  }
  function OL(e2) {
    return e2.type === "element" && (e2.fullName === "script" || e2.fullName === "style" || e2.fullName === "svg:style" || UL(e2) && (e2.name === "script" || e2.name === "style"));
  }
  function IL(e2) {
    return zL(e2).startsWith("pre");
  }
  function LL(e2) {
    return e2.type === "element" && e2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e2.name) || e2.cssDisplay.startsWith("table") && e2.cssDisplay !== "table-cell");
  }
  function jL(e2) {
    return $L(e2) || e2.type === "element" && e2.fullName === "br" || _L(e2);
  }
  function _L(e2) {
    return ML(e2) && RL(e2);
  }
  function ML(e2) {
    return e2.hasLeadingSpaces && (e2.prev ? e2.prev.sourceSpan.end.line < e2.sourceSpan.start.line : e2.parent.type === "root" || e2.parent.startSourceSpan.end.line < e2.sourceSpan.start.line);
  }
  function RL(e2) {
    return e2.hasTrailingSpaces && (e2.next ? e2.next.sourceSpan.start.line > e2.sourceSpan.end.line : e2.parent.type === "root" || e2.parent.endSourceSpan && e2.parent.endSourceSpan.start.line > e2.sourceSpan.end.line);
  }
  function $L(e2) {
    switch (e2.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;
      case "element":
        return ["script", "select"].includes(e2.name);
    }
    return false;
  }
  function VL(e2) {
    const { type: t2, lang: n2 } = e2.attrMap;
    return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || n2 === "jsx" ? "babel" : t2 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
  }
  function WL(e2) {
    return e2 === "block" || e2 === "list-item" || e2.startsWith("table");
  }
  function qL(e2) {
    return zL(e2).startsWith("pre");
  }
  function UL(e2) {
    return e2.type === "element" && !e2.hasExplicitNamespace && !["html", "svg"].includes(e2.namespace);
  }
  function zL(e2) {
    return e2.type === "element" && (!e2.namespace || UL(e2)) && FL[e2.name] || SL;
  }
  function GL(e2, t2 = function(e3) {
    let t3 = Number.POSITIVE_INFINITY;
    for (const n2 of e3.split("\n")) {
      if (n2.length === 0)
        continue;
      if (!TL.has(n2[0]))
        return 0;
      const e4 = kL(n2).length;
      n2.length !== e4 && e4 < t3 && (t3 = e4);
    }
    return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
  }(e2)) {
    return t2 === 0 ? e2 : e2.split("\n").map((e3) => e3.slice(t2)).join("\n");
  }
  const HL = new Set(["template", "style", "script"]);
  function JL(e2, t2) {
    return XL(e2, t2) && !HL.has(e2.fullName);
  }
  function XL(e2, t2) {
    return t2.parser === "vue" && e2.type === "element" && e2.parent.type === "root" && e2.fullName.toLowerCase() !== "html";
  }
  function YL(e2, t2) {
    return XL(e2, t2) && (JL(e2, t2) || e2.attrMap.lang && e2.attrMap.lang !== "html");
  }
  var KL = { HTML_ELEMENT_ATTRIBUTES: wL, HTML_TAGS: xL, htmlTrim: (e2) => ((e3) => e3.replace(/^[\t\n\f\r ]+/, ""))(BL(e2)), htmlTrimPreserveIndentation: NL, hasHtmlWhitespace: (e2) => /[\t\n\f\r ]/.test(e2), getLeadingAndTrailingHtmlWhitespace: (e2) => {
    const [, t2, n2, r2] = e2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return { leadingWhitespace: t2, trailingWhitespace: r2, text: n2 };
  }, canHaveInterpolation: function(e2) {
    return e2.children && !OL(e2);
  }, countChars: function(e2, t2) {
    let n2 = 0;
    for (let r2 = 0; r2 < e2.length; r2++)
      e2[r2] === t2 && n2++;
    return n2;
  }, countParents: function(e2, t2) {
    let n2 = 0;
    for (let r2 = e2.stack.length - 1; r2 >= 0; r2--) {
      const i2 = e2.stack[r2];
      i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && n2++;
    }
    return n2;
  }, dedentString: GL, forceBreakChildren: LL, forceBreakContent: function(e2) {
    return LL(e2) || e2.type === "element" && e2.children.length > 0 && (["body", "script", "style"].includes(e2.name) || e2.children.some((e3) => function(e4) {
      return e4.children && e4.children.some((e5) => e5.type !== "text");
    }(e3))) || e2.firstChild && e2.firstChild === e2.lastChild && e2.firstChild.type !== "text" && ML(e2.firstChild) && (!e2.lastChild.isTrailingSpaceSensitive || RL(e2.lastChild));
  }, forceNextEmptyLine: function(e2) {
    return mL(e2) || e2.next && e2.sourceSpan.end && e2.sourceSpan.end.line + 1 < e2.next.sourceSpan.start.line;
  }, getLastDescendant: function e2(t2) {
    return t2.lastChild ? e2(t2.lastChild) : t2;
  }, getNodeCssStyleDisplay: function(e2, t2) {
    if (e2.prev && e2.prev.type === "comment") {
      const t3 = e2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (t3)
        return t3[1];
    }
    let n2 = false;
    if (e2.type === "element" && e2.namespace === "svg") {
      if (!function(e3, t3) {
        let n3 = e3;
        for (; n3; ) {
          if (t3(n3))
            return true;
          n3 = n3.parent;
        }
        return false;
      }(e2, (e3) => e3.fullName === "svg:foreignObject"))
        return e2.name === "svg" ? "inline-block" : "block";
      n2 = true;
    }
    switch (t2.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return t2.parser === "vue" && e2.parent && e2.parent.type === "root" ? "block" : e2.type === "element" && (!e2.namespace || n2 || UL(e2)) && AL[e2.name] || vL;
    }
  }, getNodeCssStyleWhiteSpace: zL, hasPrettierIgnore: function(e2) {
    return e2.type !== "attribute" && (!!e2.parent && (typeof e2.index == "number" && e2.index !== 0 && function(e3) {
      return e3.type === "comment" && e3.value.trim() === "prettier-ignore";
    }(e2.parent.children[e2.index - 1])));
  }, inferScriptParser: function(e2, t2) {
    return e2.name !== "script" || e2.attrMap.src ? e2.name === "style" ? function(e3) {
      const { lang: t3 } = e3.attrMap;
      return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
    }(e2) : t2 && YL(e2, t2) ? VL(e2) || !("src" in e2.attrMap) && gL(e2.attrMap.lang, t2) : void 0 : e2.attrMap.lang || e2.attrMap.type ? VL(e2) : "babel";
  }, isVueCustomBlock: JL, isVueNonHtmlBlock: YL, isVueSlotAttribute: function(e2) {
    const t2 = e2.fullName;
    return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
  }, isVueSfcBindingsAttribute: function(e2, t2) {
    const n2 = e2.parent;
    if (!XL(n2, t2))
      return false;
    const r2 = n2.fullName, i2 = e2.fullName;
    return r2 === "script" && i2 === "setup" || r2 === "style" && i2 === "vars";
  }, isDanglingSpaceSensitiveNode: function(e2) {
    return !(t2 = e2.cssDisplay, WL(t2) || t2 === "inline-block" || OL(e2));
    var t2;
  }, isIndentationSensitiveNode: IL, isLeadingSpaceSensitiveNode: function(e2, t2) {
    const n2 = function() {
      if (mL(e2))
        return false;
      if ((e2.type === "text" || e2.type === "interpolation") && e2.prev && (e2.prev.type === "text" || e2.prev.type === "interpolation"))
        return true;
      if (!e2.parent || e2.parent.cssDisplay === "none")
        return false;
      if (qL(e2.parent))
        return true;
      if (!e2.prev && (e2.parent.type === "root" || qL(e2) && e2.parent || OL(e2.parent) || JL(e2.parent, t2) || (n3 = e2.parent.cssDisplay, WL(n3) || n3 === "inline-block")))
        return false;
      var n3;
      if (e2.prev && !function(e3) {
        return !WL(e3);
      }(e2.prev.cssDisplay))
        return false;
      return true;
    }();
    return n2 && !e2.prev && e2.parent && e2.parent.tagDefinition && e2.parent.tagDefinition.ignoreFirstLf ? e2.type === "interpolation" : n2;
  }, isPreLikeNode: qL, isScriptLikeTag: OL, isTextLikeNode: function(e2) {
    return e2.type === "text" || e2.type === "comment";
  }, isTrailingSpaceSensitiveNode: function(e2, t2) {
    return !mL(e2) && (!(e2.type !== "text" && e2.type !== "interpolation" || !e2.next || e2.next.type !== "text" && e2.next.type !== "interpolation") || !(!e2.parent || e2.parent.cssDisplay === "none") && (!!qL(e2.parent) || !(!e2.next && (e2.parent.type === "root" || qL(e2) && e2.parent || OL(e2.parent) || JL(e2.parent, t2) || (n2 = e2.parent.cssDisplay, WL(n2) || n2 === "inline-block"))) && !(e2.next && !function(e3) {
      return !WL(e3);
    }(e2.next.cssDisplay))));
    var n2;
  }, isWhitespaceSensitiveNode: function(e2) {
    return OL(e2) || e2.type === "interpolation" || IL(e2);
  }, isUnknownNamespace: UL, preferHardlineAsLeadingSpaces: function(e2) {
    return $L(e2) || e2.prev && jL(e2.prev) || _L(e2);
  }, preferHardlineAsTrailingSpaces: jL, shouldPreserveContent: function(e2, t2) {
    return !(e2.type !== "ieConditionalComment" || !e2.lastChild || e2.lastChild.isSelfClosing || e2.lastChild.endSourceSpan) || (e2.type === "ieConditionalComment" && !e2.complete || (!(!qL(e2) || !e2.children.some((e3) => e3.type !== "text" && e3.type !== "interpolation")) || !(!YL(e2, t2) || OL(e2) || e2.type === "interpolation")));
  }, unescapeQuoteEntities: function(e2) {
    return e2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }, getTextValueParts: function(e2, t2 = e2.value) {
    return e2.parent.isWhitespaceSensitive ? e2.parent.isIndentationSensitive ? bL(t2) : bL(GL(NL(t2)), DL) : CL(EL(yL, ((e3) => e3.split(/[\t\n\f\r ]+/))(t2)));
  } }, QL = r$3(function(e2, t2) {
    function n2(e3) {
      return t2.$0 <= e3 && e3 <= t2.$9;
    }
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", { value: true }), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e3) {
      return e3 >= t2.$TAB && e3 <= t2.$SPACE || e3 == t2.$NBSP;
    }, t2.isDigit = n2, t2.isAsciiLetter = function(e3) {
      return e3 >= t2.$a && e3 <= t2.$z || e3 >= t2.$A && e3 <= t2.$Z;
    }, t2.isAsciiHexDigit = function(e3) {
      return e3 >= t2.$a && e3 <= t2.$f || e3 >= t2.$A && e3 <= t2.$F || n2(e3);
    }, t2.isNewLine = function(e3) {
      return e3 === t2.$LF || e3 === t2.$CR;
    }, t2.isOctalDigit = function(e3) {
      return t2.$0 <= e3 && e3 <= t2.$7;
    };
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class ZL {
    constructor(e2, t2, n2) {
      this.filePath = e2, this.name = t2, this.members = n2;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
    }
  }
  var ej = ZL;
  var tj = class {
    constructor() {
      this.cache = new Map();
    }
    get(e2, t2, n2) {
      const r2 = `"${e2}".${t2}${(n2 = n2 || []).length ? `.${n2.join(".")}` : ""}`;
      let i2 = this.cache.get(r2);
      return i2 || (i2 = new ZL(e2, t2, n2), this.cache.set(r2, i2)), i2;
    }
  }, nj = Object.defineProperty({ StaticSymbol: ej, StaticSymbolCache: tj }, "__esModule", { value: true });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const rj = /-+([a-z0-9])/g;
  var ij = function(e2) {
    return e2.replace(rj, (...e3) => e3[1].toUpperCase());
  };
  var uj = function(e2, t2) {
    return sj(e2, ":", t2);
  };
  var oj = function(e2, t2) {
    return sj(e2, ".", t2);
  };
  function sj(e2, t2, n2) {
    const r2 = e2.indexOf(t2);
    return r2 == -1 ? n2 : [e2.slice(0, r2).trim(), e2.slice(r2 + 1).trim()];
  }
  function aj(e2, t2, n2) {
    return Array.isArray(e2) ? t2.visitArray(e2, n2) : function(e3) {
      return typeof e3 == "object" && e3 !== null && Object.getPrototypeOf(e3) === bj;
    }(e2) ? t2.visitStringMap(e2, n2) : e2 == null || typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean" ? t2.visitPrimitive(e2, n2) : t2.visitOther(e2, n2);
  }
  var cj = aj;
  var lj = function(e2) {
    return e2 != null;
  };
  var pj = function(e2) {
    return e2 === void 0 ? null : e2;
  };
  var fj = class {
    visitArray(e2, t2) {
      return e2.map((e3) => aj(e3, this, t2));
    }
    visitStringMap(e2, t2) {
      const n2 = {};
      return Object.keys(e2).forEach((r2) => {
        n2[r2] = aj(e2[r2], this, t2);
      }), n2;
    }
    visitPrimitive(e2, t2) {
      return e2;
    }
    visitOther(e2, t2) {
      return e2;
    }
  }, dj = { assertSync: (e2) => {
    if (Sj(e2))
      throw new Error("Illegal state: value cannot be a promise");
    return e2;
  }, then: (e2, t2) => Sj(e2) ? e2.then(t2) : t2(e2), all: (e2) => e2.some(Sj) ? Promise.all(e2) : e2 };
  var hj = function(e2) {
    throw new Error(`Internal Error: ${e2}`);
  };
  var gj = function(e2, t2) {
    const n2 = Error(e2);
    return n2[mj] = true, t2 && (n2[yj] = t2), n2;
  };
  const mj = "ngSyntaxError", yj = "ngParseErrors";
  var Dj = function(e2) {
    return e2[mj];
  };
  var Ej = function(e2) {
    return e2[yj] || [];
  };
  var Cj = function(e2) {
    return e2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  };
  const bj = Object.getPrototypeOf({});
  var Aj = function(e2) {
    let t2 = "";
    for (let n2 = 0; n2 < e2.length; n2++) {
      let r2 = e2.charCodeAt(n2);
      if (r2 >= 55296 && r2 <= 56319 && e2.length > n2 + 1) {
        const t3 = e2.charCodeAt(n2 + 1);
        t3 >= 56320 && t3 <= 57343 && (n2++, r2 = (r2 - 55296 << 10) + t3 - 56320 + 65536);
      }
      r2 <= 127 ? t2 += String.fromCharCode(r2) : r2 <= 2047 ? t2 += String.fromCharCode(r2 >> 6 & 31 | 192, 63 & r2 | 128) : r2 <= 65535 ? t2 += String.fromCharCode(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128) : r2 <= 2097151 && (t2 += String.fromCharCode(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128));
    }
    return t2;
  };
  var vj = function e2(t2) {
    if (typeof t2 == "string")
      return t2;
    if (t2 instanceof Array)
      return "[" + t2.map(e2).join(", ") + "]";
    if (t2 == null)
      return "" + t2;
    if (t2.overriddenName)
      return `${t2.overriddenName}`;
    if (t2.name)
      return `${t2.name}`;
    if (!t2.toString)
      return "object";
    const n2 = t2.toString();
    if (n2 == null)
      return "" + n2;
    const r2 = n2.indexOf("\n");
    return r2 === -1 ? n2 : n2.substring(0, r2);
  };
  var Fj = function(e2) {
    return typeof e2 == "function" && e2.hasOwnProperty("__forward_ref__") ? e2() : e2;
  };
  function Sj(e2) {
    return !!e2 && typeof e2.then == "function";
  }
  var xj = Sj;
  var wj = class {
    constructor(e2) {
      this.full = e2;
      const t2 = e2.split(".");
      this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
    }
  };
  const Tj = typeof window != "undefined" && window, Bj = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
  var Nj = t$3 !== void 0 && t$3 || Tj || Bj, kj = Object.defineProperty({ dashCaseToCamelCase: ij, splitAtColon: uj, splitAtPeriod: oj, visitValue: cj, isDefined: lj, noUndefined: pj, ValueTransformer: fj, SyncAsync: dj, error: hj, syntaxError: gj, isSyntaxError: Dj, getParseErrors: Ej, escapeRegExp: Cj, utf8Encode: Aj, stringify: vj, resolveForwardRef: Fj, isPromise: xj, Version: wj, global: Nj }, "__esModule", { value: true }), Pj = r$3(function(e2, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", { value: true });
    const n2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function r2(e3) {
      return e3.replace(/\W/g, "_");
    }
    t2.sanitizeIdentifier = r2;
    let i2 = 0;
    function u2(e3) {
      if (!e3 || !e3.reference)
        return null;
      const t3 = e3.reference;
      if (t3 instanceof nj.StaticSymbol)
        return t3.name;
      if (t3.__anonymousType)
        return t3.__anonymousType;
      let n3 = kj.stringify(t3);
      return n3.indexOf("(") >= 0 ? (n3 = "anonymous_" + i2++, t3.__anonymousType = n3) : n3 = r2(n3), n3;
    }
    var o2;
    t2.identifierName = u2, t2.identifierModuleUrl = function(e3) {
      const t3 = e3.reference;
      return t3 instanceof nj.StaticSymbol ? t3.filePath : `./${kj.stringify(t3)}`;
    }, t2.viewClassName = function(e3, t3) {
      return `View_${u2({ reference: e3 })}_${t3}`;
    }, t2.rendererTypeName = function(e3) {
      return `RenderType_${u2({ reference: e3 })}`;
    }, t2.hostViewClassName = function(e3) {
      return `HostView_${u2({ reference: e3 })}`;
    }, t2.componentFactoryName = function(e3) {
      return `${u2({ reference: e3 })}NgFactory`;
    }, function(e3) {
      e3[e3.Pipe = 0] = "Pipe", e3[e3.Directive = 1] = "Directive", e3[e3.NgModule = 2] = "NgModule", e3[e3.Injectable = 3] = "Injectable";
    }(o2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e3) {
      return e3.value != null ? r2(e3.value) : u2(e3.identifier);
    }, t2.tokenReference = function(e3) {
      return e3.identifier != null ? e3.identifier.reference : e3.value;
    };
    t2.CompileStylesheetMetadata = class {
      constructor({ moduleUrl: e3, styles: t3, styleUrls: n3 } = {}) {
        this.moduleUrl = e3 || null, this.styles = a2(t3), this.styleUrls = a2(n3);
      }
    };
    t2.CompileTemplateMetadata = class {
      constructor({ encapsulation: e3, template: t3, templateUrl: n3, htmlAst: r3, styles: i3, styleUrls: u3, externalStylesheets: o3, animations: s3, ngContentSelectors: l3, interpolation: p2, isInline: f2, preserveWhitespaces: d2 }) {
        if (this.encapsulation = e3, this.template = t3, this.templateUrl = n3, this.htmlAst = r3, this.styles = a2(i3), this.styleUrls = a2(u3), this.externalStylesheets = a2(o3), this.animations = s3 ? c2(s3) : [], this.ngContentSelectors = l3 || [], p2 && p2.length != 2)
          throw new Error("'interpolation' should have a start and an end symbol.");
        this.interpolation = p2, this.isInline = f2, this.preserveWhitespaces = d2;
      }
      toSummary() {
        return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
      }
    };
    class s2 {
      static create({ isHost: e3, type: t3, isComponent: r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: a3, outputs: c3, host: l3, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2 }) {
        const b2 = {}, A2 = {}, v2 = {};
        l3 != null && Object.keys(l3).forEach((e4) => {
          const t4 = l3[e4], r4 = e4.match(n2);
          r4 === null ? v2[e4] = t4 : r4[1] != null ? A2[r4[1]] = t4 : r4[2] != null && (b2[r4[2]] = t4);
        });
        const F2 = {};
        a3 != null && a3.forEach((e4) => {
          const t4 = kj.splitAtColon(e4, [e4, e4]);
          F2[t4[0]] = t4[1];
        });
        const S2 = {};
        return c3 != null && c3.forEach((e4) => {
          const t4 = kj.splitAtColon(e4, [e4, e4]);
          S2[t4[0]] = t4[1];
        }), new s2({ isHost: e3, type: t3, isComponent: !!r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: F2, outputs: S2, hostListeners: b2, hostProperties: A2, hostAttributes: v2, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2 });
      }
      constructor({ isHost: e3, type: t3, isComponent: n3, selector: r3, exportAs: i3, changeDetection: u3, inputs: o3, outputs: s3, hostListeners: c3, hostProperties: l3, hostAttributes: p2, providers: f2, viewProviders: d2, queries: h2, guards: g2, viewQueries: m2, entryComponents: y2, template: D2, componentViewType: E2, rendererType: C2, componentFactory: b2 }) {
        this.isHost = !!e3, this.type = t3, this.isComponent = n3, this.selector = r3, this.exportAs = i3, this.changeDetection = u3, this.inputs = o3, this.outputs = s3, this.hostListeners = c3, this.hostProperties = l3, this.hostAttributes = p2, this.providers = a2(f2), this.viewProviders = a2(d2), this.queries = a2(h2), this.guards = g2, this.viewQueries = a2(m2), this.entryComponents = a2(y2), this.template = D2, this.componentViewType = E2, this.rendererType = C2, this.componentFactory = b2;
      }
      toSummary() {
        return { summaryKind: o2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
      }
    }
    t2.CompileDirectiveMetadata = s2;
    t2.CompilePipeMetadata = class {
      constructor({ type: e3, name: t3, pure: n3 }) {
        this.type = e3, this.name = t3, this.pure = !!n3;
      }
      toSummary() {
        return { summaryKind: o2.Pipe, type: this.type, name: this.name, pure: this.pure };
      }
    };
    t2.CompileShallowModuleMetadata = class {
    };
    t2.CompileNgModuleMetadata = class {
      constructor({ type: e3, providers: t3, declaredDirectives: n3, exportedDirectives: r3, declaredPipes: i3, exportedPipes: u3, entryComponents: o3, bootstrapComponents: s3, importedModules: c3, exportedModules: l3, schemas: p2, transitiveModule: f2, id: d2 }) {
        this.type = e3 || null, this.declaredDirectives = a2(n3), this.exportedDirectives = a2(r3), this.declaredPipes = a2(i3), this.exportedPipes = a2(u3), this.providers = a2(t3), this.entryComponents = a2(o3), this.bootstrapComponents = a2(s3), this.importedModules = a2(c3), this.exportedModules = a2(l3), this.schemas = a2(p2), this.id = d2 || null, this.transitiveModule = f2 || null;
      }
      toSummary() {
        const e3 = this.transitiveModule;
        return { summaryKind: o2.NgModule, type: this.type, entryComponents: e3.entryComponents, providers: e3.providers, modules: e3.modules, exportedDirectives: e3.exportedDirectives, exportedPipes: e3.exportedPipes };
      }
    };
    function a2(e3) {
      return e3 || [];
    }
    t2.TransitiveCompileNgModuleMetadata = class {
      constructor() {
        this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
      }
      addProvider(e3, t3) {
        this.providers.push({ provider: e3, module: t3 });
      }
      addDirective(e3) {
        this.directivesSet.has(e3.reference) || (this.directivesSet.add(e3.reference), this.directives.push(e3));
      }
      addExportedDirective(e3) {
        this.exportedDirectivesSet.has(e3.reference) || (this.exportedDirectivesSet.add(e3.reference), this.exportedDirectives.push(e3));
      }
      addPipe(e3) {
        this.pipesSet.has(e3.reference) || (this.pipesSet.add(e3.reference), this.pipes.push(e3));
      }
      addExportedPipe(e3) {
        this.exportedPipesSet.has(e3.reference) || (this.exportedPipesSet.add(e3.reference), this.exportedPipes.push(e3));
      }
      addModule(e3) {
        this.modulesSet.has(e3.reference) || (this.modulesSet.add(e3.reference), this.modules.push(e3));
      }
      addEntryComponent(e3) {
        this.entryComponentsSet.has(e3.componentType) || (this.entryComponentsSet.add(e3.componentType), this.entryComponents.push(e3));
      }
    };
    function c2(e3) {
      return e3.reduce((e4, t3) => {
        const n3 = Array.isArray(t3) ? c2(t3) : t3;
        return e4.concat(n3);
      }, []);
    }
    function l2(e3) {
      return e3.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t2.ProviderMeta = class {
      constructor(e3, { useClass: t3, useValue: n3, useExisting: r3, useFactory: i3, deps: u3, multi: o3 }) {
        this.token = e3, this.useClass = t3 || null, this.useValue = n3, this.useExisting = r3, this.useFactory = i3 || null, this.dependencies = u3 || null, this.multi = !!o3;
      }
    }, t2.flatten = c2, t2.templateSourceUrl = function(e3, t3, n3) {
      let r3;
      return r3 = n3.isInline ? t3.type.reference instanceof nj.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${u2(e3)}/${u2(t3.type)}.html` : n3.templateUrl, t3.type.reference instanceof nj.StaticSymbol ? r3 : l2(r3);
    }, t2.sharedStylesheetJitUrl = function(e3, t3) {
      const n3 = e3.moduleUrl.split(/\/\\/g);
      return l2(`css/${t3}${n3[n3.length - 1]}.ngstyle.js`);
    }, t2.ngModuleJitUrl = function(e3) {
      return l2(`${u2(e3.type)}/module.ngfactory.js`);
    }, t2.templateJitUrl = function(e3, t3) {
      return l2(`${u2(e3)}/${u2(t3.type)}.ngfactory.js`);
    };
  }), Oj = r$3(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true });
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    class n2 {
      constructor(e3, t3, n3, r3) {
        this.file = e3, this.offset = t3, this.line = n3, this.col = r3;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(e3) {
        const t3 = this.file.content, r3 = t3.length;
        let i3 = this.offset, u3 = this.line, o2 = this.col;
        for (; i3 > 0 && e3 < 0; ) {
          i3--, e3++;
          if (t3.charCodeAt(i3) == QL.$LF) {
            u3--;
            const e4 = t3.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(QL.$LF));
            o2 = e4 > 0 ? i3 - e4 : i3;
          } else
            o2--;
        }
        for (; i3 < r3 && e3 > 0; ) {
          const n3 = t3.charCodeAt(i3);
          i3++, e3--, n3 == QL.$LF ? (u3++, o2 = 0) : o2++;
        }
        return new n2(this.file, i3, u3, o2);
      }
      getContext(e3, t3) {
        const n3 = this.file.content;
        let r3 = this.offset;
        if (r3 != null) {
          r3 > n3.length - 1 && (r3 = n3.length - 1);
          let i3 = r3, u3 = 0, o2 = 0;
          for (; u3 < e3 && r3 > 0 && (r3--, u3++, n3[r3] != "\n" || ++o2 != t3); )
            ;
          for (u3 = 0, o2 = 0; u3 < e3 && i3 < n3.length - 1 && (i3++, u3++, n3[i3] != "\n" || ++o2 != t3); )
            ;
          return { before: n3.substring(r3, this.offset), after: n3.substring(this.offset, i3 + 1) };
        }
        return null;
      }
    }
    t2.ParseLocation = n2;
    class r2 {
      constructor(e3, t3) {
        this.content = e3, this.url = t3;
      }
    }
    t2.ParseSourceFile = r2;
    class i2 {
      constructor(e3, t3, n3 = null) {
        this.start = e3, this.end = t3, this.details = n3;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    }
    var u2;
    t2.ParseSourceSpan = i2, t2.EMPTY_PARSE_LOCATION = new n2(new r2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new i2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e3) {
      e3[e3.WARNING = 0] = "WARNING", e3[e3.ERROR = 1] = "ERROR";
    }(u2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
    t2.ParseError = class {
      constructor(e3, t3, n3 = u2.ERROR) {
        this.span = e3, this.msg = t3, this.level = n3;
      }
      contextualMessage() {
        const e3 = this.span.start.getContext(100, 3);
        return e3 ? `${this.msg} ("${e3.before}[${u2[this.level]} ->]${e3.after}")` : this.msg;
      }
      toString() {
        const e3 = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${e3}`;
      }
    }, t2.typeSourceSpan = function(e3, t3) {
      const u3 = Pj.identifierModuleUrl(t3), o2 = u3 != null ? `in ${e3} ${Pj.identifierName(t3)} in ${u3}` : `in ${e3} ${Pj.identifierName(t3)}`, s2 = new r2("", o2);
      return new i2(new n2(s2, -1, -1, -1), new n2(s2, -1, -1, -1));
    }, t2.r3JitTypeSourceSpan = function(e3, t3, u3) {
      const o2 = new r2("", `in ${e3} ${t3} in ${u3}`);
      return new i2(new n2(o2, -1, -1, -1), new n2(o2, -1, -1, -1));
    };
  });
  const { ParseSourceSpan: Ij } = Oj, { htmlTrim: Lj, getLeadingAndTrailingHtmlWhitespace: jj, hasHtmlWhitespace: _j, canHaveInterpolation: Mj, getNodeCssStyleDisplay: Rj, isDanglingSpaceSensitiveNode: $j, isIndentationSensitiveNode: Vj, isLeadingSpaceSensitiveNode: Wj, isTrailingSpaceSensitiveNode: qj, isWhitespaceSensitiveNode: Uj } = KL, zj = [function(e2) {
    e2.walk((e3) => {
      if (e3.type === "element" && e3.tagDefinition.ignoreFirstLf && e3.children.length > 0 && e3.children[0].type === "text" && e3.children[0].value[0] === "\n") {
        const [t2, ...n2] = e3.children;
        e3.setChildren(t2.value.length === 1 ? n2 : [t2.clone({ value: t2.value.slice(1) }), ...n2]);
      }
    });
  }, function(e2) {
    const t2 = (e3) => e3.type === "element" && e3.prev && e3.prev.type === "ieConditionalStartComment" && e3.prev.sourceSpan.end.offset === e3.startSourceSpan.start.offset && e3.firstChild && e3.firstChild.type === "ieConditionalEndComment" && e3.firstChild.sourceSpan.start.offset === e3.startSourceSpan.end.offset;
    e2.walk((e3) => {
      if (e3.children) {
        const n2 = e3.children.map(t2);
        if (n2.some(Boolean)) {
          const t3 = [];
          for (let r2 = 0; r2 < e3.children.length; r2++) {
            const i2 = e3.children[r2];
            if (!n2[r2 + 1])
              if (n2[r2]) {
                const e4 = i2.prev, n3 = i2.firstChild, r3 = new Ij(e4.sourceSpan.start, n3.sourceSpan.end), u2 = new Ij(r3.start, i2.sourceSpan.end);
                t3.push(i2.clone({ condition: e4.condition, sourceSpan: u2, startSourceSpan: r3, children: i2.children.slice(1) }));
              } else
                t3.push(i2);
          }
          e3.setChildren(t3);
        }
      }
    });
  }, function(e2) {
    return function(e3, t2, n2) {
      e3.walk((e4) => {
        if (e4.children) {
          const r2 = e4.children.map(t2);
          if (r2.some(Boolean)) {
            const t3 = [];
            for (let i2 = 0; i2 < e4.children.length; i2++) {
              const u2 = e4.children[i2];
              if (u2.type !== "text" && !r2[i2]) {
                t3.push(u2);
                continue;
              }
              const o2 = u2.type === "text" ? u2 : u2.clone({ type: "text", value: n2(u2) });
              if (t3.length === 0 || Ln$2(t3).type !== "text") {
                t3.push(o2);
                continue;
              }
              const s2 = t3.pop();
              t3.push(s2.clone({ value: s2.value + o2.value, sourceSpan: new Ij(s2.sourceSpan.start, o2.sourceSpan.end) }));
            }
            e4.setChildren(t3);
          }
        }
      });
    }(e2, (e3) => e3.type === "cdata", (e3) => `<![CDATA[${e3.value}]]>`);
  }, function(e2, t2) {
    if (t2.parser === "html")
      return;
    const n2 = /{{(.+?)}}/s;
    e2.walk((e3) => {
      if (!Mj(e3))
        return;
      const t3 = [];
      for (const r2 of e3.children) {
        if (r2.type !== "text") {
          t3.push(r2);
          continue;
        }
        let e4 = r2.sourceSpan.start, i2 = null;
        const u2 = r2.value.split(n2);
        for (let n3 = 0; n3 < u2.length; n3++, e4 = i2) {
          const r3 = u2[n3];
          n3 % 2 != 0 ? (i2 = e4.moveBy(r3.length + 4), t3.push({ type: "interpolation", sourceSpan: new Ij(e4, i2), children: r3.length === 0 ? [] : [{ type: "text", value: r3, sourceSpan: new Ij(e4.moveBy(2), i2.moveBy(-2)) }] })) : (i2 = e4.moveBy(r3.length), r3.length > 0 && t3.push({ type: "text", value: r3, sourceSpan: new Ij(e4, i2) }));
        }
      }
      e3.setChildren(t3);
    });
  }, function(e2) {
    e2.walk((e3) => {
      if (!e3.children)
        return;
      if (e3.children.length === 0 || e3.children.length === 1 && e3.children[0].type === "text" && Lj(e3.children[0].value).length === 0)
        return e3.hasDanglingSpaces = e3.children.length > 0, void (e3.children = []);
      const t2 = Uj(e3), n2 = Vj(e3);
      e3.setChildren(e3.children.flatMap((e4) => {
        if (e4.type !== "text" || t2)
          return e4;
        const n3 = [], { leadingWhitespace: r2, text: i2, trailingWhitespace: u2 } = jj(e4.value);
        return r2 && n3.push(Gj), i2 && n3.push({ type: "text", value: i2, sourceSpan: new Ij(e4.sourceSpan.start.moveBy(r2.length), e4.sourceSpan.end.moveBy(-u2.length)) }), u2 && n3.push(Gj), n3;
      }).map((e4, t3, n3) => {
        if (e4 !== Gj)
          return Object.assign(Object.assign({}, e4), {}, { hasLeadingSpaces: n3[t3 - 1] === Gj, hasTrailingSpaces: n3[t3 + 1] === Gj });
      }).filter(Boolean)), e3.isWhitespaceSensitive = t2, e3.isIndentationSensitive = n2;
    });
  }, function(e2, t2) {
    e2.walk((e3) => Object.assign(e3, { cssDisplay: Rj(e3, t2) }));
  }, function(e2) {
    e2.walk((e3) => Object.assign(e3, { isSelfClosing: !e3.children || e3.type === "element" && (e3.tagDefinition.isVoid || e3.startSourceSpan === e3.endSourceSpan) }));
  }, function(e2, t2) {
    e2.walk((e3) => e3.type !== "element" ? e3 : Object.assign(e3, { hasHtmComponentClosingTag: e3.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t2.originalText.slice(e3.endSourceSpan.start.offset, e3.endSourceSpan.end.offset)) }));
  }, function(e2, t2) {
    e2.walk((e3) => {
      e3.children && (e3.children.length !== 0 ? e3.setChildren(e3.children.map((e4) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: Wj(e4, t2), isTrailingSpaceSensitive: qj(e4, t2) })).map((e4, t3, n2) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: (t3 === 0 || n2[t3 - 1].isTrailingSpaceSensitive) && e4.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t3 === n2.length - 1 || n2[t3 + 1].isLeadingSpaceSensitive) && e4.isTrailingSpaceSensitive }))) : e3.isDanglingSpaceSensitive = $j(e3));
    });
  }, function(e2) {
    const t2 = (e3) => e3.type === "element" && e3.attrs.length === 0 && e3.children.length === 1 && e3.firstChild.type === "text" && !_j(e3.children[0].value) && !e3.firstChild.hasLeadingSpaces && !e3.firstChild.hasTrailingSpaces && e3.isLeadingSpaceSensitive && !e3.hasLeadingSpaces && e3.isTrailingSpaceSensitive && !e3.hasTrailingSpaces && e3.prev && e3.prev.type === "text" && e3.next && e3.next.type === "text";
    e2.walk((e3) => {
      if (e3.children) {
        const n2 = e3.children.map(t2);
        if (n2.some(Boolean)) {
          const t3 = [];
          for (let r2 = 0; r2 < e3.children.length; r2++) {
            const i2 = e3.children[r2];
            if (n2[r2]) {
              const n3 = t3.pop(), u2 = e3.children[++r2], { isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2 } = u2;
              t3.push(n3.clone({ value: n3.value + `<${i2.rawName}>` + i2.firstChild.value + `</${i2.rawName}>` + u2.value, sourceSpan: new Ij(n3.sourceSpan.start, u2.sourceSpan.end), isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2 }));
            } else
              t3.push(i2);
          }
          e3.setChildren(t3);
        }
      }
    });
  }];
  const Gj = { type: "whitespace" };
  var Hj = function(e2, t2) {
    const n2 = e2.map((e3) => e3);
    for (const e3 of zj)
      e3(n2, t2);
    return n2;
  };
  var Jj = { hasPragma: function(e2) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e2);
  }, insertPragma: function(e2) {
    return "<!-- @format -->\n\n" + e2.replace(/^\s*\n/, "");
  } };
  var Xj = { locStart: function(e2) {
    return e2.sourceSpan.start.offset;
  }, locEnd: function(e2) {
    return e2.sourceSpan.end.offset;
  } };
  const { isNonEmptyArray: Yj } = yi$2, { builders: { indent: Kj, join: Qj, line: Zj, softline: e_ }, utils: { replaceTextEndOfLine: t_ } } = eu$1, { locStart: n_, locEnd: r_ } = Xj, { isTextLikeNode: i_, getLastDescendant: u_, isPreLikeNode: o_, hasPrettierIgnore: s_, shouldPreserveContent: a_ } = KL;
  function c_(e2, t2) {
    return e2.lastChild && D_(e2.lastChild) ? "" : [p_(e2, t2), d_(e2, t2)];
  }
  function l_(e2, t2) {
    return (e2.next ? m_(e2.next) : y_(e2.parent)) ? "" : [h_(e2, t2), f_(e2, t2)];
  }
  function p_(e2, t2) {
    return y_(e2) ? h_(e2.lastChild, t2) : "";
  }
  function f_(e2, t2) {
    return D_(e2) ? d_(e2.parent, t2) : E_(e2) ? S_(e2.next) : "";
  }
  function d_(e2, t2) {
    if (mf(!e2.isSelfClosing), g_(e2, t2))
      return "";
    switch (e2.type) {
      case "ieConditionalComment":
        return "<!";
      case "element":
        if (e2.hasHtmComponentClosingTag)
          return "<//";
      default:
        return `</${e2.rawName}`;
    }
  }
  function h_(e2, t2) {
    if (g_(e2, t2))
      return "";
    switch (e2.type) {
      case "ieConditionalComment":
      case "ieConditionalEndComment":
        return "[endif]-->";
      case "ieConditionalStartComment":
        return "]><!-->";
      case "interpolation":
        return "}}";
      case "element":
        if (e2.isSelfClosing)
          return "/>";
      default:
        return ">";
    }
  }
  function g_(e2, t2) {
    return !e2.isSelfClosing && !e2.endSourceSpan && (s_(e2) || a_(e2.parent, t2));
  }
  function m_(e2) {
    return e2.prev && e2.prev.type !== "docType" && !i_(e2.prev) && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
  }
  function y_(e2) {
    return e2.lastChild && e2.lastChild.isTrailingSpaceSensitive && !e2.lastChild.hasTrailingSpaces && !i_(u_(e2.lastChild)) && !o_(e2);
  }
  function D_(e2) {
    return !e2.next && !e2.hasTrailingSpaces && e2.isTrailingSpaceSensitive && i_(u_(e2));
  }
  function E_(e2) {
    return e2.next && !i_(e2.next) && i_(e2) && e2.isTrailingSpaceSensitive && !e2.hasTrailingSpaces;
  }
  function C_(e2) {
    return !e2.prev && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
  }
  function b_(e2, t2, n2) {
    const r2 = e2.getValue();
    if (!Yj(r2.attrs))
      return r2.isSelfClosing ? " " : "";
    const i2 = r2.prev && r2.prev.type === "comment" && function(e3) {
      const t3 = e3.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
      return !!t3 && (!t3[1] || t3[1].split(/\s+/));
    }(r2.prev.value), u2 = typeof i2 == "boolean" ? () => i2 : Array.isArray(i2) ? (e3) => i2.includes(e3.rawName) : () => false, o2 = e2.map((e3) => {
      const r3 = e3.getValue();
      return u2(r3) ? t_(t2.originalText.slice(n_(r3), r_(r3))) : n2();
    }, "attrs"), s2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, a2 = [Kj([s2 ? " " : Zj, Qj(Zj, o2)])];
    return r2.firstChild && C_(r2.firstChild) || r2.isSelfClosing && y_(r2.parent) || s2 ? a2.push(r2.isSelfClosing ? " " : "") : a2.push(t2.bracketSameLine ? r2.isSelfClosing ? " " : "" : r2.isSelfClosing ? Zj : e_), a2;
  }
  function A_(e2) {
    return e2.firstChild && C_(e2.firstChild) ? "" : x_(e2);
  }
  function v_(e2, t2) {
    return e2.prev && E_(e2.prev) ? "" : [F_(e2, t2), S_(e2)];
  }
  function F_(e2, t2) {
    return C_(e2) ? x_(e2.parent) : m_(e2) ? h_(e2.prev, t2) : "";
  }
  function S_(e2) {
    switch (e2.type) {
      case "ieConditionalComment":
      case "ieConditionalStartComment":
        return `<!--[if ${e2.condition}`;
      case "ieConditionalEndComment":
        return "<!--<!";
      case "interpolation":
        return "{{";
      case "docType":
        return "<!DOCTYPE";
      case "element":
        if (e2.condition)
          return `<!--[if ${e2.condition}]><!--><${e2.rawName}`;
      default:
        return `<${e2.rawName}`;
    }
  }
  function x_(e2) {
    switch (mf(!e2.isSelfClosing), e2.type) {
      case "ieConditionalComment":
        return "]>";
      case "element":
        if (e2.condition)
          return "><!--<![endif]-->";
      default:
        return ">";
    }
  }
  var w_ = { printClosingTag: function(e2, t2) {
    return [e2.isSelfClosing ? "" : c_(e2, t2), l_(e2, t2)];
  }, printClosingTagStart: c_, printClosingTagStartMarker: d_, printClosingTagEndMarker: h_, printClosingTagSuffix: f_, printClosingTagEnd: l_, needsToBorrowLastChildClosingTagEndMarker: y_, needsToBorrowParentClosingTagStartMarker: D_, needsToBorrowPrevClosingTagEndMarker: m_, printOpeningTag: function(e2, t2, n2) {
    const r2 = e2.getValue();
    return [v_(r2, t2), b_(e2, t2, n2), r2.isSelfClosing ? "" : A_(r2)];
  }, printOpeningTagStart: v_, printOpeningTagPrefix: F_, printOpeningTagStartMarker: S_, printOpeningTagEndMarker: x_, needsToBorrowNextOpeningTagStartMarker: E_, needsToBorrowParentOpeningTagEndMarker: C_ }, T_ = r$3(function(e2) {
    var n2, r2;
    n2 = t$3, r2 = function() {
      return function(e3, t2) {
        var n3 = t2 && t2.logger || console;
        function r3(e4) {
          return e4 === " " || e4 === "	" || e4 === "\n" || e4 === "\f" || e4 === "\r";
        }
        function i2(t3) {
          var n4, r4 = t3.exec(e3.substring(y2));
          if (r4)
            return n4 = r4[0], y2 += n4.length, n4;
        }
        for (var u2, o2, s2, a2, c2, l2 = e3.length, p2 = /^[ \t\n\r\u000c]+/, f2 = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g2 = /^\d+$/, m2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y2 = 0, D2 = []; ; ) {
          if (i2(f2), y2 >= l2)
            return D2;
          u2 = i2(d2), o2 = [], u2.slice(-1) === "," ? (u2 = u2.replace(h2, ""), C2()) : E2();
        }
        function E2() {
          for (i2(p2), s2 = "", a2 = "in descriptor"; ; ) {
            if (c2 = e3.charAt(y2), a2 === "in descriptor")
              if (r3(c2))
                s2 && (o2.push(s2), s2 = "", a2 = "after descriptor");
              else {
                if (c2 === ",")
                  return y2 += 1, s2 && o2.push(s2), void C2();
                if (c2 === "(")
                  s2 += c2, a2 = "in parens";
                else {
                  if (c2 === "")
                    return s2 && o2.push(s2), void C2();
                  s2 += c2;
                }
              }
            else if (a2 === "in parens")
              if (c2 === ")")
                s2 += c2, a2 = "in descriptor";
              else {
                if (c2 === "")
                  return o2.push(s2), void C2();
                s2 += c2;
              }
            else if (a2 === "after descriptor")
              if (r3(c2))
                ;
              else {
                if (c2 === "")
                  return void C2();
                a2 = "in descriptor", y2 -= 1;
              }
            y2 += 1;
          }
        }
        function C2() {
          var t3, r4, i3, s3, a3, c3, l3, p3, f3, d3 = false, h3 = {};
          for (s3 = 0; s3 < o2.length; s3++)
            c3 = (a3 = o2[s3])[a3.length - 1], l3 = a3.substring(0, a3.length - 1), p3 = parseInt(l3, 10), f3 = parseFloat(l3), g2.test(l3) && c3 === "w" ? ((t3 || r4) && (d3 = true), p3 === 0 ? d3 = true : t3 = p3) : m2.test(l3) && c3 === "x" ? ((t3 || r4 || i3) && (d3 = true), f3 < 0 ? d3 = true : r4 = f3) : g2.test(l3) && c3 === "h" ? ((i3 || r4) && (d3 = true), p3 === 0 ? d3 = true : i3 = p3) : d3 = true;
          d3 ? n3 && n3.error && n3.error("Invalid srcset descriptor found in '" + e3 + "' at '" + a3 + "'.") : (h3.url = u2, t3 && (h3.w = t3), r4 && (h3.d = r4), i3 && (h3.h = i3), D2.push(h3));
        }
      };
    }, e2.exports ? e2.exports = r2() : n2.parseSrcset = r2();
  });
  const { builders: { group: B_, ifBreak: N_, indent: k_, join: P_, line: O_, softline: I_ } } = eu$1;
  const L_ = [":", "__", "--", "_", "-"];
  function j_(e2) {
    const t2 = e2.search(/[^_-]/);
    if (t2 !== -1)
      for (const n2 of L_) {
        const r2 = e2.indexOf(n2, t2);
        if (r2 !== -1)
          return e2.slice(0, r2);
      }
    return e2;
  }
  var __ = { printImgSrcset: function(e2) {
    const t2 = T_(e2, { logger: { error(e3) {
      throw new Error(e3);
    } } }), n2 = t2.some(({ w: e3 }) => e3), r2 = t2.some(({ h: e3 }) => e3);
    if (n2 + r2 + t2.some(({ d: e3 }) => e3) > 1)
      throw new Error("Mixed descriptor in srcset is not supported");
    const i2 = n2 ? "w" : r2 ? "h" : "d", u2 = n2 ? "w" : r2 ? "h" : "x", o2 = (e3) => Math.max(...e3), s2 = t2.map((e3) => e3.url), a2 = o2(s2.map((e3) => e3.length)), c2 = t2.map((e3) => e3[i2]).map((e3) => e3 ? e3.toString() : ""), l2 = c2.map((e3) => {
      const t3 = e3.indexOf(".");
      return t3 === -1 ? e3.length : t3;
    }), p2 = o2(l2);
    return P_([",", O_], s2.map((e3, t3) => {
      const n3 = [e3], r3 = c2[t3];
      if (r3) {
        const i3 = a2 - e3.length + 1, o3 = p2 - l2[t3], s3 = " ".repeat(i3 + o3);
        n3.push(N_(s3, " "), r3 + u2);
      }
      return n3;
    }));
  }, printClassNames: function(e2) {
    const t2 = e2.trim().split(/\s+/), n2 = [];
    let r2;
    for (let e3 = 0; e3 < t2.length; e3++) {
      const i2 = j_(t2[e3]);
      i2 !== r2 && i2 !== t2[e3 - 1] && n2.push([]), Ln$2(n2).push(t2[e3]), r2 = i2;
    }
    return [k_([I_, P_(O_, n2.map((e3) => B_(P_(O_, e3))))]), I_];
  } };
  const { builders: { group: M_ } } = eu$1;
  var R_ = { isVueEventBindingExpression: function(e2) {
    const t2 = e2.trim();
    return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t2) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t2);
  }, printVueFor: function(e2, t2) {
    const { left: n2, operator: r2, right: i2 } = function(e3) {
      const t3 = /(.*?)\s+(in|of)\s+(.*)/s, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, i3 = e3.match(t3);
      if (!i3)
        return;
      const u2 = {};
      u2.for = i3[3].trim();
      const o2 = i3[1].trim().replace(r3, ""), s2 = o2.match(n3);
      s2 ? (u2.alias = o2.replace(n3, ""), u2.iterator1 = s2[1].trim(), s2[2] && (u2.iterator2 = s2[2].trim())) : u2.alias = o2;
      return { left: `${[u2.alias, u2.iterator1, u2.iterator2].filter(Boolean).join(",")}`, operator: i3[2], right: u2.for };
    }(e2);
    return [M_(t2(`function _(${n2}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", r2, " ", t2(i2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
  }, printVueBindings: function(e2, t2) {
    return t2(`function _(${e2}) {}`, { parser: "babel", __isVueBindings: true });
  } };
  const { needsToBorrowParentClosingTagStartMarker: $_, printClosingTagStartMarker: V_, needsToBorrowLastChildClosingTagEndMarker: W_, printClosingTagEndMarker: q_, needsToBorrowParentOpeningTagEndMarker: U_, printOpeningTagEndMarker: z_ } = w_;
  var G_ = function(e2, t2) {
    let n2 = e2.startSourceSpan.end.offset;
    e2.firstChild && U_(e2.firstChild) && (n2 -= z_(e2).length);
    let r2 = e2.endSourceSpan.start.offset;
    return e2.lastChild && $_(e2.lastChild) ? r2 += V_(e2, t2).length : W_(e2) && (r2 -= q_(e2.lastChild, t2).length), t2.originalText.slice(n2, r2);
  };
  const { builders: { breakParent: H_, group: J_, hardline: X_, indent: Y_, line: K_, fill: Q_, softline: Z_ }, utils: { mapDoc: eM, replaceTextEndOfLine: tM } } = eu$1, { printClosingTag: nM, printClosingTagSuffix: rM, needsToBorrowPrevClosingTagEndMarker: iM, printOpeningTagPrefix: uM, printOpeningTag: oM } = w_, { printImgSrcset: sM, printClassNames: aM } = __, { printVueFor: cM, printVueBindings: lM, isVueEventBindingExpression: pM } = R_, { isScriptLikeTag: fM, isVueNonHtmlBlock: dM, inferScriptParser: hM, htmlTrimPreserveIndentation: gM, dedentString: mM, unescapeQuoteEntities: yM, isVueSlotAttribute: DM, isVueSfcBindingsAttribute: EM, getTextValueParts: CM } = KL;
  function bM(e2, t2, n2) {
    const r2 = (t3) => new RegExp(t3.join("|")).test(e2.fullName), i2 = () => yM(e2.value);
    let u2 = false;
    const o2 = (e3, t3) => {
      const n3 = e3.type === "NGRoot" ? e3.node.type === "NGMicrosyntax" && e3.node.body.length === 1 && e3.node.body[0].type === "NGMicrosyntaxExpression" ? e3.node.body[0].expression : e3.node : e3.type === "JsExpressionRoot" ? e3.node : e3;
      !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && (t3.parser !== "__vue_expression" || n3.type !== "TemplateLiteral" && n3.type !== "StringLiteral") || (u2 = true);
    }, s2 = (e3, t3 = true) => J_([Y_([Z_, e3]), t3 ? Z_ : ""]), a2 = (e3) => u2 ? ((e4) => J_(e4))(e3) : s2(e3), c2 = (e3, n3) => t2(e3, Object.assign({ __onHtmlBindingRoot: o2, __embeddedInHtml: true }, n3), { stripTrailingHardline: true });
    if (e2.fullName === "srcset" && (e2.parent.fullName === "img" || e2.parent.fullName === "source"))
      return s2(sM(i2()));
    if (e2.fullName === "class" && !n2.parentParser) {
      const e3 = i2();
      if (!e3.includes("{{"))
        return aM(e3);
    }
    if (e2.fullName === "style" && !n2.parentParser) {
      const e3 = i2();
      if (!e3.includes("{{"))
        return s2(c2(e3, { parser: "css", __isHTMLStyleAttribute: true }));
    }
    if (n2.parser === "vue") {
      if (e2.fullName === "v-for")
        return cM(i2(), c2);
      if (DM(e2) || EM(e2, n2))
        return lM(i2(), c2);
      const t3 = ["^:", "^v-bind:"], u3 = ["^v-"];
      if (r2(["^@", "^v-on:"])) {
        const e3 = i2();
        return a2(c2(e3, { parser: pM(e3) ? "__js_expression" : "__vue_event_binding" }));
      }
      if (r2(t3))
        return a2(c2(i2(), { parser: "__vue_expression" }));
      if (r2(u3))
        return a2(c2(i2(), { parser: "__js_expression" }));
    }
    if (n2.parser === "angular") {
      const t3 = (e3, t4) => c2(e3, Object.assign(Object.assign({}, t4), {}, { trailingComma: "none" })), n3 = ["^\\*"], u3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], o3 = ["^i18n(-.+)?$"];
      if (r2(["^\\(.+\\)$", "^on-"]))
        return a2(t3(i2(), { parser: "__ng_action" }));
      if (r2(u3))
        return a2(t3(i2(), { parser: "__ng_binding" }));
      if (r2(o3)) {
        const t4 = i2().trim();
        return s2(Q_(CM(e2, t4)), !t4.includes("@@"));
      }
      if (r2(n3))
        return a2(t3(i2(), { parser: "__ng_directive" }));
      const l2 = /{{(.+?)}}/s, p2 = i2();
      if (l2.test(p2)) {
        const e3 = [];
        for (const [n4, r3] of p2.split(l2).entries())
          if (n4 % 2 == 0)
            e3.push(tM(r3));
          else
            try {
              e3.push(J_(["{{", Y_([K_, t3(r3, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), K_, "}}"]));
            } catch (e4) {
              e3.push("{{", tM(r3), "}}");
            }
        return J_(e3);
      }
    }
    return null;
  }
  var AM = function(e2, t2, n2, r2) {
    const i2 = e2.getValue();
    switch (i2.type) {
      case "element":
        if (fM(i2) || i2.type === "interpolation")
          return;
        if (!i2.isSelfClosing && dM(i2, r2)) {
          const u2 = hM(i2, r2);
          if (!u2)
            return;
          const o2 = G_(i2, r2);
          let s2 = /^\s*$/.test(o2), a2 = "";
          return s2 || (a2 = n2(gM(o2), { parser: u2, __embeddedInHtml: true }, { stripTrailingHardline: true }), s2 = a2 === ""), [uM(i2, r2), J_(oM(e2, r2, t2)), s2 ? "" : X_, a2, s2 ? "" : X_, nM(i2, r2), rM(i2, r2)];
        }
        break;
      case "text":
        if (fM(i2.parent)) {
          const e3 = hM(i2.parent);
          if (e3) {
            const t3 = e3 === "markdown" ? mM(i2.value.replace(/^[^\S\n]*?\n/, "")) : i2.value, u2 = { parser: e3, __embeddedInHtml: true };
            if (r2.parser === "html" && e3 === "babel") {
              let e4 = "script";
              const { attrMap: t4 } = i2.parent;
              t4 && (t4.type === "module" || t4.type === "text/babel" && t4["data-type"] === "module") && (e4 = "module"), u2.__babelSourceType = e4;
            }
            return [H_, uM(i2, r2), n2(t3, u2, { stripTrailingHardline: true }), rM(i2, r2)];
          }
        } else if (i2.parent.type === "interpolation") {
          const e3 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
          return r2.parser === "angular" ? (e3.parser = "__ng_interpolation", e3.trailingComma = "none") : r2.parser === "vue" ? e3.parser = "__vue_expression" : e3.parser = "__js_expression", [Y_([K_, n2(i2.value, e3, { stripTrailingHardline: true })]), i2.parent.next && iM(i2.parent.next) ? " " : K_];
        }
        break;
      case "attribute": {
        if (!i2.value)
          break;
        if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
          return [i2.rawName, "=", i2.value];
        if (r2.parser === "lwc") {
          if (/^{.*}$/s.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
            return [i2.rawName, "=", i2.value];
        }
        const e3 = bM(i2, (e4, t3) => n2(e4, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, t3), { stripTrailingHardline: true }), r2);
        if (e3)
          return [i2.rawName, '="', J_(eM(e3, (e4) => typeof e4 == "string" ? e4.replace(/"/g, "&quot;") : e4)), '"'];
        break;
      }
      case "front-matter":
        return rN(i2, n2);
    }
  };
  const { builders: { breakParent: vM, group: FM, ifBreak: SM, line: xM, softline: wM, hardline: TM }, utils: { replaceTextEndOfLine: BM } } = eu$1, { locStart: NM, locEnd: kM } = Xj, { forceBreakChildren: PM, forceNextEmptyLine: OM, isTextLikeNode: IM, hasPrettierIgnore: LM, preferHardlineAsLeadingSpaces: jM } = KL, { printOpeningTagPrefix: _M, needsToBorrowNextOpeningTagStartMarker: MM, printOpeningTagStartMarker: RM, needsToBorrowPrevClosingTagEndMarker: $M, printClosingTagEndMarker: VM, printClosingTagSuffix: WM, needsToBorrowParentClosingTagStartMarker: qM } = w_;
  function UM(e2, t2, n2) {
    const r2 = e2.getValue();
    return LM(r2) ? [_M(r2, t2), ...BM(t2.originalText.slice(NM(r2) + (r2.prev && MM(r2.prev) ? RM(r2).length : 0), kM(r2) - (r2.next && $M(r2.next) ? VM(r2, t2).length : 0))), WM(r2, t2)] : n2();
  }
  function zM(e2, t2) {
    return IM(e2) && IM(t2) ? e2.isTrailingSpaceSensitive ? e2.hasTrailingSpaces ? jM(t2) ? TM : xM : "" : jM(t2) ? TM : wM : MM(e2) && (LM(t2) || t2.firstChild || t2.isSelfClosing || t2.type === "element" && t2.attrs.length > 0) || e2.type === "element" && e2.isSelfClosing && $M(t2) ? "" : !t2.isLeadingSpaceSensitive || jM(t2) || $M(t2) && e2.lastChild && qM(e2.lastChild) && e2.lastChild.lastChild && qM(e2.lastChild.lastChild) ? TM : t2.hasLeadingSpaces ? xM : wM;
  }
  var GM = { printChildren: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (PM(r2))
      return [vM, ...e2.map((e3) => {
        const r3 = e3.getValue(), i3 = r3.prev ? zM(r3.prev, r3) : "";
        return [i3 ? [i3, OM(r3.prev) ? TM : ""] : "", UM(e3, t2, n2)];
      }, "children")];
    const i2 = r2.children.map(() => Symbol(""));
    return e2.map((e3, r3) => {
      const u2 = e3.getValue();
      if (IM(u2)) {
        if (u2.prev && IM(u2.prev)) {
          const r4 = zM(u2.prev, u2);
          if (r4)
            return OM(u2.prev) ? [TM, TM, UM(e3, t2, n2)] : [r4, UM(e3, t2, n2)];
        }
        return UM(e3, t2, n2);
      }
      const o2 = [], s2 = [], a2 = [], c2 = [], l2 = u2.prev ? zM(u2.prev, u2) : "", p2 = u2.next ? zM(u2, u2.next) : "";
      return l2 && (OM(u2.prev) ? o2.push(TM, TM) : l2 === TM ? o2.push(TM) : IM(u2.prev) ? s2.push(l2) : s2.push(SM("", wM, { groupId: i2[r3 - 1] }))), p2 && (OM(u2) ? IM(u2.next) && c2.push(TM, TM) : p2 === TM ? IM(u2.next) && c2.push(TM) : a2.push(p2)), [...o2, FM([...s2, FM([UM(e3, t2, n2), ...a2], { id: i2[r3] })]), ...c2];
    }, "children");
  } };
  const { builders: { breakParent: HM, dedentToRoot: JM, group: XM, ifBreak: YM, indentIfBreak: KM, indent: QM, line: ZM, softline: eR }, utils: { replaceTextEndOfLine: tR } } = eu$1, { shouldPreserveContent: nR, isScriptLikeTag: rR, isVueCustomBlock: iR, countParents: uR, forceBreakContent: oR } = KL, { printOpeningTagPrefix: sR, printOpeningTag: aR, printClosingTagSuffix: cR, printClosingTag: lR, needsToBorrowPrevClosingTagEndMarker: pR, needsToBorrowLastChildClosingTagEndMarker: fR } = w_, { printChildren: dR } = GM;
  var hR = { printElement: function(e2, t2, n2) {
    const r2 = e2.getValue();
    if (nR(r2, t2))
      return [sR(r2, t2), XM(aR(e2, t2, n2)), ...tR(G_(r2, t2)), ...lR(r2, t2), cR(r2, t2)];
    const i2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, u2 = Symbol("element-attr-group-id"), o2 = (i3) => XM([XM(aR(e2, t2, n2), { id: u2 }), i3, lR(r2, t2)]);
    return r2.children.length === 0 ? o2(r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? ZM : "") : o2([oR(r2) ? HM : "", (s2 = [i2 ? YM(eR, "", { groupId: u2 }) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? ZM : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? JM(eR) : eR, dR(e2, t2, n2)], i2 ? KM(s2, { groupId: u2 }) : !rR(r2) && !iR(r2, t2) || r2.parent.type !== "root" || t2.parser !== "vue" || t2.vueIndentScriptAndStyle ? QM(s2) : s2), (r2.next ? pR(r2.next) : fR(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : i2 ? YM(eR, "", { groupId: u2 }) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? ZM : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t2.tabWidth * uR(e2, (e3) => e3.parent && e3.parent.type !== "root")}}$`).test(r2.lastChild.value) ? "" : eR]);
    var s2;
  } };
  const { builders: { fill: gR, group: mR, hardline: yR, literalline: DR }, utils: { cleanDoc: ER, getDocParts: CR, isConcat: bR, replaceTextEndOfLine: AR } } = eu$1, { countChars: vR, unescapeQuoteEntities: FR, getTextValueParts: SR } = KL, { insertPragma: xR } = Jj, { locStart: wR, locEnd: TR } = Xj, { printClosingTagSuffix: BR, printClosingTagEnd: NR, printOpeningTagPrefix: kR, printOpeningTagStart: PR } = w_, { printElement: OR } = hR, { printChildren: IR } = GM;
  var LR = { preprocess: Hj, print: function(e2, t2, n2) {
    const r2 = e2.getValue();
    switch (r2.type) {
      case "front-matter":
        return AR(r2.raw);
      case "root":
        return t2.__onHtmlRoot && t2.__onHtmlRoot(r2), [mR(IR(e2, t2, n2)), yR];
      case "element":
      case "ieConditionalComment":
        return OR(e2, t2, n2);
      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return [PR(r2), NR(r2)];
      case "interpolation":
        return [PR(r2, t2), ...e2.map(n2, "children"), NR(r2, t2)];
      case "text": {
        if (r2.parent.type === "interpolation") {
          const e4 = /\n[^\S\n]*?$/, t3 = e4.test(r2.value), n3 = t3 ? r2.value.replace(e4, "") : r2.value;
          return [...AR(n3), t3 ? yR : ""];
        }
        const e3 = ER([kR(r2, t2), ...SR(r2), BR(r2, t2)]);
        return bR(e3) || e3.type === "fill" ? gR(CR(e3)) : e3;
      }
      case "docType":
        return [mR([PR(r2, t2), " ", r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), NR(r2, t2)];
      case "comment":
        return [kR(r2, t2), ...AR(t2.originalText.slice(wR(r2), TR(r2)), DR), BR(r2, t2)];
      case "attribute": {
        if (r2.value === null)
          return r2.rawName;
        const e3 = FR(r2.value), t3 = vR(e3, "'") < vR(e3, '"') ? "'" : '"';
        return [r2.rawName, "=", t3, ...AR(t3 === '"' ? e3.replace(/"/g, "&quot;") : e3.replace(/'/g, "&apos;")), t3];
      }
      default:
        throw new Error(`Unexpected node type ${r2.type}`);
    }
  }, insertPragma: xR, massageAstNode: dL, embed: AM };
  var jR = { bracketSameLine: WB.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: "HTML", type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, vueIndentScriptAndStyle: { since: "1.19.0", category: "HTML", type: "boolean", default: false, description: "Indent script and style tags in Vue files." } }, _R = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 }, MR = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
  var RR = { languages: [Xd(_R, () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), Xd(_R, (e2) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e2.extensions, ".mjml"] })), Xd(_R, () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), Xd(MR, () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], printers: { html: LR }, options: jR, parsers: void 0 };
  var $R = { isPragma: function(e2) {
    return /^\s*@(?:prettier|format)\s*$/.test(e2);
  }, hasPragma: function(e2) {
    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e2);
  }, insertPragma: function(e2) {
    return `# @format

${e2}`;
  } };
  var VR = { locStart: function(e2) {
    return e2.position.start.offset;
  }, locEnd: function(e2) {
    return e2.position.end.offset;
  } };
  var WR = function(e2, t2, n2, r2) {
    if (e2.getValue().type === "root" && r2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r2.filepath))
      return n2(r2.originalText, Object.assign(Object.assign({}, r2), {}, { parser: "json" }));
  };
  const { getLast: qR, isNonEmptyArray: UR } = yi$2;
  function zR(e2, t2) {
    return e2 && typeof e2.type == "string" && (!t2 || t2.includes(e2.type));
  }
  function GR(e2) {
    return e2.value.trim() === "prettier-ignore";
  }
  function HR(e2) {
    return e2 && UR(e2.leadingComments);
  }
  function JR(e2) {
    return e2 && UR(e2.middleComments);
  }
  function XR(e2) {
    return e2 && e2.indicatorComment;
  }
  function YR(e2) {
    return e2 && e2.trailingComment;
  }
  function KR(e2) {
    return e2 && UR(e2.endComments);
  }
  function QR(e2) {
    const t2 = [];
    let n2;
    for (const r2 of e2.split(/( +)/))
      r2 !== " " ? n2 === " " ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : n2 === void 0 && t2.unshift(""), n2 = r2;
    return n2 === " " && t2.push((t2.pop() || "") + " "), t2[0] === "" && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
  }
  var ZR = { getLast: qR, getAncestorCount: function(e2, t2) {
    let n2 = 0;
    const r2 = e2.stack.length - 1;
    for (let i2 = 0; i2 < r2; i2++) {
      const r3 = e2.stack[i2];
      zR(r3) && t2(r3) && n2++;
    }
    return n2;
  }, isNode: zR, isEmptyNode: function(e2) {
    return !UR(e2.children) && !function(e3) {
      return HR(e3) || JR(e3) || XR(e3) || YR(e3) || KR(e3);
    }(e2);
  }, isInlineNode: function(e2) {
    if (!e2)
      return true;
    switch (e2.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;
      default:
        return false;
    }
  }, mapNode: function e2(t2, n2, r2) {
    return n2("children" in t2 ? Object.assign(Object.assign({}, t2), {}, { children: t2.children.map((r3) => e2(r3, n2, t2)) }) : t2, r2);
  }, defineShortcut: function(e2, t2, n2) {
    Object.defineProperty(e2, t2, { get: n2, enumerable: false });
  }, isNextLineEmpty: function(e2, t2) {
    let n2 = 0;
    const r2 = t2.length;
    for (let i2 = e2.position.end.offset - 1; i2 < r2; i2++) {
      const e3 = t2[i2];
      if (e3 === "\n" && n2++, n2 === 1 && /\S/.test(e3))
        return false;
      if (n2 === 2)
        return true;
    }
    return false;
  }, isLastDescendantNode: function(e2) {
    switch (e2.getValue().type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }
    const t2 = e2.stack.length;
    for (let n2 = 1; n2 < t2; n2++) {
      const t3 = e2.stack[n2], r2 = e2.stack[n2 - 1];
      if (Array.isArray(r2) && typeof t3 == "number" && t3 !== r2.length - 1)
        return false;
    }
    return true;
  }, getBlockValueLineContents: function(e2, { parentIndent: t2, isLastDescendant: n2, options: r2 }) {
    const i2 = e2.position.start.line === e2.position.end.line ? "" : r2.originalText.slice(e2.position.start.offset, e2.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u2 = e2.indent === null ? ((e3) => e3 ? e3[1].length : Number.POSITIVE_INFINITY)(i2.match(/^( *)\S/m)) : e2.indent - 1 + t2, o2 = i2.split("\n").map((e3) => e3.slice(u2));
    return r2.proseWrap === "preserve" || e2.type === "blockLiteral" ? s2(o2.map((e3) => e3.length === 0 ? [] : [e3])) : s2(o2.map((e3) => e3.length === 0 ? [] : QR(e3)).reduce((e3, t3, n3) => n3 !== 0 && o2[n3 - 1].length > 0 && t3.length > 0 && !/^\s/.test(t3[0]) && !/^\s|\s$/.test(qR(e3)) ? [...e3.slice(0, -1), [...qR(e3), ...t3]] : [...e3, t3], []).map((e3) => e3.reduce((e4, t3) => e4.length > 0 && /\s$/.test(qR(e4)) ? [...e4.slice(0, -1), qR(e4) + " " + t3] : [...e4, t3], [])).map((e3) => r2.proseWrap === "never" ? [e3.join(" ")] : e3));
    function s2(t3) {
      if (e2.chomping === "keep")
        return qR(t3).length === 0 ? t3.slice(0, -1) : t3;
      let r3 = 0;
      for (let e3 = t3.length - 1; e3 >= 0 && t3[e3].length === 0; e3--)
        r3++;
      return r3 === 0 ? t3 : r3 >= 2 && !n2 ? t3.slice(0, -(r3 - 1)) : t3.slice(0, -r3);
    }
  }, getFlowScalarLineContents: function(e2, t2, n2) {
    const r2 = t2.split("\n").map((e3, t3, n3) => t3 === 0 && t3 === n3.length - 1 ? e3 : t3 !== 0 && t3 !== n3.length - 1 ? e3.trim() : t3 === 0 ? e3.trimEnd() : e3.trimStart());
    return n2.proseWrap === "preserve" ? r2.map((e3) => e3.length === 0 ? [] : [e3]) : r2.map((e3) => e3.length === 0 ? [] : QR(e3)).reduce((t3, n3, i2) => i2 !== 0 && r2[i2 - 1].length > 0 && n3.length > 0 && (e2 !== "quoteDouble" || !qR(qR(t3)).endsWith("\\")) ? [...t3.slice(0, -1), [...qR(t3), ...n3]] : [...t3, n3], []).map((e3) => n2.proseWrap === "never" ? [e3.join(" ")] : e3);
  }, getLastDescendantNode: function e2(t2) {
    return UR(t2.children) ? e2(qR(t2.children)) : t2;
  }, hasPrettierIgnore: function(e2) {
    const t2 = e2.getValue();
    if (t2.type === "documentBody") {
      const t3 = e2.getParentNode();
      return KR(t3.head) && GR(qR(t3.head.endComments));
    }
    return HR(t2) && GR(qR(t2.leadingComments));
  }, hasLeadingComments: HR, hasMiddleComments: JR, hasIndicatorComment: XR, hasTrailingComment: YR, hasEndComments: KR };
  const { defineShortcut: e$, mapNode: t$ } = ZR;
  function n$(e2) {
    switch (e2.type) {
      case "document":
        e$(e2, "head", () => e2.children[0]), e$(e2, "body", () => e2.children[1]);
        break;
      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        e$(e2, "content", () => e2.children[0]);
        break;
      case "mappingItem":
      case "flowMappingItem":
        e$(e2, "key", () => e2.children[0]), e$(e2, "value", () => e2.children[1]);
    }
    return e2;
  }
  var r$ = function(e2) {
    return t$(e2, n$);
  };
  const { builders: { softline: i$, align: u$ } } = eu$1, { hasEndComments: o$, isNextLineEmpty: s$, isNode: a$ } = ZR, c$ = new WeakMap();
  function l$(e2) {
    return o$(e2) && !a$(e2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
  }
  var p$ = { alignWithSpaces: function(e2, t2) {
    return u$(" ".repeat(e2), t2);
  }, shouldPrintEndComments: l$, printNextEmptyLine: function(e2, t2) {
    const n2 = e2.getValue(), r2 = e2.stack[0];
    let i2;
    return c$.has(r2) ? i2 = c$.get(r2) : (i2 = new Set(), c$.set(r2, i2)), i2.has(n2.position.end.line) || (i2.add(n2.position.end.line), !s$(n2, t2) || l$(e2.getParentNode())) ? "" : i$;
  } };
  const { builders: { ifBreak: f$, line: d$, softline: h$, hardline: g$, join: m$ } } = eu$1, { isEmptyNode: y$, getLast: D$, hasEndComments: E$ } = ZR, { printNextEmptyLine: C$, alignWithSpaces: b$ } = p$;
  function A$(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = r2.type === "flowMapping", u2 = i2 ? "{" : "[", o2 = i2 ? "}" : "]";
    let s2 = h$;
    i2 && r2.children.length > 0 && n2.bracketSpacing && (s2 = d$);
    const a2 = D$(r2.children), c2 = a2 && a2.type === "flowMappingItem" && y$(a2.key) && y$(a2.value);
    return [u2, b$(n2.tabWidth, [s2, v$(e2, t2, n2), n2.trailingComma === "none" ? "" : f$(","), E$(r2) ? [g$, m$(g$, e2.map(t2, "endComments"))] : ""]), c2 ? "" : s2, o2];
  }
  function v$(e2, t2, n2) {
    const r2 = e2.getValue();
    return e2.map((e3, i2) => [t2(), i2 === r2.children.length - 1 ? "" : [",", d$, r2.children[i2].position.start.line !== r2.children[i2 + 1].position.start.line ? C$(e3, n2.originalText) : ""]], "children");
  }
  var F$ = { printFlowMapping: A$, printFlowSequence: A$ };
  const { builders: { conditionalGroup: S$, group: x$, hardline: w$, ifBreak: T$, join: B$, line: N$ } } = eu$1, { hasLeadingComments: k$, hasMiddleComments: P$, hasTrailingComment: O$, hasEndComments: I$, isNode: L$, isEmptyNode: j$, isInlineNode: _$ } = ZR, { alignWithSpaces: M$ } = p$;
  function R$(e2, t2) {
    if (!e2)
      return true;
    switch (e2.type) {
      case "plain":
      case "quoteSingle":
      case "quoteDouble":
        break;
      case "alias":
        return true;
      default:
        return false;
    }
    if (t2.proseWrap === "preserve")
      return e2.position.start.line === e2.position.end.line;
    if (/\\$/m.test(t2.originalText.slice(e2.position.start.offset, e2.position.end.offset)))
      return false;
    switch (t2.proseWrap) {
      case "never":
        return !e2.value.includes("\n");
      case "always":
        return !/[\n ]/.test(e2.value);
      default:
        return false;
    }
  }
  var $$ = function(e2, t2, n2, r2, i2) {
    const { key: u2, value: o2 } = e2, s2 = j$(u2), a2 = j$(o2);
    if (s2 && a2)
      return ": ";
    const c2 = r2("key"), l2 = function(e3) {
      return e3.key.content && e3.key.content.type === "alias";
    }(e2) ? " " : "";
    if (a2)
      return e2.type === "flowMappingItem" && t2.type === "flowMapping" ? c2 : e2.type !== "mappingItem" || !R$(u2.content, i2) || O$(u2.content) || t2.tag && t2.tag.value === "tag:yaml.org,2002:set" ? ["? ", M$(2, c2)] : [c2, l2, ":"];
    const p2 = r2("value");
    if (s2)
      return [": ", M$(2, p2)];
    if (k$(o2) || !_$(u2.content))
      return ["? ", M$(2, c2), w$, B$("", n2.map(r2, "value", "leadingComments").map((e3) => [e3, w$])), ": ", M$(2, p2)];
    if (function(e3) {
      if (!e3)
        return true;
      switch (e3.type) {
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
          return e3.position.start.line === e3.position.end.line;
        case "alias":
          return true;
        default:
          return false;
      }
    }(u2.content) && !k$(u2.content) && !P$(u2.content) && !O$(u2.content) && !I$(u2) && !k$(o2.content) && !P$(o2.content) && !I$(o2) && R$(o2.content, i2))
      return [c2, l2, ": ", p2];
    const f2 = Symbol("mappingKey"), d2 = x$([T$("? "), x$(M$(2, c2), { id: f2 })]), h2 = [w$, ": ", M$(2, p2)], g2 = [l2, ":"];
    k$(o2.content) || I$(o2) && o2.content && !L$(o2.content, ["mapping", "sequence"]) || t2.type === "mapping" && O$(u2.content) && _$(o2.content) || L$(o2.content, ["mapping", "sequence"]) && o2.content.tag === null && o2.content.anchor === null ? g2.push(w$) : o2.content && g2.push(N$), g2.push(p2);
    const m2 = M$(i2.tabWidth, g2);
    return !R$(u2.content, i2) || k$(u2.content) || P$(u2.content) || I$(u2) ? S$([[d2, T$(h2, m2, { groupId: f2 })]]) : S$([[c2, m2]]);
  };
  const { builders: { dedent: V$, dedentToRoot: W$, fill: q$, hardline: U$, join: z$, line: G$, literalline: H$, markAsRoot: J$ }, utils: { getDocParts: X$ } } = eu$1, { getAncestorCount: Y$, getBlockValueLineContents: K$, hasIndicatorComment: Q$, isLastDescendantNode: Z$, isNode: eV } = ZR, { alignWithSpaces: tV } = p$;
  var nV = function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = Y$(e2, (e3) => eV(e3, ["sequence", "mapping"])), u2 = Z$(e2), o2 = [r2.type === "blockFolded" ? ">" : "|"];
    r2.indent !== null && o2.push(r2.indent.toString()), r2.chomping !== "clip" && o2.push(r2.chomping === "keep" ? "+" : "-"), Q$(r2) && o2.push(" ", t2("indicatorComment"));
    const s2 = K$(r2, { parentIndent: i2, isLastDescendant: u2, options: n2 }), a2 = [];
    for (const [e3, t3] of s2.entries())
      e3 === 0 && a2.push(U$), a2.push(q$(X$(z$(G$, t3)))), e3 !== s2.length - 1 ? a2.push(t3.length === 0 ? U$ : J$(H$)) : r2.chomping === "keep" && u2 && a2.push(W$(t3.length === 0 ? U$ : H$));
    return r2.indent === null ? o2.push(V$(tV(n2.tabWidth, a2))) : o2.push(W$(tV(r2.indent - 1 + i2, a2))), o2;
  };
  const { builders: { breakParent: rV, fill: iV, group: uV, hardline: oV, join: sV, line: aV, lineSuffix: cV, literalline: lV }, utils: { getDocParts: pV, replaceTextEndOfLine: fV } } = eu$1, { isPreviousLineEmpty: dV } = yi$2, { insertPragma: hV, isPragma: gV } = $R, { locStart: mV } = VR, { getFlowScalarLineContents: yV, getLastDescendantNode: DV, hasLeadingComments: EV, hasMiddleComments: CV, hasTrailingComment: bV, hasEndComments: AV, hasPrettierIgnore: vV, isLastDescendantNode: FV, isNode: SV, isInlineNode: xV } = ZR, { alignWithSpaces: wV, printNextEmptyLine: TV, shouldPrintEndComments: BV } = p$, { printFlowMapping: NV, printFlowSequence: kV } = F$;
  function PV(e2, t2) {
    return bV(e2) || t2 && (t2.head.children.length > 0 || AV(t2.head));
  }
  function OV(e2, t2, n2) {
    const r2 = yV(e2, t2, n2);
    return sV(oV, r2.map((e3) => iV(pV(sV(aV, e3)))));
  }
  var IV = { preprocess: r$, embed: WR, print: function(e2, t2, n2) {
    const r2 = e2.getValue(), i2 = [];
    r2.type !== "mappingValue" && EV(r2) && i2.push([sV(oV, e2.map(n2, "leadingComments")), oV]);
    const { tag: u2, anchor: o2 } = r2;
    u2 && i2.push(n2("tag")), u2 && o2 && i2.push(" "), o2 && i2.push(n2("anchor"));
    let s2 = "";
    SV(r2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !FV(e2) && (s2 = TV(e2, t2.originalText)), (u2 || o2) && (SV(r2, ["sequence", "mapping"]) && !CV(r2) ? i2.push(oV) : i2.push(" ")), CV(r2) && i2.push([r2.middleComments.length === 1 ? "" : oV, sV(oV, e2.map(n2, "middleComments")), oV]);
    const a2 = e2.getParentNode();
    return vV(e2) ? i2.push(fV(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), lV)) : i2.push(uV(function(e3, t3, n3, r3, i3) {
      switch (e3.type) {
        case "root": {
          const { children: t4 } = e3, r4 = [];
          n3.each((e4, n4) => {
            const u4 = t4[n4], o3 = t4[n4 + 1];
            n4 !== 0 && r4.push(oV), r4.push(i3()), PV(u4, o3) ? (r4.push(oV, "..."), bV(u4) && r4.push(" ", i3("trailingComment"))) : o3 && !bV(o3.head) && r4.push(oV, "---");
          }, "children");
          const u3 = DV(e3);
          return SV(u3, ["blockLiteral", "blockFolded"]) && u3.chomping === "keep" || r4.push(oV), r4;
        }
        case "document": {
          const u3 = [];
          return function(e4, t4, n4, r4) {
            if (n4.children[0] === e4 && /---(?:\s|$)/.test(r4.originalText.slice(mV(e4), mV(e4) + 4)) || e4.head.children.length > 0 || AV(e4.head) || bV(e4.head))
              return "head";
            if (PV(e4, t4))
              return false;
            return !!t4 && "root";
          }(e3, t3.children[n3.getName() + 1], t3, r3) === "head" && ((e3.head.children.length > 0 || e3.head.endComments.length > 0) && u3.push(i3("head")), bV(e3.head) ? u3.push(["---", " ", i3(["head", "trailingComment"])]) : u3.push("---")), function(e4) {
            return e4.body.children.length > 0 || AV(e4.body);
          }(e3) && u3.push(i3("body")), sV(oV, u3);
        }
        case "documentHead":
          return sV(oV, [...n3.map(i3, "children"), ...n3.map(i3, "endComments")]);
        case "documentBody": {
          const { children: t4, endComments: r4 } = e3;
          let u3 = "";
          if (t4.length > 0 && r4.length > 0) {
            const t5 = DV(e3);
            SV(t5, ["blockFolded", "blockLiteral"]) ? t5.chomping !== "keep" && (u3 = [oV, oV]) : u3 = oV;
          }
          return [sV(oV, n3.map(i3, "children")), u3, sV(oV, n3.map(i3, "endComments"))];
        }
        case "directive":
          return ["%", sV(" ", [e3.name, ...e3.parameters])];
        case "comment":
          return ["#", e3.value];
        case "alias":
          return ["*", e3.value];
        case "tag":
          return r3.originalText.slice(e3.position.start.offset, e3.position.end.offset);
        case "anchor":
          return ["&", e3.value];
        case "plain":
          return OV(e3.type, r3.originalText.slice(e3.position.start.offset, e3.position.end.offset), r3);
        case "quoteDouble":
        case "quoteSingle": {
          const t4 = "'", n4 = '"', i4 = r3.originalText.slice(e3.position.start.offset + 1, e3.position.end.offset - 1);
          if (e3.type === "quoteSingle" && i4.includes("\\") || e3.type === "quoteDouble" && /\\[^"]/.test(i4)) {
            const u4 = e3.type === "quoteDouble" ? n4 : t4;
            return [u4, OV(e3.type, i4, r3), u4];
          }
          if (i4.includes(n4))
            return [t4, OV(e3.type, e3.type === "quoteDouble" ? i4.replace(/\\"/g, n4).replace(/'/g, t4.repeat(2)) : i4, r3), t4];
          if (i4.includes(t4))
            return [n4, OV(e3.type, e3.type === "quoteSingle" ? i4.replace(/''/g, t4) : i4, r3), n4];
          const u3 = r3.singleQuote ? t4 : n4;
          return [u3, OV(e3.type, i4, r3), u3];
        }
        case "blockFolded":
        case "blockLiteral":
          return nV(n3, i3, r3);
        case "mapping":
        case "sequence":
          return sV(oV, n3.map(i3, "children"));
        case "sequenceItem":
          return ["- ", wV(2, e3.content ? i3("content") : "")];
        case "mappingKey":
        case "mappingValue":
          return e3.content ? i3("content") : "";
        case "mappingItem":
        case "flowMappingItem":
          return $$(e3, t3, n3, i3, r3);
        case "flowMapping":
          return NV(n3, i3, r3);
        case "flowSequence":
          return kV(n3, i3, r3);
        case "flowSequenceItem":
          return i3("content");
        default:
          throw new Error(`Unexpected node type ${e3.type}`);
      }
    }(r2, a2, e2, t2, n2))), bV(r2) && !SV(r2, ["document", "documentHead"]) && i2.push(cV([r2.type !== "mappingValue" || r2.content ? " " : "", a2.type === "mappingKey" && e2.getParentNode(2).type === "mapping" && xV(r2) ? "" : rV, n2("trailingComment")])), BV(r2) && i2.push(wV(r2.type === "sequenceItem" ? 2 : 0, [oV, sV(oV, e2.map((e3) => [dV(t2.originalText, e3.getValue(), mV) ? oV : "", n2()], "endComments"))])), i2.push(s2), i2;
  }, massageAstNode: function(e2, t2) {
    if (SV(t2))
      switch (delete t2.position, t2.type) {
        case "comment":
          if (gV(t2.value))
            return null;
          break;
        case "quoteDouble":
        case "quoteSingle":
          t2.type = "quote";
      }
  }, insertPragma: hV }, LV = { bracketSpacing: WB.bracketSpacing, singleQuote: WB.singleQuote, proseWrap: WB.proseWrap };
  var jV = [YB, nP, fO, OO, cL, RR, { languages: [Xd({ name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 }, (e2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e2.filenames.filter((e3) => e3 !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))], printers: { yaml: IV }, options: LV, parsers: void 0 }];
  const { version: _V } = e$3, { getSupportInfo: MV } = Qr$2;
  function RV(e2, t2 = 1) {
    return (...n2) => {
      const r2 = n2[t2] || {}, i2 = r2.plugins || [];
      return n2[t2] = Object.assign(Object.assign({}, r2), {}, { plugins: [...jV, ...Array.isArray(i2) ? i2 : Object.values(i2)] }), e2(...n2);
    };
  }
  const $V = RV(vd.formatWithCursor);
  var VV = { formatWithCursor: $V, format: (e2, t2) => $V(e2, t2).formatted, check(e2, t2) {
    const { formatted: n2 } = $V(e2, t2);
    return n2 === e2;
  }, doc: eu$1, getSupportInfo: RV(MV, 0), version: _V, util: Hd, __debug: { parse: RV(vd.parse), formatAST: RV(vd.formatAST), formatDoc: RV(vd.formatDoc), printToDoc: RV(vd.printToDoc), printDocToString: RV(vd.printDocToString) } };
  var e$2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function t$2(e2) {
    return e2 && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  function s$2(e2) {
    var t2 = { exports: {} };
    return e2(t2, t2.exports), t2.exports;
  }
  var r$2, i$2, a$2 = function(e2) {
    return e2 && e2.Math == Math && e2;
  }, n$2 = a$2(typeof globalThis == "object" && globalThis) || a$2(typeof window == "object" && window) || a$2(typeof self == "object" && self) || a$2(typeof e$2 == "object" && e$2) || function() {
    return this;
  }() || Function("return this")(), o$2 = function(e2) {
    try {
      return !!e2();
    } catch (e3) {
      return true;
    }
  }, u$2 = !o$2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  }), h$2 = {}.propertyIsEnumerable, c$2 = Object.getOwnPropertyDescriptor, p$2 = { f: c$2 && !h$2.call({ 1: 2 }, 1) ? function(e2) {
    var t2 = c$2(this, e2);
    return !!t2 && t2.enumerable;
  } : h$2 }, l$2 = function(e2, t2) {
    return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
  }, d$2 = {}.toString, D$2 = function(e2) {
    return d$2.call(e2).slice(8, -1);
  }, m$2 = "".split, f$2 = o$2(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e2) {
    return D$2(e2) == "String" ? m$2.call(e2, "") : Object(e2);
  } : Object, y$2 = function(e2) {
    if (e2 == null)
      throw TypeError("Can't call method on " + e2);
    return e2;
  }, A$2 = function(e2) {
    return f$2(y$2(e2));
  }, E$2 = function(e2) {
    return typeof e2 == "object" ? e2 !== null : typeof e2 == "function";
  }, C$2 = function(e2) {
    return typeof e2 == "function" ? e2 : void 0;
  }, x$2 = function(e2, t2) {
    return arguments.length < 2 ? C$2(n$2[e2]) : n$2[e2] && n$2[e2][t2];
  }, F$2 = x$2("navigator", "userAgent") || "", g$2 = n$2.process, b$2 = n$2.Deno, P$2 = g$2 && g$2.versions || b$2 && b$2.version, T$2 = P$2 && P$2.v8;
  T$2 ? i$2 = (r$2 = T$2.split("."))[0] < 4 ? 1 : r$2[0] + r$2[1] : F$2 && (!(r$2 = F$2.match(/Edge\/(\d+)/)) || r$2[1] >= 74) && (r$2 = F$2.match(/Chrome\/(\d+)/)) && (i$2 = r$2[1]);
  var w$2 = i$2 && +i$2, S$2 = !!Object.getOwnPropertySymbols && !o$2(function() {
    var e2 = Symbol();
    return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && w$2 && w$2 < 41;
  }), B$2 = S$2 && !Symbol.sham && typeof Symbol.iterator == "symbol", N$2 = B$2 ? function(e2) {
    return typeof e2 == "symbol";
  } : function(e2) {
    var t2 = x$2("Symbol");
    return typeof t2 == "function" && Object(e2) instanceof t2;
  }, I$2 = function(e2, t2) {
    try {
      Object.defineProperty(n$2, e2, { value: t2, configurable: true, writable: true });
    } catch (s2) {
      n$2[e2] = t2;
    }
    return t2;
  }, v$2 = n$2["__core-js_shared__"] || I$2("__core-js_shared__", {}), k$2 = s$2(function(e2) {
    (e2.exports = function(e3, t2) {
      return v$2[e3] || (v$2[e3] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({ version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
  }), L$2 = function(e2) {
    return Object(y$2(e2));
  }, O$2 = {}.hasOwnProperty, M$2 = Object.hasOwn || function(e2, t2) {
    return O$2.call(L$2(e2), t2);
  }, R$2 = 0, j$3 = Math.random(), _$2 = function(e2) {
    return "Symbol(" + String(e2 === void 0 ? "" : e2) + ")_" + (++R$2 + j$3).toString(36);
  }, U$2 = k$2("wks"), q$2 = n$2.Symbol, $$2 = B$2 ? q$2 : q$2 && q$2.withoutSetter || _$2, H$2 = function(e2) {
    return M$2(U$2, e2) && (S$2 || typeof U$2[e2] == "string") || (S$2 && M$2(q$2, e2) ? U$2[e2] = q$2[e2] : U$2[e2] = $$2("Symbol." + e2)), U$2[e2];
  }, V$2 = H$2("toPrimitive"), z$2 = function(e2, t2) {
    if (!E$2(e2) || N$2(e2))
      return e2;
    var s2, r2 = e2[V$2];
    if (r2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), s2 = r2.call(e2, t2), !E$2(s2) || N$2(s2))
        return s2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e3, t3) {
      var s3, r3;
      if (t3 === "string" && typeof (s3 = e3.toString) == "function" && !E$2(r3 = s3.call(e3)))
        return r3;
      if (typeof (s3 = e3.valueOf) == "function" && !E$2(r3 = s3.call(e3)))
        return r3;
      if (t3 !== "string" && typeof (s3 = e3.toString) == "function" && !E$2(r3 = s3.call(e3)))
        return r3;
      throw TypeError("Can't convert object to primitive value");
    }(e2, t2);
  }, W$2 = function(e2) {
    var t2 = z$2(e2, "string");
    return N$2(t2) ? t2 : String(t2);
  }, G$2 = n$2.document, K$2 = E$2(G$2) && E$2(G$2.createElement), X$2 = !u$2 && !o$2(function() {
    return Object.defineProperty((e2 = "div", K$2 ? G$2.createElement(e2) : {}), "a", { get: function() {
      return 7;
    } }).a != 7;
    var e2;
  }), J$2 = Object.getOwnPropertyDescriptor, Y$2 = { f: u$2 ? J$2 : function(e2, t2) {
    if (e2 = A$2(e2), t2 = W$2(t2), X$2)
      try {
        return J$2(e2, t2);
      } catch (e3) {
      }
    if (M$2(e2, t2))
      return l$2(!p$2.f.call(e2, t2), e2[t2]);
  } }, Q$2 = function(e2) {
    if (!E$2(e2))
      throw TypeError(String(e2) + " is not an object");
    return e2;
  }, Z$2 = Object.defineProperty, ee$2 = { f: u$2 ? Z$2 : function(e2, t2, s2) {
    if (Q$2(e2), t2 = W$2(t2), Q$2(s2), X$2)
      try {
        return Z$2(e2, t2, s2);
      } catch (e3) {
      }
    if ("get" in s2 || "set" in s2)
      throw TypeError("Accessors not supported");
    return "value" in s2 && (e2[t2] = s2.value), e2;
  } }, te$2 = u$2 ? function(e2, t2, s2) {
    return ee$2.f(e2, t2, l$2(1, s2));
  } : function(e2, t2, s2) {
    return e2[t2] = s2, e2;
  }, se$2 = Function.toString;
  typeof v$2.inspectSource != "function" && (v$2.inspectSource = function(e2) {
    return se$2.call(e2);
  });
  var re$2, ie$2, ae$2, ne$2, oe$2 = v$2.inspectSource, ue$2 = n$2.WeakMap, he$2 = typeof ue$2 == "function" && /native code/.test(oe$2(ue$2)), ce$2 = k$2("keys"), pe$2 = {}, le$2 = n$2.WeakMap;
  if (he$2 || v$2.state) {
    var de$2 = v$2.state || (v$2.state = new le$2()), De$2 = de$2.get, me$2 = de$2.has, fe$2 = de$2.set;
    re$2 = function(e2, t2) {
      if (me$2.call(de$2, e2))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, fe$2.call(de$2, e2, t2), t2;
    }, ie$2 = function(e2) {
      return De$2.call(de$2, e2) || {};
    }, ae$2 = function(e2) {
      return me$2.call(de$2, e2);
    };
  } else {
    var ye$2 = ce$2[ne$2 = "state"] || (ce$2[ne$2] = _$2(ne$2));
    pe$2[ye$2] = true, re$2 = function(e2, t2) {
      if (M$2(e2, ye$2))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, te$2(e2, ye$2, t2), t2;
    }, ie$2 = function(e2) {
      return M$2(e2, ye$2) ? e2[ye$2] : {};
    }, ae$2 = function(e2) {
      return M$2(e2, ye$2);
    };
  }
  var Ae$2 = { set: re$2, get: ie$2, has: ae$2, enforce: function(e2) {
    return ae$2(e2) ? ie$2(e2) : re$2(e2, {});
  }, getterFor: function(e2) {
    return function(t2) {
      var s2;
      if (!E$2(t2) || (s2 = ie$2(t2)).type !== e2)
        throw TypeError("Incompatible receiver, " + e2 + " required");
      return s2;
    };
  } }, Ee$2 = s$2(function(e2) {
    var t2 = Ae$2.get, s2 = Ae$2.enforce, r2 = String(String).split("String");
    (e2.exports = function(e3, t3, i2, a2) {
      var o2, u2 = !!a2 && !!a2.unsafe, h2 = !!a2 && !!a2.enumerable, c2 = !!a2 && !!a2.noTargetGet;
      typeof i2 == "function" && (typeof t3 != "string" || M$2(i2, "name") || te$2(i2, "name", t3), (o2 = s2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e3 !== n$2 ? (u2 ? !c2 && e3[t3] && (h2 = true) : delete e3[t3], h2 ? e3[t3] = i2 : te$2(e3, t3, i2)) : h2 ? e3[t3] = i2 : I$2(t3, i2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || oe$2(this);
    });
  }), Ce$2 = Math.ceil, xe$2 = Math.floor, Fe$2 = function(e2) {
    return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? xe$2 : Ce$2)(e2);
  }, ge$2 = Math.min, be$2 = function(e2) {
    return e2 > 0 ? ge$2(Fe$2(e2), 9007199254740991) : 0;
  }, Pe$2 = Math.max, Te$2 = Math.min, we$2 = function(e2) {
    return function(t2, s2, r2) {
      var i2, a2 = A$2(t2), n2 = be$2(a2.length), o2 = function(e3, t3) {
        var s3 = Fe$2(e3);
        return s3 < 0 ? Pe$2(s3 + t3, 0) : Te$2(s3, t3);
      }(r2, n2);
      if (e2 && s2 != s2) {
        for (; n2 > o2; )
          if ((i2 = a2[o2++]) != i2)
            return true;
      } else
        for (; n2 > o2; o2++)
          if ((e2 || o2 in a2) && a2[o2] === s2)
            return e2 || o2 || 0;
      return !e2 && -1;
    };
  }, Se$2 = { includes: we$2(true), indexOf: we$2(false) }.indexOf, Be$2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ne$2 = { f: Object.getOwnPropertyNames || function(e2) {
    return function(e3, t2) {
      var s2, r2 = A$2(e3), i2 = 0, a2 = [];
      for (s2 in r2)
        !M$2(pe$2, s2) && M$2(r2, s2) && a2.push(s2);
      for (; t2.length > i2; )
        M$2(r2, s2 = t2[i2++]) && (~Se$2(a2, s2) || a2.push(s2));
      return a2;
    }(e2, Be$2);
  } }, Ie$2 = { f: Object.getOwnPropertySymbols }, ve$2 = x$2("Reflect", "ownKeys") || function(e2) {
    var t2 = Ne$2.f(Q$2(e2)), s2 = Ie$2.f;
    return s2 ? t2.concat(s2(e2)) : t2;
  }, ke$2 = function(e2, t2) {
    for (var s2 = ve$2(t2), r2 = ee$2.f, i2 = Y$2.f, a2 = 0; a2 < s2.length; a2++) {
      var n2 = s2[a2];
      M$2(e2, n2) || r2(e2, n2, i2(t2, n2));
    }
  }, Le$2 = /#|\.prototype\./, Oe$2 = function(e2, t2) {
    var s2 = Re$2[Me$2(e2)];
    return s2 == _e$2 || s2 != je$2 && (typeof t2 == "function" ? o$2(t2) : !!t2);
  }, Me$2 = Oe$2.normalize = function(e2) {
    return String(e2).replace(Le$2, ".").toLowerCase();
  }, Re$2 = Oe$2.data = {}, je$2 = Oe$2.NATIVE = "N", _e$2 = Oe$2.POLYFILL = "P", Ue$2 = Oe$2, qe$2 = Y$2.f, $e$2 = function(e2, t2) {
    var s2, r2, i2, a2, o2, u2 = e2.target, h2 = e2.global, c2 = e2.stat;
    if (s2 = h2 ? n$2 : c2 ? n$2[u2] || I$2(u2, {}) : (n$2[u2] || {}).prototype)
      for (r2 in t2) {
        if (a2 = t2[r2], i2 = e2.noTargetGet ? (o2 = qe$2(s2, r2)) && o2.value : s2[r2], !Ue$2(h2 ? r2 : u2 + (c2 ? "." : "#") + r2, e2.forced) && i2 !== void 0) {
          if (typeof a2 == typeof i2)
            continue;
          ke$2(a2, i2);
        }
        (e2.sham || i2 && i2.sham) && te$2(a2, "sham", true), Ee$2(s2, r2, a2, e2);
      }
  }, He$2 = Array.isArray || function(e2) {
    return D$2(e2) == "Array";
  }, Ve$2 = function(e2) {
    if (typeof e2 != "function")
      throw TypeError(String(e2) + " is not a function");
    return e2;
  }, ze$2 = function(e2, t2, s2) {
    if (Ve$2(e2), t2 === void 0)
      return e2;
    switch (s2) {
      case 0:
        return function() {
          return e2.call(t2);
        };
      case 1:
        return function(s3) {
          return e2.call(t2, s3);
        };
      case 2:
        return function(s3, r2) {
          return e2.call(t2, s3, r2);
        };
      case 3:
        return function(s3, r2, i2) {
          return e2.call(t2, s3, r2, i2);
        };
    }
    return function() {
      return e2.apply(t2, arguments);
    };
  }, We$2 = function(e2, t2, s2, r2, i2, a2, n2, o2) {
    for (var u2, h2 = i2, c2 = 0, p2 = !!n2 && ze$2(n2, o2, 3); c2 < r2; ) {
      if (c2 in s2) {
        if (u2 = p2 ? p2(s2[c2], c2, t2) : s2[c2], a2 > 0 && He$2(u2))
          h2 = We$2(e2, t2, u2, be$2(u2.length), h2, a2 - 1) - 1;
        else {
          if (h2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e2[h2] = u2;
        }
        h2++;
      }
      c2++;
    }
    return h2;
  }, Ge$2 = We$2, Ke$2 = H$2("species"), Xe$2 = function(e2, t2) {
    return new (function(e3) {
      var t3;
      return He$2(e3) && (typeof (t3 = e3.constructor) != "function" || t3 !== Array && !He$2(t3.prototype) ? E$2(t3) && (t3 = t3[Ke$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e2))(t2 === 0 ? 0 : t2);
  };
  $e$2({ target: "Array", proto: true }, { flatMap: function(e2) {
    var t2, s2 = L$2(this), r2 = be$2(s2.length);
    return Ve$2(e2), (t2 = Xe$2(s2, 0)).length = Ge$2(t2, s2, s2, r2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t2;
  } });
  var Je$2 = function(...e2) {
    let t2;
    for (const [s2, r2] of e2.entries())
      try {
        return { result: r2() };
      } catch (e3) {
        s2 === 0 && (t2 = e3);
      }
    return { error: t2 };
  }, Ye$2 = (e2) => typeof e2 == "string" ? e2.replace((({ onlyFirst: e3 = false } = {}) => {
    const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(t2, e3 ? void 0 : "g");
  })(), "") : e2;
  const Qe$2 = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
  var Ze$2 = Qe$2, et$2 = Qe$2;
  Ze$2.default = et$2;
  const tt$2 = (e2) => {
    if (typeof e2 != "string" || e2.length === 0)
      return 0;
    if ((e2 = Ye$2(e2)).length === 0)
      return 0;
    e2 = e2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
    let t2 = 0;
    for (let s2 = 0; s2 < e2.length; s2++) {
      const r2 = e2.codePointAt(s2);
      r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && s2++, t2 += Ze$2(r2) ? 2 : 1));
    }
    return t2;
  };
  var st$2 = tt$2, rt$2 = tt$2;
  st$2.default = rt$2;
  var it$2 = (e2) => {
    if (typeof e2 != "string")
      throw new TypeError("Expected a string");
    return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  var at$2 = (e2) => e2[e2.length - 1];
  function nt$2(e2, t2) {
    if (e2 == null)
      return {};
    var s2, r2, i2 = function(e3, t3) {
      if (e3 == null)
        return {};
      var s3, r3, i3 = {}, a3 = Object.keys(e3);
      for (r3 = 0; r3 < a3.length; r3++)
        s3 = a3[r3], t3.indexOf(s3) >= 0 || (i3[s3] = e3[s3]);
      return i3;
    }(e2, t2);
    if (Object.getOwnPropertySymbols) {
      var a2 = Object.getOwnPropertySymbols(e2);
      for (r2 = 0; r2 < a2.length; r2++)
        s2 = a2[r2], t2.indexOf(s2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, s2) && (i2[s2] = e2[s2]);
    }
    return i2;
  }
  var ot$2, ut$2, ht$2 = function(e2) {
    if (N$2(e2))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e2);
  }, ct$2 = Math.floor, pt$2 = function(e2, t2) {
    var s2 = e2.length, r2 = ct$2(s2 / 2);
    return s2 < 8 ? lt$2(e2, t2) : dt$2(pt$2(e2.slice(0, r2), t2), pt$2(e2.slice(r2), t2), t2);
  }, lt$2 = function(e2, t2) {
    for (var s2, r2, i2 = e2.length, a2 = 1; a2 < i2; ) {
      for (r2 = a2, s2 = e2[a2]; r2 && t2(e2[r2 - 1], s2) > 0; )
        e2[r2] = e2[--r2];
      r2 !== a2++ && (e2[r2] = s2);
    }
    return e2;
  }, dt$2 = function(e2, t2, s2) {
    for (var r2 = e2.length, i2 = t2.length, a2 = 0, n2 = 0, o2 = []; a2 < r2 || n2 < i2; )
      a2 < r2 && n2 < i2 ? o2.push(s2(e2[a2], t2[n2]) <= 0 ? e2[a2++] : t2[n2++]) : o2.push(a2 < r2 ? e2[a2++] : t2[n2++]);
    return o2;
  }, Dt$2 = pt$2, mt$2 = F$2.match(/firefox\/(\d+)/i), ft$2 = !!mt$2 && +mt$2[1], yt$2 = /MSIE|Trident/.test(F$2), At$2 = F$2.match(/AppleWebKit\/(\d+)\./), Et$2 = !!At$2 && +At$2[1], Ct$2 = [], xt$2 = Ct$2.sort, Ft$2 = o$2(function() {
    Ct$2.sort(void 0);
  }), gt$2 = o$2(function() {
    Ct$2.sort(null);
  }), bt$2 = !!(ut$2 = []["sort"]) && o$2(function() {
    ut$2.call(null, ot$2 || function() {
      throw 1;
    }, 1);
  }), Pt$1 = !o$2(function() {
    if (w$2)
      return w$2 < 70;
    if (!(ft$2 && ft$2 > 3)) {
      if (yt$2)
        return true;
      if (Et$2)
        return Et$2 < 603;
      var e2, t2, s2, r2, i2 = "";
      for (e2 = 65; e2 < 76; e2++) {
        switch (t2 = String.fromCharCode(e2), e2) {
          case 66:
          case 69:
          case 70:
          case 72:
            s2 = 3;
            break;
          case 68:
          case 71:
            s2 = 4;
            break;
          default:
            s2 = 2;
        }
        for (r2 = 0; r2 < 47; r2++)
          Ct$2.push({ k: t2 + r2, v: s2 });
      }
      for (Ct$2.sort(function(e3, t3) {
        return t3.v - e3.v;
      }), r2 = 0; r2 < Ct$2.length; r2++)
        t2 = Ct$2[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
      return i2 !== "DGBEFHACIJK";
    }
  });
  $e$2({ target: "Array", proto: true, forced: Ft$2 || !gt$2 || !bt$2 || !Pt$1 }, { sort: function(e2) {
    e2 !== void 0 && Ve$2(e2);
    var t2 = L$2(this);
    if (Pt$1)
      return e2 === void 0 ? xt$2.call(t2) : xt$2.call(t2, e2);
    var s2, r2, i2 = [], a2 = be$2(t2.length);
    for (r2 = 0; r2 < a2; r2++)
      r2 in t2 && i2.push(t2[r2]);
    for (s2 = (i2 = Dt$2(i2, function(e3) {
      return function(t3, s3) {
        return s3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, s3) || 0 : ht$2(t3) > ht$2(s3) ? 1 : -1;
      };
    }(e2))).length, r2 = 0; r2 < s2; )
      t2[r2] = i2[r2++];
    for (; r2 < a2; )
      delete t2[r2++];
    return t2;
  } });
  var Tt$1 = {}, wt$2 = H$2("iterator"), St$1 = Array.prototype, Bt$1 = {};
  Bt$1[H$2("toStringTag")] = "z";
  var Nt$1 = String(Bt$1) === "[object z]", It$1 = H$2("toStringTag"), vt$2 = D$2(function() {
    return arguments;
  }()) == "Arguments", kt$2 = Nt$1 ? D$2 : function(e2) {
    var t2, s2, r2;
    return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (s2 = function(e3, t3) {
      try {
        return e3[t3];
      } catch (e4) {
      }
    }(t2 = Object(e2), It$1)) == "string" ? s2 : vt$2 ? D$2(t2) : (r2 = D$2(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
  }, Lt$1 = H$2("iterator"), Ot$2 = function(e2) {
    if (e2 != null)
      return e2[Lt$1] || e2["@@iterator"] || Tt$1[kt$2(e2)];
  }, Mt$1 = function(e2, t2, s2) {
    var r2, i2;
    Q$2(e2);
    try {
      if ((r2 = e2.return) === void 0) {
        if (t2 === "throw")
          throw s2;
        return s2;
      }
      r2 = r2.call(e2);
    } catch (e3) {
      i2 = true, r2 = e3;
    }
    if (t2 === "throw")
      throw s2;
    if (i2)
      throw r2;
    return Q$2(r2), s2;
  }, Rt$1 = function(e2, t2) {
    this.stopped = e2, this.result = t2;
  }, jt$1 = function(e2, t2, s2) {
    var r2, i2, a2, n2, o2, u2, h2, c2, p2 = s2 && s2.that, l2 = !(!s2 || !s2.AS_ENTRIES), d2 = !(!s2 || !s2.IS_ITERATOR), D2 = !(!s2 || !s2.INTERRUPTED), m2 = ze$2(t2, p2, 1 + l2 + D2), f2 = function(e3) {
      return r2 && Mt$1(r2, "normal", e3), new Rt$1(true, e3);
    }, y2 = function(e3) {
      return l2 ? (Q$2(e3), D2 ? m2(e3[0], e3[1], f2) : m2(e3[0], e3[1])) : D2 ? m2(e3, f2) : m2(e3);
    };
    if (d2)
      r2 = e2;
    else {
      if (typeof (i2 = Ot$2(e2)) != "function")
        throw TypeError("Target is not iterable");
      if ((c2 = i2) !== void 0 && (Tt$1.Array === c2 || St$1[wt$2] === c2)) {
        for (a2 = 0, n2 = be$2(e2.length); n2 > a2; a2++)
          if ((o2 = y2(e2[a2])) && o2 instanceof Rt$1)
            return o2;
        return new Rt$1(false);
      }
      r2 = function(e3, t3) {
        var s3 = arguments.length < 2 ? Ot$2(e3) : t3;
        if (typeof s3 != "function")
          throw TypeError(String(e3) + " is not iterable");
        return Q$2(s3.call(e3));
      }(e2, i2);
    }
    for (u2 = r2.next; !(h2 = u2.call(r2)).done; ) {
      try {
        o2 = y2(h2.value);
      } catch (e3) {
        Mt$1(r2, "throw", e3);
      }
      if (typeof o2 == "object" && o2 && o2 instanceof Rt$1)
        return o2;
    }
    return new Rt$1(false);
  };
  $e$2({ target: "Object", stat: true }, { fromEntries: function(e2) {
    var t2 = {};
    return jt$1(e2, function(e3, s2) {
      !function(e4, t3, s3) {
        var r2 = W$2(t3);
        r2 in e4 ? ee$2.f(e4, r2, l$2(0, s3)) : e4[r2] = s3;
      }(t2, e3, s2);
    }, { AS_ENTRIES: true }), t2;
  } });
  var _t$1 = _t$1 !== void 0 ? _t$1 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
  function Ut$1() {
    throw new Error("setTimeout has not been defined");
  }
  function qt$1() {
    throw new Error("clearTimeout has not been defined");
  }
  var $t$1 = Ut$1, Ht$1 = qt$1;
  function Vt$1(e2) {
    if ($t$1 === setTimeout)
      return setTimeout(e2, 0);
    if (($t$1 === Ut$1 || !$t$1) && setTimeout)
      return $t$1 = setTimeout, setTimeout(e2, 0);
    try {
      return $t$1(e2, 0);
    } catch (t2) {
      try {
        return $t$1.call(null, e2, 0);
      } catch (t3) {
        return $t$1.call(this, e2, 0);
      }
    }
  }
  typeof _t$1.setTimeout == "function" && ($t$1 = setTimeout), typeof _t$1.clearTimeout == "function" && (Ht$1 = clearTimeout);
  var zt$1, Wt$1 = [], Gt$1 = false, Kt$1 = -1;
  function Xt$1() {
    Gt$1 && zt$1 && (Gt$1 = false, zt$1.length ? Wt$1 = zt$1.concat(Wt$1) : Kt$1 = -1, Wt$1.length && Jt$1());
  }
  function Jt$1() {
    if (!Gt$1) {
      var e2 = Vt$1(Xt$1);
      Gt$1 = true;
      for (var t2 = Wt$1.length; t2; ) {
        for (zt$1 = Wt$1, Wt$1 = []; ++Kt$1 < t2; )
          zt$1 && zt$1[Kt$1].run();
        Kt$1 = -1, t2 = Wt$1.length;
      }
      zt$1 = null, Gt$1 = false, function(e3) {
        if (Ht$1 === clearTimeout)
          return clearTimeout(e3);
        if ((Ht$1 === qt$1 || !Ht$1) && clearTimeout)
          return Ht$1 = clearTimeout, clearTimeout(e3);
        try {
          Ht$1(e3);
        } catch (t3) {
          try {
            return Ht$1.call(null, e3);
          } catch (t4) {
            return Ht$1.call(this, e3);
          }
        }
      }(e2);
    }
  }
  function Yt$1(e2, t2) {
    this.fun = e2, this.array = t2;
  }
  Yt$1.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  function Qt$1() {
  }
  var Zt$1 = Qt$1, es$1 = Qt$1, ts$1 = Qt$1, ss$1 = Qt$1, rs$1 = Qt$1, is$2 = Qt$1, as$1 = Qt$1;
  var ns$1 = _t$1.performance || {}, os$2 = ns$1.now || ns$1.mozNow || ns$1.msNow || ns$1.oNow || ns$1.webkitNow || function() {
    return new Date().getTime();
  };
  var us$1 = new Date();
  var hs$1 = { nextTick: function(e2) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var s2 = 1; s2 < arguments.length; s2++)
        t2[s2 - 1] = arguments[s2];
    Wt$1.push(new Yt$1(e2, t2)), Wt$1.length !== 1 || Gt$1 || Vt$1(Jt$1);
  }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Zt$1, addListener: es$1, once: ts$1, off: ss$1, removeListener: rs$1, removeAllListeners: is$2, emit: as$1, binding: function(e2) {
    throw new Error("process.binding is not supported");
  }, cwd: function() {
    return "/";
  }, chdir: function(e2) {
    throw new Error("process.chdir is not supported");
  }, umask: function() {
    return 0;
  }, hrtime: function(e2) {
    var t2 = 1e-3 * os$2.call(ns$1), s2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
    return e2 && (s2 -= e2[0], (r2 -= e2[1]) < 0 && (s2--, r2 += 1e9)), [s2, r2];
  }, platform: "browser", release: {}, config: {}, uptime: function() {
    return (new Date() - us$1) / 1e3;
  } };
  var cs$1 = typeof hs$1 == "object" && hs$1.env && hs$1.env.NODE_DEBUG && /\bsemver\b/i.test(hs$1.env.NODE_DEBUG) ? (...e2) => console.error("SEMVER", ...e2) : () => {
  };
  var ps$1 = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, ls$1 = s$2(function(e2, t2) {
    const { MAX_SAFE_COMPONENT_LENGTH: s2 } = ps$1, r2 = (t2 = e2.exports = {}).re = [], i2 = t2.src = [], a2 = t2.t = {};
    let n2 = 0;
    const o2 = (e3, t3, s3) => {
      const o3 = n2++;
      cs$1(o3, t3), a2[e3] = o3, i2[o3] = t3, r2[o3] = new RegExp(t3, s3 ? "g" : void 0);
    };
    o2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o2("MAINVERSION", `(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})`), o2("MAINVERSIONLOOSE", `(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})`), o2("PRERELEASEIDENTIFIER", `(?:${i2[a2.NUMERICIDENTIFIER]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[a2.NUMERICIDENTIFIERLOOSE]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASE", `(?:-(${i2[a2.PRERELEASEIDENTIFIER]}(?:\\.${i2[a2.PRERELEASEIDENTIFIER]})*))`), o2("PRERELEASELOOSE", `(?:-?(${i2[a2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[a2.PRERELEASEIDENTIFIERLOOSE]})*))`), o2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o2("BUILD", `(?:\\+(${i2[a2.BUILDIDENTIFIER]}(?:\\.${i2[a2.BUILDIDENTIFIER]})*))`), o2("FULLPLAIN", `v?${i2[a2.MAINVERSION]}${i2[a2.PRERELEASE]}?${i2[a2.BUILD]}?`), o2("FULL", `^${i2[a2.FULLPLAIN]}$`), o2("LOOSEPLAIN", `[v=\\s]*${i2[a2.MAINVERSIONLOOSE]}${i2[a2.PRERELEASELOOSE]}?${i2[a2.BUILD]}?`), o2("LOOSE", `^${i2[a2.LOOSEPLAIN]}$`), o2("GTLT", "((?:<|>)?=?)"), o2("XRANGEIDENTIFIERLOOSE", `${i2[a2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), o2("XRANGEIDENTIFIER", `${i2[a2.NUMERICIDENTIFIER]}|x|X|\\*`), o2("XRANGEPLAIN", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:${i2[a2.PRERELEASE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:${i2[a2.PRERELEASELOOSE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAIN]}$`), o2("XRANGELOOSE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COERCE", `(^|[^\\d])(\\d{1,${s2}})(?:\\.(\\d{1,${s2}}))?(?:\\.(\\d{1,${s2}}))?(?:$|[^\\d])`), o2("COERCERTL", i2[a2.COERCE], true), o2("LONETILDE", "(?:~>?)"), o2("TILDETRIM", `(\\s*)${i2[a2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", o2("TILDE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAIN]}$`), o2("TILDELOOSE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("LONECARET", "(?:\\^)"), o2("CARETTRIM", `(\\s*)${i2[a2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", o2("CARET", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAIN]}$`), o2("CARETLOOSE", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COMPARATORLOOSE", `^${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]})$|^$`), o2("COMPARATOR", `^${i2[a2.GTLT]}\\s*(${i2[a2.FULLPLAIN]})$|^$`), o2("COMPARATORTRIM", `(\\s*)${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]}|${i2[a2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", o2("HYPHENRANGE", `^\\s*(${i2[a2.XRANGEPLAIN]})\\s+-\\s+(${i2[a2.XRANGEPLAIN]})\\s*$`), o2("HYPHENRANGELOOSE", `^\\s*(${i2[a2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[a2.XRANGEPLAINLOOSE]})\\s*$`), o2("STAR", "(<|>)?=?\\s*\\*"), o2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });
  const ds$1 = ["includePrerelease", "loose", "rtl"];
  var Ds$1 = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : ds$1.filter((t2) => e2[t2]).reduce((e3, t2) => (e3[t2] = true, e3), {}) : {};
  const ms$1 = /^[0-9]+$/, fs$2 = (e2, t2) => {
    const s2 = ms$1.test(e2), r2 = ms$1.test(t2);
    return s2 && r2 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : e2 < t2 ? -1 : 1;
  };
  var ys$1 = { compareIdentifiers: fs$2, rcompareIdentifiers: (e2, t2) => fs$2(t2, e2) };
  const { MAX_LENGTH: As$1, MAX_SAFE_INTEGER: Es$1 } = ps$1, { re: Cs$1, t: xs$1 } = ls$1, { compareIdentifiers: Fs$1 } = ys$1;
  class gs$1 {
    constructor(e2, t2) {
      if (t2 = Ds$1(t2), e2 instanceof gs$1) {
        if (e2.loose === !!t2.loose && e2.includePrerelease === !!t2.includePrerelease)
          return e2;
        e2 = e2.version;
      } else if (typeof e2 != "string")
        throw new TypeError(`Invalid Version: ${e2}`);
      if (e2.length > As$1)
        throw new TypeError(`version is longer than ${As$1} characters`);
      cs$1("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
      const s2 = e2.trim().match(t2.loose ? Cs$1[xs$1.LOOSE] : Cs$1[xs$1.FULL]);
      if (!s2)
        throw new TypeError(`Invalid Version: ${e2}`);
      if (this.raw = e2, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > Es$1 || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > Es$1 || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > Es$1 || this.patch < 0)
        throw new TypeError("Invalid patch version");
      s2[4] ? this.prerelease = s2[4].split(".").map((e3) => {
        if (/^[0-9]+$/.test(e3)) {
          const t3 = +e3;
          if (t3 >= 0 && t3 < Es$1)
            return t3;
        }
        return e3;
      }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e2) {
      if (cs$1("SemVer.compare", this.version, this.options, e2), !(e2 instanceof gs$1)) {
        if (typeof e2 == "string" && e2 === this.version)
          return 0;
        e2 = new gs$1(e2, this.options);
      }
      return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
    }
    compareMain(e2) {
      return e2 instanceof gs$1 || (e2 = new gs$1(e2, this.options)), Fs$1(this.major, e2.major) || Fs$1(this.minor, e2.minor) || Fs$1(this.patch, e2.patch);
    }
    comparePre(e2) {
      if (e2 instanceof gs$1 || (e2 = new gs$1(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
        return -1;
      if (!this.prerelease.length && e2.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e2.prerelease.length)
        return 0;
      let t2 = 0;
      do {
        const s2 = this.prerelease[t2], r2 = e2.prerelease[t2];
        if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (s2 === void 0)
          return -1;
        if (s2 !== r2)
          return Fs$1(s2, r2);
      } while (++t2);
    }
    compareBuild(e2) {
      e2 instanceof gs$1 || (e2 = new gs$1(e2, this.options));
      let t2 = 0;
      do {
        const s2 = this.build[t2], r2 = e2.build[t2];
        if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (s2 === void 0)
          return -1;
        if (s2 !== r2)
          return Fs$1(s2, r2);
      } while (++t2);
    }
    inc(e2, t2) {
      switch (e2) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "major":
          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let e3 = this.prerelease.length;
            for (; --e3 >= 0; )
              typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
            e3 === -1 && this.prerelease.push(0);
          }
          t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${e2}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  var bs$1 = gs$1;
  var Ps$1 = (e2, t2, s2) => new bs$1(e2, s2).compare(new bs$1(t2, s2));
  var Ts$1 = (e2, t2, s2) => Ps$1(e2, t2, s2) < 0;
  var ws$1 = (e2, t2, s2) => Ps$1(e2, t2, s2) >= 0, Ss$1 = s$2(function(e2, t2) {
    function s2() {
      for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
        e3[t3] = arguments[t3];
    }
    function r2() {
      return typeof WeakMap != "undefined" ? new WeakMap() : { add: s2, delete: s2, get: s2, set: s2, has: function(e3) {
        return false;
      } };
    }
    Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
    var i2 = Object.prototype.hasOwnProperty, a2 = function(e3, t3) {
      return i2.call(e3, t3);
    };
    function n2(e3, t3) {
      for (var s3 in t3)
        a2(t3, s3) && (e3[s3] = t3[s3]);
      return e3;
    }
    var o2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, h2 = /^(?:[\r\n]|$)/, c2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function l2(e3, t3, s3) {
      var r3 = 0, i3 = e3[0].match(c2);
      i3 && (r3 = i3[1].length);
      var a3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
      t3 && (e3 = e3.slice(1));
      var n3 = s3.newline, h3 = s3.trimLeadingNewline, p3 = s3.trimTrailingNewline, l3 = typeof n3 == "string", d3 = e3.length;
      return e3.map(function(e4, t4) {
        return e4 = e4.replace(a3, "$1"), t4 === 0 && h3 && (e4 = e4.replace(o2, "")), t4 === d3 - 1 && p3 && (e4 = e4.replace(u2, "")), l3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
          return n3;
        })), e4;
      });
    }
    function d2(e3, t3) {
      for (var s3 = "", r3 = 0, i3 = e3.length; r3 < i3; r3++)
        s3 += e3[r3], r3 < i3 - 1 && (s3 += t3[r3]);
      return s3;
    }
    function D2(e3) {
      return a2(e3, "raw") && a2(e3, "length");
    }
    var m2 = function e3(t3) {
      var s3 = r2(), i3 = r2();
      return n2(function r3(a3) {
        for (var o3 = [], u3 = 1; u3 < arguments.length; u3++)
          o3[u3 - 1] = arguments[u3];
        if (D2(a3)) {
          var c3 = a3, f2 = (o3[0] === r3 || o3[0] === m2) && p2.test(c3[0]) && h2.test(c3[1]), y2 = f2 ? i3 : s3, A2 = y2.get(c3);
          if (A2 || (A2 = l2(c3, f2, t3), y2.set(c3, A2)), o3.length === 0)
            return A2[0];
          var E2 = d2(A2, f2 ? o3.slice(1) : o3);
          return E2;
        }
        return e3(n2(n2({}, t3), a3 || {}));
      }, { string: function(e4) {
        return l2([e4], false, t3)[0];
      } });
    }({ trimLeadingNewline: true, trimTrailingNewline: true });
    t2.outdent = m2, t2.default = m2;
    try {
      e2.exports = m2, Object.defineProperty(m2, "__esModule", { value: true }), m2.default = m2, m2.outdent = m2;
    } catch (e3) {
    }
  });
  const { outdent: Bs$1 } = Ss$1, Ns$1 = { cursorOffset: { since: "1.4.0", category: "Special", type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Bs$1`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor" }, endOfLine: { since: "1.15.0", category: "Global", type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Bs$1`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { since: "0.0.10", category: "Global", type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: Bs$1`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: "Config" }, printWidth: { since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Bs$1`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, rangeStart: { since: "1.4.0", category: "Special", type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Bs$1`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, requirePragma: { since: "1.7.0", category: "Special", type: "boolean", default: false, description: Bs$1`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: "Global", type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  const Is$2 = ["cliName", "cliCategory", "cliDescription"], vs$1 = { compare: Ps$1, lt: Ts$1, gte: ws$1 }, ks$1 = "2.4.1", Ls$1 = { CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: Ns$1 }.options;
  var Os$1 = { getSupportInfo: function({ plugins: e2 = [], showUnreleased: t2 = false, showDeprecated: s2 = false, showInternal: r2 = false } = {}) {
    const i2 = ks$1.split("-", 1)[0], a2 = e2.flatMap((e3) => e3.languages || []).filter(h2), n2 = (o2 = Object.assign({}, ...e2.map(({ options: e3 }) => e3), Ls$1), u2 = "name", Object.entries(o2).map(([e3, t3]) => Object.assign({ [u2]: e3 }, t3))).filter((e3) => h2(e3) && c2(e3)).sort((e3, t3) => e3.name === t3.name ? 0 : e3.name < t3.name ? -1 : 1).map(function(e3) {
      if (r2)
        return e3;
      return nt$2(e3, Is$2);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(h2).sort((e3, t4) => vs$1.compare(t4.since, e3.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e3) => h2(e3) && c2(e3)), t3.name === "parser" && function(e3, t4, s4) {
        const r3 = new Set(e3.choices.map((e4) => e4.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!r3.has(t5)) {
                r3.add(t5);
                const a3 = s4.find((e4) => e4.parsers && e4.parsers[t5]);
                let n3 = i3.name;
                a3 && a3.name && (n3 += ` (plugin: ${a3.name})`), e3.choices.push({ value: t5, description: n3 });
              }
          }
      }(t3, a2, e2));
      const s3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t3.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: s3 });
    });
    var o2, u2;
    return { languages: a2, options: n2 };
    function h2(e3) {
      return t2 || !("since" in e3) || e3.since && vs$1.gte(i2, e3.since);
    }
    function c2(e3) {
      return s2 || !("deprecated" in e3) || e3.deprecated && vs$1.lt(i2, e3.deprecated);
    }
  } };
  const { getSupportInfo: Ms$1 } = Os$1, Rs$1 = /[^\x20-\x7F]/;
  function js$1(e2) {
    return (t2, s2, r2) => {
      const i2 = r2 && r2.backwards;
      if (s2 === false)
        return false;
      const { length: a2 } = t2;
      let n2 = s2;
      for (; n2 >= 0 && n2 < a2; ) {
        const s3 = t2.charAt(n2);
        if (e2 instanceof RegExp) {
          if (!e2.test(s3))
            return n2;
        } else if (!e2.includes(s3))
          return n2;
        i2 ? n2-- : n2++;
      }
      return (n2 === -1 || n2 === a2) && n2;
    };
  }
  const _s$1 = js$1(/\s/), Us$1 = js$1(" 	"), qs$1 = js$1(",; 	"), $s$1 = js$1(/[^\n\r]/);
  function Hs$1(e2, t2) {
    if (t2 === false)
      return false;
    if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
      for (let s2 = t2 + 2; s2 < e2.length; ++s2)
        if (e2.charAt(s2) === "*" && e2.charAt(s2 + 1) === "/")
          return s2 + 2;
    }
    return t2;
  }
  function Vs$1(e2, t2) {
    return t2 !== false && (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? $s$1(e2, t2) : t2);
  }
  function zs$1(e2, t2, s2) {
    const r2 = s2 && s2.backwards;
    if (t2 === false)
      return false;
    const i2 = e2.charAt(t2);
    if (r2) {
      if (e2.charAt(t2 - 1) === "\r" && i2 === "\n")
        return t2 - 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 - 1;
    } else {
      if (i2 === "\r" && e2.charAt(t2 + 1) === "\n")
        return t2 + 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 + 1;
    }
    return t2;
  }
  function Ws$1(e2, t2, s2 = {}) {
    const r2 = Us$1(e2, s2.backwards ? t2 - 1 : t2, s2);
    return r2 !== zs$1(e2, r2, s2);
  }
  function Gs$1(e2, t2) {
    let s2 = null, r2 = t2;
    for (; r2 !== s2; )
      s2 = r2, r2 = qs$1(e2, r2), r2 = Hs$1(e2, r2), r2 = Us$1(e2, r2);
    return r2 = Vs$1(e2, r2), r2 = zs$1(e2, r2), r2 !== false && Ws$1(e2, r2);
  }
  function Ks$1(e2, t2) {
    let s2 = null, r2 = t2;
    for (; r2 !== s2; )
      s2 = r2, r2 = Us$1(e2, r2), r2 = Hs$1(e2, r2), r2 = Vs$1(e2, r2), r2 = zs$1(e2, r2);
    return r2;
  }
  function Xs$1(e2, t2, s2) {
    return Ks$1(e2, s2(t2));
  }
  function Js$1(e2, t2, s2 = 0) {
    let r2 = 0;
    for (let i2 = s2; i2 < e2.length; ++i2)
      e2[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
    return r2;
  }
  function Ys$1(e2, t2) {
    const s2 = e2.slice(1, -1), r2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, a2 = t2 === "'" ? i2 : r2, n2 = a2 === i2 ? r2 : i2;
    let o2 = a2.quote;
    if (s2.includes(a2.quote) || s2.includes(n2.quote)) {
      o2 = (s2.match(a2.regex) || []).length > (s2.match(n2.regex) || []).length ? n2.quote : a2.quote;
    }
    return o2;
  }
  function Qs$1(e2, t2, s2) {
    const r2 = t2 === '"' ? "'" : '"', i2 = e2.replace(/\\(.)|(["'])/gs, (e3, i3, a2) => i3 === r2 ? i3 : a2 === t2 ? "\\" + a2 : a2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
    return t2 + i2 + t2;
  }
  function Zs$1(e2, t2) {
    (e2.comments || (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e3) {
      const t3 = e3.type || e3.kind || "(unknown type)";
      let s2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
      s2.length > 20 && (s2 = s2.slice(0, 19) + "\u2026");
      return t3 + (s2 ? " " + s2 : "");
    }(e2);
  }
  var er$1, tr$1 = { inferParserByLanguage: function(e2, t2) {
    const { languages: s2 } = Ms$1({ plugins: t2.plugins }), r2 = s2.find(({ name: t3 }) => t3.toLowerCase() === e2) || s2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e2)) || s2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e2}`));
    return r2 && r2.parsers[0];
  }, getStringWidth: function(e2) {
    return e2 ? Rs$1.test(e2) ? st$2(e2) : e2.length : 0;
  }, getMaxContinuousCount: function(e2, t2) {
    const s2 = e2.match(new RegExp(`(${it$2(t2)})+`, "g"));
    return s2 === null ? 0 : s2.reduce((e3, s3) => Math.max(e3, s3.length / t2.length), 0);
  }, getMinNotPresentContinuousCount: function(e2, t2) {
    const s2 = e2.match(new RegExp(`(${it$2(t2)})+`, "g"));
    if (s2 === null)
      return 0;
    const r2 = new Map();
    let i2 = 0;
    for (const e3 of s2) {
      const s3 = e3.length / t2.length;
      r2.set(s3, true), s3 > i2 && (i2 = s3);
    }
    for (let e3 = 1; e3 < i2; e3++)
      if (!r2.get(e3))
        return e3;
    return i2 + 1;
  }, getPenultimate: (e2) => e2[e2.length - 2], getLast: at$2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ks$1, getNextNonSpaceNonCommentCharacterIndex: Xs$1, getNextNonSpaceNonCommentCharacter: function(e2, t2, s2) {
    return e2.charAt(Xs$1(e2, t2, s2));
  }, skip: js$1, skipWhitespace: _s$1, skipSpaces: Us$1, skipToLineEnd: qs$1, skipEverythingButNewLine: $s$1, skipInlineComment: Hs$1, skipTrailingComment: Vs$1, skipNewline: zs$1, isNextLineEmptyAfterIndex: Gs$1, isNextLineEmpty: function(e2, t2, s2) {
    return Gs$1(e2, s2(t2));
  }, isPreviousLineEmpty: function(e2, t2, s2) {
    let r2 = s2(t2) - 1;
    return r2 = Us$1(e2, r2, { backwards: true }), r2 = zs$1(e2, r2, { backwards: true }), r2 = Us$1(e2, r2, { backwards: true }), r2 !== zs$1(e2, r2, { backwards: true });
  }, hasNewline: Ws$1, hasNewlineInRange: function(e2, t2, s2) {
    for (let r2 = t2; r2 < s2; ++r2)
      if (e2.charAt(r2) === "\n")
        return true;
    return false;
  }, hasSpaces: function(e2, t2, s2 = {}) {
    return Us$1(e2, s2.backwards ? t2 - 1 : t2, s2) !== t2;
  }, getAlignmentSize: Js$1, getIndentSize: function(e2, t2) {
    const s2 = e2.lastIndexOf("\n");
    return s2 === -1 ? 0 : Js$1(e2.slice(s2 + 1).match(/^[\t ]*/)[0], t2);
  }, getPreferredQuote: Ys$1, printString: function(e2, t2) {
    return Qs$1(e2.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Ys$1(e2, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  }, printNumber: function(e2) {
    return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }, makeString: Qs$1, addLeadingComment: function(e2, t2) {
    t2.leading = true, t2.trailing = false, Zs$1(e2, t2);
  }, addDanglingComment: function(e2, t2, s2) {
    t2.leading = false, t2.trailing = false, s2 && (t2.marker = s2), Zs$1(e2, t2);
  }, addTrailingComment: function(e2, t2) {
    t2.leading = false, t2.trailing = true, Zs$1(e2, t2);
  }, isFrontMatterNode: function(e2) {
    return e2 && e2.type === "front-matter";
  }, getShebang: function(e2) {
    if (!e2.startsWith("#!"))
      return "";
    const t2 = e2.indexOf("\n");
    return t2 === -1 ? e2 : e2.slice(0, t2);
  }, isNonEmptyArray: function(e2) {
    return Array.isArray(e2) && e2.length > 0;
  }, createGroupIdMapper: function(e2) {
    const t2 = new WeakMap();
    return function(s2) {
      return t2.has(s2) || t2.set(s2, Symbol(e2)), t2.get(s2);
    };
  } };
  function sr$1() {
    if (er$1 === void 0) {
      var e2 = new ArrayBuffer(2), t2 = new Uint8Array(e2), s2 = new Uint16Array(e2);
      if (t2[0] = 1, t2[1] = 2, s2[0] === 258)
        er$1 = "BE";
      else {
        if (s2[0] !== 513)
          throw new Error("unable to figure out endianess");
        er$1 = "LE";
      }
    }
    return er$1;
  }
  function rr$1() {
    return _t$1.location !== void 0 ? _t$1.location.hostname : "";
  }
  function ir$1() {
    return [];
  }
  function ar$1() {
    return 0;
  }
  function nr$1() {
    return Number.MAX_VALUE;
  }
  function or$1() {
    return Number.MAX_VALUE;
  }
  function ur$1() {
    return [];
  }
  function hr$1() {
    return "Browser";
  }
  function cr$1() {
    return _t$1.navigator !== void 0 ? _t$1.navigator.appVersion : "";
  }
  function pr$1() {
  }
  function lr$1() {
  }
  function dr$1() {
    return "javascript";
  }
  function Dr$1() {
    return "browser";
  }
  function mr$1() {
    return "/tmp";
  }
  var fr$1 = mr$1, yr$1 = { EOL: "\n", arch: dr$1, platform: Dr$1, tmpdir: fr$1, tmpDir: mr$1, networkInterfaces: pr$1, getNetworkInterfaces: lr$1, release: cr$1, type: hr$1, cpus: ur$1, totalmem: or$1, freemem: nr$1, uptime: ar$1, loadavg: ir$1, hostname: rr$1, endianness: sr$1 }, Ar$1 = Object.freeze({ __proto__: null, endianness: sr$1, hostname: rr$1, loadavg: ir$1, uptime: ar$1, freemem: nr$1, totalmem: or$1, cpus: ur$1, type: hr$1, release: cr$1, networkInterfaces: pr$1, getNetworkInterfaces: lr$1, arch: dr$1, platform: Dr$1, tmpDir: mr$1, tmpdir: fr$1, EOL: "\n", default: yr$1 });
  const Er$1 = (e2) => {
    if (typeof e2 != "string")
      throw new TypeError("Expected a string");
    const t2 = e2.match(/(?:\r?\n)/g) || [];
    if (t2.length === 0)
      return;
    const s2 = t2.filter((e3) => e3 === "\r\n").length;
    return s2 > t2.length - s2 ? "\r\n" : "\n";
  };
  var Cr$1 = Er$1;
  Cr$1.graceful = (e2) => typeof e2 == "string" && Er$1(e2) || "\n";
  var xr$1 = t$2(Ar$1), Fr$1 = function(e2) {
    const t2 = e2.match(Ir$1);
    return t2 ? t2[0].trimLeft() : "";
  }, gr$1 = function(e2) {
    const t2 = e2.match(Ir$1);
    return t2 && t2[0] ? e2.substring(t2[0].length) : e2;
  }, br$1 = function(e2) {
    return jr$1(e2).pragmas;
  }, Pr$1 = jr$1, Tr$1 = function({ comments: e2 = "", pragmas: t2 = {} }) {
    const s2 = (0, Sr$1().default)(e2) || wr$1().EOL, r2 = " *", i2 = Object.keys(t2), a2 = i2.map((e3) => _r$1(e3, t2[e3])).reduce((e3, t3) => e3.concat(t3), []).map((e3) => " * " + e3 + s2).join("");
    if (!e2) {
      if (i2.length === 0)
        return "";
      if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
        const e3 = t2[i2[0]];
        return `/** ${_r$1(i2[0], e3)[0]} */`;
      }
    }
    const n2 = e2.split(s2).map((e3) => ` * ${e3}`).join(s2) + s2;
    return "/**" + s2 + (e2 ? n2 : "") + (e2 && i2.length ? r2 + s2 : "") + a2 + " */";
  };
  function wr$1() {
    const e2 = xr$1;
    return wr$1 = function() {
      return e2;
    }, e2;
  }
  function Sr$1() {
    const e2 = (t2 = Cr$1) && t2.__esModule ? t2 : { default: t2 };
    var t2;
    return Sr$1 = function() {
      return e2;
    }, e2;
  }
  const Br$1 = /\*\/$/, Nr$1 = /^\/\*\*/, Ir$1 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, vr$1 = /(^|\s+)\/\/([^\r\n]*)/g, kr$1 = /^(\r?\n)+/, Lr$1 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Or$1 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Mr$1 = /(\r?\n|^) *\* ?/g, Rr$1 = [];
  function jr$1(e2) {
    const t2 = (0, Sr$1().default)(e2) || wr$1().EOL;
    e2 = e2.replace(Nr$1, "").replace(Br$1, "").replace(Mr$1, "$1");
    let s2 = "";
    for (; s2 !== e2; )
      s2 = e2, e2 = e2.replace(Lr$1, `${t2}$1 $2${t2}`);
    e2 = e2.replace(kr$1, "").trimRight();
    const r2 = Object.create(null), i2 = e2.replace(Or$1, "").replace(kr$1, "").trimRight();
    let a2;
    for (; a2 = Or$1.exec(e2); ) {
      const e3 = a2[2].replace(vr$1, "");
      typeof r2[a2[1]] == "string" || Array.isArray(r2[a2[1]]) ? r2[a2[1]] = Rr$1.concat(r2[a2[1]], e3) : r2[a2[1]] = e3;
    }
    return { comments: i2, pragmas: r2 };
  }
  function _r$1(e2, t2) {
    return Rr$1.concat(t2).map((t3) => `@${e2} ${t3}`.trim());
  }
  var Ur$1 = Object.defineProperty({ extract: Fr$1, strip: gr$1, parse: br$1, parseWithComments: Pr$1, print: Tr$1 }, "__esModule", { value: true });
  var qr$1 = { guessEndOfLine: function(e2) {
    const t2 = e2.indexOf("\r");
    return t2 >= 0 ? e2.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  }, convertEndOfLineToChars: function(e2) {
    switch (e2) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  }, countEndOfLineChars: function(e2, t2) {
    let s2;
    if (t2 === "\n")
      s2 = /\n/g;
    else if (t2 === "\r")
      s2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      s2 = /\r\n/g;
    }
    const r2 = e2.match(s2);
    return r2 ? r2.length : 0;
  }, normalizeEndOfLine: function(e2) {
    return e2.replace(/\r\n?/g, "\n");
  } };
  const { parseWithComments: $r$1, strip: Hr$1, extract: Vr$1, print: zr$1 } = Ur$1, { getShebang: Wr$1 } = tr$1, { normalizeEndOfLine: Gr$1 } = qr$1;
  function Kr$1(e2) {
    const t2 = Wr$1(e2);
    t2 && (e2 = e2.slice(t2.length + 1));
    const s2 = Vr$1(e2), { pragmas: r2, comments: i2 } = $r$1(s2);
    return { shebang: t2, text: e2, pragmas: r2, comments: i2 };
  }
  var Xr$1 = { hasPragma: function(e2) {
    const t2 = Object.keys(Kr$1(e2).pragmas);
    return t2.includes("prettier") || t2.includes("format");
  }, insertPragma: function(e2) {
    const { shebang: t2, text: s2, pragmas: r2, comments: i2 } = Kr$1(e2), a2 = Hr$1(s2), n2 = zr$1({ pragmas: Object.assign({ format: "" }, r2), comments: i2.trimStart() });
    return (t2 ? `${t2}
` : "") + Gr$1(n2) + (a2.startsWith("\n") ? "\n" : "\n\n") + a2;
  } };
  const { isNonEmptyArray: Jr$1 } = tr$1;
  function Yr$1(e2, t2) {
    const { ignoreDecorators: s2 } = t2 || {};
    if (!s2) {
      const t3 = e2.declaration && e2.declaration.decorators || e2.decorators;
      if (Jr$1(t3))
        return Yr$1(t3[0]);
    }
    return e2.range ? e2.range[0] : e2.start;
  }
  function Qr$1(e2) {
    return e2.range ? e2.range[1] : e2.end;
  }
  function Zr$1(e2, t2) {
    return Yr$1(e2) === Yr$1(t2);
  }
  var ei$1 = { locStart: Yr$1, locEnd: Qr$1, hasSameLocStart: Zr$1, hasSameLoc: function(e2, t2) {
    return Zr$1(e2, t2) && function(e3, t3) {
      return Qr$1(e3) === Qr$1(t3);
    }(e2, t2);
  } };
  const { hasPragma: ti$1 } = Xr$1, { locStart: si$1, locEnd: ri$1 } = ei$1;
  var ii$1 = function(e2) {
    return e2 = typeof e2 == "function" ? { parse: e2 } : e2, Object.assign({ astFormat: "estree", hasPragma: ti$1, locStart: si$1, locEnd: ri$1 }, e2);
  };
  var ai$1 = function(e2, t2) {
    const s2 = new SyntaxError(e2 + " (" + t2.start.line + ":" + t2.start.column + ")");
    return s2.loc = t2, s2;
  };
  var ni$1 = function(e2) {
    const { message: t2, loc: s2 } = e2;
    return ai$1(t2.replace(/ \(.*\)/, ""), { start: { line: s2 ? s2.line : 0, column: s2 ? s2.column + 1 : 0 } });
  }, oi$1 = s$2(function(e2) {
    !function() {
      function t2(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function s2(e3) {
        switch (e3.type) {
          case "IfStatement":
            return e3.alternate != null ? e3.alternate : e3.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return e3.body;
        }
        return null;
      }
      e2.exports = { isExpression: function(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }, isStatement: t2, isIterationStatement: function(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }, isSourceElement: function(e3) {
        return t2(e3) || e3 != null && e3.type === "FunctionDeclaration";
      }, isProblematicIfStatement: function(e3) {
        var t3;
        if (e3.type !== "IfStatement")
          return false;
        if (e3.alternate == null)
          return false;
        t3 = e3.consequent;
        do {
          if (t3.type === "IfStatement" && t3.alternate == null)
            return true;
          t3 = s2(t3);
        } while (t3);
        return false;
      }, trailingStatement: s2 };
    }();
  }), ui$1 = s$2(function(e2) {
    !function() {
      var t2, s2, r2, i2, a2, n2;
      function o2(e3) {
        return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode(Math.floor((e3 - 65536) / 1024) + 55296) + String.fromCharCode((e3 - 65536) % 1024 + 56320);
      }
      for (s2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), n2 = 0; n2 < 128; ++n2)
        i2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 === 36 || n2 === 95;
      for (a2 = new Array(128), n2 = 0; n2 < 128; ++n2)
        a2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 >= 48 && n2 <= 57 || n2 === 36 || n2 === 95;
      e2.exports = { isDecimalDigit: function(e3) {
        return 48 <= e3 && e3 <= 57;
      }, isHexDigit: function(e3) {
        return 48 <= e3 && e3 <= 57 || 97 <= e3 && e3 <= 102 || 65 <= e3 && e3 <= 70;
      }, isOctalDigit: function(e3) {
        return e3 >= 48 && e3 <= 55;
      }, isWhiteSpace: function(e3) {
        return e3 === 32 || e3 === 9 || e3 === 11 || e3 === 12 || e3 === 160 || e3 >= 5760 && r2.indexOf(e3) >= 0;
      }, isLineTerminator: function(e3) {
        return e3 === 10 || e3 === 13 || e3 === 8232 || e3 === 8233;
      }, isIdentifierStartES5: function(e3) {
        return e3 < 128 ? i2[e3] : s2.NonAsciiIdentifierStart.test(o2(e3));
      }, isIdentifierPartES5: function(e3) {
        return e3 < 128 ? a2[e3] : s2.NonAsciiIdentifierPart.test(o2(e3));
      }, isIdentifierStartES6: function(e3) {
        return e3 < 128 ? i2[e3] : t2.NonAsciiIdentifierStart.test(o2(e3));
      }, isIdentifierPartES6: function(e3) {
        return e3 < 128 ? a2[e3] : t2.NonAsciiIdentifierPart.test(o2(e3));
      } };
    }();
  }), hi$1 = s$2(function(e2) {
    !function() {
      var t2 = ui$1;
      function s2(e3, t3) {
        return !(!t3 && e3 === "yield") && r2(e3, t3);
      }
      function r2(e3, t3) {
        if (t3 && function(e4) {
          switch (e4) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "let":
              return true;
            default:
              return false;
          }
        }(e3))
          return true;
        switch (e3.length) {
          case 2:
            return e3 === "if" || e3 === "in" || e3 === "do";
          case 3:
            return e3 === "var" || e3 === "for" || e3 === "new" || e3 === "try";
          case 4:
            return e3 === "this" || e3 === "else" || e3 === "case" || e3 === "void" || e3 === "with" || e3 === "enum";
          case 5:
            return e3 === "while" || e3 === "break" || e3 === "catch" || e3 === "throw" || e3 === "const" || e3 === "yield" || e3 === "class" || e3 === "super";
          case 6:
            return e3 === "return" || e3 === "typeof" || e3 === "delete" || e3 === "switch" || e3 === "export" || e3 === "import";
          case 7:
            return e3 === "default" || e3 === "finally" || e3 === "extends";
          case 8:
            return e3 === "function" || e3 === "continue" || e3 === "debugger";
          case 10:
            return e3 === "instanceof";
          default:
            return false;
        }
      }
      function i2(e3, t3) {
        return e3 === "null" || e3 === "true" || e3 === "false" || s2(e3, t3);
      }
      function a2(e3, t3) {
        return e3 === "null" || e3 === "true" || e3 === "false" || r2(e3, t3);
      }
      function n2(e3) {
        var s3, r3, i3;
        if (e3.length === 0)
          return false;
        if (i3 = e3.charCodeAt(0), !t2.isIdentifierStartES5(i3))
          return false;
        for (s3 = 1, r3 = e3.length; s3 < r3; ++s3)
          if (i3 = e3.charCodeAt(s3), !t2.isIdentifierPartES5(i3))
            return false;
        return true;
      }
      function o2(e3) {
        var s3, r3, i3, a3, n3;
        if (e3.length === 0)
          return false;
        for (n3 = t2.isIdentifierStartES6, s3 = 0, r3 = e3.length; s3 < r3; ++s3) {
          if (55296 <= (i3 = e3.charCodeAt(s3)) && i3 <= 56319) {
            if (++s3 >= r3)
              return false;
            if (!(56320 <= (a3 = e3.charCodeAt(s3)) && a3 <= 57343))
              return false;
            i3 = 1024 * (i3 - 55296) + (a3 - 56320) + 65536;
          }
          if (!n3(i3))
            return false;
          n3 = t2.isIdentifierPartES6;
        }
        return true;
      }
      e2.exports = { isKeywordES5: s2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: a2, isRestrictedWord: function(e3) {
        return e3 === "eval" || e3 === "arguments";
      }, isIdentifierNameES5: n2, isIdentifierNameES6: o2, isIdentifierES5: function(e3, t3) {
        return n2(e3) && !i2(e3, t3);
      }, isIdentifierES6: function(e3, t3) {
        return o2(e3) && !a2(e3, t3);
      } };
    }();
  });
  const ci$1 = s$2(function(e2, t2) {
    t2.ast = oi$1, t2.code = ui$1, t2.keyword = hi$1;
  }).keyword.isIdentifierNameES5, { getLast: pi$1, hasNewline: li$1, skipWhitespace: di$1, isNonEmptyArray: Di$1, isNextLineEmptyAfterIndex: mi$1, getStringWidth: fi$1 } = tr$1, { locStart: yi$1, locEnd: Ai$1, hasSameLocStart: Ei$1 } = ei$1, Ci$1 = new RegExp("^(?:(?=.)\\s)*:"), xi$1 = new RegExp("^(?:(?=.)\\s)*::");
  function Fi$1(e2) {
    return e2.type === "Block" || e2.type === "CommentBlock" || e2.type === "MultiLine";
  }
  function gi$1(e2) {
    return e2.type === "Line" || e2.type === "CommentLine" || e2.type === "SingleLine" || e2.type === "HashbangComment" || e2.type === "HTMLOpen" || e2.type === "HTMLClose";
  }
  const bi$1 = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
  function Pi$1(e2) {
    return e2 && bi$1.has(e2.type);
  }
  function Ti$1(e2) {
    return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
  }
  function wi$1(e2) {
    return e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string";
  }
  function Si$1(e2) {
    return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression";
  }
  function Bi$1(e2) {
    return Mi$1(e2) && e2.callee.type === "Identifier" && (e2.callee.name === "async" || e2.callee.name === "inject" || e2.callee.name === "fakeAsync");
  }
  function Ni$1(e2) {
    return e2.type === "JSXElement" || e2.type === "JSXFragment";
  }
  function Ii$1(e2) {
    return e2.kind === "get" || e2.kind === "set";
  }
  function vi$1(e2) {
    return Ii$1(e2) || Ei$1(e2, e2.value);
  }
  const ki$1 = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
  const Li$1 = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
  const Oi$1 = /^(?:skip|[fx]?(?:it|describe|test))$/;
  function Mi$1(e2) {
    return e2 && (e2.type === "CallExpression" || e2.type === "OptionalCallExpression");
  }
  function Ri$1(e2) {
    return e2 && (e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression");
  }
  function ji$1(e2) {
    return /^(?:\d+|\d+\.\d+)$/.test(e2);
  }
  function _i$1(e2) {
    return e2.quasis.some((e3) => e3.value.raw.includes("\n"));
  }
  function Ui$1(e2) {
    return e2.extra ? e2.extra.raw : e2.raw;
  }
  const qi$1 = { "==": true, "!=": true, "===": true, "!==": true }, $i$1 = { "*": true, "/": true, "%": true }, Hi$1 = { ">>": true, ">>>": true, "<<": true };
  const Vi$1 = {};
  for (const [e2, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
    for (const s2 of t2)
      Vi$1[s2] = e2;
  function zi$1(e2) {
    return Vi$1[e2];
  }
  const Wi$1 = new WeakMap();
  function Gi$1(e2) {
    if (Wi$1.has(e2))
      return Wi$1.get(e2);
    const t2 = [];
    return e2.this && t2.push(e2.this), Array.isArray(e2.parameters) ? t2.push(...e2.parameters) : Array.isArray(e2.params) && t2.push(...e2.params), e2.rest && t2.push(e2.rest), Wi$1.set(e2, t2), t2;
  }
  const Ki$1 = new WeakMap();
  function Xi$1(e2) {
    if (Ki$1.has(e2))
      return Ki$1.get(e2);
    let t2 = e2.arguments;
    return e2.type === "ImportExpression" && (t2 = [e2.source], e2.attributes && t2.push(e2.attributes)), Ki$1.set(e2, t2), t2;
  }
  function Ji$1(e2) {
    return e2.value.trim() === "prettier-ignore" && !e2.unignore;
  }
  function Yi$1(e2) {
    return e2 && (e2.prettierIgnore || ea(e2, Qi$1.PrettierIgnore));
  }
  const Qi$1 = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Zi$1 = (e2, t2) => {
    if (typeof e2 == "function" && (t2 = e2, e2 = 0), e2 || t2)
      return (s2, r2, i2) => !(e2 & Qi$1.Leading && !s2.leading || e2 & Qi$1.Trailing && !s2.trailing || e2 & Qi$1.Dangling && (s2.leading || s2.trailing) || e2 & Qi$1.Block && !Fi$1(s2) || e2 & Qi$1.Line && !gi$1(s2) || e2 & Qi$1.First && r2 !== 0 || e2 & Qi$1.Last && r2 !== i2.length - 1 || e2 & Qi$1.PrettierIgnore && !Ji$1(s2) || t2 && !t2(s2));
  };
  function ea(e2, t2, s2) {
    if (!e2 || !Di$1(e2.comments))
      return false;
    const r2 = Zi$1(t2, s2);
    return !r2 || e2.comments.some(r2);
  }
  function ta(e2, t2, s2) {
    if (!e2 || !Array.isArray(e2.comments))
      return [];
    const r2 = Zi$1(t2, s2);
    return r2 ? e2.comments.filter(r2) : e2.comments;
  }
  function sa(e2) {
    return Mi$1(e2) || e2.type === "NewExpression" || e2.type === "ImportExpression";
  }
  var ra = { getFunctionParameters: Gi$1, iterateFunctionParametersPath: function(e2, t2) {
    const s2 = e2.getValue();
    let r2 = 0;
    const i2 = (e3) => t2(e3, r2++);
    s2.this && e2.call(i2, "this"), Array.isArray(s2.parameters) ? e2.each(i2, "parameters") : Array.isArray(s2.params) && e2.each(i2, "params"), s2.rest && e2.call(i2, "rest");
  }, getCallArguments: Xi$1, iterateCallArgumentsPath: function(e2, t2) {
    const s2 = e2.getValue();
    s2.type === "ImportExpression" ? (e2.call((e3) => t2(e3, 0), "source"), s2.attributes && e2.call((e3) => t2(e3, 1), "attributes")) : e2.each(t2, "arguments");
  }, hasRestParameter: function(e2) {
    if (e2.rest)
      return true;
    const t2 = Gi$1(e2);
    return t2.length > 0 && pi$1(t2).type === "RestElement";
  }, getLeftSide: function(e2) {
    return e2.expressions ? e2.expressions[0] : e2.left || e2.test || e2.callee || e2.object || e2.tag || e2.argument || e2.expression;
  }, getLeftSidePathName: function(e2, t2) {
    if (t2.expressions)
      return ["expressions", 0];
    if (t2.left)
      return ["left"];
    if (t2.test)
      return ["test"];
    if (t2.object)
      return ["object"];
    if (t2.callee)
      return ["callee"];
    if (t2.tag)
      return ["tag"];
    if (t2.argument)
      return ["argument"];
    if (t2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  }, getParentExportDeclaration: function(e2) {
    const t2 = e2.getParentNode();
    return e2.getName() === "declaration" && Pi$1(t2) ? t2 : null;
  }, getTypeScriptMappedTypeModifier: function(e2, t2) {
    return e2 === "+" ? "+" + t2 : e2 === "-" ? "-" + t2 : t2;
  }, hasFlowAnnotationComment: function(e2) {
    return Di$1(e2) && Fi$1(e2[0]) && xi$1.test(e2[0].value);
  }, hasFlowShorthandAnnotationComment: function(e2) {
    return e2.extra && e2.extra.parenthesized && Di$1(e2.trailingComments) && Fi$1(e2.trailingComments[0]) && Ci$1.test(e2.trailingComments[0].value);
  }, hasLeadingOwnLineComment: function(e2, t2) {
    return Ni$1(t2) ? Yi$1(t2) : ea(t2, Qi$1.Leading, (t3) => li$1(e2, Ai$1(t3)));
  }, hasNakedLeftSide: function(e2) {
    return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || Mi$1(e2) || Ri$1(e2) || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || e2.type === "TSAsExpression" || e2.type === "TSNonNullExpression";
  }, hasNode: function e2(t2, s2) {
    if (!t2 || typeof t2 != "object")
      return false;
    if (Array.isArray(t2))
      return t2.some((t3) => e2(t3, s2));
    const r2 = s2(t2);
    return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e2(t3, s2));
  }, hasIgnoreComment: function(e2) {
    return Yi$1(e2.getValue());
  }, hasNodeIgnoreComment: Yi$1, identity: function(e2) {
    return e2;
  }, isBinaryish: function(e2) {
    return ki$1.has(e2.type);
  }, isBlockComment: Fi$1, isCallLikeExpression: sa, isLineComment: gi$1, isPrettierIgnoreComment: Ji$1, isCallExpression: Mi$1, isMemberExpression: Ri$1, isExportDeclaration: Pi$1, isFlowAnnotationComment: function(e2, t2) {
    const s2 = yi$1(t2), r2 = di$1(e2, Ai$1(t2));
    return r2 !== false && e2.slice(s2, s2 + 2) === "/*" && e2.slice(r2, r2 + 2) === "*/";
  }, isFunctionCompositionArgs: function(e2) {
    if (e2.length <= 1)
      return false;
    let t2 = 0;
    for (const s2 of e2)
      if (Si$1(s2)) {
        if (t2 += 1, t2 > 1)
          return true;
      } else if (Mi$1(s2)) {
        for (const e3 of s2.arguments)
          if (Si$1(e3))
            return true;
      }
    return false;
  }, isFunctionNotation: vi$1, isFunctionOrArrowExpression: Si$1, isGetterOrSetter: Ii$1, isJestEachTemplateLiteral: function(e2, t2) {
    const s2 = /^[fx]?(?:describe|it|test)$/;
    return t2.type === "TaggedTemplateExpression" && t2.quasi === e2 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && s2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && s2.test(t2.tag.object.object.name));
  }, isJsxNode: Ni$1, isLiteral: function(e2) {
    return e2.type === "BooleanLiteral" || e2.type === "DirectiveLiteral" || e2.type === "Literal" || e2.type === "NullLiteral" || e2.type === "NumericLiteral" || e2.type === "BigIntLiteral" || e2.type === "DecimalLiteral" || e2.type === "RegExpLiteral" || e2.type === "StringLiteral" || e2.type === "TemplateLiteral" || e2.type === "TSTypeLiteral" || e2.type === "JSXText";
  }, isLongCurriedCallExpression: function(e2) {
    const t2 = e2.getValue(), s2 = e2.getParentNode();
    return Mi$1(t2) && Mi$1(s2) && s2.callee === t2 && t2.arguments.length > s2.arguments.length && s2.arguments.length > 0;
  }, isSimpleCallArgument: function e2(t2, s2) {
    if (s2 >= 2)
      return false;
    const r2 = (t3) => e2(t3, s2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
    return !(i2 && fi$1(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e3) => !e3.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e3) => !e3.computed && (e3.shorthand || e3.value && r2(e3.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e3) => e3 === null || r2(e3)) : sa(t2) ? (t2.type === "ImportExpression" || e2(t2.callee, s2)) && Xi$1(t2).every(r2) : Ri$1(t2) ? e2(t2.object, s2) && e2(t2.property, s2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e2(t2.expression, s2) : e2(t2.argument, s2)));
  }, isMemberish: function(e2) {
    return Ri$1(e2) || e2.type === "BindExpression" && Boolean(e2.object);
  }, isNumericLiteral: Ti$1, isSignedNumericLiteral: function(e2) {
    return e2.type === "UnaryExpression" && (e2.operator === "+" || e2.operator === "-") && Ti$1(e2.argument);
  }, isObjectProperty: function(e2) {
    return e2 && (e2.type === "ObjectProperty" || e2.type === "Property" && !e2.method && e2.kind === "init");
  }, isObjectType: function(e2) {
    return e2.type === "ObjectTypeAnnotation" || e2.type === "TSTypeLiteral" || e2.type === "TSMappedType";
  }, isObjectTypePropertyAFunction: function(e2) {
    return !(e2.type !== "ObjectTypeProperty" && e2.type !== "ObjectTypeInternalSlot" || e2.value.type !== "FunctionTypeAnnotation" || e2.static || vi$1(e2));
  }, isSimpleType: function(e2) {
    return !!e2 && (!(e2.type !== "GenericTypeAnnotation" && e2.type !== "TSTypeReference" || e2.typeParameters) || !!Li$1.has(e2.type));
  }, isSimpleNumber: ji$1, isSimpleTemplateLiteral: function(e2) {
    let t2 = "expressions";
    e2.type === "TSTemplateLiteralType" && (t2 = "types");
    const s2 = e2[t2];
    return s2.length !== 0 && s2.every((e3) => {
      if (ea(e3))
        return false;
      if (e3.type === "Identifier" || e3.type === "ThisExpression")
        return true;
      if (Ri$1(e3)) {
        let t3 = e3;
        for (; Ri$1(t3); ) {
          if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
            return false;
          if (t3 = t3.object, ea(t3))
            return false;
        }
        return t3.type === "Identifier" || t3.type === "ThisExpression";
      }
      return false;
    });
  }, isStringLiteral: wi$1, isStringPropSafeToUnquote: function(e2, t2) {
    return t2.parser !== "json" && wi$1(e2.key) && Ui$1(e2.key).slice(1, -1) === e2.key.value && (ci$1(e2.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e2.type === "ClassProperty") || ji$1(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
  }, isTemplateOnItsOwnLine: function(e2, t2) {
    return (e2.type === "TemplateLiteral" && _i$1(e2) || e2.type === "TaggedTemplateExpression" && _i$1(e2.quasi)) && !li$1(t2, yi$1(e2), { backwards: true });
  }, isTestCall: function e2(t2, s2) {
    if (t2.type !== "CallExpression")
      return false;
    if (t2.arguments.length === 1) {
      if (Bi$1(t2) && s2 && e2(s2))
        return Si$1(t2.arguments[0]);
      if (function(e3) {
        return e3.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e3.callee.name) && e3.arguments.length === 1;
      }(t2))
        return Bi$1(t2.arguments[0]);
    } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Oi$1.test(t2.callee.name) || function(e3) {
      return Ri$1(e3.callee) && e3.callee.object.type === "Identifier" && e3.callee.property.type === "Identifier" && Oi$1.test(e3.callee.object.name) && (e3.callee.property.name === "only" || e3.callee.property.name === "skip");
    }(t2)) && (function(e3) {
      return e3.type === "TemplateLiteral";
    }(t2.arguments[0]) || wi$1(t2.arguments[0])))
      return !(t2.arguments[2] && !Ti$1(t2.arguments[2])) && ((t2.arguments.length === 2 ? Si$1(t2.arguments[1]) : function(e3) {
        return e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression" && e3.body.type === "BlockStatement";
      }(t2.arguments[1]) && Gi$1(t2.arguments[1]).length <= 1) || Bi$1(t2.arguments[1]));
    return false;
  }, isTheOnlyJsxElementInMarkdown: function(e2, t2) {
    if (e2.parentParser !== "markdown" && e2.parentParser !== "mdx")
      return false;
    const s2 = t2.getNode();
    if (!s2.expression || !Ni$1(s2.expression))
      return false;
    const r2 = t2.getParentNode();
    return r2.type === "Program" && r2.body.length === 1;
  }, isTSXFile: function(e2) {
    return e2.filepath && /\.tsx$/i.test(e2.filepath);
  }, isTypeAnnotationAFunction: function(e2) {
    return !(e2.type !== "TypeAnnotation" && e2.type !== "TSTypeAnnotation" || e2.typeAnnotation.type !== "FunctionTypeAnnotation" || e2.static || Ei$1(e2, e2.typeAnnotation));
  }, isNextLineEmpty: (e2, { originalText: t2 }) => mi$1(t2, Ai$1(e2)), needsHardlineAfterDanglingComment: function(e2) {
    if (!ea(e2))
      return false;
    const t2 = pi$1(ta(e2, Qi$1.Dangling));
    return t2 && !Fi$1(t2);
  }, rawText: Ui$1, shouldPrintComma: function(e2, t2 = "es5") {
    return e2.trailingComma === "es5" && t2 === "es5" || e2.trailingComma === "all" && (t2 === "all" || t2 === "es5");
  }, isBitwiseOperator: function(e2) {
    return Boolean(Hi$1[e2]) || e2 === "|" || e2 === "^" || e2 === "&";
  }, shouldFlatten: function(e2, t2) {
    return zi$1(t2) === zi$1(e2) && (e2 !== "**" && ((!qi$1[e2] || !qi$1[t2]) && (!(t2 === "%" && $i$1[e2] || e2 === "%" && $i$1[t2]) && ((t2 === e2 || !$i$1[t2] || !$i$1[e2]) && (!Hi$1[e2] || !Hi$1[t2])))));
  }, startsWithNoLookaheadToken: function e2(t2, s2) {
    switch ((t2 = function(e3) {
      for (; e3.left; )
        e3 = e3.left;
      return e3;
    }(t2)).type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return s2;
      case "ObjectExpression":
        return true;
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e2(t2.object, s2);
      case "TaggedTemplateExpression":
        return t2.tag.type !== "FunctionExpression" && e2(t2.tag, s2);
      case "CallExpression":
      case "OptionalCallExpression":
        return t2.callee.type !== "FunctionExpression" && e2(t2.callee, s2);
      case "ConditionalExpression":
        return e2(t2.test, s2);
      case "UpdateExpression":
        return !t2.prefix && e2(t2.argument, s2);
      case "BindExpression":
        return t2.object && e2(t2.object, s2);
      case "SequenceExpression":
        return e2(t2.expressions[0], s2);
      case "TSAsExpression":
      case "TSNonNullExpression":
        return e2(t2.expression, s2);
      default:
        return false;
    }
  }, getPrecedence: zi$1, hasComment: ea, getComments: ta, CommentCheckFlags: Qi$1 };
  const { getLast: ia, hasNewline: aa, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: na, getNextNonSpaceNonCommentCharacter: oa, hasNewlineInRange: ua, addLeadingComment: ha, addTrailingComment: ca, addDanglingComment: pa, getNextNonSpaceNonCommentCharacterIndex: la, isNonEmptyArray: da } = tr$1, { isBlockComment: Da, getFunctionParameters: ma, isPrettierIgnoreComment: fa, isJsxNode: ya, hasFlowShorthandAnnotationComment: Aa, hasFlowAnnotationComment: Ea, hasIgnoreComment: Ca, isCallLikeExpression: xa, getCallArguments: Fa, isCallExpression: ga, isMemberExpression: ba, isObjectProperty: Pa, getComments: Ta, CommentCheckFlags: wa } = ra, { locStart: Sa, locEnd: Ba } = ei$1;
  function Na(e2, t2) {
    const s2 = (e2.body || e2.properties).find(({ type: e3 }) => e3 !== "EmptyStatement");
    s2 ? ha(s2, t2) : pa(e2, t2);
  }
  function Ia(e2, t2) {
    e2.type === "BlockStatement" ? Na(e2, t2) : ha(e2, t2);
  }
  function va({ comment: e2, followingNode: t2 }) {
    return !(!t2 || !un$1(e2)) && (ha(t2, e2), true);
  }
  function ka({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
    if (!s2 || s2.type !== "IfStatement" || !r2)
      return false;
    return oa(i2, e2, Ba) === ")" ? (ca(t2, e2), true) : t2 === s2.consequent && r2 === s2.alternate ? (t2.type === "BlockStatement" ? ca(t2, e2) : pa(s2, e2), true) : r2.type === "BlockStatement" ? (Na(r2, e2), true) : r2.type === "IfStatement" ? (Ia(r2.consequent, e2), true) : s2.consequent === r2 && (ha(r2, e2), true);
  }
  function La({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
    if (!s2 || s2.type !== "WhileStatement" || !r2)
      return false;
    return oa(i2, e2, Ba) === ")" ? (ca(t2, e2), true) : r2.type === "BlockStatement" ? (Na(r2, e2), true) : s2.body === r2 && (ha(r2, e2), true);
  }
  function Oa({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
    return !(!s2 || s2.type !== "TryStatement" && s2.type !== "CatchClause" || !r2) && (s2.type === "CatchClause" && t2 ? (ca(t2, e2), true) : r2.type === "BlockStatement" ? (Na(r2, e2), true) : r2.type === "TryStatement" ? (Ia(r2.finalizer, e2), true) : r2.type === "CatchClause" && (Ia(r2.body, e2), true));
  }
  function Ma({ comment: e2, enclosingNode: t2, followingNode: s2 }) {
    return !(!ba(t2) || !s2 || s2.type !== "Identifier") && (ha(t2, e2), true);
  }
  function Ra({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
    const a2 = t2 && !ua(i2, Ba(t2), Sa(e2));
    return !(t2 && a2 || !s2 || s2.type !== "ConditionalExpression" && s2.type !== "TSConditionalType" || !r2) && (ha(r2, e2), true);
  }
  function ja({ comment: e2, precedingNode: t2, enclosingNode: s2 }) {
    return !(!Pa(s2) || !s2.shorthand || s2.key !== t2 || s2.value.type !== "AssignmentPattern") && (ca(s2.value.left, e2), true);
  }
  function _a({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
    if (s2 && (s2.type === "ClassDeclaration" || s2.type === "ClassExpression" || s2.type === "DeclareClass" || s2.type === "DeclareInterface" || s2.type === "InterfaceDeclaration" || s2.type === "TSInterfaceDeclaration")) {
      if (da(s2.decorators) && (!r2 || r2.type !== "Decorator"))
        return ca(ia(s2.decorators), e2), true;
      if (s2.body && r2 === s2.body)
        return Na(s2.body, e2), true;
      if (r2) {
        for (const i2 of ["implements", "extends", "mixins"])
          if (s2[i2] && r2 === s2[i2][0])
            return !t2 || t2 !== s2.id && t2 !== s2.typeParameters && t2 !== s2.superClass ? pa(s2, e2, i2) : ca(t2, e2), true;
      }
    }
    return false;
  }
  function Ua({ comment: e2, precedingNode: t2, enclosingNode: s2, text: r2 }) {
    return (s2 && t2 && (s2.type === "Property" || s2.type === "TSDeclareMethod" || s2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && s2.key === t2 && oa(r2, t2, Ba) !== ":" || !(!t2 || !s2 || t2.type !== "Decorator" || s2.type !== "ClassMethod" && s2.type !== "ClassProperty" && s2.type !== "PropertyDefinition" && s2.type !== "TSAbstractClassProperty" && s2.type !== "TSAbstractMethodDefinition" && s2.type !== "TSDeclareMethod" && s2.type !== "MethodDefinition")) && (ca(t2, e2), true);
  }
  function qa({ comment: e2, precedingNode: t2, enclosingNode: s2, text: r2 }) {
    return oa(r2, e2, Ba) === "(" && (!(!t2 || !s2 || s2.type !== "FunctionDeclaration" && s2.type !== "FunctionExpression" && s2.type !== "ClassMethod" && s2.type !== "MethodDefinition" && s2.type !== "ObjectMethod") && (ca(t2, e2), true));
  }
  function $a({ comment: e2, enclosingNode: t2, text: s2 }) {
    if (!t2 || t2.type !== "ArrowFunctionExpression")
      return false;
    const r2 = la(s2, e2, Ba);
    return r2 !== false && s2.slice(r2, r2 + 2) === "=>" && (pa(t2, e2), true);
  }
  function Ha({ comment: e2, enclosingNode: t2, text: s2 }) {
    return oa(s2, e2, Ba) === ")" && (t2 && (on$1(t2) && ma(t2).length === 0 || xa(t2) && Fa(t2).length === 0) ? (pa(t2, e2), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || ma(t2.value).length !== 0) && (pa(t2.value, e2), true));
  }
  function Va({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
    if (t2 && t2.type === "FunctionTypeParam" && s2 && s2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
      return ca(t2, e2), true;
    if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && s2 && on$1(s2) && oa(i2, e2, Ba) === ")")
      return ca(t2, e2), true;
    if (s2 && s2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
      const t3 = (() => {
        const e3 = ma(s2);
        if (e3.length > 0)
          return na(i2, Ba(ia(e3)));
        const t4 = na(i2, Ba(s2.id));
        return t4 !== false && na(i2, t4 + 1);
      })();
      if (Sa(e2) > t3)
        return Na(r2, e2), true;
    }
    return false;
  }
  function za({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "ImportSpecifier") && (ha(t2, e2), true);
  }
  function Wa({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "LabeledStatement") && (ha(t2, e2), true);
  }
  function Ga({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (ca(t2, e2), true);
  }
  function Ka({ comment: e2, precedingNode: t2, enclosingNode: s2 }) {
    return !!(ga(s2) && t2 && s2.callee === t2 && s2.arguments.length > 0) && (ha(s2.arguments[0], e2), true);
  }
  function Xa({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
    return !s2 || s2.type !== "UnionTypeAnnotation" && s2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && fa(e2) && (r2.types[0].prettierIgnore = true, e2.unignore = true), false) : (fa(e2) && (r2.prettierIgnore = true, e2.unignore = true), !!t2 && (ca(t2, e2), true));
  }
  function Ja({ comment: e2, enclosingNode: t2 }) {
    return !!Pa(t2) && (ha(t2, e2), true);
  }
  function Ya({ comment: e2, enclosingNode: t2, followingNode: s2, ast: r2, isLastComment: i2 }) {
    return r2 && r2.body && r2.body.length === 0 ? (i2 ? pa(r2, e2) : ha(r2, e2), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !da(t2.directives) ? (i2 ? pa(t2, e2) : ha(t2, e2), true) : !(!s2 || s2.type !== "Program" || s2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (pa(s2, e2), true);
  }
  function Qa({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (ha(t2, e2), true);
  }
  function Za({ comment: e2, precedingNode: t2, enclosingNode: s2, text: r2 }) {
    return !!(t2 && t2.type === "ImportSpecifier" && s2 && s2.type === "ImportDeclaration" && aa(r2, Ba(e2))) && (ca(t2, e2), true);
  }
  function en$1({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "AssignmentPattern") && (ha(t2, e2), true);
  }
  function tn$1({ comment: e2, enclosingNode: t2 }) {
    return !(!t2 || t2.type !== "TypeAlias") && (ha(t2, e2), true);
  }
  function sn$1({ comment: e2, enclosingNode: t2, followingNode: s2 }) {
    return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !s2 || s2.type !== "ObjectExpression" && s2.type !== "ArrayExpression" && s2.type !== "TemplateLiteral" && s2.type !== "TaggedTemplateExpression" && !Da(e2)) && (ha(s2, e2), true);
  }
  function rn$1({ comment: e2, enclosingNode: t2, followingNode: s2, text: r2 }) {
    return !(s2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || oa(r2, e2, Ba) !== ";") && (ca(t2, e2), true);
  }
  function an$1({ comment: e2, enclosingNode: t2, followingNode: s2 }) {
    if (fa(e2) && t2 && t2.type === "TSMappedType" && s2 && s2.type === "TSTypeParameter" && s2.constraint)
      return t2.prettierIgnore = true, e2.unignore = true, true;
  }
  function nn$1({ comment: e2, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
    return !(!s2 || s2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (ha(r2.name, e2), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (ca(t2.constraint, e2), true));
  }
  function on$1(e2) {
    return e2.type === "ArrowFunctionExpression" || e2.type === "FunctionExpression" || e2.type === "FunctionDeclaration" || e2.type === "ObjectMethod" || e2.type === "ClassMethod" || e2.type === "TSDeclareFunction" || e2.type === "TSCallSignatureDeclaration" || e2.type === "TSConstructSignatureDeclaration" || e2.type === "TSMethodSignature" || e2.type === "TSConstructorType" || e2.type === "TSFunctionType" || e2.type === "TSDeclareMethod";
  }
  function un$1(e2) {
    return Da(e2) && e2.value[0] === "*" && /@type\b/.test(e2.value);
  }
  var hn$1 = { handleOwnLineComment: function(e2) {
    return [an$1, Va, Ma, ka, La, Oa, _a, za, Qa, Xa, Ya, Za, en$1, Ua, Wa].some((t2) => t2(e2));
  }, handleEndOfLineComment: function(e2) {
    return [va, Va, Ra, za, ka, La, Oa, _a, Wa, Ka, Ja, Ya, tn$1, sn$1].some((t2) => t2(e2));
  }, handleRemainingComment: function(e2) {
    return [an$1, ka, La, ja, Ha, Ua, Ya, $a, qa, nn$1, Ga, rn$1].some((t2) => t2(e2));
  }, isTypeCastComment: un$1, getCommentChildNodes: function(e2, t2) {
    if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e2.type === "MethodDefinition" && e2.value && e2.value.type === "FunctionExpression" && ma(e2.value).length === 0 && !e2.value.returnType && !da(e2.value.typeParameters) && e2.value.body)
      return [...e2.decorators || [], e2.key, e2.value.body];
  }, willPrintOwnComments: function(e2) {
    const t2 = e2.getValue(), s2 = e2.getParentNode();
    return (t2 && (ya(t2) || Aa(t2) || ga(s2) && ((e3) => Ea(Ta(e3, wa.Leading)) || Ea(Ta(e3, wa.Trailing)))(t2)) || s2 && (s2.type === "JSXSpreadAttribute" || s2.type === "JSXSpreadChild" || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType" || (s2.type === "ClassDeclaration" || s2.type === "ClassExpression") && s2.superClass === t2)) && (!Ca(e2) || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType");
  } };
  const { getLast: cn$1, getNextNonSpaceNonCommentCharacter: pn$1 } = tr$1, { locStart: ln$1, locEnd: dn$1 } = ei$1, { isTypeCastComment: Dn$1 } = hn$1;
  function mn$1(e2) {
    return e2.type === "CallExpression" ? (e2.type = "OptionalCallExpression", e2.callee = mn$1(e2.callee)) : e2.type === "MemberExpression" ? (e2.type = "OptionalMemberExpression", e2.object = mn$1(e2.object)) : e2.type === "TSNonNullExpression" && (e2.expression = mn$1(e2.expression)), e2;
  }
  function fn$1(e2, t2) {
    let s2;
    if (Array.isArray(e2))
      s2 = e2.entries();
    else {
      if (!e2 || typeof e2 != "object" || typeof e2.type != "string")
        return e2;
      s2 = Object.entries(e2);
    }
    for (const [r2, i2] of s2)
      e2[r2] = fn$1(i2, t2);
    return Array.isArray(e2) ? e2 : t2(e2) || e2;
  }
  function yn$1(e2) {
    return e2.type === "LogicalExpression" && e2.right.type === "LogicalExpression" && e2.operator === e2.right.operator;
  }
  function An$1(e2) {
    return yn$1(e2) ? An$1({ type: "LogicalExpression", operator: e2.operator, left: An$1({ type: "LogicalExpression", operator: e2.operator, left: e2.left, right: e2.right.left, range: [ln$1(e2.left), dn$1(e2.right.left)] }), right: e2.right.right, range: [ln$1(e2), dn$1(e2)] }) : e2;
  }
  var En$1 = function(e2, t2) {
    if (t2.parser === "typescript" && t2.originalText.includes("@")) {
      const { esTreeNodeToTSNodeMap: s2, tsNodeToESTreeNodeMap: r2 } = t2.tsParseResult;
      e2 = fn$1(e2, (e3) => {
        const t3 = s2.get(e3);
        if (!t3)
          return;
        const i2 = t3.decorators;
        if (!Array.isArray(i2))
          return;
        const a2 = r2.get(t3);
        if (a2 !== e3)
          return;
        const n2 = a2.decorators;
        if (!Array.isArray(n2) || n2.length !== i2.length || i2.some((e4) => {
          const t4 = r2.get(e4);
          return !t4 || !n2.includes(t4);
        })) {
          const { start: e4, end: t4 } = a2.loc;
          throw ai$1("Leading decorators must be attached to a class declaration", { start: { line: e4.line, column: e4.column + 1 }, end: { line: t4.line, column: t4.column + 1 } });
        }
      });
    }
    if (t2.parser !== "typescript" && t2.parser !== "flow" && t2.parser !== "espree" && t2.parser !== "meriyah") {
      const t3 = new Set();
      e2 = fn$1(e2, (e3) => {
        e3.leadingComments && e3.leadingComments.some(Dn$1) && t3.add(ln$1(e3));
      }), e2 = fn$1(e2, (e3) => {
        if (e3.type === "ParenthesizedExpression") {
          const { expression: s2 } = e3;
          if (s2.type === "TypeCastExpression")
            return s2.range = e3.range, s2;
          const r2 = ln$1(e3);
          if (!t3.has(r2))
            return s2.extra = Object.assign(Object.assign({}, s2.extra), {}, { parenthesized: true }), s2;
        }
      });
    }
    return e2 = fn$1(e2, (e3) => {
      switch (e3.type) {
        case "ChainExpression":
          return mn$1(e3.expression);
        case "LogicalExpression":
          if (yn$1(e3))
            return An$1(e3);
          break;
        case "VariableDeclaration": {
          const s2 = cn$1(e3.declarations);
          s2 && s2.init && function(e4, s3) {
            if (t2.originalText[dn$1(s3)] === ";")
              return;
            e4.range = [ln$1(e4), dn$1(s3)];
          }(e3, s2);
          break;
        }
        case "TSParenthesizedType":
          return e3.typeAnnotation.range = [ln$1(e3), dn$1(e3)], e3.typeAnnotation;
        case "TSTypeParameter":
          if (typeof e3.name == "string") {
            const t3 = ln$1(e3);
            e3.name = { type: "Identifier", name: e3.name, range: [t3, t3 + e3.name.length] };
          }
          break;
        case "SequenceExpression": {
          const t3 = cn$1(e3.expressions);
          e3.range = [ln$1(e3), Math.min(dn$1(t3), dn$1(e3))];
          break;
        }
        case "ClassProperty":
          e3.key && e3.key.type === "TSPrivateIdentifier" && pn$1(t2.originalText, e3.key, dn$1) === "?" && (e3.optional = true);
      }
    });
  };
  class Cn$1 {
    constructor(e2, t2 = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = e2, this.keyword = t2.keyword, this.beforeExpr = !!t2.beforeExpr, this.startsExpr = !!t2.startsExpr, this.rightAssociative = !!t2.rightAssociative, this.isLoop = !!t2.isLoop, this.isAssign = !!t2.isAssign, this.prefix = !!t2.prefix, this.postfix = !!t2.postfix, this.binop = t2.binop != null ? t2.binop : null, this.updateContext = null;
    }
  }
  const xn$1 = new Map();
  function Fn$1(e2, t2 = {}) {
    t2.keyword = e2;
    const s2 = new Cn$1(e2, t2);
    return xn$1.set(e2, s2), s2;
  }
  function gn$1(e2, t2) {
    return new Cn$1(e2, { beforeExpr: true, binop: t2 });
  }
  const bn$1 = { num: new Cn$1("num", { startsExpr: true }), bigint: new Cn$1("bigint", { startsExpr: true }), decimal: new Cn$1("decimal", { startsExpr: true }), regexp: new Cn$1("regexp", { startsExpr: true }), string: new Cn$1("string", { startsExpr: true }), name: new Cn$1("name", { startsExpr: true }), privateName: new Cn$1("#name", { startsExpr: true }), eof: new Cn$1("eof"), bracketL: new Cn$1("[", { beforeExpr: true, startsExpr: true }), bracketHashL: new Cn$1("#[", { beforeExpr: true, startsExpr: true }), bracketBarL: new Cn$1("[|", { beforeExpr: true, startsExpr: true }), bracketR: new Cn$1("]"), bracketBarR: new Cn$1("|]"), braceL: new Cn$1("{", { beforeExpr: true, startsExpr: true }), braceBarL: new Cn$1("{|", { beforeExpr: true, startsExpr: true }), braceHashL: new Cn$1("#{", { beforeExpr: true, startsExpr: true }), braceR: new Cn$1("}", { beforeExpr: true }), braceBarR: new Cn$1("|}"), parenL: new Cn$1("(", { beforeExpr: true, startsExpr: true }), parenR: new Cn$1(")"), comma: new Cn$1(",", { beforeExpr: true }), semi: new Cn$1(";", { beforeExpr: true }), colon: new Cn$1(":", { beforeExpr: true }), doubleColon: new Cn$1("::", { beforeExpr: true }), dot: new Cn$1("."), question: new Cn$1("?", { beforeExpr: true }), questionDot: new Cn$1("?."), arrow: new Cn$1("=>", { beforeExpr: true }), template: new Cn$1("template"), ellipsis: new Cn$1("...", { beforeExpr: true }), backQuote: new Cn$1("`", { startsExpr: true }), dollarBraceL: new Cn$1("${", { beforeExpr: true, startsExpr: true }), at: new Cn$1("@"), hash: new Cn$1("#", { startsExpr: true }), interpreterDirective: new Cn$1("#!..."), eq: new Cn$1("=", { beforeExpr: true, isAssign: true }), assign: new Cn$1("_=", { beforeExpr: true, isAssign: true }), slashAssign: new Cn$1("_=", { beforeExpr: true, isAssign: true }), moduloAssign: new Cn$1("_=", { beforeExpr: true, isAssign: true }), incDec: new Cn$1("++/--", { prefix: true, postfix: true, startsExpr: true }), bang: new Cn$1("!", { beforeExpr: true, prefix: true, startsExpr: true }), tilde: new Cn$1("~", { beforeExpr: true, prefix: true, startsExpr: true }), pipeline: gn$1("|>", 0), nullishCoalescing: gn$1("??", 1), logicalOR: gn$1("||", 1), logicalAND: gn$1("&&", 2), bitwiseOR: gn$1("|", 3), bitwiseXOR: gn$1("^", 4), bitwiseAND: gn$1("&", 5), equality: gn$1("==/!=/===/!==", 6), relational: gn$1("</>/<=/>=", 7), bitShift: gn$1("<</>>/>>>", 8), plusMin: new Cn$1("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: new Cn$1("%", { binop: 10, startsExpr: true }), star: new Cn$1("*", { binop: 10 }), slash: gn$1("/", 10), exponent: new Cn$1("**", { beforeExpr: true, binop: 11, rightAssociative: true }), _break: Fn$1("break"), _case: Fn$1("case", { beforeExpr: true }), _catch: Fn$1("catch"), _continue: Fn$1("continue"), _debugger: Fn$1("debugger"), _default: Fn$1("default", { beforeExpr: true }), _do: Fn$1("do", { isLoop: true, beforeExpr: true }), _else: Fn$1("else", { beforeExpr: true }), _finally: Fn$1("finally"), _for: Fn$1("for", { isLoop: true }), _function: Fn$1("function", { startsExpr: true }), _if: Fn$1("if"), _return: Fn$1("return", { beforeExpr: true }), _switch: Fn$1("switch"), _throw: Fn$1("throw", { beforeExpr: true, prefix: true, startsExpr: true }), _try: Fn$1("try"), _var: Fn$1("var"), _const: Fn$1("const"), _while: Fn$1("while", { isLoop: true }), _with: Fn$1("with"), _new: Fn$1("new", { beforeExpr: true, startsExpr: true }), _this: Fn$1("this", { startsExpr: true }), _super: Fn$1("super", { startsExpr: true }), _class: Fn$1("class", { startsExpr: true }), _extends: Fn$1("extends", { beforeExpr: true }), _export: Fn$1("export"), _import: Fn$1("import", { startsExpr: true }), _null: Fn$1("null", { startsExpr: true }), _true: Fn$1("true", { startsExpr: true }), _false: Fn$1("false", { startsExpr: true }), _in: Fn$1("in", { beforeExpr: true, binop: 7 }), _instanceof: Fn$1("instanceof", { beforeExpr: true, binop: 7 }), _typeof: Fn$1("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: Fn$1("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: Fn$1("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, Pn$1 = /\r\n?|[\n\u2028\u2029]/, Tn$1 = new RegExp(Pn$1.source, "g");
  function wn$1(e2) {
    switch (e2) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  const Sn$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Bn$1 = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Nn$1(e2) {
    switch (e2) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  class In$1 {
    constructor(e2, t2) {
      this.line = void 0, this.column = void 0, this.line = e2, this.column = t2;
    }
  }
  class vn$1 {
    constructor(e2, t2) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e2, this.end = t2;
    }
  }
  function kn$1(e2, t2) {
    e2.trailingComments === void 0 ? e2.trailingComments = t2 : e2.trailingComments.unshift(...t2);
  }
  function Ln$1(e2, t2) {
    e2.innerComments === void 0 ? e2.innerComments = t2 : t2 !== void 0 && e2.innerComments.unshift(...t2);
  }
  function On$1(e2, t2, s2) {
    let r2 = null, i2 = t2.length;
    for (; r2 === null && i2 > 0; )
      r2 = t2[--i2];
    r2 === null || r2.start > s2.start ? Ln$1(e2, s2.comments) : kn$1(r2, s2.comments);
  }
  const Mn$1 = Object.freeze({ SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }), Rn$1 = Un$1({ AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.', PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Mn$1.SyntaxError), jn$1 = Un$1({ ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'` }, Mn$1.SourceTypeModuleError);
  function _n$1(e2, t2) {
    return t2 === "flow" && e2 === "PatternIsOptional" ? "OptionalBindingPattern" : e2;
  }
  function Un$1(e2, t2, s2) {
    const r2 = {};
    return Object.keys(e2).forEach((i2) => {
      r2[i2] = Object.freeze({ code: t2, reasonCode: _n$1(i2, s2), template: e2[i2] });
    }), Object.freeze(r2);
  }
  class qn$1 {
    constructor(e2, t2) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e2, this.preserveSpace = !!t2;
    }
  }
  const $n$1 = { brace: new qn$1("{"), template: new qn$1("`", true) };
  bn$1.braceR.updateContext = (e2) => {
    e2.pop();
  }, bn$1.braceL.updateContext = bn$1.braceHashL.updateContext = bn$1.dollarBraceL.updateContext = (e2) => {
    e2.push($n$1.brace);
  }, bn$1.backQuote.updateContext = (e2) => {
    e2[e2.length - 1] === $n$1.template ? e2.pop() : e2.push($n$1.template);
  };
  let Hn$1 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Vn$1 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  const zn$1 = new RegExp("[" + Hn$1 + "]"), Wn$1 = new RegExp("[" + Hn$1 + Vn$1 + "]");
  Hn$1 = Vn$1 = null;
  const Gn$1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], Kn$1 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Xn$1(e2, t2) {
    let s2 = 65536;
    for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
      if (s2 += t2[r2], s2 > e2)
        return false;
      if (s2 += t2[r2 + 1], s2 >= e2)
        return true;
    }
    return false;
  }
  function Jn$1(e2) {
    return e2 < 65 ? e2 === 36 : e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && zn$1.test(String.fromCharCode(e2)) : Xn$1(e2, Gn$1)));
  }
  function Yn$1(e2) {
    return e2 < 48 ? e2 === 36 : e2 < 58 || !(e2 < 65) && (e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && Wn$1.test(String.fromCharCode(e2)) : Xn$1(e2, Gn$1) || Xn$1(e2, Kn$1))));
  }
  const Qn$1 = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Zn$1 = ["eval", "arguments"], eo$1 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), to$1 = new Set(Qn$1), so$1 = new Set(Zn$1);
  function ro$1(e2, t2) {
    return t2 && e2 === "await" || e2 === "enum";
  }
  function io$1(e2, t2) {
    return ro$1(e2, t2) || to$1.has(e2);
  }
  function ao$1(e2) {
    return so$1.has(e2);
  }
  function no$1(e2, t2) {
    return io$1(e2, t2) || ao$1(e2);
  }
  function oo$1(e2) {
    return eo$1.has(e2);
  }
  const uo$1 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  class ho$1 {
    constructor(e2) {
      this.var = new Set(), this.lexical = new Set(), this.functions = new Set(), this.flags = e2;
    }
  }
  class co$1 {
    constructor(e2, t2) {
      this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = e2, this.inModule = t2;
    }
    get inFunction() {
      return (2 & this.currentVarScopeFlags()) > 0;
    }
    get allowSuper() {
      return (16 & this.currentThisScopeFlags()) > 0;
    }
    get allowDirectSuper() {
      return (32 & this.currentThisScopeFlags()) > 0;
    }
    get inClass() {
      return (64 & this.currentThisScopeFlags()) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const e2 = this.currentThisScopeFlags();
      return (64 & e2) > 0 && (2 & e2) == 0;
    }
    get inStaticBlock() {
      for (let e2 = this.scopeStack.length - 1; ; e2--) {
        const { flags: t2 } = this.scopeStack[e2];
        if (128 & t2)
          return true;
        if (323 & t2)
          return false;
      }
    }
    get inNonArrowFunction() {
      return (2 & this.currentThisScopeFlags()) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e2) {
      return new ho$1(e2);
    }
    enter(e2) {
      this.scopeStack.push(this.createScope(e2));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(e2) {
      return !!(2 & e2.flags || !this.inModule && 1 & e2.flags);
    }
    declareName(e2, t2, s2) {
      let r2 = this.currentScope();
      if (8 & t2 || 16 & t2)
        this.checkRedeclarationInScope(r2, e2, t2, s2), 16 & t2 ? r2.functions.add(e2) : r2.lexical.add(e2), 8 & t2 && this.maybeExportDefined(r2, e2);
      else if (4 & t2)
        for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r2 = this.scopeStack[i2], this.checkRedeclarationInScope(r2, e2, t2, s2), r2.var.add(e2), this.maybeExportDefined(r2, e2), !(259 & r2.flags)); --i2)
          ;
      this.inModule && 1 & r2.flags && this.undefinedExports.delete(e2);
    }
    maybeExportDefined(e2, t2) {
      this.inModule && 1 & e2.flags && this.undefinedExports.delete(t2);
    }
    checkRedeclarationInScope(e2, t2, s2, r2) {
      this.isRedeclaredInScope(e2, t2, s2) && this.raise(r2, Rn$1.VarRedeclaration, t2);
    }
    isRedeclaredInScope(e2, t2, s2) {
      return !!(1 & s2) && (8 & s2 ? e2.lexical.has(t2) || e2.functions.has(t2) || e2.var.has(t2) : 16 & s2 ? e2.lexical.has(t2) || !this.treatFunctionsAsVarInScope(e2) && e2.var.has(t2) : e2.lexical.has(t2) && !(8 & e2.flags && e2.lexical.values().next().value === t2) || !this.treatFunctionsAsVarInScope(e2) && e2.functions.has(t2));
    }
    checkLocalExport(e2) {
      const { name: t2 } = e2, s2 = this.scopeStack[0];
      s2.lexical.has(t2) || s2.var.has(t2) || s2.functions.has(t2) || this.undefinedExports.set(t2, e2.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e2 = this.scopeStack.length - 1; ; e2--) {
        const { flags: t2 } = this.scopeStack[e2];
        if (259 & t2)
          return t2;
      }
    }
    currentThisScopeFlags() {
      for (let e2 = this.scopeStack.length - 1; ; e2--) {
        const { flags: t2 } = this.scopeStack[e2];
        if (323 & t2 && !(4 & t2))
          return t2;
      }
    }
  }
  class po$1 extends ho$1 {
    constructor(...e2) {
      super(...e2), this.declareFunctions = new Set();
    }
  }
  class lo$1 extends co$1 {
    createScope(e2) {
      return new po$1(e2);
    }
    declareName(e2, t2, s2) {
      const r2 = this.currentScope();
      if (2048 & t2)
        return this.checkRedeclarationInScope(r2, e2, t2, s2), this.maybeExportDefined(r2, e2), void r2.declareFunctions.add(e2);
      super.declareName(...arguments);
    }
    isRedeclaredInScope(e2, t2, s2) {
      return !!super.isRedeclaredInScope(...arguments) || !!(2048 & s2) && (!e2.declareFunctions.has(t2) && (e2.lexical.has(t2) || e2.functions.has(t2)));
    }
    checkLocalExport(e2) {
      this.scopeStack[0].declareFunctions.has(e2.name) || super.checkLocalExport(e2);
    }
  }
  class Do$1 {
    constructor() {
      this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.lineStart = 0, this.type = bn$1.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [$n$1.brace], this.exprAllowed = true, this.containsEsc = false, this.strictErrors = new Map(), this.tokensLength = 0;
    }
    init(e2) {
      this.strict = e2.strictMode !== false && (e2.strictMode === true || e2.sourceType === "module"), this.curLine = e2.startLine, this.startLoc = this.endLoc = this.curPosition();
    }
    curPosition() {
      return new In$1(this.curLine, this.pos - this.lineStart);
    }
    clone(e2) {
      const t2 = new Do$1(), s2 = Object.keys(this);
      for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) {
        const i3 = s2[r2];
        let a2 = this[i3];
        !e2 && Array.isArray(a2) && (a2 = a2.slice()), t2[i3] = a2;
      }
      return t2;
    }
  }
  var mo$1 = function(e2) {
    return e2 >= 48 && e2 <= 57;
  };
  const fo$1 = new Set([103, 109, 115, 105, 121, 117, 100]), yo$1 = { decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120] }, Ao$1 = { bin: [48, 49] };
  Ao$1.oct = [...Ao$1.bin, 50, 51, 52, 53, 54, 55], Ao$1.dec = [...Ao$1.oct, 56, 57], Ao$1.hex = [...Ao$1.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
  class Eo$1 {
    constructor(e2) {
      this.type = e2.type, this.value = e2.value, this.start = e2.start, this.end = e2.end, this.loc = new vn$1(e2.startLoc, e2.endLoc);
    }
  }
  class Co$1 {
    constructor() {
      this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();
    }
  }
  class xo$1 {
    constructor(e2) {
      this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = e2;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Co$1());
    }
    exit() {
      const e2 = this.stack.pop(), t2 = this.current();
      for (const [s2, r2] of Array.from(e2.undefinedPrivateNames))
        t2 ? t2.undefinedPrivateNames.has(s2) || t2.undefinedPrivateNames.set(s2, r2) : this.raise(r2, Rn$1.InvalidPrivateFieldResolution, s2);
    }
    declarePrivateName(e2, t2, s2) {
      const r2 = this.current();
      let i2 = r2.privateNames.has(e2);
      if (3 & t2) {
        const s3 = i2 && r2.loneAccessors.get(e2);
        if (s3) {
          const a2 = 4 & s3, n2 = 4 & t2;
          i2 = (3 & s3) === (3 & t2) || a2 !== n2, i2 || r2.loneAccessors.delete(e2);
        } else
          i2 || r2.loneAccessors.set(e2, t2);
      }
      i2 && this.raise(s2, Rn$1.PrivateNameRedeclaration, e2), r2.privateNames.add(e2), r2.undefinedPrivateNames.delete(e2);
    }
    usePrivateName(e2, t2) {
      let s2;
      for (s2 of this.stack)
        if (s2.privateNames.has(e2))
          return;
      s2 ? s2.undefinedPrivateNames.set(e2, t2) : this.raise(t2, Rn$1.InvalidPrivateFieldResolution, e2);
    }
  }
  class Fo$1 {
    constructor(e2 = 0) {
      this.type = void 0, this.type = e2;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class go$1 extends Fo$1 {
    constructor(e2) {
      super(e2), this.errors = new Map();
    }
    recordDeclarationError(e2, t2) {
      this.errors.set(e2, t2);
    }
    clearDeclarationError(e2) {
      this.errors.delete(e2);
    }
    iterateErrors(e2) {
      this.errors.forEach(e2);
    }
  }
  class bo$1 {
    constructor(e2) {
      this.stack = [new Fo$1()], this.raise = e2;
    }
    enter(e2) {
      this.stack.push(e2);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e2, t2) {
      const { stack: s2 } = this;
      let r2 = s2.length - 1, i2 = s2[r2];
      for (; !i2.isCertainlyParameterDeclaration(); ) {
        if (!i2.canBeArrowParameterDeclaration())
          return;
        i2.recordDeclarationError(e2, t2), i2 = s2[--r2];
      }
      this.raise(e2, t2);
    }
    recordParenthesizedIdentifierError(e2, t2) {
      const { stack: s2 } = this, r2 = s2[s2.length - 1];
      if (r2.isCertainlyParameterDeclaration())
        this.raise(e2, t2);
      else {
        if (!r2.canBeArrowParameterDeclaration())
          return;
        r2.recordDeclarationError(e2, t2);
      }
    }
    recordAsyncArrowParametersError(e2, t2) {
      const { stack: s2 } = this;
      let r2 = s2.length - 1, i2 = s2[r2];
      for (; i2.canBeArrowParameterDeclaration(); )
        i2.type === 2 && i2.recordDeclarationError(e2, t2), i2 = s2[--r2];
    }
    validateAsPattern() {
      const { stack: e2 } = this, t2 = e2[e2.length - 1];
      t2.canBeArrowParameterDeclaration() && t2.iterateErrors((t3, s2) => {
        this.raise(s2, t3);
        let r2 = e2.length - 2, i2 = e2[r2];
        for (; i2.canBeArrowParameterDeclaration(); )
          i2.clearDeclarationError(s2), i2 = e2[--r2];
      });
    }
  }
  function Po$1() {
    return new Fo$1();
  }
  class To$1 {
    constructor() {
      this.stacks = [];
    }
    enter(e2) {
      this.stacks.push(e2);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (2 & this.currentFlags()) > 0;
    }
    get hasYield() {
      return (1 & this.currentFlags()) > 0;
    }
    get hasReturn() {
      return (4 & this.currentFlags()) > 0;
    }
    get hasIn() {
      return (8 & this.currentFlags()) > 0;
    }
  }
  function wo$1(e2, t2) {
    return (e2 ? 2 : 0) | (t2 ? 1 : 0);
  }
  class So$1 {
    constructor() {
      this.shorthandAssign = -1, this.doubleProto = -1, this.optionalParameters = -1;
    }
  }
  class Bo$1 {
    constructor(e2, t2, s2) {
      this.type = "", this.start = t2, this.end = 0, this.loc = new vn$1(s2), e2 != null && e2.options.ranges && (this.range = [t2, 0]), e2 != null && e2.filename && (this.loc.filename = e2.filename);
    }
  }
  const No$1 = Bo$1.prototype;
  function Io$1(e2) {
    const { type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2, name: o2 } = e2, u2 = Object.create(No$1);
    return u2.type = t2, u2.start = s2, u2.end = r2, u2.loc = i2, u2.range = a2, u2.extra = n2, u2.name = o2, t2 === "Placeholder" && (u2.expectedNode = e2.expectedNode), u2;
  }
  function vo$1(e2) {
    const { type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2 } = e2;
    if (t2 === "Placeholder")
      return function(e3) {
        return Io$1(e3);
      }(e2);
    const o2 = Object.create(No$1);
    return o2.type = "StringLiteral", o2.start = s2, o2.end = r2, o2.loc = i2, o2.range = a2, o2.extra = n2, o2.value = e2.value, o2;
  }
  No$1.__clone = function() {
    const e2 = new Bo$1(), t2 = Object.keys(this);
    for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
      const r3 = t2[s2];
      r3 !== "leadingComments" && r3 !== "trailingComments" && r3 !== "innerComments" && (e2[r3] = this[r3]);
    }
    return e2;
  };
  const ko$1 = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Lo$1 = Un$1({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." }, Mn$1.SyntaxError, "flow");
  function Oo$1(e2) {
    return e2.importKind === "type" || e2.importKind === "typeof";
  }
  function Mo(e2) {
    return (e2.type === bn$1.name || !!e2.type.keyword) && e2.value !== "from";
  }
  const Ro$1 = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  const jo = /\*?\s*@((?:no)?flow)\b/;
  const _o$1 = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, Uo = /^[\da-fA-F]+$/, qo = /^\d+$/, $o = Un$1({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" }, Mn$1.SyntaxError, "jsx");
  function Ho(e2) {
    return !!e2 && (e2.type === "JSXOpeningFragment" || e2.type === "JSXClosingFragment");
  }
  function Vo(e2) {
    if (e2.type === "JSXIdentifier")
      return e2.name;
    if (e2.type === "JSXNamespacedName")
      return e2.namespace.name + ":" + e2.name.name;
    if (e2.type === "JSXMemberExpression")
      return Vo(e2.object) + "." + Vo(e2.property);
    throw new Error("Node had unexpected type: " + e2.type);
  }
  $n$1.j_oTag = new qn$1("<tag"), $n$1.j_cTag = new qn$1("</tag"), $n$1.j_expr = new qn$1("<tag>...</tag>", true), bn$1.jsxName = new Cn$1("jsxName"), bn$1.jsxText = new Cn$1("jsxText", { beforeExpr: true }), bn$1.jsxTagStart = new Cn$1("jsxTagStart", { startsExpr: true }), bn$1.jsxTagEnd = new Cn$1("jsxTagEnd"), bn$1.jsxTagStart.updateContext = (e2) => {
    e2.push($n$1.j_expr, $n$1.j_oTag);
  };
  class zo extends ho$1 {
    constructor(...e2) {
      super(...e2), this.types = new Set(), this.enums = new Set(), this.constEnums = new Set(), this.classes = new Set(), this.exportOnlyBindings = new Set();
    }
  }
  class Wo extends co$1 {
    createScope(e2) {
      return new zo(e2);
    }
    declareName(e2, t2, s2) {
      const r2 = this.currentScope();
      if (1024 & t2)
        return this.maybeExportDefined(r2, e2), void r2.exportOnlyBindings.add(e2);
      super.declareName(...arguments), 2 & t2 && (1 & t2 || (this.checkRedeclarationInScope(r2, e2, t2, s2), this.maybeExportDefined(r2, e2)), r2.types.add(e2)), 256 & t2 && r2.enums.add(e2), 512 & t2 && r2.constEnums.add(e2), 128 & t2 && r2.classes.add(e2);
    }
    isRedeclaredInScope(e2, t2, s2) {
      if (e2.enums.has(t2)) {
        if (256 & s2) {
          return !!(512 & s2) !== e2.constEnums.has(t2);
        }
        return true;
      }
      return 128 & s2 && e2.classes.has(t2) ? !!e2.lexical.has(t2) && !!(1 & s2) : !!(2 & s2 && e2.types.has(t2)) || super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(e2) {
      const t2 = this.scopeStack[0], { name: s2 } = e2;
      t2.types.has(s2) || t2.exportOnlyBindings.has(s2) || super.checkLocalExport(e2);
    }
  }
  function Go(e2) {
    if (e2 == null)
      throw new Error(`Unexpected ${e2} value.`);
    return e2;
  }
  function Ko(e2) {
    if (!e2)
      throw new Error("Assert fail");
  }
  const Xo = Un$1({ AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0." }, Mn$1.SyntaxError, "typescript");
  function Jo(e2) {
    return e2 === "private" || e2 === "public" || e2 === "protected";
  }
  bn$1.placeholder = new Cn$1("%%", { startsExpr: true });
  const Yo = Un$1({ ClassNameIsRequired: "A class name is required." }, Mn$1.SyntaxError);
  function Qo(e2, t2) {
    return e2.some((e3) => Array.isArray(e3) ? e3[0] === t2 : e3 === t2);
  }
  function Zo(e2, t2, s2) {
    const r2 = e2.find((e3) => Array.isArray(e3) ? e3[0] === t2 : e3 === t2);
    return r2 && Array.isArray(r2) ? r2[1][s2] : null;
  }
  const eu = ["minimal", "fsharp", "hack", "smart"], tu = ["%", "#"], su = ["hash", "bar"];
  const ru = { estree: (e2) => class extends e2 {
    parseRegExpLiteral({ pattern: e3, flags: t2 }) {
      let s2 = null;
      try {
        s2 = new RegExp(e3, t2);
      } catch (e4) {
      }
      const r2 = this.estreeParseLiteral(s2);
      return r2.regex = { pattern: e3, flags: t2 }, r2;
    }
    parseBigIntLiteral(e3) {
      let t2;
      try {
        t2 = BigInt(e3);
      } catch (e4) {
        t2 = null;
      }
      const s2 = this.estreeParseLiteral(t2);
      return s2.bigint = String(s2.value || e3), s2;
    }
    parseDecimalLiteral(e3) {
      const t2 = this.estreeParseLiteral(null);
      return t2.decimal = String(t2.value || e3), t2;
    }
    estreeParseLiteral(e3) {
      return this.parseLiteral(e3, "Literal");
    }
    parseStringLiteral(e3) {
      return this.estreeParseLiteral(e3);
    }
    parseNumericLiteral(e3) {
      return this.estreeParseLiteral(e3);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e3) {
      return this.estreeParseLiteral(e3);
    }
    directiveToStmt(e3) {
      const t2 = e3.value, s2 = this.startNodeAt(e3.start, e3.loc.start), r2 = this.startNodeAt(t2.start, t2.loc.start);
      return r2.value = t2.extra.expressionValue, r2.raw = t2.extra.raw, s2.expression = this.finishNodeAt(r2, "Literal", t2.end, t2.loc.end), s2.directive = t2.extra.raw.slice(1, -1), this.finishNodeAt(s2, "ExpressionStatement", e3.end, e3.loc.end);
    }
    initFunction(e3, t2) {
      super.initFunction(e3, t2), e3.expression = false;
    }
    checkDeclaration(e3) {
      e3 != null && this.isObjectProperty(e3) ? this.checkDeclaration(e3.value) : super.checkDeclaration(e3);
    }
    getObjectOrClassMethodParams(e3) {
      return e3.value.params;
    }
    isValidDirective(e3) {
      var t2;
      return e3.type === "ExpressionStatement" && e3.expression.type === "Literal" && typeof e3.expression.value == "string" && !((t2 = e3.expression.extra) != null && t2.parenthesized);
    }
    stmtToDirective(e3) {
      const t2 = e3.expression.value, s2 = super.stmtToDirective(e3);
      return this.addExtra(s2.value, "expressionValue", t2), s2;
    }
    parseBlockBody(e3, ...t2) {
      super.parseBlockBody(e3, ...t2);
      const s2 = e3.directives.map((e4) => this.directiveToStmt(e4));
      e3.body = s2.concat(e3.body), delete e3.directives;
    }
    pushClassMethod(e3, t2, s2, r2, i2, a2) {
      this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true), t2.typeParameters && (t2.value.typeParameters = t2.typeParameters, delete t2.typeParameters), e3.body.push(t2);
    }
    parseMaybePrivateName(...e3) {
      const t2 = super.parseMaybePrivateName(...e3);
      return t2.type === "PrivateName" && this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t2) : t2;
    }
    convertPrivateNameToPrivateIdentifier(e3) {
      const t2 = super.getPrivateNameSV(e3);
      return delete (e3 = e3).id, e3.name = t2, e3.type = "PrivateIdentifier", e3;
    }
    isPrivateName(e3) {
      return this.getPluginOption("estree", "classFeatures") ? e3.type === "PrivateIdentifier" : super.isPrivateName(e3);
    }
    getPrivateNameSV(e3) {
      return this.getPluginOption("estree", "classFeatures") ? e3.name : super.getPrivateNameSV(e3);
    }
    parseLiteral(e3, t2) {
      const s2 = super.parseLiteral(e3, t2);
      return s2.raw = s2.extra.raw, delete s2.extra, s2;
    }
    parseFunctionBody(e3, t2, s2 = false) {
      super.parseFunctionBody(e3, t2, s2), e3.expression = e3.body.type !== "BlockStatement";
    }
    parseMethod(e3, t2, s2, r2, i2, a2, n2 = false) {
      let o2 = this.startNode();
      return o2.kind = e3.kind, o2 = super.parseMethod(o2, t2, s2, r2, i2, a2, n2), o2.type = "FunctionExpression", delete o2.kind, e3.value = o2, a2 === "ClassPrivateMethod" && (e3.computed = false), a2 = "MethodDefinition", this.finishNode(e3, a2);
    }
    parseClassProperty(...e3) {
      const t2 = super.parseClassProperty(...e3);
      return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition"), t2;
    }
    parseClassPrivateProperty(...e3) {
      const t2 = super.parseClassPrivateProperty(...e3);
      return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition", t2.computed = false), t2;
    }
    parseObjectMethod(e3, t2, s2, r2, i2) {
      const a2 = super.parseObjectMethod(e3, t2, s2, r2, i2);
      return a2 && (a2.type = "Property", a2.kind === "method" && (a2.kind = "init"), a2.shorthand = false), a2;
    }
    parseObjectProperty(e3, t2, s2, r2, i2) {
      const a2 = super.parseObjectProperty(e3, t2, s2, r2, i2);
      return a2 && (a2.kind = "init", a2.type = "Property"), a2;
    }
    isAssignable(e3, t2) {
      return e3 != null && this.isObjectProperty(e3) ? this.isAssignable(e3.value, t2) : super.isAssignable(e3, t2);
    }
    toAssignable(e3, t2 = false) {
      return e3 != null && this.isObjectProperty(e3) ? (this.toAssignable(e3.value, t2), e3) : super.toAssignable(e3, t2);
    }
    toAssignableObjectExpressionProp(e3, ...t2) {
      e3.kind === "get" || e3.kind === "set" ? this.raise(e3.key.start, Rn$1.PatternHasAccessor) : e3.method ? this.raise(e3.key.start, Rn$1.PatternHasMethod) : super.toAssignableObjectExpressionProp(e3, ...t2);
    }
    finishCallExpression(e3, t2) {
      if (super.finishCallExpression(e3, t2), e3.callee.type === "Import") {
        var s2;
        if (e3.type = "ImportExpression", e3.source = e3.arguments[0], this.hasPlugin("importAssertions"))
          e3.attributes = (s2 = e3.arguments[1]) != null ? s2 : null;
        delete e3.arguments, delete e3.callee;
      }
      return e3;
    }
    toReferencedArguments(e3) {
      e3.type !== "ImportExpression" && super.toReferencedArguments(e3);
    }
    parseExport(e3) {
      switch (super.parseExport(e3), e3.type) {
        case "ExportAllDeclaration":
          e3.exported = null;
          break;
        case "ExportNamedDeclaration":
          e3.specifiers.length === 1 && e3.specifiers[0].type === "ExportNamespaceSpecifier" && (e3.type = "ExportAllDeclaration", e3.exported = e3.specifiers[0].exported, delete e3.specifiers);
      }
      return e3;
    }
    parseSubscript(e3, t2, s2, r2, i2) {
      const a2 = super.parseSubscript(e3, t2, s2, r2, i2);
      if (i2.optionalChainMember) {
        if (a2.type !== "OptionalMemberExpression" && a2.type !== "OptionalCallExpression" || (a2.type = a2.type.substring(8)), i2.stop) {
          const e4 = this.startNodeAtNode(a2);
          return e4.expression = a2, this.finishNode(e4, "ChainExpression");
        }
      } else
        a2.type !== "MemberExpression" && a2.type !== "CallExpression" || (a2.optional = false);
      return a2;
    }
    hasPropertyAsPrivateName(e3) {
      return e3.type === "ChainExpression" && (e3 = e3.expression), super.hasPropertyAsPrivateName(e3);
    }
    isOptionalChain(e3) {
      return e3.type === "ChainExpression";
    }
    isObjectProperty(e3) {
      return e3.type === "Property" && e3.kind === "init" && !e3.method;
    }
    isObjectMethod(e3) {
      return e3.method || e3.kind === "get" || e3.kind === "set";
    }
  }, jsx: (e2) => class extends e2 {
    jsxReadToken() {
      let e3 = "", t2 = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, $o.UnterminatedJsxContent);
        const s2 = this.input.charCodeAt(this.state.pos);
        switch (s2) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? s2 === 60 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(s2) : (e3 += this.input.slice(t2, this.state.pos), this.finishToken(bn$1.jsxText, e3));
          case 38:
            e3 += this.input.slice(t2, this.state.pos), e3 += this.jsxReadEntity(), t2 = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            wn$1(s2) ? (e3 += this.input.slice(t2, this.state.pos), e3 += this.jsxReadNewLine(true), t2 = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e3) {
      const t2 = this.input.charCodeAt(this.state.pos);
      let s2;
      return ++this.state.pos, t2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s2 = e3 ? "\n" : "\r\n") : s2 = String.fromCharCode(t2), ++this.state.curLine, this.state.lineStart = this.state.pos, s2;
    }
    jsxReadString(e3) {
      let t2 = "", s2 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, Rn$1.UnterminatedString);
        const r2 = this.input.charCodeAt(this.state.pos);
        if (r2 === e3)
          break;
        r2 === 38 ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadEntity(), s2 = this.state.pos) : wn$1(r2) ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadNewLine(false), s2 = this.state.pos) : ++this.state.pos;
      }
      return t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
    }
    jsxReadEntity() {
      let e3, t2 = "", s2 = 0, r2 = this.input[this.state.pos];
      const i2 = ++this.state.pos;
      for (; this.state.pos < this.length && s2++ < 10; ) {
        if (r2 = this.input[this.state.pos++], r2 === ";") {
          t2[0] === "#" ? t2[1] === "x" ? (t2 = t2.substr(2), Uo.test(t2) && (e3 = String.fromCodePoint(parseInt(t2, 16)))) : (t2 = t2.substr(1), qo.test(t2) && (e3 = String.fromCodePoint(parseInt(t2, 10)))) : e3 = _o$1[t2];
          break;
        }
        t2 += r2;
      }
      return e3 || (this.state.pos = i2, "&");
    }
    jsxReadWord() {
      let e3;
      const t2 = this.state.pos;
      do {
        e3 = this.input.charCodeAt(++this.state.pos);
      } while (Yn$1(e3) || e3 === 45);
      return this.finishToken(bn$1.jsxName, this.input.slice(t2, this.state.pos));
    }
    jsxParseIdentifier() {
      const e3 = this.startNode();
      return this.match(bn$1.jsxName) ? e3.name = this.state.value : this.state.type.keyword ? e3.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(e3, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e3 = this.state.start, t2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
      if (!this.eat(bn$1.colon))
        return s2;
      const r2 = this.startNodeAt(e3, t2);
      return r2.namespace = s2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e3 = this.state.start, t2 = this.state.startLoc;
      let s2 = this.jsxParseNamespacedName();
      if (s2.type === "JSXNamespacedName")
        return s2;
      for (; this.eat(bn$1.dot); ) {
        const r2 = this.startNodeAt(e3, t2);
        r2.object = s2, r2.property = this.jsxParseIdentifier(), s2 = this.finishNode(r2, "JSXMemberExpression");
      }
      return s2;
    }
    jsxParseAttributeValue() {
      let e3;
      switch (this.state.type) {
        case bn$1.braceL:
          return e3 = this.startNode(), this.next(), e3 = this.jsxParseExpressionContainer(e3), e3.expression.type === "JSXEmptyExpression" && this.raise(e3.start, $o.AttributeIsEmpty), e3;
        case bn$1.jsxTagStart:
        case bn$1.string:
          return this.parseExprAtom();
        default:
          throw this.raise(this.state.start, $o.UnsupportedJsxValue);
      }
    }
    jsxParseEmptyExpression() {
      const e3 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
      return this.finishNodeAt(e3, "JSXEmptyExpression", this.state.start, this.state.startLoc);
    }
    jsxParseSpreadChild(e3) {
      return this.next(), e3.expression = this.parseExpression(), this.expect(bn$1.braceR), this.finishNode(e3, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e3) {
      if (this.match(bn$1.braceR))
        e3.expression = this.jsxParseEmptyExpression();
      else {
        const t2 = this.parseExpression();
        e3.expression = t2;
      }
      return this.expect(bn$1.braceR), this.finishNode(e3, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e3 = this.startNode();
      return this.eat(bn$1.braceL) ? (this.expect(bn$1.ellipsis), e3.argument = this.parseMaybeAssignAllowIn(), this.expect(bn$1.braceR), this.finishNode(e3, "JSXSpreadAttribute")) : (e3.name = this.jsxParseNamespacedName(), e3.value = this.eat(bn$1.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(e3, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e3, t2) {
      const s2 = this.startNodeAt(e3, t2);
      return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXOpeningFragment")) : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
    }
    jsxParseOpeningElementAfterName(e3) {
      const t2 = [];
      for (; !this.match(bn$1.slash) && !this.match(bn$1.jsxTagEnd); )
        t2.push(this.jsxParseAttribute());
      return e3.attributes = t2, e3.selfClosing = this.eat(bn$1.slash), this.expect(bn$1.jsxTagEnd), this.finishNode(e3, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e3, t2) {
      const s2 = this.startNodeAt(e3, t2);
      return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingFragment")) : (s2.name = this.jsxParseElementName(), this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingElement"));
    }
    jsxParseElementAt(e3, t2) {
      const s2 = this.startNodeAt(e3, t2), r2 = [], i2 = this.jsxParseOpeningElementAt(e3, t2);
      let a2 = null;
      if (!i2.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case bn$1.jsxTagStart:
                if (e3 = this.state.start, t2 = this.state.startLoc, this.next(), this.eat(bn$1.slash)) {
                  a2 = this.jsxParseClosingElementAt(e3, t2);
                  break e;
                }
                r2.push(this.jsxParseElementAt(e3, t2));
                break;
              case bn$1.jsxText:
                r2.push(this.parseExprAtom());
                break;
              case bn$1.braceL: {
                const e4 = this.startNode();
                this.next(), this.match(bn$1.ellipsis) ? r2.push(this.jsxParseSpreadChild(e4)) : r2.push(this.jsxParseExpressionContainer(e4));
                break;
              }
              default:
                throw this.unexpected();
            }
        Ho(i2) && !Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagFragment) : !Ho(i2) && Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name)) : Ho(i2) || Ho(a2) || Vo(a2.name) !== Vo(i2.name) && this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name));
      }
      if (Ho(i2) ? (s2.openingFragment = i2, s2.closingFragment = a2) : (s2.openingElement = i2, s2.closingElement = a2), s2.children = r2, this.isRelational("<"))
        throw this.raise(this.state.start, $o.UnwrappedAdjacentJSXElements);
      return Ho(i2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
    }
    jsxParseElement() {
      const e3 = this.state.start, t2 = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e3, t2);
    }
    parseExprAtom(e3) {
      return this.match(bn$1.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(bn$1.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33 ? (this.finishToken(bn$1.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(e3);
    }
    createLookaheadState(e3) {
      const t2 = super.createLookaheadState(e3);
      return t2.inPropertyName = e3.inPropertyName, t2;
    }
    getTokenFromCode(e3) {
      if (this.state.inPropertyName)
        return super.getTokenFromCode(e3);
      const t2 = this.curContext();
      if (t2 === $n$1.j_expr)
        return this.jsxReadToken();
      if (t2 === $n$1.j_oTag || t2 === $n$1.j_cTag) {
        if (Jn$1(e3))
          return this.jsxReadWord();
        if (e3 === 62)
          return ++this.state.pos, this.finishToken(bn$1.jsxTagEnd);
        if ((e3 === 34 || e3 === 39) && t2 === $n$1.j_oTag)
          return this.jsxReadString(e3);
      }
      return e3 === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(e3);
    }
    updateContext(e3) {
      super.updateContext(e3);
      const { context: t2, type: s2 } = this.state;
      if (s2 === bn$1.slash && e3 === bn$1.jsxTagStart)
        t2.splice(-2, 2, $n$1.j_cTag), this.state.exprAllowed = false;
      else if (s2 === bn$1.jsxTagEnd) {
        const s3 = t2.pop();
        s3 === $n$1.j_oTag && e3 === bn$1.slash || s3 === $n$1.j_cTag ? (t2.pop(), this.state.exprAllowed = t2[t2.length - 1] === $n$1.j_expr) : this.state.exprAllowed = true;
      } else
        !s2.keyword || e3 !== bn$1.dot && e3 !== bn$1.questionDot ? this.state.exprAllowed = s2.beforeExpr : this.state.exprAllowed = false;
    }
  }, flow: (e2) => class extends e2 {
    constructor(...e3) {
      super(...e3), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return lo$1;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e3, t2) {
      return e3 !== bn$1.string && e3 !== bn$1.semi && e3 !== bn$1.interpreterDirective && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e3, t2);
    }
    addComment(e3) {
      if (this.flowPragma === void 0) {
        const t2 = jo.exec(e3.value);
        if (t2)
          if (t2[1] === "flow")
            this.flowPragma = "flow";
          else {
            if (t2[1] !== "noflow")
              throw new Error("Unexpected flow pragma");
            this.flowPragma = "noflow";
          }
      }
      return super.addComment(e3);
    }
    flowParseTypeInitialiser(e3) {
      const t2 = this.state.inType;
      this.state.inType = true, this.expect(e3 || bn$1.colon);
      const s2 = this.flowParseType();
      return this.state.inType = t2, s2;
    }
    flowParsePredicate() {
      const e3 = this.startNode(), t2 = this.state.start;
      return this.next(), this.expectContextual("checks"), this.state.lastTokStart > t2 + 1 && this.raise(t2, Lo$1.UnexpectedSpaceBetweenModuloChecks), this.eat(bn$1.parenL) ? (e3.value = this.parseExpression(), this.expect(bn$1.parenR), this.finishNode(e3, "DeclaredPredicate")) : this.finishNode(e3, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e3 = this.state.inType;
      this.state.inType = true, this.expect(bn$1.colon);
      let t2 = null, s2 = null;
      return this.match(bn$1.modulo) ? (this.state.inType = e3, s2 = this.flowParsePredicate()) : (t2 = this.flowParseType(), this.state.inType = e3, this.match(bn$1.modulo) && (s2 = this.flowParsePredicate())), [t2, s2];
    }
    flowParseDeclareClass(e3) {
      return this.next(), this.flowParseInterfaceish(e3, true), this.finishNode(e3, "DeclareClass");
    }
    flowParseDeclareFunction(e3) {
      this.next();
      const t2 = e3.id = this.parseIdentifier(), s2 = this.startNode(), r2 = this.startNode();
      this.isRelational("<") ? s2.typeParameters = this.flowParseTypeParameterDeclaration() : s2.typeParameters = null, this.expect(bn$1.parenL);
      const i2 = this.flowParseFunctionTypeParams();
      return s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(bn$1.parenR), [s2.returnType, e3.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(s2, "FunctionTypeAnnotation"), t2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(t2), this.semicolon(), this.scope.declareName(e3.id.name, 2048, e3.id.start), this.finishNode(e3, "DeclareFunction");
    }
    flowParseDeclare(e3, t2) {
      if (this.match(bn$1._class))
        return this.flowParseDeclareClass(e3);
      if (this.match(bn$1._function))
        return this.flowParseDeclareFunction(e3);
      if (this.match(bn$1._var))
        return this.flowParseDeclareVariable(e3);
      if (this.eatContextual("module"))
        return this.match(bn$1.dot) ? this.flowParseDeclareModuleExports(e3) : (t2 && this.raise(this.state.lastTokStart, Lo$1.NestedDeclareModule), this.flowParseDeclareModule(e3));
      if (this.isContextual("type"))
        return this.flowParseDeclareTypeAlias(e3);
      if (this.isContextual("opaque"))
        return this.flowParseDeclareOpaqueType(e3);
      if (this.isContextual("interface"))
        return this.flowParseDeclareInterface(e3);
      if (this.match(bn$1._export))
        return this.flowParseDeclareExportDeclaration(e3, t2);
      throw this.unexpected();
    }
    flowParseDeclareVariable(e3) {
      return this.next(), e3.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e3.id.name, 5, e3.id.start), this.semicolon(), this.finishNode(e3, "DeclareVariable");
    }
    flowParseDeclareModule(e3) {
      this.scope.enter(0), this.match(bn$1.string) ? e3.id = this.parseExprAtom() : e3.id = this.parseIdentifier();
      const t2 = e3.body = this.startNode(), s2 = t2.body = [];
      for (this.expect(bn$1.braceL); !this.match(bn$1.braceR); ) {
        let e4 = this.startNode();
        this.match(bn$1._import) ? (this.next(), this.isContextual("type") || this.match(bn$1._typeof) || this.raise(this.state.lastTokStart, Lo$1.InvalidNonTypeImportInDeclareModule), this.parseImport(e4)) : (this.expectContextual("declare", Lo$1.UnsupportedStatementInDeclareModule), e4 = this.flowParseDeclare(e4, true)), s2.push(e4);
      }
      this.scope.exit(), this.expect(bn$1.braceR), this.finishNode(t2, "BlockStatement");
      let r2 = null, i2 = false;
      return s2.forEach((e4) => {
        !function(e5) {
          return e5.type === "DeclareExportAllDeclaration" || e5.type === "DeclareExportDeclaration" && (!e5.declaration || e5.declaration.type !== "TypeAlias" && e5.declaration.type !== "InterfaceDeclaration");
        }(e4) ? e4.type === "DeclareModuleExports" && (i2 && this.raise(e4.start, Lo$1.DuplicateDeclareModuleExports), r2 === "ES" && this.raise(e4.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "CommonJS", i2 = true) : (r2 === "CommonJS" && this.raise(e4.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "ES");
      }), e3.kind = r2 || "CommonJS", this.finishNode(e3, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e3, t2) {
      if (this.expect(bn$1._export), this.eat(bn$1._default))
        return this.match(bn$1._function) || this.match(bn$1._class) ? e3.declaration = this.flowParseDeclare(this.startNode()) : (e3.declaration = this.flowParseType(), this.semicolon()), e3.default = true, this.finishNode(e3, "DeclareExportDeclaration");
      if (this.match(bn$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !t2) {
        const e4 = this.state.value, t3 = Ro$1[e4];
        throw this.raise(this.state.start, Lo$1.UnsupportedDeclareExportKind, e4, t3);
      }
      if (this.match(bn$1._var) || this.match(bn$1._function) || this.match(bn$1._class) || this.isContextual("opaque"))
        return e3.declaration = this.flowParseDeclare(this.startNode()), e3.default = false, this.finishNode(e3, "DeclareExportDeclaration");
      if (this.match(bn$1.star) || this.match(bn$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
        return (e3 = this.parseExport(e3)).type === "ExportNamedDeclaration" && (e3.type = "ExportDeclaration", e3.default = false, delete e3.exportKind), e3.type = "Declare" + e3.type, e3;
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(e3) {
      return this.next(), this.expectContextual("exports"), e3.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e3, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e3) {
      return this.next(), this.flowParseTypeAlias(e3), e3.type = "DeclareTypeAlias", e3;
    }
    flowParseDeclareOpaqueType(e3) {
      return this.next(), this.flowParseOpaqueType(e3, true), e3.type = "DeclareOpaqueType", e3;
    }
    flowParseDeclareInterface(e3) {
      return this.next(), this.flowParseInterfaceish(e3), this.finishNode(e3, "DeclareInterface");
    }
    flowParseInterfaceish(e3, t2 = false) {
      if (e3.id = this.flowParseRestrictedIdentifier(!t2, true), this.scope.declareName(e3.id.name, t2 ? 17 : 9, e3.id.start), this.isRelational("<") ? e3.typeParameters = this.flowParseTypeParameterDeclaration() : e3.typeParameters = null, e3.extends = [], e3.implements = [], e3.mixins = [], this.eat(bn$1._extends))
        do {
          e3.extends.push(this.flowParseInterfaceExtends());
        } while (!t2 && this.eat(bn$1.comma));
      if (this.isContextual("mixins")) {
        this.next();
        do {
          e3.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      }
      if (this.isContextual("implements")) {
        this.next();
        do {
          e3.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      }
      e3.body = this.flowParseObjectType({ allowStatic: t2, allowExact: false, allowSpread: false, allowProto: t2, allowInexact: false });
    }
    flowParseInterfaceExtends() {
      const e3 = this.startNode();
      return e3.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? e3.typeParameters = this.flowParseTypeParameterInstantiation() : e3.typeParameters = null, this.finishNode(e3, "InterfaceExtends");
    }
    flowParseInterface(e3) {
      return this.flowParseInterfaceish(e3), this.finishNode(e3, "InterfaceDeclaration");
    }
    checkNotUnderscore(e3) {
      e3 === "_" && this.raise(this.state.start, Lo$1.UnexpectedReservedUnderscore);
    }
    checkReservedType(e3, t2, s2) {
      ko$1.has(e3) && this.raise(t2, s2 ? Lo$1.AssignReservedType : Lo$1.UnexpectedReservedType, e3);
    }
    flowParseRestrictedIdentifier(e3, t2) {
      return this.checkReservedType(this.state.value, this.state.start, t2), this.parseIdentifier(e3);
    }
    flowParseTypeAlias(e3) {
      return e3.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e3.id.name, 9, e3.id.start), this.isRelational("<") ? e3.typeParameters = this.flowParseTypeParameterDeclaration() : e3.typeParameters = null, e3.right = this.flowParseTypeInitialiser(bn$1.eq), this.semicolon(), this.finishNode(e3, "TypeAlias");
    }
    flowParseOpaqueType(e3, t2) {
      return this.expectContextual("type"), e3.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e3.id.name, 9, e3.id.start), this.isRelational("<") ? e3.typeParameters = this.flowParseTypeParameterDeclaration() : e3.typeParameters = null, e3.supertype = null, this.match(bn$1.colon) && (e3.supertype = this.flowParseTypeInitialiser(bn$1.colon)), e3.impltype = null, t2 || (e3.impltype = this.flowParseTypeInitialiser(bn$1.eq)), this.semicolon(), this.finishNode(e3, "OpaqueType");
    }
    flowParseTypeParameter(e3 = false) {
      const t2 = this.state.start, s2 = this.startNode(), r2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
      return s2.name = i2.name, s2.variance = r2, s2.bound = i2.typeAnnotation, this.match(bn$1.eq) ? (this.eat(bn$1.eq), s2.default = this.flowParseType()) : e3 && this.raise(t2, Lo$1.MissingTypeParamDefault), this.finishNode(s2, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e3 = this.state.inType, t2 = this.startNode();
      t2.params = [], this.state.inType = true, this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected();
      let s2 = false;
      do {
        const e4 = this.flowParseTypeParameter(s2);
        t2.params.push(e4), e4.default && (s2 = true), this.isRelational(">") || this.expect(bn$1.comma);
      } while (!this.isRelational(">"));
      return this.expectRelational(">"), this.state.inType = e3, this.finishNode(t2, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e3 = this.startNode(), t2 = this.state.inType;
      e3.params = [], this.state.inType = true, this.expectRelational("<");
      const s2 = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
        e3.params.push(this.flowParseType()), this.isRelational(">") || this.expect(bn$1.comma);
      return this.state.noAnonFunctionType = s2, this.expectRelational(">"), this.state.inType = t2, this.finishNode(e3, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e3 = this.startNode(), t2 = this.state.inType;
      for (e3.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
        e3.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(bn$1.comma);
      return this.expectRelational(">"), this.state.inType = t2, this.finishNode(e3, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e3 = this.startNode();
      if (this.expectContextual("interface"), e3.extends = [], this.eat(bn$1._extends))
        do {
          e3.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      return e3.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e3, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(bn$1.num) || this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e3, t2, s2) {
      return e3.static = t2, this.lookahead().type === bn$1.colon ? (e3.id = this.flowParseObjectPropertyKey(), e3.key = this.flowParseTypeInitialiser()) : (e3.id = null, e3.key = this.flowParseType()), this.expect(bn$1.bracketR), e3.value = this.flowParseTypeInitialiser(), e3.variance = s2, this.finishNode(e3, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e3, t2) {
      return e3.static = t2, e3.id = this.flowParseObjectPropertyKey(), this.expect(bn$1.bracketR), this.expect(bn$1.bracketR), this.isRelational("<") || this.match(bn$1.parenL) ? (e3.method = true, e3.optional = false, e3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e3.start, e3.loc.start))) : (e3.method = false, this.eat(bn$1.question) && (e3.optional = true), e3.value = this.flowParseTypeInitialiser()), this.finishNode(e3, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e3) {
      for (e3.params = [], e3.rest = null, e3.typeParameters = null, e3.this = null, this.isRelational("<") && (e3.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(bn$1.parenL), this.match(bn$1._this) && (e3.this = this.flowParseFunctionTypeParam(true), e3.this.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
        e3.params.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
      return this.eat(bn$1.ellipsis) && (e3.rest = this.flowParseFunctionTypeParam(false)), this.expect(bn$1.parenR), e3.returnType = this.flowParseTypeInitialiser(), this.finishNode(e3, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e3, t2) {
      const s2 = this.startNode();
      return e3.static = t2, e3.value = this.flowParseObjectTypeMethodish(s2), this.finishNode(e3, "ObjectTypeCallProperty");
    }
    flowParseObjectType({ allowStatic: e3, allowExact: t2, allowSpread: s2, allowProto: r2, allowInexact: i2 }) {
      const a2 = this.state.inType;
      this.state.inType = true;
      const n2 = this.startNode();
      let o2, u2;
      n2.callProperties = [], n2.properties = [], n2.indexers = [], n2.internalSlots = [];
      let h2 = false;
      for (t2 && this.match(bn$1.braceBarL) ? (this.expect(bn$1.braceBarL), o2 = bn$1.braceBarR, u2 = true) : (this.expect(bn$1.braceL), o2 = bn$1.braceR, u2 = false), n2.exact = u2; !this.match(o2); ) {
        let t3 = false, a3 = null, o3 = null;
        const c3 = this.startNode();
        if (r2 && this.isContextual("proto")) {
          const t4 = this.lookahead();
          t4.type !== bn$1.colon && t4.type !== bn$1.question && (this.next(), a3 = this.state.start, e3 = false);
        }
        if (e3 && this.isContextual("static")) {
          const e4 = this.lookahead();
          e4.type !== bn$1.colon && e4.type !== bn$1.question && (this.next(), t3 = true);
        }
        const p2 = this.flowParseVariance();
        if (this.eat(bn$1.bracketL))
          a3 != null && this.unexpected(a3), this.eat(bn$1.bracketL) ? (p2 && this.unexpected(p2.start), n2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, t3))) : n2.indexers.push(this.flowParseObjectTypeIndexer(c3, t3, p2));
        else if (this.match(bn$1.parenL) || this.isRelational("<"))
          a3 != null && this.unexpected(a3), p2 && this.unexpected(p2.start), n2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, t3));
        else {
          let e4 = "init";
          if (this.isContextual("get") || this.isContextual("set")) {
            const t4 = this.lookahead();
            t4.type !== bn$1.name && t4.type !== bn$1.string && t4.type !== bn$1.num || (e4 = this.state.value, this.next());
          }
          const r3 = this.flowParseObjectTypeProperty(c3, t3, a3, p2, e4, s2, i2 != null ? i2 : !u2);
          r3 === null ? (h2 = true, o3 = this.state.lastTokStart) : n2.properties.push(r3);
        }
        this.flowObjectTypeSemicolon(), !o3 || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.raise(o3, Lo$1.UnexpectedExplicitInexactInObject);
      }
      this.expect(o2), s2 && (n2.inexact = h2);
      const c2 = this.finishNode(n2, "ObjectTypeAnnotation");
      return this.state.inType = a2, c2;
    }
    flowParseObjectTypeProperty(e3, t2, s2, r2, i2, a2, n2) {
      if (this.eat(bn$1.ellipsis)) {
        return this.match(bn$1.comma) || this.match(bn$1.semi) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) ? (a2 ? n2 || this.raise(this.state.lastTokStart, Lo$1.InexactInsideExact) : this.raise(this.state.lastTokStart, Lo$1.InexactInsideNonObject), r2 && this.raise(r2.start, Lo$1.InexactVariance), null) : (a2 || this.raise(this.state.lastTokStart, Lo$1.UnexpectedSpreadType), s2 != null && this.unexpected(s2), r2 && this.raise(r2.start, Lo$1.SpreadVariance), e3.argument = this.flowParseType(), this.finishNode(e3, "ObjectTypeSpreadProperty"));
      }
      {
        e3.key = this.flowParseObjectPropertyKey(), e3.static = t2, e3.proto = s2 != null, e3.kind = i2;
        let n3 = false;
        return this.isRelational("<") || this.match(bn$1.parenL) ? (e3.method = true, s2 != null && this.unexpected(s2), r2 && this.unexpected(r2.start), e3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e3.start, e3.loc.start)), i2 !== "get" && i2 !== "set" || this.flowCheckGetterSetterParams(e3), !a2 && e3.key.name === "constructor" && e3.value.this && this.raise(e3.value.this.start, Lo$1.ThisParamBannedInConstructor)) : (i2 !== "init" && this.unexpected(), e3.method = false, this.eat(bn$1.question) && (n3 = true), e3.value = this.flowParseTypeInitialiser(), e3.variance = r2), e3.optional = n3, this.finishNode(e3, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e3) {
      const t2 = e3.kind === "get" ? 0 : 1, s2 = e3.start, r2 = e3.value.params.length + (e3.value.rest ? 1 : 0);
      e3.value.this && this.raise(e3.value.this.start, e3.kind === "get" ? Lo$1.GetterMayNotHaveThisParam : Lo$1.SetterMayNotHaveThisParam), r2 !== t2 && (e3.kind === "get" ? this.raise(s2, Rn$1.BadGetterArity) : this.raise(s2, Rn$1.BadSetterArity)), e3.kind === "set" && e3.value.rest && this.raise(s2, Rn$1.BadSetterRestParameter);
    }
    flowObjectTypeSemicolon() {
      this.eat(bn$1.semi) || this.eat(bn$1.comma) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e3, t2, s2) {
      e3 = e3 || this.state.start, t2 = t2 || this.state.startLoc;
      let r2 = s2 || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(bn$1.dot); ) {
        const s3 = this.startNodeAt(e3, t2);
        s3.qualification = r2, s3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(s3, "QualifiedTypeIdentifier");
      }
      return r2;
    }
    flowParseGenericType(e3, t2, s2) {
      const r2 = this.startNodeAt(e3, t2);
      return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(e3, t2, s2), this.isRelational("<") && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e3 = this.startNode();
      return this.expect(bn$1._typeof), e3.argument = this.flowParsePrimaryType(), this.finishNode(e3, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e3 = this.startNode();
      for (e3.types = [], this.expect(bn$1.bracketL); this.state.pos < this.length && !this.match(bn$1.bracketR) && (e3.types.push(this.flowParseType()), !this.match(bn$1.bracketR)); )
        this.expect(bn$1.comma);
      return this.expect(bn$1.bracketR), this.finishNode(e3, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e3) {
      let t2 = null, s2 = false, r2 = null;
      const i2 = this.startNode(), a2 = this.lookahead(), n2 = this.state.type === bn$1._this;
      return a2.type === bn$1.colon || a2.type === bn$1.question ? (n2 && !e3 && this.raise(i2.start, Lo$1.ThisParamMustBeFirst), t2 = this.parseIdentifier(n2), this.eat(bn$1.question) && (s2 = true, n2 && this.raise(i2.start, Lo$1.ThisParamMayNotBeOptional)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), i2.name = t2, i2.optional = s2, i2.typeAnnotation = r2, this.finishNode(i2, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e3) {
      const t2 = this.startNodeAt(e3.start, e3.loc.start);
      return t2.name = null, t2.optional = false, t2.typeAnnotation = e3, this.finishNode(t2, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(e3 = []) {
      let t2 = null, s2 = null;
      for (this.match(bn$1._this) && (s2 = this.flowParseFunctionTypeParam(true), s2.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
        e3.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
      return this.eat(bn$1.ellipsis) && (t2 = this.flowParseFunctionTypeParam(false)), { params: e3, rest: t2, _this: s2 };
    }
    flowIdentToTypeAnnotation(e3, t2, s2, r2) {
      switch (r2.name) {
        case "any":
          return this.finishNode(s2, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s2, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s2, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s2, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s2, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s2, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s2, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r2.name), this.flowParseGenericType(e3, t2, r2);
      }
    }
    flowParsePrimaryType() {
      const e3 = this.state.start, t2 = this.state.startLoc, s2 = this.startNode();
      let r2, i2, a2 = false;
      const n2 = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case bn$1.name:
          return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e3, t2, s2, this.parseIdentifier());
        case bn$1.braceL:
          return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
        case bn$1.braceBarL:
          return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
        case bn$1.bracketL:
          return this.state.noAnonFunctionType = false, i2 = this.flowParseTupleType(), this.state.noAnonFunctionType = n2, i2;
        case bn$1.relational:
          if (this.state.value === "<")
            return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(bn$1.parenL), r2 = this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
          break;
        case bn$1.parenL:
          if (this.next(), !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis))
            if (this.match(bn$1.name) || this.match(bn$1._this)) {
              const e4 = this.lookahead().type;
              a2 = e4 !== bn$1.question && e4 !== bn$1.colon;
            } else
              a2 = true;
          if (a2) {
            if (this.state.noAnonFunctionType = false, i2 = this.flowParseType(), this.state.noAnonFunctionType = n2, this.state.noAnonFunctionType || !(this.match(bn$1.comma) || this.match(bn$1.parenR) && this.lookahead().type === bn$1.arrow))
              return this.expect(bn$1.parenR), i2;
            this.eat(bn$1.comma);
          }
          return r2 = i2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i2)]) : this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
        case bn$1.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case bn$1._true:
        case bn$1._false:
          return s2.value = this.match(bn$1._true), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
        case bn$1.plusMin:
          if (this.state.value === "-") {
            if (this.next(), this.match(bn$1.num))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
            if (this.match(bn$1.bigint))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
            throw this.raise(this.state.start, Lo$1.UnexpectedSubtractionOperand);
          }
          throw this.unexpected();
        case bn$1.num:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case bn$1.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case bn$1._void:
          return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
        case bn$1._null:
          return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
        case bn$1._this:
          return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
        case bn$1.star:
          return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
        default:
          if (this.state.type.keyword === "typeof")
            return this.flowParseTypeofType();
          if (this.state.type.keyword) {
            const e4 = this.state.type.label;
            return this.next(), super.createIdentifier(s2, e4);
          }
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const e3 = this.state.start, t2 = this.state.startLoc;
      let s2 = this.flowParsePrimaryType(), r2 = false;
      for (; (this.match(bn$1.bracketL) || this.match(bn$1.questionDot)) && !this.canInsertSemicolon(); ) {
        const i2 = this.startNodeAt(e3, t2), a2 = this.eat(bn$1.questionDot);
        r2 = r2 || a2, this.expect(bn$1.bracketL), !a2 && this.match(bn$1.bracketR) ? (i2.elementType = s2, this.next(), s2 = this.finishNode(i2, "ArrayTypeAnnotation")) : (i2.objectType = s2, i2.indexType = this.flowParseType(), this.expect(bn$1.bracketR), r2 ? (i2.optional = a2, s2 = this.finishNode(i2, "OptionalIndexedAccessType")) : s2 = this.finishNode(i2, "IndexedAccessType"));
      }
      return s2;
    }
    flowParsePrefixType() {
      const e3 = this.startNode();
      return this.eat(bn$1.question) ? (e3.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e3, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e3 = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(bn$1.arrow)) {
        const t2 = this.startNodeAt(e3.start, e3.loc.start);
        return t2.params = [this.reinterpretTypeAsFunctionTypeParam(e3)], t2.rest = null, t2.this = null, t2.returnType = this.flowParseType(), t2.typeParameters = null, this.finishNode(t2, "FunctionTypeAnnotation");
      }
      return e3;
    }
    flowParseIntersectionType() {
      const e3 = this.startNode();
      this.eat(bn$1.bitwiseAND);
      const t2 = this.flowParseAnonFunctionWithoutParens();
      for (e3.types = [t2]; this.eat(bn$1.bitwiseAND); )
        e3.types.push(this.flowParseAnonFunctionWithoutParens());
      return e3.types.length === 1 ? t2 : this.finishNode(e3, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e3 = this.startNode();
      this.eat(bn$1.bitwiseOR);
      const t2 = this.flowParseIntersectionType();
      for (e3.types = [t2]; this.eat(bn$1.bitwiseOR); )
        e3.types.push(this.flowParseIntersectionType());
      return e3.types.length === 1 ? t2 : this.finishNode(e3, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e3 = this.state.inType;
      this.state.inType = true;
      const t2 = this.flowParseUnionType();
      return this.state.inType = e3, t2;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === bn$1.name && this.state.value === "_") {
        const e3 = this.state.start, t2 = this.state.startLoc, s2 = this.parseIdentifier();
        return this.flowParseGenericType(e3, t2, s2);
      }
      return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e3 = this.startNode();
      return e3.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e3, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e3) {
      const t2 = e3 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(bn$1.colon) && (t2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t2)), t2;
    }
    typeCastToParameter(e3) {
      return e3.expression.typeAnnotation = e3.typeAnnotation, this.resetEndLocation(e3.expression, e3.typeAnnotation.end, e3.typeAnnotation.loc.end), e3.expression;
    }
    flowParseVariance() {
      let e3 = null;
      return this.match(bn$1.plusMin) && (e3 = this.startNode(), this.state.value === "+" ? e3.kind = "plus" : e3.kind = "minus", this.next(), this.finishNode(e3, "Variance")), e3;
    }
    parseFunctionBody(e3, t2, s2 = false) {
      return t2 ? this.forwardNoArrowParamsConversionAt(e3, () => super.parseFunctionBody(e3, true, s2)) : super.parseFunctionBody(e3, false, s2);
    }
    parseFunctionBodyAndFinish(e3, t2, s2 = false) {
      if (this.match(bn$1.colon)) {
        const t3 = this.startNode();
        [t3.typeAnnotation, e3.predicate] = this.flowParseTypeAndPredicateInitialiser(), e3.returnType = t3.typeAnnotation ? this.finishNode(t3, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(e3, t2, s2);
    }
    parseStatement(e3, t2) {
      if (this.state.strict && this.match(bn$1.name) && this.state.value === "interface") {
        const e4 = this.lookahead();
        if (e4.type === bn$1.name || oo$1(e4.value)) {
          const e5 = this.startNode();
          return this.next(), this.flowParseInterface(e5);
        }
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        const e4 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e4);
      }
      const s2 = super.parseStatement(e3, t2);
      return this.flowPragma !== void 0 || this.isValidDirective(s2) || (this.flowPragma = null), s2;
    }
    parseExpressionStatement(e3, t2) {
      if (t2.type === "Identifier") {
        if (t2.name === "declare") {
          if (this.match(bn$1._class) || this.match(bn$1.name) || this.match(bn$1._function) || this.match(bn$1._var) || this.match(bn$1._export))
            return this.flowParseDeclare(e3);
        } else if (this.match(bn$1.name)) {
          if (t2.name === "interface")
            return this.flowParseInterface(e3);
          if (t2.name === "type")
            return this.flowParseTypeAlias(e3);
          if (t2.name === "opaque")
            return this.flowParseOpaqueType(e3, false);
        }
      }
      return super.parseExpressionStatement(e3, t2);
    }
    shouldParseExportDeclaration() {
      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      return (!this.match(bn$1.name) || !(this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) && super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        const e3 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e3);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e3, t2, s2, r2) {
      if (!this.match(bn$1.question))
        return e3;
      if (this.state.maybeInArrowParameters) {
        const t3 = this.lookaheadCharCode();
        if (t3 === 44 || t3 === 61 || t3 === 58 || t3 === 41)
          return this.setOptionalParametersError(r2), e3;
      }
      this.expect(bn$1.question);
      const i2 = this.state.clone(), a2 = this.state.noArrowAt, n2 = this.startNodeAt(t2, s2);
      let { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent(), [h2, c2] = this.getArrowLikeExpressions(o2);
      if (u2 || c2.length > 0) {
        const e4 = [...a2];
        if (c2.length > 0) {
          this.state = i2, this.state.noArrowAt = e4;
          for (let t3 = 0; t3 < c2.length; t3++)
            e4.push(c2[t3].start);
          ({ consequent: o2, failed: u2 } = this.tryParseConditionalConsequent()), [h2, c2] = this.getArrowLikeExpressions(o2);
        }
        u2 && h2.length > 1 && this.raise(i2.start, Lo$1.AmbiguousConditionalArrow), u2 && h2.length === 1 && (this.state = i2, e4.push(h2[0].start), this.state.noArrowAt = e4, { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = a2, this.expect(bn$1.colon), n2.test = e3, n2.consequent = o2, n2.alternate = this.forwardNoArrowParamsConversionAt(n2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(n2, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e3 = this.parseMaybeAssignAllowIn(), t2 = !this.match(bn$1.colon);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: e3, failed: t2 };
    }
    getArrowLikeExpressions(e3, t2) {
      const s2 = [e3], r2 = [];
      for (; s2.length !== 0; ) {
        const e4 = s2.pop();
        e4.type === "ArrowFunctionExpression" ? (e4.typeParameters || !e4.returnType ? this.finishArrowValidation(e4) : r2.push(e4), s2.push(e4.body)) : e4.type === "ConditionalExpression" && (s2.push(e4.consequent), s2.push(e4.alternate));
      }
      return t2 ? (r2.forEach((e4) => this.finishArrowValidation(e4)), [r2, []]) : function(e4, t3) {
        const s3 = [], r3 = [];
        for (let i2 = 0; i2 < e4.length; i2++)
          (t3(e4[i2], i2, e4) ? s3 : r3).push(e4[i2]);
        return [s3, r3];
      }(r2, (e4) => e4.params.every((e5) => this.isAssignable(e5, true)));
    }
    finishArrowValidation(e3) {
      var t2;
      this.toAssignableList(e3.params, (t2 = e3.extra) == null ? void 0 : t2.trailingComma, false), this.scope.enter(6), super.checkParams(e3, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e3, t2) {
      let s2;
      return this.state.noArrowParamsConversionAt.indexOf(e3.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s2 = t2(), this.state.noArrowParamsConversionAt.pop()) : s2 = t2(), s2;
    }
    parseParenItem(e3, t2, s2) {
      if (e3 = super.parseParenItem(e3, t2, s2), this.eat(bn$1.question) && (e3.optional = true, this.resetEndLocation(e3)), this.match(bn$1.colon)) {
        const r2 = this.startNodeAt(t2, s2);
        return r2.expression = e3, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
      }
      return e3;
    }
    assertModuleNodeAllowed(e3) {
      e3.type === "ImportDeclaration" && (e3.importKind === "type" || e3.importKind === "typeof") || e3.type === "ExportNamedDeclaration" && e3.exportKind === "type" || e3.type === "ExportAllDeclaration" && e3.exportKind === "type" || super.assertModuleNodeAllowed(e3);
    }
    parseExport(e3) {
      const t2 = super.parseExport(e3);
      return t2.type !== "ExportNamedDeclaration" && t2.type !== "ExportAllDeclaration" || (t2.exportKind = t2.exportKind || "value"), t2;
    }
    parseExportDeclaration(e3) {
      if (this.isContextual("type")) {
        e3.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.match(bn$1.braceL) ? (e3.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(e3), null) : this.flowParseTypeAlias(t2);
      }
      if (this.isContextual("opaque")) {
        e3.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.flowParseOpaqueType(t2, false);
      }
      if (this.isContextual("interface")) {
        e3.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.flowParseInterface(t2);
      }
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        e3.exportKind = "value";
        const t2 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t2);
      }
      return super.parseExportDeclaration(e3);
    }
    eatExportStar(e3) {
      return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== bn$1.star) && (e3.exportKind = "type", this.next(), this.next(), true);
    }
    maybeParseExportNamespaceSpecifier(e3) {
      const t2 = this.state.start, s2 = super.maybeParseExportNamespaceSpecifier(e3);
      return s2 && e3.exportKind === "type" && this.unexpected(t2), s2;
    }
    parseClassId(e3, t2, s2) {
      super.parseClassId(e3, t2, s2), this.isRelational("<") && (e3.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e3, t2, s2) {
      const r2 = this.state.start;
      if (this.isContextual("declare")) {
        if (this.parseClassMemberFromModifier(e3, t2))
          return;
        t2.declare = true;
      }
      super.parseClassMember(e3, t2, s2), t2.declare && (t2.type !== "ClassProperty" && t2.type !== "ClassPrivateProperty" && t2.type !== "PropertyDefinition" ? this.raise(r2, Lo$1.DeclareClassElement) : t2.value && this.raise(t2.value.start, Lo$1.DeclareClassFieldInitializer));
    }
    isIterator(e3) {
      return e3 === "iterator" || e3 === "asyncIterator";
    }
    readIterator() {
      const e3 = super.readWord1(), t2 = "@@" + e3;
      this.isIterator(e3) && this.state.inType || this.raise(this.state.pos, Rn$1.InvalidIdentifier, t2), this.finishToken(bn$1.name, t2);
    }
    getTokenFromCode(e3) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      return e3 === 123 && t2 === 124 ? this.finishOp(bn$1.braceBarL, 2) : !this.state.inType || e3 !== 62 && e3 !== 60 ? this.state.inType && e3 === 63 ? t2 === 46 ? this.finishOp(bn$1.questionDot, 2) : this.finishOp(bn$1.question, 1) : function(e4, t3) {
        return e4 === 64 && t3 === 64;
      }(e3, t2) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e3) : this.finishOp(bn$1.relational, 1);
    }
    isAssignable(e3, t2) {
      return e3.type === "TypeCastExpression" ? this.isAssignable(e3.expression, t2) : super.isAssignable(e3, t2);
    }
    toAssignable(e3, t2 = false) {
      return e3.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(e3), t2) : super.toAssignable(e3, t2);
    }
    toAssignableList(e3, t2, s2) {
      for (let t3 = 0; t3 < e3.length; t3++) {
        const s3 = e3[t3];
        (s3 == null ? void 0 : s3.type) === "TypeCastExpression" && (e3[t3] = this.typeCastToParameter(s3));
      }
      return super.toAssignableList(e3, t2, s2);
    }
    toReferencedList(e3, t2) {
      for (let r2 = 0; r2 < e3.length; r2++) {
        var s2;
        const i2 = e3[r2];
        !i2 || i2.type !== "TypeCastExpression" || (s2 = i2.extra) != null && s2.parenthesized || !(e3.length > 1) && t2 || this.raise(i2.typeAnnotation.start, Lo$1.TypeCastInPattern);
      }
      return e3;
    }
    parseArrayLike(e3, t2, s2, r2) {
      const i2 = super.parseArrayLike(e3, t2, s2, r2);
      return t2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
    }
    checkLVal(e3, ...t2) {
      if (e3.type !== "TypeCastExpression")
        return super.checkLVal(e3, ...t2);
    }
    parseClassProperty(e3) {
      return this.match(bn$1.colon) && (e3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e3);
    }
    parseClassPrivateProperty(e3) {
      return this.match(bn$1.colon) && (e3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e3);
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(bn$1.colon) || super.isClassProperty();
    }
    isNonstaticConstructor(e3) {
      return !this.match(bn$1.colon) && super.isNonstaticConstructor(e3);
    }
    pushClassMethod(e3, t2, s2, r2, i2, a2) {
      if (t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e3, t2, s2, r2, i2, a2), t2.params && i2) {
        const e4 = t2.params;
        e4.length > 0 && this.isThisParam(e4[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
      } else if (t2.type === "MethodDefinition" && i2 && t2.value.params) {
        const e4 = t2.value.params;
        e4.length > 0 && this.isThisParam(e4[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
      }
    }
    pushClassPrivateMethod(e3, t2, s2, r2) {
      t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e3, t2, s2, r2);
    }
    parseClassSuper(e3) {
      if (super.parseClassSuper(e3), e3.superClass && this.isRelational("<") && (e3.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
        this.next();
        const t2 = e3.implements = [];
        do {
          const e4 = this.startNode();
          e4.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? e4.typeParameters = this.flowParseTypeParameterInstantiation() : e4.typeParameters = null, t2.push(this.finishNode(e4, "ClassImplements"));
        } while (this.eat(bn$1.comma));
      }
    }
    checkGetterSetterParams(e3) {
      super.checkGetterSetterParams(e3);
      const t2 = this.getObjectOrClassMethodParams(e3);
      if (t2.length > 0) {
        const s2 = t2[0];
        this.isThisParam(s2) && e3.kind === "get" ? this.raise(s2.start, Lo$1.GetterMayNotHaveThisParam) : this.isThisParam(s2) && this.raise(s2.start, Lo$1.SetterMayNotHaveThisParam);
      }
    }
    parsePropertyName(e3, t2) {
      const s2 = this.flowParseVariance(), r2 = super.parsePropertyName(e3, t2);
      return e3.variance = s2, r2;
    }
    parseObjPropValue(e3, t2, s2, r2, i2, a2, n2, o2) {
      let u2;
      e3.variance && this.unexpected(e3.variance.start), delete e3.variance, this.isRelational("<") && !n2 && (u2 = this.flowParseTypeParameterDeclaration(), this.match(bn$1.parenL) || this.unexpected()), super.parseObjPropValue(e3, t2, s2, r2, i2, a2, n2, o2), u2 && ((e3.value || e3).typeParameters = u2);
    }
    parseAssignableListItemTypes(e3) {
      return this.eat(bn$1.question) && (e3.type !== "Identifier" && this.raise(e3.start, Lo$1.PatternIsOptional), this.isThisParam(e3) && this.raise(e3.start, Lo$1.ThisParamMayNotBeOptional), e3.optional = true), this.match(bn$1.colon) ? e3.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e3) && this.raise(e3.start, Lo$1.ThisParamAnnotationRequired), this.match(bn$1.eq) && this.isThisParam(e3) && this.raise(e3.start, Lo$1.ThisParamNoDefault), this.resetEndLocation(e3), e3;
    }
    parseMaybeDefault(e3, t2, s2) {
      const r2 = super.parseMaybeDefault(e3, t2, s2);
      return r2.type === "AssignmentPattern" && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, Lo$1.TypeBeforeInitializer), r2;
    }
    shouldParseDefaultImport(e3) {
      return Oo$1(e3) ? Mo(this.state) : super.shouldParseDefaultImport(e3);
    }
    parseImportSpecifierLocal(e3, t2, s2, r2) {
      t2.local = Oo$1(e3) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e3.specifiers.push(this.finishNode(t2, s2));
    }
    maybeParseDefaultImportSpecifier(e3) {
      e3.importKind = "value";
      let t2 = null;
      if (this.match(bn$1._typeof) ? t2 = "typeof" : this.isContextual("type") && (t2 = "type"), t2) {
        const s2 = this.lookahead();
        t2 === "type" && s2.type === bn$1.star && this.unexpected(s2.start), (Mo(s2) || s2.type === bn$1.braceL || s2.type === bn$1.star) && (this.next(), e3.importKind = t2);
      }
      return super.maybeParseDefaultImportSpecifier(e3);
    }
    parseImportSpecifier(e3) {
      const t2 = this.startNode(), s2 = this.match(bn$1.string), r2 = this.parseModuleExportName();
      let i2 = null;
      r2.type === "Identifier" && (r2.name === "type" ? i2 = "type" : r2.name === "typeof" && (i2 = "typeof"));
      let a2 = false;
      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
        const e4 = this.parseIdentifier(true);
        i2 === null || this.match(bn$1.name) || this.state.type.keyword ? (t2.imported = r2, t2.importKind = null, t2.local = this.parseIdentifier()) : (t2.imported = e4, t2.importKind = i2, t2.local = Io$1(e4));
      } else {
        if (i2 !== null && (this.match(bn$1.name) || this.state.type.keyword))
          t2.imported = this.parseIdentifier(true), t2.importKind = i2;
        else {
          if (s2)
            throw this.raise(t2.start, Rn$1.ImportBindingIsString, r2.value);
          t2.imported = r2, t2.importKind = null;
        }
        this.eatContextual("as") ? t2.local = this.parseIdentifier() : (a2 = true, t2.local = Io$1(t2.imported));
      }
      const n2 = Oo$1(e3), o2 = Oo$1(t2);
      n2 && o2 && this.raise(t2.start, Lo$1.ImportTypeShorthandOnlyInPureImport), (n2 || o2) && this.checkReservedType(t2.local.name, t2.local.start, true), !a2 || n2 || o2 || this.checkReservedWord(t2.local.name, t2.start, true, true), this.checkLVal(t2.local, "import specifier", 9), e3.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e3, t2) {
      const s2 = e3.kind;
      s2 !== "get" && s2 !== "set" && this.isRelational("<") && (e3.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e3, t2);
    }
    parseVarId(e3, t2) {
      super.parseVarId(e3, t2), this.match(bn$1.colon) && (e3.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e3.id));
    }
    parseAsyncArrowFromCallExpression(e3, t2) {
      if (this.match(bn$1.colon)) {
        const t3 = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e3.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t3;
      }
      return super.parseAsyncArrowFromCallExpression(e3, t2);
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e3, t2) {
      var s2;
      let r2, i2 = null;
      if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
        if (i2 = this.state.clone(), r2 = this.tryParse(() => super.parseMaybeAssign(e3, t2), i2), !r2.error)
          return r2.node;
        const { context: s3 } = this.state, a3 = s3[s3.length - 1];
        a3 === $n$1.j_oTag ? s3.length -= 2 : a3 === $n$1.j_expr && (s3.length -= 1);
      }
      if ((s2 = r2) != null && s2.error || this.isRelational("<")) {
        var a2, n2;
        let s3;
        i2 = i2 || this.state.clone();
        const o2 = this.tryParse((r3) => {
          var i3;
          s3 = this.flowParseTypeParameterDeclaration();
          const a3 = this.forwardNoArrowParamsConversionAt(s3, () => {
            const r4 = super.parseMaybeAssign(e3, t2);
            return this.resetStartLocationFromNode(r4, s3), r4;
          });
          (i3 = a3.extra) != null && i3.parenthesized && r3();
          const n3 = this.maybeUnwrapTypeCastExpression(a3);
          return n3.type !== "ArrowFunctionExpression" && r3(), n3.typeParameters = s3, this.resetStartLocationFromNode(n3, s3), a3;
        }, i2);
        let u2 = null;
        if (o2.node && this.maybeUnwrapTypeCastExpression(o2.node).type === "ArrowFunctionExpression") {
          if (!o2.error && !o2.aborted)
            return o2.node.async && this.raise(s3.start, Lo$1.UnexpectedTypeParameterBeforeAsyncArrowFunction), o2.node;
          u2 = o2.node;
        }
        if ((a2 = r2) != null && a2.node)
          return this.state = r2.failState, r2.node;
        if (u2)
          return this.state = o2.failState, u2;
        if ((n2 = r2) != null && n2.thrown)
          throw r2.error;
        if (o2.thrown)
          throw o2.error;
        throw this.raise(s3.start, Lo$1.UnexpectedTokenAfterTypeParameter);
      }
      return super.parseMaybeAssign(e3, t2);
    }
    parseArrow(e3) {
      if (this.match(bn$1.colon)) {
        const t2 = this.tryParse(() => {
          const t3 = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const s2 = this.startNode();
          return [s2.typeAnnotation, e3.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t3, this.canInsertSemicolon() && this.unexpected(), this.match(bn$1.arrow) || this.unexpected(), s2;
        });
        if (t2.thrown)
          return null;
        t2.error && (this.state = t2.failState), e3.returnType = t2.node.typeAnnotation ? this.finishNode(t2.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e3);
    }
    shouldParseArrow(e3) {
      return this.match(bn$1.colon) || super.shouldParseArrow(e3);
    }
    setArrowFunctionParameters(e3, t2) {
      this.state.noArrowParamsConversionAt.indexOf(e3.start) !== -1 ? e3.params = t2 : super.setArrowFunctionParameters(e3, t2);
    }
    checkParams(e3, t2, s2) {
      if (!s2 || this.state.noArrowParamsConversionAt.indexOf(e3.start) === -1) {
        for (let t3 = 0; t3 < e3.params.length; t3++)
          this.isThisParam(e3.params[t3]) && t3 > 0 && this.raise(e3.params[t3].start, Lo$1.ThisParamMustBeFirst);
        return super.checkParams(...arguments);
      }
    }
    parseParenAndDistinguishExpression(e3) {
      return super.parseParenAndDistinguishExpression(e3 && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e3, t2, s2, r2) {
      if (e3.type === "Identifier" && e3.name === "async" && this.state.noArrowAt.indexOf(t2) !== -1) {
        this.next();
        const r3 = this.startNodeAt(t2, s2);
        r3.callee = e3, r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), e3 = this.finishNode(r3, "CallExpression");
      } else if (e3.type === "Identifier" && e3.name === "async" && this.isRelational("<")) {
        const i2 = this.state.clone(), a2 = this.tryParse((e4) => this.parseAsyncArrowWithTypeParameters(t2, s2) || e4(), i2);
        if (!a2.error && !a2.aborted)
          return a2.node;
        const n2 = this.tryParse(() => super.parseSubscripts(e3, t2, s2, r2), i2);
        if (n2.node && !n2.error)
          return n2.node;
        if (a2.node)
          return this.state = a2.failState, a2.node;
        if (n2.node)
          return this.state = n2.failState, n2.node;
        throw a2.error || n2.error;
      }
      return super.parseSubscripts(e3, t2, s2, r2);
    }
    parseSubscript(e3, t2, s2, r2, i2) {
      if (this.match(bn$1.questionDot) && this.isLookaheadToken_lt()) {
        if (i2.optionalChainMember = true, r2)
          return i2.stop = true, e3;
        this.next();
        const a2 = this.startNodeAt(t2, s2);
        return a2.callee = e3, a2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(bn$1.parenL), a2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), a2.optional = true, this.finishCallExpression(a2, true);
      }
      if (!r2 && this.shouldParseTypes() && this.isRelational("<")) {
        const r3 = this.startNodeAt(t2, s2);
        r3.callee = e3;
        const a2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(bn$1.parenL), r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), i2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, i2.optionalChainMember)));
        if (a2.node)
          return a2.error && (this.state = a2.failState), a2.node;
      }
      return super.parseSubscript(e3, t2, s2, r2, i2);
    }
    parseNewArguments(e3) {
      let t2 = null;
      this.shouldParseTypes() && this.isRelational("<") && (t2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e3.typeArguments = t2, super.parseNewArguments(e3);
    }
    parseAsyncArrowWithTypeParameters(e3, t2) {
      const s2 = this.startNodeAt(e3, t2);
      if (this.parseFunctionParams(s2), this.parseArrow(s2))
        return this.parseArrowExpression(s2, void 0, true);
    }
    readToken_mult_modulo(e3) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      if (e3 === 42 && t2 === 47 && this.state.hasFlowComment)
        return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
      super.readToken_mult_modulo(e3);
    }
    readToken_pipe_amp(e3) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      e3 !== 124 || t2 !== 125 ? super.readToken_pipe_amp(e3) : this.finishOp(bn$1.braceBarR, 2);
    }
    parseTopLevel(e3, t2) {
      const s2 = super.parseTopLevel(e3, t2);
      return this.state.hasFlowComment && this.raise(this.state.pos, Lo$1.UnterminatedFlowComment), s2;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment())
        return this.state.hasFlowComment && this.unexpected(null, Lo$1.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
      if (!this.state.hasFlowComment)
        return super.skipBlockComment();
      {
        const e3 = this.input.indexOf("*-/", this.state.pos += 2);
        if (e3 === -1)
          throw this.raise(this.state.pos - 2, Rn$1.UnterminatedComment);
        this.state.pos = e3 + 3;
      }
    }
    skipFlowComment() {
      const { pos: e3 } = this.state;
      let t2 = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e3 + t2)); )
        t2++;
      const s2 = this.input.charCodeAt(t2 + e3), r2 = this.input.charCodeAt(t2 + e3 + 1);
      return s2 === 58 && r2 === 58 ? t2 + 2 : this.input.slice(t2 + e3, t2 + e3 + 12) === "flow-include" ? t2 + 12 : s2 === 58 && r2 !== 58 && t2;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(this.state.pos, Rn$1.UnterminatedComment);
    }
    flowEnumErrorBooleanMemberNotInitialized(e3, { enumName: t2, memberName: s2 }) {
      this.raise(e3, Lo$1.EnumBooleanMemberNotInitialized, s2, t2);
    }
    flowEnumErrorInvalidMemberName(e3, { enumName: t2, memberName: s2 }) {
      const r2 = s2[0].toUpperCase() + s2.slice(1);
      this.raise(e3, Lo$1.EnumInvalidMemberName, s2, r2, t2);
    }
    flowEnumErrorDuplicateMemberName(e3, { enumName: t2, memberName: s2 }) {
      this.raise(e3, Lo$1.EnumDuplicateMemberName, s2, t2);
    }
    flowEnumErrorInconsistentMemberValues(e3, { enumName: t2 }) {
      this.raise(e3, Lo$1.EnumInconsistentMemberValues, t2);
    }
    flowEnumErrorInvalidExplicitType(e3, { enumName: t2, suppliedType: s2 }) {
      return this.raise(e3, s2 === null ? Lo$1.EnumInvalidExplicitTypeUnknownSupplied : Lo$1.EnumInvalidExplicitType, t2, s2);
    }
    flowEnumErrorInvalidMemberInitializer(e3, { enumName: t2, explicitType: s2, memberName: r2 }) {
      let i2 = null;
      switch (s2) {
        case "boolean":
        case "number":
        case "string":
          i2 = Lo$1.EnumInvalidMemberInitializerPrimaryType;
          break;
        case "symbol":
          i2 = Lo$1.EnumInvalidMemberInitializerSymbolType;
          break;
        default:
          i2 = Lo$1.EnumInvalidMemberInitializerUnknownType;
      }
      return this.raise(e3, i2, t2, r2, s2);
    }
    flowEnumErrorNumberMemberNotInitialized(e3, { enumName: t2, memberName: s2 }) {
      this.raise(e3, Lo$1.EnumNumberMemberNotInitialized, t2, s2);
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e3, { enumName: t2 }) {
      this.raise(e3, Lo$1.EnumStringMemberInconsistentlyInitailized, t2);
    }
    flowEnumMemberInit() {
      const e3 = this.state.start, t2 = () => this.match(bn$1.comma) || this.match(bn$1.braceR);
      switch (this.state.type) {
        case bn$1.num: {
          const s2 = this.parseNumericLiteral(this.state.value);
          return t2() ? { type: "number", pos: s2.start, value: s2 } : { type: "invalid", pos: e3 };
        }
        case bn$1.string: {
          const s2 = this.parseStringLiteral(this.state.value);
          return t2() ? { type: "string", pos: s2.start, value: s2 } : { type: "invalid", pos: e3 };
        }
        case bn$1._true:
        case bn$1._false: {
          const s2 = this.parseBooleanLiteral(this.match(bn$1._true));
          return t2() ? { type: "boolean", pos: s2.start, value: s2 } : { type: "invalid", pos: e3 };
        }
        default:
          return { type: "invalid", pos: e3 };
      }
    }
    flowEnumMemberRaw() {
      const e3 = this.state.start;
      return { id: this.parseIdentifier(true), init: this.eat(bn$1.eq) ? this.flowEnumMemberInit() : { type: "none", pos: e3 } };
    }
    flowEnumCheckExplicitTypeMismatch(e3, t2, s2) {
      const { explicitType: r2 } = t2;
      r2 !== null && r2 !== s2 && this.flowEnumErrorInvalidMemberInitializer(e3, t2);
    }
    flowEnumMembers({ enumName: e3, explicitType: t2 }) {
      const s2 = new Set(), r2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
      let i2 = false;
      for (; !this.match(bn$1.braceR); ) {
        if (this.eat(bn$1.ellipsis)) {
          i2 = true;
          break;
        }
        const a2 = this.startNode(), { id: n2, init: o2 } = this.flowEnumMemberRaw(), u2 = n2.name;
        if (u2 === "")
          continue;
        /^[a-z]/.test(u2) && this.flowEnumErrorInvalidMemberName(n2.start, { enumName: e3, memberName: u2 }), s2.has(u2) && this.flowEnumErrorDuplicateMemberName(n2.start, { enumName: e3, memberName: u2 }), s2.add(u2);
        const h2 = { enumName: e3, explicitType: t2, memberName: u2 };
        switch (a2.id = n2, o2.type) {
          case "boolean":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "boolean"), a2.init = o2.value, r2.booleanMembers.push(this.finishNode(a2, "EnumBooleanMember"));
            break;
          case "number":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "number"), a2.init = o2.value, r2.numberMembers.push(this.finishNode(a2, "EnumNumberMember"));
            break;
          case "string":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "string"), a2.init = o2.value, r2.stringMembers.push(this.finishNode(a2, "EnumStringMember"));
            break;
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(o2.pos, h2);
          case "none":
            switch (t2) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(o2.pos, h2);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(o2.pos, h2);
                break;
              default:
                r2.defaultedMembers.push(this.finishNode(a2, "EnumDefaultedMember"));
            }
        }
        this.match(bn$1.braceR) || this.expect(bn$1.comma);
      }
      return { members: r2, hasUnknownMembers: i2 };
    }
    flowEnumStringMembers(e3, t2, { enumName: s2 }) {
      if (e3.length === 0)
        return t2;
      if (t2.length === 0)
        return e3;
      if (t2.length > e3.length) {
        for (const t3 of e3)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(t3.start, { enumName: s2 });
        return t2;
      }
      for (const e4 of t2)
        this.flowEnumErrorStringMemberInconsistentlyInitailized(e4.start, { enumName: s2 });
      return e3;
    }
    flowEnumParseExplicitType({ enumName: e3 }) {
      if (this.eatContextual("of")) {
        if (!this.match(bn$1.name))
          throw this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e3, suppliedType: null });
        const { value: t2 } = this.state;
        return this.next(), t2 !== "boolean" && t2 !== "number" && t2 !== "string" && t2 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e3, suppliedType: t2 }), t2;
      }
      return null;
    }
    flowEnumBody(e3, { enumName: t2, nameLoc: s2 }) {
      const r2 = this.flowEnumParseExplicitType({ enumName: t2 });
      this.expect(bn$1.braceL);
      const { members: i2, hasUnknownMembers: a2 } = this.flowEnumMembers({ enumName: t2, explicitType: r2 });
      switch (e3.hasUnknownMembers = a2, r2) {
        case "boolean":
          return e3.explicitType = true, e3.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e3, "EnumBooleanBody");
        case "number":
          return e3.explicitType = true, e3.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e3, "EnumNumberBody");
        case "string":
          return e3.explicitType = true, e3.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: t2 }), this.expect(bn$1.braceR), this.finishNode(e3, "EnumStringBody");
        case "symbol":
          return e3.members = i2.defaultedMembers, this.expect(bn$1.braceR), this.finishNode(e3, "EnumSymbolBody");
        default: {
          const r3 = () => (e3.members = [], this.expect(bn$1.braceR), this.finishNode(e3, "EnumStringBody"));
          e3.explicitType = false;
          const a3 = i2.booleanMembers.length, n2 = i2.numberMembers.length, o2 = i2.stringMembers.length, u2 = i2.defaultedMembers.length;
          if (a3 || n2 || o2 || u2) {
            if (a3 || n2) {
              if (!n2 && !o2 && a3 >= u2) {
                for (const e4 of i2.defaultedMembers)
                  this.flowEnumErrorBooleanMemberNotInitialized(e4.start, { enumName: t2, memberName: e4.id.name });
                return e3.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e3, "EnumBooleanBody");
              }
              if (!a3 && !o2 && n2 >= u2) {
                for (const e4 of i2.defaultedMembers)
                  this.flowEnumErrorNumberMemberNotInitialized(e4.start, { enumName: t2, memberName: e4.id.name });
                return e3.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e3, "EnumNumberBody");
              }
              return this.flowEnumErrorInconsistentMemberValues(s2, { enumName: t2 }), r3();
            }
            return e3.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: t2 }), this.expect(bn$1.braceR), this.finishNode(e3, "EnumStringBody");
          }
          return r3();
        }
      }
    }
    flowParseEnumDeclaration(e3) {
      const t2 = this.parseIdentifier();
      return e3.id = t2, e3.body = this.flowEnumBody(this.startNode(), { enumName: t2.name, nameLoc: t2.start }), this.finishNode(e3, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e3 = this.nextTokenStart();
      if (this.input.charCodeAt(e3) === 60) {
        const t2 = this.input.charCodeAt(e3 + 1);
        return t2 !== 60 && t2 !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e3) {
      return e3.type === "TypeCastExpression" ? e3.expression : e3;
    }
  }, typescript: (e2) => class extends e2 {
    getScopeHandler() {
      return Wo;
    }
    tsIsIdentifier() {
      return this.match(bn$1.name);
    }
    tsTokenCanFollowModifier() {
      return (this.match(bn$1.bracketL) || this.match(bn$1.braceL) || this.match(bn$1.star) || this.match(bn$1.ellipsis) || this.match(bn$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e3, t2) {
      if (!this.match(bn$1.name))
        return;
      const s2 = this.state.value;
      if (e3.indexOf(s2) !== -1) {
        if (t2 && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return s2;
      }
    }
    tsParseModifiers(e3, t2, s2, r2, i2) {
      const a2 = (t3, s3, r3, i3) => {
        s3 === r3 && e3[i3] && this.raise(t3, Xo.InvalidModifiersOrder, r3, i3);
      }, n2 = (t3, s3, r3, i3) => {
        (e3[r3] && s3 === i3 || e3[i3] && s3 === r3) && this.raise(t3, Xo.IncompatibleModifiers, r3, i3);
      };
      for (; ; ) {
        const o2 = this.state.start, u2 = this.tsParseModifier(t2.concat(s2 != null ? s2 : []), i2);
        if (!u2)
          break;
        Jo(u2) ? e3.accessibility ? this.raise(o2, Xo.DuplicateAccessibilityModifier) : (a2(o2, u2, u2, "override"), a2(o2, u2, u2, "static"), a2(o2, u2, u2, "readonly"), e3.accessibility = u2) : (Object.hasOwnProperty.call(e3, u2) ? this.raise(o2, Xo.DuplicateModifier, u2) : (a2(o2, u2, "static", "readonly"), a2(o2, u2, "static", "override"), a2(o2, u2, "override", "readonly"), a2(o2, u2, "abstract", "override"), n2(o2, u2, "declare", "override"), n2(o2, u2, "static", "abstract")), e3[u2] = true), s2 != null && s2.includes(u2) && this.raise(o2, r2, u2);
      }
    }
    tsIsListTerminator(e3) {
      switch (e3) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(bn$1.braceR);
        case "HeritageClauseElement":
          return this.match(bn$1.braceL);
        case "TupleElementTypes":
          return this.match(bn$1.bracketR);
        case "TypeParametersOrArguments":
          return this.isRelational(">");
      }
      throw new Error("Unreachable");
    }
    tsParseList(e3, t2) {
      const s2 = [];
      for (; !this.tsIsListTerminator(e3); )
        s2.push(t2());
      return s2;
    }
    tsParseDelimitedList(e3, t2) {
      return Go(this.tsParseDelimitedListWorker(e3, t2, true));
    }
    tsParseDelimitedListWorker(e3, t2, s2) {
      const r2 = [];
      for (; !this.tsIsListTerminator(e3); ) {
        const i2 = t2();
        if (i2 == null)
          return;
        if (r2.push(i2), !this.eat(bn$1.comma)) {
          if (this.tsIsListTerminator(e3))
            break;
          return void (s2 && this.expect(bn$1.comma));
        }
      }
      return r2;
    }
    tsParseBracketedList(e3, t2, s2, r2) {
      r2 || (s2 ? this.expect(bn$1.bracketL) : this.expectRelational("<"));
      const i2 = this.tsParseDelimitedList(e3, t2);
      return s2 ? this.expect(bn$1.bracketR) : this.expectRelational(">"), i2;
    }
    tsParseImportType() {
      const e3 = this.startNode();
      return this.expect(bn$1._import), this.expect(bn$1.parenL), this.match(bn$1.string) || this.raise(this.state.start, Xo.UnsupportedImportTypeArgument), e3.argument = this.parseExprAtom(), this.expect(bn$1.parenR), this.eat(bn$1.dot) && (e3.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (e3.typeParameters = this.tsParseTypeArguments()), this.finishNode(e3, "TSImportType");
    }
    tsParseEntityName(e3) {
      let t2 = this.parseIdentifier();
      for (; this.eat(bn$1.dot); ) {
        const s2 = this.startNodeAtNode(t2);
        s2.left = t2, s2.right = this.parseIdentifier(e3), t2 = this.finishNode(s2, "TSQualifiedName");
      }
      return t2;
    }
    tsParseTypeReference() {
      const e3 = this.startNode();
      return e3.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (e3.typeParameters = this.tsParseTypeArguments()), this.finishNode(e3, "TSTypeReference");
    }
    tsParseThisTypePredicate(e3) {
      this.next();
      const t2 = this.startNodeAtNode(e3);
      return t2.parameterName = e3, t2.typeAnnotation = this.tsParseTypeAnnotation(false), t2.asserts = false, this.finishNode(t2, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e3 = this.startNode();
      return this.next(), this.finishNode(e3, "TSThisType");
    }
    tsParseTypeQuery() {
      const e3 = this.startNode();
      return this.expect(bn$1._typeof), this.match(bn$1._import) ? e3.exprName = this.tsParseImportType() : e3.exprName = this.tsParseEntityName(true), this.finishNode(e3, "TSTypeQuery");
    }
    tsParseTypeParameter() {
      const e3 = this.startNode();
      return e3.name = this.tsParseTypeParameterName(), e3.constraint = this.tsEatThenParseType(bn$1._extends), e3.default = this.tsEatThenParseType(bn$1.eq), this.finishNode(e3, "TSTypeParameter");
    }
    tsTryParseTypeParameters() {
      if (this.isRelational("<"))
        return this.tsParseTypeParameters();
    }
    tsParseTypeParameters() {
      const e3 = this.startNode();
      return this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected(), e3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), e3.params.length === 0 && this.raise(e3.start, Xo.EmptyTypeParameters), this.finishNode(e3, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      return this.lookahead().type === bn$1._const ? (this.next(), this.tsParseTypeReference()) : null;
    }
    tsFillSignature(e3, t2) {
      const s2 = e3 === bn$1.arrow;
      t2.typeParameters = this.tsTryParseTypeParameters(), this.expect(bn$1.parenL), t2.parameters = this.tsParseBindingListForSignature(), (s2 || this.match(e3)) && (t2.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e3));
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(bn$1.parenR, 41).map((e3) => (e3.type !== "Identifier" && e3.type !== "RestElement" && e3.type !== "ObjectPattern" && e3.type !== "ArrayPattern" && this.raise(e3.start, Xo.UnsupportedSignatureParameterKind, e3.type), e3));
    }
    tsParseTypeMemberSemicolon() {
      this.eat(bn$1.comma) || this.isLineTerminator() || this.expect(bn$1.semi);
    }
    tsParseSignatureMember(e3, t2) {
      return this.tsFillSignature(bn$1.colon, t2), this.tsParseTypeMemberSemicolon(), this.finishNode(t2, e3);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), this.eat(bn$1.name) && this.match(bn$1.colon);
    }
    tsTryParseIndexSignature(e3) {
      if (!this.match(bn$1.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
        return;
      this.expect(bn$1.bracketL);
      const t2 = this.parseIdentifier();
      t2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t2), this.expect(bn$1.bracketR), e3.parameters = [t2];
      const s2 = this.tsTryParseTypeAnnotation();
      return s2 && (e3.typeAnnotation = s2), this.tsParseTypeMemberSemicolon(), this.finishNode(e3, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e3, t2) {
      this.eat(bn$1.question) && (e3.optional = true);
      const s2 = e3;
      if (this.match(bn$1.parenL) || this.isRelational("<")) {
        t2 && this.raise(e3.start, Xo.ReadonlyForMethodSignature);
        const r2 = s2;
        if (r2.kind && this.isRelational("<") && this.raise(this.state.pos, Xo.AccesorCannotHaveTypeParameters), this.tsFillSignature(bn$1.colon, r2), this.tsParseTypeMemberSemicolon(), r2.kind === "get")
          r2.parameters.length > 0 && (this.raise(this.state.pos, Rn$1.BadGetterArity), this.isThisParam(r2.parameters[0]) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter));
        else if (r2.kind === "set") {
          if (r2.parameters.length !== 1)
            this.raise(this.state.pos, Rn$1.BadSetterArity);
          else {
            const e4 = r2.parameters[0];
            this.isThisParam(e4) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter), e4.type === "Identifier" && e4.optional && this.raise(this.state.pos, Xo.SetAccesorCannotHaveOptionalParameter), e4.type === "RestElement" && this.raise(this.state.pos, Xo.SetAccesorCannotHaveRestParameter);
          }
          r2.typeAnnotation && this.raise(r2.typeAnnotation.start, Xo.SetAccesorCannotHaveReturnType);
        } else
          r2.kind = "method";
        return this.finishNode(r2, "TSMethodSignature");
      }
      {
        const e4 = s2;
        t2 && (e4.readonly = true);
        const r2 = this.tsTryParseTypeAnnotation();
        return r2 && (e4.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(e4, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e3 = this.startNode();
      if (this.match(bn$1.parenL) || this.isRelational("<"))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e3);
      if (this.match(bn$1._new)) {
        const t3 = this.startNode();
        return this.next(), this.match(bn$1.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e3) : (e3.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e3, false));
      }
      this.tsParseModifiers(e3, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], Xo.InvalidModifierOnTypeMember);
      const t2 = this.tsTryParseIndexSignature(e3);
      return t2 || (this.parsePropertyName(e3, false), e3.computed || e3.key.type !== "Identifier" || e3.key.name !== "get" && e3.key.name !== "set" || !this.tsTokenCanFollowModifier() || (e3.kind = e3.key.name, this.parsePropertyName(e3, false)), this.tsParsePropertyOrMethodSignature(e3, !!e3.readonly));
    }
    tsParseTypeLiteral() {
      const e3 = this.startNode();
      return e3.members = this.tsParseObjectTypeMembers(), this.finishNode(e3, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(bn$1.braceL);
      const e3 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(bn$1.braceR), e3;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(bn$1.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(bn$1.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(bn$1._in))));
    }
    tsParseMappedTypeParameter() {
      const e3 = this.startNode();
      return e3.name = this.tsParseTypeParameterName(), e3.constraint = this.tsExpectThenParseType(bn$1._in), this.finishNode(e3, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e3 = this.startNode();
      return this.expect(bn$1.braceL), this.match(bn$1.plusMin) ? (e3.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (e3.readonly = true), this.expect(bn$1.bracketL), e3.typeParameter = this.tsParseMappedTypeParameter(), e3.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(bn$1.bracketR), this.match(bn$1.plusMin) ? (e3.optional = this.state.value, this.next(), this.expect(bn$1.question)) : this.eat(bn$1.question) && (e3.optional = true), e3.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(bn$1.braceR), this.finishNode(e3, "TSMappedType");
    }
    tsParseTupleType() {
      const e3 = this.startNode();
      e3.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t2 = false, s2 = null;
      return e3.elementTypes.forEach((e4) => {
        var r2;
        let { type: i2 } = e4;
        !t2 || i2 === "TSRestType" || i2 === "TSOptionalType" || i2 === "TSNamedTupleMember" && e4.optional || this.raise(e4.start, Xo.OptionalTypeBeforeRequired), t2 = t2 || i2 === "TSNamedTupleMember" && e4.optional || i2 === "TSOptionalType", i2 === "TSRestType" && (i2 = (e4 = e4.typeAnnotation).type);
        const a2 = i2 === "TSNamedTupleMember";
        s2 = (r2 = s2) != null ? r2 : a2, s2 !== a2 && this.raise(e4.start, Xo.MixedLabeledAndUnlabeledElements);
      }), this.finishNode(e3, "TSTupleType");
    }
    tsParseTupleElementType() {
      const { start: e3, startLoc: t2 } = this.state, s2 = this.eat(bn$1.ellipsis);
      let r2 = this.tsParseType();
      const i2 = this.eat(bn$1.question);
      if (this.eat(bn$1.colon)) {
        const e4 = this.startNodeAtNode(r2);
        e4.optional = i2, r2.type !== "TSTypeReference" || r2.typeParameters || r2.typeName.type !== "Identifier" ? (this.raise(r2.start, Xo.InvalidTupleMemberLabel), e4.label = r2) : e4.label = r2.typeName, e4.elementType = this.tsParseType(), r2 = this.finishNode(e4, "TSNamedTupleMember");
      } else if (i2) {
        const e4 = this.startNodeAtNode(r2);
        e4.typeAnnotation = r2, r2 = this.finishNode(e4, "TSOptionalType");
      }
      if (s2) {
        const s3 = this.startNodeAt(e3, t2);
        s3.typeAnnotation = r2, r2 = this.finishNode(s3, "TSRestType");
      }
      return r2;
    }
    tsParseParenthesizedType() {
      const e3 = this.startNode();
      return this.expect(bn$1.parenL), e3.typeAnnotation = this.tsParseType(), this.expect(bn$1.parenR), this.finishNode(e3, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e3, t2) {
      const s2 = this.startNode();
      return e3 === "TSConstructorType" && (s2.abstract = !!t2, t2 && this.next(), this.next()), this.tsFillSignature(bn$1.arrow, s2), this.finishNode(s2, e3);
    }
    tsParseLiteralTypeNode() {
      const e3 = this.startNode();
      return e3.literal = (() => {
        switch (this.state.type) {
          case bn$1.num:
          case bn$1.bigint:
          case bn$1.string:
          case bn$1._true:
          case bn$1._false:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })(), this.finishNode(e3, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e3 = this.startNode();
      return e3.literal = this.parseTemplate(false), this.finishNode(e3, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e3 = this.tsParseThisTypeNode();
      return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e3) : e3;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case bn$1.name:
        case bn$1._void:
        case bn$1._null: {
          const e3 = this.match(bn$1._void) ? "TSVoidKeyword" : this.match(bn$1._null) ? "TSNullKeyword" : function(e4) {
            switch (e4) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return;
            }
          }(this.state.value);
          if (e3 !== void 0 && this.lookaheadCharCode() !== 46) {
            const t2 = this.startNode();
            return this.next(), this.finishNode(t2, e3);
          }
          return this.tsParseTypeReference();
        }
        case bn$1.string:
        case bn$1.num:
        case bn$1.bigint:
        case bn$1._true:
        case bn$1._false:
          return this.tsParseLiteralTypeNode();
        case bn$1.plusMin:
          if (this.state.value === "-") {
            const e3 = this.startNode(), t2 = this.lookahead();
            if (t2.type !== bn$1.num && t2.type !== bn$1.bigint)
              throw this.unexpected();
            return e3.literal = this.parseMaybeUnary(), this.finishNode(e3, "TSLiteralType");
          }
          break;
        case bn$1._this:
          return this.tsParseThisTypeOrThisTypePredicate();
        case bn$1._typeof:
          return this.tsParseTypeQuery();
        case bn$1._import:
          return this.tsParseImportType();
        case bn$1.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case bn$1.bracketL:
          return this.tsParseTupleType();
        case bn$1.parenL:
          return this.tsParseParenthesizedType();
        case bn$1.backQuote:
          return this.tsParseTemplateLiteralType();
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e3 = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(bn$1.bracketL); )
        if (this.match(bn$1.bracketR)) {
          const t2 = this.startNodeAtNode(e3);
          t2.elementType = e3, this.expect(bn$1.bracketR), e3 = this.finishNode(t2, "TSArrayType");
        } else {
          const t2 = this.startNodeAtNode(e3);
          t2.objectType = e3, t2.indexType = this.tsParseType(), this.expect(bn$1.bracketR), e3 = this.finishNode(t2, "TSIndexedAccessType");
        }
      return e3;
    }
    tsParseTypeOperator(e3) {
      const t2 = this.startNode();
      return this.expectContextual(e3), t2.operator = e3, t2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), e3 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t2), this.finishNode(t2, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e3) {
      switch (e3.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(e3.start, Xo.UnexpectedReadonly);
      }
    }
    tsParseInferType() {
      const e3 = this.startNode();
      this.expectContextual("infer");
      const t2 = this.startNode();
      return t2.name = this.tsParseTypeParameterName(), e3.typeParameter = this.finishNode(t2, "TSTypeParameter"), this.finishNode(e3, "TSInferType");
    }
    tsParseTypeOperatorOrHigher() {
      const e3 = ["keyof", "unique", "readonly"].find((e4) => this.isContextual(e4));
      return e3 ? this.tsParseTypeOperator(e3) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
    }
    tsParseUnionOrIntersectionType(e3, t2, s2) {
      const r2 = this.startNode(), i2 = this.eat(s2), a2 = [];
      do {
        a2.push(t2());
      } while (this.eat(s2));
      return a2.length !== 1 || i2 ? (r2.types = a2, this.finishNode(r2, e3)) : a2[0];
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), bn$1.bitwiseAND);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), bn$1.bitwiseOR);
    }
    tsIsStartOfFunctionType() {
      return !!this.isRelational("<") || this.match(bn$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (this.match(bn$1.name) || this.match(bn$1._this))
        return this.next(), true;
      if (this.match(bn$1.braceL)) {
        let e3 = 1;
        for (this.next(); e3 > 0; )
          this.match(bn$1.braceL) ? ++e3 : this.match(bn$1.braceR) && --e3, this.next();
        return true;
      }
      if (this.match(bn$1.bracketL)) {
        let e3 = 1;
        for (this.next(); e3 > 0; )
          this.match(bn$1.bracketL) ? ++e3 : this.match(bn$1.bracketR) && --e3, this.next();
        return true;
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      if (this.next(), this.match(bn$1.parenR) || this.match(bn$1.ellipsis))
        return true;
      if (this.tsSkipParameterStart()) {
        if (this.match(bn$1.colon) || this.match(bn$1.comma) || this.match(bn$1.question) || this.match(bn$1.eq))
          return true;
        if (this.match(bn$1.parenR) && (this.next(), this.match(bn$1.arrow)))
          return true;
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(e3) {
      return this.tsInType(() => {
        const t2 = this.startNode();
        this.expect(e3);
        const s2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (r2 && this.match(bn$1._this)) {
          let e4 = this.tsParseThisTypeOrThisTypePredicate();
          return e4.type === "TSThisType" ? (s2.parameterName = e4, s2.asserts = true, s2.typeAnnotation = null, e4 = this.finishNode(s2, "TSTypePredicate")) : (this.resetStartLocationFromNode(e4, s2), e4.asserts = true), t2.typeAnnotation = e4, this.finishNode(t2, "TSTypeAnnotation");
        }
        const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!i2)
          return r2 ? (s2.parameterName = this.parseIdentifier(), s2.asserts = r2, s2.typeAnnotation = null, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t2);
        const a2 = this.tsParseTypeAnnotation(false);
        return s2.parameterName = i2, s2.typeAnnotation = a2, s2.asserts = r2, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(bn$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(bn$1.colon) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(bn$1.colon);
    }
    tsParseTypePredicatePrefix() {
      const e3 = this.parseIdentifier();
      if (this.isContextual("is") && !this.hasPrecedingLineBreak())
        return this.next(), e3;
    }
    tsParseTypePredicateAsserts() {
      if (!this.match(bn$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak())
        return false;
      const e3 = this.state.containsEsc;
      return this.next(), !(!this.match(bn$1.name) && !this.match(bn$1._this)) && (e3 && this.raise(this.state.lastTokStart, Rn$1.InvalidEscapedReservedWord, "asserts"), true);
    }
    tsParseTypeAnnotation(e3 = true, t2 = this.startNode()) {
      return this.tsInType(() => {
        e3 && this.expect(bn$1.colon), t2.typeAnnotation = this.tsParseType();
      }), this.finishNode(t2, "TSTypeAnnotation");
    }
    tsParseType() {
      Ko(this.state.inType);
      const e3 = this.tsParseNonConditionalType();
      if (this.hasPrecedingLineBreak() || !this.eat(bn$1._extends))
        return e3;
      const t2 = this.startNodeAtNode(e3);
      return t2.checkType = e3, t2.extendsType = this.tsParseNonConditionalType(), this.expect(bn$1.question), t2.trueType = this.tsParseType(), this.expect(bn$1.colon), t2.falseType = this.tsParseType(), this.finishNode(t2, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual("abstract") && this.lookahead().type === bn$1._new;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(bn$1._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      const e3 = this.startNode(), t2 = this.tsTryNextParseConstantContext();
      return e3.typeAnnotation = t2 || this.tsNextThenParseType(), this.expectRelational(">"), e3.expression = this.parseMaybeUnary(), this.finishNode(e3, "TSTypeAssertion");
    }
    tsParseHeritageClause(e3) {
      const t2 = this.state.start, s2 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
      return s2.length || this.raise(t2, Xo.EmptyHeritageClauseType, e3), s2;
    }
    tsParseExpressionWithTypeArguments() {
      const e3 = this.startNode();
      return e3.expression = this.tsParseEntityName(false), this.isRelational("<") && (e3.typeParameters = this.tsParseTypeArguments()), this.finishNode(e3, "TSExpressionWithTypeArguments");
    }
    tsParseInterfaceDeclaration(e3) {
      this.match(bn$1.name) ? (e3.id = this.parseIdentifier(), this.checkLVal(e3.id, "typescript interface declaration", 130)) : (e3.id = null, this.raise(this.state.start, Xo.MissingInterfaceName)), e3.typeParameters = this.tsTryParseTypeParameters(), this.eat(bn$1._extends) && (e3.extends = this.tsParseHeritageClause("extends"));
      const t2 = this.startNode();
      return t2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e3.body = this.finishNode(t2, "TSInterfaceBody"), this.finishNode(e3, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e3) {
      return e3.id = this.parseIdentifier(), this.checkLVal(e3.id, "typescript type alias", 2), e3.typeParameters = this.tsTryParseTypeParameters(), e3.typeAnnotation = this.tsInType(() => {
        if (this.expect(bn$1.eq), this.isContextual("intrinsic") && this.lookahead().type !== bn$1.dot) {
          const e4 = this.startNode();
          return this.next(), this.finishNode(e4, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e3, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e3) {
      const t2 = this.state.context;
      this.state.context = [t2[0]];
      try {
        return e3();
      } finally {
        this.state.context = t2;
      }
    }
    tsInType(e3) {
      const t2 = this.state.inType;
      this.state.inType = true;
      try {
        return e3();
      } finally {
        this.state.inType = t2;
      }
    }
    tsEatThenParseType(e3) {
      return this.match(e3) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e3) {
      return this.tsDoThenParseType(() => this.expect(e3));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e3) {
      return this.tsInType(() => (e3(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e3 = this.startNode();
      return e3.id = this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(bn$1.eq) && (e3.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e3, "TSEnumMember");
    }
    tsParseEnumDeclaration(e3, t2) {
      return t2 && (e3.const = true), e3.id = this.parseIdentifier(), this.checkLVal(e3.id, "typescript enum declaration", t2 ? 779 : 267), this.expect(bn$1.braceL), e3.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(bn$1.braceR), this.finishNode(e3, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e3 = this.startNode();
      return this.scope.enter(0), this.expect(bn$1.braceL), this.parseBlockOrModuleBlockBody(e3.body = [], void 0, true, bn$1.braceR), this.scope.exit(), this.finishNode(e3, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e3, t2 = false) {
      if (e3.id = this.parseIdentifier(), t2 || this.checkLVal(e3.id, "module or namespace declaration", 1024), this.eat(bn$1.dot)) {
        const t3 = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(t3, true), e3.body = t3;
      } else
        this.scope.enter(256), this.prodParam.enter(0), e3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e3, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e3) {
      return this.isContextual("global") ? (e3.global = true, e3.id = this.parseIdentifier()) : this.match(bn$1.string) ? e3.id = this.parseExprAtom() : this.unexpected(), this.match(bn$1.braceL) ? (this.scope.enter(256), this.prodParam.enter(0), e3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e3, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e3, t2) {
      e3.isExport = t2 || false, e3.id = this.parseIdentifier(), this.checkLVal(e3.id, "import equals declaration", 9), this.expect(bn$1.eq);
      const s2 = this.tsParseModuleReference();
      return e3.importKind === "type" && s2.type !== "TSExternalModuleReference" && this.raise(s2.start, Xo.ImportAliasHasImportType), e3.moduleReference = s2, this.semicolon(), this.finishNode(e3, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual("require") && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e3 = this.startNode();
      if (this.expectContextual("require"), this.expect(bn$1.parenL), !this.match(bn$1.string))
        throw this.unexpected();
      return e3.expression = this.parseExprAtom(), this.expect(bn$1.parenR), this.finishNode(e3, "TSExternalModuleReference");
    }
    tsLookAhead(e3) {
      const t2 = this.state.clone(), s2 = e3();
      return this.state = t2, s2;
    }
    tsTryParseAndCatch(e3) {
      const t2 = this.tryParse((t3) => e3() || t3());
      if (!t2.aborted && t2.node)
        return t2.error && (this.state = t2.failState), t2.node;
    }
    tsTryParse(e3) {
      const t2 = this.state.clone(), s2 = e3();
      return s2 !== void 0 && s2 !== false ? s2 : void (this.state = t2);
    }
    tsTryParseDeclare(e3) {
      if (this.isLineTerminator())
        return;
      let t2, s2 = this.state.type;
      return this.isContextual("let") && (s2 = bn$1._var, t2 = "let"), this.tsInAmbientContext(() => {
        switch (s2) {
          case bn$1._function:
            return e3.declare = true, this.parseFunctionStatement(e3, false, true);
          case bn$1._class:
            return e3.declare = true, this.parseClass(e3, true, false);
          case bn$1._const:
            if (this.match(bn$1._const) && this.isLookaheadContextual("enum"))
              return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e3, true);
          case bn$1._var:
            return t2 = t2 || this.state.value, this.parseVarStatement(e3, t2);
          case bn$1.name: {
            const t3 = this.state.value;
            return t3 === "global" ? this.tsParseAmbientExternalModuleDeclaration(e3) : this.tsParseDeclaration(e3, t3, true);
          }
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(e3, t2) {
      switch (t2.name) {
        case "declare": {
          const t3 = this.tsTryParseDeclare(e3);
          if (t3)
            return t3.declare = true, t3;
          break;
        }
        case "global":
          if (this.match(bn$1.braceL)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const s2 = e3;
            return s2.global = true, s2.id = t2, s2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s2, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e3, t2.name, false);
      }
    }
    tsParseDeclaration(e3, t2, s2) {
      switch (t2) {
        case "abstract":
          if (this.tsCheckLineTerminator(s2) && (this.match(bn$1._class) || this.match(bn$1.name)))
            return this.tsParseAbstractDeclaration(e3);
          break;
        case "enum":
          if (s2 || this.match(bn$1.name))
            return s2 && this.next(), this.tsParseEnumDeclaration(e3, false);
          break;
        case "interface":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseInterfaceDeclaration(e3);
          break;
        case "module":
          if (this.tsCheckLineTerminator(s2)) {
            if (this.match(bn$1.string))
              return this.tsParseAmbientExternalModuleDeclaration(e3);
            if (this.match(bn$1.name))
              return this.tsParseModuleOrNamespaceDeclaration(e3);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseModuleOrNamespaceDeclaration(e3);
          break;
        case "type":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseTypeAliasDeclaration(e3);
      }
    }
    tsCheckLineTerminator(e3) {
      return e3 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e3, t2) {
      if (!this.isRelational("<"))
        return;
      const s2 = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const r2 = this.tsTryParseAndCatch(() => {
        const s3 = this.startNodeAt(e3, t2);
        return s3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s3), s3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(bn$1.arrow), s3;
      });
      return this.state.maybeInArrowParameters = s2, r2 ? this.parseArrowExpression(r2, null, true) : void 0;
    }
    tsParseTypeArguments() {
      const e3 = this.startNode();
      return e3.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e3.params.length === 0 && this.raise(e3.start, Xo.EmptyTypeArguments), this.expectRelational(">"), this.finishNode(e3, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      if (this.match(bn$1.name))
        switch (this.state.value) {
          case "abstract":
          case "declare":
          case "enum":
          case "interface":
          case "module":
          case "namespace":
          case "type":
            return true;
        }
      return false;
    }
    isExportDefaultSpecifier() {
      return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e3, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      let i2, a2 = false, n2 = false;
      if (e3 !== void 0) {
        const t3 = {};
        this.tsParseModifiers(t3, ["public", "private", "protected", "override", "readonly"]), i2 = t3.accessibility, n2 = t3.override, a2 = t3.readonly, e3 === false && (i2 || a2 || n2) && this.raise(s2, Xo.UnexpectedParameterModifier);
      }
      const o2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(o2);
      const u2 = this.parseMaybeDefault(o2.start, o2.loc.start, o2);
      if (i2 || a2 || n2) {
        const e4 = this.startNodeAt(s2, r2);
        return t2.length && (e4.decorators = t2), i2 && (e4.accessibility = i2), a2 && (e4.readonly = a2), n2 && (e4.override = n2), u2.type !== "Identifier" && u2.type !== "AssignmentPattern" && this.raise(e4.start, Xo.UnsupportedParameterPropertyKind), e4.parameter = u2, this.finishNode(e4, "TSParameterProperty");
      }
      return t2.length && (o2.decorators = t2), u2;
    }
    parseFunctionBodyAndFinish(e3, t2, s2 = false) {
      this.match(bn$1.colon) && (e3.returnType = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon));
      const r2 = t2 === "FunctionDeclaration" ? "TSDeclareFunction" : t2 === "ClassMethod" ? "TSDeclareMethod" : void 0;
      r2 && !this.match(bn$1.braceL) && this.isLineTerminator() ? this.finishNode(e3, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(e3.start, Xo.DeclareFunctionHasImplementation), e3.declare) ? super.parseFunctionBodyAndFinish(e3, r2, s2) : super.parseFunctionBodyAndFinish(e3, t2, s2);
    }
    registerFunctionStatementId(e3) {
      !e3.body && e3.id ? this.checkLVal(e3.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
    }
    tsCheckForInvalidTypeCasts(e3) {
      e3.forEach((e4) => {
        (e4 == null ? void 0 : e4.type) === "TSTypeCastExpression" && this.raise(e4.typeAnnotation.start, Xo.UnexpectedTypeAnnotation);
      });
    }
    toReferencedList(e3, t2) {
      return this.tsCheckForInvalidTypeCasts(e3), e3;
    }
    parseArrayLike(...e3) {
      const t2 = super.parseArrayLike(...e3);
      return t2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t2.elements), t2;
    }
    parseSubscript(e3, t2, s2, r2, i2) {
      if (!this.hasPrecedingLineBreak() && this.match(bn$1.bang)) {
        this.state.exprAllowed = false, this.next();
        const r3 = this.startNodeAt(t2, s2);
        return r3.expression = e3, this.finishNode(r3, "TSNonNullExpression");
      }
      let a2 = false;
      if (this.match(bn$1.questionDot) && this.lookaheadCharCode() === 60) {
        if (r2)
          return i2.stop = true, e3;
        i2.optionalChainMember = a2 = true, this.next();
      }
      if (this.isRelational("<")) {
        let n2;
        const o2 = this.tsTryParseAndCatch(() => {
          if (!r2 && this.atPossibleAsyncArrow(e3)) {
            const e4 = this.tsTryParseGenericAsyncArrowFunction(t2, s2);
            if (e4)
              return e4;
          }
          const o3 = this.startNodeAt(t2, s2);
          o3.callee = e3;
          const u2 = this.tsParseTypeArguments();
          if (u2) {
            if (a2 && !this.match(bn$1.parenL) && (n2 = this.state.pos, this.unexpected()), !r2 && this.eat(bn$1.parenL))
              return o3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.tsCheckForInvalidTypeCasts(o3.arguments), o3.typeParameters = u2, i2.optionalChainMember && (o3.optional = a2), this.finishCallExpression(o3, i2.optionalChainMember);
            if (this.match(bn$1.backQuote)) {
              const r3 = this.parseTaggedTemplateExpression(e3, t2, s2, i2);
              return r3.typeParameters = u2, r3;
            }
          }
          this.unexpected();
        });
        if (n2 && this.unexpected(n2, bn$1.parenL), o2)
          return o2;
      }
      return super.parseSubscript(e3, t2, s2, r2, i2);
    }
    parseNewArguments(e3) {
      if (this.isRelational("<")) {
        const t2 = this.tsTryParseAndCatch(() => {
          const e4 = this.tsParseTypeArguments();
          return this.match(bn$1.parenL) || this.unexpected(), e4;
        });
        t2 && (e3.typeParameters = t2);
      }
      super.parseNewArguments(e3);
    }
    parseExprOp(e3, t2, s2, r2) {
      if (Go(bn$1._in.binop) > r2 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
        const i2 = this.startNodeAt(t2, s2);
        i2.expression = e3;
        const a2 = this.tsTryNextParseConstantContext();
        return i2.typeAnnotation = a2 || this.tsNextThenParseType(), this.finishNode(i2, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, t2, s2, r2);
      }
      return super.parseExprOp(e3, t2, s2, r2);
    }
    checkReservedWord(e3, t2, s2, r2) {
    }
    checkDuplicateExports() {
    }
    parseImport(e3) {
      if (e3.importKind = "value", this.match(bn$1.name) || this.match(bn$1.star) || this.match(bn$1.braceL)) {
        let t3 = this.lookahead();
        if (!this.isContextual("type") || t3.type === bn$1.comma || t3.type === bn$1.name && t3.value === "from" || t3.type === bn$1.eq || (e3.importKind = "type", this.next(), t3 = this.lookahead()), this.match(bn$1.name) && t3.type === bn$1.eq)
          return this.tsParseImportEqualsDeclaration(e3);
      }
      const t2 = super.parseImport(e3);
      return t2.importKind === "type" && t2.specifiers.length > 1 && t2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(t2.start, Xo.TypeImportCannotSpecifyDefaultAndNamed), t2;
    }
    parseExport(e3) {
      if (this.match(bn$1._import))
        return this.next(), this.isContextual("type") && this.lookaheadCharCode() !== 61 ? (e3.importKind = "type", this.next()) : e3.importKind = "value", this.tsParseImportEqualsDeclaration(e3, true);
      if (this.eat(bn$1.eq)) {
        const t2 = e3;
        return t2.expression = this.parseExpression(), this.semicolon(), this.finishNode(t2, "TSExportAssignment");
      }
      if (this.eatContextual("as")) {
        const t2 = e3;
        return this.expectContextual("namespace"), t2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t2, "TSNamespaceExportDeclaration");
      }
      return this.isContextual("type") && this.lookahead().type === bn$1.braceL ? (this.next(), e3.exportKind = "type") : e3.exportKind = "value", super.parseExport(e3);
    }
    isAbstractClass() {
      return this.isContextual("abstract") && this.lookahead().type === bn$1._class;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e3 = this.startNode();
        return this.next(), e3.abstract = true, this.parseClass(e3, true, true), e3;
      }
      if (this.state.value === "interface") {
        const e3 = this.startNode();
        this.next();
        const t2 = this.tsParseInterfaceDeclaration(e3);
        if (t2)
          return t2;
      }
      return super.parseExportDefaultExpression();
    }
    parseStatementContent(e3, t2) {
      if (this.state.type === bn$1._const) {
        const e4 = this.lookahead();
        if (e4.type === bn$1.name && e4.value === "enum") {
          const e5 = this.startNode();
          return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e5, true);
        }
      }
      return super.parseStatementContent(e3, t2);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e3, t2) {
      return t2.some((t3) => Jo(t3) ? e3.accessibility === t3 : !!e3[t3]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual("static") && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e3, t2, s2) {
      const r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers(t2, r2, void 0, void 0, true);
      const i2 = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t2, r2) && this.raise(this.state.pos, Xo.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(e3, t2)) : this.parseClassMemberWithIsStatic(e3, t2, s2, !!t2.static);
      };
      t2.declare ? this.tsInAmbientContext(i2) : i2();
    }
    parseClassMemberWithIsStatic(e3, t2, s2, r2) {
      const i2 = this.tsTryParseIndexSignature(t2);
      if (i2)
        return e3.body.push(i2), t2.abstract && this.raise(t2.start, Xo.IndexSignatureHasAbstract), t2.accessibility && this.raise(t2.start, Xo.IndexSignatureHasAccessibility, t2.accessibility), t2.declare && this.raise(t2.start, Xo.IndexSignatureHasDeclare), void (t2.override && this.raise(t2.start, Xo.IndexSignatureHasOverride));
      !this.state.inAbstractClass && t2.abstract && this.raise(t2.start, Xo.NonAbstractClassHasAbstractMethod), t2.override && (s2.hadSuperClass || this.raise(t2.start, Xo.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(e3, t2, s2, r2);
    }
    parsePostMemberNameModifiers(e3) {
      this.eat(bn$1.question) && (e3.optional = true), e3.readonly && this.match(bn$1.parenL) && this.raise(e3.start, Xo.ClassMethodHasReadonly), e3.declare && this.match(bn$1.parenL) && this.raise(e3.start, Xo.ClassMethodHasDeclare);
    }
    parseExpressionStatement(e3, t2) {
      return (t2.type === "Identifier" ? this.tsParseExpressionStatement(e3, t2) : void 0) || super.parseExpressionStatement(e3, t2);
    }
    shouldParseExportDeclaration() {
      return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
    }
    parseConditional(e3, t2, s2, r2) {
      if (!this.state.maybeInArrowParameters || !this.match(bn$1.question))
        return super.parseConditional(e3, t2, s2, r2);
      const i2 = this.tryParse(() => super.parseConditional(e3, t2, s2));
      return i2.node ? (i2.error && (this.state = i2.failState), i2.node) : (i2.error && super.setOptionalParametersError(r2, i2.error), e3);
    }
    parseParenItem(e3, t2, s2) {
      if (e3 = super.parseParenItem(e3, t2, s2), this.eat(bn$1.question) && (e3.optional = true, this.resetEndLocation(e3)), this.match(bn$1.colon)) {
        const r2 = this.startNodeAt(t2, s2);
        return r2.expression = e3, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
      }
      return e3;
    }
    parseExportDeclaration(e3) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.eatContextual("declare");
      if (r2 && (this.isContextual("declare") || !this.shouldParseExportDeclaration()))
        throw this.raise(this.state.start, Xo.ExpectedAmbientAfterExportDeclare);
      let i2;
      return this.match(bn$1.name) && (i2 = this.tsTryParseExportDeclaration()), i2 || (i2 = super.parseExportDeclaration(e3)), i2 && (i2.type === "TSInterfaceDeclaration" || i2.type === "TSTypeAliasDeclaration" || r2) && (e3.exportKind = "type"), i2 && r2 && (this.resetStartLocation(i2, t2, s2), i2.declare = true), i2;
    }
    parseClassId(e3, t2, s2) {
      if ((!t2 || s2) && this.isContextual("implements"))
        return;
      super.parseClassId(e3, t2, s2, e3.declare ? 1024 : 139);
      const r2 = this.tsTryParseTypeParameters();
      r2 && (e3.typeParameters = r2);
    }
    parseClassPropertyAnnotation(e3) {
      !e3.optional && this.eat(bn$1.bang) && (e3.definite = true);
      const t2 = this.tsTryParseTypeAnnotation();
      t2 && (e3.typeAnnotation = t2);
    }
    parseClassProperty(e3) {
      if (this.parseClassPropertyAnnotation(e3), this.state.isAmbientContext && this.match(bn$1.eq) && this.raise(this.state.start, Xo.DeclareClassFieldHasInitializer), e3.abstract && this.match(bn$1.eq)) {
        const { key: t2 } = e3;
        this.raise(this.state.start, Xo.AbstractPropertyHasInitializer, t2.type !== "Identifier" || e3.computed ? `[${this.input.slice(t2.start, t2.end)}]` : t2.name);
      }
      return super.parseClassProperty(e3);
    }
    parseClassPrivateProperty(e3) {
      return e3.abstract && this.raise(e3.start, Xo.PrivateElementHasAbstract), e3.accessibility && this.raise(e3.start, Xo.PrivateElementHasAccessibility, e3.accessibility), this.parseClassPropertyAnnotation(e3), super.parseClassPrivateProperty(e3);
    }
    pushClassMethod(e3, t2, s2, r2, i2, a2) {
      const n2 = this.tsTryParseTypeParameters();
      n2 && i2 && this.raise(n2.start, Xo.ConstructorHasTypeParameters), !t2.declare || t2.kind !== "get" && t2.kind !== "set" || this.raise(t2.start, Xo.DeclareAccessor, t2.kind), n2 && (t2.typeParameters = n2), super.pushClassMethod(e3, t2, s2, r2, i2, a2);
    }
    pushClassPrivateMethod(e3, t2, s2, r2) {
      const i2 = this.tsTryParseTypeParameters();
      i2 && (t2.typeParameters = i2), super.pushClassPrivateMethod(e3, t2, s2, r2);
    }
    parseClassSuper(e3) {
      super.parseClassSuper(e3), e3.superClass && this.isRelational("<") && (e3.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (e3.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e3, ...t2) {
      const s2 = this.tsTryParseTypeParameters();
      s2 && (e3.typeParameters = s2), super.parseObjPropValue(e3, ...t2);
    }
    parseFunctionParams(e3, t2) {
      const s2 = this.tsTryParseTypeParameters();
      s2 && (e3.typeParameters = s2), super.parseFunctionParams(e3, t2);
    }
    parseVarId(e3, t2) {
      super.parseVarId(e3, t2), e3.id.type === "Identifier" && this.eat(bn$1.bang) && (e3.definite = true);
      const s2 = this.tsTryParseTypeAnnotation();
      s2 && (e3.id.typeAnnotation = s2, this.resetEndLocation(e3.id));
    }
    parseAsyncArrowFromCallExpression(e3, t2) {
      return this.match(bn$1.colon) && (e3.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e3, t2);
    }
    parseMaybeAssign(...e3) {
      var t2, s2, r2, i2, a2, n2, o2;
      let u2, h2, c2, p2;
      if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
        if (u2 = this.state.clone(), h2 = this.tryParse(() => super.parseMaybeAssign(...e3), u2), !h2.error)
          return h2.node;
        const { context: t3 } = this.state;
        t3[t3.length - 1] === $n$1.j_oTag ? t3.length -= 2 : t3[t3.length - 1] === $n$1.j_expr && (t3.length -= 1);
      }
      if (!((t2 = h2) != null && t2.error || this.isRelational("<")))
        return super.parseMaybeAssign(...e3);
      u2 = u2 || this.state.clone();
      const l2 = this.tryParse((t3) => {
        var s3, r3;
        p2 = this.tsParseTypeParameters();
        const i3 = super.parseMaybeAssign(...e3);
        return (i3.type !== "ArrowFunctionExpression" || (s3 = i3.extra) != null && s3.parenthesized) && t3(), ((r3 = p2) == null ? void 0 : r3.params.length) !== 0 && this.resetStartLocationFromNode(i3, p2), i3.typeParameters = p2, i3;
      }, u2);
      if (!l2.error && !l2.aborted)
        return l2.node;
      if (!h2 && (Ko(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(...e3), u2), !c2.error))
        return c2.node;
      if ((s2 = h2) != null && s2.node)
        return this.state = h2.failState, h2.node;
      if (l2.node)
        return this.state = l2.failState, l2.node;
      if ((r2 = c2) != null && r2.node)
        return this.state = c2.failState, c2.node;
      if ((i2 = h2) != null && i2.thrown)
        throw h2.error;
      if (l2.thrown)
        throw l2.error;
      if ((a2 = c2) != null && a2.thrown)
        throw c2.error;
      throw ((n2 = h2) == null ? void 0 : n2.error) || l2.error || ((o2 = c2) == null ? void 0 : o2.error);
    }
    parseMaybeUnary(e3) {
      return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e3);
    }
    parseArrow(e3) {
      if (this.match(bn$1.colon)) {
        const t2 = this.tryParse((e4) => {
          const t3 = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon);
          return !this.canInsertSemicolon() && this.match(bn$1.arrow) || e4(), t3;
        });
        if (t2.aborted)
          return;
        t2.thrown || (t2.error && (this.state = t2.failState), e3.returnType = t2.node);
      }
      return super.parseArrow(e3);
    }
    parseAssignableListItemTypes(e3) {
      this.eat(bn$1.question) && (e3.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(e3.start, Xo.PatternIsOptional), e3.optional = true);
      const t2 = this.tsTryParseTypeAnnotation();
      return t2 && (e3.typeAnnotation = t2), this.resetEndLocation(e3), e3;
    }
    isAssignable(e3, t2) {
      switch (e3.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e3.expression, t2);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e3, t2);
      }
    }
    toAssignable(e3, t2 = false) {
      switch (e3.type) {
        case "TSTypeCastExpression":
          return super.toAssignable(this.typeCastToParameter(e3), t2);
        case "TSParameterProperty":
          return super.toAssignable(e3, t2);
        case "ParenthesizedExpression":
          return this.toAssignableParenthesizedExpression(e3, t2);
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          return e3.expression = this.toAssignable(e3.expression, t2), e3;
        default:
          return super.toAssignable(e3, t2);
      }
    }
    toAssignableParenthesizedExpression(e3, t2) {
      switch (e3.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          return e3.expression = this.toAssignable(e3.expression, t2), e3;
        default:
          return super.toAssignable(e3, t2);
      }
    }
    checkLVal(e3, t2, ...s2) {
      var r2;
      switch (e3.type) {
        case "TSTypeCastExpression":
          return;
        case "TSParameterProperty":
          return void this.checkLVal(e3.parameter, "parameter property", ...s2);
        case "TSAsExpression":
        case "TSTypeAssertion":
          if (!(s2[0] || t2 === "parenthesized expression" || (r2 = e3.extra) != null && r2.parenthesized)) {
            this.raise(e3.start, Rn$1.InvalidLhs, t2);
            break;
          }
          return void this.checkLVal(e3.expression, "parenthesized expression", ...s2);
        case "TSNonNullExpression":
          return void this.checkLVal(e3.expression, t2, ...s2);
        default:
          return void super.checkLVal(e3, t2, ...s2);
      }
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e3) {
      if (this.isRelational("<")) {
        const t2 = this.tsParseTypeArguments();
        if (this.match(bn$1.parenL)) {
          const s2 = super.parseMaybeDecoratorArguments(e3);
          return s2.typeParameters = t2, s2;
        }
        this.unexpected(this.state.start, bn$1.parenL);
      }
      return super.parseMaybeDecoratorArguments(e3);
    }
    checkCommaAfterRest(e3) {
      this.state.isAmbientContext && this.match(bn$1.comma) && this.lookaheadCharCode() === e3 ? this.next() : super.checkCommaAfterRest(e3);
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(bn$1.bang) || this.match(bn$1.colon) || super.isClassProperty();
    }
    parseMaybeDefault(...e3) {
      const t2 = super.parseMaybeDefault(...e3);
      return t2.type === "AssignmentPattern" && t2.typeAnnotation && t2.right.start < t2.typeAnnotation.start && this.raise(t2.typeAnnotation.start, Xo.TypeAnnotationAfterAssign), t2;
    }
    getTokenFromCode(e3) {
      return !this.state.inType || e3 !== 62 && e3 !== 60 ? super.getTokenFromCode(e3) : this.finishOp(bn$1.relational, 1);
    }
    reScan_lt_gt() {
      if (this.match(bn$1.relational)) {
        const e3 = this.input.charCodeAt(this.state.start);
        e3 !== 60 && e3 !== 62 || (this.state.pos -= 1, this.readToken_lt_gt(e3));
      }
    }
    toAssignableList(e3) {
      for (let t2 = 0; t2 < e3.length; t2++) {
        const s2 = e3[t2];
        if (s2)
          switch (s2.type) {
            case "TSTypeCastExpression":
              e3[t2] = this.typeCastToParameter(s2);
              break;
            case "TSAsExpression":
            case "TSTypeAssertion":
              this.state.maybeInArrowParameters ? this.raise(s2.start, Xo.UnexpectedTypeCastInParameter) : e3[t2] = this.typeCastToParameter(s2);
          }
      }
      return super.toAssignableList(...arguments);
    }
    typeCastToParameter(e3) {
      return e3.expression.typeAnnotation = e3.typeAnnotation, this.resetEndLocation(e3.expression, e3.typeAnnotation.end, e3.typeAnnotation.loc.end), e3.expression;
    }
    shouldParseArrow(e3) {
      return this.match(bn$1.colon) ? e3.every((e4) => this.isAssignable(e4, true)) : super.shouldParseArrow(e3);
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e3) {
      if (this.isRelational("<")) {
        const t2 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
        t2 && (e3.typeParameters = t2);
      }
      return super.jsxParseOpeningElementAfterName(e3);
    }
    getGetterSetterExpectedParamCount(e3) {
      const t2 = super.getGetterSetterExpectedParamCount(e3), s2 = this.getObjectOrClassMethodParams(e3)[0];
      return s2 && this.isThisParam(s2) ? t2 + 1 : t2;
    }
    parseCatchClauseParam() {
      const e3 = super.parseCatchClauseParam(), t2 = this.tsTryParseTypeAnnotation();
      return t2 && (e3.typeAnnotation = t2, this.resetEndLocation(e3)), e3;
    }
    tsInAmbientContext(e3) {
      const t2 = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e3();
      } finally {
        this.state.isAmbientContext = t2;
      }
    }
    parseClass(e3, ...t2) {
      const s2 = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e3.abstract;
      try {
        return super.parseClass(e3, ...t2);
      } finally {
        this.state.inAbstractClass = s2;
      }
    }
    tsParseAbstractDeclaration(e3) {
      if (this.match(bn$1._class))
        return e3.abstract = true, this.parseClass(e3, true, false);
      if (this.isContextual("interface")) {
        if (!this.hasFollowingLineBreak())
          return e3.abstract = true, this.raise(e3.start, Xo.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(e3);
      } else
        this.unexpected(null, bn$1._class);
    }
    parseMethod(...e3) {
      const t2 = super.parseMethod(...e3);
      if (t2.abstract) {
        if (this.hasPlugin("estree") ? !!t2.value.body : !!t2.body) {
          const { key: e4 } = t2;
          this.raise(t2.start, Xo.AbstractMethodHasImplementation, e4.type !== "Identifier" || t2.computed ? `[${this.input.slice(e4.start, e4.end)}]` : e4.name);
        }
      }
      return t2;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
  }, v8intrinsic: (e2) => class extends e2 {
    parseV8Intrinsic() {
      if (this.match(bn$1.modulo)) {
        const e3 = this.state.start, t2 = this.startNode();
        if (this.eat(bn$1.modulo), this.match(bn$1.name)) {
          const e4 = this.parseIdentifierName(this.state.start), s2 = this.createIdentifier(t2, e4);
          if (s2.type = "V8IntrinsicIdentifier", this.match(bn$1.parenL))
            return s2;
        }
        this.unexpected(e3);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  }, placeholders: (e2) => class extends e2 {
    parsePlaceholder(e3) {
      if (this.match(bn$1.placeholder)) {
        const t2 = this.startNode();
        return this.next(), this.assertNoSpace("Unexpected space in placeholder."), t2.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(bn$1.placeholder), this.finishPlaceholder(t2, e3);
      }
    }
    finishPlaceholder(e3, t2) {
      const s2 = !(!e3.expectedNode || e3.type !== "Placeholder");
      return e3.expectedNode = t2, s2 ? e3 : this.finishNode(e3, "Placeholder");
    }
    getTokenFromCode(e3) {
      return e3 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(bn$1.placeholder, 2) : super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(e3) {
      e3 !== void 0 && super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    checkLVal(e3) {
      e3.type !== "Placeholder" && super.checkLVal(...arguments);
    }
    toAssignable(e3) {
      return e3 && e3.type === "Placeholder" && e3.expectedNode === "Expression" ? (e3.expectedNode = "Pattern", e3) : super.toAssignable(...arguments);
    }
    isLet(e3) {
      if (super.isLet(e3))
        return true;
      if (!this.isContextual("let"))
        return false;
      if (e3)
        return false;
      return this.lookahead().type === bn$1.placeholder;
    }
    verifyBreakContinue(e3) {
      e3.label && e3.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(e3, t2) {
      if (t2.type !== "Placeholder" || t2.extra && t2.extra.parenthesized)
        return super.parseExpressionStatement(...arguments);
      if (this.match(bn$1.colon)) {
        const s2 = e3;
        return s2.label = this.finishPlaceholder(t2, "Identifier"), this.next(), s2.body = this.parseStatement("label"), this.finishNode(s2, "LabeledStatement");
      }
      return this.semicolon(), e3.name = t2.name, this.finishPlaceholder(e3, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(e3, t2, s2) {
      const r2 = t2 ? "ClassDeclaration" : "ClassExpression";
      this.next(), this.takeDecorators(e3);
      const i2 = this.state.strict, a2 = this.parsePlaceholder("Identifier");
      if (a2)
        if (this.match(bn$1._extends) || this.match(bn$1.placeholder) || this.match(bn$1.braceL))
          e3.id = a2;
        else {
          if (s2 || !t2)
            return e3.id = null, e3.body = this.finishPlaceholder(a2, "ClassBody"), this.finishNode(e3, r2);
          this.unexpected(null, Yo.ClassNameIsRequired);
        }
      else
        this.parseClassId(e3, t2, s2);
      return this.parseClassSuper(e3), e3.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e3.superClass, i2), this.finishNode(e3, r2);
    }
    parseExport(e3) {
      const t2 = this.parsePlaceholder("Identifier");
      if (!t2)
        return super.parseExport(...arguments);
      if (!this.isContextual("from") && !this.match(bn$1.comma))
        return e3.specifiers = [], e3.source = null, e3.declaration = this.finishPlaceholder(t2, "Declaration"), this.finishNode(e3, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const s2 = this.startNode();
      return s2.exported = t2, e3.specifiers = [this.finishNode(s2, "ExportDefaultSpecifier")], super.parseExport(e3);
    }
    isExportDefaultSpecifier() {
      if (this.match(bn$1._default)) {
        const e3 = this.nextTokenStart();
        if (this.isUnparsedContextual(e3, "from") && this.input.startsWith(bn$1.placeholder.label, this.nextTokenStartSince(e3 + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e3) {
      return !!(e3.specifiers && e3.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(e3) {
      const { specifiers: t2 } = e3;
      t2 != null && t2.length && (e3.specifiers = t2.filter((e4) => e4.exported.type === "Placeholder")), super.checkExport(e3), e3.specifiers = t2;
    }
    parseImport(e3) {
      const t2 = this.parsePlaceholder("Identifier");
      if (!t2)
        return super.parseImport(...arguments);
      if (e3.specifiers = [], !this.isContextual("from") && !this.match(bn$1.comma))
        return e3.source = this.finishPlaceholder(t2, "StringLiteral"), this.semicolon(), this.finishNode(e3, "ImportDeclaration");
      const s2 = this.startNodeAtNode(t2);
      if (s2.local = t2, this.finishNode(s2, "ImportDefaultSpecifier"), e3.specifiers.push(s2), this.eat(bn$1.comma)) {
        this.maybeParseStarImportSpecifier(e3) || this.parseNamedImportSpecifiers(e3);
      }
      return this.expectContextual("from"), e3.source = this.parseImportSource(), this.semicolon(), this.finishNode(e3, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
  } }, iu = Object.keys(ru), au = { sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
  const nu = (e2) => e2.type === "ParenthesizedExpression" ? nu(e2.expression) : e2;
  const ou = { kind: "loop" }, uu = { kind: "switch" }, hu = /[\uD800-\uDFFF]/u, cu = /in(?:stanceof)?/y;
  class pu extends class extends class extends class extends class extends class extends class extends class extends class extends class {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(e2) {
      return this.plugins.has(e2);
    }
    getPluginOption(e2, t2) {
      if (this.hasPlugin(e2))
        return this.plugins.get(e2)[t2];
    }
  } {
    addComment(e2) {
      this.filename && (e2.loc.filename = this.filename), this.state.comments.push(e2);
    }
    processComment(e2) {
      const { commentStack: t2 } = this.state, s2 = t2.length;
      if (s2 === 0)
        return;
      let r2 = s2 - 1;
      const i2 = t2[r2];
      i2.start === e2.end && (i2.leadingNode = e2, r2--);
      const { start: a2 } = e2;
      for (; r2 >= 0; r2--) {
        const s3 = t2[r2], i3 = s3.end;
        if (!(i3 > a2)) {
          i3 === a2 && (s3.trailingNode = e2);
          break;
        }
        s3.containingNode = e2, this.finalizeComment(s3), t2.splice(r2, 1);
      }
    }
    finalizeComment(e2) {
      const { comments: t2 } = e2;
      if (e2.leadingNode !== null || e2.trailingNode !== null)
        e2.leadingNode !== null && kn$1(e2.leadingNode, t2), e2.trailingNode !== null && (e2.trailingNode.leadingComments = t2);
      else {
        const { containingNode: s2, start: r2 } = e2;
        if (this.input.charCodeAt(r2 - 1) === 44)
          switch (s2.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              On$1(s2, s2.properties, e2);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              On$1(s2, s2.arguments, e2);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              On$1(s2, s2.params, e2);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              On$1(s2, s2.elements, e2);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              On$1(s2, s2.specifiers, e2);
              break;
            default:
              Ln$1(s2, t2);
          }
        else
          Ln$1(s2, t2);
      }
    }
    finalizeRemainingComments() {
      const { commentStack: e2 } = this.state;
      for (let t2 = e2.length - 1; t2 >= 0; t2--)
        this.finalizeComment(e2[t2]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e2) {
      const { commentStack: t2 } = this.state, { length: s2 } = t2;
      if (s2 === 0)
        return;
      const r2 = t2[s2 - 1];
      r2.leadingNode === e2 && (r2.leadingNode = null);
    }
  } {
    getLocationForPosition(e2) {
      let t2;
      return t2 = e2 === this.state.start ? this.state.startLoc : e2 === this.state.lastTokStart ? this.state.lastTokStartLoc : e2 === this.state.end ? this.state.endLoc : e2 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(e3, t3) {
        let s2, r2 = 1, i2 = 0;
        for (Tn$1.lastIndex = 0; (s2 = Tn$1.exec(e3)) && s2.index < t3; )
          r2++, i2 = Tn$1.lastIndex;
        return new In$1(r2, t3 - i2);
      }(this.input, e2), t2;
    }
    raise(e2, { code: t2, reasonCode: s2, template: r2 }, ...i2) {
      return this.raiseWithData(e2, { code: t2, reasonCode: s2 }, r2, ...i2);
    }
    raiseOverwrite(e2, { code: t2, template: s2 }, ...r2) {
      const i2 = this.getLocationForPosition(e2), a2 = s2.replace(/%(\d+)/g, (e3, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
      if (this.options.errorRecovery) {
        const t3 = this.state.errors;
        for (let s3 = t3.length - 1; s3 >= 0; s3--) {
          const r3 = t3[s3];
          if (r3.pos === e2)
            return Object.assign(r3, { message: a2 });
          if (r3.pos < e2)
            break;
        }
      }
      return this._raise({ code: t2, loc: i2, pos: e2 }, a2);
    }
    raiseWithData(e2, t2, s2, ...r2) {
      const i2 = this.getLocationForPosition(e2), a2 = s2.replace(/%(\d+)/g, (e3, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
      return this._raise(Object.assign({ loc: i2, pos: e2 }, t2), a2);
    }
    _raise(e2, t2) {
      const s2 = new SyntaxError(t2);
      if (Object.assign(s2, e2), this.options.errorRecovery)
        return this.isLookahead || this.state.errors.push(s2), s2;
      throw s2;
    }
  } {
    constructor(e2, t2) {
      super(), this.isLookahead = void 0, this.tokens = [], this.state = new Do$1(), this.state.init(e2), this.input = t2, this.length = t2.length, this.isLookahead = false;
    }
    pushToken(e2) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e2), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Eo$1(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e2) {
      return !!this.match(e2) && (this.next(), true);
    }
    match(e2) {
      return this.state.type === e2;
    }
    createLookaheadState(e2) {
      return { pos: e2.pos, value: null, type: e2.type, start: e2.start, end: e2.end, lastTokEnd: e2.end, context: [this.curContext()], inType: e2.inType };
    }
    lookahead() {
      const e2 = this.state;
      this.state = this.createLookaheadState(e2), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      const t2 = this.state;
      return this.state = e2, t2;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e2) {
      return Sn$1.lastIndex = e2, Sn$1.test(this.input) ? Sn$1.lastIndex : e2;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(e2) {
      let t2 = this.input.charCodeAt(e2);
      if ((64512 & t2) == 55296 && ++e2 < this.input.length) {
        const s2 = this.input.charCodeAt(e2);
        (64512 & s2) == 56320 && (t2 = 65536 + ((1023 & t2) << 10) + (1023 & s2));
      }
      return t2;
    }
    setStrict(e2) {
      this.state.strict = e2, e2 && (this.state.strictErrors.forEach((e3, t2) => this.raise(t2, e3)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      const e2 = this.curContext();
      e2.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(bn$1.eof) : e2 === $n$1.template ? this.readTmplToken() : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment() {
      let e2;
      this.isLookahead || (e2 = this.state.curPosition());
      const t2 = this.state.pos, s2 = this.input.indexOf("*/", t2 + 2);
      if (s2 === -1)
        throw this.raise(t2, Rn$1.UnterminatedComment);
      for (this.state.pos = s2 + 2, Tn$1.lastIndex = t2 + 2; Tn$1.test(this.input) && Tn$1.lastIndex <= s2; )
        ++this.state.curLine, this.state.lineStart = Tn$1.lastIndex;
      if (this.isLookahead)
        return;
      const r2 = { type: "CommentBlock", value: this.input.slice(t2 + 2, s2), start: t2, end: s2 + 2, loc: new vn$1(e2, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(r2), r2;
    }
    skipLineComment(e2) {
      const t2 = this.state.pos;
      let s2;
      this.isLookahead || (s2 = this.state.curPosition());
      let r2 = this.input.charCodeAt(this.state.pos += e2);
      if (this.state.pos < this.length)
        for (; !wn$1(r2) && ++this.state.pos < this.length; )
          r2 = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      const i2 = this.state.pos, a2 = { type: "CommentLine", value: this.input.slice(t2 + e2, i2), start: t2, end: i2, loc: new vn$1(s2, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(a2), a2;
    }
    skipSpace() {
      const e2 = this.state.pos, t2 = [];
      e:
        for (; this.state.pos < this.length; ) {
          const s2 = this.input.charCodeAt(this.state.pos);
          switch (s2) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const e3 = this.skipBlockComment();
                  e3 !== void 0 && (this.addComment(e3), this.options.attachComment && t2.push(e3));
                  break;
                }
                case 47: {
                  const e3 = this.skipLineComment(2);
                  e3 !== void 0 && (this.addComment(e3), this.options.attachComment && t2.push(e3));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (Nn$1(s2))
                ++this.state.pos;
              else if (s2 !== 45 || this.inModule) {
                if (s2 !== 60 || this.inModule)
                  break e;
                {
                  const e3 = this.state.pos;
                  if (this.input.charCodeAt(e3 + 1) !== 33 || this.input.charCodeAt(e3 + 2) !== 45 || this.input.charCodeAt(e3 + 3) !== 45)
                    break e;
                  {
                    const e4 = this.skipLineComment(4);
                    e4 !== void 0 && (this.addComment(e4), this.options.attachComment && t2.push(e4));
                  }
                }
              } else {
                const s3 = this.state.pos;
                if (this.input.charCodeAt(s3 + 1) !== 45 || this.input.charCodeAt(s3 + 2) !== 62 || !(e2 === 0 || this.state.lineStart > e2))
                  break e;
                {
                  const e3 = this.skipLineComment(3);
                  e3 !== void 0 && (this.addComment(e3), this.options.attachComment && t2.push(e3));
                }
              }
          }
        }
      if (t2.length > 0) {
        const s2 = { start: e2, end: this.state.pos, comments: t2, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(s2);
      }
    }
    finishToken(e2, t2) {
      this.state.end = this.state.pos;
      const s2 = this.state.type;
      this.state.type = e2, this.state.value = t2, this.isLookahead || (this.state.endLoc = this.state.curPosition(), this.updateContext(s2));
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const e2 = this.state.pos + 1, t2 = this.codePointAtPos(e2);
      if (t2 >= 48 && t2 <= 57)
        throw this.raise(this.state.pos, Rn$1.UnexpectedDigitAfterHash);
      if (t2 === 123 || t2 === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
          throw this.raise(this.state.pos, t2 === 123 ? Rn$1.RecordExpressionHashIncorrectStartSyntaxType : Rn$1.TupleExpressionHashIncorrectStartSyntaxType);
        this.state.pos += 2, t2 === 123 ? this.finishToken(bn$1.braceHashL) : this.finishToken(bn$1.bracketHashL);
      } else
        Jn$1(t2) ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1(t2))) : t2 === 92 ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1())) : this.finishOp(bn$1.hash, 1);
    }
    readToken_dot() {
      const e2 = this.input.charCodeAt(this.state.pos + 1);
      e2 >= 48 && e2 <= 57 ? this.readNumber(true) : e2 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(bn$1.ellipsis)) : (++this.state.pos, this.finishToken(bn$1.dot));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.slashAssign, 2) : this.finishOp(bn$1.slash, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let e2 = this.input.charCodeAt(this.state.pos + 1);
      if (e2 !== 33)
        return false;
      const t2 = this.state.pos;
      for (this.state.pos += 1; !wn$1(e2) && ++this.state.pos < this.length; )
        e2 = this.input.charCodeAt(this.state.pos);
      const s2 = this.input.slice(t2 + 2, this.state.pos);
      return this.finishToken(bn$1.interpreterDirective, s2), true;
    }
    readToken_mult_modulo(e2) {
      let t2 = e2 === 42 ? bn$1.star : bn$1.modulo, s2 = 1, r2 = this.input.charCodeAt(this.state.pos + 1);
      e2 === 42 && r2 === 42 && (s2++, r2 = this.input.charCodeAt(this.state.pos + 2), t2 = bn$1.exponent), r2 !== 61 || this.state.inType || (s2++, t2 = e2 === 37 ? bn$1.moduloAssign : bn$1.assign), this.finishOp(t2, s2);
    }
    readToken_pipe_amp(e2) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      if (t2 !== e2) {
        if (e2 === 124) {
          if (t2 === 62)
            return void this.finishOp(bn$1.pipeline, 2);
          if (this.hasPlugin("recordAndTuple") && t2 === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectEndSyntaxType);
            return this.state.pos += 2, void this.finishToken(bn$1.braceBarR);
          }
          if (this.hasPlugin("recordAndTuple") && t2 === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectEndSyntaxType);
            return this.state.pos += 2, void this.finishToken(bn$1.bracketBarR);
          }
        }
        t2 !== 61 ? this.finishOp(e2 === 124 ? bn$1.bitwiseOR : bn$1.bitwiseAND, 1) : this.finishOp(bn$1.assign, 2);
      } else
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(e2 === 124 ? bn$1.logicalOR : bn$1.logicalAND, 2);
    }
    readToken_caret() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.bitwiseXOR, 1);
    }
    readToken_plus_min(e2) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      t2 !== e2 ? t2 === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.plusMin, 1) : this.finishOp(bn$1.incDec, 2);
    }
    readToken_lt_gt(e2) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      let s2 = 1;
      if (t2 === e2)
        return s2 = e2 === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.state.pos + s2) === 61 ? void this.finishOp(bn$1.assign, s2 + 1) : void this.finishOp(bn$1.bitShift, s2);
      t2 === 61 && (s2 = 2), this.finishOp(bn$1.relational, s2);
    }
    readToken_eq_excl(e2) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      if (t2 !== 61)
        return e2 === 61 && t2 === 62 ? (this.state.pos += 2, void this.finishToken(bn$1.arrow)) : void this.finishOp(e2 === 61 ? bn$1.eq : bn$1.bang, 1);
      this.finishOp(bn$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    }
    readToken_question() {
      const e2 = this.input.charCodeAt(this.state.pos + 1), t2 = this.input.charCodeAt(this.state.pos + 2);
      e2 === 63 ? t2 === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(bn$1.nullishCoalescing, 2) : e2 !== 46 || t2 >= 48 && t2 <= 57 ? (++this.state.pos, this.finishToken(bn$1.question)) : (this.state.pos += 2, this.finishToken(bn$1.questionDot));
    }
    getTokenFromCode(e2) {
      switch (e2) {
        case 46:
          return void this.readToken_dot();
        case 40:
          return ++this.state.pos, void this.finishToken(bn$1.parenL);
        case 41:
          return ++this.state.pos, void this.finishToken(bn$1.parenR);
        case 59:
          return ++this.state.pos, void this.finishToken(bn$1.semi);
        case 44:
          return ++this.state.pos, void this.finishToken(bn$1.comma);
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectStartSyntaxType);
            this.state.pos += 2, this.finishToken(bn$1.bracketBarL);
          } else
            ++this.state.pos, this.finishToken(bn$1.bracketL);
          return;
        case 93:
          return ++this.state.pos, void this.finishToken(bn$1.bracketR);
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectStartSyntaxType);
            this.state.pos += 2, this.finishToken(bn$1.braceBarL);
          } else
            ++this.state.pos, this.finishToken(bn$1.braceL);
          return;
        case 125:
          return ++this.state.pos, void this.finishToken(bn$1.braceR);
        case 58:
          return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(bn$1.doubleColon, 2) : (++this.state.pos, this.finishToken(bn$1.colon)));
        case 63:
          return void this.readToken_question();
        case 96:
          return ++this.state.pos, void this.finishToken(bn$1.backQuote);
        case 48: {
          const e3 = this.input.charCodeAt(this.state.pos + 1);
          if (e3 === 120 || e3 === 88)
            return void this.readRadixNumber(16);
          if (e3 === 111 || e3 === 79)
            return void this.readRadixNumber(8);
          if (e3 === 98 || e3 === 66)
            return void this.readRadixNumber(2);
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return void this.readNumber(false);
        case 34:
        case 39:
          return void this.readString(e2);
        case 47:
          return void this.readToken_slash();
        case 37:
        case 42:
          return void this.readToken_mult_modulo(e2);
        case 124:
        case 38:
          return void this.readToken_pipe_amp(e2);
        case 94:
          return void this.readToken_caret();
        case 43:
        case 45:
          return void this.readToken_plus_min(e2);
        case 60:
        case 62:
          return void this.readToken_lt_gt(e2);
        case 61:
        case 33:
          return void this.readToken_eq_excl(e2);
        case 126:
          return void this.finishOp(bn$1.tilde, 1);
        case 64:
          return ++this.state.pos, void this.finishToken(bn$1.at);
        case 35:
          return void this.readToken_numberSign();
        case 92:
          return void this.readWord();
        default:
          if (Jn$1(e2))
            return void this.readWord(e2);
      }
      throw this.raise(this.state.pos, Rn$1.InvalidOrUnexpectedToken, String.fromCodePoint(e2));
    }
    finishOp(e2, t2) {
      const s2 = this.input.slice(this.state.pos, this.state.pos + t2);
      this.state.pos += t2, this.finishToken(e2, s2);
    }
    readRegexp() {
      const e2 = this.state.start + 1;
      let t2, s2, { pos: r2 } = this.state;
      for (; ; ++r2) {
        if (r2 >= this.length)
          throw this.raise(e2, Rn$1.UnterminatedRegExp);
        const i3 = this.input.charCodeAt(r2);
        if (wn$1(i3))
          throw this.raise(e2, Rn$1.UnterminatedRegExp);
        if (t2)
          t2 = false;
        else {
          if (i3 === 91)
            s2 = true;
          else if (i3 === 93 && s2)
            s2 = false;
          else if (i3 === 47 && !s2)
            break;
          t2 = i3 === 92;
        }
      }
      const i2 = this.input.slice(e2, r2);
      ++r2;
      let a2 = "";
      for (; r2 < this.length; ) {
        const e3 = this.codePointAtPos(r2), t3 = String.fromCharCode(e3);
        if (fo$1.has(e3))
          a2.includes(t3) && this.raise(r2 + 1, Rn$1.DuplicateRegExpFlags);
        else {
          if (!Yn$1(e3) && e3 !== 92)
            break;
          this.raise(r2 + 1, Rn$1.MalformedRegExpFlags);
        }
        ++r2, a2 += t3;
      }
      this.state.pos = r2, this.finishToken(bn$1.regexp, { pattern: i2, flags: a2 });
    }
    readInt(e2, t2, s2, r2 = true) {
      const i2 = this.state.pos, a2 = e2 === 16 ? yo$1.hex : yo$1.decBinOct, n2 = e2 === 16 ? Ao$1.hex : e2 === 10 ? Ao$1.dec : e2 === 8 ? Ao$1.oct : Ao$1.bin;
      let o2 = false, u2 = 0;
      for (let i3 = 0, h2 = t2 == null ? 1 / 0 : t2; i3 < h2; ++i3) {
        const t3 = this.input.charCodeAt(this.state.pos);
        let h3;
        if (t3 !== 95) {
          if (h3 = t3 >= 97 ? t3 - 97 + 10 : t3 >= 65 ? t3 - 65 + 10 : mo$1(t3) ? t3 - 48 : 1 / 0, h3 >= e2)
            if (this.options.errorRecovery && h3 <= 9)
              h3 = 0, this.raise(this.state.start + i3 + 2, Rn$1.InvalidDigit, e2);
            else {
              if (!s2)
                break;
              h3 = 0, o2 = true;
            }
          ++this.state.pos, u2 = u2 * e2 + h3;
        } else {
          const e3 = this.input.charCodeAt(this.state.pos - 1), t4 = this.input.charCodeAt(this.state.pos + 1);
          (n2.indexOf(t4) === -1 || a2.indexOf(e3) > -1 || a2.indexOf(t4) > -1 || Number.isNaN(t4)) && this.raise(this.state.pos, Rn$1.UnexpectedNumericSeparator), r2 || this.raise(this.state.pos, Rn$1.NumericSeparatorInEscapeSequence), ++this.state.pos;
        }
      }
      return this.state.pos === i2 || t2 != null && this.state.pos - i2 !== t2 || o2 ? null : u2;
    }
    readRadixNumber(e2) {
      const t2 = this.state.pos;
      let s2 = false;
      this.state.pos += 2;
      const r2 = this.readInt(e2);
      r2 == null && this.raise(this.state.start + 2, Rn$1.InvalidDigit, e2);
      const i2 = this.input.charCodeAt(this.state.pos);
      if (i2 === 110)
        ++this.state.pos, s2 = true;
      else if (i2 === 109)
        throw this.raise(t2, Rn$1.InvalidDecimal);
      if (Jn$1(this.codePointAtPos(this.state.pos)))
        throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
      if (s2) {
        const e3 = this.input.slice(t2, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(bn$1.bigint, e3);
      } else
        this.finishToken(bn$1.num, r2);
    }
    readNumber(e2) {
      const t2 = this.state.pos;
      let s2 = false, r2 = false, i2 = false, a2 = false, n2 = false;
      e2 || this.readInt(10) !== null || this.raise(t2, Rn$1.InvalidNumber);
      const o2 = this.state.pos - t2 >= 2 && this.input.charCodeAt(t2) === 48;
      if (o2) {
        const e3 = this.input.slice(t2, this.state.pos);
        if (this.recordStrictModeErrors(t2, Rn$1.StrictOctalLiteral), !this.state.strict) {
          const s3 = e3.indexOf("_");
          s3 > 0 && this.raise(s3 + t2, Rn$1.ZeroDigitNumericSeparator);
        }
        n2 = o2 && !/[89]/.test(e3);
      }
      let u2 = this.input.charCodeAt(this.state.pos);
      if (u2 !== 46 || n2 || (++this.state.pos, this.readInt(10), s2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 !== 69 && u2 !== 101 || n2 || (u2 = this.input.charCodeAt(++this.state.pos), u2 !== 43 && u2 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(t2, Rn$1.InvalidOrMissingExponent), s2 = true, a2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 === 110 && ((s2 || o2) && this.raise(t2, Rn$1.InvalidBigIntLiteral), ++this.state.pos, r2 = true), u2 === 109 && (this.expectPlugin("decimal", this.state.pos), (a2 || o2) && this.raise(t2, Rn$1.InvalidDecimal), ++this.state.pos, i2 = true), Jn$1(this.codePointAtPos(this.state.pos)))
        throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
      const h2 = this.input.slice(t2, this.state.pos).replace(/[_mn]/g, "");
      if (r2)
        return void this.finishToken(bn$1.bigint, h2);
      if (i2)
        return void this.finishToken(bn$1.decimal, h2);
      const c2 = n2 ? parseInt(h2, 8) : parseFloat(h2);
      this.finishToken(bn$1.num, c2);
    }
    readCodePoint(e2) {
      let t2;
      if (this.input.charCodeAt(this.state.pos) === 123) {
        const s2 = ++this.state.pos;
        if (t2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e2), ++this.state.pos, t2 !== null && t2 > 1114111) {
          if (!e2)
            return null;
          this.raise(s2, Rn$1.InvalidCodePoint);
        }
      } else
        t2 = this.readHexChar(4, false, e2);
      return t2;
    }
    readString(e2) {
      let t2 = "", s2 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, Rn$1.UnterminatedString);
        const r2 = this.input.charCodeAt(this.state.pos);
        if (r2 === e2)
          break;
        if (r2 === 92)
          t2 += this.input.slice(s2, this.state.pos), t2 += this.readEscapedChar(false), s2 = this.state.pos;
        else if (r2 === 8232 || r2 === 8233)
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
        else {
          if (wn$1(r2))
            throw this.raise(this.state.start, Rn$1.UnterminatedString);
          ++this.state.pos;
        }
      }
      t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
    }
    readTmplToken() {
      let e2 = "", t2 = this.state.pos, s2 = false;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, Rn$1.UnterminatedTemplate);
        const r2 = this.input.charCodeAt(this.state.pos);
        if (r2 === 96 || r2 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
          return this.state.pos === this.state.start && this.match(bn$1.template) ? r2 === 36 ? (this.state.pos += 2, void this.finishToken(bn$1.dollarBraceL)) : (++this.state.pos, void this.finishToken(bn$1.backQuote)) : (e2 += this.input.slice(t2, this.state.pos), void this.finishToken(bn$1.template, s2 ? null : e2));
        if (r2 === 92) {
          e2 += this.input.slice(t2, this.state.pos);
          const r3 = this.readEscapedChar(true);
          r3 === null ? s2 = true : e2 += r3, t2 = this.state.pos;
        } else if (wn$1(r2)) {
          switch (e2 += this.input.slice(t2, this.state.pos), ++this.state.pos, r2) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
            case 10:
              e2 += "\n";
              break;
            default:
              e2 += String.fromCharCode(r2);
          }
          ++this.state.curLine, this.state.lineStart = this.state.pos, t2 = this.state.pos;
        } else
          ++this.state.pos;
      }
    }
    recordStrictModeErrors(e2, t2) {
      this.state.strict && !this.state.strictErrors.has(e2) ? this.raise(e2, t2) : this.state.strictErrors.set(e2, t2);
    }
    readEscapedChar(e2) {
      const t2 = !e2, s2 = this.input.charCodeAt(++this.state.pos);
      switch (++this.state.pos, s2) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120: {
          const e3 = this.readHexChar(2, false, t2);
          return e3 === null ? null : String.fromCharCode(e3);
        }
        case 117: {
          const e3 = this.readCodePoint(t2);
          return e3 === null ? null : String.fromCodePoint(e3);
        }
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
        case 10:
          this.state.lineStart = this.state.pos, ++this.state.curLine;
        case 8232:
        case 8233:
          return "";
        case 56:
        case 57:
          if (e2)
            return null;
          this.recordStrictModeErrors(this.state.pos - 1, Rn$1.StrictNumericEscape);
        default:
          if (s2 >= 48 && s2 <= 55) {
            const t3 = this.state.pos - 1;
            let s3 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s3, 8);
            r2 > 255 && (s3 = s3.slice(0, -1), r2 = parseInt(s3, 8)), this.state.pos += s3.length - 1;
            const i2 = this.input.charCodeAt(this.state.pos);
            if (s3 !== "0" || i2 === 56 || i2 === 57) {
              if (e2)
                return null;
              this.recordStrictModeErrors(t3, Rn$1.StrictNumericEscape);
            }
            return String.fromCharCode(r2);
          }
          return String.fromCharCode(s2);
      }
    }
    readHexChar(e2, t2, s2) {
      const r2 = this.state.pos, i2 = this.readInt(16, e2, t2, false);
      return i2 === null && (s2 ? this.raise(r2, Rn$1.InvalidEscapeSequence) : this.state.pos = r2 - 1), i2;
    }
    readWord1(e2) {
      this.state.containsEsc = false;
      let t2 = "";
      const s2 = this.state.pos;
      let r2 = this.state.pos;
      for (e2 !== void 0 && (this.state.pos += e2 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const e3 = this.codePointAtPos(this.state.pos);
        if (Yn$1(e3))
          this.state.pos += e3 <= 65535 ? 1 : 2;
        else {
          if (e3 !== 92)
            break;
          {
            this.state.containsEsc = true, t2 += this.input.slice(r2, this.state.pos);
            const e4 = this.state.pos, i2 = this.state.pos === s2 ? Jn$1 : Yn$1;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(this.state.pos, Rn$1.MissingUnicodeEscape), r2 = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const a2 = this.readCodePoint(true);
            a2 !== null && (i2(a2) || this.raise(e4, Rn$1.EscapedCharNotAnIdentifier), t2 += String.fromCodePoint(a2)), r2 = this.state.pos;
          }
        }
      }
      return t2 + this.input.slice(r2, this.state.pos);
    }
    readWord(e2) {
      const t2 = this.readWord1(e2), s2 = xn$1.get(t2) || bn$1.name;
      this.finishToken(s2, t2);
    }
    checkKeywordEscapes() {
      const e2 = this.state.type.keyword;
      e2 && this.state.containsEsc && this.raise(this.state.start, Rn$1.InvalidEscapedReservedWord, e2);
    }
    updateContext(e2) {
      var t2, s2;
      (t2 = (s2 = this.state.type).updateContext) == null || t2.call(s2, this.state.context);
    }
  } {
    addExtra(e2, t2, s2) {
      if (!e2)
        return;
      (e2.extra = e2.extra || {})[t2] = s2;
    }
    isRelational(e2) {
      return this.match(bn$1.relational) && this.state.value === e2;
    }
    expectRelational(e2) {
      this.isRelational(e2) ? this.next() : this.unexpected(null, bn$1.relational);
    }
    isContextual(e2) {
      return this.match(bn$1.name) && this.state.value === e2 && !this.state.containsEsc;
    }
    isUnparsedContextual(e2, t2) {
      const s2 = e2 + t2.length;
      if (this.input.slice(e2, s2) === t2) {
        const e3 = this.input.charCodeAt(s2);
        return !(Yn$1(e3) || (64512 & e3) == 55296);
      }
      return false;
    }
    isLookaheadContextual(e2) {
      const t2 = this.nextTokenStart();
      return this.isUnparsedContextual(t2, e2);
    }
    eatContextual(e2) {
      return this.isContextual(e2) && this.eat(bn$1.name);
    }
    expectContextual(e2, t2) {
      this.eatContextual(e2) || this.unexpected(null, t2);
    }
    canInsertSemicolon() {
      return this.match(bn$1.eof) || this.match(bn$1.braceR) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Pn$1.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
    hasFollowingLineBreak() {
      return Bn$1.lastIndex = this.state.end, Bn$1.test(this.input);
    }
    isLineTerminator() {
      return this.eat(bn$1.semi) || this.canInsertSemicolon();
    }
    semicolon(e2 = true) {
      (e2 ? this.isLineTerminator() : this.eat(bn$1.semi)) || this.raise(this.state.lastTokEnd, Rn$1.MissingSemicolon);
    }
    expect(e2, t2) {
      this.eat(e2) || this.unexpected(t2, e2);
    }
    assertNoSpace(e2 = "Unexpected space.") {
      this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, { code: Mn$1.SyntaxError, reasonCode: "UnexpectedSpace", template: e2 });
    }
    unexpected(e2, t2 = { code: Mn$1.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token" }) {
      throw t2 instanceof Cn$1 && (t2 = { code: Mn$1.SyntaxError, reasonCode: "UnexpectedToken", template: `Unexpected token, expected "${t2.label}"` }), this.raise(e2 != null ? e2 : this.state.start, t2);
    }
    expectPlugin(e2, t2) {
      if (!this.hasPlugin(e2))
        throw this.raiseWithData(t2 != null ? t2 : this.state.start, { missingPlugin: [e2] }, `This experimental syntax requires enabling the parser plugin: '${e2}'`);
      return true;
    }
    expectOnePlugin(e2, t2) {
      if (!e2.some((e3) => this.hasPlugin(e3)))
        throw this.raiseWithData(t2 != null ? t2 : this.state.start, { missingPlugin: e2 }, `This experimental syntax requires enabling one of the following parser plugin(s): '${e2.join(", ")}'`);
    }
    tryParse(e2, t2 = this.state.clone()) {
      const s2 = { node: null };
      try {
        const r2 = e2((e3 = null) => {
          throw s2.node = e3, s2;
        });
        if (this.state.errors.length > t2.errors.length) {
          const e3 = this.state;
          return this.state = t2, this.state.tokensLength = e3.tokensLength, { node: r2, error: e3.errors[t2.errors.length], thrown: false, aborted: false, failState: e3 };
        }
        return { node: r2, error: null, thrown: false, aborted: false, failState: null };
      } catch (e3) {
        const r2 = this.state;
        if (this.state = t2, e3 instanceof SyntaxError)
          return { node: null, error: e3, thrown: true, aborted: false, failState: r2 };
        if (e3 === s2)
          return { node: s2.node, error: null, thrown: false, aborted: true, failState: r2 };
        throw e3;
      }
    }
    checkExpressionErrors(e2, t2) {
      if (!e2)
        return false;
      const { shorthandAssign: s2, doubleProto: r2, optionalParameters: i2 } = e2;
      if (!t2)
        return s2 >= 0 || r2 >= 0 || i2 >= 0;
      s2 >= 0 && this.unexpected(s2), r2 >= 0 && this.raise(r2, Rn$1.DuplicateProto), i2 >= 0 && this.unexpected(i2);
    }
    isLiteralPropertyName() {
      return this.match(bn$1.name) || !!this.state.type.keyword || this.match(bn$1.string) || this.match(bn$1.num) || this.match(bn$1.bigint) || this.match(bn$1.decimal);
    }
    isPrivateName(e2) {
      return e2.type === "PrivateName";
    }
    getPrivateNameSV(e2) {
      return e2.id.name;
    }
    hasPropertyAsPrivateName(e2) {
      return (e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression") && this.isPrivateName(e2.property);
    }
    isOptionalChain(e2) {
      return e2.type === "OptionalMemberExpression" || e2.type === "OptionalCallExpression";
    }
    isObjectProperty(e2) {
      return e2.type === "ObjectProperty";
    }
    isObjectMethod(e2) {
      return e2.type === "ObjectMethod";
    }
    initializeScopes(e2 = this.options.sourceType === "module") {
      const t2 = this.state.labels;
      this.state.labels = [];
      const s2 = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      const r2 = this.inModule;
      this.inModule = e2;
      const i2 = this.scope, a2 = this.getScopeHandler();
      this.scope = new a2(this.raise.bind(this), this.inModule);
      const n2 = this.prodParam;
      this.prodParam = new To$1();
      const o2 = this.classScope;
      this.classScope = new xo$1(this.raise.bind(this));
      const u2 = this.expressionScope;
      return this.expressionScope = new bo$1(this.raise.bind(this)), () => {
        this.state.labels = t2, this.exportedIdentifiers = s2, this.inModule = r2, this.scope = i2, this.prodParam = n2, this.classScope = o2, this.expressionScope = u2;
      };
    }
    enterInitialScopes() {
      let e2 = 0;
      this.inModule && (e2 |= 2), this.scope.enter(1), this.prodParam.enter(e2);
    }
  } {
    startNode() {
      return new Bo$1(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(e2, t2) {
      return new Bo$1(this, e2, t2);
    }
    startNodeAtNode(e2) {
      return this.startNodeAt(e2.start, e2.loc.start);
    }
    finishNode(e2, t2) {
      return this.finishNodeAt(e2, t2, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
    finishNodeAt(e2, t2, s2, r2) {
      return e2.type = t2, e2.end = s2, e2.loc.end = r2, this.options.ranges && (e2.range[1] = s2), this.options.attachComment && this.processComment(e2), e2;
    }
    resetStartLocation(e2, t2, s2) {
      e2.start = t2, e2.loc.start = s2, this.options.ranges && (e2.range[0] = t2);
    }
    resetEndLocation(e2, t2 = this.state.lastTokEnd, s2 = this.state.lastTokEndLoc) {
      e2.end = t2, e2.loc.end = s2, this.options.ranges && (e2.range[1] = t2);
    }
    resetStartLocationFromNode(e2, t2) {
      this.resetStartLocation(e2, t2.start, t2.loc.start);
    }
  } {
    toAssignable(e2, t2 = false) {
      var s2, r2;
      let i2;
      switch ((e2.type === "ParenthesizedExpression" || (s2 = e2.extra) != null && s2.parenthesized) && (i2 = nu(e2), t2 ? i2.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(e2.start, Rn$1.InvalidParenthesizedAssignment) : i2.type !== "MemberExpression" && this.raise(e2.start, Rn$1.InvalidParenthesizedAssignment) : this.raise(e2.start, Rn$1.InvalidParenthesizedAssignment)), e2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e2.type = "ObjectPattern";
          for (let s3 = 0, r3 = e2.properties.length, i3 = r3 - 1; s3 < r3; s3++) {
            var a2;
            const r4 = e2.properties[s3], n2 = s3 === i3;
            this.toAssignableObjectExpressionProp(r4, n2, t2), n2 && r4.type === "RestElement" && (a2 = e2.extra) != null && a2.trailingComma && this.raiseRestNotLast(e2.extra.trailingComma);
          }
          break;
        case "ObjectProperty":
          this.toAssignable(e2.value, t2);
          break;
        case "SpreadElement": {
          this.checkToRestConversion(e2), e2.type = "RestElement";
          const s3 = e2.argument;
          this.toAssignable(s3, t2);
          break;
        }
        case "ArrayExpression":
          e2.type = "ArrayPattern", this.toAssignableList(e2.elements, (r2 = e2.extra) == null ? void 0 : r2.trailingComma, t2);
          break;
        case "AssignmentExpression":
          e2.operator !== "=" && this.raise(e2.left.end, Rn$1.MissingEqInAssignment), e2.type = "AssignmentPattern", delete e2.operator, this.toAssignable(e2.left, t2);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(i2, t2);
      }
      return e2;
    }
    toAssignableObjectExpressionProp(e2, t2, s2) {
      if (e2.type === "ObjectMethod") {
        const t3 = e2.kind === "get" || e2.kind === "set" ? Rn$1.PatternHasAccessor : Rn$1.PatternHasMethod;
        this.raise(e2.key.start, t3);
      } else
        e2.type !== "SpreadElement" || t2 ? this.toAssignable(e2, s2) : this.raiseRestNotLast(e2.start);
    }
    toAssignableList(e2, t2, s2) {
      let r2 = e2.length;
      if (r2) {
        const i2 = e2[r2 - 1];
        if ((i2 == null ? void 0 : i2.type) === "RestElement")
          --r2;
        else if ((i2 == null ? void 0 : i2.type) === "SpreadElement") {
          i2.type = "RestElement";
          let e3 = i2.argument;
          this.toAssignable(e3, s2), e3 = nu(e3), e3.type !== "Identifier" && e3.type !== "MemberExpression" && e3.type !== "ArrayPattern" && e3.type !== "ObjectPattern" && this.unexpected(e3.start), t2 && this.raiseTrailingCommaAfterRest(t2), --r2;
        }
      }
      for (let t3 = 0; t3 < r2; t3++) {
        const r3 = e2[t3];
        r3 && (this.toAssignable(r3, s2), r3.type === "RestElement" && this.raiseRestNotLast(r3.start));
      }
      return e2;
    }
    isAssignable(e2, t2) {
      switch (e2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const t3 = e2.properties.length - 1;
          return e2.properties.every((e3, s2) => e3.type !== "ObjectMethod" && (s2 === t3 || e3.type !== "SpreadElement") && this.isAssignable(e3));
        }
        case "ObjectProperty":
          return this.isAssignable(e2.value);
        case "SpreadElement":
          return this.isAssignable(e2.argument);
        case "ArrayExpression":
          return e2.elements.every((e3) => e3 === null || this.isAssignable(e3));
        case "AssignmentExpression":
          return e2.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e2.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !t2;
        default:
          return false;
      }
    }
    toReferencedList(e2, t2) {
      return e2;
    }
    toReferencedListDeep(e2, t2) {
      this.toReferencedList(e2, t2);
      for (const t3 of e2)
        (t3 == null ? void 0 : t3.type) === "ArrayExpression" && this.toReferencedListDeep(t3.elements);
    }
    parseSpread(e2, t2) {
      const s2 = this.startNode();
      return this.next(), s2.argument = this.parseMaybeAssignAllowIn(e2, void 0, t2), this.finishNode(s2, "SpreadElement");
    }
    parseRestBinding() {
      const e2 = this.startNode();
      return this.next(), e2.argument = this.parseBindingAtom(), this.finishNode(e2, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1.bracketL: {
          const e2 = this.startNode();
          return this.next(), e2.elements = this.parseBindingList(bn$1.bracketR, 93, true), this.finishNode(e2, "ArrayPattern");
        }
        case bn$1.braceL:
          return this.parseObjectLike(bn$1.braceR, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e2, t2, s2, r2) {
      const i2 = [];
      let a2 = true;
      for (; !this.eat(e2); )
        if (a2 ? a2 = false : this.expect(bn$1.comma), s2 && this.match(bn$1.comma))
          i2.push(null);
        else {
          if (this.eat(e2))
            break;
          if (this.match(bn$1.ellipsis)) {
            i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(t2), this.expect(e2);
            break;
          }
          {
            const e3 = [];
            for (this.match(bn$1.at) && this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedParameterDecorator); this.match(bn$1.at); )
              e3.push(this.parseDecorator());
            i2.push(this.parseAssignableListItem(r2, e3));
          }
        }
      return i2;
    }
    parseAssignableListItem(e2, t2) {
      const s2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s2);
      const r2 = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
      return t2.length && (s2.decorators = t2), r2;
    }
    parseAssignableListItemTypes(e2) {
      return e2;
    }
    parseMaybeDefault(e2, t2, s2) {
      var r2, i2, a2;
      if (t2 = (r2 = t2) != null ? r2 : this.state.startLoc, e2 = (i2 = e2) != null ? i2 : this.state.start, s2 = (a2 = s2) != null ? a2 : this.parseBindingAtom(), !this.eat(bn$1.eq))
        return s2;
      const n2 = this.startNodeAt(e2, t2);
      return n2.left = s2, n2.right = this.parseMaybeAssignAllowIn(), this.finishNode(n2, "AssignmentPattern");
    }
    checkLVal(e2, t2, s2 = 64, r2, i2, a2 = false) {
      switch (e2.type) {
        case "Identifier": {
          const { name: t3 } = e2;
          this.state.strict && (a2 ? no$1(t3, this.inModule) : ao$1(t3)) && this.raise(e2.start, s2 === 64 ? Rn$1.StrictEvalArguments : Rn$1.StrictEvalArgumentsBinding, t3), r2 && (r2.has(t3) ? this.raise(e2.start, Rn$1.ParamDupe) : r2.add(t3)), i2 && t3 === "let" && this.raise(e2.start, Rn$1.LetInLexicalBinding), 64 & s2 || this.scope.declareName(t3, s2, e2.start);
          break;
        }
        case "MemberExpression":
          s2 !== 64 && this.raise(e2.start, Rn$1.InvalidPropertyBindingPattern);
          break;
        case "ObjectPattern":
          for (let t3 of e2.properties) {
            if (this.isObjectProperty(t3))
              t3 = t3.value;
            else if (this.isObjectMethod(t3))
              continue;
            this.checkLVal(t3, "object destructuring pattern", s2, r2, i2);
          }
          break;
        case "ArrayPattern":
          for (const t3 of e2.elements)
            t3 && this.checkLVal(t3, "array destructuring pattern", s2, r2, i2);
          break;
        case "AssignmentPattern":
          this.checkLVal(e2.left, "assignment pattern", s2, r2);
          break;
        case "RestElement":
          this.checkLVal(e2.argument, "rest element", s2, r2);
          break;
        case "ParenthesizedExpression":
          this.checkLVal(e2.expression, "parenthesized expression", s2, r2);
          break;
        default:
          this.raise(e2.start, s2 === 64 ? Rn$1.InvalidLhs : Rn$1.InvalidLhsBinding, t2);
      }
    }
    checkToRestConversion(e2) {
      e2.argument.type !== "Identifier" && e2.argument.type !== "MemberExpression" && this.raise(e2.argument.start, Rn$1.InvalidRestAssignmentPattern);
    }
    checkCommaAfterRest(e2) {
      this.match(bn$1.comma) && (this.lookaheadCharCode() === e2 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
    }
    raiseRestNotLast(e2) {
      throw this.raise(e2, Rn$1.ElementAfterRest);
    }
    raiseTrailingCommaAfterRest(e2) {
      this.raise(e2, Rn$1.RestTrailingComma);
    }
  } {
    checkProto(e2, t2, s2, r2) {
      if (e2.type === "SpreadElement" || this.isObjectMethod(e2) || e2.computed || e2.shorthand)
        return;
      const i2 = e2.key;
      if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
        if (t2)
          return void this.raise(i2.start, Rn$1.RecordNoProto);
        s2.used && (r2 ? r2.doubleProto === -1 && (r2.doubleProto = i2.start) : this.raise(i2.start, Rn$1.DuplicateProto)), s2.used = true;
      }
    }
    shouldExitDescending(e2, t2) {
      return e2.type === "ArrowFunctionExpression" && e2.start === t2;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const e2 = this.parseExpression();
      return this.match(bn$1.eof) || this.unexpected(), this.finalizeRemainingComments(), e2.comments = this.state.comments, e2.errors = this.state.errors, this.options.tokens && (e2.tokens = this.tokens), e2;
    }
    parseExpression(e2, t2) {
      return e2 ? this.disallowInAnd(() => this.parseExpressionBase(t2)) : this.allowInAnd(() => this.parseExpressionBase(t2));
    }
    parseExpressionBase(e2) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.parseMaybeAssign(e2);
      if (this.match(bn$1.comma)) {
        const i2 = this.startNodeAt(t2, s2);
        for (i2.expressions = [r2]; this.eat(bn$1.comma); )
          i2.expressions.push(this.parseMaybeAssign(e2));
        return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
      }
      return r2;
    }
    parseMaybeAssignDisallowIn(e2, t2) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e2, t2));
    }
    parseMaybeAssignAllowIn(e2, t2) {
      return this.allowInAnd(() => this.parseMaybeAssign(e2, t2));
    }
    setOptionalParametersError(e2, t2) {
      var s2;
      e2.optionalParameters = (s2 = t2 == null ? void 0 : t2.pos) != null ? s2 : this.state.start;
    }
    parseMaybeAssign(e2, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      if (this.isContextual("yield") && this.prodParam.hasYield) {
        let e3 = this.parseYield();
        return t2 && (e3 = t2.call(this, e3, s2, r2)), e3;
      }
      let i2;
      e2 ? i2 = false : (e2 = new So$1(), i2 = true), (this.match(bn$1.parenL) || this.match(bn$1.name)) && (this.state.potentialArrowAt = this.state.start);
      let a2 = this.parseMaybeConditional(e2);
      if (t2 && (a2 = t2.call(this, a2, s2, r2)), this.state.type.isAssign) {
        const t3 = this.startNodeAt(s2, r2), i3 = this.state.value;
        t3.operator = i3;
        if (a2.type === "BinaryExpression" && a2.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack")
          throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, i3);
        return this.match(bn$1.eq) ? (t3.left = this.toAssignable(a2, true), e2.doubleProto = -1) : t3.left = a2, e2.shorthandAssign >= t3.left.start && (e2.shorthandAssign = -1), this.checkLVal(a2, "assignment expression"), this.next(), t3.right = this.parseMaybeAssign(), this.finishNode(t3, "AssignmentExpression");
      }
      return i2 && this.checkExpressionErrors(e2, true), a2;
    }
    parseMaybeConditional(e2) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprOps(e2);
      return this.shouldExitDescending(i2, r2) ? i2 : this.parseConditional(i2, t2, s2, e2);
    }
    parseConditional(e2, t2, s2, r2) {
      if (this.eat(bn$1.question)) {
        const r3 = this.startNodeAt(t2, s2);
        return r3.test = e2, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(bn$1.colon), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
      }
      return e2;
    }
    parseMaybeUnaryOrPrivate(e2) {
      return this.match(bn$1.privateName) ? this.parsePrivateName() : this.parseMaybeUnary(e2);
    }
    parseExprOps(e2) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(e2);
      return this.shouldExitDescending(i2, r2) ? i2 : this.parseExprOp(i2, t2, s2, -1);
    }
    parseExprOp(e2, t2, s2, r2) {
      if (this.isPrivateName(e2)) {
        const t3 = this.getPrivateNameSV(e2), { start: s3 } = e2;
        (r2 >= bn$1._in.binop || !this.prodParam.hasIn || !this.match(bn$1._in)) && this.raise(s3, Rn$1.PrivateInExpectedIn, t3), this.classScope.usePrivateName(t3, s3);
      }
      let i2 = this.state.type.binop;
      if (i2 != null && (this.prodParam.hasIn || !this.match(bn$1._in)) && i2 > r2) {
        const a2 = this.state.type;
        if (a2 === bn$1.pipeline) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
            return e2;
          this.checkPipelineAtInfixOperator(e2, t2);
        }
        const n2 = this.startNodeAt(t2, s2);
        n2.left = e2, n2.operator = this.state.value;
        const o2 = a2 === bn$1.logicalOR || a2 === bn$1.logicalAND, u2 = a2 === bn$1.nullishCoalescing;
        if (u2 && (i2 = bn$1.logicalAND.binop), this.next(), a2 === bn$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.match(bn$1.name) && this.state.value === "await" && this.prodParam.hasAwait)
          throw this.raise(this.state.start, Rn$1.UnexpectedAwaitAfterPipelineBody);
        n2.right = this.parseExprOpRightExpr(a2, i2), this.finishNode(n2, o2 || u2 ? "LogicalExpression" : "BinaryExpression");
        const h2 = this.state.type;
        if (u2 && (h2 === bn$1.logicalOR || h2 === bn$1.logicalAND) || o2 && h2 === bn$1.nullishCoalescing)
          throw this.raise(this.state.start, Rn$1.MixingCoalesceWithLogical);
        return this.parseExprOp(n2, t2, s2, r2);
      }
      return e2;
    }
    parseExprOpRightExpr(e2, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      switch (e2) {
        case bn$1.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => {
                const r3 = this.parseHackPipeBody(e2, t2);
                return this.checkHackPipeBodyEarlyErrors(s2), r3;
              });
            case "smart":
              return this.withTopicBindingContext(() => {
                const i2 = this.parseHackPipeBody(e2, t2);
                return this.parseSmartPipelineBodyInStyle(i2, s2, r2);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t2));
          }
        default:
          return this.parseExprOpBaseRightExpr(e2, t2);
      }
    }
    parseExprOpBaseRightExpr(e2, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, r2, e2.rightAssociative ? t2 - 1 : t2);
    }
    parseHackPipeBody(e2, t2) {
      if (this.prodParam.hasYield && this.isContextual("yield"))
        throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, this.state.value);
      return this.parseExprOpBaseRightExpr(e2, t2);
    }
    checkExponentialAfterUnary(e2) {
      this.match(bn$1.exponent) && this.raise(e2.argument.start, Rn$1.UnexpectedTokenUnaryExponentiation);
    }
    parseMaybeUnary(e2, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.isContextual("await");
      if (i2 && this.isAwaitAllowed()) {
        this.next();
        const e3 = this.parseAwait(s2, r2);
        return t2 || this.checkExponentialAfterUnary(e3), e3;
      }
      const a2 = this.match(bn$1.incDec), n2 = this.startNode();
      if (this.state.type.prefix) {
        n2.operator = this.state.value, n2.prefix = true, this.match(bn$1._throw) && this.expectPlugin("throwExpressions");
        const s3 = this.match(bn$1._delete);
        if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e2, true), this.state.strict && s3) {
          const e3 = n2.argument;
          e3.type === "Identifier" ? this.raise(n2.start, Rn$1.StrictDelete) : this.hasPropertyAsPrivateName(e3) && this.raise(n2.start, Rn$1.DeletePrivateField);
        }
        if (!a2)
          return t2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
      }
      const o2 = this.parseUpdate(n2, a2, e2);
      if (i2) {
        if ((this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(bn$1.modulo)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(s2, Rn$1.AwaitNotInAsyncContext), this.parseAwait(s2, r2);
      }
      return o2;
    }
    parseUpdate(e2, t2, s2) {
      if (t2)
        return this.checkLVal(e2.argument, "prefix operation"), this.finishNode(e2, "UpdateExpression");
      const r2 = this.state.start, i2 = this.state.startLoc;
      let a2 = this.parseExprSubscripts(s2);
      if (this.checkExpressionErrors(s2, false))
        return a2;
      for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
        const e3 = this.startNodeAt(r2, i2);
        e3.operator = this.state.value, e3.prefix = false, e3.argument = a2, this.checkLVal(a2, "postfix operation"), this.next(), a2 = this.finishNode(e3, "UpdateExpression");
      }
      return a2;
    }
    parseExprSubscripts(e2) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(e2);
      return this.shouldExitDescending(i2, r2) ? i2 : this.parseSubscripts(i2, t2, s2);
    }
    parseSubscripts(e2, t2, s2, r2) {
      const i2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e2), stop: false };
      do {
        e2 = this.parseSubscript(e2, t2, s2, r2, i2), i2.maybeAsyncArrow = false;
      } while (!i2.stop);
      return e2;
    }
    parseSubscript(e2, t2, s2, r2, i2) {
      if (!r2 && this.eat(bn$1.doubleColon))
        return this.parseBind(e2, t2, s2, r2, i2);
      if (this.match(bn$1.backQuote))
        return this.parseTaggedTemplateExpression(e2, t2, s2, i2);
      let a2 = false;
      if (this.match(bn$1.questionDot)) {
        if (r2 && this.lookaheadCharCode() === 40)
          return i2.stop = true, e2;
        i2.optionalChainMember = a2 = true, this.next();
      }
      if (!r2 && this.match(bn$1.parenL))
        return this.parseCoverCallAndAsyncArrowHead(e2, t2, s2, i2, a2);
      {
        const r3 = this.eat(bn$1.bracketL);
        return r3 || a2 || this.eat(bn$1.dot) ? this.parseMember(e2, t2, s2, i2, r3, a2) : (i2.stop = true, e2);
      }
    }
    parseMember(e2, t2, s2, r2, i2, a2) {
      const n2 = this.startNodeAt(t2, s2);
      n2.object = e2, n2.computed = i2;
      const o2 = !i2 && this.match(bn$1.privateName) && this.state.value, u2 = i2 ? this.parseExpression() : o2 ? this.parsePrivateName() : this.parseIdentifier(true);
      return o2 !== false && (n2.object.type === "Super" && this.raise(t2, Rn$1.SuperPrivateField), this.classScope.usePrivateName(o2, u2.start)), n2.property = u2, i2 && this.expect(bn$1.bracketR), r2.optionalChainMember ? (n2.optional = a2, this.finishNode(n2, "OptionalMemberExpression")) : this.finishNode(n2, "MemberExpression");
    }
    parseBind(e2, t2, s2, r2, i2) {
      const a2 = this.startNodeAt(t2, s2);
      return a2.object = e2, a2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(a2, "BindExpression"), t2, s2, r2);
    }
    parseCoverCallAndAsyncArrowHead(e2, t2, s2, r2, i2) {
      const a2 = this.state.maybeInArrowParameters;
      let n2 = null;
      this.state.maybeInArrowParameters = true, this.next();
      let o2 = this.startNodeAt(t2, s2);
      return o2.callee = e2, r2.maybeAsyncArrow && (this.expressionScope.enter(new go$1(2)), n2 = new So$1()), r2.optionalChainMember && (o2.optional = i2), o2.arguments = i2 ? this.parseCallExpressionArguments(bn$1.parenR) : this.parseCallExpressionArguments(bn$1.parenR, e2.type === "Import", e2.type !== "Super", o2, n2), this.finishCallExpression(o2, r2.optionalChainMember), r2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i2 ? (r2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t2, s2), o2)) : (r2.maybeAsyncArrow && (this.checkExpressionErrors(n2, true), this.expressionScope.exit()), this.toReferencedArguments(o2)), this.state.maybeInArrowParameters = a2, o2;
    }
    toReferencedArguments(e2, t2) {
      this.toReferencedListDeep(e2.arguments, t2);
    }
    parseTaggedTemplateExpression(e2, t2, s2, r2) {
      const i2 = this.startNodeAt(t2, s2);
      return i2.tag = e2, i2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(t2, Rn$1.OptionalChainingNoTemplate), this.finishNode(i2, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e2) {
      return e2.type === "Identifier" && e2.name === "async" && this.state.lastTokEnd === e2.end && !this.canInsertSemicolon() && e2.end - e2.start == 5 && e2.start === this.state.potentialArrowAt;
    }
    finishCallExpression(e2, t2) {
      if (e2.callee.type === "Import")
        if (e2.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e2.arguments.length === 0 || e2.arguments.length > 2)
          this.raise(e2.start, Rn$1.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        else
          for (const t3 of e2.arguments)
            t3.type === "SpreadElement" && this.raise(t3.start, Rn$1.ImportCallSpreadArgument);
      return this.finishNode(e2, t2 ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e2, t2, s2, r2, i2) {
      const a2 = [];
      let n2 = true;
      const o2 = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e2); ) {
        if (n2)
          n2 = false;
        else if (this.expect(bn$1.comma), this.match(e2)) {
          !t2 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Rn$1.ImportCallArgumentTrailingComma), r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
          break;
        }
        a2.push(this.parseExprListItem(false, i2, s2));
      }
      return this.state.inFSharpPipelineDirectBody = o2, a2;
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.arrow) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e2, t2) {
      var s2;
      return this.resetPreviousNodeTrailingComments(t2), this.expect(bn$1.arrow), this.parseArrowExpression(e2, t2.arguments, true, (s2 = t2.extra) == null ? void 0 : s2.trailingComma), Ln$1(e2, t2.innerComments), Ln$1(e2, t2.callee.trailingComments), e2;
    }
    parseNoCallExpr() {
      const e2 = this.state.start, t2 = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e2, t2, true);
    }
    parseExprAtom(e2) {
      let t2;
      switch (this.state.type) {
        case bn$1._super:
          return this.parseSuper();
        case bn$1._import:
          return t2 = this.startNode(), this.next(), this.match(bn$1.dot) ? this.parseImportMetaProperty(t2) : (this.match(bn$1.parenL) || this.raise(this.state.lastTokStart, Rn$1.UnsupportedImport), this.finishNode(t2, "Import"));
        case bn$1._this:
          return t2 = this.startNode(), this.next(), this.finishNode(t2, "ThisExpression");
        case bn$1.name: {
          if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
            return this.parseModuleExpression();
          const e3 = this.state.potentialArrowAt === this.state.start, t3 = this.state.containsEsc, s2 = this.parseIdentifier();
          if (!t3 && s2.name === "async" && !this.canInsertSemicolon()) {
            if (this.match(bn$1._function))
              return this.resetPreviousNodeTrailingComments(s2), this.next(), this.parseFunction(this.startNodeAtNode(s2), void 0, true);
            if (this.match(bn$1.name))
              return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(s2)) : s2;
            if (this.match(bn$1._do))
              return this.resetPreviousNodeTrailingComments(s2), this.parseDo(this.startNodeAtNode(s2), true);
          }
          return e3 && this.match(bn$1.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s2), [s2], false)) : s2;
        }
        case bn$1._do:
          return this.parseDo(this.startNode(), false);
        case bn$1.slash:
        case bn$1.slashAssign:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case bn$1.num:
          return this.parseNumericLiteral(this.state.value);
        case bn$1.bigint:
          return this.parseBigIntLiteral(this.state.value);
        case bn$1.decimal:
          return this.parseDecimalLiteral(this.state.value);
        case bn$1.string:
          return this.parseStringLiteral(this.state.value);
        case bn$1._null:
          return this.parseNullLiteral();
        case bn$1._true:
          return this.parseBooleanLiteral(true);
        case bn$1._false:
          return this.parseBooleanLiteral(false);
        case bn$1.parenL: {
          const e3 = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(e3);
        }
        case bn$1.bracketBarL:
        case bn$1.bracketHashL:
          return this.parseArrayLike(this.state.type === bn$1.bracketBarL ? bn$1.bracketBarR : bn$1.bracketR, false, true, e2);
        case bn$1.bracketL:
          return this.parseArrayLike(bn$1.bracketR, true, false, e2);
        case bn$1.braceBarL:
        case bn$1.braceHashL:
          return this.parseObjectLike(this.state.type === bn$1.braceBarL ? bn$1.braceBarR : bn$1.braceR, false, true, e2);
        case bn$1.braceL:
          return this.parseObjectLike(bn$1.braceR, false, false, e2);
        case bn$1._function:
          return this.parseFunctionOrFunctionSent();
        case bn$1.at:
          this.parseDecorators();
        case bn$1._class:
          return t2 = this.startNode(), this.takeDecorators(t2), this.parseClass(t2, false);
        case bn$1._new:
          return this.parseNewOrNewTarget();
        case bn$1.backQuote:
          return this.parseTemplate(false);
        case bn$1.doubleColon: {
          t2 = this.startNode(), this.next(), t2.object = null;
          const e3 = t2.callee = this.parseNoCallExpr();
          if (e3.type === "MemberExpression")
            return this.finishNode(t2, "BindExpression");
          throw this.raise(e3.start, Rn$1.UnsupportedBind);
        }
        case bn$1.privateName:
          return this.raise(this.state.start, Rn$1.PrivateInExpectedIn, this.state.value), this.parsePrivateName();
        case bn$1.moduloAssign:
          if (this.getPluginOption("pipelineOperator", "proposal") !== "hack" || this.getPluginOption("pipelineOperator", "topicToken") !== "%")
            throw this.unexpected();
          this.state.value = "%", this.state.type = bn$1.modulo, this.state.pos--, this.state.end--, this.state.endLoc.column--;
        case bn$1.modulo:
        case bn$1.hash: {
          const e3 = this.getPluginOption("pipelineOperator", "proposal");
          if (e3) {
            t2 = this.startNode();
            const s2 = this.state.start, r2 = this.state.type;
            return this.next(), this.finishTopicReference(t2, s2, e3, r2);
          }
        }
        case bn$1.relational:
          if (this.state.value === "<") {
            const e3 = this.input.codePointAt(this.nextTokenStart());
            (Jn$1(e3) || e3 === 62) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
          }
        default:
          throw this.unexpected();
      }
    }
    finishTopicReference(e2, t2, s2, r2) {
      if (this.testTopicReferenceConfiguration(s2, t2, r2)) {
        let r3;
        return r3 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference", this.topicReferenceIsAllowedInCurrentContext() || (s2 === "smart" ? this.raise(t2, Rn$1.PrimaryTopicNotAllowed) : this.raise(t2, Rn$1.PipeTopicUnbound)), this.registerTopicReference(), this.finishNode(e2, r3);
      }
      throw this.raise(t2, Rn$1.PipeTopicUnconfiguredToken, r2.label);
    }
    testTopicReferenceConfiguration(e2, t2, s2) {
      switch (e2) {
        case "hack": {
          const e3 = this.getPluginOption("pipelineOperator", "topicToken");
          return s2.label === e3;
        }
        case "smart":
          return s2 === bn$1.hash;
        default:
          throw this.raise(t2, Rn$1.PipeTopicRequiresHackPipes);
      }
    }
    parseAsyncArrowUnaryFunction(e2) {
      this.prodParam.enter(wo$1(true, this.prodParam.hasYield));
      const t2 = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, Rn$1.LineTerminatorBeforeArrow), this.expect(bn$1.arrow), this.parseArrowExpression(e2, t2, true), e2;
    }
    parseDo(e2, t2) {
      this.expectPlugin("doExpressions"), t2 && this.expectPlugin("asyncDoExpressions"), e2.async = t2, this.next();
      const s2 = this.state.labels;
      return this.state.labels = [], t2 ? (this.prodParam.enter(2), e2.body = this.parseBlock(), this.prodParam.exit()) : e2.body = this.parseBlock(), this.state.labels = s2, this.finishNode(e2, "DoExpression");
    }
    parseSuper() {
      const e2 = this.startNode();
      return this.next(), !this.match(bn$1.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(e2.start, Rn$1.UnexpectedSuper) : this.raise(e2.start, Rn$1.SuperNotAllowed), this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.dot) || this.raise(e2.start, Rn$1.UnsupportedSuper), this.finishNode(e2, "Super");
    }
    parseMaybePrivateName(e2) {
      return this.match(bn$1.privateName) ? (e2 || this.raise(this.state.start + 1, Rn$1.UnexpectedPrivateField), this.parsePrivateName()) : this.parseIdentifier(true);
    }
    parsePrivateName() {
      const e2 = this.startNode(), t2 = this.startNodeAt(this.state.start + 1, new In$1(this.state.curLine, this.state.start + 1 - this.state.lineStart)), s2 = this.state.value;
      return this.next(), e2.id = this.createIdentifier(t2, s2), this.finishNode(e2, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const e2 = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(bn$1.dot)) {
        const t2 = this.createIdentifier(this.startNodeAtNode(e2), "function");
        return this.next(), this.parseMetaProperty(e2, t2, "sent");
      }
      return this.parseFunction(e2);
    }
    parseMetaProperty(e2, t2, s2) {
      e2.meta = t2, t2.name === "function" && s2 === "sent" && (this.isContextual(s2) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
      const r2 = this.state.containsEsc;
      return e2.property = this.parseIdentifier(true), (e2.property.name !== s2 || r2) && this.raise(e2.property.start, Rn$1.UnsupportedMetaProperty, t2.name, s2), this.finishNode(e2, "MetaProperty");
    }
    parseImportMetaProperty(e2) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e2), "import");
      return this.next(), this.isContextual("meta") && (this.inModule || this.raise(t2.start, jn$1.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(e2, t2, "meta");
    }
    parseLiteralAtNode(e2, t2, s2) {
      return this.addExtra(s2, "rawValue", e2), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = e2, this.next(), this.finishNode(s2, t2);
    }
    parseLiteral(e2, t2) {
      const s2 = this.startNode();
      return this.parseLiteralAtNode(e2, t2, s2);
    }
    parseStringLiteral(e2) {
      return this.parseLiteral(e2, "StringLiteral");
    }
    parseNumericLiteral(e2) {
      return this.parseLiteral(e2, "NumericLiteral");
    }
    parseBigIntLiteral(e2) {
      return this.parseLiteral(e2, "BigIntLiteral");
    }
    parseDecimalLiteral(e2) {
      return this.parseLiteral(e2, "DecimalLiteral");
    }
    parseRegExpLiteral(e2) {
      const t2 = this.parseLiteral(e2.value, "RegExpLiteral");
      return t2.pattern = e2.pattern, t2.flags = e2.flags, t2;
    }
    parseBooleanLiteral(e2) {
      const t2 = this.startNode();
      return t2.value = e2, this.next(), this.finishNode(t2, "BooleanLiteral");
    }
    parseNullLiteral() {
      const e2 = this.startNode();
      return this.next(), this.finishNode(e2, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e2) {
      const t2 = this.state.start, s2 = this.state.startLoc;
      let r2;
      this.next(), this.expressionScope.enter(new go$1(1));
      const i2 = this.state.maybeInArrowParameters, a2 = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      const n2 = this.state.start, o2 = this.state.startLoc, u2 = [], h2 = new So$1();
      let c2, p2, l2 = true;
      for (; !this.match(bn$1.parenR); ) {
        if (l2)
          l2 = false;
        else if (this.expect(bn$1.comma, h2.optionalParameters === -1 ? null : h2.optionalParameters), this.match(bn$1.parenR)) {
          p2 = this.state.start;
          break;
        }
        if (this.match(bn$1.ellipsis)) {
          const e3 = this.state.start, t3 = this.state.startLoc;
          c2 = this.state.start, u2.push(this.parseParenItem(this.parseRestBinding(), e3, t3)), this.checkCommaAfterRest(41);
          break;
        }
        u2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
      }
      const d2 = this.state.lastTokEnd, D2 = this.state.lastTokEndLoc;
      this.expect(bn$1.parenR), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = a2;
      let m2 = this.startNodeAt(t2, s2);
      if (e2 && this.shouldParseArrow(u2) && (m2 = this.parseArrow(m2)))
        return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(m2, u2, false), m2;
      if (this.expressionScope.exit(), u2.length || this.unexpected(this.state.lastTokStart), p2 && this.unexpected(p2), c2 && this.unexpected(c2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(u2, true), u2.length > 1 ? (r2 = this.startNodeAt(n2, o2), r2.expressions = u2, this.finishNode(r2, "SequenceExpression"), r2.end = d2, r2.loc.end = D2) : r2 = u2[0], !this.options.createParenthesizedExpressions)
        return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", t2), r2;
      const f2 = this.startNodeAt(t2, s2);
      return f2.expression = r2, this.finishNode(f2, "ParenthesizedExpression"), f2;
    }
    shouldParseArrow(e2) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e2) {
      if (this.eat(bn$1.arrow))
        return e2;
    }
    parseParenItem(e2, t2, s2) {
      return e2;
    }
    parseNewOrNewTarget() {
      const e2 = this.startNode();
      if (this.next(), this.match(bn$1.dot)) {
        const t2 = this.createIdentifier(this.startNodeAtNode(e2), "new");
        this.next();
        const s2 = this.parseMetaProperty(e2, t2, "target");
        return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(s2.start, Rn$1.UnexpectedNewTarget), s2;
      }
      return this.parseNew(e2);
    }
    parseNew(e2) {
      return e2.callee = this.parseNoCallExpr(), e2.callee.type === "Import" ? this.raise(e2.callee.start, Rn$1.ImportCallNotNewExpression) : this.isOptionalChain(e2.callee) ? this.raise(this.state.lastTokEnd, Rn$1.OptionalChainingNoNew) : this.eat(bn$1.questionDot) && this.raise(this.state.start, Rn$1.OptionalChainingNoNew), this.parseNewArguments(e2), this.finishNode(e2, "NewExpression");
    }
    parseNewArguments(e2) {
      if (this.eat(bn$1.parenL)) {
        const t2 = this.parseExprList(bn$1.parenR);
        this.toReferencedList(t2), e2.arguments = t2;
      } else
        e2.arguments = [];
    }
    parseTemplateElement(e2) {
      const t2 = this.startNode();
      return this.state.value === null && (e2 || this.raise(this.state.start + 1, Rn$1.InvalidEscapeSequenceTemplate)), t2.value = { raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value }, this.next(), t2.tail = this.match(bn$1.backQuote), this.finishNode(t2, "TemplateElement");
    }
    parseTemplate(e2) {
      const t2 = this.startNode();
      this.next(), t2.expressions = [];
      let s2 = this.parseTemplateElement(e2);
      for (t2.quasis = [s2]; !s2.tail; )
        this.expect(bn$1.dollarBraceL), t2.expressions.push(this.parseTemplateSubstitution()), this.expect(bn$1.braceR), t2.quasis.push(s2 = this.parseTemplateElement(e2));
      return this.next(), this.finishNode(t2, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e2, t2, s2, r2) {
      s2 && this.expectPlugin("recordAndTuple");
      const i2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const a2 = Object.create(null);
      let n2 = true;
      const o2 = this.startNode();
      for (o2.properties = [], this.next(); !this.match(e2); ) {
        if (n2)
          n2 = false;
        else if (this.expect(bn$1.comma), this.match(e2)) {
          this.addExtra(o2, "trailingComma", this.state.lastTokStart);
          break;
        }
        const i3 = this.parsePropertyDefinition(t2, r2);
        t2 || this.checkProto(i3, s2, a2, r2), s2 && !this.isObjectProperty(i3) && i3.type !== "SpreadElement" && this.raise(i3.start, Rn$1.InvalidRecordProperty), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = i2;
      let u2 = "ObjectExpression";
      return t2 ? u2 = "ObjectPattern" : s2 && (u2 = "RecordExpression"), this.finishNode(o2, u2);
    }
    maybeAsyncOrAccessorProp(e2) {
      return !e2.computed && e2.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(bn$1.bracketL) || this.match(bn$1.star));
    }
    parsePropertyDefinition(e2, t2) {
      let s2 = [];
      if (this.match(bn$1.at))
        for (this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedPropertyDecorator); this.match(bn$1.at); )
          s2.push(this.parseDecorator());
      const r2 = this.startNode();
      let i2, a2, n2 = false, o2 = false, u2 = false;
      if (this.match(bn$1.ellipsis))
        return s2.length && this.unexpected(), e2 ? (this.next(), r2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r2, "RestElement")) : this.parseSpread();
      s2.length && (r2.decorators = s2, s2 = []), r2.method = false, (e2 || t2) && (i2 = this.state.start, a2 = this.state.startLoc), e2 || (n2 = this.eat(bn$1.star));
      const h2 = this.state.containsEsc, c2 = this.parsePropertyName(r2, false);
      if (!e2 && !n2 && !h2 && this.maybeAsyncOrAccessorProp(r2)) {
        const e3 = c2.name;
        e3 !== "async" || this.hasPrecedingLineBreak() || (o2 = true, this.resetPreviousNodeTrailingComments(c2), n2 = this.eat(bn$1.star), this.parsePropertyName(r2, false)), e3 !== "get" && e3 !== "set" || (u2 = true, this.resetPreviousNodeTrailingComments(c2), r2.kind = e3, this.match(bn$1.star) && (n2 = true, this.raise(this.state.pos, Rn$1.AccessorIsGenerator, e3), this.next()), this.parsePropertyName(r2, false));
      }
      return this.parseObjPropValue(r2, i2, a2, n2, o2, e2, u2, t2), r2;
    }
    getGetterSetterExpectedParamCount(e2) {
      return e2.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e2) {
      return e2.params;
    }
    checkGetterSetterParams(e2) {
      var t2;
      const s2 = this.getGetterSetterExpectedParamCount(e2), r2 = this.getObjectOrClassMethodParams(e2), i2 = e2.start;
      r2.length !== s2 && (e2.kind === "get" ? this.raise(i2, Rn$1.BadGetterArity) : this.raise(i2, Rn$1.BadSetterArity)), e2.kind === "set" && ((t2 = r2[r2.length - 1]) == null ? void 0 : t2.type) === "RestElement" && this.raise(i2, Rn$1.BadSetterRestParameter);
    }
    parseObjectMethod(e2, t2, s2, r2, i2) {
      return i2 ? (this.parseMethod(e2, t2, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e2), e2) : s2 || t2 || this.match(bn$1.parenL) ? (r2 && this.unexpected(), e2.kind = "method", e2.method = true, this.parseMethod(e2, t2, s2, false, false, "ObjectMethod")) : void 0;
    }
    parseObjectProperty(e2, t2, s2, r2, i2) {
      return e2.shorthand = false, this.eat(bn$1.colon) ? (e2.value = r2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(e2, "ObjectProperty")) : e2.computed || e2.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(e2.key.name, e2.key.start, true, false), r2 ? e2.value = this.parseMaybeDefault(t2, s2, Io$1(e2.key)) : this.match(bn$1.eq) && i2 ? (i2.shorthandAssign === -1 && (i2.shorthandAssign = this.state.start), e2.value = this.parseMaybeDefault(t2, s2, Io$1(e2.key))) : e2.value = Io$1(e2.key), e2.shorthand = true, this.finishNode(e2, "ObjectProperty"));
    }
    parseObjPropValue(e2, t2, s2, r2, i2, a2, n2, o2) {
      const u2 = this.parseObjectMethod(e2, r2, i2, a2, n2) || this.parseObjectProperty(e2, t2, s2, a2, o2);
      return u2 || this.unexpected(), u2;
    }
    parsePropertyName(e2, t2) {
      if (this.eat(bn$1.bracketL))
        e2.computed = true, e2.key = this.parseMaybeAssignAllowIn(), this.expect(bn$1.bracketR);
      else {
        const s2 = this.state.inPropertyName;
        this.state.inPropertyName = true;
        const r2 = this.state.type;
        e2.key = r2 === bn$1.num || r2 === bn$1.string || r2 === bn$1.bigint || r2 === bn$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(t2), r2 !== bn$1.privateName && (e2.computed = false), this.state.inPropertyName = s2;
      }
      return e2.key;
    }
    initFunction(e2, t2) {
      e2.id = null, e2.generator = false, e2.async = !!t2;
    }
    parseMethod(e2, t2, s2, r2, i2, a2, n2 = false) {
      this.initFunction(e2, s2), e2.generator = !!t2;
      const o2 = r2;
      return this.scope.enter(18 | (n2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(wo$1(s2, e2.generator)), this.parseFunctionParams(e2, o2), this.parseFunctionBodyAndFinish(e2, a2, true), this.prodParam.exit(), this.scope.exit(), e2;
    }
    parseArrayLike(e2, t2, s2, r2) {
      s2 && this.expectPlugin("recordAndTuple");
      const i2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const a2 = this.startNode();
      return this.next(), a2.elements = this.parseExprList(e2, !s2, r2, a2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a2, s2 ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e2, t2, s2, r2) {
      this.scope.enter(6);
      let i2 = wo$1(s2, false);
      !this.match(bn$1.bracketL) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(e2, s2);
      const a2 = this.state.maybeInArrowParameters;
      return t2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e2, t2, r2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e2, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(e2, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(e2, t2, s2) {
      e2.params = this.toAssignableList(t2, s2, false);
    }
    parseFunctionBodyAndFinish(e2, t2, s2 = false) {
      this.parseFunctionBody(e2, false, s2), this.finishNode(e2, t2);
    }
    parseFunctionBody(e2, t2, s2 = false) {
      const r2 = t2 && !this.match(bn$1.braceL);
      if (this.expressionScope.enter(Po$1()), r2)
        e2.body = this.parseMaybeAssign(), this.checkParams(e2, false, t2, false);
      else {
        const r3 = this.state.strict, i2 = this.state.labels;
        this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e2.body = this.parseBlock(true, false, (i3) => {
          const a2 = !this.isSimpleParamList(e2.params);
          if (i3 && a2) {
            const t3 = e2.kind !== "method" && e2.kind !== "constructor" || !e2.key ? e2.start : e2.key.end;
            this.raise(t3, Rn$1.IllegalLanguageModeDirective);
          }
          const n2 = !r3 && this.state.strict;
          this.checkParams(e2, !(this.state.strict || t2 || s2 || a2), t2, n2), this.state.strict && e2.id && this.checkLVal(e2.id, "function name", 65, void 0, void 0, n2);
        }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i2;
      }
    }
    isSimpleParamList(e2) {
      for (let t2 = 0, s2 = e2.length; t2 < s2; t2++)
        if (e2[t2].type !== "Identifier")
          return false;
      return true;
    }
    checkParams(e2, t2, s2, r2 = true) {
      const i2 = new Set();
      for (const s3 of e2.params)
        this.checkLVal(s3, "function parameter list", 5, t2 ? null : i2, void 0, r2);
    }
    parseExprList(e2, t2, s2, r2) {
      const i2 = [];
      let a2 = true;
      for (; !this.eat(e2); ) {
        if (a2)
          a2 = false;
        else if (this.expect(bn$1.comma), this.match(e2)) {
          r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
          break;
        }
        i2.push(this.parseExprListItem(t2, s2));
      }
      return i2;
    }
    parseExprListItem(e2, t2, s2) {
      let r2;
      if (this.match(bn$1.comma))
        e2 || this.raise(this.state.pos, Rn$1.UnexpectedToken, ","), r2 = null;
      else if (this.match(bn$1.ellipsis)) {
        const e3 = this.state.start, s3 = this.state.startLoc;
        r2 = this.parseParenItem(this.parseSpread(t2), e3, s3);
      } else if (this.match(bn$1.question)) {
        this.expectPlugin("partialApplication"), s2 || this.raise(this.state.start, Rn$1.UnexpectedArgumentPlaceholder);
        const e3 = this.startNode();
        this.next(), r2 = this.finishNode(e3, "ArgumentPlaceholder");
      } else
        r2 = this.parseMaybeAssignAllowIn(t2, this.parseParenItem);
      return r2;
    }
    parseIdentifier(e2) {
      const t2 = this.startNode(), s2 = this.parseIdentifierName(t2.start, e2);
      return this.createIdentifier(t2, s2);
    }
    createIdentifier(e2, t2) {
      return e2.name = t2, e2.loc.identifierName = t2, this.finishNode(e2, "Identifier");
    }
    parseIdentifierName(e2, t2) {
      let s2;
      const { start: r2, type: i2 } = this.state;
      if (i2 === bn$1.name)
        s2 = this.state.value;
      else {
        if (!i2.keyword)
          throw this.unexpected();
        s2 = i2.keyword;
      }
      return t2 ? this.state.type = bn$1.name : this.checkReservedWord(s2, r2, !!i2.keyword, false), this.next(), s2;
    }
    checkReservedWord(e2, t2, s2, r2) {
      if (e2.length > 10)
        return;
      if (!function(e3) {
        return uo$1.has(e3);
      }(e2))
        return;
      if (e2 === "yield") {
        if (this.prodParam.hasYield)
          return void this.raise(t2, Rn$1.YieldBindingIdentifier);
      } else if (e2 === "await") {
        if (this.prodParam.hasAwait)
          return void this.raise(t2, Rn$1.AwaitBindingIdentifier);
        if (this.scope.inStaticBlock)
          return void this.raise(t2, Rn$1.AwaitBindingIdentifierInStaticBlock);
        this.expressionScope.recordAsyncArrowParametersError(t2, Rn$1.AwaitBindingIdentifier);
      } else if (e2 === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
        return void this.raise(t2, Rn$1.ArgumentsInClass);
      if (s2 && oo$1(e2))
        return void this.raise(t2, Rn$1.UnexpectedKeyword, e2);
      (this.state.strict ? r2 ? no$1 : io$1 : ro$1)(e2, this.inModule) && this.raise(t2, Rn$1.UnexpectedReservedWord, e2);
    }
    isAwaitAllowed() {
      return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
    }
    parseAwait(e2, t2) {
      const s2 = this.startNodeAt(e2, t2);
      return this.expressionScope.recordParameterInitializerError(s2.start, Rn$1.AwaitExpressionFormalParameter), this.eat(bn$1.star) && this.raise(s2.start, Rn$1.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
    }
    isAmbiguousAwait() {
      return this.hasPrecedingLineBreak() || this.match(bn$1.plusMin) || this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.backQuote) || this.match(bn$1.regexp) || this.match(bn$1.slash) || this.hasPlugin("v8intrinsic") && this.match(bn$1.modulo);
    }
    parseYield() {
      const e2 = this.startNode();
      this.expressionScope.recordParameterInitializerError(e2.start, Rn$1.YieldInParameter), this.next();
      let t2 = false, s2 = null;
      if (!this.hasPrecedingLineBreak())
        switch (t2 = this.eat(bn$1.star), this.state.type) {
          case bn$1.semi:
          case bn$1.eof:
          case bn$1.braceR:
          case bn$1.parenR:
          case bn$1.bracketR:
          case bn$1.braceBarR:
          case bn$1.colon:
          case bn$1.comma:
            if (!t2)
              break;
          default:
            s2 = this.parseMaybeAssign();
        }
      return e2.delegate = t2, e2.argument = s2, this.finishNode(e2, "YieldExpression");
    }
    checkPipelineAtInfixOperator(e2, t2) {
      this.getPluginOption("pipelineOperator", "proposal") === "smart" && e2.type === "SequenceExpression" && this.raise(t2, Rn$1.PipelineHeadSequenceExpression);
    }
    checkHackPipeBodyEarlyErrors(e2) {
      if (this.match(bn$1.arrow))
        throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, bn$1.arrow.label);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(e2, Rn$1.PipeTopicUnused);
    }
    parseSmartPipelineBodyInStyle(e2, t2, s2) {
      const r2 = this.startNodeAt(t2, s2);
      return this.isSimpleReference(e2) ? (r2.callee = e2, this.finishNode(r2, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(t2), r2.expression = e2, this.finishNode(r2, "PipelineTopicExpression"));
    }
    isSimpleReference(e2) {
      switch (e2.type) {
        case "MemberExpression":
          return !e2.computed && this.isSimpleReference(e2.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e2) {
      if (this.match(bn$1.arrow))
        throw this.raise(this.state.start, Rn$1.PipelineBodyNoArrow);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(e2, Rn$1.PipelineTopicUnused);
    }
    withTopicBindingContext(e2) {
      const t2 = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return e2();
      } finally {
        this.state.topicContext = t2;
      }
    }
    withSmartMixTopicForbiddingContext(e2) {
      if (this.getPluginOption("pipelineOperator", "proposal") !== "smart")
        return e2();
      {
        const t2 = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return e2();
        } finally {
          this.state.topicContext = t2;
        }
      }
    }
    withSoloAwaitPermittingContext(e2) {
      const t2 = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return e2();
      } finally {
        this.state.soloAwait = t2;
      }
    }
    allowInAnd(e2) {
      const t2 = this.prodParam.currentFlags();
      if (8 & ~t2) {
        this.prodParam.enter(8 | t2);
        try {
          return e2();
        } finally {
          this.prodParam.exit();
        }
      }
      return e2();
    }
    disallowInAnd(e2) {
      const t2 = this.prodParam.currentFlags();
      if (8 & t2) {
        this.prodParam.enter(-9 & t2);
        try {
          return e2();
        } finally {
          this.prodParam.exit();
        }
      }
      return e2();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e2) {
      const t2 = this.state.start, s2 = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const r2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t2, s2, e2);
      return this.state.inFSharpPipelineDirectBody = r2, i2;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const e2 = this.startNode();
      this.next(), this.eat(bn$1.braceL);
      const t2 = this.initializeScopes(true);
      this.enterInitialScopes();
      const s2 = this.startNode();
      try {
        e2.body = this.parseProgram(s2, bn$1.braceR, "module");
      } finally {
        t2();
      }
      return this.eat(bn$1.braceR), this.finishNode(e2, "ModuleExpression");
    }
  } {
    parseTopLevel(e2, t2) {
      return e2.program = this.parseProgram(t2), e2.comments = this.state.comments, this.options.tokens && (e2.tokens = function(e3) {
        for (let t3 = 0; t3 < e3.length; t3++) {
          const s2 = e3[t3];
          if (s2.type === bn$1.privateName) {
            const { loc: r2, start: i2, value: a2, end: n2 } = s2, o2 = i2 + 1, u2 = new In$1(r2.start.line, r2.start.column + 1);
            e3.splice(t3, 1, new Eo$1({ type: bn$1.hash, value: "#", start: i2, end: o2, startLoc: r2.start, endLoc: u2 }), new Eo$1({ type: bn$1.name, value: a2, start: o2, end: n2, startLoc: u2, endLoc: r2.end }));
          }
        }
        return e3;
      }(this.tokens)), this.finishNode(e2, "File");
    }
    parseProgram(e2, t2 = bn$1.eof, s2 = this.options.sourceType) {
      if (e2.sourceType = s2, e2.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e2, true, true, t2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (const [e3] of Array.from(this.scope.undefinedExports)) {
          const t3 = this.scope.undefinedExports.get(e3);
          this.raise(t3, Rn$1.ModuleExportUndefined, e3);
        }
      return this.finishNode(e2, "Program");
    }
    stmtToDirective(e2) {
      const t2 = e2;
      t2.type = "Directive", t2.value = t2.expression, delete t2.expression;
      const s2 = t2.value, r2 = this.input.slice(s2.start, s2.end), i2 = s2.value = r2.slice(1, -1);
      return this.addExtra(s2, "raw", r2), this.addExtra(s2, "rawValue", i2), s2.type = "DirectiveLiteral", t2;
    }
    parseInterpreterDirective() {
      if (!this.match(bn$1.interpreterDirective))
        return null;
      const e2 = this.startNode();
      return e2.value = this.state.value, this.next(), this.finishNode(e2, "InterpreterDirective");
    }
    isLet(e2) {
      return !!this.isContextual("let") && this.isLetKeyword(e2);
    }
    isLetKeyword(e2) {
      const t2 = this.nextTokenStart(), s2 = this.codePointAtPos(t2);
      if (s2 === 92 || s2 === 91)
        return true;
      if (e2)
        return false;
      if (s2 === 123)
        return true;
      if (Jn$1(s2)) {
        if (cu.lastIndex = t2, cu.test(this.input)) {
          const e3 = this.codePointAtPos(cu.lastIndex);
          if (!Yn$1(e3) && e3 !== 92)
            return false;
        }
        return true;
      }
      return false;
    }
    parseStatement(e2, t2) {
      return this.match(bn$1.at) && this.parseDecorators(true), this.parseStatementContent(e2, t2);
    }
    parseStatementContent(e2, t2) {
      let s2 = this.state.type;
      const r2 = this.startNode();
      let i2;
      switch (this.isLet(e2) && (s2 = bn$1._var, i2 = "let"), s2) {
        case bn$1._break:
        case bn$1._continue:
          return this.parseBreakContinueStatement(r2, s2.keyword);
        case bn$1._debugger:
          return this.parseDebuggerStatement(r2);
        case bn$1._do:
          return this.parseDoStatement(r2);
        case bn$1._for:
          return this.parseForStatement(r2);
        case bn$1._function:
          if (this.lookaheadCharCode() === 46)
            break;
          return e2 && (this.state.strict ? this.raise(this.state.start, Rn$1.StrictFunction) : e2 !== "if" && e2 !== "label" && this.raise(this.state.start, Rn$1.SloppyFunction)), this.parseFunctionStatement(r2, false, !e2);
        case bn$1._class:
          return e2 && this.unexpected(), this.parseClass(r2, true);
        case bn$1._if:
          return this.parseIfStatement(r2);
        case bn$1._return:
          return this.parseReturnStatement(r2);
        case bn$1._switch:
          return this.parseSwitchStatement(r2);
        case bn$1._throw:
          return this.parseThrowStatement(r2);
        case bn$1._try:
          return this.parseTryStatement(r2);
        case bn$1._const:
        case bn$1._var:
          return i2 = i2 || this.state.value, e2 && i2 !== "var" && this.raise(this.state.start, Rn$1.UnexpectedLexicalDeclaration), this.parseVarStatement(r2, i2);
        case bn$1._while:
          return this.parseWhileStatement(r2);
        case bn$1._with:
          return this.parseWithStatement(r2);
        case bn$1.braceL:
          return this.parseBlock();
        case bn$1.semi:
          return this.parseEmptyStatement(r2);
        case bn$1._import: {
          const e3 = this.lookaheadCharCode();
          if (e3 === 40 || e3 === 46)
            break;
        }
        case bn$1._export: {
          let e3;
          return this.options.allowImportExportEverywhere || t2 || this.raise(this.state.start, Rn$1.UnexpectedImportExport), this.next(), s2 === bn$1._import ? (e3 = this.parseImport(r2), e3.type !== "ImportDeclaration" || e3.importKind && e3.importKind !== "value" || (this.sawUnambiguousESM = true)) : (e3 = this.parseExport(r2), (e3.type !== "ExportNamedDeclaration" || e3.exportKind && e3.exportKind !== "value") && (e3.type !== "ExportAllDeclaration" || e3.exportKind && e3.exportKind !== "value") && e3.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r2), e3;
        }
        default:
          if (this.isAsyncFunction())
            return e2 && this.raise(this.state.start, Rn$1.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r2, true, !e2);
      }
      const a2 = this.state.value, n2 = this.parseExpression();
      return s2 === bn$1.name && n2.type === "Identifier" && this.eat(bn$1.colon) ? this.parseLabeledStatement(r2, a2, n2, e2) : this.parseExpressionStatement(r2, n2);
    }
    assertModuleNodeAllowed(e2) {
      this.options.allowImportExportEverywhere || this.inModule || this.raise(e2.start, jn$1.ImportOutsideModule);
    }
    takeDecorators(e2) {
      const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      t2.length && (e2.decorators = t2, this.resetStartLocationFromNode(e2, t2[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
    }
    canHaveLeadingDecorator() {
      return this.match(bn$1._class);
    }
    parseDecorators(e2) {
      const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      for (; this.match(bn$1.at); ) {
        const e3 = this.parseDecorator();
        t2.push(e3);
      }
      if (this.match(bn$1._export))
        e2 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorExportClass);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(this.state.start, Rn$1.UnexpectedLeadingDecorator);
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      const e2 = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const t2 = this.state.start, s2 = this.state.startLoc;
        let r2;
        if (this.eat(bn$1.parenL))
          r2 = this.parseExpression(), this.expect(bn$1.parenR);
        else
          for (r2 = this.parseIdentifier(false); this.eat(bn$1.dot); ) {
            const e3 = this.startNodeAt(t2, s2);
            e3.object = r2, e3.property = this.parseIdentifier(true), e3.computed = false, r2 = this.finishNode(e3, "MemberExpression");
          }
        e2.expression = this.parseMaybeDecoratorArguments(r2), this.state.decoratorStack.pop();
      } else
        e2.expression = this.parseExprSubscripts();
      return this.finishNode(e2, "Decorator");
    }
    parseMaybeDecoratorArguments(e2) {
      if (this.eat(bn$1.parenL)) {
        const t2 = this.startNodeAtNode(e2);
        return t2.callee = e2, t2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.toReferencedList(t2.arguments), this.finishNode(t2, "CallExpression");
      }
      return e2;
    }
    parseBreakContinueStatement(e2, t2) {
      const s2 = t2 === "break";
      return this.next(), this.isLineTerminator() ? e2.label = null : (e2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e2, t2), this.finishNode(e2, s2 ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e2, t2) {
      const s2 = t2 === "break";
      let r2;
      for (r2 = 0; r2 < this.state.labels.length; ++r2) {
        const t3 = this.state.labels[r2];
        if (e2.label == null || t3.name === e2.label.name) {
          if (t3.kind != null && (s2 || t3.kind === "loop"))
            break;
          if (e2.label && s2)
            break;
        }
      }
      r2 === this.state.labels.length && this.raise(e2.start, Rn$1.IllegalBreakContinue, t2);
    }
    parseDebuggerStatement(e2) {
      return this.next(), this.semicolon(), this.finishNode(e2, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(bn$1.parenL);
      const e2 = this.parseExpression();
      return this.expect(bn$1.parenR), e2;
    }
    parseDoStatement(e2) {
      return this.next(), this.state.labels.push(ou), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(bn$1._while), e2.test = this.parseHeaderExpression(), this.eat(bn$1.semi), this.finishNode(e2, "DoWhileStatement");
    }
    parseForStatement(e2) {
      this.next(), this.state.labels.push(ou);
      let t2 = -1;
      if (this.isAwaitAllowed() && this.eatContextual("await") && (t2 = this.state.lastTokStart), this.scope.enter(0), this.expect(bn$1.parenL), this.match(bn$1.semi))
        return t2 > -1 && this.unexpected(t2), this.parseFor(e2, null);
      const s2 = this.isContextual("let"), r2 = s2 && this.isLetKeyword();
      if (this.match(bn$1._var) || this.match(bn$1._const) || r2) {
        const s3 = this.startNode(), i3 = r2 ? "let" : this.state.value;
        return this.next(), this.parseVar(s3, true, i3), this.finishNode(s3, "VariableDeclaration"), (this.match(bn$1._in) || this.isContextual("of")) && s3.declarations.length === 1 ? this.parseForIn(e2, s3, t2) : (t2 > -1 && this.unexpected(t2), this.parseFor(e2, s3));
      }
      const i2 = this.match(bn$1.name) && !this.state.containsEsc, a2 = new So$1(), n2 = this.parseExpression(true, a2), o2 = this.isContextual("of");
      if (o2 && (s2 ? this.raise(n2.start, Rn$1.ForOfLet) : t2 === -1 && i2 && n2.type === "Identifier" && n2.name === "async" && this.raise(n2.start, Rn$1.ForOfAsync)), o2 || this.match(bn$1._in)) {
        this.toAssignable(n2, true);
        const s3 = o2 ? "for-of statement" : "for-in statement";
        return this.checkLVal(n2, s3), this.parseForIn(e2, n2, t2);
      }
      return this.checkExpressionErrors(a2, true), t2 > -1 && this.unexpected(t2), this.parseFor(e2, n2);
    }
    parseFunctionStatement(e2, t2, s2) {
      return this.next(), this.parseFunction(e2, 1 | (s2 ? 0 : 2), t2);
    }
    parseIfStatement(e2) {
      return this.next(), e2.test = this.parseHeaderExpression(), e2.consequent = this.parseStatement("if"), e2.alternate = this.eat(bn$1._else) ? this.parseStatement("if") : null, this.finishNode(e2, "IfStatement");
    }
    parseReturnStatement(e2) {
      return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Rn$1.IllegalReturn), this.next(), this.isLineTerminator() ? e2.argument = null : (e2.argument = this.parseExpression(), this.semicolon()), this.finishNode(e2, "ReturnStatement");
    }
    parseSwitchStatement(e2) {
      this.next(), e2.discriminant = this.parseHeaderExpression();
      const t2 = e2.cases = [];
      let s2, r2;
      for (this.expect(bn$1.braceL), this.state.labels.push(uu), this.scope.enter(0); !this.match(bn$1.braceR); )
        if (this.match(bn$1._case) || this.match(bn$1._default)) {
          const e3 = this.match(bn$1._case);
          s2 && this.finishNode(s2, "SwitchCase"), t2.push(s2 = this.startNode()), s2.consequent = [], this.next(), e3 ? s2.test = this.parseExpression() : (r2 && this.raise(this.state.lastTokStart, Rn$1.MultipleDefaultsInSwitch), r2 = true, s2.test = null), this.expect(bn$1.colon);
        } else
          s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
      return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e2, "SwitchStatement");
    }
    parseThrowStatement(e2) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Rn$1.NewlineAfterThrow), e2.argument = this.parseExpression(), this.semicolon(), this.finishNode(e2, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const e2 = this.parseBindingAtom(), t2 = e2.type === "Identifier";
      return this.scope.enter(t2 ? 8 : 0), this.checkLVal(e2, "catch clause", 9), e2;
    }
    parseTryStatement(e2) {
      if (this.next(), e2.block = this.parseBlock(), e2.handler = null, this.match(bn$1._catch)) {
        const t2 = this.startNode();
        this.next(), this.match(bn$1.parenL) ? (this.expect(bn$1.parenL), t2.param = this.parseCatchClauseParam(), this.expect(bn$1.parenR)) : (t2.param = null, this.scope.enter(0)), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e2.handler = this.finishNode(t2, "CatchClause");
      }
      return e2.finalizer = this.eat(bn$1._finally) ? this.parseBlock() : null, e2.handler || e2.finalizer || this.raise(e2.start, Rn$1.NoCatchOrFinally), this.finishNode(e2, "TryStatement");
    }
    parseVarStatement(e2, t2) {
      return this.next(), this.parseVar(e2, false, t2), this.semicolon(), this.finishNode(e2, "VariableDeclaration");
    }
    parseWhileStatement(e2) {
      return this.next(), e2.test = this.parseHeaderExpression(), this.state.labels.push(ou), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e2, "WhileStatement");
    }
    parseWithStatement(e2) {
      return this.state.strict && this.raise(this.state.start, Rn$1.StrictWith), this.next(), e2.object = this.parseHeaderExpression(), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e2, "WithStatement");
    }
    parseEmptyStatement(e2) {
      return this.next(), this.finishNode(e2, "EmptyStatement");
    }
    parseLabeledStatement(e2, t2, s2, r2) {
      for (const e3 of this.state.labels)
        e3.name === t2 && this.raise(s2.start, Rn$1.LabelRedeclaration, t2);
      const i2 = this.state.type.isLoop ? "loop" : this.match(bn$1._switch) ? "switch" : null;
      for (let t3 = this.state.labels.length - 1; t3 >= 0; t3--) {
        const s3 = this.state.labels[t3];
        if (s3.statementStart !== e2.start)
          break;
        s3.statementStart = this.state.start, s3.kind = i2;
      }
      return this.state.labels.push({ name: t2, kind: i2, statementStart: this.state.start }), e2.body = this.parseStatement(r2 ? r2.indexOf("label") === -1 ? r2 + "label" : r2 : "label"), this.state.labels.pop(), e2.label = s2, this.finishNode(e2, "LabeledStatement");
    }
    parseExpressionStatement(e2, t2) {
      return e2.expression = t2, this.semicolon(), this.finishNode(e2, "ExpressionStatement");
    }
    parseBlock(e2 = false, t2 = true, s2) {
      const r2 = this.startNode();
      return e2 && this.state.strictErrors.clear(), this.expect(bn$1.braceL), t2 && this.scope.enter(0), this.parseBlockBody(r2, e2, false, bn$1.braceR, s2), t2 && this.scope.exit(), this.finishNode(r2, "BlockStatement");
    }
    isValidDirective(e2) {
      return e2.type === "ExpressionStatement" && e2.expression.type === "StringLiteral" && !e2.expression.extra.parenthesized;
    }
    parseBlockBody(e2, t2, s2, r2, i2) {
      const a2 = e2.body = [], n2 = e2.directives = [];
      this.parseBlockOrModuleBlockBody(a2, t2 ? n2 : void 0, s2, r2, i2);
    }
    parseBlockOrModuleBlockBody(e2, t2, s2, r2, i2) {
      const a2 = this.state.strict;
      let n2 = false, o2 = false;
      for (; !this.match(r2); ) {
        const r3 = this.parseStatement(null, s2);
        if (t2 && !o2) {
          if (this.isValidDirective(r3)) {
            const e3 = this.stmtToDirective(r3);
            t2.push(e3), n2 || e3.value.value !== "use strict" || (n2 = true, this.setStrict(true));
            continue;
          }
          o2 = true, this.state.strictErrors.clear();
        }
        e2.push(r3);
      }
      i2 && i2.call(this, n2), a2 || this.setStrict(false), this.next();
    }
    parseFor(e2, t2) {
      return e2.init = t2, this.semicolon(false), e2.test = this.match(bn$1.semi) ? null : this.parseExpression(), this.semicolon(false), e2.update = this.match(bn$1.parenR) ? null : this.parseExpression(), this.expect(bn$1.parenR), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e2, "ForStatement");
    }
    parseForIn(e2, t2, s2) {
      const r2 = this.match(bn$1._in);
      return this.next(), r2 ? s2 > -1 && this.unexpected(s2) : e2.await = s2 > -1, t2.type !== "VariableDeclaration" || t2.declarations[0].init == null || r2 && !this.state.strict && t2.kind === "var" && t2.declarations[0].id.type === "Identifier" ? t2.type === "AssignmentPattern" && this.raise(t2.start, Rn$1.InvalidLhs, "for-loop") : this.raise(t2.start, Rn$1.ForInOfLoopInitializer, r2 ? "for-in" : "for-of"), e2.left = t2, e2.right = r2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(bn$1.parenR), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e2, r2 ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e2, t2, s2) {
      const r2 = e2.declarations = [], i2 = this.hasPlugin("typescript");
      for (e2.kind = s2; ; ) {
        const e3 = this.startNode();
        if (this.parseVarId(e3, s2), this.eat(bn$1.eq) ? e3.init = t2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (s2 !== "const" || this.match(bn$1._in) || this.isContextual("of") ? e3.id.type === "Identifier" || t2 && (this.match(bn$1._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Complex binding patterns") : i2 || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Const declarations"), e3.init = null), r2.push(this.finishNode(e3, "VariableDeclarator")), !this.eat(bn$1.comma))
          break;
      }
      return e2;
    }
    parseVarId(e2, t2) {
      e2.id = this.parseBindingAtom(), this.checkLVal(e2.id, "variable declaration", t2 === "var" ? 5 : 9, void 0, t2 !== "var");
    }
    parseFunction(e2, t2 = 0, s2 = false) {
      const r2 = 1 & t2, i2 = 2 & t2, a2 = !(!r2 || 4 & t2);
      this.initFunction(e2, s2), this.match(bn$1.star) && i2 && this.raise(this.state.start, Rn$1.GeneratorInSingleStatementContext), e2.generator = this.eat(bn$1.star), r2 && (e2.id = this.parseFunctionId(a2));
      const n2 = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(wo$1(s2, e2.generator)), r2 || (e2.id = this.parseFunctionId()), this.parseFunctionParams(e2, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e2, r2 ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), r2 && !i2 && this.registerFunctionStatementId(e2), this.state.maybeInArrowParameters = n2, e2;
    }
    parseFunctionId(e2) {
      return e2 || this.match(bn$1.name) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e2, t2) {
      this.expect(bn$1.parenL), this.expressionScope.enter(new Fo$1(3)), e2.params = this.parseBindingList(bn$1.parenR, 41, false, t2), this.expressionScope.exit();
    }
    registerFunctionStatementId(e2) {
      e2.id && this.scope.declareName(e2.id.name, this.state.strict || e2.generator || e2.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, e2.id.start);
    }
    parseClass(e2, t2, s2) {
      this.next(), this.takeDecorators(e2);
      const r2 = this.state.strict;
      return this.state.strict = true, this.parseClassId(e2, t2, s2), this.parseClassSuper(e2), e2.body = this.parseClassBody(!!e2.superClass, r2), this.finishNode(e2, t2 ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(bn$1.eq) || this.match(bn$1.semi) || this.match(bn$1.braceR);
    }
    isClassMethod() {
      return this.match(bn$1.parenL);
    }
    isNonstaticConstructor(e2) {
      return !(e2.computed || e2.static || e2.key.name !== "constructor" && e2.key.value !== "constructor");
    }
    parseClassBody(e2, t2) {
      this.classScope.enter();
      const s2 = { hadConstructor: false, hadSuperClass: e2 };
      let r2 = [];
      const i2 = this.startNode();
      if (i2.body = [], this.expect(bn$1.braceL), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(bn$1.braceR); ) {
          if (this.eat(bn$1.semi)) {
            if (r2.length > 0)
              throw this.raise(this.state.lastTokEnd, Rn$1.DecoratorSemicolon);
            continue;
          }
          if (this.match(bn$1.at)) {
            r2.push(this.parseDecorator());
            continue;
          }
          const e3 = this.startNode();
          r2.length && (e3.decorators = r2, this.resetStartLocationFromNode(e3, r2[0]), r2 = []), this.parseClassMember(i2, e3, s2), e3.kind === "constructor" && e3.decorators && e3.decorators.length > 0 && this.raise(e3.start, Rn$1.DecoratorConstructor);
        }
      }), this.state.strict = t2, this.next(), r2.length)
        throw this.raise(this.state.start, Rn$1.TrailingDecorator);
      return this.classScope.exit(), this.finishNode(i2, "ClassBody");
    }
    parseClassMemberFromModifier(e2, t2) {
      const s2 = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const r2 = t2;
        return r2.kind = "method", r2.computed = false, r2.key = s2, r2.static = false, this.pushClassMethod(e2, r2, false, false, false, false), true;
      }
      if (this.isClassProperty()) {
        const r2 = t2;
        return r2.computed = false, r2.key = s2, r2.static = false, e2.body.push(this.parseClassProperty(r2)), true;
      }
      return this.resetPreviousNodeTrailingComments(s2), false;
    }
    parseClassMember(e2, t2, s2) {
      const r2 = this.isContextual("static");
      if (r2) {
        if (this.parseClassMemberFromModifier(e2, t2))
          return;
        if (this.eat(bn$1.braceL))
          return void this.parseClassStaticBlock(e2, t2);
      }
      this.parseClassMemberWithIsStatic(e2, t2, s2, r2);
    }
    parseClassMemberWithIsStatic(e2, t2, s2, r2) {
      const i2 = t2, a2 = t2, n2 = t2, o2 = t2, u2 = i2, h2 = i2;
      if (t2.static = r2, this.eat(bn$1.star)) {
        u2.kind = "method";
        const t3 = this.match(bn$1.privateName);
        return this.parseClassElementName(u2), t3 ? void this.pushClassPrivateMethod(e2, a2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsGenerator), void this.pushClassMethod(e2, i2, true, false, false, false));
      }
      const c2 = this.match(bn$1.name) && !this.state.containsEsc, p2 = this.match(bn$1.privateName), l2 = this.parseClassElementName(t2), d2 = this.state.start;
      if (this.parsePostMemberNameModifiers(h2), this.isClassMethod()) {
        if (u2.kind = "method", p2)
          return void this.pushClassPrivateMethod(e2, a2, false, false);
        const r3 = this.isNonstaticConstructor(i2);
        let n3 = false;
        r3 && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(l2.start, Rn$1.DuplicateConstructor), r3 && this.hasPlugin("typescript") && t2.override && this.raise(l2.start, Rn$1.OverrideOnConstructor), s2.hadConstructor = true, n3 = s2.hadSuperClass), this.pushClassMethod(e2, i2, false, false, r3, n3);
      } else if (this.isClassProperty())
        p2 ? this.pushClassPrivateProperty(e2, o2) : this.pushClassProperty(e2, n2);
      else if (c2 && l2.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(l2);
        const t3 = this.eat(bn$1.star);
        h2.optional && this.unexpected(d2), u2.kind = "method";
        const s3 = this.match(bn$1.privateName);
        this.parseClassElementName(u2), this.parsePostMemberNameModifiers(h2), s3 ? this.pushClassPrivateMethod(e2, a2, t3, true) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAsync), this.pushClassMethod(e2, i2, t3, true, false, false));
      } else if (!c2 || l2.name !== "get" && l2.name !== "set" || this.match(bn$1.star) && this.isLineTerminator())
        this.isLineTerminator() ? p2 ? this.pushClassPrivateProperty(e2, o2) : this.pushClassProperty(e2, n2) : this.unexpected();
      else {
        this.resetPreviousNodeTrailingComments(l2), u2.kind = l2.name;
        const t3 = this.match(bn$1.privateName);
        this.parseClassElementName(i2), t3 ? this.pushClassPrivateMethod(e2, a2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAccessor), this.pushClassMethod(e2, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
      }
    }
    parseClassElementName(e2) {
      const { type: t2, value: s2, start: r2 } = this.state;
      return t2 !== bn$1.name && t2 !== bn$1.string || !e2.static || s2 !== "prototype" || this.raise(r2, Rn$1.StaticPrototype), t2 === bn$1.privateName && s2 === "constructor" && this.raise(r2, Rn$1.ConstructorClassPrivateField), this.parsePropertyName(e2, true);
    }
    parseClassStaticBlock(e2, t2) {
      var s2;
      this.expectPlugin("classStaticBlock", t2.start), this.scope.enter(208);
      const r2 = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const i2 = t2.body = [];
      this.parseBlockOrModuleBlockBody(i2, void 0, false, bn$1.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = r2, e2.body.push(this.finishNode(t2, "StaticBlock")), (s2 = t2.decorators) != null && s2.length && this.raise(t2.start, Rn$1.DecoratorStaticBlock);
    }
    pushClassProperty(e2, t2) {
      t2.computed || t2.key.name !== "constructor" && t2.key.value !== "constructor" || this.raise(t2.key.start, Rn$1.ConstructorClassField), e2.body.push(this.parseClassProperty(t2));
    }
    pushClassPrivateProperty(e2, t2) {
      const s2 = this.parseClassPrivateProperty(t2);
      e2.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.start);
    }
    pushClassMethod(e2, t2, s2, r2, i2, a2) {
      e2.body.push(this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true));
    }
    pushClassPrivateMethod(e2, t2, s2, r2) {
      const i2 = this.parseMethod(t2, s2, r2, false, false, "ClassPrivateMethod", true);
      e2.body.push(i2);
      const a2 = i2.kind === "get" ? i2.static ? 6 : 2 : i2.kind === "set" ? i2.static ? 5 : 1 : 0;
      this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), a2, i2.key.start);
    }
    parsePostMemberNameModifiers(e2) {
    }
    parseClassPrivateProperty(e2) {
      return this.parseInitializer(e2), this.semicolon(), this.finishNode(e2, "ClassPrivateProperty");
    }
    parseClassProperty(e2) {
      return this.parseInitializer(e2), this.semicolon(), this.finishNode(e2, "ClassProperty");
    }
    parseInitializer(e2) {
      this.scope.enter(80), this.expressionScope.enter(Po$1()), this.prodParam.enter(0), e2.value = this.eat(bn$1.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e2, t2, s2, r2 = 139) {
      this.match(bn$1.name) ? (e2.id = this.parseIdentifier(), t2 && this.checkLVal(e2.id, "class name", r2)) : s2 || !t2 ? e2.id = null : this.unexpected(null, Rn$1.MissingClassName);
    }
    parseClassSuper(e2) {
      e2.superClass = this.eat(bn$1._extends) ? this.parseExprSubscripts() : null;
    }
    parseExport(e2) {
      const t2 = this.maybeParseExportDefaultSpecifier(e2), s2 = !t2 || this.eat(bn$1.comma), r2 = s2 && this.eatExportStar(e2), i2 = r2 && this.maybeParseExportNamespaceSpecifier(e2), a2 = s2 && (!i2 || this.eat(bn$1.comma)), n2 = t2 || r2;
      if (r2 && !i2)
        return t2 && this.unexpected(), this.parseExportFrom(e2, true), this.finishNode(e2, "ExportAllDeclaration");
      const o2 = this.maybeParseExportNamedSpecifiers(e2);
      if (t2 && s2 && !r2 && !o2 || i2 && a2 && !o2)
        throw this.unexpected(null, bn$1.braceL);
      let u2;
      if (n2 || o2 ? (u2 = false, this.parseExportFrom(e2, n2)) : u2 = this.maybeParseExportDeclaration(e2), n2 || o2 || u2)
        return this.checkExport(e2, true, false, !!e2.source), this.finishNode(e2, "ExportNamedDeclaration");
      if (this.eat(bn$1._default))
        return e2.declaration = this.parseExportDefaultExpression(), this.checkExport(e2, true, true), this.finishNode(e2, "ExportDefaultDeclaration");
      throw this.unexpected(null, bn$1.braceL);
    }
    eatExportStar(e2) {
      return this.eat(bn$1.star);
    }
    maybeParseExportDefaultSpecifier(e2) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const t2 = this.startNode();
        return t2.exported = this.parseIdentifier(true), e2.specifiers = [this.finishNode(t2, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(e2) {
      if (this.isContextual("as")) {
        e2.specifiers || (e2.specifiers = []);
        const t2 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        return this.next(), t2.exported = this.parseModuleExportName(), e2.specifiers.push(this.finishNode(t2, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(e2) {
      return !!this.match(bn$1.braceL) && (e2.specifiers || (e2.specifiers = []), e2.specifiers.push(...this.parseExportSpecifiers()), e2.source = null, e2.declaration = null, true);
    }
    maybeParseExportDeclaration(e2) {
      return !!this.shouldParseExportDeclaration() && (e2.specifiers = [], e2.source = null, e2.declaration = this.parseExportDeclaration(e2), true);
    }
    isAsyncFunction() {
      if (!this.isContextual("async"))
        return false;
      const e2 = this.nextTokenStart();
      return !Pn$1.test(this.input.slice(this.state.pos, e2)) && this.isUnparsedContextual(e2, "function");
    }
    parseExportDefaultExpression() {
      const e2 = this.startNode(), t2 = this.isAsyncFunction();
      if (this.match(bn$1._function) || t2)
        return this.next(), t2 && this.next(), this.parseFunction(e2, 5, t2);
      if (this.match(bn$1._class))
        return this.parseClass(e2, true, true);
      if (this.match(bn$1.at))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(e2, true, true);
      if (this.match(bn$1._const) || this.match(bn$1._var) || this.isLet())
        throw this.raise(this.state.start, Rn$1.UnsupportedDefaultExport);
      {
        const e3 = this.parseMaybeAssignAllowIn();
        return this.semicolon(), e3;
      }
    }
    parseExportDeclaration(e2) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      if (this.match(bn$1.name)) {
        const e3 = this.state.value;
        if (e3 === "async" && !this.state.containsEsc || e3 === "let")
          return false;
        if ((e3 === "type" || e3 === "interface") && !this.state.containsEsc) {
          const e4 = this.lookahead();
          if (e4.type === bn$1.name && e4.value !== "from" || e4.type === bn$1.braceL)
            return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(bn$1._default))
        return false;
      const e2 = this.nextTokenStart(), t2 = this.isUnparsedContextual(e2, "from");
      if (this.input.charCodeAt(e2) === 44 || this.match(bn$1.name) && t2)
        return true;
      if (this.match(bn$1._default) && t2) {
        const t3 = this.input.charCodeAt(this.nextTokenStartSince(e2 + 4));
        return t3 === 34 || t3 === 39;
      }
      return false;
    }
    parseExportFrom(e2, t2) {
      if (this.eatContextual("from")) {
        e2.source = this.parseImportSource(), this.checkExport(e2);
        const t3 = this.maybeParseImportAssertions();
        t3 && (e2.assertions = t3);
      } else
        t2 ? this.unexpected() : e2.source = null;
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      if (this.match(bn$1.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
        if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
          return true;
        this.unexpected(this.state.start, Rn$1.DecoratorBeforeExport);
      }
      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e2, t2, s2, r2) {
      if (t2) {
        if (s2) {
          if (this.checkDuplicateExports(e2, "default"), this.hasPlugin("exportDefaultFrom")) {
            var i2;
            const t3 = e2.declaration;
            t3.type !== "Identifier" || t3.name !== "from" || t3.end - t3.start != 4 || (i2 = t3.extra) != null && i2.parenthesized || this.raise(t3.start, Rn$1.ExportDefaultFromAsIdentifier);
          }
        } else if (e2.specifiers && e2.specifiers.length)
          for (const t3 of e2.specifiers) {
            const { exported: e3 } = t3, s3 = e3.type === "Identifier" ? e3.name : e3.value;
            if (this.checkDuplicateExports(t3, s3), !r2 && t3.local) {
              const { local: e4 } = t3;
              e4.type !== "Identifier" ? this.raise(t3.start, Rn$1.ExportBindingIsString, e4.value, s3) : (this.checkReservedWord(e4.name, e4.start, true, false), this.scope.checkLocalExport(e4));
            }
          }
        else if (e2.declaration) {
          if (e2.declaration.type === "FunctionDeclaration" || e2.declaration.type === "ClassDeclaration") {
            const t3 = e2.declaration.id;
            if (!t3)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(e2, t3.name);
          } else if (e2.declaration.type === "VariableDeclaration")
            for (const t3 of e2.declaration.declarations)
              this.checkDeclaration(t3.id);
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(e2.start, Rn$1.UnsupportedDecoratorExport);
    }
    checkDeclaration(e2) {
      if (e2.type === "Identifier")
        this.checkDuplicateExports(e2, e2.name);
      else if (e2.type === "ObjectPattern")
        for (const t2 of e2.properties)
          this.checkDeclaration(t2);
      else if (e2.type === "ArrayPattern")
        for (const t2 of e2.elements)
          t2 && this.checkDeclaration(t2);
      else
        e2.type === "ObjectProperty" ? this.checkDeclaration(e2.value) : e2.type === "RestElement" ? this.checkDeclaration(e2.argument) : e2.type === "AssignmentPattern" && this.checkDeclaration(e2.left);
    }
    checkDuplicateExports(e2, t2) {
      this.exportedIdentifiers.has(t2) && this.raise(e2.start, t2 === "default" ? Rn$1.DuplicateDefaultExport : Rn$1.DuplicateExport, t2), this.exportedIdentifiers.add(t2);
    }
    parseExportSpecifiers() {
      const e2 = [];
      let t2 = true;
      for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
        if (t2)
          t2 = false;
        else if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
          break;
        const s2 = this.startNode(), r2 = this.match(bn$1.string), i2 = this.parseModuleExportName();
        s2.local = i2, this.eatContextual("as") ? s2.exported = this.parseModuleExportName() : s2.exported = r2 ? vo$1(i2) : Io$1(i2), e2.push(this.finishNode(s2, "ExportSpecifier"));
      }
      return e2;
    }
    parseModuleExportName() {
      if (this.match(bn$1.string)) {
        const e2 = this.parseStringLiteral(this.state.value), t2 = e2.value.match(hu);
        return t2 && this.raise(e2.start, Rn$1.ModuleExportNameHasLoneSurrogate, t2[0].charCodeAt(0).toString(16)), e2;
      }
      return this.parseIdentifier(true);
    }
    parseImport(e2) {
      if (e2.specifiers = [], !this.match(bn$1.string)) {
        const t3 = !this.maybeParseDefaultImportSpecifier(e2) || this.eat(bn$1.comma), s2 = t3 && this.maybeParseStarImportSpecifier(e2);
        t3 && !s2 && this.parseNamedImportSpecifiers(e2), this.expectContextual("from");
      }
      e2.source = this.parseImportSource();
      const t2 = this.maybeParseImportAssertions();
      if (t2)
        e2.assertions = t2;
      else {
        const t3 = this.maybeParseModuleAttributes();
        t3 && (e2.attributes = t3);
      }
      return this.semicolon(), this.finishNode(e2, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(bn$1.string) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(e2) {
      return this.match(bn$1.name);
    }
    parseImportSpecifierLocal(e2, t2, s2, r2) {
      t2.local = this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e2.specifiers.push(this.finishNode(t2, s2));
    }
    parseAssertEntries() {
      const e2 = [], t2 = new Set();
      do {
        if (this.match(bn$1.braceR))
          break;
        const s2 = this.startNode(), r2 = this.state.value;
        if (t2.has(r2) && this.raise(this.state.start, Rn$1.ModuleAttributesWithDuplicateKeys, r2), t2.add(r2), this.match(bn$1.string) ? s2.key = this.parseStringLiteral(r2) : s2.key = this.parseIdentifier(true), this.expect(bn$1.colon), !this.match(bn$1.string))
          throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
        s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e2.push(s2);
      } while (this.eat(bn$1.comma));
      return e2;
    }
    maybeParseModuleAttributes() {
      if (!this.match(bn$1._with) || this.hasPrecedingLineBreak())
        return this.hasPlugin("moduleAttributes") ? [] : null;
      this.expectPlugin("moduleAttributes"), this.next();
      const e2 = [], t2 = new Set();
      do {
        const s2 = this.startNode();
        if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(s2.key.start, Rn$1.ModuleAttributeDifferentFromType, s2.key.name), t2.has(s2.key.name) && this.raise(s2.key.start, Rn$1.ModuleAttributesWithDuplicateKeys, s2.key.name), t2.add(s2.key.name), this.expect(bn$1.colon), !this.match(bn$1.string))
          throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
        s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e2.push(s2);
      } while (this.eat(bn$1.comma));
      return e2;
    }
    maybeParseImportAssertions() {
      if (!this.isContextual("assert") || this.hasPrecedingLineBreak())
        return this.hasPlugin("importAssertions") ? [] : null;
      this.expectPlugin("importAssertions"), this.next(), this.eat(bn$1.braceL);
      const e2 = this.parseAssertEntries();
      return this.eat(bn$1.braceR), e2;
    }
    maybeParseDefaultImportSpecifier(e2) {
      return !!this.shouldParseDefaultImport(e2) && (this.parseImportSpecifierLocal(e2, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
    }
    maybeParseStarImportSpecifier(e2) {
      if (this.match(bn$1.star)) {
        const t2 = this.startNode();
        return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(e2, t2, "ImportNamespaceSpecifier", "import namespace specifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(e2) {
      let t2 = true;
      for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
        if (t2)
          t2 = false;
        else {
          if (this.eat(bn$1.colon))
            throw this.raise(this.state.start, Rn$1.DestructureNamedImport);
          if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
            break;
        }
        this.parseImportSpecifier(e2);
      }
    }
    parseImportSpecifier(e2) {
      const t2 = this.startNode(), s2 = this.match(bn$1.string);
      if (t2.imported = this.parseModuleExportName(), this.eatContextual("as"))
        t2.local = this.parseIdentifier();
      else {
        const { imported: e3 } = t2;
        if (s2)
          throw this.raise(t2.start, Rn$1.ImportBindingIsString, e3.value);
        this.checkReservedWord(e3.name, t2.start, true, true), t2.local = Io$1(e3);
      }
      this.checkLVal(t2.local, "import specifier", 9), e2.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
    }
    isThisParam(e2) {
      return e2.type === "Identifier" && e2.name === "this";
    }
  } {
    constructor(e2, t2) {
      super(e2 = function(e3) {
        const t3 = {};
        for (const s2 of Object.keys(au))
          t3[s2] = e3 && e3[s2] != null ? e3[s2] : au[s2];
        return t3;
      }(e2), t2), this.options = e2, this.initializeScopes(), this.plugins = function(e3) {
        const t3 = new Map();
        for (const s2 of e3) {
          const [e4, r2] = Array.isArray(s2) ? s2 : [s2, {}];
          t3.has(e4) || t3.set(e4, r2 || {});
        }
        return t3;
      }(this.options.plugins), this.filename = e2.sourceFilename;
    }
    getScopeHandler() {
      return co$1;
    }
    parse() {
      this.enterInitialScopes();
      const e2 = this.startNode(), t2 = this.startNode();
      return this.nextToken(), e2.errors = null, this.parseTopLevel(e2, t2), e2.errors = this.state.errors, e2;
    }
  }
  function lu(e2, t2) {
    let s2 = pu;
    return e2 != null && e2.plugins && (!function(e3) {
      if (Qo(e3, "decorators")) {
        if (Qo(e3, "decorators-legacy"))
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        const t3 = Zo(e3, "decorators", "decoratorsBeforeExport");
        if (t3 == null)
          throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
        if (typeof t3 != "boolean")
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
      if (Qo(e3, "flow") && Qo(e3, "typescript"))
        throw new Error("Cannot combine flow and typescript plugins.");
      if (Qo(e3, "placeholders") && Qo(e3, "v8intrinsic"))
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      if (Qo(e3, "pipelineOperator")) {
        const t3 = Zo(e3, "pipelineOperator", "proposal");
        if (!eu.includes(t3)) {
          const e4 = eu.map((e5) => `"${e5}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e4}.`);
        }
        const s3 = Qo(e3, "recordAndTuple") && Zo(e3, "recordAndTuple", "syntaxType") === "hash";
        if (t3 === "hack") {
          if (Qo(e3, "placeholders"))
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          if (Qo(e3, "v8intrinsic"))
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          const t4 = Zo(e3, "pipelineOperator", "topicToken");
          if (!tu.includes(t4)) {
            const e4 = tu.map((e5) => `"${e5}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e4}.`);
          }
          if (t4 === "#" && s3)
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        } else if (t3 === "smart" && s3)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
      if (Qo(e3, "moduleAttributes")) {
        if (Qo(e3, "importAssertions"))
          throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
        if (Zo(e3, "moduleAttributes", "version") !== "may-2020")
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
      }
      if (Qo(e3, "recordAndTuple") && !su.includes(Zo(e3, "recordAndTuple", "syntaxType")))
        throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + su.map((e4) => `'${e4}'`).join(", "));
      if (Qo(e3, "asyncDoExpressions") && !Qo(e3, "doExpressions")) {
        const e4 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        throw e4.missingPlugins = "doExpressions", e4;
      }
    }(e2.plugins), s2 = function(e3) {
      const t3 = iu.filter((t4) => Qo(e3, t4)), s3 = t3.join("/");
      let r2 = du[s3];
      if (!r2) {
        r2 = pu;
        for (const e4 of t3)
          r2 = ru[e4](r2);
        du[s3] = r2;
      }
      return r2;
    }(e2.plugins)), new s2(e2, t2);
  }
  const du = {};
  var Du = function(e2, t2) {
    var s2;
    if (((s2 = t2) == null ? void 0 : s2.sourceType) !== "unambiguous")
      return lu(t2, e2).parse();
    t2 = Object.assign({}, t2);
    try {
      t2.sourceType = "module";
      const s3 = lu(t2, e2), r2 = s3.parse();
      if (s3.sawUnambiguousESM)
        return r2;
      if (s3.ambiguousScriptDifferentAst)
        try {
          return t2.sourceType = "script", lu(t2, e2).parse();
        } catch (e3) {
        }
      else
        r2.program.sourceType = "script";
      return r2;
    } catch (s3) {
      try {
        return t2.sourceType = "script", lu(t2, e2).parse();
      } catch (e3) {
      }
      throw s3;
    }
  }, mu = function(e2, t2) {
    const s2 = lu(t2, e2);
    return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
  }, fu = bn$1, yu = Object.defineProperty({ parse: Du, parseExpression: mu, tokTypes: fu }, "__esModule", { value: true });
  const { isNonEmptyArray: Au } = tr$1;
  function Eu(e2 = {}) {
    const { allowComments: t2 = true } = e2;
    return function(e3) {
      const { parseExpression: s2 } = yu;
      let r2;
      try {
        r2 = s2(e3, { tokens: true, ranges: true });
      } catch (e4) {
        throw ni$1(e4);
      }
      if (!t2 && Au(r2.comments))
        throw Cu(r2.comments[0], "Comment");
      return xu(r2), r2;
    };
  }
  function Cu(e2, t2) {
    const [s2, r2] = [e2.loc.start, e2.loc.end].map(({ line: e3, column: t3 }) => ({ line: e3, column: t3 + 1 }));
    return ai$1(`${t2} is not allowed in JSON.`, { start: s2, end: r2 });
  }
  function xu(e2) {
    switch (e2.type) {
      case "ArrayExpression":
        for (const t2 of e2.elements)
          t2 !== null && xu(t2);
        return;
      case "ObjectExpression":
        for (const t2 of e2.properties)
          xu(t2);
        return;
      case "ObjectProperty":
        if (e2.computed)
          throw Cu(e2.key, "Computed key");
        if (e2.shorthand)
          throw Cu(e2.key, "Shorthand property");
        return e2.key.type !== "Identifier" && xu(e2.key), void xu(e2.value);
      case "UnaryExpression": {
        const { operator: t2, argument: s2 } = e2;
        if (t2 !== "+" && t2 !== "-")
          throw Cu(e2, `Operator '${e2.operator}'`);
        if (s2.type === "NumericLiteral" || s2.type === "Identifier" && (s2.name === "Infinity" || s2.name === "NaN"))
          return;
        throw Cu(s2, `Operator '${t2}' before '${s2.type}'`);
      }
      case "Identifier":
        if (e2.name !== "Infinity" && e2.name !== "NaN" && e2.name !== "undefined")
          throw Cu(e2, `Identifier '${e2.name}'`);
        return;
      case "TemplateLiteral":
        if (Au(e2.expressions))
          throw Cu(e2.expressions[0], "'TemplateLiteral' with expression");
        for (const t2 of e2.quasis)
          xu(t2);
        return;
      case "NullLiteral":
      case "BooleanLiteral":
      case "NumericLiteral":
      case "StringLiteral":
      case "TemplateElement":
        return;
      default:
        throw Cu(e2, `'${e2.type}'`);
    }
  }
  const Fu = Eu();
  var gu = { json: ii$1({ parse: Fu, hasPragma: () => true }), json5: ii$1(Fu), "json-stringify": ii$1({ parse: Eu({ allowComments: false }), astFormat: "estree-json" }) };
  const { getNextNonSpaceNonCommentCharacterIndexWithStartIndex: bu, getShebang: Pu } = tr$1, Tu = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "classStaticBlock", "moduleBlocks", "asyncDoExpressions"], tokens: true, ranges: true }, wu = ["recordAndTuple", { syntaxType: "hash" }], Su = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], Bu = (e2, t2 = Tu) => Object.assign(Object.assign({}, t2), {}, { plugins: [...t2.plugins, ...e2] }), Nu = /@(?:no)?flow\b/;
  function Iu(e2, ...t2) {
    return (s2, r2, i2 = {}) => {
      if ((i2.parser === "babel" || i2.parser === "__babel_estree") && function(e3, t3) {
        if (t3.filepath && t3.filepath.endsWith(".js.flow"))
          return true;
        const s3 = Pu(e3);
        s3 && (e3 = e3.slice(s3.length));
        const r3 = bu(e3, 0);
        return r3 !== false && (e3 = e3.slice(0, r3)), Nu.test(e3);
      }(s2, i2))
        return i2.parser = "babel-flow", ku(s2, r2, i2);
      let a2 = t2;
      i2.__babelSourceType === "script" && (a2 = a2.map((e3) => Object.assign(Object.assign({}, e3), {}, { sourceType: "script" }))), /#[[{]/.test(s2) && (a2 = a2.map((e3) => Bu([wu], e3)));
      const n2 = /%[A-Z]/.test(s2);
      if (s2.includes("|>")) {
        const e3 = n2 ? [...Su, "v8intrinsic"] : Su;
        a2 = e3.flatMap((e4) => a2.map((t3) => Bu([e4], t3)));
      } else
        n2 && (a2 = a2.map((e3) => Bu(["v8intrinsic"], e3)));
      const { result: o2, error: u2 } = Je$2(...a2.map((t3) => () => function(e3, t4, s3) {
        const r3 = (0, yu[e3])(t4, s3), i3 = r3.errors.find((e4) => !Ru.has(e4.reasonCode));
        if (i3)
          throw i3;
        return r3;
      }(e2, s2, t3)));
      if (!o2)
        throw ni$1(u2);
      return En$1(o2, Object.assign(Object.assign({}, i2), {}, { originalText: s2 }));
    };
  }
  const vu = Iu("parse", Bu(["jsx", "flow"])), ku = Iu("parse", Bu(["jsx", ["flow", { all: true, enums: true }]])), Lu = Iu("parse", Bu(["jsx", "typescript"]), Bu(["typescript"])), Ou = Iu("parse", Bu(["jsx", "flow", "estree"])), Mu = Iu("parseExpression", Bu(["jsx"])), Ru = new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), ju = ii$1(vu), _u = ii$1(Mu);
  var Uu = { parsers: Object.assign(Object.assign({ babel: ju, "babel-flow": ii$1(ku), "babel-ts": ii$1(Lu) }, gu), {}, { __js_expression: _u, __vue_expression: _u, __vue_event_binding: ju, __babel_estree: ii$1(Ou) }) };
  var e$1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function t$1(e2) {
    var t2 = { exports: {} };
    return e2(t2, t2.exports), t2.exports;
  }
  var r$1 = t$1(function(e2, t2) {
    function r2(e3) {
      return t2.$0 <= e3 && e3 <= t2.$9;
    }
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", { value: true }), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e3) {
      return e3 >= t2.$TAB && e3 <= t2.$SPACE || e3 == t2.$NBSP;
    }, t2.isDigit = r2, t2.isAsciiLetter = function(e3) {
      return e3 >= t2.$a && e3 <= t2.$z || e3 >= t2.$A && e3 <= t2.$Z;
    }, t2.isAsciiHexDigit = function(e3) {
      return e3 >= t2.$a && e3 <= t2.$f || e3 >= t2.$A && e3 <= t2.$F || r2(e3);
    }, t2.isNewLine = function(e3) {
      return e3 === t2.$LF || e3 === t2.$CR;
    }, t2.isOctalDigit = function(e3) {
      return t2.$0 <= e3 && e3 <= t2.$7;
    };
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class n$1 {
    constructor(e2, t2, r2) {
      this.filePath = e2, this.name = t2, this.members = r2;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
    }
  }
  var i$1 = n$1;
  var s$1 = class {
    constructor() {
      this.cache = new Map();
    }
    get(e2, t2, r2) {
      const i2 = `"${e2}".${t2}${(r2 = r2 || []).length ? `.${r2.join(".")}` : ""}`;
      let s2 = this.cache.get(i2);
      return s2 || (s2 = new n$1(e2, t2, r2), this.cache.set(i2, s2)), s2;
    }
  }, o$1 = Object.defineProperty({ StaticSymbol: i$1, StaticSymbolCache: s$1 }, "__esModule", { value: true });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const a$1 = /-+([a-z0-9])/g;
  var u$1 = function(e2) {
    return e2.replace(a$1, (...e3) => e3[1].toUpperCase());
  };
  var c$1 = function(e2, t2) {
    return p$1(e2, ":", t2);
  };
  var l$1 = function(e2, t2) {
    return p$1(e2, ".", t2);
  };
  function p$1(e2, t2, r2) {
    const n2 = e2.indexOf(t2);
    return n2 == -1 ? r2 : [e2.slice(0, n2).trim(), e2.slice(n2 + 1).trim()];
  }
  function h$1(e2, t2, r2) {
    return Array.isArray(e2) ? t2.visitArray(e2, r2) : typeof (n2 = e2) == "object" && n2 !== null && Object.getPrototypeOf(n2) === v$1 ? t2.visitStringMap(e2, r2) : e2 == null || typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean" ? t2.visitPrimitive(e2, r2) : t2.visitOther(e2, r2);
    var n2;
  }
  var D$1 = h$1;
  var f$1 = function(e2) {
    return e2 != null;
  };
  var d$1 = function(e2) {
    return e2 === void 0 ? null : e2;
  };
  var g$1 = class {
    visitArray(e2, t2) {
      return e2.map((e3) => h$1(e3, this, t2));
    }
    visitStringMap(e2, t2) {
      const r2 = {};
      return Object.keys(e2).forEach((n2) => {
        r2[n2] = h$1(e2[n2], this, t2);
      }), r2;
    }
    visitPrimitive(e2, t2) {
      return e2;
    }
    visitOther(e2, t2) {
      return e2;
    }
  }, m$1 = { assertSync: (e2) => {
    if (k$1(e2))
      throw new Error("Illegal state: value cannot be a promise");
    return e2;
  }, then: (e2, t2) => k$1(e2) ? e2.then(t2) : t2(e2), all: (e2) => e2.some(k$1) ? Promise.all(e2) : e2 };
  var E$1 = function(e2) {
    throw new Error(`Internal Error: ${e2}`);
  };
  var C$1 = function(e2, t2) {
    const r2 = Error(e2);
    return r2[y$1] = true, t2 && (r2[b$1] = t2), r2;
  };
  const y$1 = "ngSyntaxError", b$1 = "ngParseErrors";
  var S$1 = function(e2) {
    return e2[y$1];
  };
  var T$1 = function(e2) {
    return e2[b$1] || [];
  };
  var _$1 = function(e2) {
    return e2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  };
  const v$1 = Object.getPrototypeOf({});
  var A$1 = function(e2) {
    let t2 = "";
    for (let r2 = 0; r2 < e2.length; r2++) {
      let n2 = e2.charCodeAt(r2);
      if (n2 >= 55296 && n2 <= 56319 && e2.length > r2 + 1) {
        const t3 = e2.charCodeAt(r2 + 1);
        t3 >= 56320 && t3 <= 57343 && (r2++, n2 = (n2 - 55296 << 10) + t3 - 56320 + 65536);
      }
      n2 <= 127 ? t2 += String.fromCharCode(n2) : n2 <= 2047 ? t2 += String.fromCharCode(n2 >> 6 & 31 | 192, 63 & n2 | 128) : n2 <= 65535 ? t2 += String.fromCharCode(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128) : n2 <= 2097151 && (t2 += String.fromCharCode(n2 >> 18 & 7 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128));
    }
    return t2;
  };
  var F$1 = function e2(t2) {
    if (typeof t2 == "string")
      return t2;
    if (t2 instanceof Array)
      return "[" + t2.map(e2).join(", ") + "]";
    if (t2 == null)
      return "" + t2;
    if (t2.overriddenName)
      return `${t2.overriddenName}`;
    if (t2.name)
      return `${t2.name}`;
    if (!t2.toString)
      return "object";
    const r2 = t2.toString();
    if (r2 == null)
      return "" + r2;
    const n2 = r2.indexOf("\n");
    return n2 === -1 ? r2 : r2.substring(0, n2);
  };
  var w$1 = function(e2) {
    return typeof e2 == "function" && e2.hasOwnProperty("__forward_ref__") ? e2() : e2;
  };
  function k$1(e2) {
    return !!e2 && typeof e2.then == "function";
  }
  var N$1 = k$1;
  var O$1 = class {
    constructor(e2) {
      this.full = e2;
      const t2 = e2.split(".");
      this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
    }
  };
  const x$1 = typeof window != "undefined" && window, I$1 = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
  var P$1 = e$1 !== void 0 && e$1 || x$1 || I$1, R$1 = Object.defineProperty({ dashCaseToCamelCase: u$1, splitAtColon: c$1, splitAtPeriod: l$1, visitValue: D$1, isDefined: f$1, noUndefined: d$1, ValueTransformer: g$1, SyncAsync: m$1, error: E$1, syntaxError: C$1, isSyntaxError: S$1, getParseErrors: T$1, escapeRegExp: _$1, utf8Encode: A$1, stringify: F$1, resolveForwardRef: w$1, isPromise: N$1, Version: O$1, global: P$1 }, "__esModule", { value: true }), L$1 = t$1(function(e2, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", { value: true });
    const r2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function n2(e3) {
      return e3.replace(/\W/g, "_");
    }
    t2.sanitizeIdentifier = n2;
    let i2 = 0;
    function s2(e3) {
      if (!e3 || !e3.reference)
        return null;
      const t3 = e3.reference;
      if (t3 instanceof o$1.StaticSymbol)
        return t3.name;
      if (t3.__anonymousType)
        return t3.__anonymousType;
      let r3 = R$1.stringify(t3);
      return r3.indexOf("(") >= 0 ? (r3 = "anonymous_" + i2++, t3.__anonymousType = r3) : r3 = n2(r3), r3;
    }
    var a2;
    t2.identifierName = s2, t2.identifierModuleUrl = function(e3) {
      const t3 = e3.reference;
      return t3 instanceof o$1.StaticSymbol ? t3.filePath : `./${R$1.stringify(t3)}`;
    }, t2.viewClassName = function(e3, t3) {
      return `View_${s2({ reference: e3 })}_${t3}`;
    }, t2.rendererTypeName = function(e3) {
      return `RenderType_${s2({ reference: e3 })}`;
    }, t2.hostViewClassName = function(e3) {
      return `HostView_${s2({ reference: e3 })}`;
    }, t2.componentFactoryName = function(e3) {
      return `${s2({ reference: e3 })}NgFactory`;
    }, function(e3) {
      e3[e3.Pipe = 0] = "Pipe", e3[e3.Directive = 1] = "Directive", e3[e3.NgModule = 2] = "NgModule", e3[e3.Injectable = 3] = "Injectable";
    }(a2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e3) {
      return e3.value != null ? n2(e3.value) : s2(e3.identifier);
    }, t2.tokenReference = function(e3) {
      return e3.identifier != null ? e3.identifier.reference : e3.value;
    };
    t2.CompileStylesheetMetadata = class {
      constructor({ moduleUrl: e3, styles: t3, styleUrls: r3 } = {}) {
        this.moduleUrl = e3 || null, this.styles = c2(t3), this.styleUrls = c2(r3);
      }
    };
    t2.CompileTemplateMetadata = class {
      constructor({ encapsulation: e3, template: t3, templateUrl: r3, htmlAst: n3, styles: i3, styleUrls: s3, externalStylesheets: o2, animations: a3, ngContentSelectors: u3, interpolation: p3, isInline: h2, preserveWhitespaces: D2 }) {
        if (this.encapsulation = e3, this.template = t3, this.templateUrl = r3, this.htmlAst = n3, this.styles = c2(i3), this.styleUrls = c2(s3), this.externalStylesheets = c2(o2), this.animations = a3 ? l2(a3) : [], this.ngContentSelectors = u3 || [], p3 && p3.length != 2)
          throw new Error("'interpolation' should have a start and an end symbol.");
        this.interpolation = p3, this.isInline = h2, this.preserveWhitespaces = D2;
      }
      toSummary() {
        return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
      }
    };
    class u2 {
      static create({ isHost: e3, type: t3, isComponent: n3, selector: i3, exportAs: s3, changeDetection: o2, inputs: a3, outputs: c3, host: l3, providers: p3, viewProviders: h2, queries: D2, guards: f2, viewQueries: d2, entryComponents: g2, template: m2, componentViewType: E2, rendererType: C2, componentFactory: y2 }) {
        const b2 = {}, S2 = {}, T2 = {};
        l3 != null && Object.keys(l3).forEach((e4) => {
          const t4 = l3[e4], n4 = e4.match(r2);
          n4 === null ? T2[e4] = t4 : n4[1] != null ? S2[n4[1]] = t4 : n4[2] != null && (b2[n4[2]] = t4);
        });
        const _2 = {};
        a3 != null && a3.forEach((e4) => {
          const t4 = R$1.splitAtColon(e4, [e4, e4]);
          _2[t4[0]] = t4[1];
        });
        const v2 = {};
        return c3 != null && c3.forEach((e4) => {
          const t4 = R$1.splitAtColon(e4, [e4, e4]);
          v2[t4[0]] = t4[1];
        }), new u2({ isHost: e3, type: t3, isComponent: !!n3, selector: i3, exportAs: s3, changeDetection: o2, inputs: _2, outputs: v2, hostListeners: b2, hostProperties: S2, hostAttributes: T2, providers: p3, viewProviders: h2, queries: D2, guards: f2, viewQueries: d2, entryComponents: g2, template: m2, componentViewType: E2, rendererType: C2, componentFactory: y2 });
      }
      constructor({ isHost: e3, type: t3, isComponent: r3, selector: n3, exportAs: i3, changeDetection: s3, inputs: o2, outputs: a3, hostListeners: u3, hostProperties: l3, hostAttributes: p3, providers: h2, viewProviders: D2, queries: f2, guards: d2, viewQueries: g2, entryComponents: m2, template: E2, componentViewType: C2, rendererType: y2, componentFactory: b2 }) {
        this.isHost = !!e3, this.type = t3, this.isComponent = r3, this.selector = n3, this.exportAs = i3, this.changeDetection = s3, this.inputs = o2, this.outputs = a3, this.hostListeners = u3, this.hostProperties = l3, this.hostAttributes = p3, this.providers = c2(h2), this.viewProviders = c2(D2), this.queries = c2(f2), this.guards = d2, this.viewQueries = c2(g2), this.entryComponents = c2(m2), this.template = E2, this.componentViewType = C2, this.rendererType = y2, this.componentFactory = b2;
      }
      toSummary() {
        return { summaryKind: a2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
      }
    }
    t2.CompileDirectiveMetadata = u2;
    t2.CompilePipeMetadata = class {
      constructor({ type: e3, name: t3, pure: r3 }) {
        this.type = e3, this.name = t3, this.pure = !!r3;
      }
      toSummary() {
        return { summaryKind: a2.Pipe, type: this.type, name: this.name, pure: this.pure };
      }
    };
    t2.CompileShallowModuleMetadata = class {
    };
    t2.CompileNgModuleMetadata = class {
      constructor({ type: e3, providers: t3, declaredDirectives: r3, exportedDirectives: n3, declaredPipes: i3, exportedPipes: s3, entryComponents: o2, bootstrapComponents: a3, importedModules: u3, exportedModules: l3, schemas: p3, transitiveModule: h2, id: D2 }) {
        this.type = e3 || null, this.declaredDirectives = c2(r3), this.exportedDirectives = c2(n3), this.declaredPipes = c2(i3), this.exportedPipes = c2(s3), this.providers = c2(t3), this.entryComponents = c2(o2), this.bootstrapComponents = c2(a3), this.importedModules = c2(u3), this.exportedModules = c2(l3), this.schemas = c2(p3), this.id = D2 || null, this.transitiveModule = h2 || null;
      }
      toSummary() {
        const e3 = this.transitiveModule;
        return { summaryKind: a2.NgModule, type: this.type, entryComponents: e3.entryComponents, providers: e3.providers, modules: e3.modules, exportedDirectives: e3.exportedDirectives, exportedPipes: e3.exportedPipes };
      }
    };
    function c2(e3) {
      return e3 || [];
    }
    t2.TransitiveCompileNgModuleMetadata = class {
      constructor() {
        this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
      }
      addProvider(e3, t3) {
        this.providers.push({ provider: e3, module: t3 });
      }
      addDirective(e3) {
        this.directivesSet.has(e3.reference) || (this.directivesSet.add(e3.reference), this.directives.push(e3));
      }
      addExportedDirective(e3) {
        this.exportedDirectivesSet.has(e3.reference) || (this.exportedDirectivesSet.add(e3.reference), this.exportedDirectives.push(e3));
      }
      addPipe(e3) {
        this.pipesSet.has(e3.reference) || (this.pipesSet.add(e3.reference), this.pipes.push(e3));
      }
      addExportedPipe(e3) {
        this.exportedPipesSet.has(e3.reference) || (this.exportedPipesSet.add(e3.reference), this.exportedPipes.push(e3));
      }
      addModule(e3) {
        this.modulesSet.has(e3.reference) || (this.modulesSet.add(e3.reference), this.modules.push(e3));
      }
      addEntryComponent(e3) {
        this.entryComponentsSet.has(e3.componentType) || (this.entryComponentsSet.add(e3.componentType), this.entryComponents.push(e3));
      }
    };
    function l2(e3) {
      return e3.reduce((e4, t3) => {
        const r3 = Array.isArray(t3) ? l2(t3) : t3;
        return e4.concat(r3);
      }, []);
    }
    function p2(e3) {
      return e3.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t2.ProviderMeta = class {
      constructor(e3, { useClass: t3, useValue: r3, useExisting: n3, useFactory: i3, deps: s3, multi: o2 }) {
        this.token = e3, this.useClass = t3 || null, this.useValue = r3, this.useExisting = n3, this.useFactory = i3 || null, this.dependencies = s3 || null, this.multi = !!o2;
      }
    }, t2.flatten = l2, t2.templateSourceUrl = function(e3, t3, r3) {
      let n3;
      return n3 = r3.isInline ? t3.type.reference instanceof o$1.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${s2(e3)}/${s2(t3.type)}.html` : r3.templateUrl, t3.type.reference instanceof o$1.StaticSymbol ? n3 : p2(n3);
    }, t2.sharedStylesheetJitUrl = function(e3, t3) {
      const r3 = e3.moduleUrl.split(/\/\\/g);
      return p2(`css/${t3}${r3[r3.length - 1]}.ngstyle.js`);
    }, t2.ngModuleJitUrl = function(e3) {
      return p2(`${s2(e3.type)}/module.ngfactory.js`);
    }, t2.templateJitUrl = function(e3, t3) {
      return p2(`${s2(e3)}/${s2(t3.type)}.ngfactory.js`);
    };
  }), B$1 = t$1(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true });
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    class n2 {
      constructor(e3, t3, r2, n3) {
        this.file = e3, this.offset = t3, this.line = r2, this.col = n3;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(e3) {
        const t3 = this.file.content, i3 = t3.length;
        let s3 = this.offset, o3 = this.line, a2 = this.col;
        for (; s3 > 0 && e3 < 0; ) {
          s3--, e3++;
          if (t3.charCodeAt(s3) == r$1.$LF) {
            o3--;
            const e4 = t3.substr(0, s3 - 1).lastIndexOf(String.fromCharCode(r$1.$LF));
            a2 = e4 > 0 ? s3 - e4 : s3;
          } else
            a2--;
        }
        for (; s3 < i3 && e3 > 0; ) {
          const n3 = t3.charCodeAt(s3);
          s3++, e3--, n3 == r$1.$LF ? (o3++, a2 = 0) : a2++;
        }
        return new n2(this.file, s3, o3, a2);
      }
      getContext(e3, t3) {
        const r2 = this.file.content;
        let n3 = this.offset;
        if (n3 != null) {
          n3 > r2.length - 1 && (n3 = r2.length - 1);
          let i3 = n3, s3 = 0, o3 = 0;
          for (; s3 < e3 && n3 > 0 && (n3--, s3++, r2[n3] != "\n" || ++o3 != t3); )
            ;
          for (s3 = 0, o3 = 0; s3 < e3 && i3 < r2.length - 1 && (i3++, s3++, r2[i3] != "\n" || ++o3 != t3); )
            ;
          return { before: r2.substring(n3, this.offset), after: r2.substring(this.offset, i3 + 1) };
        }
        return null;
      }
    }
    t2.ParseLocation = n2;
    class i2 {
      constructor(e3, t3) {
        this.content = e3, this.url = t3;
      }
    }
    t2.ParseSourceFile = i2;
    class s2 {
      constructor(e3, t3, r2 = null) {
        this.start = e3, this.end = t3, this.details = r2;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    }
    var o2;
    t2.ParseSourceSpan = s2, t2.EMPTY_PARSE_LOCATION = new n2(new i2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new s2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e3) {
      e3[e3.WARNING = 0] = "WARNING", e3[e3.ERROR = 1] = "ERROR";
    }(o2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
    t2.ParseError = class {
      constructor(e3, t3, r2 = o2.ERROR) {
        this.span = e3, this.msg = t3, this.level = r2;
      }
      contextualMessage() {
        const e3 = this.span.start.getContext(100, 3);
        return e3 ? `${this.msg} ("${e3.before}[${o2[this.level]} ->]${e3.after}")` : this.msg;
      }
      toString() {
        const e3 = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${e3}`;
      }
    }, t2.typeSourceSpan = function(e3, t3) {
      const r2 = L$1.identifierModuleUrl(t3), o3 = r2 != null ? `in ${e3} ${L$1.identifierName(t3)} in ${r2}` : `in ${e3} ${L$1.identifierName(t3)}`, a2 = new i2("", o3);
      return new s2(new n2(a2, -1, -1, -1), new n2(a2, -1, -1, -1));
    }, t2.r3JitTypeSourceSpan = function(e3, t3, r2) {
      const o3 = new i2("", `in ${e3} ${t3} in ${r2}`);
      return new s2(new n2(o3, -1, -1, -1), new n2(o3, -1, -1, -1));
    };
  });
  const $$1 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  var q$1 = function(e2) {
    const t2 = e2.match($$1);
    if (!t2)
      return { content: e2 };
    const { startDelimiter: r2, language: n2, value: i2 = "", endDelimiter: s2 } = t2.groups;
    let o2 = n2.trim() || "yaml";
    if (r2 === "+++" && (o2 = "toml"), o2 !== "yaml" && r2 !== s2)
      return { content: e2 };
    const [a2] = t2;
    return { frontMatter: { type: "front-matter", lang: o2, value: i2, startDelimiter: r2, endDelimiter: s2, raw: a2.replace(/\n$/, "") }, content: a2.replace(/[^\n]/g, " ") + e2.slice(a2.length) };
  };
  var M$1 = (e2) => e2[e2.length - 1];
  var j$2 = function(e2, t2) {
    const r2 = new SyntaxError(e2 + " (" + t2.start.line + ":" + t2.start.column + ")");
    return r2.loc = t2, r2;
  }, U$1 = (e2) => typeof e2 == "string" ? e2.replace((({ onlyFirst: e3 = false } = {}) => {
    const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(t2, e3 ? void 0 : "g");
  })(), "") : e2;
  const G$1 = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
  var V$1 = G$1, H$1 = G$1;
  V$1.default = H$1;
  const X$1 = (e2) => {
    if (typeof e2 != "string" || e2.length === 0)
      return 0;
    if ((e2 = U$1(e2)).length === 0)
      return 0;
    e2 = e2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
    let t2 = 0;
    for (let r2 = 0; r2 < e2.length; r2++) {
      const n2 = e2.codePointAt(r2);
      n2 <= 31 || n2 >= 127 && n2 <= 159 || (n2 >= 768 && n2 <= 879 || (n2 > 65535 && r2++, t2 += V$1(n2) ? 2 : 1));
    }
    return t2;
  };
  var z$1 = X$1, W$1 = X$1;
  z$1.default = W$1;
  var Y$1 = (e2) => {
    if (typeof e2 != "string")
      throw new TypeError("Expected a string");
    return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  function Q$1(e2, t2) {
    if (e2 == null)
      return {};
    var r2, n2, i2 = function(e3, t3) {
      if (e3 == null)
        return {};
      var r3, n3, i3 = {}, s3 = Object.keys(e3);
      for (n3 = 0; n3 < s3.length; n3++)
        r3 = s3[n3], t3.indexOf(r3) >= 0 || (i3[r3] = e3[r3]);
      return i3;
    }(e2, t2);
    if (Object.getOwnPropertySymbols) {
      var s2 = Object.getOwnPropertySymbols(e2);
      for (n2 = 0; n2 < s2.length; n2++)
        r2 = s2[n2], t2.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, r2) && (i2[r2] = e2[r2]);
    }
    return i2;
  }
  var J$1, K$1, Z$1 = function(e2) {
    return e2 && e2.Math == Math && e2;
  }, ee$1 = Z$1(typeof globalThis == "object" && globalThis) || Z$1(typeof window == "object" && window) || Z$1(typeof self == "object" && self) || Z$1(typeof e$1 == "object" && e$1) || function() {
    return this;
  }() || Function("return this")(), te$1 = function(e2) {
    try {
      return !!e2();
    } catch (e3) {
      return true;
    }
  }, re$1 = !te$1(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  }), ne$1 = {}.propertyIsEnumerable, ie$1 = Object.getOwnPropertyDescriptor, se$1 = { f: ie$1 && !ne$1.call({ 1: 2 }, 1) ? function(e2) {
    var t2 = ie$1(this, e2);
    return !!t2 && t2.enumerable;
  } : ne$1 }, oe$1 = function(e2, t2) {
    return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
  }, ae$1 = {}.toString, ue$1 = function(e2) {
    return ae$1.call(e2).slice(8, -1);
  }, ce$1 = "".split, le$1 = te$1(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e2) {
    return ue$1(e2) == "String" ? ce$1.call(e2, "") : Object(e2);
  } : Object, pe$1 = function(e2) {
    if (e2 == null)
      throw TypeError("Can't call method on " + e2);
    return e2;
  }, he$1 = function(e2) {
    return le$1(pe$1(e2));
  }, De$1 = function(e2) {
    return typeof e2 == "object" ? e2 !== null : typeof e2 == "function";
  }, fe$1 = function(e2) {
    return typeof e2 == "function" ? e2 : void 0;
  }, de$1 = function(e2, t2) {
    return arguments.length < 2 ? fe$1(ee$1[e2]) : ee$1[e2] && ee$1[e2][t2];
  }, ge$1 = de$1("navigator", "userAgent") || "", me$1 = ee$1.process, Ee$1 = ee$1.Deno, Ce$1 = me$1 && me$1.versions || Ee$1 && Ee$1.version, ye$1 = Ce$1 && Ce$1.v8;
  ye$1 ? K$1 = (J$1 = ye$1.split("."))[0] < 4 ? 1 : J$1[0] + J$1[1] : ge$1 && (!(J$1 = ge$1.match(/Edge\/(\d+)/)) || J$1[1] >= 74) && (J$1 = ge$1.match(/Chrome\/(\d+)/)) && (K$1 = J$1[1]);
  var be$1 = K$1 && +K$1, Se$1 = !!Object.getOwnPropertySymbols && !te$1(function() {
    var e2 = Symbol();
    return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && be$1 && be$1 < 41;
  }), Te$1 = Se$1 && !Symbol.sham && typeof Symbol.iterator == "symbol", _e$1 = Te$1 ? function(e2) {
    return typeof e2 == "symbol";
  } : function(e2) {
    var t2 = de$1("Symbol");
    return typeof t2 == "function" && Object(e2) instanceof t2;
  }, ve$1 = function(e2, t2) {
    try {
      Object.defineProperty(ee$1, e2, { value: t2, configurable: true, writable: true });
    } catch (r2) {
      ee$1[e2] = t2;
    }
    return t2;
  }, Ae$1 = ee$1["__core-js_shared__"] || ve$1("__core-js_shared__", {}), Fe$1 = t$1(function(e2) {
    (e2.exports = function(e3, t2) {
      return Ae$1[e3] || (Ae$1[e3] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({ version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
  }), we$1 = function(e2) {
    return Object(pe$1(e2));
  }, ke$1 = {}.hasOwnProperty, Ne$1 = Object.hasOwn || function(e2, t2) {
    return ke$1.call(we$1(e2), t2);
  }, Oe$1 = 0, xe$1 = Math.random(), Ie$1 = function(e2) {
    return "Symbol(" + String(e2 === void 0 ? "" : e2) + ")_" + (++Oe$1 + xe$1).toString(36);
  }, Pe$1 = Fe$1("wks"), Re$1 = ee$1.Symbol, Le$1 = Te$1 ? Re$1 : Re$1 && Re$1.withoutSetter || Ie$1, Be$1 = function(e2) {
    return Ne$1(Pe$1, e2) && (Se$1 || typeof Pe$1[e2] == "string") || (Se$1 && Ne$1(Re$1, e2) ? Pe$1[e2] = Re$1[e2] : Pe$1[e2] = Le$1("Symbol." + e2)), Pe$1[e2];
  }, $e$1 = Be$1("toPrimitive"), qe$1 = function(e2, t2) {
    if (!De$1(e2) || _e$1(e2))
      return e2;
    var r2, n2 = e2[$e$1];
    if (n2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e2, t2), !De$1(r2) || _e$1(r2))
        return r2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e3, t3) {
      var r3, n3;
      if (t3 === "string" && typeof (r3 = e3.toString) == "function" && !De$1(n3 = r3.call(e3)))
        return n3;
      if (typeof (r3 = e3.valueOf) == "function" && !De$1(n3 = r3.call(e3)))
        return n3;
      if (t3 !== "string" && typeof (r3 = e3.toString) == "function" && !De$1(n3 = r3.call(e3)))
        return n3;
      throw TypeError("Can't convert object to primitive value");
    }(e2, t2);
  }, Me$1 = function(e2) {
    var t2 = qe$1(e2, "string");
    return _e$1(t2) ? t2 : String(t2);
  }, je$1 = ee$1.document, Ue$1 = De$1(je$1) && De$1(je$1.createElement), Ge$1 = !re$1 && !te$1(function() {
    return Object.defineProperty((e2 = "div", Ue$1 ? je$1.createElement(e2) : {}), "a", { get: function() {
      return 7;
    } }).a != 7;
    var e2;
  }), Ve$1 = Object.getOwnPropertyDescriptor, He$1 = { f: re$1 ? Ve$1 : function(e2, t2) {
    if (e2 = he$1(e2), t2 = Me$1(t2), Ge$1)
      try {
        return Ve$1(e2, t2);
      } catch (e3) {
      }
    if (Ne$1(e2, t2))
      return oe$1(!se$1.f.call(e2, t2), e2[t2]);
  } }, Xe$1 = function(e2) {
    if (!De$1(e2))
      throw TypeError(String(e2) + " is not an object");
    return e2;
  }, ze$1 = Object.defineProperty, We$1 = { f: re$1 ? ze$1 : function(e2, t2, r2) {
    if (Xe$1(e2), t2 = Me$1(t2), Xe$1(r2), Ge$1)
      try {
        return ze$1(e2, t2, r2);
      } catch (e3) {
      }
    if ("get" in r2 || "set" in r2)
      throw TypeError("Accessors not supported");
    return "value" in r2 && (e2[t2] = r2.value), e2;
  } }, Ye$1 = re$1 ? function(e2, t2, r2) {
    return We$1.f(e2, t2, oe$1(1, r2));
  } : function(e2, t2, r2) {
    return e2[t2] = r2, e2;
  }, Qe$1 = Function.toString;
  typeof Ae$1.inspectSource != "function" && (Ae$1.inspectSource = function(e2) {
    return Qe$1.call(e2);
  });
  var Je$1, Ke$1, Ze$1, et$1, tt$1 = Ae$1.inspectSource, rt$1 = ee$1.WeakMap, nt$1 = typeof rt$1 == "function" && /native code/.test(tt$1(rt$1)), it$1 = Fe$1("keys"), st$1 = {}, ot$1 = ee$1.WeakMap;
  if (nt$1 || Ae$1.state) {
    var at$1 = Ae$1.state || (Ae$1.state = new ot$1()), ut$1 = at$1.get, ct$1 = at$1.has, lt$1 = at$1.set;
    Je$1 = function(e2, t2) {
      if (ct$1.call(at$1, e2))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, lt$1.call(at$1, e2, t2), t2;
    }, Ke$1 = function(e2) {
      return ut$1.call(at$1, e2) || {};
    }, Ze$1 = function(e2) {
      return ct$1.call(at$1, e2);
    };
  } else {
    var pt$1 = it$1[et$1 = "state"] || (it$1[et$1] = Ie$1(et$1));
    st$1[pt$1] = true, Je$1 = function(e2, t2) {
      if (Ne$1(e2, pt$1))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, Ye$1(e2, pt$1, t2), t2;
    }, Ke$1 = function(e2) {
      return Ne$1(e2, pt$1) ? e2[pt$1] : {};
    }, Ze$1 = function(e2) {
      return Ne$1(e2, pt$1);
    };
  }
  var ht$1 = { set: Je$1, get: Ke$1, has: Ze$1, enforce: function(e2) {
    return Ze$1(e2) ? Ke$1(e2) : Je$1(e2, {});
  }, getterFor: function(e2) {
    return function(t2) {
      var r2;
      if (!De$1(t2) || (r2 = Ke$1(t2)).type !== e2)
        throw TypeError("Incompatible receiver, " + e2 + " required");
      return r2;
    };
  } }, Dt$1 = t$1(function(e2) {
    var t2 = ht$1.get, r2 = ht$1.enforce, n2 = String(String).split("String");
    (e2.exports = function(e3, t3, i2, s2) {
      var o2, a2 = !!s2 && !!s2.unsafe, u2 = !!s2 && !!s2.enumerable, c2 = !!s2 && !!s2.noTargetGet;
      typeof i2 == "function" && (typeof t3 != "string" || Ne$1(i2, "name") || Ye$1(i2, "name", t3), (o2 = r2(i2)).source || (o2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e3 !== ee$1 ? (a2 ? !c2 && e3[t3] && (u2 = true) : delete e3[t3], u2 ? e3[t3] = i2 : Ye$1(e3, t3, i2)) : u2 ? e3[t3] = i2 : ve$1(t3, i2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || tt$1(this);
    });
  }), ft$1 = Math.ceil, dt$1 = Math.floor, gt$1 = function(e2) {
    return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? dt$1 : ft$1)(e2);
  }, mt$1 = Math.min, Et$1 = function(e2) {
    return e2 > 0 ? mt$1(gt$1(e2), 9007199254740991) : 0;
  }, Ct$1 = Math.max, yt$1 = Math.min, bt$1 = function(e2) {
    return function(t2, r2, n2) {
      var i2, s2 = he$1(t2), o2 = Et$1(s2.length), a2 = function(e3, t3) {
        var r3 = gt$1(e3);
        return r3 < 0 ? Ct$1(r3 + t3, 0) : yt$1(r3, t3);
      }(n2, o2);
      if (e2 && r2 != r2) {
        for (; o2 > a2; )
          if ((i2 = s2[a2++]) != i2)
            return true;
      } else
        for (; o2 > a2; a2++)
          if ((e2 || a2 in s2) && s2[a2] === r2)
            return e2 || a2 || 0;
      return !e2 && -1;
    };
  }, St = { includes: bt$1(true), indexOf: bt$1(false) }.indexOf, Tt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), _t = { f: Object.getOwnPropertyNames || function(e2) {
    return function(e3, t2) {
      var r2, n2 = he$1(e3), i2 = 0, s2 = [];
      for (r2 in n2)
        !Ne$1(st$1, r2) && Ne$1(n2, r2) && s2.push(r2);
      for (; t2.length > i2; )
        Ne$1(n2, r2 = t2[i2++]) && (~St(s2, r2) || s2.push(r2));
      return s2;
    }(e2, Tt);
  } }, vt$1 = { f: Object.getOwnPropertySymbols }, At$1 = de$1("Reflect", "ownKeys") || function(e2) {
    var t2 = _t.f(Xe$1(e2)), r2 = vt$1.f;
    return r2 ? t2.concat(r2(e2)) : t2;
  }, Ft$1 = function(e2, t2) {
    for (var r2 = At$1(t2), n2 = We$1.f, i2 = He$1.f, s2 = 0; s2 < r2.length; s2++) {
      var o2 = r2[s2];
      Ne$1(e2, o2) || n2(e2, o2, i2(t2, o2));
    }
  }, wt$1 = /#|\.prototype\./, kt$1 = function(e2, t2) {
    var r2 = Ot$1[Nt(e2)];
    return r2 == It || r2 != xt$1 && (typeof t2 == "function" ? te$1(t2) : !!t2);
  }, Nt = kt$1.normalize = function(e2) {
    return String(e2).replace(wt$1, ".").toLowerCase();
  }, Ot$1 = kt$1.data = {}, xt$1 = kt$1.NATIVE = "N", It = kt$1.POLYFILL = "P", Pt = kt$1, Rt = He$1.f, Lt = function(e2, t2) {
    var r2, n2, i2, s2, o2, a2 = e2.target, u2 = e2.global, c2 = e2.stat;
    if (r2 = u2 ? ee$1 : c2 ? ee$1[a2] || ve$1(a2, {}) : (ee$1[a2] || {}).prototype)
      for (n2 in t2) {
        if (s2 = t2[n2], i2 = e2.noTargetGet ? (o2 = Rt(r2, n2)) && o2.value : r2[n2], !Pt(u2 ? n2 : a2 + (c2 ? "." : "#") + n2, e2.forced) && i2 !== void 0) {
          if (typeof s2 == typeof i2)
            continue;
          Ft$1(s2, i2);
        }
        (e2.sham || i2 && i2.sham) && Ye$1(s2, "sham", true), Dt$1(r2, n2, s2, e2);
      }
  }, Bt = Array.isArray || function(e2) {
    return ue$1(e2) == "Array";
  }, $t = function(e2) {
    if (typeof e2 != "function")
      throw TypeError(String(e2) + " is not a function");
    return e2;
  }, qt = function(e2, t2, r2) {
    if ($t(e2), t2 === void 0)
      return e2;
    switch (r2) {
      case 0:
        return function() {
          return e2.call(t2);
        };
      case 1:
        return function(r3) {
          return e2.call(t2, r3);
        };
      case 2:
        return function(r3, n2) {
          return e2.call(t2, r3, n2);
        };
      case 3:
        return function(r3, n2, i2) {
          return e2.call(t2, r3, n2, i2);
        };
    }
    return function() {
      return e2.apply(t2, arguments);
    };
  }, Mt = function(e2, t2, r2, n2, i2, s2, o2, a2) {
    for (var u2, c2 = i2, l2 = 0, p2 = !!o2 && qt(o2, a2, 3); l2 < n2; ) {
      if (l2 in r2) {
        if (u2 = p2 ? p2(r2[l2], l2, t2) : r2[l2], s2 > 0 && Bt(u2))
          c2 = Mt(e2, t2, u2, Et$1(u2.length), c2, s2 - 1) - 1;
        else {
          if (c2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e2[c2] = u2;
        }
        c2++;
      }
      l2++;
    }
    return c2;
  }, jt = Mt, Ut = Be$1("species"), Gt = function(e2, t2) {
    return new (function(e3) {
      var t3;
      return Bt(e3) && (typeof (t3 = e3.constructor) != "function" || t3 !== Array && !Bt(t3.prototype) ? De$1(t3) && (t3 = t3[Ut]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e2))(t2 === 0 ? 0 : t2);
  };
  Lt({ target: "Array", proto: true }, { flatMap: function(e2) {
    var t2, r2 = we$1(this), n2 = Et$1(r2.length);
    return $t(e2), (t2 = Gt(r2, 0)).length = jt(t2, r2, r2, n2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t2;
  } });
  var Vt, Ht, Xt = function(e2) {
    if (_e$1(e2))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e2);
  }, zt = Math.floor, Wt = function(e2, t2) {
    var r2 = e2.length, n2 = zt(r2 / 2);
    return r2 < 8 ? Yt(e2, t2) : Qt(Wt(e2.slice(0, n2), t2), Wt(e2.slice(n2), t2), t2);
  }, Yt = function(e2, t2) {
    for (var r2, n2, i2 = e2.length, s2 = 1; s2 < i2; ) {
      for (n2 = s2, r2 = e2[s2]; n2 && t2(e2[n2 - 1], r2) > 0; )
        e2[n2] = e2[--n2];
      n2 !== s2++ && (e2[n2] = r2);
    }
    return e2;
  }, Qt = function(e2, t2, r2) {
    for (var n2 = e2.length, i2 = t2.length, s2 = 0, o2 = 0, a2 = []; s2 < n2 || o2 < i2; )
      s2 < n2 && o2 < i2 ? a2.push(r2(e2[s2], t2[o2]) <= 0 ? e2[s2++] : t2[o2++]) : a2.push(s2 < n2 ? e2[s2++] : t2[o2++]);
    return a2;
  }, Jt = Wt, Kt = ge$1.match(/firefox\/(\d+)/i), Zt = !!Kt && +Kt[1], er = /MSIE|Trident/.test(ge$1), tr = ge$1.match(/AppleWebKit\/(\d+)\./), rr = !!tr && +tr[1], nr = [], ir = nr.sort, sr = te$1(function() {
    nr.sort(void 0);
  }), or = te$1(function() {
    nr.sort(null);
  }), ar = !!(Ht = []["sort"]) && te$1(function() {
    Ht.call(null, Vt || function() {
      throw 1;
    }, 1);
  }), ur = !te$1(function() {
    if (be$1)
      return be$1 < 70;
    if (!(Zt && Zt > 3)) {
      if (er)
        return true;
      if (rr)
        return rr < 603;
      var e2, t2, r2, n2, i2 = "";
      for (e2 = 65; e2 < 76; e2++) {
        switch (t2 = String.fromCharCode(e2), e2) {
          case 66:
          case 69:
          case 70:
          case 72:
            r2 = 3;
            break;
          case 68:
          case 71:
            r2 = 4;
            break;
          default:
            r2 = 2;
        }
        for (n2 = 0; n2 < 47; n2++)
          nr.push({ k: t2 + n2, v: r2 });
      }
      for (nr.sort(function(e3, t3) {
        return t3.v - e3.v;
      }), n2 = 0; n2 < nr.length; n2++)
        t2 = nr[n2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
      return i2 !== "DGBEFHACIJK";
    }
  });
  Lt({ target: "Array", proto: true, forced: sr || !or || !ar || !ur }, { sort: function(e2) {
    e2 !== void 0 && $t(e2);
    var t2 = we$1(this);
    if (ur)
      return e2 === void 0 ? ir.call(t2) : ir.call(t2, e2);
    var r2, n2, i2 = [], s2 = Et$1(t2.length);
    for (n2 = 0; n2 < s2; n2++)
      n2 in t2 && i2.push(t2[n2]);
    for (r2 = (i2 = Jt(i2, function(e3) {
      return function(t3, r3) {
        return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, r3) || 0 : Xt(t3) > Xt(r3) ? 1 : -1;
      };
    }(e2))).length, n2 = 0; n2 < r2; )
      t2[n2] = i2[n2++];
    for (; n2 < s2; )
      delete t2[n2++];
    return t2;
  } });
  var cr = {}, lr = Be$1("iterator"), pr = Array.prototype, hr = {};
  hr[Be$1("toStringTag")] = "z";
  var Dr = String(hr) === "[object z]", fr = Be$1("toStringTag"), dr = ue$1(function() {
    return arguments;
  }()) == "Arguments", gr = Dr ? ue$1 : function(e2) {
    var t2, r2, n2;
    return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (r2 = function(e3, t3) {
      try {
        return e3[t3];
      } catch (e4) {
      }
    }(t2 = Object(e2), fr)) == "string" ? r2 : dr ? ue$1(t2) : (n2 = ue$1(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
  }, mr = Be$1("iterator"), Er = function(e2) {
    if (e2 != null)
      return e2[mr] || e2["@@iterator"] || cr[gr(e2)];
  }, Cr = function(e2, t2, r2) {
    var n2, i2;
    Xe$1(e2);
    try {
      if ((n2 = e2.return) === void 0) {
        if (t2 === "throw")
          throw r2;
        return r2;
      }
      n2 = n2.call(e2);
    } catch (e3) {
      i2 = true, n2 = e3;
    }
    if (t2 === "throw")
      throw r2;
    if (i2)
      throw n2;
    return Xe$1(n2), r2;
  }, yr = function(e2, t2) {
    this.stopped = e2, this.result = t2;
  }, br = function(e2, t2, r2) {
    var n2, i2, s2, o2, a2, u2, c2, l2, p2 = r2 && r2.that, h2 = !(!r2 || !r2.AS_ENTRIES), D2 = !(!r2 || !r2.IS_ITERATOR), f2 = !(!r2 || !r2.INTERRUPTED), d2 = qt(t2, p2, 1 + h2 + f2), g2 = function(e3) {
      return n2 && Cr(n2, "normal", e3), new yr(true, e3);
    }, m2 = function(e3) {
      return h2 ? (Xe$1(e3), f2 ? d2(e3[0], e3[1], g2) : d2(e3[0], e3[1])) : f2 ? d2(e3, g2) : d2(e3);
    };
    if (D2)
      n2 = e2;
    else {
      if (typeof (i2 = Er(e2)) != "function")
        throw TypeError("Target is not iterable");
      if ((l2 = i2) !== void 0 && (cr.Array === l2 || pr[lr] === l2)) {
        for (s2 = 0, o2 = Et$1(e2.length); o2 > s2; s2++)
          if ((a2 = m2(e2[s2])) && a2 instanceof yr)
            return a2;
        return new yr(false);
      }
      n2 = function(e3, t3) {
        var r3 = arguments.length < 2 ? Er(e3) : t3;
        if (typeof r3 != "function")
          throw TypeError(String(e3) + " is not iterable");
        return Xe$1(r3.call(e3));
      }(e2, i2);
    }
    for (u2 = n2.next; !(c2 = u2.call(n2)).done; ) {
      try {
        a2 = m2(c2.value);
      } catch (e3) {
        Cr(n2, "throw", e3);
      }
      if (typeof a2 == "object" && a2 && a2 instanceof yr)
        return a2;
    }
    return new yr(false);
  };
  Lt({ target: "Object", stat: true }, { fromEntries: function(e2) {
    var t2 = {};
    return br(e2, function(e3, r2) {
      !function(e4, t3, r3) {
        var n2 = Me$1(t3);
        n2 in e4 ? We$1.f(e4, n2, oe$1(0, r3)) : e4[n2] = r3;
      }(t2, e3, r2);
    }, { AS_ENTRIES: true }), t2;
  } });
  var Sr = Sr !== void 0 ? Sr : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
  function Tr() {
    throw new Error("setTimeout has not been defined");
  }
  function _r() {
    throw new Error("clearTimeout has not been defined");
  }
  var vr = Tr, Ar = _r;
  function Fr(e2) {
    if (vr === setTimeout)
      return setTimeout(e2, 0);
    if ((vr === Tr || !vr) && setTimeout)
      return vr = setTimeout, setTimeout(e2, 0);
    try {
      return vr(e2, 0);
    } catch (t2) {
      try {
        return vr.call(null, e2, 0);
      } catch (t3) {
        return vr.call(this, e2, 0);
      }
    }
  }
  typeof Sr.setTimeout == "function" && (vr = setTimeout), typeof Sr.clearTimeout == "function" && (Ar = clearTimeout);
  var wr, kr = [], Nr = false, Or = -1;
  function xr() {
    Nr && wr && (Nr = false, wr.length ? kr = wr.concat(kr) : Or = -1, kr.length && Ir());
  }
  function Ir() {
    if (!Nr) {
      var e2 = Fr(xr);
      Nr = true;
      for (var t2 = kr.length; t2; ) {
        for (wr = kr, kr = []; ++Or < t2; )
          wr && wr[Or].run();
        Or = -1, t2 = kr.length;
      }
      wr = null, Nr = false, function(e3) {
        if (Ar === clearTimeout)
          return clearTimeout(e3);
        if ((Ar === _r || !Ar) && clearTimeout)
          return Ar = clearTimeout, clearTimeout(e3);
        try {
          Ar(e3);
        } catch (t3) {
          try {
            return Ar.call(null, e3);
          } catch (t4) {
            return Ar.call(this, e3);
          }
        }
      }(e2);
    }
  }
  function Pr(e2, t2) {
    this.fun = e2, this.array = t2;
  }
  Pr.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  function Rr() {
  }
  var Lr = Rr, Br = Rr, $r = Rr, qr = Rr, Mr = Rr, jr = Rr, Ur = Rr;
  var Gr = Sr.performance || {}, Vr = Gr.now || Gr.mozNow || Gr.msNow || Gr.oNow || Gr.webkitNow || function() {
    return new Date().getTime();
  };
  var Hr = new Date();
  var Xr = { nextTick: function(e2) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r2 = 1; r2 < arguments.length; r2++)
        t2[r2 - 1] = arguments[r2];
    kr.push(new Pr(e2, t2)), kr.length !== 1 || Nr || Fr(Ir);
  }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Lr, addListener: Br, once: $r, off: qr, removeListener: Mr, removeAllListeners: jr, emit: Ur, binding: function(e2) {
    throw new Error("process.binding is not supported");
  }, cwd: function() {
    return "/";
  }, chdir: function(e2) {
    throw new Error("process.chdir is not supported");
  }, umask: function() {
    return 0;
  }, hrtime: function(e2) {
    var t2 = 1e-3 * Vr.call(Gr), r2 = Math.floor(t2), n2 = Math.floor(t2 % 1 * 1e9);
    return e2 && (r2 -= e2[0], (n2 -= e2[1]) < 0 && (r2--, n2 += 1e9)), [r2, n2];
  }, platform: "browser", release: {}, config: {}, uptime: function() {
    return (new Date() - Hr) / 1e3;
  } };
  var zr = typeof Xr == "object" && Xr.env && Xr.env.NODE_DEBUG && /\bsemver\b/i.test(Xr.env.NODE_DEBUG) ? (...e2) => console.error("SEMVER", ...e2) : () => {
  };
  var Wr = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, Yr = t$1(function(e2, t2) {
    const { MAX_SAFE_COMPONENT_LENGTH: r2 } = Wr, n2 = (t2 = e2.exports = {}).re = [], i2 = t2.src = [], s2 = t2.t = {};
    let o2 = 0;
    const a2 = (e3, t3, r3) => {
      const a3 = o2++;
      zr(a3, t3), s2[e3] = a3, i2[a3] = t3, n2[a3] = new RegExp(t3, r3 ? "g" : void 0);
    };
    a2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a2("MAINVERSION", `(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})`), a2("MAINVERSIONLOOSE", `(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})`), a2("PRERELEASEIDENTIFIER", `(?:${i2[s2.NUMERICIDENTIFIER]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[s2.NUMERICIDENTIFIERLOOSE]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASE", `(?:-(${i2[s2.PRERELEASEIDENTIFIER]}(?:\\.${i2[s2.PRERELEASEIDENTIFIER]})*))`), a2("PRERELEASELOOSE", `(?:-?(${i2[s2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[s2.PRERELEASEIDENTIFIERLOOSE]})*))`), a2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a2("BUILD", `(?:\\+(${i2[s2.BUILDIDENTIFIER]}(?:\\.${i2[s2.BUILDIDENTIFIER]})*))`), a2("FULLPLAIN", `v?${i2[s2.MAINVERSION]}${i2[s2.PRERELEASE]}?${i2[s2.BUILD]}?`), a2("FULL", `^${i2[s2.FULLPLAIN]}$`), a2("LOOSEPLAIN", `[v=\\s]*${i2[s2.MAINVERSIONLOOSE]}${i2[s2.PRERELEASELOOSE]}?${i2[s2.BUILD]}?`), a2("LOOSE", `^${i2[s2.LOOSEPLAIN]}$`), a2("GTLT", "((?:<|>)?=?)"), a2("XRANGEIDENTIFIERLOOSE", `${i2[s2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a2("XRANGEIDENTIFIER", `${i2[s2.NUMERICIDENTIFIER]}|x|X|\\*`), a2("XRANGEPLAIN", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:${i2[s2.PRERELEASE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:${i2[s2.PRERELEASELOOSE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAIN]}$`), a2("XRANGELOOSE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COERCE", `(^|[^\\d])(\\d{1,${r2}})(?:\\.(\\d{1,${r2}}))?(?:\\.(\\d{1,${r2}}))?(?:$|[^\\d])`), a2("COERCERTL", i2[s2.COERCE], true), a2("LONETILDE", "(?:~>?)"), a2("TILDETRIM", `(\\s*)${i2[s2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", a2("TILDE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAIN]}$`), a2("TILDELOOSE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("LONECARET", "(?:\\^)"), a2("CARETTRIM", `(\\s*)${i2[s2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", a2("CARET", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAIN]}$`), a2("CARETLOOSE", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COMPARATORLOOSE", `^${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]})$|^$`), a2("COMPARATOR", `^${i2[s2.GTLT]}\\s*(${i2[s2.FULLPLAIN]})$|^$`), a2("COMPARATORTRIM", `(\\s*)${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]}|${i2[s2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", a2("HYPHENRANGE", `^\\s*(${i2[s2.XRANGEPLAIN]})\\s+-\\s+(${i2[s2.XRANGEPLAIN]})\\s*$`), a2("HYPHENRANGELOOSE", `^\\s*(${i2[s2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[s2.XRANGEPLAINLOOSE]})\\s*$`), a2("STAR", "(<|>)?=?\\s*\\*"), a2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });
  const Qr = ["includePrerelease", "loose", "rtl"];
  var Jr = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : Qr.filter((t2) => e2[t2]).reduce((e3, t2) => (e3[t2] = true, e3), {}) : {};
  const Kr = /^[0-9]+$/, Zr = (e2, t2) => {
    const r2 = Kr.test(e2), n2 = Kr.test(t2);
    return r2 && n2 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : r2 && !n2 ? -1 : n2 && !r2 ? 1 : e2 < t2 ? -1 : 1;
  };
  var en = { compareIdentifiers: Zr, rcompareIdentifiers: (e2, t2) => Zr(t2, e2) };
  const { MAX_LENGTH: tn, MAX_SAFE_INTEGER: rn } = Wr, { re: nn, t: sn } = Yr, { compareIdentifiers: on } = en;
  class an {
    constructor(e2, t2) {
      if (t2 = Jr(t2), e2 instanceof an) {
        if (e2.loose === !!t2.loose && e2.includePrerelease === !!t2.includePrerelease)
          return e2;
        e2 = e2.version;
      } else if (typeof e2 != "string")
        throw new TypeError(`Invalid Version: ${e2}`);
      if (e2.length > tn)
        throw new TypeError(`version is longer than ${tn} characters`);
      zr("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
      const r2 = e2.trim().match(t2.loose ? nn[sn.LOOSE] : nn[sn.FULL]);
      if (!r2)
        throw new TypeError(`Invalid Version: ${e2}`);
      if (this.raw = e2, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > rn || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > rn || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > rn || this.patch < 0)
        throw new TypeError("Invalid patch version");
      r2[4] ? this.prerelease = r2[4].split(".").map((e3) => {
        if (/^[0-9]+$/.test(e3)) {
          const t3 = +e3;
          if (t3 >= 0 && t3 < rn)
            return t3;
        }
        return e3;
      }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e2) {
      if (zr("SemVer.compare", this.version, this.options, e2), !(e2 instanceof an)) {
        if (typeof e2 == "string" && e2 === this.version)
          return 0;
        e2 = new an(e2, this.options);
      }
      return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
    }
    compareMain(e2) {
      return e2 instanceof an || (e2 = new an(e2, this.options)), on(this.major, e2.major) || on(this.minor, e2.minor) || on(this.patch, e2.patch);
    }
    comparePre(e2) {
      if (e2 instanceof an || (e2 = new an(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
        return -1;
      if (!this.prerelease.length && e2.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e2.prerelease.length)
        return 0;
      let t2 = 0;
      do {
        const r2 = this.prerelease[t2], n2 = e2.prerelease[t2];
        if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
          return 0;
        if (n2 === void 0)
          return 1;
        if (r2 === void 0)
          return -1;
        if (r2 !== n2)
          return on(r2, n2);
      } while (++t2);
    }
    compareBuild(e2) {
      e2 instanceof an || (e2 = new an(e2, this.options));
      let t2 = 0;
      do {
        const r2 = this.build[t2], n2 = e2.build[t2];
        if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
          return 0;
        if (n2 === void 0)
          return 1;
        if (r2 === void 0)
          return -1;
        if (r2 !== n2)
          return on(r2, n2);
      } while (++t2);
    }
    inc(e2, t2) {
      switch (e2) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "major":
          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let e3 = this.prerelease.length;
            for (; --e3 >= 0; )
              typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
            e3 === -1 && this.prerelease.push(0);
          }
          t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${e2}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  var un = an;
  var cn = (e2, t2, r2) => new un(e2, r2).compare(new un(t2, r2));
  var ln = (e2, t2, r2) => cn(e2, t2, r2) < 0;
  var pn = (e2, t2, r2) => cn(e2, t2, r2) >= 0, hn = t$1(function(e2, t2) {
    function r2() {
      for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
        e3[t3] = arguments[t3];
    }
    function n2() {
      return typeof WeakMap != "undefined" ? new WeakMap() : { add: r2, delete: r2, get: r2, set: r2, has: function(e3) {
        return false;
      } };
    }
    Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
    var i2 = Object.prototype.hasOwnProperty, s2 = function(e3, t3) {
      return i2.call(e3, t3);
    };
    function o2(e3, t3) {
      for (var r3 in t3)
        s2(t3, r3) && (e3[r3] = t3[r3]);
      return e3;
    }
    var a2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function h2(e3, t3, r3) {
      var n3 = 0, i3 = e3[0].match(l2);
      i3 && (n3 = i3[1].length);
      var s3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
      t3 && (e3 = e3.slice(1));
      var o3 = r3.newline, c3 = r3.trimLeadingNewline, p3 = r3.trimTrailingNewline, h3 = typeof o3 == "string", D3 = e3.length;
      return e3.map(function(e4, t4) {
        return e4 = e4.replace(s3, "$1"), t4 === 0 && c3 && (e4 = e4.replace(a2, "")), t4 === D3 - 1 && p3 && (e4 = e4.replace(u2, "")), h3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
          return o3;
        })), e4;
      });
    }
    function D2(e3, t3) {
      for (var r3 = "", n3 = 0, i3 = e3.length; n3 < i3; n3++)
        r3 += e3[n3], n3 < i3 - 1 && (r3 += t3[n3]);
      return r3;
    }
    function f2(e3) {
      return s2(e3, "raw") && s2(e3, "length");
    }
    var d2 = function e3(t3) {
      var r3 = n2(), i3 = n2();
      return o2(function n3(s3) {
        for (var a3 = [], u3 = 1; u3 < arguments.length; u3++)
          a3[u3 - 1] = arguments[u3];
        if (f2(s3)) {
          var l3 = s3, g2 = (a3[0] === n3 || a3[0] === d2) && p2.test(l3[0]) && c2.test(l3[1]), m2 = g2 ? i3 : r3, E2 = m2.get(l3);
          if (E2 || (E2 = h2(l3, g2, t3), m2.set(l3, E2)), a3.length === 0)
            return E2[0];
          var C2 = D2(E2, g2 ? a3.slice(1) : a3);
          return C2;
        }
        return e3(o2(o2({}, t3), s3 || {}));
      }, { string: function(e4) {
        return h2([e4], false, t3)[0];
      } });
    }({ trimLeadingNewline: true, trimTrailingNewline: true });
    t2.outdent = d2, t2.default = d2;
    try {
      e2.exports = d2, Object.defineProperty(d2, "__esModule", { value: true }), d2.default = d2, d2.outdent = d2;
    } catch (e3) {
    }
  });
  const { outdent: Dn } = hn, fn = { cursorOffset: { since: "1.4.0", category: "Special", type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Dn`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor" }, endOfLine: { since: "1.15.0", category: "Global", type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Dn`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { since: "0.0.10", category: "Global", type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: Dn`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: "Config" }, printWidth: { since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Dn`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, rangeStart: { since: "1.4.0", category: "Special", type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Dn`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, requirePragma: { since: "1.7.0", category: "Special", type: "boolean", default: false, description: Dn`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: "Global", type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  const dn = ["cliName", "cliCategory", "cliDescription"], gn = { compare: cn, lt: ln, gte: pn }, mn = "2.4.1", En = { CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: fn }.options;
  var Cn = { getSupportInfo: function({ plugins: e2 = [], showUnreleased: t2 = false, showDeprecated: r2 = false, showInternal: n2 = false } = {}) {
    const i2 = mn.split("-", 1)[0], s2 = e2.flatMap((e3) => e3.languages || []).filter(a2), o2 = ((e3, t3) => Object.entries(e3).map(([e4, r3]) => Object.assign({ [t3]: e4 }, r3)))(Object.assign({}, ...e2.map(({ options: e3 }) => e3), En), "name").filter((e3) => a2(e3) && u2(e3)).sort((e3, t3) => e3.name === t3.name ? 0 : e3.name < t3.name ? -1 : 1).map(function(e3) {
      if (n2)
        return e3;
      return Q$1(e3, dn);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(a2).sort((e3, t4) => gn.compare(t4.since, e3.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e3) => a2(e3) && u2(e3)), t3.name === "parser" && function(e3, t4, r4) {
        const n3 = new Set(e3.choices.map((e4) => e4.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!n3.has(t5)) {
                n3.add(t5);
                const s3 = r4.find((e4) => e4.parsers && e4.parsers[t5]);
                let o3 = i3.name;
                s3 && s3.name && (o3 += ` (plugin: ${s3.name})`), e3.choices.push({ value: t5, description: o3 });
              }
          }
      }(t3, s2, e2));
      const r3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t3.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: r3 });
    });
    return { languages: s2, options: o2 };
    function a2(e3) {
      return t2 || !("since" in e3) || e3.since && gn.gte(i2, e3.since);
    }
    function u2(e3) {
      return r2 || !("deprecated" in e3) || e3.deprecated && gn.lt(i2, e3.deprecated);
    }
  } };
  const { getSupportInfo: yn } = Cn, bn = /[^\x20-\x7F]/;
  function Sn(e2) {
    return (t2, r2, n2) => {
      const i2 = n2 && n2.backwards;
      if (r2 === false)
        return false;
      const { length: s2 } = t2;
      let o2 = r2;
      for (; o2 >= 0 && o2 < s2; ) {
        const r3 = t2.charAt(o2);
        if (e2 instanceof RegExp) {
          if (!e2.test(r3))
            return o2;
        } else if (!e2.includes(r3))
          return o2;
        i2 ? o2-- : o2++;
      }
      return (o2 === -1 || o2 === s2) && o2;
    };
  }
  const Tn = Sn(/\s/), _n = Sn(" 	"), vn = Sn(",; 	"), An = Sn(/[^\n\r]/);
  function Fn(e2, t2) {
    if (t2 === false)
      return false;
    if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
      for (let r2 = t2 + 2; r2 < e2.length; ++r2)
        if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
          return r2 + 2;
    }
    return t2;
  }
  function wn(e2, t2) {
    return t2 !== false && (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? An(e2, t2) : t2);
  }
  function kn(e2, t2, r2) {
    const n2 = r2 && r2.backwards;
    if (t2 === false)
      return false;
    const i2 = e2.charAt(t2);
    if (n2) {
      if (e2.charAt(t2 - 1) === "\r" && i2 === "\n")
        return t2 - 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 - 1;
    } else {
      if (i2 === "\r" && e2.charAt(t2 + 1) === "\n")
        return t2 + 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 + 1;
    }
    return t2;
  }
  function Nn(e2, t2, r2 = {}) {
    const n2 = _n(e2, r2.backwards ? t2 - 1 : t2, r2);
    return n2 !== kn(e2, n2, r2);
  }
  function On(e2, t2) {
    let r2 = null, n2 = t2;
    for (; n2 !== r2; )
      r2 = n2, n2 = vn(e2, n2), n2 = Fn(e2, n2), n2 = _n(e2, n2);
    return n2 = wn(e2, n2), n2 = kn(e2, n2), n2 !== false && Nn(e2, n2);
  }
  function xn(e2, t2) {
    let r2 = null, n2 = t2;
    for (; n2 !== r2; )
      r2 = n2, n2 = _n(e2, n2), n2 = Fn(e2, n2), n2 = wn(e2, n2), n2 = kn(e2, n2);
    return n2;
  }
  function In(e2, t2, r2) {
    return xn(e2, r2(t2));
  }
  function Pn(e2, t2, r2 = 0) {
    let n2 = 0;
    for (let i2 = r2; i2 < e2.length; ++i2)
      e2[i2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
    return n2;
  }
  function Rn(e2, t2) {
    const r2 = e2.slice(1, -1), n2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, s2 = t2 === "'" ? i2 : n2, o2 = s2 === i2 ? n2 : i2;
    let a2 = s2.quote;
    if (r2.includes(s2.quote) || r2.includes(o2.quote)) {
      a2 = (r2.match(s2.regex) || []).length > (r2.match(o2.regex) || []).length ? o2.quote : s2.quote;
    }
    return a2;
  }
  function Ln(e2, t2, r2) {
    const n2 = t2 === '"' ? "'" : '"', i2 = e2.replace(/\\(.)|(["'])/gs, (e3, i3, s2) => i3 === n2 ? i3 : s2 === t2 ? "\\" + s2 : s2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
    return t2 + i2 + t2;
  }
  function Bn(e2, t2) {
    (e2.comments || (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e3) {
      const t3 = e3.type || e3.kind || "(unknown type)";
      let r2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
      r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026");
      return t3 + (r2 ? " " + r2 : "");
    }(e2);
  }
  var $n = { inferParserByLanguage: function(e2, t2) {
    const { languages: r2 } = yn({ plugins: t2.plugins }), n2 = r2.find(({ name: t3 }) => t3.toLowerCase() === e2) || r2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e2)) || r2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e2}`));
    return n2 && n2.parsers[0];
  }, getStringWidth: function(e2) {
    return e2 ? bn.test(e2) ? z$1(e2) : e2.length : 0;
  }, getMaxContinuousCount: function(e2, t2) {
    const r2 = e2.match(new RegExp(`(${Y$1(t2)})+`, "g"));
    return r2 === null ? 0 : r2.reduce((e3, r3) => Math.max(e3, r3.length / t2.length), 0);
  }, getMinNotPresentContinuousCount: function(e2, t2) {
    const r2 = e2.match(new RegExp(`(${Y$1(t2)})+`, "g"));
    if (r2 === null)
      return 0;
    const n2 = new Map();
    let i2 = 0;
    for (const e3 of r2) {
      const r3 = e3.length / t2.length;
      n2.set(r3, true), r3 > i2 && (i2 = r3);
    }
    for (let e3 = 1; e3 < i2; e3++)
      if (!n2.get(e3))
        return e3;
    return i2 + 1;
  }, getPenultimate: (e2) => e2[e2.length - 2], getLast: M$1, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: xn, getNextNonSpaceNonCommentCharacterIndex: In, getNextNonSpaceNonCommentCharacter: function(e2, t2, r2) {
    return e2.charAt(In(e2, t2, r2));
  }, skip: Sn, skipWhitespace: Tn, skipSpaces: _n, skipToLineEnd: vn, skipEverythingButNewLine: An, skipInlineComment: Fn, skipTrailingComment: wn, skipNewline: kn, isNextLineEmptyAfterIndex: On, isNextLineEmpty: function(e2, t2, r2) {
    return On(e2, r2(t2));
  }, isPreviousLineEmpty: function(e2, t2, r2) {
    let n2 = r2(t2) - 1;
    return n2 = _n(e2, n2, { backwards: true }), n2 = kn(e2, n2, { backwards: true }), n2 = _n(e2, n2, { backwards: true }), n2 !== kn(e2, n2, { backwards: true });
  }, hasNewline: Nn, hasNewlineInRange: function(e2, t2, r2) {
    for (let n2 = t2; n2 < r2; ++n2)
      if (e2.charAt(n2) === "\n")
        return true;
    return false;
  }, hasSpaces: function(e2, t2, r2 = {}) {
    return _n(e2, r2.backwards ? t2 - 1 : t2, r2) !== t2;
  }, getAlignmentSize: Pn, getIndentSize: function(e2, t2) {
    const r2 = e2.lastIndexOf("\n");
    return r2 === -1 ? 0 : Pn(e2.slice(r2 + 1).match(/^[\t ]*/)[0], t2);
  }, getPreferredQuote: Rn, printString: function(e2, t2) {
    return Ln(e2.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Rn(e2, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  }, printNumber: function(e2) {
    return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }, makeString: Ln, addLeadingComment: function(e2, t2) {
    t2.leading = true, t2.trailing = false, Bn(e2, t2);
  }, addDanglingComment: function(e2, t2, r2) {
    t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Bn(e2, t2);
  }, addTrailingComment: function(e2, t2) {
    t2.leading = false, t2.trailing = true, Bn(e2, t2);
  }, isFrontMatterNode: function(e2) {
    return e2 && e2.type === "front-matter";
  }, getShebang: function(e2) {
    if (!e2.startsWith("#!"))
      return "";
    const t2 = e2.indexOf("\n");
    return t2 === -1 ? e2 : e2.slice(0, t2);
  }, isNonEmptyArray: function(e2) {
    return Array.isArray(e2) && e2.length > 0;
  }, createGroupIdMapper: function(e2) {
    const t2 = new WeakMap();
    return function(r2) {
      return t2.has(r2) || t2.set(r2, Symbol(e2)), t2.get(r2);
    };
  } }, qn = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] };
  function Mn(e2) {
    return { type: "concat", parts: e2 };
  }
  function jn(e2) {
    return { type: "indent", contents: e2 };
  }
  function Un(e2, t2) {
    return { type: "align", contents: t2, n: e2 };
  }
  function Gn(e2, t2 = {}) {
    return { type: "group", id: t2.id, contents: e2, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates };
  }
  const Vn = { type: "break-parent" }, Hn = { type: "line", hard: true }, Xn = { type: "line", hard: true, literal: true }, zn = Mn([Hn, Vn]), Wn = Mn([Xn, Vn]);
  var Yn = { concat: Mn, join: function(e2, t2) {
    const r2 = [];
    for (let n2 = 0; n2 < t2.length; n2++)
      n2 !== 0 && r2.push(e2), r2.push(t2[n2]);
    return Mn(r2);
  }, line: { type: "line" }, softline: { type: "line", soft: true }, hardline: zn, literalline: Wn, group: Gn, conditionalGroup: function(e2, t2) {
    return Gn(e2[0], Object.assign(Object.assign({}, t2), {}, { expandedStates: e2 }));
  }, fill: function(e2) {
    return { type: "fill", parts: e2 };
  }, lineSuffix: function(e2) {
    return { type: "line-suffix", contents: e2 };
  }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: Vn, ifBreak: function(e2, t2, r2 = {}) {
    return { type: "if-break", breakContents: e2, flatContents: t2, groupId: r2.groupId };
  }, trim: { type: "trim" }, indent: jn, indentIfBreak: function(e2, t2) {
    return { type: "indent-if-break", contents: e2, groupId: t2.groupId, negate: t2.negate };
  }, align: Un, addAlignmentToDoc: function(e2, t2, r2) {
    let n2 = e2;
    if (t2 > 0) {
      for (let e3 = 0; e3 < Math.floor(t2 / r2); ++e3)
        n2 = jn(n2);
      n2 = Un(t2 % r2, n2), n2 = Un(Number.NEGATIVE_INFINITY, n2);
    }
    return n2;
  }, markAsRoot: function(e2) {
    return Un({ type: "root" }, e2);
  }, dedentToRoot: function(e2) {
    return Un(Number.NEGATIVE_INFINITY, e2);
  }, dedent: function(e2) {
    return Un(-1, e2);
  }, hardlineWithoutBreakParent: Hn, literallineWithoutBreakParent: Xn, label: function(e2, t2) {
    return { type: "label", label: e2, contents: t2 };
  } };
  var Qn = { guessEndOfLine: function(e2) {
    const t2 = e2.indexOf("\r");
    return t2 >= 0 ? e2.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  }, convertEndOfLineToChars: function(e2) {
    switch (e2) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  }, countEndOfLineChars: function(e2, t2) {
    let r2;
    if (t2 === "\n")
      r2 = /\n/g;
    else if (t2 === "\r")
      r2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      r2 = /\r\n/g;
    }
    const n2 = e2.match(r2);
    return n2 ? n2.length : 0;
  }, normalizeEndOfLine: function(e2) {
    return e2.replace(/\r\n?/g, "\n");
  } };
  const { literalline: Jn, join: Kn } = Yn, Zn = (e2) => Array.isArray(e2) || e2 && e2.type === "concat", ei = (e2) => {
    if (Array.isArray(e2))
      return e2;
    if (e2.type !== "concat" && e2.type !== "fill")
      throw new Error("Expect doc type to be `concat` or `fill`.");
    return e2.parts;
  }, ti = {};
  function ri(e2, t2, r2, n2) {
    const i2 = [e2];
    for (; i2.length > 0; ) {
      const e3 = i2.pop();
      if (e3 !== ti) {
        if (r2 && i2.push(e3, ti), !t2 || t2(e3) !== false)
          if (Zn(e3) || e3.type === "fill") {
            const t3 = ei(e3);
            for (let e4 = t3.length - 1; e4 >= 0; --e4)
              i2.push(t3[e4]);
          } else if (e3.type === "if-break")
            e3.flatContents && i2.push(e3.flatContents), e3.breakContents && i2.push(e3.breakContents);
          else if (e3.type === "group" && e3.expandedStates)
            if (n2)
              for (let t3 = e3.expandedStates.length - 1; t3 >= 0; --t3)
                i2.push(e3.expandedStates[t3]);
            else
              i2.push(e3.contents);
          else
            e3.contents && i2.push(e3.contents);
      } else
        r2(i2.pop());
    }
  }
  function ni(e2, t2) {
    const r2 = new Map();
    return n2(e2);
    function n2(e3) {
      if (r2.has(e3))
        return r2.get(e3);
      const i2 = function(e4) {
        if (Array.isArray(e4))
          return t2(e4.map(n2));
        if (e4.type === "concat" || e4.type === "fill") {
          const r3 = e4.parts.map(n2);
          return t2(Object.assign(Object.assign({}, e4), {}, { parts: r3 }));
        }
        if (e4.type === "if-break") {
          const r3 = e4.breakContents && n2(e4.breakContents), i3 = e4.flatContents && n2(e4.flatContents);
          return t2(Object.assign(Object.assign({}, e4), {}, { breakContents: r3, flatContents: i3 }));
        }
        if (e4.type === "group" && e4.expandedStates) {
          const r3 = e4.expandedStates.map(n2), i3 = r3[0];
          return t2(Object.assign(Object.assign({}, e4), {}, { contents: i3, expandedStates: r3 }));
        }
        if (e4.contents) {
          const r3 = n2(e4.contents);
          return t2(Object.assign(Object.assign({}, e4), {}, { contents: r3 }));
        }
        return t2(e4);
      }(e3);
      return r2.set(e3, i2), i2;
    }
  }
  function ii(e2, t2, r2) {
    let n2 = r2, i2 = false;
    return ri(e2, function(e3) {
      const r3 = t2(e3);
      if (r3 !== void 0 && (i2 = true, n2 = r3), i2)
        return false;
    }), n2;
  }
  function si(e2) {
    return !(e2.type !== "group" || !e2.break) || (!(e2.type !== "line" || !e2.hard) || (e2.type === "break-parent" || void 0));
  }
  function oi(e2) {
    if (e2.length > 0) {
      const t2 = M$1(e2);
      t2.expandedStates || t2.break || (t2.break = "propagated");
    }
    return null;
  }
  function ai(e2) {
    return e2.type !== "line" || e2.hard ? e2.type === "if-break" ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
  }
  const ui = (e2, t2) => e2 && e2.type === "line" && e2.hard && t2 && t2.type === "break-parent";
  function ci(e2) {
    if (!e2)
      return e2;
    if (Zn(e2) || e2.type === "fill") {
      const t2 = ei(e2);
      for (; t2.length > 1 && ui(...t2.slice(-2)); )
        t2.length -= 2;
      if (t2.length > 0) {
        const e3 = ci(M$1(t2));
        t2[t2.length - 1] = e3;
      }
      return Array.isArray(e2) ? t2 : Object.assign(Object.assign({}, e2), {}, { parts: t2 });
    }
    switch (e2.type) {
      case "align":
      case "indent":
      case "indent-if-break":
      case "group":
      case "line-suffix":
      case "label": {
        const t2 = ci(e2.contents);
        return Object.assign(Object.assign({}, e2), {}, { contents: t2 });
      }
      case "if-break": {
        const t2 = ci(e2.breakContents), r2 = ci(e2.flatContents);
        return Object.assign(Object.assign({}, e2), {}, { breakContents: t2, flatContents: r2 });
      }
    }
    return e2;
  }
  function li(e2) {
    return ni(e2, (e3) => function(e4) {
      switch (e4.type) {
        case "fill":
          if (e4.parts.length === 0 || e4.parts.every((e5) => e5 === ""))
            return "";
          break;
        case "group":
          if (!(e4.contents || e4.id || e4.break || e4.expandedStates))
            return "";
          if (e4.contents.type === "group" && e4.contents.id === e4.id && e4.contents.break === e4.break && e4.contents.expandedStates === e4.expandedStates)
            return e4.contents;
          break;
        case "align":
        case "indent":
        case "indent-if-break":
        case "line-suffix":
          if (!e4.contents)
            return "";
          break;
        case "if-break":
          if (!e4.flatContents && !e4.breakContents)
            return "";
      }
      if (!Zn(e4))
        return e4;
      const t2 = [];
      for (const r2 of ei(e4)) {
        if (!r2)
          continue;
        const [e5, ...n2] = Zn(r2) ? ei(r2) : [r2];
        typeof e5 == "string" && typeof M$1(t2) == "string" ? t2[t2.length - 1] += e5 : t2.push(e5), t2.push(...n2);
      }
      return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e4) ? t2 : Object.assign(Object.assign({}, e4), {}, { parts: t2 });
    }(e3));
  }
  function pi(e2) {
    const t2 = [], r2 = e2.filter(Boolean);
    for (; r2.length > 0; ) {
      const e3 = r2.shift();
      e3 && (Zn(e3) ? r2.unshift(...ei(e3)) : t2.length > 0 && typeof M$1(t2) == "string" && typeof e3 == "string" ? t2[t2.length - 1] += e3 : t2.push(e3));
    }
    return t2;
  }
  function hi(e2, t2 = Jn) {
    return Kn(t2, e2.split("\n")).parts;
  }
  var Di = { isConcat: Zn, getDocParts: ei, willBreak: function(e2) {
    return ii(e2, si, false);
  }, traverseDoc: ri, findInDoc: ii, mapDoc: ni, propagateBreaks: function(e2) {
    const t2 = new Set(), r2 = [];
    ri(e2, function(e3) {
      if (e3.type === "break-parent" && oi(r2), e3.type === "group") {
        if (r2.push(e3), t2.has(e3))
          return false;
        t2.add(e3);
      }
    }, function(e3) {
      if (e3.type === "group") {
        r2.pop().break && oi(r2);
      }
    }, true);
  }, removeLines: function(e2) {
    return ni(e2, ai);
  }, stripTrailingHardline: function(e2) {
    return ci(li(e2));
  }, normalizeParts: pi, normalizeDoc: function(e2) {
    return ni(e2, (e3) => Array.isArray(e3) ? pi(e3) : e3.parts ? Object.assign(Object.assign({}, e3), {}, { parts: pi(e3.parts) }) : e3);
  }, cleanDoc: li, replaceTextEndOfLine: hi, replaceEndOfLine: function(e2) {
    return ni(e2, (e3) => typeof e3 == "string" && e3.includes("\n") ? hi(e3) : e3);
  } };
  const { getStringWidth: fi, getLast: di } = $n, { convertEndOfLineToChars: gi } = Qn, { fill: mi, cursor: Ei, indent: Ci } = Yn, { isConcat: yi, getDocParts: bi } = Di;
  let Si;
  function Ti(e2, t2) {
    return vi(e2, { type: "indent" }, t2);
  }
  function _i(e2, t2, r2) {
    if (t2 === Number.NEGATIVE_INFINITY)
      return e2.root || { value: "", length: 0, queue: [] };
    if (t2 < 0)
      return vi(e2, { type: "dedent" }, r2);
    if (!t2)
      return e2;
    if (t2.type === "root")
      return Object.assign(Object.assign({}, e2), {}, { root: e2 });
    return vi(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, r2);
  }
  function vi(e2, t2, r2) {
    const n2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2];
    let i2 = "", s2 = 0, o2 = 0, a2 = 0;
    for (const e3 of n2)
      switch (e3.type) {
        case "indent":
          l2(), r2.useTabs ? u2(1) : c2(r2.tabWidth);
          break;
        case "stringAlign":
          l2(), i2 += e3.n, s2 += e3.n.length;
          break;
        case "numberAlign":
          o2 += 1, a2 += e3.n;
          break;
        default:
          throw new Error(`Unexpected type '${e3.type}'`);
      }
    return p2(), Object.assign(Object.assign({}, e2), {}, { value: i2, length: s2, queue: n2 });
    function u2(e3) {
      i2 += "	".repeat(e3), s2 += r2.tabWidth * e3;
    }
    function c2(e3) {
      i2 += " ".repeat(e3), s2 += e3;
    }
    function l2() {
      r2.useTabs ? function() {
        o2 > 0 && u2(o2);
        h2();
      }() : p2();
    }
    function p2() {
      a2 > 0 && c2(a2), h2();
    }
    function h2() {
      o2 = 0, a2 = 0;
    }
  }
  function Ai(e2) {
    if (e2.length === 0)
      return 0;
    let t2 = 0;
    for (; e2.length > 0 && typeof di(e2) == "string" && /^[\t ]*$/.test(di(e2)); )
      t2 += e2.pop().length;
    if (e2.length > 0 && typeof di(e2) == "string") {
      const r2 = di(e2).replace(/[\t ]*$/, "");
      t2 += di(e2).length - r2.length, e2[e2.length - 1] = r2;
    }
    return t2;
  }
  function Fi(e2, t2, r2, n2, i2, s2) {
    let o2 = t2.length;
    const a2 = [e2], u2 = [];
    for (; r2 >= 0; ) {
      if (a2.length === 0) {
        if (o2 === 0)
          return true;
        a2.push(t2[o2 - 1]), o2--;
        continue;
      }
      const [e3, c2, l2] = a2.pop();
      if (typeof l2 == "string")
        u2.push(l2), r2 -= fi(l2);
      else if (yi(l2)) {
        const t3 = bi(l2);
        for (let r3 = t3.length - 1; r3 >= 0; r3--)
          a2.push([e3, c2, t3[r3]]);
      } else
        switch (l2.type) {
          case "indent":
            a2.push([Ti(e3, n2), c2, l2.contents]);
            break;
          case "align":
            a2.push([_i(e3, l2.n, n2), c2, l2.contents]);
            break;
          case "trim":
            r2 += Ai(u2);
            break;
          case "group": {
            if (s2 && l2.break)
              return false;
            const t3 = l2.break ? 1 : c2;
            a2.push([e3, t3, l2.expandedStates && t3 === 1 ? di(l2.expandedStates) : l2.contents]), l2.id && (Si[l2.id] = t3);
            break;
          }
          case "fill":
            for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
              a2.push([e3, c2, l2.parts[t3]]);
            break;
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Si[l2.groupId] : c2;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
              t4 && a2.push([e3, c2, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
              t4 && a2.push([e3, c2, t4]);
            }
            break;
          }
          case "line":
            switch (c2) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (u2.push(" "), r2 -= 1);
                  break;
                }
                return true;
              case 1:
                return true;
            }
            break;
          case "line-suffix":
            i2 = true;
            break;
          case "line-suffix-boundary":
            if (i2)
              return false;
            break;
          case "label":
            a2.push([e3, c2, l2.contents]);
        }
    }
    return false;
  }
  var wi = { printDocToString: function(e2, t2) {
    Si = {};
    const r2 = t2.printWidth, n2 = gi(t2.endOfLine);
    let i2 = 0;
    const s2 = [[{ value: "", length: 0, queue: [] }, 1, e2]], o2 = [];
    let a2 = false, u2 = [];
    for (; s2.length > 0; ) {
      const [e3, c3, l2] = s2.pop();
      if (typeof l2 == "string") {
        const e4 = n2 !== "\n" ? l2.replace(/\n/g, n2) : l2;
        o2.push(e4), i2 += fi(e4);
      } else if (yi(l2)) {
        const t3 = bi(l2);
        for (let r3 = t3.length - 1; r3 >= 0; r3--)
          s2.push([e3, c3, t3[r3]]);
      } else
        switch (l2.type) {
          case "cursor":
            o2.push(Ei.placeholder);
            break;
          case "indent":
            s2.push([Ti(e3, t2), c3, l2.contents]);
            break;
          case "align":
            s2.push([_i(e3, l2.n, t2), c3, l2.contents]);
            break;
          case "trim":
            i2 -= Ai(o2);
            break;
          case "group":
            switch (c3) {
              case 2:
                if (!a2) {
                  s2.push([e3, l2.break ? 1 : 2, l2.contents]);
                  break;
                }
              case 1: {
                a2 = false;
                const n3 = [e3, 2, l2.contents], o3 = r2 - i2, c4 = u2.length > 0;
                if (!l2.break && Fi(n3, s2, o3, t2, c4))
                  s2.push(n3);
                else if (l2.expandedStates) {
                  const r3 = di(l2.expandedStates);
                  if (l2.break) {
                    s2.push([e3, 1, r3]);
                    break;
                  }
                  for (let n4 = 1; n4 < l2.expandedStates.length + 1; n4++) {
                    if (n4 >= l2.expandedStates.length) {
                      s2.push([e3, 1, r3]);
                      break;
                    }
                    {
                      const r4 = [e3, 2, l2.expandedStates[n4]];
                      if (Fi(r4, s2, o3, t2, c4)) {
                        s2.push(r4);
                        break;
                      }
                    }
                  }
                } else
                  s2.push([e3, 1, l2.contents]);
                break;
              }
            }
            l2.id && (Si[l2.id] = di(s2)[1]);
            break;
          case "fill": {
            const n3 = r2 - i2, { parts: o3 } = l2;
            if (o3.length === 0)
              break;
            const [a3, p2] = o3, h2 = [e3, 2, a3], D2 = [e3, 1, a3], f2 = Fi(h2, [], n3, t2, u2.length > 0, true);
            if (o3.length === 1) {
              f2 ? s2.push(h2) : s2.push(D2);
              break;
            }
            const d2 = [e3, 2, p2], g2 = [e3, 1, p2];
            if (o3.length === 2) {
              f2 ? s2.push(d2, h2) : s2.push(g2, D2);
              break;
            }
            o3.splice(0, 2);
            const m2 = [e3, c3, mi(o3)];
            Fi([e3, 2, [a3, p2, o3[0]]], [], n3, t2, u2.length > 0, true) ? s2.push(m2, d2, h2) : f2 ? s2.push(m2, g2, h2) : s2.push(m2, g2, D2);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Si[l2.groupId] : c3;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
              t4 && s2.push([e3, c3, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
              t4 && s2.push([e3, c3, t4]);
            }
            break;
          }
          case "line-suffix":
            u2.push([e3, c3, l2.contents]);
            break;
          case "line-suffix-boundary":
            u2.length > 0 && s2.push([e3, c3, { type: "line", hard: true }]);
            break;
          case "line":
            switch (c3) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (o2.push(" "), i2 += 1);
                  break;
                }
                a2 = true;
              case 1:
                if (u2.length > 0) {
                  s2.push([e3, c3, l2], ...u2.reverse()), u2 = [];
                  break;
                }
                l2.literal ? e3.root ? (o2.push(n2, e3.root.value), i2 = e3.root.length) : (o2.push(n2), i2 = 0) : (i2 -= Ai(o2), o2.push(n2 + e3.value), i2 = e3.length);
            }
            break;
          case "label":
            s2.push([e3, c3, l2.contents]);
        }
      s2.length === 0 && u2.length > 0 && (s2.push(...u2.reverse()), u2 = []);
    }
    const c2 = o2.indexOf(Ei.placeholder);
    if (c2 !== -1) {
      const e3 = o2.indexOf(Ei.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), r3 = o2.slice(c2 + 1, e3).join("");
      return { formatted: t3 + r3 + o2.slice(e3 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: r3 };
    }
    return { formatted: o2.join("") };
  } };
  const { isConcat: ki, getDocParts: Ni } = Di;
  function Oi(e2) {
    if (!e2)
      return "";
    if (ki(e2)) {
      const t2 = [];
      for (const r2 of Ni(e2))
        if (ki(r2))
          t2.push(...Oi(r2).parts);
        else {
          const e3 = Oi(r2);
          e3 !== "" && t2.push(e3);
        }
      return { type: "concat", parts: t2 };
    }
    return e2.type === "if-break" ? Object.assign(Object.assign({}, e2), {}, { breakContents: Oi(e2.breakContents), flatContents: Oi(e2.flatContents) }) : e2.type === "group" ? Object.assign(Object.assign({}, e2), {}, { contents: Oi(e2.contents), expandedStates: e2.expandedStates && e2.expandedStates.map(Oi) }) : e2.type === "fill" ? { type: "fill", parts: e2.parts.map(Oi) } : e2.contents ? Object.assign(Object.assign({}, e2), {}, { contents: Oi(e2.contents) }) : e2;
  }
  var xi = { builders: Yn, printer: wi, utils: Di, debug: { printDocToDebug: function(e2) {
    const t2 = Object.create(null), r2 = new Set();
    return function e3(t3, r3, i2) {
      if (typeof t3 == "string")
        return JSON.stringify(t3);
      if (ki(t3)) {
        const r4 = Ni(t3).map(e3).filter(Boolean);
        return r4.length === 1 ? r4[0] : `[${r4.join(", ")}]`;
      }
      if (t3.type === "line") {
        const e4 = Array.isArray(i2) && i2[r3 + 1] && i2[r3 + 1].type === "break-parent";
        return t3.literal ? e4 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e4 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
      }
      if (t3.type === "break-parent") {
        return Array.isArray(i2) && i2[r3 - 1] && i2[r3 - 1].type === "line" && i2[r3 - 1].hard ? void 0 : "breakParent";
      }
      if (t3.type === "trim")
        return "trim";
      if (t3.type === "indent")
        return "indent(" + e3(t3.contents) + ")";
      if (t3.type === "align")
        return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e3(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e3(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e3(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e3(t3.contents) + ")";
      if (t3.type === "if-break")
        return "ifBreak(" + e3(t3.breakContents) + (t3.flatContents ? ", " + e3(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${n2(t3.groupId)} }` : "") + ")";
      if (t3.type === "indent-if-break") {
        const r4 = [];
        t3.negate && r4.push("negate: true"), t3.groupId && r4.push(`groupId: ${n2(t3.groupId)}`);
        const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
        return `indentIfBreak(${e3(t3.contents)}${i3})`;
      }
      if (t3.type === "group") {
        const r4 = [];
        t3.break && t3.break !== "propagated" && r4.push("shouldBreak: true"), t3.id && r4.push(`id: ${n2(t3.id)}`);
        const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
        return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e3(t4)).join(",")}]${i3})` : `group(${e3(t3.contents)}${i3})`;
      }
      if (t3.type === "fill")
        return `fill([${t3.parts.map((t4) => e3(t4)).join(", ")}])`;
      if (t3.type === "line-suffix")
        return "lineSuffix(" + e3(t3.contents) + ")";
      if (t3.type === "line-suffix-boundary")
        return "lineSuffixBoundary";
      if (t3.type === "label")
        return `label(${JSON.stringify(t3.label)}, ${e3(t3.contents)})`;
      throw new Error("Unknown doc type " + t3.type);
    }(Oi(e2));
    function n2(e3) {
      if (typeof e3 != "symbol")
        return JSON.stringify(String(e3));
      if (e3 in t2)
        return t2[e3];
      const n3 = String(e3).slice(7, -1) || "symbol";
      for (let i2 = 0; ; i2++) {
        const s2 = n3 + (i2 > 0 ? ` #${i2}` : "");
        if (!r2.has(s2))
          return r2.add(s2), t2[e3] = `Symbol.for(${JSON.stringify(s2)})`;
      }
    }
  } } };
  const { inferParserByLanguage: Ii, isFrontMatterNode: Pi } = $n, { builders: { line: Ri, hardline: Li, join: Bi }, utils: { getDocParts: $i, replaceTextEndOfLine: qi } } = xi, { CSS_DISPLAY_TAGS: Mi, CSS_DISPLAY_DEFAULT: ji, CSS_WHITE_SPACE_TAGS: Ui, CSS_WHITE_SPACE_DEFAULT: Gi } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, Vi = Yi(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), Hi = function(e2, t2) {
    const r2 = Object.create(null);
    for (const [n2, i2] of Object.entries(e2))
      r2[n2] = t2(i2, n2);
    return r2;
  }(qn, Yi), Xi = new Set(["	", "\n", "\f", "\r", " "]), zi = (e2) => e2.replace(/[\t\n\f\r ]+$/, ""), Wi = (e2) => ((e3) => e3.replace(/^[\t\f\r ]*?\n/g, ""))(zi(e2));
  function Yi(e2) {
    const t2 = Object.create(null);
    for (const r2 of e2)
      t2[r2] = true;
    return t2;
  }
  function Qi(e2) {
    return e2.type === "element" && (e2.fullName === "script" || e2.fullName === "style" || e2.fullName === "svg:style" || as(e2) && (e2.name === "script" || e2.name === "style"));
  }
  function Ji(e2) {
    return us(e2).startsWith("pre");
  }
  function Ki(e2) {
    return e2.type === "element" && e2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e2.name) || e2.cssDisplay.startsWith("table") && e2.cssDisplay !== "table-cell");
  }
  function Zi(e2) {
    return ns(e2) || e2.type === "element" && e2.fullName === "br" || es(e2);
  }
  function es(e2) {
    return ts(e2) && rs(e2);
  }
  function ts(e2) {
    return e2.hasLeadingSpaces && (e2.prev ? e2.prev.sourceSpan.end.line < e2.sourceSpan.start.line : e2.parent.type === "root" || e2.parent.startSourceSpan.end.line < e2.sourceSpan.start.line);
  }
  function rs(e2) {
    return e2.hasTrailingSpaces && (e2.next ? e2.next.sourceSpan.start.line > e2.sourceSpan.end.line : e2.parent.type === "root" || e2.parent.endSourceSpan && e2.parent.endSourceSpan.start.line > e2.sourceSpan.end.line);
  }
  function ns(e2) {
    switch (e2.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;
      case "element":
        return ["script", "select"].includes(e2.name);
    }
    return false;
  }
  function is$1(e2) {
    const { type: t2, lang: r2 } = e2.attrMap;
    return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || r2 === "jsx" ? "babel" : t2 === "application/x-typescript" || r2 === "ts" || r2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
  }
  function ss(e2) {
    return e2 === "block" || e2 === "list-item" || e2.startsWith("table");
  }
  function os$1(e2) {
    return us(e2).startsWith("pre");
  }
  function as(e2) {
    return e2.type === "element" && !e2.hasExplicitNamespace && !["html", "svg"].includes(e2.namespace);
  }
  function us(e2) {
    return e2.type === "element" && (!e2.namespace || as(e2)) && Ui[e2.name] || Gi;
  }
  function cs(e2, t2 = function(e3) {
    let t3 = Number.POSITIVE_INFINITY;
    for (const n2 of e3.split("\n")) {
      if (n2.length === 0)
        continue;
      if (!Xi.has(n2[0]))
        return 0;
      const e4 = (r2 = n2, r2.match(/^[\t\n\f\r ]*/)[0]).length;
      n2.length !== e4 && e4 < t3 && (t3 = e4);
    }
    var r2;
    return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
  }(e2)) {
    return t2 === 0 ? e2 : e2.split("\n").map((e3) => e3.slice(t2)).join("\n");
  }
  const ls = new Set(["template", "style", "script"]);
  function ps(e2, t2) {
    return hs(e2, t2) && !ls.has(e2.fullName);
  }
  function hs(e2, t2) {
    return t2.parser === "vue" && e2.type === "element" && e2.parent.type === "root" && e2.fullName.toLowerCase() !== "html";
  }
  function Ds(e2, t2) {
    return hs(e2, t2) && (ps(e2, t2) || e2.attrMap.lang && e2.attrMap.lang !== "html");
  }
  var fs$1 = { HTML_ELEMENT_ATTRIBUTES: Hi, HTML_TAGS: Vi, htmlTrim: (e2) => ((e3) => e3.replace(/^[\t\n\f\r ]+/, ""))(zi(e2)), htmlTrimPreserveIndentation: Wi, hasHtmlWhitespace: (e2) => /[\t\n\f\r ]/.test(e2), getLeadingAndTrailingHtmlWhitespace: (e2) => {
    const [, t2, r2, n2] = e2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return { leadingWhitespace: t2, trailingWhitespace: n2, text: r2 };
  }, canHaveInterpolation: function(e2) {
    return e2.children && !Qi(e2);
  }, countChars: function(e2, t2) {
    let r2 = 0;
    for (let n2 = 0; n2 < e2.length; n2++)
      e2[n2] === t2 && r2++;
    return r2;
  }, countParents: function(e2, t2) {
    let r2 = 0;
    for (let n2 = e2.stack.length - 1; n2 >= 0; n2--) {
      const i2 = e2.stack[n2];
      i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && r2++;
    }
    return r2;
  }, dedentString: cs, forceBreakChildren: Ki, forceBreakContent: function(e2) {
    return Ki(e2) || e2.type === "element" && e2.children.length > 0 && (["body", "script", "style"].includes(e2.name) || e2.children.some((e3) => function(e4) {
      return e4.children && e4.children.some((e5) => e5.type !== "text");
    }(e3))) || e2.firstChild && e2.firstChild === e2.lastChild && e2.firstChild.type !== "text" && ts(e2.firstChild) && (!e2.lastChild.isTrailingSpaceSensitive || rs(e2.lastChild));
  }, forceNextEmptyLine: function(e2) {
    return Pi(e2) || e2.next && e2.sourceSpan.end && e2.sourceSpan.end.line + 1 < e2.next.sourceSpan.start.line;
  }, getLastDescendant: function e2(t2) {
    return t2.lastChild ? e2(t2.lastChild) : t2;
  }, getNodeCssStyleDisplay: function(e2, t2) {
    if (e2.prev && e2.prev.type === "comment") {
      const t3 = e2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (t3)
        return t3[1];
    }
    let r2 = false;
    if (e2.type === "element" && e2.namespace === "svg") {
      if (!function(e3, t3) {
        let r3 = e3;
        for (; r3; ) {
          if (t3(r3))
            return true;
          r3 = r3.parent;
        }
        return false;
      }(e2, (e3) => e3.fullName === "svg:foreignObject"))
        return e2.name === "svg" ? "inline-block" : "block";
      r2 = true;
    }
    switch (t2.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return t2.parser === "vue" && e2.parent && e2.parent.type === "root" ? "block" : e2.type === "element" && (!e2.namespace || r2 || as(e2)) && Mi[e2.name] || ji;
    }
  }, getNodeCssStyleWhiteSpace: us, hasPrettierIgnore: function(e2) {
    return e2.type !== "attribute" && (!!e2.parent && (typeof e2.index == "number" && e2.index !== 0 && function(e3) {
      return e3.type === "comment" && e3.value.trim() === "prettier-ignore";
    }(e2.parent.children[e2.index - 1])));
  }, inferScriptParser: function(e2, t2) {
    return e2.name !== "script" || e2.attrMap.src ? e2.name === "style" ? function(e3) {
      const { lang: t3 } = e3.attrMap;
      return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
    }(e2) : t2 && Ds(e2, t2) ? is$1(e2) || !("src" in e2.attrMap) && Ii(e2.attrMap.lang, t2) : void 0 : e2.attrMap.lang || e2.attrMap.type ? is$1(e2) : "babel";
  }, isVueCustomBlock: ps, isVueNonHtmlBlock: Ds, isVueSlotAttribute: function(e2) {
    const t2 = e2.fullName;
    return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
  }, isVueSfcBindingsAttribute: function(e2, t2) {
    const r2 = e2.parent;
    if (!hs(r2, t2))
      return false;
    const n2 = r2.fullName, i2 = e2.fullName;
    return n2 === "script" && i2 === "setup" || n2 === "style" && i2 === "vars";
  }, isDanglingSpaceSensitiveNode: function(e2) {
    return !(t2 = e2.cssDisplay, ss(t2) || t2 === "inline-block" || Qi(e2));
    var t2;
  }, isIndentationSensitiveNode: Ji, isLeadingSpaceSensitiveNode: function(e2, t2) {
    const r2 = function() {
      if (Pi(e2))
        return false;
      if ((e2.type === "text" || e2.type === "interpolation") && e2.prev && (e2.prev.type === "text" || e2.prev.type === "interpolation"))
        return true;
      if (!e2.parent || e2.parent.cssDisplay === "none")
        return false;
      if (os$1(e2.parent))
        return true;
      if (!e2.prev && (e2.parent.type === "root" || os$1(e2) && e2.parent || Qi(e2.parent) || ps(e2.parent, t2) || (r3 = e2.parent.cssDisplay, ss(r3) || r3 === "inline-block")))
        return false;
      var r3;
      if (e2.prev && !function(e3) {
        return !ss(e3);
      }(e2.prev.cssDisplay))
        return false;
      return true;
    }();
    return r2 && !e2.prev && e2.parent && e2.parent.tagDefinition && e2.parent.tagDefinition.ignoreFirstLf ? e2.type === "interpolation" : r2;
  }, isPreLikeNode: os$1, isScriptLikeTag: Qi, isTextLikeNode: function(e2) {
    return e2.type === "text" || e2.type === "comment";
  }, isTrailingSpaceSensitiveNode: function(e2, t2) {
    return !Pi(e2) && (!(e2.type !== "text" && e2.type !== "interpolation" || !e2.next || e2.next.type !== "text" && e2.next.type !== "interpolation") || !(!e2.parent || e2.parent.cssDisplay === "none") && (!!os$1(e2.parent) || !(!e2.next && (e2.parent.type === "root" || os$1(e2) && e2.parent || Qi(e2.parent) || ps(e2.parent, t2) || (r2 = e2.parent.cssDisplay, ss(r2) || r2 === "inline-block"))) && !(e2.next && !function(e3) {
      return !ss(e3);
    }(e2.next.cssDisplay))));
    var r2;
  }, isWhitespaceSensitiveNode: function(e2) {
    return Qi(e2) || e2.type === "interpolation" || Ji(e2);
  }, isUnknownNamespace: as, preferHardlineAsLeadingSpaces: function(e2) {
    return ns(e2) || e2.prev && Zi(e2.prev) || es(e2);
  }, preferHardlineAsTrailingSpaces: Zi, shouldPreserveContent: function(e2, t2) {
    return !(e2.type !== "ieConditionalComment" || !e2.lastChild || e2.lastChild.isSelfClosing || e2.lastChild.endSourceSpan) || (e2.type === "ieConditionalComment" && !e2.complete || (!(!os$1(e2) || !e2.children.some((e3) => e3.type !== "text" && e3.type !== "interpolation")) || !(!Ds(e2, t2) || Qi(e2) || e2.type === "interpolation")));
  }, unescapeQuoteEntities: function(e2) {
    return e2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }, getTextValueParts: function(e2, t2 = e2.value) {
    return e2.parent.isWhitespaceSensitive ? e2.parent.isIndentationSensitive ? qi(t2) : qi(cs(Wi(t2)), Li) : $i(Bi(Ri, t2.split(/[\t\n\f\r ]+/)));
  } };
  var ds = { hasPragma: function(e2) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e2);
  }, insertPragma: function(e2) {
    return "<!-- @format -->\n\n" + e2.replace(/^\s*\n/, "");
  } };
  const { isNonEmptyArray: gs } = $n, ms = { attrs: true, children: true };
  class Es {
    constructor(e2 = {}) {
      for (const [t2, r2] of Object.entries(e2))
        t2 in ms ? this._setNodes(t2, r2) : this[t2] = r2;
    }
    _setNodes(e2, t2) {
      t2 !== this[e2] && (this[e2] = function(e3, t3) {
        const r2 = e3.map((e4) => e4 instanceof Es ? e4.clone() : new Es(e4));
        let n2 = null, i2 = r2[0], s2 = r2[1] || null;
        for (let e4 = 0; e4 < r2.length; e4++)
          ys(i2, { index: e4, siblings: r2, prev: n2, next: s2, parent: t3 }), n2 = i2, i2 = s2, s2 = r2[e4 + 2] || null;
        return r2;
      }(t2, this), e2 === "attrs" && ys(this, { attrMap: Object.fromEntries(this[e2].map((e3) => [e3.fullName, e3.value])) }));
    }
    map(e2) {
      let t2 = null;
      for (const r2 in ms) {
        const n2 = this[r2];
        if (n2) {
          const i2 = Cs(n2, (t3) => t3.map(e2));
          t2 !== n2 && (t2 || (t2 = new Es()), t2._setNodes(r2, i2));
        }
      }
      if (t2) {
        for (const e4 in this)
          e4 in ms || (t2[e4] = this[e4]);
        const { index: e3, siblings: r2, prev: n2, next: i2, parent: s2 } = this;
        ys(t2, { index: e3, siblings: r2, prev: n2, next: i2, parent: s2 });
      }
      return e2(t2 || this);
    }
    walk(e2) {
      for (const t2 in ms) {
        const r2 = this[t2];
        if (r2)
          for (let t3 = 0; t3 < r2.length; t3++)
            r2[t3].walk(e2);
      }
      e2(this);
    }
    clone(e2) {
      return new Es(e2 ? Object.assign(Object.assign({}, this), e2) : this);
    }
    setChildren(e2) {
      this._setNodes("children", e2);
    }
    get firstChild() {
      return gs(this.children) ? this.children[0] : null;
    }
    get lastChild() {
      return gs(this.children) ? M$1(this.children) : null;
    }
    get rawName() {
      return this.hasExplicitNamespace ? this.fullName : this.name;
    }
    get fullName() {
      return this.namespace ? this.namespace + ":" + this.name : this.name;
    }
  }
  function Cs(e2, t2) {
    const r2 = e2.map(t2);
    return r2.some((t3, r3) => t3 !== e2[r3]) ? r2 : e2;
  }
  function ys(e2, t2) {
    const r2 = Object.fromEntries(Object.entries(t2).map(([e3, t3]) => [e3, { value: t3, enumerable: false }]));
    Object.defineProperties(e2, r2);
  }
  var bs = { Node: Es };
  const { ParseSourceSpan: Ss } = B$1, Ts = [{ regex: /^(\[if([^\]]*?)]>)(.*?)<!\s*\[endif]$/s, parse: function(e2, t2, r2) {
    const [, n2, i2, s2] = r2, o2 = "<!--".length + n2.length, a2 = e2.sourceSpan.start.moveBy(o2), u2 = a2.moveBy(s2.length), [c2, l2] = (() => {
      try {
        return [true, t2(s2, a2).children];
      } catch (e3) {
        return [false, [{ type: "text", value: s2, sourceSpan: new Ss(a2, u2) }]];
      }
    })();
    return { type: "ieConditionalComment", complete: c2, children: l2, condition: i2.trim().replace(/\s+/g, " "), sourceSpan: e2.sourceSpan, startSourceSpan: new Ss(e2.sourceSpan.start, a2), endSourceSpan: new Ss(u2, e2.sourceSpan.end) };
  } }, { regex: /^\[if([^\]]*?)]><!$/, parse: function(e2, t2, r2) {
    const [, n2] = r2;
    return { type: "ieConditionalStartComment", condition: n2.trim().replace(/\s+/g, " "), sourceSpan: e2.sourceSpan };
  } }, { regex: /^<!\s*\[endif]$/, parse: function(e2) {
    return { type: "ieConditionalEndComment", sourceSpan: e2.sourceSpan };
  } }];
  var _s = { parseIeConditionalComment: function(e2, t2) {
    if (e2.value)
      for (const { regex: r2, parse: n2 } of Ts) {
        const i2 = e2.value.match(r2);
        if (i2)
          return n2(e2, t2, i2);
      }
    return null;
  } };
  var vs = { locStart: function(e2) {
    return e2.sourceSpan.start.offset;
  }, locEnd: function(e2) {
    return e2.sourceSpan.end.offset;
  } }, As = t$1(function(e2, t2) {
    function r2(e3) {
      if (e3[0] != ":")
        return [null, e3];
      const t3 = e3.indexOf(":", 1);
      if (t3 == -1)
        throw new Error(`Unsupported format "${e3}" expecting ":namespace:name"`);
      return [e3.slice(1, t3), e3.slice(t3 + 1)];
    }
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", { value: true }), function(e3) {
      e3[e3.RAW_TEXT = 0] = "RAW_TEXT", e3[e3.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e3[e3.PARSABLE_DATA = 2] = "PARSABLE_DATA";
    }(t2.TagContentType || (t2.TagContentType = {})), t2.splitNsName = r2, t2.isNgContainer = function(e3) {
      return r2(e3)[1] === "ng-container";
    }, t2.isNgContent = function(e3) {
      return r2(e3)[1] === "ng-content";
    }, t2.isNgTemplate = function(e3) {
      return r2(e3)[1] === "ng-template";
    }, t2.getNsPrefix = function(e3) {
      return e3 === null ? null : r2(e3)[0];
    }, t2.mergeNsAndName = function(e3, t3) {
      return e3 ? `:${e3}:${t3}` : t3;
    }, t2.NAMED_ENTITIES = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", GT: ">", Gt: "\u226B", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", LT: "<", Lt: "\u226A", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" }, t2.NGSP_UNICODE = "\uE500", t2.NAMED_ENTITIES.ngsp = t2.NGSP_UNICODE;
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class Fs {
    constructor({ closedByChildren: e2, implicitNamespacePrefix: t2, contentType: r2 = As.TagContentType.PARSABLE_DATA, closedByParent: n2 = false, isVoid: i2 = false, ignoreFirstLf: s2 = false } = {}) {
      this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, e2 && e2.length > 0 && e2.forEach((e3) => this.closedByChildren[e3] = true), this.isVoid = i2, this.closedByParent = n2 || i2, this.implicitNamespacePrefix = t2 || null, this.contentType = r2, this.ignoreFirstLf = s2;
    }
    isClosedByChild(e2) {
      return this.isVoid || e2.toLowerCase() in this.closedByChildren;
    }
  }
  var ws = Fs;
  let ks, Ns;
  var Os = function(e2) {
    return Ns || (ks = new Fs(), Ns = { base: new Fs({ isVoid: true }), meta: new Fs({ isVoid: true }), area: new Fs({ isVoid: true }), embed: new Fs({ isVoid: true }), link: new Fs({ isVoid: true }), img: new Fs({ isVoid: true }), input: new Fs({ isVoid: true }), param: new Fs({ isVoid: true }), hr: new Fs({ isVoid: true }), br: new Fs({ isVoid: true }), source: new Fs({ isVoid: true }), track: new Fs({ isVoid: true }), wbr: new Fs({ isVoid: true }), p: new Fs({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new Fs({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Fs({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new Fs({ closedByChildren: ["tbody"], closedByParent: true }), tr: new Fs({ closedByChildren: ["tr"], closedByParent: true }), td: new Fs({ closedByChildren: ["td", "th"], closedByParent: true }), th: new Fs({ closedByChildren: ["td", "th"], closedByParent: true }), col: new Fs({ isVoid: true }), svg: new Fs({ implicitNamespacePrefix: "svg" }), math: new Fs({ implicitNamespacePrefix: "math" }), li: new Fs({ closedByChildren: ["li"], closedByParent: true }), dt: new Fs({ closedByChildren: ["dt", "dd"] }), dd: new Fs({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new Fs({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new Fs({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new Fs({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new Fs({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new Fs({ closedByChildren: ["optgroup"], closedByParent: true }), option: new Fs({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new Fs({ ignoreFirstLf: true }), listing: new Fs({ ignoreFirstLf: true }), style: new Fs({ contentType: As.TagContentType.RAW_TEXT }), script: new Fs({ contentType: As.TagContentType.RAW_TEXT }), title: new Fs({ contentType: As.TagContentType.ESCAPABLE_RAW_TEXT }), textarea: new Fs({ contentType: As.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), Ns[e2] || ks;
  }, xs = Object.defineProperty({ HtmlTagDefinition: ws, getHtmlTagDefinition: Os }, "__esModule", { value: true });
  var Is$1 = class {
    constructor(e2, t2 = -1) {
      this.path = e2, this.position = t2;
    }
    get empty() {
      return !this.path || !this.path.length;
    }
    get head() {
      return this.path[0];
    }
    get tail() {
      return this.path[this.path.length - 1];
    }
    parentOf(e2) {
      return e2 && this.path[this.path.indexOf(e2) - 1];
    }
    childOf(e2) {
      return this.path[this.path.indexOf(e2) + 1];
    }
    first(e2) {
      for (let t2 = this.path.length - 1; t2 >= 0; t2--) {
        let r2 = this.path[t2];
        if (r2 instanceof e2)
          return r2;
      }
    }
    push(e2) {
      this.path.push(e2);
    }
    pop() {
      return this.path.pop();
    }
  }, Ps = Object.defineProperty({ AstPath: Is$1 }, "__esModule", { value: true });
  var Rs = class {
    constructor(e2, t2, r2) {
      this.value = e2, this.sourceSpan = t2, this.i18n = r2, this.type = "text";
    }
    visit(e2, t2) {
      return e2.visitText(this, t2);
    }
  };
  var Ls = class {
    constructor(e2, t2) {
      this.value = e2, this.sourceSpan = t2, this.type = "cdata";
    }
    visit(e2, t2) {
      return e2.visitCdata(this, t2);
    }
  };
  var Bs = class {
    constructor(e2, t2, r2, n2, i2, s2) {
      this.switchValue = e2, this.type = t2, this.cases = r2, this.sourceSpan = n2, this.switchValueSourceSpan = i2, this.i18n = s2;
    }
    visit(e2, t2) {
      return e2.visitExpansion(this, t2);
    }
  };
  var $s = class {
    constructor(e2, t2, r2, n2, i2) {
      this.value = e2, this.expression = t2, this.sourceSpan = r2, this.valueSourceSpan = n2, this.expSourceSpan = i2;
    }
    visit(e2, t2) {
      return e2.visitExpansionCase(this, t2);
    }
  };
  var qs = class {
    constructor(e2, t2, r2, n2 = null, i2 = null, s2 = null) {
      this.name = e2, this.value = t2, this.sourceSpan = r2, this.valueSpan = n2, this.nameSpan = i2, this.i18n = s2, this.type = "attribute";
    }
    visit(e2, t2) {
      return e2.visitAttribute(this, t2);
    }
  };
  class Ms {
    constructor(e2, t2, r2, n2, i2 = null, s2 = null, o2 = null, a2 = null) {
      this.name = e2, this.attrs = t2, this.children = r2, this.sourceSpan = n2, this.startSourceSpan = i2, this.endSourceSpan = s2, this.nameSpan = o2, this.i18n = a2, this.type = "element";
    }
    visit(e2, t2) {
      return e2.visitElement(this, t2);
    }
  }
  var js = Ms;
  var Us = class {
    constructor(e2, t2) {
      this.value = e2, this.sourceSpan = t2, this.type = "comment";
    }
    visit(e2, t2) {
      return e2.visitComment(this, t2);
    }
  };
  var Gs = class {
    constructor(e2, t2) {
      this.value = e2, this.sourceSpan = t2, this.type = "docType";
    }
    visit(e2, t2) {
      return e2.visitDocType(this, t2);
    }
  };
  function Vs(e2, t2, r2 = null) {
    const n2 = [], i2 = e2.visit ? (t3) => e2.visit(t3, r2) || t3.visit(e2, r2) : (t3) => t3.visit(e2, r2);
    return t2.forEach((e3) => {
      const t3 = i2(e3);
      t3 && n2.push(t3);
    }), n2;
  }
  var Hs = Vs;
  class Xs {
    constructor() {
    }
    visitElement(e2, t2) {
      this.visitChildren(t2, (t3) => {
        t3(e2.attrs), t3(e2.children);
      });
    }
    visitAttribute(e2, t2) {
    }
    visitText(e2, t2) {
    }
    visitCdata(e2, t2) {
    }
    visitComment(e2, t2) {
    }
    visitDocType(e2, t2) {
    }
    visitExpansion(e2, t2) {
      return this.visitChildren(t2, (t3) => {
        t3(e2.cases);
      });
    }
    visitExpansionCase(e2, t2) {
    }
    visitChildren(e2, t2) {
      let r2 = [], n2 = this;
      return t2(function(t3) {
        t3 && r2.push(Vs(n2, t3, e2));
      }), Array.prototype.concat.apply([], r2);
    }
  }
  var zs = Xs;
  function Ws(e2) {
    const t2 = e2.sourceSpan.start.offset;
    let r2 = e2.sourceSpan.end.offset;
    return e2 instanceof Ms && (e2.endSourceSpan ? r2 = e2.endSourceSpan.end.offset : e2.children && e2.children.length && (r2 = Ws(e2.children[e2.children.length - 1]).end)), { start: t2, end: r2 };
  }
  var Ys = function(e2, t2) {
    const r2 = [];
    return Vs(new class extends Xs {
      visit(e3, n2) {
        const i2 = Ws(e3);
        if (!(i2.start <= t2 && t2 < i2.end))
          return true;
        r2.push(e3);
      }
    }(), e2), new Ps.AstPath(r2, t2);
  }, Qs = Object.defineProperty({ Text: Rs, CDATA: Ls, Expansion: Bs, ExpansionCase: $s, Attribute: qs, Element: js, Comment: Us, DocType: Gs, visitAll: Hs, RecursiveVisitor: zs, findNode: Ys }, "__esModule", { value: true });
  var Js = function(e2, t2) {
    if (t2 != null) {
      if (!Array.isArray(t2))
        throw new Error(`Expected '${e2}' to be an array of strings.`);
      for (let r2 = 0; r2 < t2.length; r2 += 1)
        if (typeof t2[r2] != "string")
          throw new Error(`Expected '${e2}' to be an array of strings.`);
    }
  };
  const Ks = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  var Zs = function(e2, t2) {
    if (!(t2 == null || Array.isArray(t2) && t2.length == 2))
      throw new Error(`Expected '${e2}' to be an array, [start, end].`);
    if (t2 != null) {
      const e3 = t2[0], r2 = t2[1];
      Ks.forEach((t3) => {
        if (t3.test(e3) || t3.test(r2))
          throw new Error(`['${e3}', '${r2}'] contains unusable interpolation symbol.`);
      });
    }
  }, eo = Object.defineProperty({ assertArrayOfStrings: Js, assertInterpolationSymbols: Zs }, "__esModule", { value: true }), to = t$1(function(e2, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", { value: true });
    class r2 {
      constructor(e3, t3) {
        this.start = e3, this.end = t3;
      }
      static fromArray(e3) {
        return e3 ? (eo.assertInterpolationSymbols("interpolation", e3), new r2(e3[0], e3[1])) : t2.DEFAULT_INTERPOLATION_CONFIG;
      }
    }
    t2.InterpolationConfig = r2, t2.DEFAULT_INTERPOLATION_CONFIG = new r2("{{", "}}");
  }), ro = t$1(function(e2, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", { value: true });
    const n2 = r$1;
    var i2;
    !function(e3) {
      e3[e3.TAG_OPEN_START = 0] = "TAG_OPEN_START", e3[e3.TAG_OPEN_END = 1] = "TAG_OPEN_END", e3[e3.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e3[e3.TAG_CLOSE = 3] = "TAG_CLOSE", e3[e3.TEXT = 4] = "TEXT", e3[e3.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", e3[e3.RAW_TEXT = 6] = "RAW_TEXT", e3[e3.COMMENT_START = 7] = "COMMENT_START", e3[e3.COMMENT_END = 8] = "COMMENT_END", e3[e3.CDATA_START = 9] = "CDATA_START", e3[e3.CDATA_END = 10] = "CDATA_END", e3[e3.ATTR_NAME = 11] = "ATTR_NAME", e3[e3.ATTR_QUOTE = 12] = "ATTR_QUOTE", e3[e3.ATTR_VALUE = 13] = "ATTR_VALUE", e3[e3.DOC_TYPE_START = 14] = "DOC_TYPE_START", e3[e3.DOC_TYPE_END = 15] = "DOC_TYPE_END", e3[e3.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e3[e3.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e3[e3.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e3[e3.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e3[e3.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e3[e3.EOF = 21] = "EOF";
    }(i2 = t2.TokenType || (t2.TokenType = {}));
    class s2 {
      constructor(e3, t3, r2) {
        this.type = e3, this.parts = t3, this.sourceSpan = r2;
      }
    }
    t2.Token = s2;
    class o2 extends B$1.ParseError {
      constructor(e3, t3, r2) {
        super(r2, e3), this.tokenType = t3;
      }
    }
    t2.TokenError = o2;
    class a2 {
      constructor(e3, t3) {
        this.tokens = e3, this.errors = t3;
      }
    }
    t2.TokenizeResult = a2, t2.tokenize = function(e3, t3, r2, n3 = {}) {
      return new h2(new B$1.ParseSourceFile(e3, t3), r2, n3).tokenize();
    };
    const u2 = /\r\n?/g;
    function c2(e3) {
      return `Unexpected character "${e3 === n2.$EOF ? "EOF" : String.fromCharCode(e3)}"`;
    }
    function l2(e3) {
      return `Unknown entity "${e3}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
    }
    class p2 {
      constructor(e3) {
        this.error = e3;
      }
    }
    class h2 {
      constructor(e3, t3, r2) {
        this._getTagContentType = t3, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = r2.tokenizeExpansionForms || false, this._interpolationConfig = r2.interpolationConfig || to.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = r2.leadingTriviaChars && r2.leadingTriviaChars.map((e4) => e4.codePointAt(0) || 0), this._canSelfClose = r2.canSelfClose || false, this._allowHtmComponentClosingTags = r2.allowHtmComponentClosingTags || false;
        const n3 = r2.range || { endPos: e3.content.length, startPos: 0, startLine: 0, startCol: 0 };
        this._cursor = r2.escapedString ? new C2(e3, n3) : new E2(e3, n3);
        try {
          this._cursor.init();
        } catch (e4) {
          this.handleError(e4);
        }
      }
      _processCarriageReturns(e3) {
        return e3.replace(u2, "\n");
      }
      tokenize() {
        for (; this._cursor.peek() !== n2.$EOF; ) {
          const e3 = this._cursor.clone();
          try {
            if (this._attemptCharCode(n2.$LT))
              if (this._attemptCharCode(n2.$BANG))
                this._attemptStr("[CDATA[") ? this._consumeCdata(e3) : this._attemptStr("--") ? this._consumeComment(e3) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e3) : this._consumeBogusComment(e3);
              else if (this._attemptCharCode(n2.$SLASH))
                this._consumeTagClose(e3);
              else {
                const t3 = this._cursor.clone();
                this._attemptCharCode(n2.$QUESTION) ? (this._cursor = t3, this._consumeBogusComment(e3)) : this._consumeTagOpen(e3);
              }
            else
              this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
          } catch (e4) {
            this.handleError(e4);
          }
        }
        return this._beginToken(i2.EOF), this._endToken([]), new a2(function(e3) {
          const t3 = [];
          let r2;
          for (let n3 = 0; n3 < e3.length; n3++) {
            const s3 = e3[n3];
            r2 && r2.type == i2.TEXT && s3.type == i2.TEXT ? (r2.parts[0] += s3.parts[0], r2.sourceSpan.end = s3.sourceSpan.end) : (r2 = s3, t3.push(r2));
          }
          return t3;
        }(this.tokens), this.errors);
      }
      _tokenizeExpansionForm() {
        if (this.isExpansionFormStart())
          return this._consumeExpansionFormStart(), true;
        if (((e3 = this._cursor.peek()) === n2.$EQ || n2.isAsciiLetter(e3) || n2.isDigit(e3)) && this._isInExpansionForm())
          return this._consumeExpansionCaseStart(), true;
        var e3;
        if (this._cursor.peek() === n2.$RBRACE) {
          if (this._isInExpansionCase())
            return this._consumeExpansionCaseEnd(), true;
          if (this._isInExpansionForm())
            return this._consumeExpansionFormEnd(), true;
        }
        return false;
      }
      _beginToken(e3, t3 = this._cursor.clone()) {
        this._currentTokenStart = t3, this._currentTokenType = e3;
      }
      _endToken(e3, t3 = this._cursor.clone()) {
        if (this._currentTokenStart === null)
          throw new o2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t3));
        if (this._currentTokenType === null)
          throw new o2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
        const r2 = new s2(this._currentTokenType, e3, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
        return this.tokens.push(r2), this._currentTokenStart = null, this._currentTokenType = null, r2;
      }
      _createError(e3, t3) {
        this._isInExpansionForm() && (e3 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
        const r2 = new o2(e3, this._currentTokenType, t3);
        return this._currentTokenStart = null, this._currentTokenType = null, new p2(r2);
      }
      handleError(e3) {
        if (e3 instanceof y2 && (e3 = this._createError(e3.msg, this._cursor.getSpan(e3.cursor))), !(e3 instanceof p2))
          throw e3;
        this.errors.push(e3.error);
      }
      _attemptCharCode(e3) {
        return this._cursor.peek() === e3 && (this._cursor.advance(), true);
      }
      _attemptCharCodeCaseInsensitive(e3) {
        return t3 = this._cursor.peek(), r2 = e3, m2(t3) == m2(r2) && (this._cursor.advance(), true);
        var t3, r2;
      }
      _requireCharCode(e3) {
        const t3 = this._cursor.clone();
        if (!this._attemptCharCode(e3))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
      }
      _attemptStr(e3) {
        const t3 = e3.length;
        if (this._cursor.charsLeft() < t3)
          return false;
        const r2 = this._cursor.clone();
        for (let n3 = 0; n3 < t3; n3++)
          if (!this._attemptCharCode(e3.charCodeAt(n3)))
            return this._cursor = r2, false;
        return true;
      }
      _attemptStrCaseInsensitive(e3) {
        for (let t3 = 0; t3 < e3.length; t3++)
          if (!this._attemptCharCodeCaseInsensitive(e3.charCodeAt(t3)))
            return false;
        return true;
      }
      _requireStr(e3) {
        const t3 = this._cursor.clone();
        if (!this._attemptStr(e3))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
      }
      _requireStrCaseInsensitive(e3) {
        const t3 = this._cursor.clone();
        if (!this._attemptStrCaseInsensitive(e3))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
      }
      _attemptCharCodeUntilFn(e3) {
        for (; !e3(this._cursor.peek()); )
          this._cursor.advance();
      }
      _requireCharCodeUntilFn(e3, t3) {
        const r2 = this._cursor.clone();
        this._attemptCharCodeUntilFn(e3);
        if (this._cursor.clone().diff(r2) < t3)
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(r2));
      }
      _attemptUntilChar(e3) {
        for (; this._cursor.peek() !== e3; )
          this._cursor.advance();
      }
      _readChar(e3) {
        if (e3 && this._cursor.peek() === n2.$AMPERSAND)
          return this._decodeEntity();
        {
          const e4 = String.fromCodePoint(this._cursor.peek());
          return this._cursor.advance(), e4;
        }
      }
      _decodeEntity() {
        const e3 = this._cursor.clone();
        if (this._cursor.advance(), !this._attemptCharCode(n2.$HASH)) {
          const t3 = this._cursor.clone();
          if (this._attemptCharCodeUntilFn(g2), this._cursor.peek() != n2.$SEMICOLON)
            return this._cursor = t3, "&";
          const r2 = this._cursor.getChars(t3);
          this._cursor.advance();
          const i3 = As.NAMED_ENTITIES[r2];
          if (!i3)
            throw this._createError(l2(r2), this._cursor.getSpan(e3));
          return i3;
        }
        {
          const t3 = this._attemptCharCode(n2.$x) || this._attemptCharCode(n2.$X), r2 = this._cursor.clone();
          if (this._attemptCharCodeUntilFn(d2), this._cursor.peek() != n2.$SEMICOLON)
            throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan());
          const i3 = this._cursor.getChars(r2);
          this._cursor.advance();
          try {
            const e4 = parseInt(i3, t3 ? 16 : 10);
            return String.fromCharCode(e4);
          } catch (t4) {
            throw this._createError(l2(this._cursor.getChars(e3)), this._cursor.getSpan());
          }
        }
      }
      _consumeRawText(e3, t3) {
        this._beginToken(e3 ? i2.ESCAPABLE_RAW_TEXT : i2.RAW_TEXT);
        const r2 = [];
        for (; ; ) {
          const n3 = this._cursor.clone(), i3 = t3();
          if (this._cursor = n3, i3)
            break;
          r2.push(this._readChar(e3));
        }
        return this._endToken([this._processCarriageReturns(r2.join(""))]);
      }
      _consumeComment(e3) {
        this._beginToken(i2.COMMENT_START, e3), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(i2.COMMENT_END), this._requireStr("-->"), this._endToken([]);
      }
      _consumeBogusComment(e3) {
        this._beginToken(i2.COMMENT_START, e3), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.COMMENT_END), this._cursor.advance(), this._endToken([]);
      }
      _consumeCdata(e3) {
        this._beginToken(i2.CDATA_START, e3), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(i2.CDATA_END), this._requireStr("]]>"), this._endToken([]);
      }
      _consumeDocType(e3) {
        this._beginToken(i2.DOC_TYPE_START, e3), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
      }
      _consumePrefixAndName() {
        const e3 = this._cursor.clone();
        let t3 = "";
        for (; this._cursor.peek() !== n2.$COLON && !(((r2 = this._cursor.peek()) < n2.$a || n2.$z < r2) && (r2 < n2.$A || n2.$Z < r2) && (r2 < n2.$0 || r2 > n2.$9)); )
          this._cursor.advance();
        var r2;
        let i3;
        this._cursor.peek() === n2.$COLON ? (t3 = this._cursor.getChars(e3), this._cursor.advance(), i3 = this._cursor.clone()) : i3 = e3, this._requireCharCodeUntilFn(f2, t3 === "" ? 0 : 1);
        return [t3, this._cursor.getChars(i3)];
      }
      _consumeTagOpen(e3) {
        let t3, r2, s3, o3 = this.tokens.length;
        const a3 = this._cursor.clone(), u3 = [];
        try {
          if (!n2.isAsciiLetter(this._cursor.peek()))
            throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(e3));
          for (s3 = this._consumeTagOpenStart(e3), r2 = s3.parts[0], t3 = s3.parts[1], this._attemptCharCodeUntilFn(D2); this._cursor.peek() !== n2.$SLASH && this._cursor.peek() !== n2.$GT; ) {
            const [e4, t4] = this._consumeAttributeName();
            if (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$EQ)) {
              this._attemptCharCodeUntilFn(D2);
              const r3 = this._consumeAttributeValue();
              u3.push({ prefix: e4, name: t4, value: r3 });
            } else
              u3.push({ prefix: e4, name: t4 });
            this._attemptCharCodeUntilFn(D2);
          }
          this._consumeTagOpenEnd();
        } catch (t4) {
          if (t4 instanceof p2)
            return this._cursor = a3, s3 && (this.tokens.length = o3), this._beginToken(i2.TEXT, e3), void this._endToken(["<"]);
          throw t4;
        }
        if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === i2.TAG_OPEN_END_VOID)
          return;
        const l3 = this._getTagContentType(t3, r2, this._fullNameStack.length > 0, u3);
        this._handleFullNameStackForTagOpen(r2, t3), l3 === As.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(r2, t3, false) : l3 === As.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r2, t3, true);
      }
      _consumeRawTextWithTagClose(e3, t3, r2) {
        this._consumeRawText(r2, () => !!this._attemptCharCode(n2.$LT) && (!!this._attemptCharCode(n2.$SLASH) && (this._attemptCharCodeUntilFn(D2), !!this._attemptStrCaseInsensitive(e3 ? `${e3}:${t3}` : t3) && (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$GT))))), this._beginToken(i2.TAG_CLOSE), this._requireCharCodeUntilFn((e4) => e4 === n2.$GT, 3), this._cursor.advance(), this._endToken([e3, t3]), this._handleFullNameStackForTagClose(e3, t3);
      }
      _consumeTagOpenStart(e3) {
        this._beginToken(i2.TAG_OPEN_START, e3);
        const t3 = this._consumePrefixAndName();
        return this._endToken(t3);
      }
      _consumeAttributeName() {
        const e3 = this._cursor.peek();
        if (e3 === n2.$SQ || e3 === n2.$DQ)
          throw this._createError(c2(e3), this._cursor.getSpan());
        this._beginToken(i2.ATTR_NAME);
        const t3 = this._consumePrefixAndName();
        return this._endToken(t3), t3;
      }
      _consumeAttributeValue() {
        let e3;
        if (this._cursor.peek() === n2.$SQ || this._cursor.peek() === n2.$DQ) {
          this._beginToken(i2.ATTR_QUOTE);
          const t3 = this._cursor.peek();
          this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]), this._beginToken(i2.ATTR_VALUE);
          const r2 = [];
          for (; this._cursor.peek() !== t3; )
            r2.push(this._readChar(true));
          e3 = this._processCarriageReturns(r2.join("")), this._endToken([e3]), this._beginToken(i2.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]);
        } else {
          this._beginToken(i2.ATTR_VALUE);
          const t3 = this._cursor.clone();
          this._requireCharCodeUntilFn(f2, 1), e3 = this._processCarriageReturns(this._cursor.getChars(t3)), this._endToken([e3]);
        }
        return e3;
      }
      _consumeTagOpenEnd() {
        const e3 = this._attemptCharCode(n2.$SLASH) ? i2.TAG_OPEN_END_VOID : i2.TAG_OPEN_END;
        this._beginToken(e3), this._requireCharCode(n2.$GT), this._endToken([]);
      }
      _consumeTagClose(e3) {
        if (this._beginToken(i2.TAG_CLOSE, e3), this._attemptCharCodeUntilFn(D2), this._allowHtmComponentClosingTags && this._attemptCharCode(n2.$SLASH))
          this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([]);
        else {
          const [e4, t3] = this._consumePrefixAndName();
          this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([e4, t3]), this._handleFullNameStackForTagClose(e4, t3);
        }
      }
      _consumeExpansionFormStart() {
        this._beginToken(i2.EXPANSION_FORM_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._expansionCaseStack.push(i2.EXPANSION_FORM_START), this._beginToken(i2.RAW_TEXT);
        const e3 = this._readUntil(n2.$COMMA);
        this._endToken([e3]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.RAW_TEXT);
        const t3 = this._readUntil(n2.$COMMA);
        this._endToken([t3]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2);
      }
      _consumeExpansionCaseStart() {
        this._beginToken(i2.EXPANSION_CASE_VALUE);
        const e3 = this._readUntil(n2.$LBRACE).trim();
        this._endToken([e3]), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.EXPANSION_CASE_EXP_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.push(i2.EXPANSION_CASE_EXP_START);
      }
      _consumeExpansionCaseEnd() {
        this._beginToken(i2.EXPANSION_CASE_EXP_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.pop();
      }
      _consumeExpansionFormEnd() {
        this._beginToken(i2.EXPANSION_FORM_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
      }
      _consumeText() {
        const e3 = this._cursor.clone();
        this._beginToken(i2.TEXT, e3);
        const t3 = [];
        do {
          this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t3.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t3.push(this._interpolationConfig.end), this._inInterpolation = false) : t3.push(this._readChar(true));
        } while (!this._isTextEnd());
        this._endToken([this._processCarriageReturns(t3.join(""))]);
      }
      _isTextEnd() {
        if (this._cursor.peek() === n2.$LT || this._cursor.peek() === n2.$EOF)
          return true;
        if (this._tokenizeIcu && !this._inInterpolation) {
          if (this.isExpansionFormStart())
            return true;
          if (this._cursor.peek() === n2.$RBRACE && this._isInExpansionCase())
            return true;
        }
        return false;
      }
      _readUntil(e3) {
        const t3 = this._cursor.clone();
        return this._attemptUntilChar(e3), this._cursor.getChars(t3);
      }
      _isInExpansionCase() {
        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_CASE_EXP_START;
      }
      _isInExpansionForm() {
        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_FORM_START;
      }
      isExpansionFormStart() {
        if (this._cursor.peek() !== n2.$LBRACE)
          return false;
        if (this._interpolationConfig) {
          const e3 = this._cursor.clone(), t3 = this._attemptStr(this._interpolationConfig.start);
          return this._cursor = e3, !t3;
        }
        return true;
      }
      _handleFullNameStackForTagOpen(e3, t3) {
        const r2 = As.mergeNsAndName(e3, t3);
        this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] !== r2 || this._fullNameStack.push(r2);
      }
      _handleFullNameStackForTagClose(e3, t3) {
        const r2 = As.mergeNsAndName(e3, t3);
        this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === r2 && this._fullNameStack.pop();
      }
    }
    function D2(e3) {
      return !n2.isWhitespace(e3) || e3 === n2.$EOF;
    }
    function f2(e3) {
      return n2.isWhitespace(e3) || e3 === n2.$GT || e3 === n2.$SLASH || e3 === n2.$SQ || e3 === n2.$DQ || e3 === n2.$EQ;
    }
    function d2(e3) {
      return e3 == n2.$SEMICOLON || e3 == n2.$EOF || !n2.isAsciiHexDigit(e3);
    }
    function g2(e3) {
      return e3 == n2.$SEMICOLON || e3 == n2.$EOF || !n2.isAsciiLetter(e3);
    }
    function m2(e3) {
      return e3 >= n2.$a && e3 <= n2.$z ? e3 - n2.$a + n2.$A : e3;
    }
    class E2 {
      constructor(e3, t3) {
        if (e3 instanceof E2)
          this.file = e3.file, this.input = e3.input, this.end = e3.end, this.state = Object.assign({}, e3.state);
        else {
          if (!t3)
            throw new Error("Programming error: the range argument must be provided with a file argument.");
          this.file = e3, this.input = e3.content, this.end = t3.endPos, this.state = { peek: -1, offset: t3.startPos, line: t3.startLine, column: t3.startCol };
        }
      }
      clone() {
        return new E2(this);
      }
      peek() {
        return this.state.peek;
      }
      charsLeft() {
        return this.end - this.state.offset;
      }
      diff(e3) {
        return this.state.offset - e3.state.offset;
      }
      advance() {
        this.advanceState(this.state);
      }
      init() {
        this.updatePeek(this.state);
      }
      getSpan(e3, t3) {
        if (e3 = e3 || this, t3)
          for (e3 = e3.clone(); this.diff(e3) > 0 && t3.indexOf(e3.peek()) !== -1; )
            e3.advance();
        return new B$1.ParseSourceSpan(new B$1.ParseLocation(e3.file, e3.state.offset, e3.state.line, e3.state.column), new B$1.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
      }
      getChars(e3) {
        return this.input.substring(e3.state.offset, this.state.offset);
      }
      charAt(e3) {
        return this.input.charCodeAt(e3);
      }
      advanceState(e3) {
        if (e3.offset >= this.end)
          throw this.state = e3, new y2('Unexpected character "EOF"', this);
        const t3 = this.charAt(e3.offset);
        t3 === n2.$LF ? (e3.line++, e3.column = 0) : n2.isNewLine(t3) || e3.column++, e3.offset++, this.updatePeek(e3);
      }
      updatePeek(e3) {
        e3.peek = e3.offset >= this.end ? n2.$EOF : this.charAt(e3.offset);
      }
    }
    class C2 extends E2 {
      constructor(e3, t3) {
        e3 instanceof C2 ? (super(e3), this.internalState = Object.assign({}, e3.internalState)) : (super(e3, t3), this.internalState = this.state);
      }
      advance() {
        this.state = this.internalState, super.advance(), this.processEscapeSequence();
      }
      init() {
        super.init(), this.processEscapeSequence();
      }
      clone() {
        return new C2(this);
      }
      getChars(e3) {
        const t3 = e3.clone();
        let r2 = "";
        for (; t3.internalState.offset < this.internalState.offset; )
          r2 += String.fromCodePoint(t3.peek()), t3.advance();
        return r2;
      }
      processEscapeSequence() {
        const e3 = () => this.internalState.peek;
        if (e3() === n2.$BACKSLASH)
          if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), e3() === n2.$n)
            this.state.peek = n2.$LF;
          else if (e3() === n2.$r)
            this.state.peek = n2.$CR;
          else if (e3() === n2.$v)
            this.state.peek = n2.$VTAB;
          else if (e3() === n2.$t)
            this.state.peek = n2.$TAB;
          else if (e3() === n2.$b)
            this.state.peek = n2.$BSPACE;
          else if (e3() === n2.$f)
            this.state.peek = n2.$FF;
          else if (e3() === n2.$u)
            if (this.advanceState(this.internalState), e3() === n2.$LBRACE) {
              this.advanceState(this.internalState);
              const t3 = this.clone();
              let r2 = 0;
              for (; e3() !== n2.$RBRACE; )
                this.advanceState(this.internalState), r2++;
              this.state.peek = this.decodeHexDigits(t3, r2);
            } else {
              const e4 = this.clone();
              this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e4, 4);
            }
          else if (e3() === n2.$x) {
            this.advanceState(this.internalState);
            const e4 = this.clone();
            this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e4, 2);
          } else if (n2.isOctalDigit(e3())) {
            let t3 = "", r2 = 0, i3 = this.clone();
            for (; n2.isOctalDigit(e3()) && r2 < 3; )
              i3 = this.clone(), t3 += String.fromCodePoint(e3()), this.advanceState(this.internalState), r2++;
            this.state.peek = parseInt(t3, 8), this.internalState = i3.internalState;
          } else
            n2.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
      }
      decodeHexDigits(e3, t3) {
        const r2 = this.input.substr(e3.internalState.offset, t3), n3 = parseInt(r2, 16);
        if (isNaN(n3))
          throw e3.state = e3.internalState, new y2("Invalid hexadecimal escape sequence", e3);
        return n3;
      }
    }
    class y2 {
      constructor(e3, t3) {
        this.msg = e3, this.cursor = t3;
      }
    }
    t2.CursorError = y2;
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class no extends B$1.ParseError {
    constructor(e2, t2, r2) {
      super(t2, r2), this.elementName = e2;
    }
    static create(e2, t2, r2) {
      return new no(e2, t2, r2);
    }
  }
  var io = no;
  class so {
    constructor(e2, t2) {
      this.rootNodes = e2, this.errors = t2;
    }
  }
  var oo = so;
  var ao = class {
    constructor(e2) {
      this.getTagDefinition = e2;
    }
    parse(e2, t2, r2, n2 = false, i2) {
      const s2 = (e3) => (t3, ...r3) => e3(t3.toLowerCase(), ...r3), o2 = n2 ? this.getTagDefinition : s2(this.getTagDefinition), a2 = (e3) => o2(e3).contentType, u2 = n2 ? i2 : s2(i2), c2 = i2 ? (e3, t3, r3, n3) => {
        const i3 = u2(e3, t3, r3, n3);
        return i3 !== void 0 ? i3 : a2(e3);
      } : a2, l2 = ro.tokenize(e2, t2, c2, r2), p2 = r2 && r2.canSelfClose || false, h2 = r2 && r2.allowHtmComponentClosingTags || false, D2 = new uo(l2.tokens, o2, p2, h2, n2).build();
      return new so(D2.rootNodes, l2.errors.concat(D2.errors));
    }
  };
  class uo {
    constructor(e2, t2, r2, n2, i2) {
      this.tokens = e2, this.getTagDefinition = t2, this.canSelfClose = r2, this.allowHtmComponentClosingTags = n2, this.isTagNameCaseSensitive = i2, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
    }
    build() {
      for (; this._peek.type !== ro.TokenType.EOF; )
        this._peek.type === ro.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === ro.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === ro.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === ro.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === ro.TokenType.TEXT || this._peek.type === ro.TokenType.RAW_TEXT || this._peek.type === ro.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === ro.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === ro.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
      return new so(this._rootNodes, this._errors);
    }
    _advance() {
      const e2 = this._peek;
      return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e2;
    }
    _advanceIf(e2) {
      return this._peek.type === e2 ? this._advance() : null;
    }
    _consumeCdata(e2) {
      const t2 = this._advance(), r2 = this._getText(t2), n2 = this._advanceIf(ro.TokenType.CDATA_END);
      this._addToParent(new Qs.CDATA(r2, new B$1.ParseSourceSpan(e2.sourceSpan.start, (n2 || t2).sourceSpan.end)));
    }
    _consumeComment(e2) {
      const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.COMMENT_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e2.sourceSpan.start, (r2 || t2 || e2).sourceSpan.end);
      this._addToParent(new Qs.Comment(n2, i2));
    }
    _consumeDocType(e2) {
      const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.DOC_TYPE_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e2.sourceSpan.start, (r2 || t2 || e2).sourceSpan.end);
      this._addToParent(new Qs.DocType(n2, i2));
    }
    _consumeExpansion(e2) {
      const t2 = this._advance(), r2 = this._advance(), n2 = [];
      for (; this._peek.type === ro.TokenType.EXPANSION_CASE_VALUE; ) {
        const e3 = this._parseExpansionCase();
        if (!e3)
          return;
        n2.push(e3);
      }
      if (this._peek.type !== ro.TokenType.EXPANSION_FORM_END)
        return void this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      const i2 = new B$1.ParseSourceSpan(e2.sourceSpan.start, this._peek.sourceSpan.end);
      this._addToParent(new Qs.Expansion(t2.parts[0], r2.parts[0], n2, i2, t2.sourceSpan)), this._advance();
    }
    _parseExpansionCase() {
      const e2 = this._advance();
      if (this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START)
        return this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
      const t2 = this._advance(), r2 = this._collectExpansionExpTokens(t2);
      if (!r2)
        return null;
      const n2 = this._advance();
      r2.push(new ro.Token(ro.TokenType.EOF, [], n2.sourceSpan));
      const i2 = new uo(r2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
      if (i2.errors.length > 0)
        return this._errors = this._errors.concat(i2.errors), null;
      const s2 = new B$1.ParseSourceSpan(e2.sourceSpan.start, n2.sourceSpan.end), o2 = new B$1.ParseSourceSpan(t2.sourceSpan.start, n2.sourceSpan.end);
      return new Qs.ExpansionCase(e2.parts[0], i2.rootNodes, s2, e2.sourceSpan, o2);
    }
    _collectExpansionExpTokens(e2) {
      const t2 = [], r2 = [ro.TokenType.EXPANSION_CASE_EXP_START];
      for (; ; ) {
        if (this._peek.type !== ro.TokenType.EXPANSION_FORM_START && this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START || r2.push(this._peek.type), this._peek.type === ro.TokenType.EXPANSION_CASE_EXP_END) {
          if (!co(r2, ro.TokenType.EXPANSION_CASE_EXP_START))
            return this._errors.push(no.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
          if (r2.pop(), r2.length == 0)
            return t2;
        }
        if (this._peek.type === ro.TokenType.EXPANSION_FORM_END) {
          if (!co(r2, ro.TokenType.EXPANSION_FORM_START))
            return this._errors.push(no.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
          r2.pop();
        }
        if (this._peek.type === ro.TokenType.EOF)
          return this._errors.push(no.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        t2.push(this._advance());
      }
    }
    _getText(e2) {
      let t2 = e2.parts[0];
      if (t2.length > 0 && t2[0] == "\n") {
        const e3 = this._getParentElement();
        e3 != null && e3.children.length == 0 && this.getTagDefinition(e3.name).ignoreFirstLf && (t2 = t2.substring(1));
      }
      return t2;
    }
    _consumeText(e2) {
      const t2 = this._getText(e2);
      t2.length > 0 && this._addToParent(new Qs.Text(t2, e2.sourceSpan));
    }
    _closeVoidElement() {
      const e2 = this._getParentElement();
      e2 && this.getTagDefinition(e2.name).isVoid && this._elementStack.pop();
    }
    _consumeStartTag(e2) {
      const t2 = e2.parts[0], r2 = e2.parts[1], n2 = [];
      for (; this._peek.type === ro.TokenType.ATTR_NAME; )
        n2.push(this._consumeAttr(this._advance()));
      const i2 = this._getElementFullName(t2, r2, this._getParentElement());
      let s2 = false;
      if (this._peek.type === ro.TokenType.TAG_OPEN_END_VOID) {
        this._advance(), s2 = true;
        const t3 = this.getTagDefinition(i2);
        this.canSelfClose || t3.canSelfClose || As.getNsPrefix(i2) !== null || t3.isVoid || this._errors.push(no.create(i2, e2.sourceSpan, `Only void and foreign elements can be self closed "${e2.parts[1]}"`));
      } else
        this._peek.type === ro.TokenType.TAG_OPEN_END && (this._advance(), s2 = false);
      const o2 = this._peek.sourceSpan.start, a2 = new B$1.ParseSourceSpan(e2.sourceSpan.start, o2), u2 = new B$1.ParseSourceSpan(e2.sourceSpan.start.moveBy(1), e2.sourceSpan.end), c2 = new Qs.Element(i2, n2, [], a2, a2, void 0, u2);
      this._pushElement(c2), s2 && (this._popElement(i2), c2.endSourceSpan = a2);
    }
    _pushElement(e2) {
      const t2 = this._getParentElement();
      t2 && this.getTagDefinition(t2.name).isClosedByChild(e2.name) && this._elementStack.pop(), this._addToParent(e2), this._elementStack.push(e2);
    }
    _consumeEndTag(e2) {
      const t2 = this.allowHtmComponentClosingTags && e2.parts.length === 0 ? null : this._getElementFullName(e2.parts[0], e2.parts[1], this._getParentElement());
      if (this._getParentElement() && (this._getParentElement().endSourceSpan = e2.sourceSpan), t2 && this.getTagDefinition(t2).isVoid)
        this._errors.push(no.create(t2, e2.sourceSpan, `Void elements do not have end tags "${e2.parts[1]}"`));
      else if (!this._popElement(t2)) {
        const r2 = `Unexpected closing tag "${t2}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
        this._errors.push(no.create(t2, e2.sourceSpan, r2));
      }
    }
    _popElement(e2) {
      for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
        const r2 = this._elementStack[t2];
        if (!e2 || (As.getNsPrefix(r2.name) ? r2.name == e2 : r2.name.toLowerCase() == e2.toLowerCase()))
          return this._elementStack.splice(t2, this._elementStack.length - t2), true;
        if (!this.getTagDefinition(r2.name).closedByParent)
          return false;
      }
      return false;
    }
    _consumeAttr(e2) {
      const t2 = As.mergeNsAndName(e2.parts[0], e2.parts[1]);
      let r2, n2, i2 = e2.sourceSpan.end, s2 = "";
      if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
        n2 = this._advance().sourceSpan.start;
      }
      if (this._peek.type === ro.TokenType.ATTR_VALUE) {
        const e3 = this._advance();
        s2 = e3.parts[0], i2 = e3.sourceSpan.end, r2 = e3.sourceSpan;
      }
      if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
        i2 = this._advance().sourceSpan.end, r2 = new B$1.ParseSourceSpan(n2, i2);
      }
      return new Qs.Attribute(t2, s2, new B$1.ParseSourceSpan(e2.sourceSpan.start, i2), r2, e2.sourceSpan);
    }
    _getParentElement() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    }
    _getParentElementSkippingContainers() {
      let e2 = null;
      for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
        if (!As.isNgContainer(this._elementStack[t2].name))
          return { parent: this._elementStack[t2], container: e2 };
        e2 = this._elementStack[t2];
      }
      return { parent: null, container: e2 };
    }
    _addToParent(e2) {
      const t2 = this._getParentElement();
      t2 != null ? t2.children.push(e2) : this._rootNodes.push(e2);
    }
    _insertBeforeContainer(e2, t2, r2) {
      if (t2) {
        if (e2) {
          const n2 = e2.children.indexOf(t2);
          e2.children[n2] = r2;
        } else
          this._rootNodes.push(r2);
        r2.children.push(t2), this._elementStack.splice(this._elementStack.indexOf(t2), 0, r2);
      } else
        this._addToParent(r2), this._elementStack.push(r2);
    }
    _getElementFullName(e2, t2, r2) {
      return e2 === "" && (e2 = this.getTagDefinition(t2).implicitNamespacePrefix || "") === "" && r2 != null && (e2 = As.getNsPrefix(r2.name)), As.mergeNsAndName(e2, t2);
    }
  }
  function co(e2, t2) {
    return e2.length > 0 && e2[e2.length - 1] === t2;
  }
  var lo = Object.defineProperty({ TreeError: io, ParseTreeResult: oo, Parser: ao }, "__esModule", { value: true }), po = lo, ho = po.ParseTreeResult, Do = po.TreeError;
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class fo extends lo.Parser {
    constructor() {
      super(xs.getHtmlTagDefinition);
    }
    parse(e2, t2, r2, n2 = false, i2) {
      return super.parse(e2, t2, r2, n2, i2);
    }
  }
  var go = fo, mo = Object.defineProperty({ ParseTreeResult: ho, TreeError: Do, HtmlParser: go }, "__esModule", { value: true }), Eo = As.TagContentType;
  let Co = null;
  var yo = function(e2, t2 = {}) {
    const { canSelfClose: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: i2 = false, getTagContentType: s2 } = t2;
    return (Co || (Co = new mo.HtmlParser()), Co).parse(e2, "angular-html-parser", { tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: r2, allowHtmComponentClosingTags: n2 }, i2, s2);
  }, bo = Object.defineProperty({ TagContentType: Eo, parse: yo }, "__esModule", { value: true });
  const { ParseSourceSpan: So, ParseLocation: To, ParseSourceFile: _o } = B$1, { inferParserByLanguage: vo } = $n, { HTML_ELEMENT_ATTRIBUTES: Ao, HTML_TAGS: Fo, isUnknownNamespace: wo } = fs$1, { hasPragma: ko } = ds, { Node: No } = bs, { parseIeConditionalComment: Oo } = _s, { locStart: xo, locEnd: Io } = vs;
  function Po(e2, { recognizeSelfClosing: t2, normalizeTagName: r2, normalizeAttributeName: n2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2, getTagContentType: o2 }, a2) {
    const u2 = bo, { RecursiveVisitor: c2, visitAll: l2 } = Qs, { ParseSourceSpan: p2 } = B$1, { getHtmlTagDefinition: h2 } = xs;
    let { rootNodes: D2, errors: f2 } = u2.parse(e2, { canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2, getTagContentType: o2 });
    if (a2.parser === "vue") {
      if (D2.some((e3) => e3.type === "docType" && e3.value === "html" || e3.type === "element" && e3.name.toLowerCase() === "html")) {
        t2 = true, r2 = true, n2 = true, i2 = true, s2 = false;
        const o3 = u2.parse(e2, { canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2 });
        D2 = o3.rootNodes, f2 = o3.errors;
      } else {
        const r3 = (e3) => {
          if (!e3)
            return false;
          if (e3.type !== "element" || e3.name !== "template")
            return false;
          const t3 = e3.attrs.find((e4) => e4.name === "lang"), r4 = t3 && t3.value;
          return !r4 || vo(r4, a2) === "html";
        };
        if (D2.some(r3)) {
          let n3;
          const o3 = () => u2.parse(e2, { canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2 }), a3 = () => n3 || (n3 = o3()), c3 = (e3) => a3().rootNodes.find(({ startSourceSpan: t3 }) => t3 && t3.start.offset === e3.startSourceSpan.start.offset);
          for (let e3 = 0; e3 < D2.length; e3++) {
            const t3 = D2[e3], { endSourceSpan: n4, startSourceSpan: i3 } = t3;
            if (n4 === null) {
              f2 = a3().errors, D2[e3] = c3(t3) || t3;
            } else if (r3(t3)) {
              const r4 = a3(), s3 = i3.end.offset, o4 = n4.start.offset;
              for (const e4 of r4.errors) {
                const { offset: t4 } = e4.span.start;
                if (s3 < t4 && t4 < o4) {
                  f2 = [e4];
                  break;
                }
              }
              D2[e3] = c3(t3) || t3;
            }
          }
        }
      }
    }
    if (f2.length > 0) {
      const { msg: e3, span: { start: t3, end: r3 } } = f2[0];
      throw j$2(e3, { start: { line: t3.line + 1, column: t3.col + 1 }, end: { line: r3.line + 1, column: r3.col + 1 } });
    }
    const d2 = (e3) => {
      const t3 = e3.name.startsWith(":") ? e3.name.slice(1).split(":")[0] : null, r3 = e3.nameSpan.toString(), n3 = t3 !== null && r3.startsWith(`${t3}:`), i3 = n3 ? r3.slice(t3.length + 1) : r3;
      e3.name = i3, e3.namespace = t3, e3.hasExplicitNamespace = n3;
    }, g2 = (e3, t3) => {
      const r3 = e3.toLowerCase();
      return t3(r3) ? r3 : e3;
    };
    return l2(new class extends c2 {
      visit(e3) {
        ((e4) => {
          if (e4.type === "element") {
            d2(e4);
            for (const t3 of e4.attrs)
              d2(t3), t3.valueSpan ? (t3.value = t3.valueSpan.toString(), /["']/.test(t3.value[0]) && (t3.value = t3.value.slice(1, -1))) : t3.value = null;
          } else
            e4.type === "comment" ? e4.value = e4.sourceSpan.toString().slice("<!--".length, -"-->".length) : e4.type === "text" && (e4.value = e4.sourceSpan.toString());
        })(e3), ((e4) => {
          if (e4.type === "element") {
            const t3 = h2(s2 ? e4.name : e4.name.toLowerCase());
            !e4.namespace || e4.namespace === t3.implicitNamespacePrefix || wo(e4) ? e4.tagDefinition = t3 : e4.tagDefinition = h2("");
          }
        })(e3), ((e4) => {
          if (e4.type === "element" && (!r2 || e4.namespace && e4.namespace !== e4.tagDefinition.implicitNamespacePrefix && !wo(e4) || (e4.name = g2(e4.name, (e5) => e5 in Fo)), n2)) {
            const t3 = Ao[e4.name] || Object.create(null);
            for (const r3 of e4.attrs)
              r3.namespace || (r3.name = g2(r3.name, (r4) => e4.name in Ao && (r4 in Ao["*"] || r4 in t3)));
          }
        })(e3), ((e4) => {
          e4.sourceSpan && e4.endSourceSpan && (e4.sourceSpan = new p2(e4.sourceSpan.start, e4.endSourceSpan.end));
        })(e3);
      }
    }(), D2), D2;
  }
  function Ro(e2, t2, r2, n2 = true) {
    const { frontMatter: i2, content: s2 } = n2 ? q$1(e2) : { frontMatter: null, content: e2 }, o2 = new _o(e2, t2.filepath), a2 = new To(o2, 0, 0, 0), u2 = a2.moveBy(e2.length), c2 = { type: "root", sourceSpan: new So(a2, u2), children: Po(s2, r2, t2) };
    if (i2) {
      const e3 = new To(o2, 0, 0, 0), t3 = e3.moveBy(i2.raw.length);
      i2.sourceSpan = new So(e3, t3), c2.children.unshift(i2);
    }
    const l2 = new No(c2), p2 = (n3, i3) => {
      const { offset: s3 } = i3, o3 = Ro(e2.slice(0, s3).replace(/[^\n\r]/g, " ") + n3, t2, r2, false);
      o3.sourceSpan = new So(i3, M$1(o3.children).sourceSpan.end);
      const a3 = o3.children[0];
      return a3.length === s3 ? o3.children.shift() : (a3.sourceSpan = new So(a3.sourceSpan.start.moveBy(s3), a3.sourceSpan.end), a3.value = a3.value.slice(s3)), o3;
    };
    return l2.map((e3) => {
      if (e3.type === "comment") {
        const t3 = Oo(e3, p2);
        if (t3)
          return t3;
      }
      return e3;
    });
  }
  function Lo({ recognizeSelfClosing: e2 = false, normalizeTagName: t2 = false, normalizeAttributeName: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: i2 = false, getTagContentType: s2 } = {}) {
    return { parse: (o2, a2, u2) => Ro(o2, u2, { recognizeSelfClosing: e2, normalizeTagName: t2, normalizeAttributeName: r2, allowHtmComponentClosingTags: n2, isTagNameCaseSensitive: i2, getTagContentType: s2 }), hasPragma: ko, astFormat: "html", locStart: xo, locEnd: Io };
  }
  var Bo = { parsers: { html: Lo({ recognizeSelfClosing: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true }), angular: Lo(), vue: Lo({ recognizeSelfClosing: true, isTagNameCaseSensitive: true, getTagContentType: (e2, t2, r2, n2) => {
    if (e2.toLowerCase() !== "html" && !r2 && (e2 !== "template" || n2.some(({ name: e3, value: t3 }) => e3 === "lang" && t3 !== "html")))
      return bo.TagContentType.RAW_TEXT;
  } }), lwc: Lo() } };
  var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function t(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  function r(e2) {
    var t2 = { exports: {} };
    return e2(t2, t2.exports), t2.exports;
  }
  var n, o, i = function(e2) {
    return e2 && e2.Math == Math && e2;
  }, s = i(typeof globalThis == "object" && globalThis) || i(typeof window == "object" && window) || i(typeof self == "object" && self) || i(typeof e == "object" && e) || function() {
    return this;
  }() || Function("return this")(), u = function(e2) {
    try {
      return !!e2();
    } catch (e3) {
      return true;
    }
  }, a = !u(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  }), c = {}.propertyIsEnumerable, l = Object.getOwnPropertyDescriptor, f = { f: l && !c.call({ 1: 2 }, 1) ? function(e2) {
    var t2 = l(this, e2);
    return !!t2 && t2.enumerable;
  } : c }, p = function(e2, t2) {
    return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
  }, h = {}.toString, d = function(e2) {
    return h.call(e2).slice(8, -1);
  }, D = "".split, g = u(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e2) {
    return d(e2) == "String" ? D.call(e2, "") : Object(e2);
  } : Object, m = function(e2) {
    if (e2 == null)
      throw TypeError("Can't call method on " + e2);
    return e2;
  }, v = function(e2) {
    return g(m(e2));
  }, y = function(e2) {
    return typeof e2 == "object" ? e2 !== null : typeof e2 == "function";
  }, w = function(e2) {
    return typeof e2 == "function" ? e2 : void 0;
  }, b = function(e2, t2) {
    return arguments.length < 2 ? w(s[e2]) : s[e2] && s[e2][t2];
  }, C = b("navigator", "userAgent") || "", E = s.process, F = s.Deno, x = E && E.versions || F && F.version, A = x && x.v8;
  A ? o = (n = A.split("."))[0] < 4 ? 1 : n[0] + n[1] : C && (!(n = C.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = C.match(/Chrome\/(\d+)/)) && (o = n[1]);
  var k = o && +o, O = !!Object.getOwnPropertySymbols && !u(function() {
    var e2 = Symbol();
    return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && k && k < 41;
  }), _ = O && !Symbol.sham && typeof Symbol.iterator == "symbol", S = _ ? function(e2) {
    return typeof e2 == "symbol";
  } : function(e2) {
    var t2 = b("Symbol");
    return typeof t2 == "function" && Object(e2) instanceof t2;
  }, T = function(e2, t2) {
    try {
      Object.defineProperty(s, e2, { value: t2, configurable: true, writable: true });
    } catch (r2) {
      s[e2] = t2;
    }
    return t2;
  }, I = s["__core-js_shared__"] || T("__core-js_shared__", {}), N = r(function(e2) {
    (e2.exports = function(e3, t2) {
      return I[e3] || (I[e3] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({ version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
  }), M = function(e2) {
    return Object(m(e2));
  }, R = {}.hasOwnProperty, j$1 = Object.hasOwn || function(e2, t2) {
    return R.call(M(e2), t2);
  }, L = 0, B = Math.random(), P = function(e2) {
    return "Symbol(" + String(e2 === void 0 ? "" : e2) + ")_" + (++L + B).toString(36);
  }, $ = N("wks"), U = s.Symbol, G = _ ? U : U && U.withoutSetter || P, W = function(e2) {
    return j$1($, e2) && (O || typeof $[e2] == "string") || (O && j$1(U, e2) ? $[e2] = U[e2] : $[e2] = G("Symbol." + e2)), $[e2];
  }, z = W("toPrimitive"), V = function(e2, t2) {
    if (!y(e2) || S(e2))
      return e2;
    var r2, n2 = e2[z];
    if (n2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e2, t2), !y(r2) || S(r2))
        return r2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e3, t3) {
      var r3, n3;
      if (t3 === "string" && typeof (r3 = e3.toString) == "function" && !y(n3 = r3.call(e3)))
        return n3;
      if (typeof (r3 = e3.valueOf) == "function" && !y(n3 = r3.call(e3)))
        return n3;
      if (t3 !== "string" && typeof (r3 = e3.toString) == "function" && !y(n3 = r3.call(e3)))
        return n3;
      throw TypeError("Can't convert object to primitive value");
    }(e2, t2);
  }, q = function(e2) {
    var t2 = V(e2, "string");
    return S(t2) ? t2 : String(t2);
  }, X = s.document, J = y(X) && y(X.createElement), H = !a && !u(function() {
    return Object.defineProperty((e2 = "div", J ? X.createElement(e2) : {}), "a", { get: function() {
      return 7;
    } }).a != 7;
    var e2;
  }), Y = Object.getOwnPropertyDescriptor, K = { f: a ? Y : function(e2, t2) {
    if (e2 = v(e2), t2 = q(t2), H)
      try {
        return Y(e2, t2);
      } catch (e3) {
      }
    if (j$1(e2, t2))
      return p(!f.f.call(e2, t2), e2[t2]);
  } }, Z = function(e2) {
    if (!y(e2))
      throw TypeError(String(e2) + " is not an object");
    return e2;
  }, Q = Object.defineProperty, ee = { f: a ? Q : function(e2, t2, r2) {
    if (Z(e2), t2 = q(t2), Z(r2), H)
      try {
        return Q(e2, t2, r2);
      } catch (e3) {
      }
    if ("get" in r2 || "set" in r2)
      throw TypeError("Accessors not supported");
    return "value" in r2 && (e2[t2] = r2.value), e2;
  } }, te = a ? function(e2, t2, r2) {
    return ee.f(e2, t2, p(1, r2));
  } : function(e2, t2, r2) {
    return e2[t2] = r2, e2;
  }, re = Function.toString;
  typeof I.inspectSource != "function" && (I.inspectSource = function(e2) {
    return re.call(e2);
  });
  var ne, oe, ie, se, ue = I.inspectSource, ae = s.WeakMap, ce = typeof ae == "function" && /native code/.test(ue(ae)), le = N("keys"), fe = {}, pe = s.WeakMap;
  if (ce || I.state) {
    var he = I.state || (I.state = new pe()), de = he.get, De = he.has, ge = he.set;
    ne = function(e2, t2) {
      if (De.call(he, e2))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, ge.call(he, e2, t2), t2;
    }, oe = function(e2) {
      return de.call(he, e2) || {};
    }, ie = function(e2) {
      return De.call(he, e2);
    };
  } else {
    var me = le[se = "state"] || (le[se] = P(se));
    fe[me] = true, ne = function(e2, t2) {
      if (j$1(e2, me))
        throw new TypeError("Object already initialized");
      return t2.facade = e2, te(e2, me, t2), t2;
    }, oe = function(e2) {
      return j$1(e2, me) ? e2[me] : {};
    }, ie = function(e2) {
      return j$1(e2, me);
    };
  }
  var ve, ye, we = { set: ne, get: oe, has: ie, enforce: function(e2) {
    return ie(e2) ? oe(e2) : ne(e2, {});
  }, getterFor: function(e2) {
    return function(t2) {
      var r2;
      if (!y(t2) || (r2 = oe(t2)).type !== e2)
        throw TypeError("Incompatible receiver, " + e2 + " required");
      return r2;
    };
  } }, be = r(function(e2) {
    var t2 = we.get, r2 = we.enforce, n2 = String(String).split("String");
    (e2.exports = function(e3, t3, o2, i2) {
      var u2, a2 = !!i2 && !!i2.unsafe, c2 = !!i2 && !!i2.enumerable, l2 = !!i2 && !!i2.noTargetGet;
      typeof o2 == "function" && (typeof t3 != "string" || j$1(o2, "name") || te(o2, "name", t3), (u2 = r2(o2)).source || (u2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e3 !== s ? (a2 ? !l2 && e3[t3] && (c2 = true) : delete e3[t3], c2 ? e3[t3] = o2 : te(e3, t3, o2)) : c2 ? e3[t3] = o2 : T(t3, o2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || ue(this);
    });
  }), Ce = Math.ceil, Ee = Math.floor, Fe = function(e2) {
    return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? Ee : Ce)(e2);
  }, xe = Math.min, Ae = function(e2) {
    return e2 > 0 ? xe(Fe(e2), 9007199254740991) : 0;
  }, ke = Math.max, Oe = Math.min, _e = function(e2) {
    return function(t2, r2, n2) {
      var o2, i2 = v(t2), s2 = Ae(i2.length), u2 = function(e3, t3) {
        var r3 = Fe(e3);
        return r3 < 0 ? ke(r3 + t3, 0) : Oe(r3, t3);
      }(n2, s2);
      if (e2 && r2 != r2) {
        for (; s2 > u2; )
          if ((o2 = i2[u2++]) != o2)
            return true;
      } else
        for (; s2 > u2; u2++)
          if ((e2 || u2 in i2) && i2[u2] === r2)
            return e2 || u2 || 0;
      return !e2 && -1;
    };
  }, Se = { includes: _e(true), indexOf: _e(false) }.indexOf, Te = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ie = { f: Object.getOwnPropertyNames || function(e2) {
    return function(e3, t2) {
      var r2, n2 = v(e3), o2 = 0, i2 = [];
      for (r2 in n2)
        !j$1(fe, r2) && j$1(n2, r2) && i2.push(r2);
      for (; t2.length > o2; )
        j$1(n2, r2 = t2[o2++]) && (~Se(i2, r2) || i2.push(r2));
      return i2;
    }(e2, Te);
  } }, Ne = { f: Object.getOwnPropertySymbols }, Me = b("Reflect", "ownKeys") || function(e2) {
    var t2 = Ie.f(Z(e2)), r2 = Ne.f;
    return r2 ? t2.concat(r2(e2)) : t2;
  }, Re = function(e2, t2) {
    for (var r2 = Me(t2), n2 = ee.f, o2 = K.f, i2 = 0; i2 < r2.length; i2++) {
      var s2 = r2[i2];
      j$1(e2, s2) || n2(e2, s2, o2(t2, s2));
    }
  }, je = /#|\.prototype\./, Le = function(e2, t2) {
    var r2 = Pe[Be(e2)];
    return r2 == Ue || r2 != $e && (typeof t2 == "function" ? u(t2) : !!t2);
  }, Be = Le.normalize = function(e2) {
    return String(e2).replace(je, ".").toLowerCase();
  }, Pe = Le.data = {}, $e = Le.NATIVE = "N", Ue = Le.POLYFILL = "P", Ge = Le, We = K.f, ze = function(e2, t2) {
    var r2, n2, o2, i2, u2, a2 = e2.target, c2 = e2.global, l2 = e2.stat;
    if (r2 = c2 ? s : l2 ? s[a2] || T(a2, {}) : (s[a2] || {}).prototype)
      for (n2 in t2) {
        if (i2 = t2[n2], o2 = e2.noTargetGet ? (u2 = We(r2, n2)) && u2.value : r2[n2], !Ge(c2 ? n2 : a2 + (l2 ? "." : "#") + n2, e2.forced) && o2 !== void 0) {
          if (typeof i2 == typeof o2)
            continue;
          Re(i2, o2);
        }
        (e2.sham || o2 && o2.sham) && te(i2, "sham", true), be(r2, n2, i2, e2);
      }
  }, Ve = function(e2) {
    if (typeof e2 != "function")
      throw TypeError(String(e2) + " is not a function");
    return e2;
  }, qe = function(e2) {
    if (S(e2))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e2);
  }, Xe = Math.floor, Je = function(e2, t2) {
    var r2 = e2.length, n2 = Xe(r2 / 2);
    return r2 < 8 ? He(e2, t2) : Ye(Je(e2.slice(0, n2), t2), Je(e2.slice(n2), t2), t2);
  }, He = function(e2, t2) {
    for (var r2, n2, o2 = e2.length, i2 = 1; i2 < o2; ) {
      for (n2 = i2, r2 = e2[i2]; n2 && t2(e2[n2 - 1], r2) > 0; )
        e2[n2] = e2[--n2];
      n2 !== i2++ && (e2[n2] = r2);
    }
    return e2;
  }, Ye = function(e2, t2, r2) {
    for (var n2 = e2.length, o2 = t2.length, i2 = 0, s2 = 0, u2 = []; i2 < n2 || s2 < o2; )
      i2 < n2 && s2 < o2 ? u2.push(r2(e2[i2], t2[s2]) <= 0 ? e2[i2++] : t2[s2++]) : u2.push(i2 < n2 ? e2[i2++] : t2[s2++]);
    return u2;
  }, Ke = Je, Ze = C.match(/firefox\/(\d+)/i), Qe = !!Ze && +Ze[1], et = /MSIE|Trident/.test(C), tt = C.match(/AppleWebKit\/(\d+)\./), rt = !!tt && +tt[1], nt = [], ot = nt.sort, it = u(function() {
    nt.sort(void 0);
  }), st = u(function() {
    nt.sort(null);
  }), ut = !!(ye = []["sort"]) && u(function() {
    ye.call(null, ve || function() {
      throw 1;
    }, 1);
  }), at = !u(function() {
    if (k)
      return k < 70;
    if (!(Qe && Qe > 3)) {
      if (et)
        return true;
      if (rt)
        return rt < 603;
      var e2, t2, r2, n2, o2 = "";
      for (e2 = 65; e2 < 76; e2++) {
        switch (t2 = String.fromCharCode(e2), e2) {
          case 66:
          case 69:
          case 70:
          case 72:
            r2 = 3;
            break;
          case 68:
          case 71:
            r2 = 4;
            break;
          default:
            r2 = 2;
        }
        for (n2 = 0; n2 < 47; n2++)
          nt.push({ k: t2 + n2, v: r2 });
      }
      for (nt.sort(function(e3, t3) {
        return t3.v - e3.v;
      }), n2 = 0; n2 < nt.length; n2++)
        t2 = nt[n2].k.charAt(0), o2.charAt(o2.length - 1) !== t2 && (o2 += t2);
      return o2 !== "DGBEFHACIJK";
    }
  });
  ze({ target: "Array", proto: true, forced: it || !st || !ut || !at }, { sort: function(e2) {
    e2 !== void 0 && Ve(e2);
    var t2 = M(this);
    if (at)
      return e2 === void 0 ? ot.call(t2) : ot.call(t2, e2);
    var r2, n2, o2 = [], i2 = Ae(t2.length);
    for (n2 = 0; n2 < i2; n2++)
      n2 in t2 && o2.push(t2[n2]);
    for (r2 = (o2 = Ke(o2, function(e3) {
      return function(t3, r3) {
        return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, r3) || 0 : qe(t3) > qe(r3) ? 1 : -1;
      };
    }(e2))).length, n2 = 0; n2 < r2; )
      t2[n2] = o2[n2++];
    for (; n2 < i2; )
      delete t2[n2++];
    return t2;
  } });
  var ct = Array.isArray || function(e2) {
    return d(e2) == "Array";
  }, lt = function(e2, t2, r2) {
    if (Ve(e2), t2 === void 0)
      return e2;
    switch (r2) {
      case 0:
        return function() {
          return e2.call(t2);
        };
      case 1:
        return function(r3) {
          return e2.call(t2, r3);
        };
      case 2:
        return function(r3, n2) {
          return e2.call(t2, r3, n2);
        };
      case 3:
        return function(r3, n2, o2) {
          return e2.call(t2, r3, n2, o2);
        };
    }
    return function() {
      return e2.apply(t2, arguments);
    };
  }, ft = function(e2, t2, r2, n2, o2, i2, s2, u2) {
    for (var a2, c2 = o2, l2 = 0, f2 = !!s2 && lt(s2, u2, 3); l2 < n2; ) {
      if (l2 in r2) {
        if (a2 = f2 ? f2(r2[l2], l2, t2) : r2[l2], i2 > 0 && ct(a2))
          c2 = ft(e2, t2, a2, Ae(a2.length), c2, i2 - 1) - 1;
        else {
          if (c2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e2[c2] = a2;
        }
        c2++;
      }
      l2++;
    }
    return c2;
  }, pt = ft, ht = W("species"), dt = function(e2, t2) {
    return new (function(e3) {
      var t3;
      return ct(e3) && (typeof (t3 = e3.constructor) != "function" || t3 !== Array && !ct(t3.prototype) ? y(t3) && (t3 = t3[ht]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e2))(t2 === 0 ? 0 : t2);
  };
  ze({ target: "Array", proto: true }, { flatMap: function(e2) {
    var t2, r2 = M(this), n2 = Ae(r2.length);
    return Ve(e2), (t2 = dt(r2, 0)).length = pt(t2, r2, r2, n2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t2;
  } });
  var Dt = {}, gt = W("iterator"), mt = Array.prototype, vt = {};
  vt[W("toStringTag")] = "z";
  var yt = String(vt) === "[object z]", wt = W("toStringTag"), bt = d(function() {
    return arguments;
  }()) == "Arguments", Ct = yt ? d : function(e2) {
    var t2, r2, n2;
    return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (r2 = function(e3, t3) {
      try {
        return e3[t3];
      } catch (e4) {
      }
    }(t2 = Object(e2), wt)) == "string" ? r2 : bt ? d(t2) : (n2 = d(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
  }, Et = W("iterator"), Ft = function(e2) {
    if (e2 != null)
      return e2[Et] || e2["@@iterator"] || Dt[Ct(e2)];
  }, xt = function(e2, t2, r2) {
    var n2, o2;
    Z(e2);
    try {
      if ((n2 = e2.return) === void 0) {
        if (t2 === "throw")
          throw r2;
        return r2;
      }
      n2 = n2.call(e2);
    } catch (e3) {
      o2 = true, n2 = e3;
    }
    if (t2 === "throw")
      throw r2;
    if (o2)
      throw n2;
    return Z(n2), r2;
  }, At = function(e2, t2) {
    this.stopped = e2, this.result = t2;
  }, kt = function(e2, t2, r2) {
    var n2, o2, i2, s2, u2, a2, c2, l2, f2 = r2 && r2.that, p2 = !(!r2 || !r2.AS_ENTRIES), h2 = !(!r2 || !r2.IS_ITERATOR), d2 = !(!r2 || !r2.INTERRUPTED), D2 = lt(t2, f2, 1 + p2 + d2), g2 = function(e3) {
      return n2 && xt(n2, "normal", e3), new At(true, e3);
    }, m2 = function(e3) {
      return p2 ? (Z(e3), d2 ? D2(e3[0], e3[1], g2) : D2(e3[0], e3[1])) : d2 ? D2(e3, g2) : D2(e3);
    };
    if (h2)
      n2 = e2;
    else {
      if (typeof (o2 = Ft(e2)) != "function")
        throw TypeError("Target is not iterable");
      if ((l2 = o2) !== void 0 && (Dt.Array === l2 || mt[gt] === l2)) {
        for (i2 = 0, s2 = Ae(e2.length); s2 > i2; i2++)
          if ((u2 = m2(e2[i2])) && u2 instanceof At)
            return u2;
        return new At(false);
      }
      n2 = function(e3, t3) {
        var r3 = arguments.length < 2 ? Ft(e3) : t3;
        if (typeof r3 != "function")
          throw TypeError(String(e3) + " is not iterable");
        return Z(r3.call(e3));
      }(e2, o2);
    }
    for (a2 = n2.next; !(c2 = a2.call(n2)).done; ) {
      try {
        u2 = m2(c2.value);
      } catch (e3) {
        xt(n2, "throw", e3);
      }
      if (typeof u2 == "object" && u2 && u2 instanceof At)
        return u2;
    }
    return new At(false);
  };
  ze({ target: "Object", stat: true }, { fromEntries: function(e2) {
    var t2 = {};
    return kt(e2, function(e3, r2) {
      !function(e4, t3, r3) {
        var n2 = q(t3);
        n2 in e4 ? ee.f(e4, n2, p(0, r3)) : e4[n2] = r3;
      }(t2, e3, r2);
    }, { AS_ENTRIES: true }), t2;
  } });
  var Ot = t(r(function(e2, t2) {
    new Function("return this")(), e2.exports = (() => {
      var e3 = { 2426: (e4) => {
        e4.exports = ({ onlyFirst: e5 = false } = {}) => {
          const t4 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(t4, e5 ? void 0 : "g");
        };
      }, 118: (e4) => {
        e4.exports = function(e5) {
          if (typeof e5 != "function")
            throw TypeError(String(e5) + " is not a function");
          return e5;
        };
      }, 6956: (e4, t4, r3) => {
        var n2 = r3(2521);
        e4.exports = function(e5) {
          if (!n2(e5))
            throw TypeError(String(e5) + " is not an object");
          return e5;
        };
      }, 9729: (e4, t4, r3) => {
        var n2 = r3(9969), o2 = r3(8331), i2 = r3(1588), s2 = function(e5) {
          return function(t5, r4, s3) {
            var u2, a2 = n2(t5), c2 = o2(a2.length), l2 = i2(s3, c2);
            if (e5 && r4 != r4) {
              for (; c2 > l2; )
                if ((u2 = a2[l2++]) != u2)
                  return true;
            } else
              for (; c2 > l2; l2++)
                if ((e5 || l2 in a2) && a2[l2] === r4)
                  return e5 || l2 || 0;
            return !e5 && -1;
          };
        };
        e4.exports = { includes: s2(true), indexOf: s2(false) };
      }, 9719: (e4, t4, r3) => {
        var n2 = r3(2763);
        e4.exports = function(e5, t5) {
          var r4 = [][e5];
          return !!r4 && n2(function() {
            r4.call(null, t5 || function() {
              throw 1;
            }, 1);
          });
        };
      }, 3407: (e4) => {
        var t4 = Math.floor, r3 = function(e5, i2) {
          var s2 = e5.length, u2 = t4(s2 / 2);
          return s2 < 8 ? n2(e5, i2) : o2(r3(e5.slice(0, u2), i2), r3(e5.slice(u2), i2), i2);
        }, n2 = function(e5, t5) {
          for (var r4, n3, o3 = e5.length, i2 = 1; i2 < o3; ) {
            for (n3 = i2, r4 = e5[i2]; n3 && t5(e5[n3 - 1], r4) > 0; )
              e5[n3] = e5[--n3];
            n3 !== i2++ && (e5[n3] = r4);
          }
          return e5;
        }, o2 = function(e5, t5, r4) {
          for (var n3 = e5.length, o3 = t5.length, i2 = 0, s2 = 0, u2 = []; i2 < n3 || s2 < o3; )
            i2 < n3 && s2 < o3 ? u2.push(r4(e5[i2], t5[s2]) <= 0 ? e5[i2++] : t5[s2++]) : u2.push(i2 < n3 ? e5[i2++] : t5[s2++]);
          return u2;
        };
        e4.exports = r3;
      }, 2021: (e4, t4, r3) => {
        var n2 = r3(2521), o2 = r3(3964), i2 = r3(1386)("species");
        e4.exports = function(e5) {
          var t5;
          return o2(e5) && (typeof (t5 = e5.constructor) != "function" || t5 !== Array && !o2(t5.prototype) ? n2(t5) && (t5 = t5[i2]) === null && (t5 = void 0) : t5 = void 0), t5 === void 0 ? Array : t5;
        };
      }, 8347: (e4, t4, r3) => {
        var n2 = r3(2021);
        e4.exports = function(e5, t5) {
          return new (n2(e5))(t5 === 0 ? 0 : t5);
        };
      }, 2849: (e4) => {
        var t4 = {}.toString;
        e4.exports = function(e5) {
          return t4.call(e5).slice(8, -1);
        };
      }, 9538: (e4, t4, r3) => {
        var n2 = r3(6395), o2 = r3(2849), i2 = r3(1386)("toStringTag"), s2 = o2(function() {
          return arguments;
        }()) == "Arguments";
        e4.exports = n2 ? o2 : function(e5) {
          var t5, r4, n3;
          return e5 === void 0 ? "Undefined" : e5 === null ? "Null" : typeof (r4 = function(e6, t6) {
            try {
              return e6[t6];
            } catch (e7) {
            }
          }(t5 = Object(e5), i2)) == "string" ? r4 : s2 ? o2(t5) : (n3 = o2(t5)) == "Object" && typeof t5.callee == "function" ? "Arguments" : n3;
        };
      }, 4488: (e4, t4, r3) => {
        var n2 = r3(2766), o2 = r3(9593), i2 = r3(8769), s2 = r3(7455);
        e4.exports = function(e5, t5) {
          for (var r4 = o2(t5), u2 = s2.f, a2 = i2.f, c2 = 0; c2 < r4.length; c2++) {
            var l2 = r4[c2];
            n2(e5, l2) || u2(e5, l2, a2(t5, l2));
          }
        };
      }, 1471: (e4, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7455), i2 = r3(5938);
        e4.exports = n2 ? function(e5, t5, r4) {
          return o2.f(e5, t5, i2(1, r4));
        } : function(e5, t5, r4) {
          return e5[t5] = r4, e5;
        };
      }, 5938: (e4) => {
        e4.exports = function(e5, t4) {
          return { enumerable: !(1 & e5), configurable: !(2 & e5), writable: !(4 & e5), value: t4 };
        };
      }, 2385: (e4, t4, r3) => {
        var n2 = r3(5224), o2 = r3(7455), i2 = r3(5938);
        e4.exports = function(e5, t5, r4) {
          var s2 = n2(t5);
          s2 in e5 ? o2.f(e5, s2, i2(0, r4)) : e5[s2] = r4;
        };
      }, 7703: (e4, t4, r3) => {
        var n2 = r3(2763);
        e4.exports = !n2(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      }, 6004: (e4, t4, r3) => {
        var n2 = r3(6121), o2 = r3(2521), i2 = n2.document, s2 = o2(i2) && o2(i2.createElement);
        e4.exports = function(e5) {
          return s2 ? i2.createElement(e5) : {};
        };
      }, 5249: (e4, t4, r3) => {
        var n2 = r3(8635).match(/firefox\/(\d+)/i);
        e4.exports = !!n2 && +n2[1];
      }, 2049: (e4, t4, r3) => {
        var n2 = r3(8635);
        e4.exports = /MSIE|Trident/.test(n2);
      }, 8635: (e4, t4, r3) => {
        var n2 = r3(7642);
        e4.exports = n2("navigator", "userAgent") || "";
      }, 6962: (e4, t4, r3) => {
        var n2, o2, i2 = r3(6121), s2 = r3(8635), u2 = i2.process, a2 = i2.Deno, c2 = u2 && u2.versions || a2 && a2.version, l2 = c2 && c2.v8;
        l2 ? o2 = (n2 = l2.split("."))[0] < 4 ? 1 : n2[0] + n2[1] : s2 && (!(n2 = s2.match(/Edge\/(\d+)/)) || n2[1] >= 74) && (n2 = s2.match(/Chrome\/(\d+)/)) && (o2 = n2[1]), e4.exports = o2 && +o2;
      }, 8998: (e4, t4, r3) => {
        var n2 = r3(8635).match(/AppleWebKit\/(\d+)\./);
        e4.exports = !!n2 && +n2[1];
      }, 4731: (e4) => {
        e4.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, 7309: (e4, t4, r3) => {
        var n2 = r3(6121), o2 = r3(8769).f, i2 = r3(1471), s2 = r3(2327), u2 = r3(6565), a2 = r3(4488), c2 = r3(676);
        e4.exports = function(e5, t5) {
          var r4, l2, f2, p2, h2, d2 = e5.target, D2 = e5.global, g2 = e5.stat;
          if (r4 = D2 ? n2 : g2 ? n2[d2] || u2(d2, {}) : (n2[d2] || {}).prototype)
            for (l2 in t5) {
              if (p2 = t5[l2], f2 = e5.noTargetGet ? (h2 = o2(r4, l2)) && h2.value : r4[l2], !c2(D2 ? l2 : d2 + (g2 ? "." : "#") + l2, e5.forced) && f2 !== void 0) {
                if (typeof p2 == typeof f2)
                  continue;
                a2(p2, f2);
              }
              (e5.sham || f2 && f2.sham) && i2(p2, "sham", true), s2(r4, l2, p2, e5);
            }
        };
      }, 2763: (e4) => {
        e4.exports = function(e5) {
          try {
            return !!e5();
          } catch (e6) {
            return true;
          }
        };
      }, 5538: (e4, t4, r3) => {
        var n2 = r3(3964), o2 = r3(8331), i2 = r3(3322), s2 = function(e5, t5, r4, u2, a2, c2, l2, f2) {
          for (var p2, h2 = a2, d2 = 0, D2 = !!l2 && i2(l2, f2, 3); d2 < u2; ) {
            if (d2 in r4) {
              if (p2 = D2 ? D2(r4[d2], d2, t5) : r4[d2], c2 > 0 && n2(p2))
                h2 = s2(e5, t5, p2, o2(p2.length), h2, c2 - 1) - 1;
              else {
                if (h2 >= 9007199254740991)
                  throw TypeError("Exceed the acceptable array length");
                e5[h2] = p2;
              }
              h2++;
            }
            d2++;
          }
          return h2;
        };
        e4.exports = s2;
      }, 3322: (e4, t4, r3) => {
        var n2 = r3(118);
        e4.exports = function(e5, t5, r4) {
          if (n2(e5), t5 === void 0)
            return e5;
          switch (r4) {
            case 0:
              return function() {
                return e5.call(t5);
              };
            case 1:
              return function(r5) {
                return e5.call(t5, r5);
              };
            case 2:
              return function(r5, n3) {
                return e5.call(t5, r5, n3);
              };
            case 3:
              return function(r5, n3, o2) {
                return e5.call(t5, r5, n3, o2);
              };
          }
          return function() {
            return e5.apply(t5, arguments);
          };
        };
      }, 7642: (e4, t4, r3) => {
        var n2 = r3(6121), o2 = function(e5) {
          return typeof e5 == "function" ? e5 : void 0;
        };
        e4.exports = function(e5, t5) {
          return arguments.length < 2 ? o2(n2[e5]) : n2[e5] && n2[e5][t5];
        };
      }, 5111: (e4, t4, r3) => {
        var n2 = r3(9538), o2 = r3(3403), i2 = r3(1386)("iterator");
        e4.exports = function(e5) {
          if (e5 != null)
            return e5[i2] || e5["@@iterator"] || o2[n2(e5)];
        };
      }, 8977: (e4, t4, r3) => {
        var n2 = r3(6956), o2 = r3(5111);
        e4.exports = function(e5, t5) {
          var r4 = arguments.length < 2 ? o2(e5) : t5;
          if (typeof r4 != "function")
            throw TypeError(String(e5) + " is not iterable");
          return n2(r4.call(e5));
        };
      }, 6121: (e4, t4, r3) => {
        var n2 = function(e5) {
          return e5 && e5.Math == Math && e5;
        };
        e4.exports = n2(typeof globalThis == "object" && globalThis) || n2(typeof window == "object" && window) || n2(typeof self == "object" && self) || n2(typeof r3.g == "object" && r3.g) || function() {
          return this;
        }() || Function("return this")();
      }, 2766: (e4, t4, r3) => {
        var n2 = r3(4766), o2 = {}.hasOwnProperty;
        e4.exports = Object.hasOwn || function(e5, t5) {
          return o2.call(n2(e5), t5);
        };
      }, 2048: (e4) => {
        e4.exports = {};
      }, 7226: (e4, t4, r3) => {
        var n2 = r3(7703), o2 = r3(2763), i2 = r3(6004);
        e4.exports = !n2 && !o2(function() {
          return Object.defineProperty(i2("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      }, 3169: (e4, t4, r3) => {
        var n2 = r3(2763), o2 = r3(2849), i2 = "".split;
        e4.exports = n2(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(e5) {
          return o2(e5) == "String" ? i2.call(e5, "") : Object(e5);
        } : Object;
      }, 9835: (e4, t4, r3) => {
        var n2 = r3(4682), o2 = Function.toString;
        typeof n2.inspectSource != "function" && (n2.inspectSource = function(e5) {
          return o2.call(e5);
        }), e4.exports = n2.inspectSource;
      }, 2995: (e4, t4, r3) => {
        var n2, o2, i2, s2 = r3(5546), u2 = r3(6121), a2 = r3(2521), c2 = r3(1471), l2 = r3(2766), f2 = r3(4682), p2 = r3(2562), h2 = r3(2048), d2 = "Object already initialized", D2 = u2.WeakMap;
        if (s2 || f2.state) {
          var g2 = f2.state || (f2.state = new D2()), m2 = g2.get, v2 = g2.has, y2 = g2.set;
          n2 = function(e5, t5) {
            if (v2.call(g2, e5))
              throw new TypeError(d2);
            return t5.facade = e5, y2.call(g2, e5, t5), t5;
          }, o2 = function(e5) {
            return m2.call(g2, e5) || {};
          }, i2 = function(e5) {
            return v2.call(g2, e5);
          };
        } else {
          var w2 = p2("state");
          h2[w2] = true, n2 = function(e5, t5) {
            if (l2(e5, w2))
              throw new TypeError(d2);
            return t5.facade = e5, c2(e5, w2, t5), t5;
          }, o2 = function(e5) {
            return l2(e5, w2) ? e5[w2] : {};
          }, i2 = function(e5) {
            return l2(e5, w2);
          };
        }
        e4.exports = { set: n2, get: o2, has: i2, enforce: function(e5) {
          return i2(e5) ? o2(e5) : n2(e5, {});
        }, getterFor: function(e5) {
          return function(t5) {
            var r4;
            if (!a2(t5) || (r4 = o2(t5)).type !== e5)
              throw TypeError("Incompatible receiver, " + e5 + " required");
            return r4;
          };
        } };
      }, 9439: (e4, t4, r3) => {
        var n2 = r3(1386), o2 = r3(3403), i2 = n2("iterator"), s2 = Array.prototype;
        e4.exports = function(e5) {
          return e5 !== void 0 && (o2.Array === e5 || s2[i2] === e5);
        };
      }, 3964: (e4, t4, r3) => {
        var n2 = r3(2849);
        e4.exports = Array.isArray || function(e5) {
          return n2(e5) == "Array";
        };
      }, 676: (e4, t4, r3) => {
        var n2 = r3(2763), o2 = /#|\.prototype\./, i2 = function(e5, t5) {
          var r4 = u2[s2(e5)];
          return r4 == c2 || r4 != a2 && (typeof t5 == "function" ? n2(t5) : !!t5);
        }, s2 = i2.normalize = function(e5) {
          return String(e5).replace(o2, ".").toLowerCase();
        }, u2 = i2.data = {}, a2 = i2.NATIVE = "N", c2 = i2.POLYFILL = "P";
        e4.exports = i2;
      }, 2521: (e4) => {
        e4.exports = function(e5) {
          return typeof e5 == "object" ? e5 !== null : typeof e5 == "function";
        };
      }, 8451: (e4) => {
        e4.exports = false;
      }, 5057: (e4, t4, r3) => {
        var n2 = r3(7642), o2 = r3(2020);
        e4.exports = o2 ? function(e5) {
          return typeof e5 == "symbol";
        } : function(e5) {
          var t5 = n2("Symbol");
          return typeof t5 == "function" && Object(e5) instanceof t5;
        };
      }, 4572: (e4, t4, r3) => {
        var n2 = r3(6956), o2 = r3(9439), i2 = r3(8331), s2 = r3(3322), u2 = r3(8977), a2 = r3(5111), c2 = r3(4556), l2 = function(e5, t5) {
          this.stopped = e5, this.result = t5;
        };
        e4.exports = function(e5, t5, r4) {
          var f2, p2, h2, d2, D2, g2, m2, v2 = r4 && r4.that, y2 = !(!r4 || !r4.AS_ENTRIES), w2 = !(!r4 || !r4.IS_ITERATOR), b2 = !(!r4 || !r4.INTERRUPTED), C2 = s2(t5, v2, 1 + y2 + b2), E2 = function(e6) {
            return f2 && c2(f2, "normal", e6), new l2(true, e6);
          }, F2 = function(e6) {
            return y2 ? (n2(e6), b2 ? C2(e6[0], e6[1], E2) : C2(e6[0], e6[1])) : b2 ? C2(e6, E2) : C2(e6);
          };
          if (w2)
            f2 = e5;
          else {
            if (typeof (p2 = a2(e5)) != "function")
              throw TypeError("Target is not iterable");
            if (o2(p2)) {
              for (h2 = 0, d2 = i2(e5.length); d2 > h2; h2++)
                if ((D2 = F2(e5[h2])) && D2 instanceof l2)
                  return D2;
              return new l2(false);
            }
            f2 = u2(e5, p2);
          }
          for (g2 = f2.next; !(m2 = g2.call(f2)).done; ) {
            try {
              D2 = F2(m2.value);
            } catch (e6) {
              c2(f2, "throw", e6);
            }
            if (typeof D2 == "object" && D2 && D2 instanceof l2)
              return D2;
          }
          return new l2(false);
        };
      }, 4556: (e4, t4, r3) => {
        var n2 = r3(6956);
        e4.exports = function(e5, t5, r4) {
          var o2, i2;
          n2(e5);
          try {
            if ((o2 = e5.return) === void 0) {
              if (t5 === "throw")
                throw r4;
              return r4;
            }
            o2 = o2.call(e5);
          } catch (e6) {
            i2 = true, o2 = e6;
          }
          if (t5 === "throw")
            throw r4;
          if (i2)
            throw o2;
          return n2(o2), r4;
        };
      }, 3403: (e4) => {
        e4.exports = {};
      }, 4020: (e4, t4, r3) => {
        var n2 = r3(6962), o2 = r3(2763);
        e4.exports = !!Object.getOwnPropertySymbols && !o2(function() {
          var e5 = Symbol();
          return !String(e5) || !(Object(e5) instanceof Symbol) || !Symbol.sham && n2 && n2 < 41;
        });
      }, 5546: (e4, t4, r3) => {
        var n2 = r3(6121), o2 = r3(9835), i2 = n2.WeakMap;
        e4.exports = typeof i2 == "function" && /native code/.test(o2(i2));
      }, 7455: (e4, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7226), i2 = r3(6956), s2 = r3(5224), u2 = Object.defineProperty;
        t4.f = n2 ? u2 : function(e5, t5, r4) {
          if (i2(e5), t5 = s2(t5), i2(r4), o2)
            try {
              return u2(e5, t5, r4);
            } catch (e6) {
            }
          if ("get" in r4 || "set" in r4)
            throw TypeError("Accessors not supported");
          return "value" in r4 && (e5[t5] = r4.value), e5;
        };
      }, 8769: (e4, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7751), i2 = r3(5938), s2 = r3(9969), u2 = r3(5224), a2 = r3(2766), c2 = r3(7226), l2 = Object.getOwnPropertyDescriptor;
        t4.f = n2 ? l2 : function(e5, t5) {
          if (e5 = s2(e5), t5 = u2(t5), c2)
            try {
              return l2(e5, t5);
            } catch (e6) {
            }
          if (a2(e5, t5))
            return i2(!o2.f.call(e5, t5), e5[t5]);
        };
      }, 2042: (e4, t4, r3) => {
        var n2 = r3(3224), o2 = r3(4731).concat("length", "prototype");
        t4.f = Object.getOwnPropertyNames || function(e5) {
          return n2(e5, o2);
        };
      }, 2719: (e4, t4) => {
        t4.f = Object.getOwnPropertySymbols;
      }, 3224: (e4, t4, r3) => {
        var n2 = r3(2766), o2 = r3(9969), i2 = r3(9729).indexOf, s2 = r3(2048);
        e4.exports = function(e5, t5) {
          var r4, u2 = o2(e5), a2 = 0, c2 = [];
          for (r4 in u2)
            !n2(s2, r4) && n2(u2, r4) && c2.push(r4);
          for (; t5.length > a2; )
            n2(u2, r4 = t5[a2++]) && (~i2(c2, r4) || c2.push(r4));
          return c2;
        };
      }, 7751: (e4, t4) => {
        var r3 = {}.propertyIsEnumerable, n2 = Object.getOwnPropertyDescriptor, o2 = n2 && !r3.call({ 1: 2 }, 1);
        t4.f = o2 ? function(e5) {
          var t5 = n2(this, e5);
          return !!t5 && t5.enumerable;
        } : r3;
      }, 1047: (e4, t4, r3) => {
        var n2 = r3(2521);
        e4.exports = function(e5, t5) {
          var r4, o2;
          if (t5 === "string" && typeof (r4 = e5.toString) == "function" && !n2(o2 = r4.call(e5)))
            return o2;
          if (typeof (r4 = e5.valueOf) == "function" && !n2(o2 = r4.call(e5)))
            return o2;
          if (t5 !== "string" && typeof (r4 = e5.toString) == "function" && !n2(o2 = r4.call(e5)))
            return o2;
          throw TypeError("Can't convert object to primitive value");
        };
      }, 9593: (e4, t4, r3) => {
        var n2 = r3(7642), o2 = r3(2042), i2 = r3(2719), s2 = r3(6956);
        e4.exports = n2("Reflect", "ownKeys") || function(e5) {
          var t5 = o2.f(s2(e5)), r4 = i2.f;
          return r4 ? t5.concat(r4(e5)) : t5;
        };
      }, 2327: (e4, t4, r3) => {
        var n2 = r3(6121), o2 = r3(1471), i2 = r3(2766), s2 = r3(6565), u2 = r3(9835), a2 = r3(2995), c2 = a2.get, l2 = a2.enforce, f2 = String(String).split("String");
        (e4.exports = function(e5, t5, r4, u3) {
          var a3, c3 = !!u3 && !!u3.unsafe, p2 = !!u3 && !!u3.enumerable, h2 = !!u3 && !!u3.noTargetGet;
          typeof r4 == "function" && (typeof t5 != "string" || i2(r4, "name") || o2(r4, "name", t5), (a3 = l2(r4)).source || (a3.source = f2.join(typeof t5 == "string" ? t5 : ""))), e5 !== n2 ? (c3 ? !h2 && e5[t5] && (p2 = true) : delete e5[t5], p2 ? e5[t5] = r4 : o2(e5, t5, r4)) : p2 ? e5[t5] = r4 : s2(t5, r4);
        })(Function.prototype, "toString", function() {
          return typeof this == "function" && c2(this).source || u2(this);
        });
      }, 7263: (e4) => {
        e4.exports = function(e5) {
          if (e5 == null)
            throw TypeError("Can't call method on " + e5);
          return e5;
        };
      }, 6565: (e4, t4, r3) => {
        var n2 = r3(6121);
        e4.exports = function(e5, t5) {
          try {
            Object.defineProperty(n2, e5, { value: t5, configurable: true, writable: true });
          } catch (r4) {
            n2[e5] = t5;
          }
          return t5;
        };
      }, 2562: (e4, t4, r3) => {
        var n2 = r3(896), o2 = r3(1735), i2 = n2("keys");
        e4.exports = function(e5) {
          return i2[e5] || (i2[e5] = o2(e5));
        };
      }, 4682: (e4, t4, r3) => {
        var n2 = r3(6121), o2 = r3(6565), i2 = "__core-js_shared__", s2 = n2[i2] || o2(i2, {});
        e4.exports = s2;
      }, 896: (e4, t4, r3) => {
        var n2 = r3(8451), o2 = r3(4682);
        (e4.exports = function(e5, t5) {
          return o2[e5] || (o2[e5] = t5 !== void 0 ? t5 : {});
        })("versions", []).push({ version: "3.17.3", mode: n2 ? "pure" : "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
      }, 1588: (e4, t4, r3) => {
        var n2 = r3(5623), o2 = Math.max, i2 = Math.min;
        e4.exports = function(e5, t5) {
          var r4 = n2(e5);
          return r4 < 0 ? o2(r4 + t5, 0) : i2(r4, t5);
        };
      }, 9969: (e4, t4, r3) => {
        var n2 = r3(3169), o2 = r3(7263);
        e4.exports = function(e5) {
          return n2(o2(e5));
        };
      }, 5623: (e4) => {
        var t4 = Math.ceil, r3 = Math.floor;
        e4.exports = function(e5) {
          return isNaN(e5 = +e5) ? 0 : (e5 > 0 ? r3 : t4)(e5);
        };
      }, 8331: (e4, t4, r3) => {
        var n2 = r3(5623), o2 = Math.min;
        e4.exports = function(e5) {
          return e5 > 0 ? o2(n2(e5), 9007199254740991) : 0;
        };
      }, 4766: (e4, t4, r3) => {
        var n2 = r3(7263);
        e4.exports = function(e5) {
          return Object(n2(e5));
        };
      }, 687: (e4, t4, r3) => {
        var n2 = r3(2521), o2 = r3(5057), i2 = r3(1047), s2 = r3(1386)("toPrimitive");
        e4.exports = function(e5, t5) {
          if (!n2(e5) || o2(e5))
            return e5;
          var r4, u2 = e5[s2];
          if (u2 !== void 0) {
            if (t5 === void 0 && (t5 = "default"), r4 = u2.call(e5, t5), !n2(r4) || o2(r4))
              return r4;
            throw TypeError("Can't convert object to primitive value");
          }
          return t5 === void 0 && (t5 = "number"), i2(e5, t5);
        };
      }, 5224: (e4, t4, r3) => {
        var n2 = r3(687), o2 = r3(5057);
        e4.exports = function(e5) {
          var t5 = n2(e5, "string");
          return o2(t5) ? t5 : String(t5);
        };
      }, 6395: (e4, t4, r3) => {
        var n2 = {};
        n2[r3(1386)("toStringTag")] = "z", e4.exports = String(n2) === "[object z]";
      }, 3710: (e4, t4, r3) => {
        var n2 = r3(5057);
        e4.exports = function(e5) {
          if (n2(e5))
            throw TypeError("Cannot convert a Symbol value to a string");
          return String(e5);
        };
      }, 1735: (e4) => {
        var t4 = 0, r3 = Math.random();
        e4.exports = function(e5) {
          return "Symbol(" + String(e5 === void 0 ? "" : e5) + ")_" + (++t4 + r3).toString(36);
        };
      }, 2020: (e4, t4, r3) => {
        var n2 = r3(4020);
        e4.exports = n2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
      }, 1386: (e4, t4, r3) => {
        var n2 = r3(6121), o2 = r3(896), i2 = r3(2766), s2 = r3(1735), u2 = r3(4020), a2 = r3(2020), c2 = o2("wks"), l2 = n2.Symbol, f2 = a2 ? l2 : l2 && l2.withoutSetter || s2;
        e4.exports = function(e5) {
          return i2(c2, e5) && (u2 || typeof c2[e5] == "string") || (u2 && i2(l2, e5) ? c2[e5] = l2[e5] : c2[e5] = f2("Symbol." + e5)), c2[e5];
        };
      }, 4304: (e4, t4, r3) => {
        var n2 = r3(7309), o2 = r3(5538), i2 = r3(4766), s2 = r3(8331), u2 = r3(118), a2 = r3(8347);
        n2({ target: "Array", proto: true }, { flatMap: function(e5) {
          var t5, r4 = i2(this), n3 = s2(r4.length);
          return u2(e5), (t5 = a2(r4, 0)).length = o2(t5, r4, r4, n3, 0, 1, e5, arguments.length > 1 ? arguments[1] : void 0), t5;
        } });
      }, 4070: (e4, t4, r3) => {
        var n2 = r3(7309), o2 = r3(118), i2 = r3(4766), s2 = r3(8331), u2 = r3(3710), a2 = r3(2763), c2 = r3(3407), l2 = r3(9719), f2 = r3(5249), p2 = r3(2049), h2 = r3(6962), d2 = r3(8998), D2 = [], g2 = D2.sort, m2 = a2(function() {
          D2.sort(void 0);
        }), v2 = a2(function() {
          D2.sort(null);
        }), y2 = l2("sort"), w2 = !a2(function() {
          if (h2)
            return h2 < 70;
          if (!(f2 && f2 > 3)) {
            if (p2)
              return true;
            if (d2)
              return d2 < 603;
            var e5, t5, r4, n3, o3 = "";
            for (e5 = 65; e5 < 76; e5++) {
              switch (t5 = String.fromCharCode(e5), e5) {
                case 66:
                case 69:
                case 70:
                case 72:
                  r4 = 3;
                  break;
                case 68:
                case 71:
                  r4 = 4;
                  break;
                default:
                  r4 = 2;
              }
              for (n3 = 0; n3 < 47; n3++)
                D2.push({ k: t5 + n3, v: r4 });
            }
            for (D2.sort(function(e6, t6) {
              return t6.v - e6.v;
            }), n3 = 0; n3 < D2.length; n3++)
              t5 = D2[n3].k.charAt(0), o3.charAt(o3.length - 1) !== t5 && (o3 += t5);
            return o3 !== "DGBEFHACIJK";
          }
        });
        n2({ target: "Array", proto: true, forced: m2 || !v2 || !y2 || !w2 }, { sort: function(e5) {
          e5 !== void 0 && o2(e5);
          var t5 = i2(this);
          if (w2)
            return e5 === void 0 ? g2.call(t5) : g2.call(t5, e5);
          var r4, n3, a3 = [], l3 = s2(t5.length);
          for (n3 = 0; n3 < l3; n3++)
            n3 in t5 && a3.push(t5[n3]);
          for (r4 = (a3 = c2(a3, function(e6) {
            return function(t6, r5) {
              return r5 === void 0 ? -1 : t6 === void 0 ? 1 : e6 !== void 0 ? +e6(t6, r5) || 0 : u2(t6) > u2(r5) ? 1 : -1;
            };
          }(e5))).length, n3 = 0; n3 < r4; )
            t5[n3] = a3[n3++];
          for (; n3 < l3; )
            delete t5[n3++];
          return t5;
        } });
      }, 2612: (e4, t4, r3) => {
        var n2 = r3(7309), o2 = r3(4572), i2 = r3(2385);
        n2({ target: "Object", stat: true }, { fromEntries: function(e5) {
          var t5 = {};
          return o2(e5, function(e6, r4) {
            i2(t5, e6, r4);
          }, { AS_ENTRIES: true }), t5;
        } });
      }, 3584: (e4) => {
        const t4 = (e5) => {
          if (typeof e5 != "string")
            throw new TypeError("Expected a string");
          const t5 = e5.match(/(?:\r?\n)/g) || [];
          if (t5.length === 0)
            return;
          const r3 = t5.filter((e6) => e6 === "\r\n").length;
          return r3 > t5.length - r3 ? "\r\n" : "\n";
        };
        e4.exports = t4, e4.exports.graceful = (e5) => typeof e5 == "string" && t4(e5) || "\n";
      }, 541: (e4) => {
        e4.exports = function() {
          return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
        };
      }, 2240: (e4) => {
        e4.exports = (e5) => {
          if (typeof e5 != "string")
            throw new TypeError("Expected a string");
          return e5.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        };
      }, 8051: (e4) => {
        e4.exports = function(e5, t4) {
          return (t4 = typeof t4 == "number" ? t4 : 1 / 0) ? function e6(r3, n2) {
            return r3.reduce(function(r4, o2) {
              return Array.isArray(o2) && n2 < t4 ? r4.concat(e6(o2, n2 + 1)) : r4.concat(o2);
            }, []);
          }(e5, 1) : Array.isArray(e5) ? e5.map(function(e6) {
            return e6;
          }) : e5;
        };
      }, 7886: (e4) => {
        e4.exports = function(e5, t4) {
          for (var r3 = -1, n2 = []; (r3 = e5.indexOf(t4, r3 + 1)) !== -1; )
            n2.push(r3);
          return n2;
        };
      }, 8528: (e4) => {
        const t4 = (e5) => !Number.isNaN(e5) && e5 >= 4352 && (e5 <= 4447 || e5 === 9001 || e5 === 9002 || 11904 <= e5 && e5 <= 12871 && e5 !== 12351 || 12880 <= e5 && e5 <= 19903 || 19968 <= e5 && e5 <= 42182 || 43360 <= e5 && e5 <= 43388 || 44032 <= e5 && e5 <= 55203 || 63744 <= e5 && e5 <= 64255 || 65040 <= e5 && e5 <= 65049 || 65072 <= e5 && e5 <= 65131 || 65281 <= e5 && e5 <= 65376 || 65504 <= e5 && e5 <= 65510 || 110592 <= e5 && e5 <= 110593 || 127488 <= e5 && e5 <= 127569 || 131072 <= e5 && e5 <= 262141);
        e4.exports = t4, e4.exports.default = t4;
      }, 9234: (e4, t4, r3) => {
        function n2() {
          const e5 = r3(4372);
          return n2 = function() {
            return e5;
          }, e5;
        }
        function o2() {
          const e5 = (t5 = r3(3584)) && t5.__esModule ? t5 : { default: t5 };
          var t5;
          return o2 = function() {
            return e5;
          }, e5;
        }
        Object.defineProperty(t4, "__esModule", { value: true }), t4.extract = function(e5) {
          const t5 = e5.match(u2);
          return t5 ? t5[0].trimLeft() : "";
        }, t4.strip = function(e5) {
          const t5 = e5.match(u2);
          return t5 && t5[0] ? e5.substring(t5[0].length) : e5;
        }, t4.parse = function(e5) {
          return d2(e5).pragmas;
        }, t4.parseWithComments = d2, t4.print = function({ comments: e5 = "", pragmas: t5 = {} }) {
          const r4 = (0, o2().default)(e5) || n2().EOL, i3 = " *", s3 = Object.keys(t5), u3 = s3.map((e6) => D2(e6, t5[e6])).reduce((e6, t6) => e6.concat(t6), []).map((e6) => " * " + e6 + r4).join("");
          if (!e5) {
            if (s3.length === 0)
              return "";
            if (s3.length === 1 && !Array.isArray(t5[s3[0]])) {
              const e6 = t5[s3[0]];
              return `/** ${D2(s3[0], e6)[0]} */`;
            }
          }
          const a3 = e5.split(r4).map((e6) => ` * ${e6}`).join(r4) + r4;
          return "/**" + r4 + (e5 ? a3 : "") + (e5 && s3.length ? i3 + r4 : "") + u3 + " */";
        };
        const i2 = /\*\/$/, s2 = /^\/\*\*/, u2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a2 = /(^|\s+)\/\/([^\r\n]*)/g, c2 = /^(\r?\n)+/, l2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, f2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p2 = /(\r?\n|^) *\* ?/g, h2 = [];
        function d2(e5) {
          const t5 = (0, o2().default)(e5) || n2().EOL;
          e5 = e5.replace(s2, "").replace(i2, "").replace(p2, "$1");
          let r4 = "";
          for (; r4 !== e5; )
            r4 = e5, e5 = e5.replace(l2, `${t5}$1 $2${t5}`);
          e5 = e5.replace(c2, "").trimRight();
          const u3 = Object.create(null), d3 = e5.replace(f2, "").replace(c2, "").trimRight();
          let D3;
          for (; D3 = f2.exec(e5); ) {
            const e6 = D3[2].replace(a2, "");
            typeof u3[D3[1]] == "string" || Array.isArray(u3[D3[1]]) ? u3[D3[1]] = h2.concat(u3[D3[1]], e6) : u3[D3[1]] = e6;
          }
          return { comments: d3, pragmas: u3 };
        }
        function D2(e5, t5) {
          return h2.concat(t5).map((t6) => `@${e5} ${t6}`.trim());
        }
      }, 5311: (e4, t4, r3) => {
        function n2() {
          for (var e5 = [], t5 = 0; t5 < arguments.length; t5++)
            e5[t5] = arguments[t5];
        }
        function o2() {
          return typeof WeakMap != "undefined" ? new WeakMap() : { add: n2, delete: n2, get: n2, set: n2, has: function(e5) {
            return false;
          } };
        }
        r3.r(t4), r3.d(t4, { default: () => m2, outdent: () => g2 }), e4 = r3.hmd(e4);
        var i2 = Object.prototype.hasOwnProperty, s2 = function(e5, t5) {
          return i2.call(e5, t5);
        };
        function u2(e5, t5) {
          for (var r4 in t5)
            s2(t5, r4) && (e5[r4] = t5[r4]);
          return e5;
        }
        var a2 = /^[ \t]*(?:\r\n|\r|\n)/, c2 = /(?:\r\n|\r|\n)[ \t]*$/, l2 = /^(?:[\r\n]|$)/, f2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function h2(e5, t5, r4) {
          var n3 = 0, o3 = e5[0].match(f2);
          o3 && (n3 = o3[1].length);
          var i3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
          t5 && (e5 = e5.slice(1));
          var s3 = r4.newline, u3 = r4.trimLeadingNewline, l3 = r4.trimTrailingNewline, p3 = typeof s3 == "string", h3 = e5.length;
          return e5.map(function(e6, t6) {
            return e6 = e6.replace(i3, "$1"), t6 === 0 && u3 && (e6 = e6.replace(a2, "")), t6 === h3 - 1 && l3 && (e6 = e6.replace(c2, "")), p3 && (e6 = e6.replace(/\r\n|\n|\r/g, function(e7) {
              return s3;
            })), e6;
          });
        }
        function d2(e5, t5) {
          for (var r4 = "", n3 = 0, o3 = e5.length; n3 < o3; n3++)
            r4 += e5[n3], n3 < o3 - 1 && (r4 += t5[n3]);
          return r4;
        }
        function D2(e5) {
          return s2(e5, "raw") && s2(e5, "length");
        }
        var g2 = function e5(t5) {
          var r4 = o2(), n3 = o2();
          return u2(function o3(i3) {
            for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
              s3[a3 - 1] = arguments[a3];
            if (D2(i3)) {
              var c3 = i3, f3 = (s3[0] === o3 || s3[0] === g2) && p2.test(c3[0]) && l2.test(c3[1]), m3 = f3 ? n3 : r4, v2 = m3.get(c3);
              return v2 || (v2 = h2(c3, f3, t5), m3.set(c3, v2)), s3.length === 0 ? v2[0] : d2(v2, f3 ? s3.slice(1) : s3);
            }
            return e5(u2(u2({}, t5), i3 || {}));
          }, { string: function(e6) {
            return h2([e6], false, t5)[0];
          } });
        }({ trimLeadingNewline: true, trimTrailingNewline: true });
        const m2 = g2;
        try {
          e4.exports = g2, Object.defineProperty(g2, "__esModule", { value: true }), g2.default = g2, g2.outdent = g2;
        } catch (e5) {
        }
      }, 5724: (e4) => {
        function t4(e5) {
          if (typeof e5 != "string")
            throw new TypeError("Path must be a string. Received " + JSON.stringify(e5));
        }
        function r3(e5, t5) {
          for (var r4, n3 = "", o2 = 0, i2 = -1, s2 = 0, u2 = 0; u2 <= e5.length; ++u2) {
            if (u2 < e5.length)
              r4 = e5.charCodeAt(u2);
            else {
              if (r4 === 47)
                break;
              r4 = 47;
            }
            if (r4 === 47) {
              if (i2 === u2 - 1 || s2 === 1)
                ;
              else if (i2 !== u2 - 1 && s2 === 2) {
                if (n3.length < 2 || o2 !== 2 || n3.charCodeAt(n3.length - 1) !== 46 || n3.charCodeAt(n3.length - 2) !== 46) {
                  if (n3.length > 2) {
                    var a2 = n3.lastIndexOf("/");
                    if (a2 !== n3.length - 1) {
                      a2 === -1 ? (n3 = "", o2 = 0) : o2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), i2 = u2, s2 = 0;
                      continue;
                    }
                  } else if (n3.length === 2 || n3.length === 1) {
                    n3 = "", o2 = 0, i2 = u2, s2 = 0;
                    continue;
                  }
                }
                t5 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o2 = 2);
              } else
                n3.length > 0 ? n3 += "/" + e5.slice(i2 + 1, u2) : n3 = e5.slice(i2 + 1, u2), o2 = u2 - i2 - 1;
              i2 = u2, s2 = 0;
            } else
              r4 === 46 && s2 !== -1 ? ++s2 : s2 = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var e5, n3 = "", o2 = false, i2 = arguments.length - 1; i2 >= -1 && !o2; i2--) {
            var s2;
            i2 >= 0 ? s2 = arguments[i2] : (e5 === void 0 && (e5 = process.cwd()), s2 = e5), t4(s2), s2.length !== 0 && (n3 = s2 + "/" + n3, o2 = s2.charCodeAt(0) === 47);
          }
          return n3 = r3(n3, !o2), o2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(e5) {
          if (t4(e5), e5.length === 0)
            return ".";
          var n3 = e5.charCodeAt(0) === 47, o2 = e5.charCodeAt(e5.length - 1) === 47;
          return (e5 = r3(e5, !n3)).length !== 0 || n3 || (e5 = "."), e5.length > 0 && o2 && (e5 += "/"), n3 ? "/" + e5 : e5;
        }, isAbsolute: function(e5) {
          return t4(e5), e5.length > 0 && e5.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0)
            return ".";
          for (var e5, r4 = 0; r4 < arguments.length; ++r4) {
            var o2 = arguments[r4];
            t4(o2), o2.length > 0 && (e5 === void 0 ? e5 = o2 : e5 += "/" + o2);
          }
          return e5 === void 0 ? "." : n2.normalize(e5);
        }, relative: function(e5, r4) {
          if (t4(e5), t4(r4), e5 === r4)
            return "";
          if ((e5 = n2.resolve(e5)) === (r4 = n2.resolve(r4)))
            return "";
          for (var o2 = 1; o2 < e5.length && e5.charCodeAt(o2) === 47; ++o2)
            ;
          for (var i2 = e5.length, s2 = i2 - o2, u2 = 1; u2 < r4.length && r4.charCodeAt(u2) === 47; ++u2)
            ;
          for (var a2 = r4.length - u2, c2 = s2 < a2 ? s2 : a2, l2 = -1, f2 = 0; f2 <= c2; ++f2) {
            if (f2 === c2) {
              if (a2 > c2) {
                if (r4.charCodeAt(u2 + f2) === 47)
                  return r4.slice(u2 + f2 + 1);
                if (f2 === 0)
                  return r4.slice(u2 + f2);
              } else
                s2 > c2 && (e5.charCodeAt(o2 + f2) === 47 ? l2 = f2 : f2 === 0 && (l2 = 0));
              break;
            }
            var p2 = e5.charCodeAt(o2 + f2);
            if (p2 !== r4.charCodeAt(u2 + f2))
              break;
            p2 === 47 && (l2 = f2);
          }
          var h2 = "";
          for (f2 = o2 + l2 + 1; f2 <= i2; ++f2)
            f2 !== i2 && e5.charCodeAt(f2) !== 47 || (h2.length === 0 ? h2 += ".." : h2 += "/..");
          return h2.length > 0 ? h2 + r4.slice(u2 + l2) : (u2 += l2, r4.charCodeAt(u2) === 47 && ++u2, r4.slice(u2));
        }, _makeLong: function(e5) {
          return e5;
        }, dirname: function(e5) {
          if (t4(e5), e5.length === 0)
            return ".";
          for (var r4 = e5.charCodeAt(0), n3 = r4 === 47, o2 = -1, i2 = true, s2 = e5.length - 1; s2 >= 1; --s2)
            if ((r4 = e5.charCodeAt(s2)) === 47) {
              if (!i2) {
                o2 = s2;
                break;
              }
            } else
              i2 = false;
          return o2 === -1 ? n3 ? "/" : "." : n3 && o2 === 1 ? "//" : e5.slice(0, o2);
        }, basename: function(e5, r4) {
          if (r4 !== void 0 && typeof r4 != "string")
            throw new TypeError('"ext" argument must be a string');
          t4(e5);
          var n3, o2 = 0, i2 = -1, s2 = true;
          if (r4 !== void 0 && r4.length > 0 && r4.length <= e5.length) {
            if (r4.length === e5.length && r4 === e5)
              return "";
            var u2 = r4.length - 1, a2 = -1;
            for (n3 = e5.length - 1; n3 >= 0; --n3) {
              var c2 = e5.charCodeAt(n3);
              if (c2 === 47) {
                if (!s2) {
                  o2 = n3 + 1;
                  break;
                }
              } else
                a2 === -1 && (s2 = false, a2 = n3 + 1), u2 >= 0 && (c2 === r4.charCodeAt(u2) ? --u2 == -1 && (i2 = n3) : (u2 = -1, i2 = a2));
            }
            return o2 === i2 ? i2 = a2 : i2 === -1 && (i2 = e5.length), e5.slice(o2, i2);
          }
          for (n3 = e5.length - 1; n3 >= 0; --n3)
            if (e5.charCodeAt(n3) === 47) {
              if (!s2) {
                o2 = n3 + 1;
                break;
              }
            } else
              i2 === -1 && (s2 = false, i2 = n3 + 1);
          return i2 === -1 ? "" : e5.slice(o2, i2);
        }, extname: function(e5) {
          t4(e5);
          for (var r4 = -1, n3 = 0, o2 = -1, i2 = true, s2 = 0, u2 = e5.length - 1; u2 >= 0; --u2) {
            var a2 = e5.charCodeAt(u2);
            if (a2 !== 47)
              o2 === -1 && (i2 = false, o2 = u2 + 1), a2 === 46 ? r4 === -1 ? r4 = u2 : s2 !== 1 && (s2 = 1) : r4 !== -1 && (s2 = -1);
            else if (!i2) {
              n3 = u2 + 1;
              break;
            }
          }
          return r4 === -1 || o2 === -1 || s2 === 0 || s2 === 1 && r4 === o2 - 1 && r4 === n3 + 1 ? "" : e5.slice(r4, o2);
        }, format: function(e5) {
          if (e5 === null || typeof e5 != "object")
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e5);
          return function(e6, t5) {
            var r4 = t5.dir || t5.root, n3 = t5.base || (t5.name || "") + (t5.ext || "");
            return r4 ? r4 === t5.root ? r4 + n3 : r4 + e6 + n3 : n3;
          }("/", e5);
        }, parse: function(e5) {
          t4(e5);
          var r4 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (e5.length === 0)
            return r4;
          var n3, o2 = e5.charCodeAt(0), i2 = o2 === 47;
          i2 ? (r4.root = "/", n3 = 1) : n3 = 0;
          for (var s2 = -1, u2 = 0, a2 = -1, c2 = true, l2 = e5.length - 1, f2 = 0; l2 >= n3; --l2)
            if ((o2 = e5.charCodeAt(l2)) !== 47)
              a2 === -1 && (c2 = false, a2 = l2 + 1), o2 === 46 ? s2 === -1 ? s2 = l2 : f2 !== 1 && (f2 = 1) : s2 !== -1 && (f2 = -1);
            else if (!c2) {
              u2 = l2 + 1;
              break;
            }
          return s2 === -1 || a2 === -1 || f2 === 0 || f2 === 1 && s2 === a2 - 1 && s2 === u2 + 1 ? a2 !== -1 && (r4.base = r4.name = u2 === 0 && i2 ? e5.slice(1, a2) : e5.slice(u2, a2)) : (u2 === 0 && i2 ? (r4.name = e5.slice(1, s2), r4.base = e5.slice(1, a2)) : (r4.name = e5.slice(u2, s2), r4.base = e5.slice(u2, a2)), r4.ext = e5.slice(s2, a2)), u2 > 0 ? r4.dir = e5.slice(0, u2 - 1) : i2 && (r4.dir = "/"), r4;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, e4.exports = n2;
      }, 8681: (e4, t4, r3) => {
        const n2 = r3(3102), o2 = r3(7116), { isInlineComment: i2 } = r3(1101), { interpolation: s2 } = r3(3295), { isMixinToken: u2 } = r3(5953), a2 = r3(1330), c2 = r3(5255), l2 = /(!\s*important)$/i;
        e4.exports = class extends o2 {
          constructor(...e5) {
            super(...e5), this.lastNode = null;
          }
          atrule(e5) {
            s2.bind(this)(e5) || (super.atrule(e5), a2(this.lastNode), c2(this.lastNode));
          }
          decl(...e5) {
            super.decl(...e5), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
          }
          each(e5) {
            e5[0][1] = ` ${e5[0][1]}`;
            const t5 = e5.findIndex((e6) => e6[0] === "("), r4 = e5.reverse().find((e6) => e6[0] === ")"), n3 = e5.reverse().indexOf(r4), o3 = e5.splice(t5, n3).map((e6) => e6[1]).join("");
            for (const t6 of e5.reverse())
              this.tokenizer.back(t6);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = o3;
          }
          init(e5, t5, r4) {
            super.init(e5, t5, r4), this.lastNode = e5;
          }
          inlineComment(e5) {
            const t5 = new n2(), r4 = e5[1].slice(2);
            if (this.init(t5, e5[2], e5[3]), t5.source.end = { line: e5[4], column: e5[5] }, t5.inline = true, t5.raws.begin = "//", /^\s*$/.test(r4))
              t5.text = "", t5.raws.left = r4, t5.raws.right = "";
            else {
              const e6 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
              [, t5.raws.left, t5.text, t5.raws.right] = e6;
            }
          }
          mixin(e5) {
            const [t5] = e5, r4 = t5[1].slice(0, 1), n3 = e5.findIndex((e6) => e6[0] === "brackets"), o3 = e5.findIndex((e6) => e6[0] === "(");
            let i3 = "";
            if ((n3 < 0 || n3 > 3) && o3 > 0) {
              const t6 = e5.reduce((e6, t7, r6) => t7[0] === ")" ? r6 : e6), r5 = e5.slice(o3, t6 + o3).map((e6) => e6[1]).join(""), [n4] = e5.slice(o3), i4 = [n4[2], n4[3]], [s4] = e5.slice(t6, t6 + 1), u4 = [s4[2], s4[3]], a3 = ["brackets", r5].concat(i4, u4), c3 = e5.slice(0, o3), l3 = e5.slice(t6 + 1);
              (e5 = c3).push(a3), e5 = e5.concat(l3);
            }
            const s3 = [];
            for (const t6 of e5)
              if ((t6[1] === "!" || s3.length) && s3.push(t6), t6[1] === "important")
                break;
            if (s3.length) {
              const [t6] = s3, r5 = e5.indexOf(t6), n4 = s3[s3.length - 1], o4 = [t6[2], t6[3]], i4 = [n4[4], n4[5]], u4 = ["word", s3.map((e6) => e6[1]).join("")].concat(o4, i4);
              e5.splice(r5, s3.length, u4);
            }
            const u3 = e5.findIndex((e6) => l2.test(e6[1]));
            u3 > 0 && ([, i3] = e5[u3], e5.splice(u3, 1));
            for (const t6 of e5.reverse())
              this.tokenizer.back(t6);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = r4, i3 && (this.lastNode.important = true, this.lastNode.raws.important = i3);
          }
          other(e5) {
            i2.bind(this)(e5) || super.other(e5);
          }
          rule(e5) {
            const t5 = e5[e5.length - 1], r4 = e5[e5.length - 2];
            if (r4[0] === "at-word" && t5[0] === "{" && (this.tokenizer.back(t5), s2.bind(this)(r4))) {
              const t6 = this.tokenizer.nextToken();
              e5 = e5.slice(0, e5.length - 2).concat([t6]);
              for (const t7 of e5.reverse())
                this.tokenizer.back(t7);
            } else
              super.rule(e5), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
          }
          unknownWord(e5) {
            const [t5] = e5;
            e5[0][1] !== "each" || e5[1][0] !== "(" ? u2(t5) ? this.mixin(e5) : super.unknownWord(e5) : this.each(e5);
          }
        };
      }, 3406: (e4, t4, r3) => {
        const n2 = r3(5701);
        e4.exports = class extends n2 {
          atrule(e5, t5) {
            if (!e5.mixin && !e5.variable && !e5.function)
              return void super.atrule(e5, t5);
            let r4 = `${e5.function ? "" : e5.raws.identifier || "@"}${e5.name}`, n3 = e5.params ? this.rawValue(e5, "params") : "";
            const o2 = e5.raws.important || "";
            if (e5.variable && (n3 = e5.value), e5.raws.afterName !== void 0 ? r4 += e5.raws.afterName : n3 && (r4 += " "), e5.nodes)
              this.block(e5, r4 + n3 + o2);
            else {
              const i2 = (e5.raws.between || "") + o2 + (t5 ? ";" : "");
              this.builder(r4 + n3 + i2, e5);
            }
          }
          comment(e5) {
            if (e5.inline) {
              const t5 = this.raw(e5, "left", "commentLeft"), r4 = this.raw(e5, "right", "commentRight");
              this.builder(`//${t5}${e5.text}${r4}`, e5);
            } else
              super.comment(e5);
          }
        };
      }, 7371: (e4, t4, r3) => {
        const n2 = r3(2993), o2 = r3(8681), i2 = r3(3406);
        e4.exports = { parse(e5, t5) {
          const r4 = new n2(e5, t5), i3 = new o2(r4);
          return i3.parse(), i3.root;
        }, stringify(e5, t5) {
          new i2(t5).stringify(e5);
        }, nodeToString(t5) {
          let r4 = "";
          return e4.exports.stringify(t5, (e5) => {
            r4 += e5;
          }), r4;
        } };
      }, 1330: (e4, t4, r3) => {
        const n2 = r3(1157), o2 = /^url\((.+)\)/;
        e4.exports = (e5) => {
          const { name: t5, params: r4 = "" } = e5;
          if (t5 === "import" && r4.length) {
            e5.import = true;
            const t6 = n2({ css: r4 });
            for (e5.filename = r4.replace(o2, "$1"); !t6.endOfFile(); ) {
              const [n3, o3] = t6.nextToken();
              if (n3 === "word" && o3 === "url")
                return;
              if (n3 === "brackets") {
                e5.options = o3, e5.filename = r4.replace(o3, "").trim();
                break;
              }
            }
          }
        };
      }, 1101: (e4, t4, r3) => {
        const n2 = r3(1157), o2 = r3(2993);
        e4.exports = { isInlineComment(t5) {
          if (t5[0] === "word" && t5[1].slice(0, 2) === "//") {
            const e5 = t5, r4 = [];
            let i2;
            for (; t5; ) {
              if (/\r?\n/.test(t5[1])) {
                if (/['"].*\r?\n/.test(t5[1])) {
                  r4.push(t5[1].substring(0, t5[1].indexOf("\n")));
                  let e6 = t5[1].substring(t5[1].indexOf("\n"));
                  e6 += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new o2(e6), this.tokenizer = n2(this.input);
                } else
                  this.tokenizer.back(t5);
                break;
              }
              r4.push(t5[1]), i2 = t5, t5 = this.tokenizer.nextToken({ ignoreUnclosed: true });
            }
            const s2 = ["comment", r4.join(""), e5[2], e5[3], i2[2], i2[3]];
            return this.inlineComment(s2), true;
          }
          if (t5[1] === "/") {
            const r4 = this.tokenizer.nextToken({ ignoreUnclosed: true });
            if (r4[0] === "comment" && /^\/\*/.test(r4[1]))
              return r4[0] = "word", r4[1] = r4[1].slice(1), t5[1] = "//", this.tokenizer.back(r4), e4.exports.isInlineComment.bind(this)(t5);
          }
          return false;
        } };
      }, 3295: (e4) => {
        e4.exports = { interpolation(e5) {
          let t4 = e5;
          const r3 = [e5], n2 = ["word", "{", "}"];
          if (e5 = this.tokenizer.nextToken(), t4[1].length > 1 || e5[0] !== "{")
            return this.tokenizer.back(e5), false;
          for (; e5 && n2.includes(e5[0]); )
            r3.push(e5), e5 = this.tokenizer.nextToken();
          const o2 = r3.map((e6) => e6[1]);
          [t4] = r3;
          const i2 = r3.pop(), s2 = [t4[2], t4[3]], u2 = [i2[4] || i2[2], i2[5] || i2[3]], a2 = ["word", o2.join("")].concat(s2, u2);
          return this.tokenizer.back(e5), this.tokenizer.back(a2), true;
        } };
      }, 5953: (e4) => {
        const t4 = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, r3 = /\.[0-9]/;
        e4.exports = { isMixinToken: (e5) => {
          const [, n2] = e5, [o2] = n2;
          return (o2 === "." || o2 === "#") && t4.test(n2) === false && r3.test(n2) === false;
        } };
      }, 5255: (e4) => {
        const t4 = /:$/, r3 = /^:(\s+)?/;
        e4.exports = (e5) => {
          const { name: n2, params: o2 = "" } = e5;
          if (e5.name.slice(-1) === ":") {
            if (t4.test(n2)) {
              const [r4] = n2.match(t4);
              e5.name = n2.replace(r4, ""), e5.raws.afterName = r4 + (e5.raws.afterName || ""), e5.variable = true, e5.value = e5.params;
            }
            if (r3.test(o2)) {
              const [t5] = o2.match(r3);
              e5.value = o2.replace(t5, ""), e5.raws.afterName = (e5.raws.afterName || "") + t5, e5.variable = true;
            }
          }
        };
      }, 8322: (e4, t4, r3) => {
        t4.Z = function(e5) {
          return new o2.default({ nodes: (0, i2.parseMediaList)(e5), type: "media-query-list", value: e5.trim() });
        };
        var n2, o2 = (n2 = r3(9066)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(7625);
      }, 9066: (e4, t4, r3) => {
        Object.defineProperty(t4, "__esModule", { value: true });
        var n2, o2 = (n2 = r3(7680)) && n2.__esModule ? n2 : { default: n2 };
        function i2(e5) {
          var t5 = this;
          this.constructor(e5), this.nodes = e5.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(e6) {
            e6.parent = t5;
          });
        }
        i2.prototype = Object.create(o2.default.prototype), i2.constructor = o2.default, i2.prototype.walk = function(e5, t5) {
          for (var r4 = typeof e5 == "string" || e5 instanceof RegExp, n3 = r4 ? t5 : e5, o3 = typeof e5 == "string" ? new RegExp(e5) : e5, i3 = 0; i3 < this.nodes.length; i3++) {
            var s2 = this.nodes[i3];
            if ((!r4 || o3.test(s2.type)) && n3 && n3(s2, i3, this.nodes) === false)
              return false;
            if (s2.nodes && s2.walk(e5, t5) === false)
              return false;
          }
          return true;
        }, i2.prototype.each = function() {
          for (var e5 = arguments.length <= 0 || arguments[0] === void 0 ? function() {
          } : arguments[0], t5 = 0; t5 < this.nodes.length; t5++)
            if (e5(this.nodes[t5], t5, this.nodes) === false)
              return false;
          return true;
        }, t4.default = i2;
      }, 7680: (e4, t4) => {
        Object.defineProperty(t4, "__esModule", { value: true }), t4.default = function(e5) {
          this.after = e5.after, this.before = e5.before, this.type = e5.type, this.value = e5.value, this.sourceIndex = e5.sourceIndex;
        };
      }, 7625: (e4, t4, r3) => {
        Object.defineProperty(t4, "__esModule", { value: true }), t4.parseMediaFeature = s2, t4.parseMediaQuery = u2, t4.parseMediaList = function(e5) {
          var t5 = [], r4 = 0, i3 = 0, s3 = /^(\s*)url\s*\(/.exec(e5);
          if (s3 !== null) {
            for (var a2 = s3[0].length, c2 = 1; c2 > 0; ) {
              var l2 = e5[a2];
              l2 === "(" && c2++, l2 === ")" && c2--, a2++;
            }
            t5.unshift(new n2.default({ type: "url", value: e5.substring(0, a2).trim(), sourceIndex: s3[1].length, before: s3[1], after: /^(\s*)/.exec(e5.substring(a2))[1] })), r4 = a2;
          }
          for (var f2 = r4; f2 < e5.length; f2++) {
            var p2 = e5[f2];
            if (p2 === "(" && i3++, p2 === ")" && i3--, i3 === 0 && p2 === ",") {
              var h2 = e5.substring(r4, f2), d2 = /^(\s*)/.exec(h2)[1];
              t5.push(new o2.default({ type: "media-query", value: h2.trim(), sourceIndex: r4 + d2.length, nodes: u2(h2, r4), before: d2, after: /(\s*)$/.exec(h2)[1] })), r4 = f2 + 1;
            }
          }
          var D2 = e5.substring(r4), g2 = /^(\s*)/.exec(D2)[1];
          return t5.push(new o2.default({ type: "media-query", value: D2.trim(), sourceIndex: r4 + g2.length, nodes: u2(D2, r4), before: g2, after: /(\s*)$/.exec(D2)[1] })), t5;
        };
        var n2 = i2(r3(7680)), o2 = i2(r3(9066));
        function i2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function s2(e5) {
          var t5 = [{ mode: "normal", character: null }], r4 = [], n3 = 0, o3 = "", i3 = null, s3 = null, u3 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], a2 = e5;
          e5[0] === "(" && e5[e5.length - 1] === ")" && (a2 = e5.substring(1, e5.length - 1), u3++);
          for (var c2 = 0; c2 < a2.length; c2++) {
            var l2 = a2[c2];
            if (l2 !== "'" && l2 !== '"' || (t5[n3].isCalculationEnabled === true ? (t5.push({ mode: "string", isCalculationEnabled: false, character: l2 }), n3++) : t5[n3].mode === "string" && t5[n3].character === l2 && a2[c2 - 1] !== "\\" && (t5.pop(), n3--)), l2 === "{" ? (t5.push({ mode: "interpolation", isCalculationEnabled: true }), n3++) : l2 === "}" && (t5.pop(), n3--), t5[n3].mode === "normal" && l2 === ":") {
              var f2 = a2.substring(c2 + 1);
              (s3 = { type: "value", before: /^(\s*)/.exec(f2)[1], after: /(\s*)$/.exec(f2)[1], value: f2.trim() }).sourceIndex = s3.before.length + c2 + 1 + u3, i3 = { type: "colon", sourceIndex: c2 + u3, after: s3.before, value: ":" };
              break;
            }
            o3 += l2;
          }
          return (o3 = { type: "media-feature", before: /^(\s*)/.exec(o3)[1], after: /(\s*)$/.exec(o3)[1], value: o3.trim() }).sourceIndex = o3.before.length + u3, r4.push(o3), i3 !== null && (i3.before = o3.after, r4.push(i3)), s3 !== null && r4.push(s3), r4;
        }
        function u2(e5) {
          var t5 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r4 = [], i3 = 0, u3 = false, a2 = void 0;
          a2 = { before: "", after: "", value: "" };
          for (var c2 = 0; c2 < e5.length; c2++) {
            var l2 = e5[c2];
            u3 ? (a2.value += l2, l2 !== "{" && l2 !== "(" || i3++, l2 !== ")" && l2 !== "}" || i3--) : l2.search(/\s/) !== -1 ? a2.before += l2 : (l2 === "(" && (a2.type = "media-feature-expression", i3++), a2.value = l2, a2.sourceIndex = t5 + c2, u3 = true), !u3 || i3 !== 0 || l2 !== ")" && c2 !== e5.length - 1 && e5[c2 + 1].search(/\s/) === -1 || (["not", "only", "and"].indexOf(a2.value) !== -1 && (a2.type = "keyword"), a2.type === "media-feature-expression" && (a2.nodes = s2(a2.value, a2.sourceIndex)), r4.push(Array.isArray(a2.nodes) ? new o2.default(a2) : new n2.default(a2)), a2 = { before: "", after: "", value: "" }, u3 = false);
          }
          for (var f2 = 0; f2 < r4.length; f2++)
            if (a2 = r4[f2], f2 > 0 && (r4[f2 - 1].after = a2.before), a2.type === void 0) {
              if (f2 > 0) {
                if (r4[f2 - 1].type === "media-feature-expression") {
                  a2.type = "keyword";
                  continue;
                }
                if (r4[f2 - 1].value === "not" || r4[f2 - 1].value === "only") {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 - 1].value === "and") {
                  a2.type = "media-feature-expression";
                  continue;
                }
                r4[f2 - 1].type === "media-type" && (r4[f2 + 1] ? a2.type = r4[f2 + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : a2.type = "media-feature-expression");
              }
              if (f2 === 0) {
                if (!r4[f2 + 1]) {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 + 1] && (r4[f2 + 1].type === "media-feature-expression" || r4[f2 + 1].type === "keyword")) {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 + 2]) {
                  if (r4[f2 + 2].type === "media-feature-expression") {
                    a2.type = "media-type", r4[f2 + 1].type = "keyword";
                    continue;
                  }
                  if (r4[f2 + 2].type === "keyword") {
                    a2.type = "keyword", r4[f2 + 1].type = "media-type";
                    continue;
                  }
                }
                if (r4[f2 + 3] && r4[f2 + 3].type === "media-feature-expression") {
                  a2.type = "keyword", r4[f2 + 1].type = "media-type", r4[f2 + 2].type = "keyword";
                  continue;
                }
              }
            }
          return r4;
        }
      }, 5822: (e4, t4, r3) => {
        var n2 = function(e5) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e5.call(this, t6) || this).type = "decl", r5.isNested = true, r5.nodes || (r5.nodes = []), r5;
          }
          return r4 = e5, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(r3(1204));
        e4.exports = n2;
      }, 1945: (e4, t4, r3) => {
        var n2 = r3(2993), o2 = r3(1713);
        e4.exports = function(e5, t5) {
          var r4 = new n2(e5, t5), i2 = new o2(r4);
          return i2.parse(), i2.root;
        };
      }, 1713: (e4, t4, r3) => {
        var n2 = r3(3102), o2 = r3(7116), i2 = r3(5822), s2 = r3(6256), u2 = function(e5) {
          var t5, r4;
          function o3() {
            return e5.apply(this, arguments) || this;
          }
          r4 = e5, (t5 = o3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var u3 = o3.prototype;
          return u3.createTokenizer = function() {
            this.tokenizer = s2(this.input);
          }, u3.rule = function(t6) {
            var r5 = false, n3 = 0, o4 = "", s3 = t6, u4 = Array.isArray(s3), a2 = 0;
            for (s3 = u4 ? s3 : s3[Symbol.iterator](); ; ) {
              var c2;
              if (u4) {
                if (a2 >= s3.length)
                  break;
                c2 = s3[a2++];
              } else {
                if ((a2 = s3.next()).done)
                  break;
                c2 = a2.value;
              }
              var l2 = c2;
              if (r5)
                l2[0] !== "comment" && l2[0] !== "{" && (o4 += l2[1]);
              else {
                if (l2[0] === "space" && l2[1].indexOf("\n") !== -1)
                  break;
                l2[0] === "(" ? n3 += 1 : l2[0] === ")" ? n3 -= 1 : n3 === 0 && l2[0] === ":" && (r5 = true);
              }
            }
            if (!r5 || o4.trim() === "" || /^[a-zA-Z-:#]/.test(o4))
              e5.prototype.rule.call(this, t6);
            else {
              t6.pop();
              var f2 = new i2();
              this.init(f2);
              var p2, h2 = t6[t6.length - 1];
              for (h2[4] ? f2.source.end = { line: h2[4], column: h2[5] } : f2.source.end = { line: h2[2], column: h2[3] }; t6[0][0] !== "word"; )
                f2.raws.before += t6.shift()[1];
              for (f2.source.start = { line: t6[0][2], column: t6[0][3] }, f2.prop = ""; t6.length; ) {
                var d2 = t6[0][0];
                if (d2 === ":" || d2 === "space" || d2 === "comment")
                  break;
                f2.prop += t6.shift()[1];
              }
              for (f2.raws.between = ""; t6.length; ) {
                if ((p2 = t6.shift())[0] === ":") {
                  f2.raws.between += p2[1];
                  break;
                }
                f2.raws.between += p2[1];
              }
              f2.prop[0] !== "_" && f2.prop[0] !== "*" || (f2.raws.before += f2.prop[0], f2.prop = f2.prop.slice(1)), f2.raws.between += this.spacesAndCommentsFromStart(t6), this.precheckMissedSemicolon(t6);
              for (var D2 = t6.length - 1; D2 > 0; D2--) {
                if ((p2 = t6[D2])[1] === "!important") {
                  f2.important = true;
                  var g2 = this.stringFrom(t6, D2);
                  (g2 = this.spacesFromEnd(t6) + g2) !== " !important" && (f2.raws.important = g2);
                  break;
                }
                if (p2[1] === "important") {
                  for (var m2 = t6.slice(0), v2 = "", y2 = D2; y2 > 0; y2--) {
                    var w2 = m2[y2][0];
                    if (v2.trim().indexOf("!") === 0 && w2 !== "space")
                      break;
                    v2 = m2.pop()[1] + v2;
                  }
                  v2.trim().indexOf("!") === 0 && (f2.important = true, f2.raws.important = v2, t6 = m2);
                }
                if (p2[0] !== "space" && p2[0] !== "comment")
                  break;
              }
              this.raw(f2, "value", t6), f2.value.indexOf(":") !== -1 && this.checkMissedSemicolon(t6), this.current = f2;
            }
          }, u3.comment = function(t6) {
            if (t6[6] === "inline") {
              var r5 = new n2();
              this.init(r5, t6[2], t6[3]), r5.raws.inline = true, r5.source.end = { line: t6[4], column: t6[5] };
              var o4 = t6[1].slice(2);
              if (/^\s*$/.test(o4))
                r5.text = "", r5.raws.left = o4, r5.raws.right = "";
              else {
                var i3 = o4.match(/^(\s*)([^]*[^\s])(\s*)$/), s3 = i3[2].replace(/(\*\/|\/\*)/g, "*//*");
                r5.text = s3, r5.raws.left = i3[1], r5.raws.right = i3[3], r5.raws.text = i3[2];
              }
            } else
              e5.prototype.comment.call(this, t6);
          }, u3.raw = function(t6, r5, n3) {
            if (e5.prototype.raw.call(this, t6, r5, n3), t6.raws[r5]) {
              var o4 = t6.raws[r5].raw;
              t6.raws[r5].raw = n3.reduce(function(e6, t7) {
                return t7[0] === "comment" && t7[6] === "inline" ? e6 + "/*" + t7[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*") + "*/" : e6 + t7[1];
              }, ""), o4 !== t6.raws[r5].raw && (t6.raws[r5].scss = o4);
            }
          }, o3;
        }(o2);
        e4.exports = u2;
      }, 9235: (e4, t4, r3) => {
        var n2 = function(e5) {
          var t5, r4;
          function n3() {
            return e5.apply(this, arguments) || this;
          }
          r4 = e5, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var o2 = n3.prototype;
          return o2.comment = function(e6) {
            var t6 = this.raw(e6, "left", "commentLeft"), r5 = this.raw(e6, "right", "commentRight");
            if (e6.raws.inline) {
              var n4 = e6.raws.text || e6.text;
              this.builder("//" + t6 + n4 + r5, e6);
            } else
              this.builder("/*" + t6 + e6.text + r5 + "*/", e6);
          }, o2.decl = function(t6, r5) {
            if (t6.isNested) {
              var n4, o3 = this.raw(t6, "between", "colon"), i2 = t6.prop + o3 + this.rawValue(t6, "value");
              t6.important && (i2 += t6.raws.important || " !important"), this.builder(i2 + "{", t6, "start"), t6.nodes && t6.nodes.length ? (this.body(t6), n4 = this.raw(t6, "after")) : n4 = this.raw(t6, "after", "emptyBody"), n4 && this.builder(n4), this.builder("}", t6, "end");
            } else
              e5.prototype.decl.call(this, t6, r5);
          }, o2.rawValue = function(e6, t6) {
            var r5 = e6[t6], n4 = e6.raws[t6];
            return n4 && n4.value === r5 ? n4.scss ? n4.scss : n4.raw : r5;
          }, n3;
        }(r3(5701));
        e4.exports = n2;
      }, 4933: (e4, t4, r3) => {
        var n2 = r3(9235);
        e4.exports = function(e5, t5) {
          new n2(t5).stringify(e5);
        };
      }, 304: (e4, t4, r3) => {
        var n2 = r3(4933), o2 = r3(1945);
        e4.exports = { parse: o2, stringify: n2 };
      }, 6256: (e4) => {
        var t4 = "'".charCodeAt(0), r3 = '"'.charCodeAt(0), n2 = "\\".charCodeAt(0), o2 = "/".charCodeAt(0), i2 = "\n".charCodeAt(0), s2 = " ".charCodeAt(0), u2 = "\f".charCodeAt(0), a2 = "	".charCodeAt(0), c2 = "\r".charCodeAt(0), l2 = "[".charCodeAt(0), f2 = "]".charCodeAt(0), p2 = "(".charCodeAt(0), h2 = ")".charCodeAt(0), d2 = "{".charCodeAt(0), D2 = "}".charCodeAt(0), g2 = ";".charCodeAt(0), m2 = "*".charCodeAt(0), v2 = ":".charCodeAt(0), y2 = "@".charCodeAt(0), w2 = ",".charCodeAt(0), b2 = "#".charCodeAt(0), C2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, E2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, F2 = /.[\\/("'\n]/, x2 = /[a-f0-9]/i, A2 = /[\r\f\n]/g;
        e4.exports = function(e5, k2) {
          k2 === void 0 && (k2 = {});
          var O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2, $2, U2, G2 = e5.css.valueOf(), W2 = k2.ignoreErrors, z2 = G2.length, V2 = -1, q2 = 1, X2 = 0, J2 = [], H2 = [];
          function Y2(t5) {
            throw e5.error("Unclosed " + t5, q2, X2 - V2);
          }
          function K2() {
            for (var e6 = 1, o3 = false, i3 = false; e6 > 0; )
              _2 += 1, G2.length <= _2 && Y2("interpolation"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), o3 ? i3 || O2 !== o3 ? O2 === n2 ? i3 = !L2 : i3 && (i3 = false) : (o3 = false, i3 = false) : O2 === t4 || O2 === r3 ? o3 = O2 : O2 === D2 ? e6 -= 1 : O2 === b2 && P2 === d2 && (e6 += 1);
          }
          return { back: function(e6) {
            H2.push(e6);
          }, nextToken: function() {
            if (H2.length)
              return H2.pop();
            if (!(X2 >= z2)) {
              switch (((O2 = G2.charCodeAt(X2)) === i2 || O2 === u2 || O2 === c2 && G2.charCodeAt(X2 + 1) !== i2) && (V2 = X2, q2 += 1), O2) {
                case i2:
                case s2:
                case a2:
                case c2:
                case u2:
                  _2 = X2;
                  do {
                    _2 += 1, (O2 = G2.charCodeAt(_2)) === i2 && (V2 = _2, q2 += 1);
                  } while (O2 === s2 || O2 === i2 || O2 === a2 || O2 === c2 || O2 === u2);
                  $2 = ["space", G2.slice(X2, _2)], X2 = _2 - 1;
                  break;
                case l2:
                  $2 = ["[", "[", q2, X2 - V2];
                  break;
                case f2:
                  $2 = ["]", "]", q2, X2 - V2];
                  break;
                case d2:
                  $2 = ["{", "{", q2, X2 - V2];
                  break;
                case D2:
                  $2 = ["}", "}", q2, X2 - V2];
                  break;
                case w2:
                  $2 = ["word", ",", q2, X2 - V2, q2, X2 - V2 + 1];
                  break;
                case v2:
                  $2 = [":", ":", q2, X2 - V2];
                  break;
                case g2:
                  $2 = [";", ";", q2, X2 - V2];
                  break;
                case p2:
                  if (B2 = J2.length ? J2.pop()[1] : "", P2 = G2.charCodeAt(X2 + 1), B2 === "url" && P2 !== t4 && P2 !== r3) {
                    for (U2 = 1, L2 = false, _2 = X2 + 1; _2 <= G2.length - 1; ) {
                      if ((P2 = G2.charCodeAt(_2)) === n2)
                        L2 = !L2;
                      else if (P2 === p2)
                        U2 += 1;
                      else if (P2 === h2 && (U2 -= 1) == 0)
                        break;
                      _2 += 1;
                    }
                    N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["brackets", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2;
                  } else
                    _2 = G2.indexOf(")", X2 + 1), N2 = G2.slice(X2, _2 + 1), _2 === -1 || F2.test(N2) ? $2 = ["(", "(", q2, X2 - V2] : ($2 = ["brackets", N2, q2, X2 - V2, q2, _2 - V2], X2 = _2);
                  break;
                case h2:
                  $2 = [")", ")", q2, X2 - V2];
                  break;
                case t4:
                case r3:
                  for (S2 = O2, _2 = X2, L2 = false; _2 < z2 && (++_2 === z2 && Y2("string"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), L2 || O2 !== S2); )
                    O2 === n2 ? L2 = !L2 : L2 ? L2 = false : O2 === b2 && P2 === d2 && K2();
                  N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["string", G2.slice(X2, _2 + 1), q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2;
                  break;
                case y2:
                  C2.lastIndex = X2 + 1, C2.test(G2), _2 = C2.lastIndex === 0 ? G2.length - 1 : C2.lastIndex - 2, $2 = ["at-word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], X2 = _2;
                  break;
                case n2:
                  for (_2 = X2, M2 = true; G2.charCodeAt(_2 + 1) === n2; )
                    _2 += 1, M2 = !M2;
                  if (O2 = G2.charCodeAt(_2 + 1), M2 && O2 !== o2 && O2 !== s2 && O2 !== i2 && O2 !== a2 && O2 !== c2 && O2 !== u2 && (_2 += 1, x2.test(G2.charAt(_2)))) {
                    for (; x2.test(G2.charAt(_2 + 1)); )
                      _2 += 1;
                    G2.charCodeAt(_2 + 1) === s2 && (_2 += 1);
                  }
                  $2 = ["word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], X2 = _2;
                  break;
                default:
                  P2 = G2.charCodeAt(X2 + 1), O2 === b2 && P2 === d2 ? (_2 = X2, K2(), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["word", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === m2 ? ((_2 = G2.indexOf("*/", X2 + 2) + 1) === 0 && (W2 ? _2 = G2.length : Y2("comment")), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["comment", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === o2 ? (A2.lastIndex = X2 + 1, A2.test(G2), _2 = A2.lastIndex === 0 ? G2.length - 1 : A2.lastIndex - 2, N2 = G2.slice(X2, _2 + 1), $2 = ["comment", N2, q2, X2 - V2, q2, _2 - V2, "inline"], X2 = _2) : (E2.lastIndex = X2 + 1, E2.test(G2), _2 = E2.lastIndex === 0 ? G2.length - 1 : E2.lastIndex - 2, $2 = ["word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], J2.push($2), X2 = _2);
              }
              return X2++, $2;
            }
          }, endOfFile: function() {
            return H2.length === 0 && X2 >= z2;
          } };
        };
      }, 1264: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2 = m2(r3(2566)), o2 = m2(r3(616)), i2 = m2(r3(7835)), s2 = m2(r3(478)), u2 = m2(r3(4907)), a2 = m2(r3(8420)), c2 = m2(r3(7523)), l2 = m2(r3(4316)), f2 = m2(r3(6909)), p2 = m2(r3(6279)), h2 = m2(r3(439)), d2 = m2(r3(9956)), D2 = m2(r3(70)), g2 = function(e5) {
          if (e5 && e5.__esModule)
            return e5;
          var t5 = {};
          if (e5 != null)
            for (var r4 in e5)
              Object.prototype.hasOwnProperty.call(e5, r4) && (t5[r4] = e5[r4]);
          return t5.default = e5, t5;
        }(r3(8790));
        function m2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        var v2 = function(e5) {
          return new n2.default(e5);
        };
        v2.attribute = function(e5) {
          return new o2.default(e5);
        }, v2.className = function(e5) {
          return new i2.default(e5);
        }, v2.combinator = function(e5) {
          return new s2.default(e5);
        }, v2.comment = function(e5) {
          return new u2.default(e5);
        }, v2.id = function(e5) {
          return new a2.default(e5);
        }, v2.nesting = function(e5) {
          return new c2.default(e5);
        }, v2.pseudo = function(e5) {
          return new l2.default(e5);
        }, v2.root = function(e5) {
          return new f2.default(e5);
        }, v2.selector = function(e5) {
          return new p2.default(e5);
        }, v2.string = function(e5) {
          return new h2.default(e5);
        }, v2.tag = function(e5) {
          return new d2.default(e5);
        }, v2.universal = function(e5) {
          return new D2.default(e5);
        }, Object.keys(g2).forEach(function(e5) {
          e5 !== "__esModule" && (v2[e5] = g2[e5]);
        }), t4.default = v2, e4.exports = t4.default;
      }, 5269: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2 = function() {
          function e5(e6, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e6, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e5(t5.prototype, r4), n3 && e5(t5, n3), t5;
          };
        }(), o2 = C2(r3(8051)), i2 = C2(r3(7886)), s2 = C2(r3(3210)), u2 = C2(r3(6909)), a2 = C2(r3(6279)), c2 = C2(r3(7835)), l2 = C2(r3(4907)), f2 = C2(r3(8420)), p2 = C2(r3(9956)), h2 = C2(r3(439)), d2 = C2(r3(4316)), D2 = C2(r3(616)), g2 = C2(r3(70)), m2 = C2(r3(478)), v2 = C2(r3(7523)), y2 = C2(r3(9788)), w2 = C2(r3(6554)), b2 = function(e5) {
          if (e5 && e5.__esModule)
            return e5;
          var t5 = {};
          if (e5 != null)
            for (var r4 in e5)
              Object.prototype.hasOwnProperty.call(e5, r4) && (t5[r4] = e5[r4]);
          return t5.default = e5, t5;
        }(r3(8790));
        function C2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        var E2 = function() {
          function e5(t5) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, e5), this.input = t5, this.lossy = t5.options.lossless === false, this.position = 0, this.root = new u2.default();
            var r4 = new a2.default();
            return this.root.append(r4), this.current = r4, this.lossy ? this.tokens = (0, w2.default)({ safe: t5.safe, css: t5.css.trim() }) : this.tokens = (0, w2.default)(t5), this.loop();
          }
          return e5.prototype.attribute = function() {
            var e6 = "", t5 = void 0, r4 = this.currToken;
            for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
              e6 += this.tokens[this.position][1], this.position++;
            this.position !== this.tokens.length || ~e6.indexOf("]") || this.error("Expected a closing square bracket.");
            var n3 = e6.split(/((?:[*~^$|]?=))([^]*)/), o3 = n3[0].split(/(\|)/g), i3 = { operator: n3[1], value: n3[2], source: { start: { line: r4[2], column: r4[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: r4[4] };
            if (o3.length > 1 ? (o3[0] === "" && (o3[0] = true), i3.attribute = this.parseValue(o3[2]), i3.namespace = this.parseNamespace(o3[0])) : i3.attribute = this.parseValue(n3[0]), t5 = new D2.default(i3), n3[2]) {
              var s3 = n3[2].split(/(\s+i\s*?)$/), u3 = s3[0].trim();
              t5.value = this.lossy ? u3 : s3[0], s3[1] && (t5.insensitive = true, this.lossy || (t5.raws.insensitive = s3[1])), t5.quoted = u3[0] === "'" || u3[0] === '"', t5.raws.unquoted = t5.quoted ? u3.slice(1, -1) : u3;
            }
            this.newNode(t5), this.position++;
          }, e5.prototype.combinator = function() {
            if (this.currToken[1] === "|")
              return this.namespace();
            for (var e6 = new m2.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
              this.nextToken && this.nextToken[0] === "combinator" ? (e6.spaces.before = this.parseSpace(this.currToken[1]), e6.source.start.line = this.nextToken[2], e6.source.start.column = this.nextToken[3], e6.source.end.column = this.nextToken[3], e6.source.end.line = this.nextToken[2], e6.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? e6.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? e6.value = this.currToken[1] : this.currToken[0] === "space" && (e6.value = this.parseSpace(this.currToken[1], " ")), this.position++;
            return this.newNode(e6);
          }, e5.prototype.comma = function() {
            if (this.position === this.tokens.length - 1)
              return this.root.trailingComma = true, void this.position++;
            var e6 = new a2.default();
            this.current.parent.append(e6), this.current = e6, this.position++;
          }, e5.prototype.comment = function() {
            var e6 = new l2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
            this.newNode(e6), this.position++;
          }, e5.prototype.error = function(e6) {
            throw new this.input.error(e6);
          }, e5.prototype.missingBackslash = function() {
            return this.error("Expected a backslash preceding the semicolon.");
          }, e5.prototype.missingParenthesis = function() {
            return this.error("Expected opening parenthesis.");
          }, e5.prototype.missingSquareBracket = function() {
            return this.error("Expected opening square bracket.");
          }, e5.prototype.namespace = function() {
            var e6 = this.prevToken && this.prevToken[1] || true;
            return this.nextToken[0] === "word" ? (this.position++, this.word(e6)) : this.nextToken[0] === "*" ? (this.position++, this.universal(e6)) : void 0;
          }, e5.prototype.nesting = function() {
            this.newNode(new v2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
          }, e5.prototype.parentheses = function() {
            var e6 = this.current.last;
            if (e6 && e6.type === b2.PSEUDO) {
              var t5 = new a2.default(), r4 = this.current;
              e6.append(t5), this.current = t5;
              var n3 = 1;
              for (this.position++; this.position < this.tokens.length && n3; )
                this.currToken[0] === "(" && n3++, this.currToken[0] === ")" && n3--, n3 ? this.parse() : (t5.parent.source.end.line = this.currToken[2], t5.parent.source.end.column = this.currToken[3], this.position++);
              n3 && this.error("Expected closing parenthesis."), this.current = r4;
            } else {
              var o3 = 1;
              for (this.position++, e6.value += "("; this.position < this.tokens.length && o3; )
                this.currToken[0] === "(" && o3++, this.currToken[0] === ")" && o3--, e6.value += this.parseParenthesisToken(this.currToken), this.position++;
              o3 && this.error("Expected closing parenthesis.");
            }
          }, e5.prototype.pseudo = function() {
            for (var e6 = this, t5 = "", r4 = this.currToken; this.currToken && this.currToken[0] === ":"; )
              t5 += this.currToken[1], this.position++;
            if (!this.currToken)
              return this.error("Expected pseudo-class or pseudo-element");
            if (this.currToken[0] === "word") {
              var n3 = void 0;
              this.splitWord(false, function(o3, i3) {
                t5 += o3, n3 = new d2.default({ value: t5, source: { start: { line: r4[2], column: r4[3] }, end: { line: e6.currToken[4], column: e6.currToken[5] } }, sourceIndex: r4[4] }), e6.newNode(n3), i3 > 1 && e6.nextToken && e6.nextToken[0] === "(" && e6.error("Misplaced parenthesis.");
              });
            } else
              this.error('Unexpected "' + this.currToken[0] + '" found.');
          }, e5.prototype.space = function() {
            var e6 = this.currToken;
            this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(e6[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(e6[1]), this.position++) : this.combinator();
          }, e5.prototype.string = function() {
            var e6 = this.currToken;
            this.newNode(new h2.default({ value: this.currToken[1], source: { start: { line: e6[2], column: e6[3] }, end: { line: e6[4], column: e6[5] } }, sourceIndex: e6[6] })), this.position++;
          }, e5.prototype.universal = function(e6) {
            var t5 = this.nextToken;
            if (t5 && t5[1] === "|")
              return this.position++, this.namespace();
            this.newNode(new g2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), e6), this.position++;
          }, e5.prototype.splitWord = function(e6, t5) {
            for (var r4 = this, n3 = this.nextToken, u3 = this.currToken[1]; n3 && n3[0] === "word"; ) {
              this.position++;
              var a3 = this.currToken[1];
              if (u3 += a3, a3.lastIndexOf("\\") === a3.length - 1) {
                var l3 = this.nextToken;
                l3 && l3[0] === "space" && (u3 += this.parseSpace(l3[1], " "), this.position++);
              }
              n3 = this.nextToken;
            }
            var h3 = (0, i2.default)(u3, "."), d3 = (0, i2.default)(u3, "#"), D3 = (0, i2.default)(u3, "#{");
            D3.length && (d3 = d3.filter(function(e7) {
              return !~D3.indexOf(e7);
            }));
            var g3 = (0, y2.default)((0, s2.default)((0, o2.default)([[0], h3, d3])));
            g3.forEach(function(n4, o3) {
              var i3 = g3[o3 + 1] || u3.length, s3 = u3.slice(n4, i3);
              if (o3 === 0 && t5)
                return t5.call(r4, s3, g3.length);
              var a4 = void 0;
              a4 = ~h3.indexOf(n4) ? new c2.default({ value: s3.slice(1), source: { start: { line: r4.currToken[2], column: r4.currToken[3] + n4 }, end: { line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1) } }, sourceIndex: r4.currToken[6] + g3[o3] }) : ~d3.indexOf(n4) ? new f2.default({ value: s3.slice(1), source: { start: { line: r4.currToken[2], column: r4.currToken[3] + n4 }, end: { line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1) } }, sourceIndex: r4.currToken[6] + g3[o3] }) : new p2.default({ value: s3, source: { start: { line: r4.currToken[2], column: r4.currToken[3] + n4 }, end: { line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1) } }, sourceIndex: r4.currToken[6] + g3[o3] }), r4.newNode(a4, e6);
            }), this.position++;
          }, e5.prototype.word = function(e6) {
            var t5 = this.nextToken;
            return t5 && t5[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(e6);
          }, e5.prototype.loop = function() {
            for (; this.position < this.tokens.length; )
              this.parse(true);
            return this.root;
          }, e5.prototype.parse = function(e6) {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parentheses();
                break;
              case ")":
                e6 && this.missingParenthesis();
                break;
              case "[":
                this.attribute();
                break;
              case "]":
                this.missingSquareBracket();
                break;
              case "at-word":
              case "word":
                this.word();
                break;
              case ":":
                this.pseudo();
                break;
              case ";":
                this.missingBackslash();
                break;
              case ",":
                this.comma();
                break;
              case "*":
                this.universal();
                break;
              case "&":
                this.nesting();
                break;
              case "combinator":
                this.combinator();
                break;
              case "string":
                this.string();
            }
          }, e5.prototype.parseNamespace = function(e6) {
            if (this.lossy && typeof e6 == "string") {
              var t5 = e6.trim();
              return !t5.length || t5;
            }
            return e6;
          }, e5.prototype.parseSpace = function(e6, t5) {
            return this.lossy ? t5 || "" : e6;
          }, e5.prototype.parseValue = function(e6) {
            return this.lossy && e6 && typeof e6 == "string" ? e6.trim() : e6;
          }, e5.prototype.parseParenthesisToken = function(e6) {
            return this.lossy ? e6[0] === "space" ? this.parseSpace(e6[1], " ") : this.parseValue(e6[1]) : e6[1];
          }, e5.prototype.newNode = function(e6, t5) {
            return t5 && (e6.namespace = this.parseNamespace(t5)), this.spaces && (e6.spaces.before = this.spaces, this.spaces = ""), this.current.append(e6);
          }, n2(e5, [{ key: "currToken", get: function() {
            return this.tokens[this.position];
          } }, { key: "nextToken", get: function() {
            return this.tokens[this.position + 1];
          } }, { key: "prevToken", get: function() {
            return this.tokens[this.position - 1];
          } }]), e5;
        }();
        t4.default = E2, e4.exports = t4.default;
      }, 2566: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = function() {
          function e5(e6, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e6, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e5(t5.prototype, r4), n3 && e5(t5, n3), t5;
          };
        }(), i2 = (n2 = r3(5269)) && n2.__esModule ? n2 : { default: n2 }, s2 = function() {
          function e5(t5) {
            return function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, e5), this.func = t5 || function() {
            }, this;
          }
          return e5.prototype.process = function(e6) {
            var t5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r4 = new i2.default({ css: e6, error: function(e7) {
              throw new Error(e7);
            }, options: t5 });
            return this.res = r4, this.func(r4), this;
          }, o2(e5, [{ key: "result", get: function() {
            return String(this.res);
          } }]), e5;
        }();
        t4.default = s2, e4.exports = t4.default;
      }, 616: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.ATTRIBUTE, n3.raws = {}, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5.prototype.toString = function() {
            var e6 = [this.spaces.before, "[", this.ns, this.attribute];
            return this.operator && e6.push(this.operator), this.value && e6.push(this.value), this.raws.insensitive ? e6.push(this.raws.insensitive) : this.insensitive && e6.push(" i"), e6.push("]"), e6.concat(this.spaces.after).join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 7835: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.CLASS, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5.prototype.toString = function() {
            return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 478: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.COMBINATOR, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 4907: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.COMMENT, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 7144: (e4, t4, r3) => {
        r3(4070), t4.__esModule = true;
        var n2, o2 = function() {
          function e5(e6, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e6, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e5(t5.prototype, r4), n3 && e5(t5, n3), t5;
          };
        }(), i2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, s2 = function(e5) {
          if (e5 && e5.__esModule)
            return e5;
          var t5 = {};
          if (e5 != null)
            for (var r4 in e5)
              Object.prototype.hasOwnProperty.call(e5, r4) && (t5[r4] = e5[r4]);
          return t5.default = e5, t5;
        }(r3(8790)), u2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.nodes || (n3.nodes = []), n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5.prototype.append = function(e6) {
            return e6.parent = this, this.nodes.push(e6), this;
          }, t5.prototype.prepend = function(e6) {
            return e6.parent = this, this.nodes.unshift(e6), this;
          }, t5.prototype.at = function(e6) {
            return this.nodes[e6];
          }, t5.prototype.index = function(e6) {
            return typeof e6 == "number" ? e6 : this.nodes.indexOf(e6);
          }, t5.prototype.removeChild = function(e6) {
            e6 = this.index(e6), this.at(e6).parent = void 0, this.nodes.splice(e6, 1);
            var t6 = void 0;
            for (var r4 in this.indexes)
              (t6 = this.indexes[r4]) >= e6 && (this.indexes[r4] = t6 - 1);
            return this;
          }, t5.prototype.removeAll = function() {
            var e6 = this.nodes, t6 = Array.isArray(e6), r4 = 0;
            for (e6 = t6 ? e6 : e6[Symbol.iterator](); ; ) {
              var n3;
              if (t6) {
                if (r4 >= e6.length)
                  break;
                n3 = e6[r4++];
              } else {
                if ((r4 = e6.next()).done)
                  break;
                n3 = r4.value;
              }
              n3.parent = void 0;
            }
            return this.nodes = [], this;
          }, t5.prototype.empty = function() {
            return this.removeAll();
          }, t5.prototype.insertAfter = function(e6, t6) {
            var r4 = this.index(e6);
            this.nodes.splice(r4 + 1, 0, t6);
            var n3 = void 0;
            for (var o3 in this.indexes)
              r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
            return this;
          }, t5.prototype.insertBefore = function(e6, t6) {
            var r4 = this.index(e6);
            this.nodes.splice(r4, 0, t6);
            var n3 = void 0;
            for (var o3 in this.indexes)
              r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
            return this;
          }, t5.prototype.each = function(e6) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
            var t6 = this.lastEach;
            if (this.indexes[t6] = 0, this.length) {
              for (var r4 = void 0, n3 = void 0; this.indexes[t6] < this.length && (r4 = this.indexes[t6], (n3 = e6(this.at(r4), r4)) !== false); )
                this.indexes[t6] += 1;
              return delete this.indexes[t6], n3 !== false && void 0;
            }
          }, t5.prototype.walk = function(e6) {
            return this.each(function(t6, r4) {
              var n3 = e6(t6, r4);
              if (n3 !== false && t6.length && (n3 = t6.walk(e6)), n3 === false)
                return false;
            });
          }, t5.prototype.walkAttributes = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.ATTRIBUTE)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkClasses = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.CLASS)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkCombinators = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.COMBINATOR)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkComments = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.COMMENT)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkIds = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.ID)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkNesting = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.NESTING)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkPseudos = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.PSEUDO)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkTags = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.TAG)
                return e6.call(t6, r4);
            });
          }, t5.prototype.walkUniversals = function(e6) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.UNIVERSAL)
                return e6.call(t6, r4);
            });
          }, t5.prototype.split = function(e6) {
            var t6 = this, r4 = [];
            return this.reduce(function(n3, o3, i3) {
              var s3 = e6.call(t6, o3);
              return r4.push(o3), s3 ? (n3.push(r4), r4 = []) : i3 === t6.length - 1 && n3.push(r4), n3;
            }, []);
          }, t5.prototype.map = function(e6) {
            return this.nodes.map(e6);
          }, t5.prototype.reduce = function(e6, t6) {
            return this.nodes.reduce(e6, t6);
          }, t5.prototype.every = function(e6) {
            return this.nodes.every(e6);
          }, t5.prototype.some = function(e6) {
            return this.nodes.some(e6);
          }, t5.prototype.filter = function(e6) {
            return this.nodes.filter(e6);
          }, t5.prototype.sort = function(e6) {
            return this.nodes.sort(e6);
          }, t5.prototype.toString = function() {
            return this.map(String).join("");
          }, o2(t5, [{ key: "first", get: function() {
            return this.at(0);
          } }, { key: "last", get: function() {
            return this.at(this.length - 1);
          } }, { key: "length", get: function() {
            return this.nodes.length;
          } }]), t5;
        }(i2.default);
        t4.default = u2, e4.exports = t4.default;
      }, 8420: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.ID, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5.prototype.toString = function() {
            return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 4379: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = function() {
          function e5(e6, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e6, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e5(t5.prototype, r4), n3 && e5(t5, n3), t5;
          };
        }();
        function i2(e5, t5) {
          if (!(e5 instanceof t5))
            throw new TypeError("Cannot call a class as a function");
        }
        function s2(e5, t5) {
          if (!e5)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !t5 || typeof t5 != "object" && typeof t5 != "function" ? e5 : t5;
        }
        var u2 = function(e5) {
          function t5() {
            return i2(this, t5), s2(this, e5.apply(this, arguments));
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5.prototype.toString = function() {
            return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
          }, o2(t5, [{ key: "ns", get: function() {
            var e6 = this.namespace;
            return e6 ? (typeof e6 == "string" ? e6 : "") + "|" : "";
          } }]), t5;
        }(((n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = u2, e4.exports = t4.default;
      }, 7523: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.NESTING, n3.value = "&", n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 8871: (e4, t4) => {
        t4.__esModule = true;
        var r3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        };
        function n2(e5, t5) {
          if (!(e5 instanceof t5))
            throw new TypeError("Cannot call a class as a function");
        }
        var o2 = function e5(t5, n3) {
          if ((t5 === void 0 ? "undefined" : r3(t5)) !== "object")
            return t5;
          var o3 = new t5.constructor();
          for (var i3 in t5)
            if (t5.hasOwnProperty(i3)) {
              var s2 = t5[i3], u2 = s2 === void 0 ? "undefined" : r3(s2);
              i3 === "parent" && u2 === "object" ? n3 && (o3[i3] = n3) : o3[i3] = s2 instanceof Array ? s2.map(function(t6) {
                return e5(t6, o3);
              }) : e5(s2, o3);
            }
          return o3;
        }, i2 = function() {
          function e5() {
            var t5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            for (var r4 in n2(this, e5), t5)
              this[r4] = t5[r4];
            var o3 = t5.spaces, i3 = (o3 = o3 === void 0 ? {} : o3).before, s2 = i3 === void 0 ? "" : i3, u2 = o3.after, a2 = u2 === void 0 ? "" : u2;
            this.spaces = { before: s2, after: a2 };
          }
          return e5.prototype.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }, e5.prototype.replaceWith = function() {
            if (this.parent) {
              for (var e6 in arguments)
                this.parent.insertBefore(this, arguments[e6]);
              this.remove();
            }
            return this;
          }, e5.prototype.next = function() {
            return this.parent.at(this.parent.index(this) + 1);
          }, e5.prototype.prev = function() {
            return this.parent.at(this.parent.index(this) - 1);
          }, e5.prototype.clone = function() {
            var e6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t5 = o2(this);
            for (var r4 in e6)
              t5[r4] = e6[r4];
            return t5;
          }, e5.prototype.toString = function() {
            return [this.spaces.before, String(this.value), this.spaces.after].join("");
          }, e5;
        }();
        t4.default = i2, e4.exports = t4.default;
      }, 4316: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.PSEUDO, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5.prototype.toString = function() {
            var e6 = this.length ? "(" + this.map(String).join(",") + ")" : "";
            return [this.spaces.before, String(this.value), e6, this.spaces.after].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 6909: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.ROOT, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5.prototype.toString = function() {
            var e6 = this.reduce(function(e7, t6) {
              var r4 = String(t6);
              return r4 ? e7 + r4 + "," : "";
            }, "").slice(0, -1);
            return this.trailingComma ? e6 + "," : e6;
          }, t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 6279: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.SELECTOR, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 439: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.STRING, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 9956: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.TAG, n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 8790: (e4, t4) => {
        t4.__esModule = true, t4.TAG = "tag", t4.STRING = "string", t4.SELECTOR = "selector", t4.ROOT = "root", t4.PSEUDO = "pseudo", t4.NESTING = "nesting", t4.ID = "id", t4.COMMENT = "comment", t4.COMBINATOR = "combinator", t4.CLASS = "class", t4.ATTRIBUTE = "attribute", t4.UNIVERSAL = "universal";
      }, 70: (e4, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e5) {
          function t5(r4) {
            !function(e6, t6) {
              if (!(e6 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e6, t6) {
              if (!e6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e6 : t6;
            }(this, e5.call(this, r4));
            return n3.type = i2.UNIVERSAL, n3.value = "*", n3;
          }
          return function(e6, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e6.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e6, t6) : e6.__proto__ = t6);
          }(t5, e5), t5;
        }(o2.default);
        t4.default = s2, e4.exports = t4.default;
      }, 9788: (e4, t4, r3) => {
        r3(4070), t4.__esModule = true, t4.default = function(e5) {
          return e5.sort(function(e6, t5) {
            return e6 - t5;
          });
        }, e4.exports = t4.default;
      }, 6554: (e4, t4) => {
        t4.__esModule = true, t4.default = function(e5) {
          for (var t5 = [], o2 = e5.css.valueOf(), i2 = void 0, s2 = void 0, u2 = void 0, a2 = void 0, c2 = void 0, l2 = void 0, f2 = void 0, p2 = void 0, h2 = void 0, d2 = void 0, D2 = void 0, g2 = o2.length, m2 = -1, v2 = 1, y2 = 0, w2 = function(t6, r4) {
            if (!e5.safe)
              throw e5.error("Unclosed " + t6, v2, y2 - m2, y2);
            s2 = (o2 += r4).length - 1;
          }; y2 < g2; ) {
            switch ((i2 = o2.charCodeAt(y2)) === 10 && (m2 = y2, v2 += 1), i2) {
              case 10:
              case 32:
              case 9:
              case 13:
              case 12:
                s2 = y2;
                do {
                  s2 += 1, (i2 = o2.charCodeAt(s2)) === 10 && (m2 = s2, v2 += 1);
                } while (i2 === 32 || i2 === 10 || i2 === 9 || i2 === 13 || i2 === 12);
                t5.push(["space", o2.slice(y2, s2), v2, y2 - m2, y2]), y2 = s2 - 1;
                break;
              case 43:
              case 62:
              case 126:
              case 124:
                s2 = y2;
                do {
                  s2 += 1, i2 = o2.charCodeAt(s2);
                } while (i2 === 43 || i2 === 62 || i2 === 126 || i2 === 124);
                t5.push(["combinator", o2.slice(y2, s2), v2, y2 - m2, y2]), y2 = s2 - 1;
                break;
              case 42:
                t5.push(["*", "*", v2, y2 - m2, y2]);
                break;
              case 38:
                t5.push(["&", "&", v2, y2 - m2, y2]);
                break;
              case 44:
                t5.push([",", ",", v2, y2 - m2, y2]);
                break;
              case 91:
                t5.push(["[", "[", v2, y2 - m2, y2]);
                break;
              case 93:
                t5.push(["]", "]", v2, y2 - m2, y2]);
                break;
              case 58:
                t5.push([":", ":", v2, y2 - m2, y2]);
                break;
              case 59:
                t5.push([";", ";", v2, y2 - m2, y2]);
                break;
              case 40:
                t5.push(["(", "(", v2, y2 - m2, y2]);
                break;
              case 41:
                t5.push([")", ")", v2, y2 - m2, y2]);
                break;
              case 39:
              case 34:
                u2 = i2 === 39 ? "'" : '"', s2 = y2;
                do {
                  for (d2 = false, (s2 = o2.indexOf(u2, s2 + 1)) === -1 && w2("quote", u2), D2 = s2; o2.charCodeAt(D2 - 1) === 92; )
                    D2 -= 1, d2 = !d2;
                } while (d2);
                t5.push(["string", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
                break;
              case 64:
                r3.lastIndex = y2 + 1, r3.test(o2), s2 = r3.lastIndex === 0 ? o2.length - 1 : r3.lastIndex - 2, t5.push(["at-word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
                break;
              case 92:
                for (s2 = y2, f2 = true; o2.charCodeAt(s2 + 1) === 92; )
                  s2 += 1, f2 = !f2;
                i2 = o2.charCodeAt(s2 + 1), f2 && i2 !== 47 && i2 !== 32 && i2 !== 10 && i2 !== 9 && i2 !== 13 && i2 !== 12 && (s2 += 1), t5.push(["word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
                break;
              default:
                i2 === 47 && o2.charCodeAt(y2 + 1) === 42 ? ((s2 = o2.indexOf("*/", y2 + 2) + 1) === 0 && w2("comment", "*/"), (c2 = (a2 = (l2 = o2.slice(y2, s2 + 1)).split("\n")).length - 1) > 0 ? (p2 = v2 + c2, h2 = s2 - a2[c2].length) : (p2 = v2, h2 = m2), t5.push(["comment", l2, v2, y2 - m2, p2, s2 - h2, y2]), m2 = h2, v2 = p2, y2 = s2) : (n2.lastIndex = y2 + 1, n2.test(o2), s2 = n2.lastIndex === 0 ? o2.length - 1 : n2.lastIndex - 2, t5.push(["word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2);
            }
            y2++;
          }
          return t5;
        };
        var r3 = /[ \n\t\r\{\(\)'"\\;/]/g, n2 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
        e4.exports = t4.default;
      }, 5294: (e4, t4, r3) => {
        const n2 = r3(4196);
        class o2 extends n2 {
          constructor(e5) {
            super(e5), this.type = "atword";
          }
          toString() {
            return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
          }
        }
        n2.registerWalker(o2), e4.exports = o2;
      }, 8709: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "colon";
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 3627: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "comma";
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 4384: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "comment", this.inline = Object(e5).inline || false;
          }
          toString() {
            return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 4196: (e4, t4, r3) => {
        const n2 = r3(1466);
        class o2 extends n2 {
          constructor(e5) {
            super(e5), this.nodes || (this.nodes = []);
          }
          push(e5) {
            return e5.parent = this, this.nodes.push(e5), this;
          }
          each(e5) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            let t5, r4, n3 = this.lastEach;
            if (this.indexes[n3] = 0, this.nodes) {
              for (; this.indexes[n3] < this.nodes.length && (t5 = this.indexes[n3], r4 = e5(this.nodes[t5], t5), r4 !== false); )
                this.indexes[n3] += 1;
              return delete this.indexes[n3], r4;
            }
          }
          walk(e5) {
            return this.each((t5, r4) => {
              let n3 = e5(t5, r4);
              return n3 !== false && t5.walk && (n3 = t5.walk(e5)), n3;
            });
          }
          walkType(e5, t5) {
            if (!e5 || !t5)
              throw new Error("Parameters {type} and {callback} are required.");
            const r4 = typeof e5 == "function";
            return this.walk((n3, o3) => {
              if (r4 && n3 instanceof e5 || !r4 && n3.type === e5)
                return t5.call(this, n3, o3);
            });
          }
          append(e5) {
            return e5.parent = this, this.nodes.push(e5), this;
          }
          prepend(e5) {
            return e5.parent = this, this.nodes.unshift(e5), this;
          }
          cleanRaws(e5) {
            if (super.cleanRaws(e5), this.nodes)
              for (let t5 of this.nodes)
                t5.cleanRaws(e5);
          }
          insertAfter(e5, t5) {
            let r4, n3 = this.index(e5);
            this.nodes.splice(n3 + 1, 0, t5);
            for (let e6 in this.indexes)
              r4 = this.indexes[e6], n3 <= r4 && (this.indexes[e6] = r4 + this.nodes.length);
            return this;
          }
          insertBefore(e5, t5) {
            let r4, n3 = this.index(e5);
            this.nodes.splice(n3, 0, t5);
            for (let e6 in this.indexes)
              r4 = this.indexes[e6], n3 <= r4 && (this.indexes[e6] = r4 + this.nodes.length);
            return this;
          }
          removeChild(e5) {
            let t5;
            e5 = this.index(e5), this.nodes[e5].parent = void 0, this.nodes.splice(e5, 1);
            for (let r4 in this.indexes)
              t5 = this.indexes[r4], t5 >= e5 && (this.indexes[r4] = t5 - 1);
            return this;
          }
          removeAll() {
            for (let e5 of this.nodes)
              e5.parent = void 0;
            return this.nodes = [], this;
          }
          every(e5) {
            return this.nodes.every(e5);
          }
          some(e5) {
            return this.nodes.some(e5);
          }
          index(e5) {
            return typeof e5 == "number" ? e5 : this.nodes.indexOf(e5);
          }
          get first() {
            if (this.nodes)
              return this.nodes[0];
          }
          get last() {
            if (this.nodes)
              return this.nodes[this.nodes.length - 1];
          }
          toString() {
            let e5 = this.nodes.map(String).join("");
            return this.value && (e5 = this.value + e5), this.raws.before && (e5 = this.raws.before + e5), this.raws.after && (e5 += this.raws.after), e5;
          }
        }
        o2.registerWalker = (e5) => {
          let t5 = "walk" + e5.name;
          t5.lastIndexOf("s") !== t5.length - 1 && (t5 += "s"), o2.prototype[t5] || (o2.prototype[t5] = function(t6) {
            return this.walkType(e5, t6);
          });
        }, e4.exports = o2;
      }, 9645: (e4) => {
        class t4 extends Error {
          constructor(e5) {
            super(e5), this.name = this.constructor.name, this.message = e5 || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e5).stack;
          }
        }
        e4.exports = t4;
      }, 5128: (e4) => {
        class t4 extends Error {
          constructor(e5) {
            super(e5), this.name = this.constructor.name, this.message = e5 || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e5).stack;
          }
        }
        e4.exports = t4;
      }, 4320: (e4, t4, r3) => {
        const n2 = r3(4196);
        class o2 extends n2 {
          constructor(e5) {
            super(e5), this.type = "func", this.unbalanced = -1;
          }
        }
        n2.registerWalker(o2), e4.exports = o2;
      }, 9962: (e4, t4, r3) => {
        const n2 = r3(3784), o2 = r3(5294), i2 = r3(8709), s2 = r3(3627), u2 = r3(4384), a2 = r3(4320), c2 = r3(3074), l2 = r3(7214), f2 = r3(1238), p2 = r3(9672), h2 = r3(1369), d2 = r3(2057), D2 = r3(6593);
        let g2 = function(e5, t5) {
          return new n2(e5, t5);
        };
        g2.atword = function(e5) {
          return new o2(e5);
        }, g2.colon = function(e5) {
          return new i2(Object.assign({ value: ":" }, e5));
        }, g2.comma = function(e5) {
          return new s2(Object.assign({ value: "," }, e5));
        }, g2.comment = function(e5) {
          return new u2(e5);
        }, g2.func = function(e5) {
          return new a2(e5);
        }, g2.number = function(e5) {
          return new c2(e5);
        }, g2.operator = function(e5) {
          return new l2(e5);
        }, g2.paren = function(e5) {
          return new f2(Object.assign({ value: "(" }, e5));
        }, g2.string = function(e5) {
          return new p2(Object.assign({ quote: "'" }, e5));
        }, g2.value = function(e5) {
          return new d2(e5);
        }, g2.word = function(e5) {
          return new D2(e5);
        }, g2.unicodeRange = function(e5) {
          return new h2(e5);
        }, e4.exports = g2;
      }, 1466: (e4) => {
        let t4 = function(e5, r3) {
          let n2 = new e5.constructor();
          for (let o2 in e5) {
            if (!e5.hasOwnProperty(o2))
              continue;
            let i2 = e5[o2], s2 = typeof i2;
            o2 === "parent" && s2 === "object" ? r3 && (n2[o2] = r3) : o2 === "source" ? n2[o2] = i2 : i2 instanceof Array ? n2[o2] = i2.map((e6) => t4(e6, n2)) : o2 !== "before" && o2 !== "after" && o2 !== "between" && o2 !== "semicolon" && (s2 === "object" && i2 !== null && (i2 = t4(i2)), n2[o2] = i2);
          }
          return n2;
        };
        e4.exports = class {
          constructor(e5) {
            e5 = e5 || {}, this.raws = { before: "", after: "" };
            for (let t5 in e5)
              this[t5] = e5[t5];
          }
          remove() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }
          toString() {
            return [this.raws.before, String(this.value), this.raws.after].join("");
          }
          clone(e5) {
            e5 = e5 || {};
            let r3 = t4(this);
            for (let t5 in e5)
              r3[t5] = e5[t5];
            return r3;
          }
          cloneBefore(e5) {
            e5 = e5 || {};
            let t5 = this.clone(e5);
            return this.parent.insertBefore(this, t5), t5;
          }
          cloneAfter(e5) {
            e5 = e5 || {};
            let t5 = this.clone(e5);
            return this.parent.insertAfter(this, t5), t5;
          }
          replaceWith() {
            let e5 = Array.prototype.slice.call(arguments);
            if (this.parent) {
              for (let t5 of e5)
                this.parent.insertBefore(this, t5);
              this.remove();
            }
            return this;
          }
          moveTo(e5) {
            return this.cleanRaws(this.root() === e5.root()), this.remove(), e5.append(this), this;
          }
          moveBefore(e5) {
            return this.cleanRaws(this.root() === e5.root()), this.remove(), e5.parent.insertBefore(e5, this), this;
          }
          moveAfter(e5) {
            return this.cleanRaws(this.root() === e5.root()), this.remove(), e5.parent.insertAfter(e5, this), this;
          }
          next() {
            let e5 = this.parent.index(this);
            return this.parent.nodes[e5 + 1];
          }
          prev() {
            let e5 = this.parent.index(this);
            return this.parent.nodes[e5 - 1];
          }
          toJSON() {
            let e5 = {};
            for (let t5 in this) {
              if (!this.hasOwnProperty(t5))
                continue;
              if (t5 === "parent")
                continue;
              let r3 = this[t5];
              r3 instanceof Array ? e5[t5] = r3.map((e6) => typeof e6 == "object" && e6.toJSON ? e6.toJSON() : e6) : typeof r3 == "object" && r3.toJSON ? e5[t5] = r3.toJSON() : e5[t5] = r3;
            }
            return e5;
          }
          root() {
            let e5 = this;
            for (; e5.parent; )
              e5 = e5.parent;
            return e5;
          }
          cleanRaws(e5) {
            delete this.raws.before, delete this.raws.after, e5 || delete this.raws.between;
          }
          positionInside(e5) {
            let t5 = this.toString(), r3 = this.source.start.column, n2 = this.source.start.line;
            for (let o2 = 0; o2 < e5; o2++)
              t5[o2] === "\n" ? (r3 = 1, n2 += 1) : r3 += 1;
            return { line: n2, column: r3 };
          }
          positionBy(e5) {
            let t5 = this.source.start;
            if (Object(e5).index)
              t5 = this.positionInside(e5.index);
            else if (Object(e5).word) {
              let r3 = this.toString().indexOf(e5.word);
              r3 !== -1 && (t5 = this.positionInside(r3));
            }
            return t5;
          }
        };
      }, 3074: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "number", this.unit = Object(e5).unit || "";
          }
          toString() {
            return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 7214: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "operator";
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 1238: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "paren", this.parenType = "";
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 3784: (e4, t4, r3) => {
        r3(4070);
        const n2 = r3(4343), o2 = r3(2057), i2 = r3(5294), s2 = r3(8709), u2 = r3(3627), a2 = r3(4384), c2 = r3(4320), l2 = r3(3074), f2 = r3(7214), p2 = r3(1238), h2 = r3(9672), d2 = r3(6593), D2 = r3(1369), g2 = r3(2481), m2 = r3(8051), v2 = r3(7886), y2 = r3(3210), w2 = r3(9645);
        e4.exports = class {
          constructor(e5, t5) {
            this.cache = [], this.input = e5, this.options = Object.assign({}, { loose: false }, t5), this.position = 0, this.unbalanced = 0, this.root = new n2();
            let r4 = new o2();
            this.root.append(r4), this.current = r4, this.tokens = g2(e5, this.options);
          }
          parse() {
            return this.loop();
          }
          colon() {
            let e5 = this.currToken;
            this.newNode(new s2({ value: e5[1], source: { start: { line: e5[2], column: e5[3] }, end: { line: e5[4], column: e5[5] } }, sourceIndex: e5[6] })), this.position++;
          }
          comma() {
            let e5 = this.currToken;
            this.newNode(new u2({ value: e5[1], source: { start: { line: e5[2], column: e5[3] }, end: { line: e5[4], column: e5[5] } }, sourceIndex: e5[6] })), this.position++;
          }
          comment() {
            let e5, t5 = false, r4 = this.currToken[1].replace(/\/\*|\*\//g, "");
            this.options.loose && r4.startsWith("//") && (r4 = r4.substring(2), t5 = true), e5 = new a2({ value: r4, inline: t5, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(e5), this.position++;
          }
          error(e5, t5) {
            throw new w2(e5 + ` at line: ${t5[2]}, column ${t5[3]}`);
          }
          loop() {
            for (; this.position < this.tokens.length; )
              this.parseTokens();
            return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
          }
          operator() {
            let e5, t5 = this.currToken[1];
            if (t5 === "+" || t5 === "-") {
              if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? (this.prevToken[0] !== "space" && this.prevToken[0] !== "(" || this.nextToken[0] !== "space" && this.nextToken[0] !== "word" || this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(") && this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "operator" && this.prevToken[0] !== "operator" || this.error("Syntax Error", this.currToken)), this.options.loose) {
                if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
                  return this.word();
              } else if (this.nextToken[0] === "word")
                return this.word();
            }
            return e5 = new f2({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(e5);
          }
          parseTokens() {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "colon":
                this.colon();
                break;
              case "comma":
                this.comma();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parenOpen();
                break;
              case ")":
                this.parenClose();
                break;
              case "atword":
              case "word":
                this.word();
                break;
              case "operator":
                this.operator();
                break;
              case "string":
                this.string();
                break;
              case "unicoderange":
                this.unicodeRange();
                break;
              default:
                this.word();
            }
          }
          parenOpen() {
            let e5, t5 = 1, r4 = this.position + 1, n3 = this.currToken;
            for (; r4 < this.tokens.length && t5; ) {
              let e6 = this.tokens[r4];
              e6[0] === "(" && t5++, e6[0] === ")" && t5--, r4++;
            }
            if (t5 && this.error("Expected closing parenthesis", n3), e5 = this.current.last, e5 && e5.type === "func" && e5.unbalanced < 0 && (e5.unbalanced = 0, this.current = e5), this.current.unbalanced++, this.newNode(new p2({ value: n3[1], source: { start: { line: n3[2], column: n3[3] }, end: { line: n3[4], column: n3[5] } }, sourceIndex: n3[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
              let e6 = this.nextToken, t6 = this.currToken[1], r5 = { line: this.currToken[2], column: this.currToken[3] };
              for (; e6 && e6[0] !== ")" && this.current.unbalanced; )
                this.position++, t6 += this.currToken[1], e6 = this.nextToken;
              this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d2({ value: t6, source: { start: r5, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
            }
          }
          parenClose() {
            let e5 = this.currToken;
            this.newNode(new p2({ value: e5[1], source: { start: { line: e5[2], column: e5[3] }, end: { line: e5[4], column: e5[5] } }, sourceIndex: e5[6] })), this.position++, this.position >= this.tokens.length - 1 && !this.current.unbalanced || (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e5), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
          }
          space() {
            let e5 = this.currToken;
            this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += e5[1], this.position++) : (this.spaces = e5[1], this.position++);
          }
          unicodeRange() {
            let e5 = this.currToken;
            this.newNode(new D2({ value: e5[1], source: { start: { line: e5[2], column: e5[3] }, end: { line: e5[4], column: e5[5] } }, sourceIndex: e5[6] })), this.position++;
          }
          splitWord() {
            let e5, t5, r4 = this.nextToken, n3 = this.currToken[1], o3 = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
            if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(n3))
              for (; r4 && r4[0] === "word"; ) {
                this.position++;
                let e6 = this.currToken[1];
                n3 += e6, r4 = this.nextToken;
              }
            var s3;
            e5 = v2(n3, "@"), s3 = y2(m2([[0], e5])), t5 = s3.sort((e6, t6) => e6 - t6), t5.forEach((s4, u3) => {
              let a3, f3 = t5[u3 + 1] || n3.length, p3 = n3.slice(s4, f3);
              if (~e5.indexOf(s4))
                a3 = new i2({ value: p3.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + s4 }, end: { line: this.currToken[4], column: this.currToken[3] + (f3 - 1) } }, sourceIndex: this.currToken[6] + t5[u3] });
              else if (o3.test(this.currToken[1])) {
                let e6 = p3.replace(o3, "");
                a3 = new l2({ value: p3.replace(e6, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + s4 }, end: { line: this.currToken[4], column: this.currToken[3] + (f3 - 1) } }, sourceIndex: this.currToken[6] + t5[u3], unit: e6 });
              } else
                a3 = new (r4 && r4[0] === "(" ? c2 : d2)({ value: p3, source: { start: { line: this.currToken[2], column: this.currToken[3] + s4 }, end: { line: this.currToken[4], column: this.currToken[3] + (f3 - 1) } }, sourceIndex: this.currToken[6] + t5[u3] }), a3.constructor.name === "Word" ? (a3.isHex = /^#(.+)/.test(p3), a3.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(p3)) : this.cache.push(this.current);
              this.newNode(a3);
            }), this.position++;
          }
          string() {
            let e5, t5 = this.currToken, r4 = this.currToken[1], n3 = /^(\"|\')/, o3 = n3.test(r4), i3 = "";
            o3 && (i3 = r4.match(n3)[0], r4 = r4.slice(1, r4.length - 1)), e5 = new h2({ value: r4, source: { start: { line: t5[2], column: t5[3] }, end: { line: t5[4], column: t5[5] } }, sourceIndex: t5[6], quoted: o3 }), e5.raws.quote = i3, this.newNode(e5), this.position++;
          }
          word() {
            return this.splitWord();
          }
          newNode(e5) {
            return this.spaces && (e5.raws.before += this.spaces, this.spaces = ""), this.current.append(e5);
          }
          get currToken() {
            return this.tokens[this.position];
          }
          get nextToken() {
            return this.tokens[this.position + 1];
          }
          get prevToken() {
            return this.tokens[this.position - 1];
          }
        };
      }, 4343: (e4, t4, r3) => {
        const n2 = r3(4196);
        e4.exports = class extends n2 {
          constructor(e5) {
            super(e5), this.type = "root";
          }
        };
      }, 9672: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "string";
          }
          toString() {
            let e5 = this.quoted ? this.raws.quote : "";
            return [this.raws.before, e5, this.value + "", e5, this.raws.after].join("");
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 2481: (e4, t4, r3) => {
        const n2 = "{".charCodeAt(0), o2 = "}".charCodeAt(0), i2 = "(".charCodeAt(0), s2 = ")".charCodeAt(0), u2 = "'".charCodeAt(0), a2 = '"'.charCodeAt(0), c2 = "\\".charCodeAt(0), l2 = "/".charCodeAt(0), f2 = ".".charCodeAt(0), p2 = ",".charCodeAt(0), h2 = ":".charCodeAt(0), d2 = "*".charCodeAt(0), D2 = "-".charCodeAt(0), g2 = "+".charCodeAt(0), m2 = "#".charCodeAt(0), v2 = "\n".charCodeAt(0), y2 = " ".charCodeAt(0), w2 = "\f".charCodeAt(0), b2 = "	".charCodeAt(0), C2 = "\r".charCodeAt(0), E2 = "@".charCodeAt(0), F2 = "e".charCodeAt(0), x2 = "E".charCodeAt(0), A2 = "0".charCodeAt(0), k2 = "9".charCodeAt(0), O2 = "u".charCodeAt(0), _2 = "U".charCodeAt(0), S2 = /[ \n\t\r\{\(\)'"\\;,/]/g, T2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, I2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, N2 = /^[a-z0-9]/i, M2 = /^[a-f0-9?\-]/i, R2 = r3(8472), j2 = r3(5128);
        e4.exports = function(e5, t5) {
          t5 = t5 || {};
          let r4, L2, B2, P2, $2, U2, G2, W2, z2, V2, q2, X2 = [], J2 = e5.valueOf(), H2 = J2.length, Y2 = -1, K2 = 1, Z2 = 0, Q2 = 0, ee2 = null;
          function te2(e6) {
            let t6 = R2.format("Unclosed %s at line: %d, column: %d, token: %d", e6, K2, Z2 - Y2, Z2);
            throw new j2(t6);
          }
          for (; Z2 < H2; ) {
            switch (r4 = J2.charCodeAt(Z2), r4 === v2 && (Y2 = Z2, K2 += 1), r4) {
              case v2:
              case y2:
              case b2:
              case C2:
              case w2:
                L2 = Z2;
                do {
                  L2 += 1, r4 = J2.charCodeAt(L2), r4 === v2 && (Y2 = L2, K2 += 1);
                } while (r4 === y2 || r4 === v2 || r4 === b2 || r4 === C2 || r4 === w2);
                X2.push(["space", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              case h2:
                L2 = Z2 + 1, X2.push(["colon", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              case p2:
                L2 = Z2 + 1, X2.push(["comma", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              case n2:
                X2.push(["{", "{", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case o2:
                X2.push(["}", "}", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case i2:
                Q2++, ee2 = !ee2 && Q2 === 1 && X2.length > 0 && X2[X2.length - 1][0] === "word" && X2[X2.length - 1][1] === "url", X2.push(["(", "(", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case s2:
                Q2--, ee2 = ee2 && Q2 > 0, X2.push([")", ")", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case u2:
              case a2:
                B2 = r4 === u2 ? "'" : '"', L2 = Z2;
                do {
                  for (z2 = false, L2 = J2.indexOf(B2, L2 + 1), L2 === -1 && te2("quote"), V2 = L2; J2.charCodeAt(V2 - 1) === c2; )
                    V2 -= 1, z2 = !z2;
                } while (z2);
                X2.push(["string", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                break;
              case E2:
                S2.lastIndex = Z2 + 1, S2.test(J2), L2 = S2.lastIndex === 0 ? J2.length - 1 : S2.lastIndex - 2, X2.push(["atword", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                break;
              case c2:
                L2 = Z2, r4 = J2.charCodeAt(L2 + 1), X2.push(["word", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                break;
              case g2:
              case D2:
              case d2:
                if (L2 = Z2 + 1, q2 = J2.slice(Z2 + 1, L2 + 1), J2.slice(Z2 - 1, Z2), r4 === D2 && q2.charCodeAt(0) === D2) {
                  L2++, X2.push(["word", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                  break;
                }
                X2.push(["operator", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              default:
                if (r4 === l2 && (J2.charCodeAt(Z2 + 1) === d2 || t5.loose && !ee2 && J2.charCodeAt(Z2 + 1) === l2)) {
                  if (J2.charCodeAt(Z2 + 1) === d2)
                    L2 = J2.indexOf("*/", Z2 + 2) + 1, L2 === 0 && te2("comment");
                  else {
                    const e6 = J2.indexOf("\n", Z2 + 2);
                    L2 = e6 !== -1 ? e6 - 1 : H2;
                  }
                  U2 = J2.slice(Z2, L2 + 1), P2 = U2.split("\n"), $2 = P2.length - 1, $2 > 0 ? (G2 = K2 + $2, W2 = L2 - P2[$2].length) : (G2 = K2, W2 = Y2), X2.push(["comment", U2, K2, Z2 - Y2, G2, L2 - W2, Z2]), Y2 = W2, K2 = G2, Z2 = L2;
                } else if (r4 !== m2 || N2.test(J2.slice(Z2 + 1, Z2 + 2)))
                  if (r4 !== O2 && r4 !== _2 || J2.charCodeAt(Z2 + 1) !== g2)
                    if (r4 === l2)
                      L2 = Z2 + 1, X2.push(["operator", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                    else {
                      let e6 = T2;
                      if (r4 >= A2 && r4 <= k2 && (e6 = I2), e6.lastIndex = Z2 + 1, e6.test(J2), L2 = e6.lastIndex === 0 ? J2.length - 1 : e6.lastIndex - 2, e6 === I2 || r4 === f2) {
                        let e7 = J2.charCodeAt(L2), t6 = J2.charCodeAt(L2 + 1), r5 = J2.charCodeAt(L2 + 2);
                        (e7 === F2 || e7 === x2) && (t6 === D2 || t6 === g2) && r5 >= A2 && r5 <= k2 && (I2.lastIndex = L2 + 2, I2.test(J2), L2 = I2.lastIndex === 0 ? J2.length - 1 : I2.lastIndex - 2);
                      }
                      X2.push(["word", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                    }
                  else {
                    L2 = Z2 + 2;
                    do {
                      L2 += 1, r4 = J2.charCodeAt(L2);
                    } while (L2 < H2 && M2.test(J2.slice(L2, L2 + 1)));
                    X2.push(["unicoderange", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                  }
                else
                  L2 = Z2 + 1, X2.push(["#", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
            }
            Z2++;
          }
          return X2;
        };
      }, 1369: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "unicode-range";
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 2057: (e4, t4, r3) => {
        const n2 = r3(4196);
        e4.exports = class extends n2 {
          constructor(e5) {
            super(e5), this.type = "value", this.unbalanced = 0;
          }
        };
      }, 6593: (e4, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e5) {
            super(e5), this.type = "word";
          }
        }
        n2.registerWalker(i2), e4.exports = i2;
      }, 8940: (e4, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e5) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e5.call(this, t6) || this).type = "atrule", r5;
          }
          r4 = e5, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var o3 = n3.prototype;
          return o3.append = function() {
            var t6;
            this.nodes || (this.nodes = []);
            for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
              n4[o4] = arguments[o4];
            return (t6 = e5.prototype.append).call.apply(t6, [this].concat(n4));
          }, o3.prepend = function() {
            var t6;
            this.nodes || (this.nodes = []);
            for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
              n4[o4] = arguments[o4];
            return (t6 = e5.prototype.prepend).call.apply(t6, [this].concat(n4));
          }, n3;
        }(((n2 = r3(1204)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = o2, e4.exports = t4.default;
      }, 3102: (e4, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e5) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e5.call(this, t6) || this).type = "comment", r5;
          }
          return r4 = e5, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(((n2 = r3(1714)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = o2, e4.exports = t4.default;
      }, 1204: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(6417)), o2 = i2(r3(3102));
        function i2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function s2(e5, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
            if (Array.isArray(e5) || (r4 = function(e6, t6) {
              if (e6) {
                if (typeof e6 == "string")
                  return u2(e6, t6);
                var r5 = Object.prototype.toString.call(e6).slice(8, -1);
                return r5 === "Object" && e6.constructor && (r5 = e6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e6, t6) : void 0;
              }
            }(e5)) || t5 && e5 && typeof e5.length == "number") {
              r4 && (e5 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e5.length ? { done: true } : { done: false, value: e5[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e5[Symbol.iterator]()).next.bind(r4);
        }
        function u2(e5, t5) {
          (t5 == null || t5 > e5.length) && (t5 = e5.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e5[r4];
          return n3;
        }
        function a2(e5, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e5, n3.key, n3);
          }
        }
        function c2(e5) {
          return e5.map(function(e6) {
            return e6.nodes && (e6.nodes = c2(e6.nodes)), delete e6.source, e6;
          });
        }
        var l2 = function(e5) {
          var t5, i3;
          function u3() {
            return e5.apply(this, arguments) || this;
          }
          i3 = e5, (t5 = u3).prototype = Object.create(i3.prototype), t5.prototype.constructor = t5, t5.__proto__ = i3;
          var l3, f2 = u3.prototype;
          return f2.push = function(e6) {
            return e6.parent = this, this.nodes.push(e6), this;
          }, f2.each = function(e6) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            var t6 = this.lastEach;
            if (this.indexes[t6] = 0, this.nodes) {
              for (var r4, n3; this.indexes[t6] < this.nodes.length && (r4 = this.indexes[t6], (n3 = e6(this.nodes[r4], r4)) !== false); )
                this.indexes[t6] += 1;
              return delete this.indexes[t6], n3;
            }
          }, f2.walk = function(e6) {
            return this.each(function(t6, r4) {
              var n3;
              try {
                n3 = e6(t6, r4);
              } catch (e7) {
                if (e7.postcssNode = t6, e7.stack && t6.source && /\n\s{4}at /.test(e7.stack)) {
                  var o3 = t6.source;
                  e7.stack = e7.stack.replace(/\n\s{4}at /, "$&" + o3.input.from + ":" + o3.start.line + ":" + o3.start.column + "$&");
                }
                throw e7;
              }
              return n3 !== false && t6.walk && (n3 = t6.walk(e6)), n3;
            });
          }, f2.walkDecls = function(e6, t6) {
            return t6 ? e6 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "decl" && e6.test(r4.prop))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "decl" && r4.prop === e6)
                return t6(r4, n3);
            }) : (t6 = e6, this.walk(function(e7, r4) {
              if (e7.type === "decl")
                return t6(e7, r4);
            }));
          }, f2.walkRules = function(e6, t6) {
            return t6 ? e6 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "rule" && e6.test(r4.selector))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "rule" && r4.selector === e6)
                return t6(r4, n3);
            }) : (t6 = e6, this.walk(function(e7, r4) {
              if (e7.type === "rule")
                return t6(e7, r4);
            }));
          }, f2.walkAtRules = function(e6, t6) {
            return t6 ? e6 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "atrule" && e6.test(r4.name))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "atrule" && r4.name === e6)
                return t6(r4, n3);
            }) : (t6 = e6, this.walk(function(e7, r4) {
              if (e7.type === "atrule")
                return t6(e7, r4);
            }));
          }, f2.walkComments = function(e6) {
            return this.walk(function(t6, r4) {
              if (t6.type === "comment")
                return e6(t6, r4);
            });
          }, f2.append = function() {
            for (var e6 = arguments.length, t6 = new Array(e6), r4 = 0; r4 < e6; r4++)
              t6[r4] = arguments[r4];
            for (var n3 = 0, o3 = t6; n3 < o3.length; n3++)
              for (var i4, u4 = o3[n3], a3 = s2(this.normalize(u4, this.last)); !(i4 = a3()).done; ) {
                var c3 = i4.value;
                this.nodes.push(c3);
              }
            return this;
          }, f2.prepend = function() {
            for (var e6 = arguments.length, t6 = new Array(e6), r4 = 0; r4 < e6; r4++)
              t6[r4] = arguments[r4];
            for (var n3, o3 = s2(t6 = t6.reverse()); !(n3 = o3()).done; ) {
              for (var i4, u4 = n3.value, a3 = this.normalize(u4, this.first, "prepend").reverse(), c3 = s2(a3); !(i4 = c3()).done; ) {
                var l4 = i4.value;
                this.nodes.unshift(l4);
              }
              for (var f3 in this.indexes)
                this.indexes[f3] = this.indexes[f3] + a3.length;
            }
            return this;
          }, f2.cleanRaws = function(t6) {
            if (e5.prototype.cleanRaws.call(this, t6), this.nodes)
              for (var r4, n3 = s2(this.nodes); !(r4 = n3()).done; )
                r4.value.cleanRaws(t6);
          }, f2.insertBefore = function(e6, t6) {
            for (var r4, n3, o3 = (e6 = this.index(e6)) === 0 && "prepend", i4 = this.normalize(t6, this.nodes[e6], o3).reverse(), u4 = s2(i4); !(r4 = u4()).done; ) {
              var a3 = r4.value;
              this.nodes.splice(e6, 0, a3);
            }
            for (var c3 in this.indexes)
              e6 <= (n3 = this.indexes[c3]) && (this.indexes[c3] = n3 + i4.length);
            return this;
          }, f2.insertAfter = function(e6, t6) {
            e6 = this.index(e6);
            for (var r4, n3, o3 = this.normalize(t6, this.nodes[e6]).reverse(), i4 = s2(o3); !(r4 = i4()).done; ) {
              var u4 = r4.value;
              this.nodes.splice(e6 + 1, 0, u4);
            }
            for (var a3 in this.indexes)
              e6 < (n3 = this.indexes[a3]) && (this.indexes[a3] = n3 + o3.length);
            return this;
          }, f2.removeChild = function(e6) {
            var t6;
            for (var r4 in e6 = this.index(e6), this.nodes[e6].parent = void 0, this.nodes.splice(e6, 1), this.indexes)
              (t6 = this.indexes[r4]) >= e6 && (this.indexes[r4] = t6 - 1);
            return this;
          }, f2.removeAll = function() {
            for (var e6, t6 = s2(this.nodes); !(e6 = t6()).done; )
              e6.value.parent = void 0;
            return this.nodes = [], this;
          }, f2.replaceValues = function(e6, t6, r4) {
            return r4 || (r4 = t6, t6 = {}), this.walkDecls(function(n3) {
              t6.props && t6.props.indexOf(n3.prop) === -1 || t6.fast && n3.value.indexOf(t6.fast) === -1 || (n3.value = n3.value.replace(e6, r4));
            }), this;
          }, f2.every = function(e6) {
            return this.nodes.every(e6);
          }, f2.some = function(e6) {
            return this.nodes.some(e6);
          }, f2.index = function(e6) {
            return typeof e6 == "number" ? e6 : this.nodes.indexOf(e6);
          }, f2.normalize = function(e6, t6) {
            var i4 = this;
            if (typeof e6 == "string")
              e6 = c2(r3(7057)(e6).nodes);
            else if (Array.isArray(e6))
              for (var u4, a3 = s2(e6 = e6.slice(0)); !(u4 = a3()).done; ) {
                var l4 = u4.value;
                l4.parent && l4.parent.removeChild(l4, "ignore");
              }
            else if (e6.type === "root")
              for (var f3, p2 = s2(e6 = e6.nodes.slice(0)); !(f3 = p2()).done; ) {
                var h2 = f3.value;
                h2.parent && h2.parent.removeChild(h2, "ignore");
              }
            else if (e6.type)
              e6 = [e6];
            else if (e6.prop) {
              if (e6.value === void 0)
                throw new Error("Value field is missed in node creation");
              typeof e6.value != "string" && (e6.value = String(e6.value)), e6 = [new n2.default(e6)];
            } else if (e6.selector)
              e6 = [new (r3(6621))(e6)];
            else if (e6.name)
              e6 = [new (r3(8940))(e6)];
            else {
              if (!e6.text)
                throw new Error("Unknown node type in node creation");
              e6 = [new o2.default(e6)];
            }
            return e6.map(function(e7) {
              return e7.parent && e7.parent.removeChild(e7), e7.raws.before === void 0 && t6 && t6.raws.before !== void 0 && (e7.raws.before = t6.raws.before.replace(/[^\s]/g, "")), e7.parent = i4, e7;
            });
          }, (l3 = [{ key: "first", get: function() {
            if (this.nodes)
              return this.nodes[0];
          } }, { key: "last", get: function() {
            if (this.nodes)
              return this.nodes[this.nodes.length - 1];
          } }]) && a2(u3.prototype, l3), u3;
        }(i2(r3(1714)).default);
        t4.default = l2, e4.exports = t4.default;
      }, 1667: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(6083)), o2 = s2(r3(3248)), i2 = s2(r3(2868));
        function s2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function u2(e5) {
          var t5 = typeof Map == "function" ? new Map() : void 0;
          return (u2 = function(e6) {
            if (e6 === null || (r4 = e6, Function.toString.call(r4).indexOf("[native code]") === -1))
              return e6;
            var r4;
            if (typeof e6 != "function")
              throw new TypeError("Super expression must either be null or a function");
            if (t5 !== void 0) {
              if (t5.has(e6))
                return t5.get(e6);
              t5.set(e6, n3);
            }
            function n3() {
              return a2(e6, arguments, f2(this).constructor);
            }
            return n3.prototype = Object.create(e6.prototype, { constructor: { value: n3, enumerable: false, writable: true, configurable: true } }), l2(n3, e6);
          })(e5);
        }
        function a2(e5, t5, r4) {
          return (a2 = c2() ? Reflect.construct : function(e6, t6, r5) {
            var n3 = [null];
            n3.push.apply(n3, t6);
            var o3 = new (Function.bind.apply(e6, n3))();
            return r5 && l2(o3, r5.prototype), o3;
          }).apply(null, arguments);
        }
        function c2() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (e5) {
            return false;
          }
        }
        function l2(e5, t5) {
          return (l2 = Object.setPrototypeOf || function(e6, t6) {
            return e6.__proto__ = t6, e6;
          })(e5, t5);
        }
        function f2(e5) {
          return (f2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e6) {
            return e6.__proto__ || Object.getPrototypeOf(e6);
          })(e5);
        }
        var p2 = function(e5) {
          var t5, r4;
          function s3(t6, r5, n3, o3, i3, u4) {
            var a3;
            return (a3 = e5.call(this, t6) || this).name = "CssSyntaxError", a3.reason = t6, i3 && (a3.file = i3), o3 && (a3.source = o3), u4 && (a3.plugin = u4), r5 !== void 0 && n3 !== void 0 && (a3.line = r5, a3.column = n3), a3.setMessage(), Error.captureStackTrace && Error.captureStackTrace(function(e6) {
              if (e6 === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e6;
            }(a3), s3), a3;
          }
          r4 = e5, (t5 = s3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var u3 = s3.prototype;
          return u3.setMessage = function() {
            this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", this.line !== void 0 && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
          }, u3.showSourceCode = function(e6) {
            var t6 = this;
            if (!this.source)
              return "";
            var r5 = this.source;
            i2.default && (e6 === void 0 && (e6 = n2.default.stdout), e6 && (r5 = (0, i2.default)(r5)));
            var s4 = r5.split(/\r?\n/), u4 = Math.max(this.line - 3, 0), a3 = Math.min(this.line + 2, s4.length), c3 = String(a3).length;
            function l3(t7) {
              return e6 && o2.default.red ? o2.default.red.bold(t7) : t7;
            }
            function f3(t7) {
              return e6 && o2.default.gray ? o2.default.gray(t7) : t7;
            }
            return s4.slice(u4, a3).map(function(e7, r6) {
              var n3 = u4 + 1 + r6, o3 = " " + (" " + n3).slice(-c3) + " | ";
              if (n3 === t6.line) {
                var i3 = f3(o3.replace(/\d/g, " ")) + e7.slice(0, t6.column - 1).replace(/[^\t]/g, " ");
                return l3(">") + f3(o3) + e7 + "\n " + i3 + l3("^");
              }
              return " " + f3(o3) + e7;
            }).join("\n");
          }, u3.toString = function() {
            var e6 = this.showSourceCode();
            return e6 && (e6 = "\n\n" + e6 + "\n"), this.name + ": " + this.message + e6;
          }, s3;
        }(u2(Error));
        t4.default = p2, e4.exports = t4.default;
      }, 6417: (e4, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e5) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e5.call(this, t6) || this).type = "decl", r5;
          }
          return r4 = e5, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(((n2 = r3(1714)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = o2, e4.exports = t4.default;
      }, 2993: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(3974)), o2 = s2(r3(1667)), i2 = s2(r3(3353));
        function s2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function u2(e5, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e5, n3.key, n3);
          }
        }
        var a2 = 0, c2 = function() {
          function e5(e6, t6) {
            if (t6 === void 0 && (t6 = {}), e6 == null || typeof e6 == "object" && !e6.toString)
              throw new Error("PostCSS received " + e6 + " instead of CSS string");
            this.css = e6.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, t6.from && (/^\w+:\/\//.test(t6.from) || n2.default.isAbsolute(t6.from) ? this.file = t6.from : this.file = n2.default.resolve(t6.from));
            var r5 = new i2.default(this.css, t6);
            if (r5.text) {
              this.map = r5;
              var o3 = r5.consumer().file;
              !this.file && o3 && (this.file = this.mapResolve(o3));
            }
            this.file || (a2 += 1, this.id = "<input css " + a2 + ">"), this.map && (this.map.file = this.from);
          }
          var t5, r4 = e5.prototype;
          return r4.error = function(e6, t6, r5, n3) {
            var i3;
            n3 === void 0 && (n3 = {});
            var s3 = this.origin(t6, r5);
            return (i3 = s3 ? new o2.default(e6, s3.line, s3.column, s3.source, s3.file, n3.plugin) : new o2.default(e6, t6, r5, this.css, this.file, n3.plugin)).input = { line: t6, column: r5, source: this.css }, this.file && (i3.input.file = this.file), i3;
          }, r4.origin = function(e6, t6) {
            if (!this.map)
              return false;
            var r5 = this.map.consumer(), n3 = r5.originalPositionFor({ line: e6, column: t6 });
            if (!n3.source)
              return false;
            var o3 = { file: this.mapResolve(n3.source), line: n3.line, column: n3.column }, i3 = r5.sourceContentFor(n3.source);
            return i3 && (o3.source = i3), o3;
          }, r4.mapResolve = function(e6) {
            return /^\w+:\/\//.test(e6) ? e6 : n2.default.resolve(this.map.consumer().sourceRoot || ".", e6);
          }, (t5 = [{ key: "from", get: function() {
            return this.file || this.id;
          } }]) && u2(e5.prototype, t5), e5;
        }();
        t4.default = c2, e4.exports = t4.default;
      }, 6992: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = u2(r3(8991)), o2 = u2(r3(6157)), i2 = (u2(r3(6574)), u2(r3(6865))), s2 = u2(r3(7057));
        function u2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function a2(e5, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
            if (Array.isArray(e5) || (r4 = function(e6, t6) {
              if (e6) {
                if (typeof e6 == "string")
                  return c2(e6, t6);
                var r5 = Object.prototype.toString.call(e6).slice(8, -1);
                return r5 === "Object" && e6.constructor && (r5 = e6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? c2(e6, t6) : void 0;
              }
            }(e5)) || t5 && e5 && typeof e5.length == "number") {
              r4 && (e5 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e5.length ? { done: true } : { done: false, value: e5[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e5[Symbol.iterator]()).next.bind(r4);
        }
        function c2(e5, t5) {
          (t5 == null || t5 > e5.length) && (t5 = e5.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e5[r4];
          return n3;
        }
        function l2(e5, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e5, n3.key, n3);
          }
        }
        function f2(e5) {
          return typeof e5 == "object" && typeof e5.then == "function";
        }
        var p2 = function() {
          function e5(t6, r5, n3) {
            var o3;
            if (this.stringified = false, this.processed = false, typeof r5 == "object" && r5 !== null && r5.type === "root")
              o3 = r5;
            else if (r5 instanceof e5 || r5 instanceof i2.default)
              o3 = r5.root, r5.map && (n3.map === void 0 && (n3.map = {}), n3.map.inline || (n3.map.inline = false), n3.map.prev = r5.map);
            else {
              var u3 = s2.default;
              n3.syntax && (u3 = n3.syntax.parse), n3.parser && (u3 = n3.parser), u3.parse && (u3 = u3.parse);
              try {
                o3 = u3(r5, n3);
              } catch (t7) {
                this.error = t7;
              }
            }
            this.result = new i2.default(t6, o3, n3);
          }
          var t5, r4 = e5.prototype;
          return r4.warnings = function() {
            return this.sync().warnings();
          }, r4.toString = function() {
            return this.css;
          }, r4.then = function(e6, t6) {
            return this.async().then(e6, t6);
          }, r4.catch = function(e6) {
            return this.async().catch(e6);
          }, r4.finally = function(e6) {
            return this.async().then(e6, e6);
          }, r4.handleError = function(e6, t6) {
            try {
              this.error = e6, e6.name !== "CssSyntaxError" || e6.plugin ? t6.postcssVersion : (e6.plugin = t6.postcssPlugin, e6.setMessage());
            } catch (e7) {
              console && console.error && console.error(e7);
            }
          }, r4.asyncTick = function(e6, t6) {
            var r5 = this;
            if (this.plugin >= this.processor.plugins.length)
              return this.processed = true, e6();
            try {
              var n3 = this.processor.plugins[this.plugin], o3 = this.run(n3);
              this.plugin += 1, f2(o3) ? o3.then(function() {
                r5.asyncTick(e6, t6);
              }).catch(function(e7) {
                r5.handleError(e7, n3), r5.processed = true, t6(e7);
              }) : this.asyncTick(e6, t6);
            } catch (e7) {
              this.processed = true, t6(e7);
            }
          }, r4.async = function() {
            var e6 = this;
            return this.processed ? new Promise(function(t6, r5) {
              e6.error ? r5(e6.error) : t6(e6.stringify());
            }) : (this.processing || (this.processing = new Promise(function(t6, r5) {
              if (e6.error)
                return r5(e6.error);
              e6.plugin = 0, e6.asyncTick(t6, r5);
            }).then(function() {
              return e6.processed = true, e6.stringify();
            })), this.processing);
          }, r4.sync = function() {
            if (this.processed)
              return this.result;
            if (this.processed = true, this.processing)
              throw new Error("Use process(css).then(cb) to work with async plugins");
            if (this.error)
              throw this.error;
            for (var e6, t6 = a2(this.result.processor.plugins); !(e6 = t6()).done; ) {
              var r5 = e6.value;
              if (f2(this.run(r5)))
                throw new Error("Use process(css).then(cb) to work with async plugins");
            }
            return this.result;
          }, r4.run = function(e6) {
            this.result.lastPlugin = e6;
            try {
              return e6(this.result.root, this.result);
            } catch (t6) {
              throw this.handleError(t6, e6), t6;
            }
          }, r4.stringify = function() {
            if (this.stringified)
              return this.result;
            this.stringified = true, this.sync();
            var e6 = this.result.opts, t6 = o2.default;
            e6.syntax && (t6 = e6.syntax.stringify), e6.stringifier && (t6 = e6.stringifier), t6.stringify && (t6 = t6.stringify);
            var r5 = new n2.default(t6, this.result.root, this.result.opts).generate();
            return this.result.css = r5[0], this.result.map = r5[1], this.result;
          }, (t5 = [{ key: "processor", get: function() {
            return this.result.processor;
          } }, { key: "opts", get: function() {
            return this.result.opts;
          } }, { key: "css", get: function() {
            return this.stringify().css;
          } }, { key: "content", get: function() {
            return this.stringify().content;
          } }, { key: "map", get: function() {
            return this.stringify().map;
          } }, { key: "root", get: function() {
            return this.sync().root;
          } }, { key: "messages", get: function() {
            return this.sync().messages;
          } }]) && l2(e5.prototype, t5), e5;
        }();
        t4.default = p2, e4.exports = t4.default;
      }, 6136: (e4, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = { split: function(e5, t5, r4) {
          for (var n3 = [], o2 = "", i2 = false, s2 = 0, u2 = false, a2 = false, c2 = 0; c2 < e5.length; c2++) {
            var l2 = e5[c2];
            u2 ? a2 ? a2 = false : l2 === "\\" ? a2 = true : l2 === u2 && (u2 = false) : l2 === '"' || l2 === "'" ? u2 = l2 : l2 === "(" ? s2 += 1 : l2 === ")" ? s2 > 0 && (s2 -= 1) : s2 === 0 && t5.indexOf(l2) !== -1 && (i2 = true), i2 ? (o2 !== "" && n3.push(o2.trim()), o2 = "", i2 = false) : o2 += l2;
          }
          return (r4 || o2 !== "") && n3.push(o2.trim()), n3;
        }, space: function(e5) {
          return r3.split(e5, [" ", "\n", "	"]);
        }, comma: function(e5) {
          return r3.split(e5, [","], true);
        } }, n2 = r3;
        t4.default = n2, e4.exports = t4.default;
      }, 8991: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(2447)), o2 = i2(r3(3974));
        function i2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function s2(e5, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
            if (Array.isArray(e5) || (r4 = function(e6, t6) {
              if (e6) {
                if (typeof e6 == "string")
                  return u2(e6, t6);
                var r5 = Object.prototype.toString.call(e6).slice(8, -1);
                return r5 === "Object" && e6.constructor && (r5 = e6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e6, t6) : void 0;
              }
            }(e5)) || t5 && e5 && typeof e5.length == "number") {
              r4 && (e5 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e5.length ? { done: true } : { done: false, value: e5[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e5[Symbol.iterator]()).next.bind(r4);
        }
        function u2(e5, t5) {
          (t5 == null || t5 > e5.length) && (t5 = e5.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e5[r4];
          return n3;
        }
        var a2 = function() {
          function e5(e6, t6, r4) {
            this.stringify = e6, this.mapOpts = r4.map || {}, this.root = t6, this.opts = r4;
          }
          var t5 = e5.prototype;
          return t5.isMap = function() {
            return this.opts.map !== void 0 ? !!this.opts.map : this.previous().length > 0;
          }, t5.previous = function() {
            var e6 = this;
            return this.previousMaps || (this.previousMaps = [], this.root.walk(function(t6) {
              if (t6.source && t6.source.input.map) {
                var r4 = t6.source.input.map;
                e6.previousMaps.indexOf(r4) === -1 && e6.previousMaps.push(r4);
              }
            })), this.previousMaps;
          }, t5.isInline = function() {
            if (this.mapOpts.inline !== void 0)
              return this.mapOpts.inline;
            var e6 = this.mapOpts.annotation;
            return (e6 === void 0 || e6 === true) && (!this.previous().length || this.previous().some(function(e7) {
              return e7.inline;
            }));
          }, t5.isSourcesContent = function() {
            return this.mapOpts.sourcesContent !== void 0 ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some(function(e6) {
              return e6.withContent();
            });
          }, t5.clearAnnotation = function() {
            if (this.mapOpts.annotation !== false)
              for (var e6, t6 = this.root.nodes.length - 1; t6 >= 0; t6--)
                (e6 = this.root.nodes[t6]).type === "comment" && e6.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t6);
          }, t5.setSourcesContent = function() {
            var e6 = this, t6 = {};
            this.root.walk(function(r4) {
              if (r4.source) {
                var n3 = r4.source.input.from;
                if (n3 && !t6[n3]) {
                  t6[n3] = true;
                  var o3 = e6.relative(n3);
                  e6.map.setSourceContent(o3, r4.source.input.css);
                }
              }
            });
          }, t5.applyPrevMaps = function() {
            for (var e6, t6 = s2(this.previous()); !(e6 = t6()).done; ) {
              var r4 = e6.value, i3 = this.relative(r4.file), u3 = r4.root || o2.default.dirname(r4.file), a3 = void 0;
              this.mapOpts.sourcesContent === false ? (a3 = new n2.default.SourceMapConsumer(r4.text)).sourcesContent && (a3.sourcesContent = a3.sourcesContent.map(function() {
                return null;
              })) : a3 = r4.consumer(), this.map.applySourceMap(a3, i3, this.relative(u3));
            }
          }, t5.isAnnotation = function() {
            return !!this.isInline() || (this.mapOpts.annotation !== void 0 ? this.mapOpts.annotation : !this.previous().length || this.previous().some(function(e6) {
              return e6.annotation;
            }));
          }, t5.toBase64 = function(e6) {
            return Buffer ? Buffer.from(e6).toString("base64") : window.btoa(unescape(encodeURIComponent(e6)));
          }, t5.addAnnotation = function() {
            var e6;
            e6 = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? this.mapOpts.annotation : this.outputFile() + ".map";
            var t6 = "\n";
            this.css.indexOf("\r\n") !== -1 && (t6 = "\r\n"), this.css += t6 + "/*# sourceMappingURL=" + e6 + " */";
          }, t5.outputFile = function() {
            return this.opts.to ? this.relative(this.opts.to) : this.opts.from ? this.relative(this.opts.from) : "to.css";
          }, t5.generateMap = function() {
            return this.generateString(), this.isSourcesContent() && this.setSourcesContent(), this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
          }, t5.relative = function(e6) {
            if (e6.indexOf("<") === 0)
              return e6;
            if (/^\w+:\/\//.test(e6))
              return e6;
            var t6 = this.opts.to ? o2.default.dirname(this.opts.to) : ".";
            return typeof this.mapOpts.annotation == "string" && (t6 = o2.default.dirname(o2.default.resolve(t6, this.mapOpts.annotation))), e6 = o2.default.relative(t6, e6), o2.default.sep === "\\" ? e6.replace(/\\/g, "/") : e6;
          }, t5.sourcePath = function(e6) {
            return this.mapOpts.from ? this.mapOpts.from : this.relative(e6.source.input.from);
          }, t5.generateString = function() {
            var e6 = this;
            this.css = "", this.map = new n2.default.SourceMapGenerator({ file: this.outputFile() });
            var t6, r4, o3 = 1, i3 = 1;
            this.stringify(this.root, function(n3, s3, u3) {
              if (e6.css += n3, s3 && u3 !== "end" && (s3.source && s3.source.start ? e6.map.addMapping({ source: e6.sourcePath(s3), generated: { line: o3, column: i3 - 1 }, original: { line: s3.source.start.line, column: s3.source.start.column - 1 } }) : e6.map.addMapping({ source: "<no source>", original: { line: 1, column: 0 }, generated: { line: o3, column: i3 - 1 } })), (t6 = n3.match(/\n/g)) ? (o3 += t6.length, r4 = n3.lastIndexOf("\n"), i3 = n3.length - r4) : i3 += n3.length, s3 && u3 !== "start") {
                var a3 = s3.parent || { raws: {} };
                (s3.type !== "decl" || s3 !== a3.last || a3.raws.semicolon) && (s3.source && s3.source.end ? e6.map.addMapping({ source: e6.sourcePath(s3), generated: { line: o3, column: i3 - 2 }, original: { line: s3.source.end.line, column: s3.source.end.column - 1 } }) : e6.map.addMapping({ source: "<no source>", original: { line: 1, column: 0 }, generated: { line: o3, column: i3 - 1 } }));
              }
            });
          }, t5.generate = function() {
            if (this.clearAnnotation(), this.isMap())
              return this.generateMap();
            var e6 = "";
            return this.stringify(this.root, function(t6) {
              e6 += t6;
            }), [e6];
          }, e5;
        }();
        t4.default = a2, e4.exports = t4.default;
      }, 1714: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(1667)), o2 = s2(r3(5701)), i2 = s2(r3(6157));
        function s2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function u2(e5, t5) {
          var r4 = new e5.constructor();
          for (var n3 in e5)
            if (e5.hasOwnProperty(n3)) {
              var o3 = e5[n3], i3 = typeof o3;
              n3 === "parent" && i3 === "object" ? t5 && (r4[n3] = t5) : n3 === "source" ? r4[n3] = o3 : o3 instanceof Array ? r4[n3] = o3.map(function(e6) {
                return u2(e6, r4);
              }) : (i3 === "object" && o3 !== null && (o3 = u2(o3)), r4[n3] = o3);
            }
          return r4;
        }
        var a2 = function() {
          function e5(e6) {
            for (var t6 in e6 === void 0 && (e6 = {}), this.raws = {}, e6)
              this[t6] = e6[t6];
          }
          var t5 = e5.prototype;
          return t5.error = function(e6, t6) {
            if (t6 === void 0 && (t6 = {}), this.source) {
              var r4 = this.positionBy(t6);
              return this.source.input.error(e6, r4.line, r4.column, t6);
            }
            return new n2.default(e6);
          }, t5.warn = function(e6, t6, r4) {
            var n3 = { node: this };
            for (var o3 in r4)
              n3[o3] = r4[o3];
            return e6.warn(t6, n3);
          }, t5.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }, t5.toString = function(e6) {
            e6 === void 0 && (e6 = i2.default), e6.stringify && (e6 = e6.stringify);
            var t6 = "";
            return e6(this, function(e7) {
              t6 += e7;
            }), t6;
          }, t5.clone = function(e6) {
            e6 === void 0 && (e6 = {});
            var t6 = u2(this);
            for (var r4 in e6)
              t6[r4] = e6[r4];
            return t6;
          }, t5.cloneBefore = function(e6) {
            e6 === void 0 && (e6 = {});
            var t6 = this.clone(e6);
            return this.parent.insertBefore(this, t6), t6;
          }, t5.cloneAfter = function(e6) {
            e6 === void 0 && (e6 = {});
            var t6 = this.clone(e6);
            return this.parent.insertAfter(this, t6), t6;
          }, t5.replaceWith = function() {
            if (this.parent) {
              for (var e6 = arguments.length, t6 = new Array(e6), r4 = 0; r4 < e6; r4++)
                t6[r4] = arguments[r4];
              for (var n3 = 0, o3 = t6; n3 < o3.length; n3++) {
                var i3 = o3[n3];
                this.parent.insertBefore(this, i3);
              }
              this.remove();
            }
            return this;
          }, t5.next = function() {
            if (this.parent) {
              var e6 = this.parent.index(this);
              return this.parent.nodes[e6 + 1];
            }
          }, t5.prev = function() {
            if (this.parent) {
              var e6 = this.parent.index(this);
              return this.parent.nodes[e6 - 1];
            }
          }, t5.before = function(e6) {
            return this.parent.insertBefore(this, e6), this;
          }, t5.after = function(e6) {
            return this.parent.insertAfter(this, e6), this;
          }, t5.toJSON = function() {
            var e6 = {};
            for (var t6 in this)
              if (this.hasOwnProperty(t6) && t6 !== "parent") {
                var r4 = this[t6];
                r4 instanceof Array ? e6[t6] = r4.map(function(e7) {
                  return typeof e7 == "object" && e7.toJSON ? e7.toJSON() : e7;
                }) : typeof r4 == "object" && r4.toJSON ? e6[t6] = r4.toJSON() : e6[t6] = r4;
              }
            return e6;
          }, t5.raw = function(e6, t6) {
            return new o2.default().raw(this, e6, t6);
          }, t5.root = function() {
            for (var e6 = this; e6.parent; )
              e6 = e6.parent;
            return e6;
          }, t5.cleanRaws = function(e6) {
            delete this.raws.before, delete this.raws.after, e6 || delete this.raws.between;
          }, t5.positionInside = function(e6) {
            for (var t6 = this.toString(), r4 = this.source.start.column, n3 = this.source.start.line, o3 = 0; o3 < e6; o3++)
              t6[o3] === "\n" ? (r4 = 1, n3 += 1) : r4 += 1;
            return { line: n3, column: r4 };
          }, t5.positionBy = function(e6) {
            var t6 = this.source.start;
            if (e6.index)
              t6 = this.positionInside(e6.index);
            else if (e6.word) {
              var r4 = this.toString().indexOf(e6.word);
              r4 !== -1 && (t6 = this.positionInside(r4));
            }
            return t6;
          }, e5;
        }();
        t4.default = a2, e4.exports = t4.default;
      }, 7057: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(7116)), o2 = i2(r3(2993));
        function i2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        var s2 = function(e5, t5) {
          var r4 = new o2.default(e5, t5), i3 = new n2.default(r4);
          try {
            i3.parse();
          } catch (e6) {
            throw e6;
          }
          return i3.root;
        };
        t4.default = s2, e4.exports = t4.default;
      }, 7116: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = c2(r3(6417)), o2 = c2(r3(1157)), i2 = c2(r3(3102)), s2 = c2(r3(8940)), u2 = c2(r3(7563)), a2 = c2(r3(6621));
        function c2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        var l2 = function() {
          function e5(e6) {
            this.input = e6, this.root = new u2.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: e6, start: { line: 1, column: 1 } };
          }
          var t5 = e5.prototype;
          return t5.createTokenizer = function() {
            this.tokenizer = (0, o2.default)(this.input);
          }, t5.parse = function() {
            for (var e6; !this.tokenizer.endOfFile(); )
              switch ((e6 = this.tokenizer.nextToken())[0]) {
                case "space":
                  this.spaces += e6[1];
                  break;
                case ";":
                  this.freeSemicolon(e6);
                  break;
                case "}":
                  this.end(e6);
                  break;
                case "comment":
                  this.comment(e6);
                  break;
                case "at-word":
                  this.atrule(e6);
                  break;
                case "{":
                  this.emptyRule(e6);
                  break;
                default:
                  this.other(e6);
              }
            this.endFile();
          }, t5.comment = function(e6) {
            var t6 = new i2.default();
            this.init(t6, e6[2], e6[3]), t6.source.end = { line: e6[4], column: e6[5] };
            var r4 = e6[1].slice(2, -2);
            if (/^\s*$/.test(r4))
              t6.text = "", t6.raws.left = r4, t6.raws.right = "";
            else {
              var n3 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
              t6.text = n3[2], t6.raws.left = n3[1], t6.raws.right = n3[3];
            }
          }, t5.emptyRule = function(e6) {
            var t6 = new a2.default();
            this.init(t6, e6[2], e6[3]), t6.selector = "", t6.raws.between = "", this.current = t6;
          }, t5.other = function(e6) {
            for (var t6 = false, r4 = null, n3 = false, o3 = null, i3 = [], s3 = [], u3 = e6; u3; ) {
              if (r4 = u3[0], s3.push(u3), r4 === "(" || r4 === "[")
                o3 || (o3 = u3), i3.push(r4 === "(" ? ")" : "]");
              else if (i3.length === 0) {
                if (r4 === ";") {
                  if (n3)
                    return void this.decl(s3);
                  break;
                }
                if (r4 === "{")
                  return void this.rule(s3);
                if (r4 === "}") {
                  this.tokenizer.back(s3.pop()), t6 = true;
                  break;
                }
                r4 === ":" && (n3 = true);
              } else
                r4 === i3[i3.length - 1] && (i3.pop(), i3.length === 0 && (o3 = null));
              u3 = this.tokenizer.nextToken();
            }
            if (this.tokenizer.endOfFile() && (t6 = true), i3.length > 0 && this.unclosedBracket(o3), t6 && n3) {
              for (; s3.length && ((u3 = s3[s3.length - 1][0]) === "space" || u3 === "comment"); )
                this.tokenizer.back(s3.pop());
              this.decl(s3);
            } else
              this.unknownWord(s3);
          }, t5.rule = function(e6) {
            e6.pop();
            var t6 = new a2.default();
            this.init(t6, e6[0][2], e6[0][3]), t6.raws.between = this.spacesAndCommentsFromEnd(e6), this.raw(t6, "selector", e6), this.current = t6;
          }, t5.decl = function(e6) {
            var t6 = new n2.default();
            this.init(t6);
            var r4, o3 = e6[e6.length - 1];
            for (o3[0] === ";" && (this.semicolon = true, e6.pop()), o3[4] ? t6.source.end = { line: o3[4], column: o3[5] } : t6.source.end = { line: o3[2], column: o3[3] }; e6[0][0] !== "word"; )
              e6.length === 1 && this.unknownWord(e6), t6.raws.before += e6.shift()[1];
            for (t6.source.start = { line: e6[0][2], column: e6[0][3] }, t6.prop = ""; e6.length; ) {
              var i3 = e6[0][0];
              if (i3 === ":" || i3 === "space" || i3 === "comment")
                break;
              t6.prop += e6.shift()[1];
            }
            for (t6.raws.between = ""; e6.length; ) {
              if ((r4 = e6.shift())[0] === ":") {
                t6.raws.between += r4[1];
                break;
              }
              r4[0] === "word" && /\w/.test(r4[1]) && this.unknownWord([r4]), t6.raws.between += r4[1];
            }
            t6.prop[0] !== "_" && t6.prop[0] !== "*" || (t6.raws.before += t6.prop[0], t6.prop = t6.prop.slice(1)), t6.raws.between += this.spacesAndCommentsFromStart(e6), this.precheckMissedSemicolon(e6);
            for (var s3 = e6.length - 1; s3 > 0; s3--) {
              if ((r4 = e6[s3])[1].toLowerCase() === "!important") {
                t6.important = true;
                var u3 = this.stringFrom(e6, s3);
                (u3 = this.spacesFromEnd(e6) + u3) !== " !important" && (t6.raws.important = u3);
                break;
              }
              if (r4[1].toLowerCase() === "important") {
                for (var a3 = e6.slice(0), c3 = "", l3 = s3; l3 > 0; l3--) {
                  var f2 = a3[l3][0];
                  if (c3.trim().indexOf("!") === 0 && f2 !== "space")
                    break;
                  c3 = a3.pop()[1] + c3;
                }
                c3.trim().indexOf("!") === 0 && (t6.important = true, t6.raws.important = c3, e6 = a3);
              }
              if (r4[0] !== "space" && r4[0] !== "comment")
                break;
            }
            this.raw(t6, "value", e6), t6.value.indexOf(":") !== -1 && this.checkMissedSemicolon(e6);
          }, t5.atrule = function(e6) {
            var t6, r4, n3 = new s2.default();
            n3.name = e6[1].slice(1), n3.name === "" && this.unnamedAtrule(n3, e6), this.init(n3, e6[2], e6[3]);
            for (var o3 = false, i3 = false, u3 = []; !this.tokenizer.endOfFile(); ) {
              if ((e6 = this.tokenizer.nextToken())[0] === ";") {
                n3.source.end = { line: e6[2], column: e6[3] }, this.semicolon = true;
                break;
              }
              if (e6[0] === "{") {
                i3 = true;
                break;
              }
              if (e6[0] === "}") {
                if (u3.length > 0) {
                  for (t6 = u3[r4 = u3.length - 1]; t6 && t6[0] === "space"; )
                    t6 = u3[--r4];
                  t6 && (n3.source.end = { line: t6[4], column: t6[5] });
                }
                this.end(e6);
                break;
              }
              if (u3.push(e6), this.tokenizer.endOfFile()) {
                o3 = true;
                break;
              }
            }
            n3.raws.between = this.spacesAndCommentsFromEnd(u3), u3.length ? (n3.raws.afterName = this.spacesAndCommentsFromStart(u3), this.raw(n3, "params", u3), o3 && (e6 = u3[u3.length - 1], n3.source.end = { line: e6[4], column: e6[5] }, this.spaces = n3.raws.between, n3.raws.between = "")) : (n3.raws.afterName = "", n3.params = ""), i3 && (n3.nodes = [], this.current = n3);
          }, t5.end = function(e6) {
            this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = { line: e6[2], column: e6[3] }, this.current = this.current.parent) : this.unexpectedClose(e6);
          }, t5.endFile = function() {
            this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          }, t5.freeSemicolon = function(e6) {
            if (this.spaces += e6[1], this.current.nodes) {
              var t6 = this.current.nodes[this.current.nodes.length - 1];
              t6 && t6.type === "rule" && !t6.raws.ownSemicolon && (t6.raws.ownSemicolon = this.spaces, this.spaces = "");
            }
          }, t5.init = function(e6, t6, r4) {
            this.current.push(e6), e6.source = { start: { line: t6, column: r4 }, input: this.input }, e6.raws.before = this.spaces, this.spaces = "", e6.type !== "comment" && (this.semicolon = false);
          }, t5.raw = function(e6, t6, r4) {
            for (var n3, o3, i3, s3, u3 = r4.length, a3 = "", c3 = true, l3 = /^([.|#])?([\w])+/i, f2 = 0; f2 < u3; f2 += 1)
              (o3 = (n3 = r4[f2])[0]) !== "comment" || e6.type !== "rule" ? o3 === "comment" || o3 === "space" && f2 === u3 - 1 ? c3 = false : a3 += n3[1] : (s3 = r4[f2 - 1], i3 = r4[f2 + 1], s3[0] !== "space" && i3[0] !== "space" && l3.test(s3[1]) && l3.test(i3[1]) ? a3 += n3[1] : c3 = false);
            if (!c3) {
              var p2 = r4.reduce(function(e7, t7) {
                return e7 + t7[1];
              }, "");
              e6.raws[t6] = { value: a3, raw: p2 };
            }
            e6[t6] = a3;
          }, t5.spacesAndCommentsFromEnd = function(e6) {
            for (var t6, r4 = ""; e6.length && ((t6 = e6[e6.length - 1][0]) === "space" || t6 === "comment"); )
              r4 = e6.pop()[1] + r4;
            return r4;
          }, t5.spacesAndCommentsFromStart = function(e6) {
            for (var t6, r4 = ""; e6.length && ((t6 = e6[0][0]) === "space" || t6 === "comment"); )
              r4 += e6.shift()[1];
            return r4;
          }, t5.spacesFromEnd = function(e6) {
            for (var t6 = ""; e6.length && e6[e6.length - 1][0] === "space"; )
              t6 = e6.pop()[1] + t6;
            return t6;
          }, t5.stringFrom = function(e6, t6) {
            for (var r4 = "", n3 = t6; n3 < e6.length; n3++)
              r4 += e6[n3][1];
            return e6.splice(t6, e6.length - t6), r4;
          }, t5.colon = function(e6) {
            for (var t6, r4, n3, o3 = 0, i3 = 0; i3 < e6.length; i3++) {
              if ((r4 = (t6 = e6[i3])[0]) === "(" && (o3 += 1), r4 === ")" && (o3 -= 1), o3 === 0 && r4 === ":") {
                if (n3) {
                  if (n3[0] === "word" && n3[1] === "progid")
                    continue;
                  return i3;
                }
                this.doubleColon(t6);
              }
              n3 = t6;
            }
            return false;
          }, t5.unclosedBracket = function(e6) {
            throw this.input.error("Unclosed bracket", e6[2], e6[3]);
          }, t5.unknownWord = function(e6) {
            throw this.input.error("Unknown word", e6[0][2], e6[0][3]);
          }, t5.unexpectedClose = function(e6) {
            throw this.input.error("Unexpected }", e6[2], e6[3]);
          }, t5.unclosedBlock = function() {
            var e6 = this.current.source.start;
            throw this.input.error("Unclosed block", e6.line, e6.column);
          }, t5.doubleColon = function(e6) {
            throw this.input.error("Double colon", e6[2], e6[3]);
          }, t5.unnamedAtrule = function(e6, t6) {
            throw this.input.error("At-rule without name", t6[2], t6[3]);
          }, t5.precheckMissedSemicolon = function() {
          }, t5.checkMissedSemicolon = function(e6) {
            var t6 = this.colon(e6);
            if (t6 !== false) {
              for (var r4, n3 = 0, o3 = t6 - 1; o3 >= 0 && ((r4 = e6[o3])[0] === "space" || (n3 += 1) !== 2); o3--)
                ;
              throw this.input.error("Missed semicolon", r4[2], r4[3]);
            }
          }, e5;
        }();
        t4.default = l2, e4.exports = t4.default;
      }, 3353: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(2447)), o2 = s2(r3(3974)), i2 = s2(r3(4940));
        function s2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        var u2 = function() {
          function e5(e6, t6) {
            this.loadAnnotation(e6), this.inline = this.startWith(this.annotation, "data:");
            var r4 = t6.map ? t6.map.prev : void 0, n3 = this.loadMap(t6.from, r4);
            n3 && (this.text = n3);
          }
          var t5 = e5.prototype;
          return t5.consumer = function() {
            return this.consumerCache || (this.consumerCache = new n2.default.SourceMapConsumer(this.text)), this.consumerCache;
          }, t5.withContent = function() {
            return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
          }, t5.startWith = function(e6, t6) {
            return !!e6 && e6.substr(0, t6.length) === t6;
          }, t5.getAnnotationURL = function(e6) {
            return e6.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
          }, t5.loadAnnotation = function(e6) {
            var t6 = e6.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
            if (t6 && t6.length > 0) {
              var r4 = t6[t6.length - 1];
              r4 && (this.annotation = this.getAnnotationURL(r4));
            }
          }, t5.decodeInline = function(e6) {
            var t6, r4 = "data:application/json,";
            if (this.startWith(e6, r4))
              return decodeURIComponent(e6.substr(r4.length));
            if (/^data:application\/json;charset=utf-?8;base64,/.test(e6) || /^data:application\/json;base64,/.test(e6))
              return t6 = e6.substr(RegExp.lastMatch.length), Buffer ? Buffer.from(t6, "base64").toString() : window.atob(t6);
            var n3 = e6.match(/data:application\/json;([^,]+),/)[1];
            throw new Error("Unsupported source map encoding " + n3);
          }, t5.loadMap = function(e6, t6) {
            if (t6 === false)
              return false;
            if (t6) {
              if (typeof t6 == "string")
                return t6;
              if (typeof t6 == "function") {
                var r4 = t6(e6);
                if (r4 && i2.default.existsSync && i2.default.existsSync(r4))
                  return i2.default.readFileSync(r4, "utf-8").toString().trim();
                throw new Error("Unable to load previous source map: " + r4.toString());
              }
              if (t6 instanceof n2.default.SourceMapConsumer)
                return n2.default.SourceMapGenerator.fromSourceMap(t6).toString();
              if (t6 instanceof n2.default.SourceMapGenerator)
                return t6.toString();
              if (this.isMap(t6))
                return JSON.stringify(t6);
              throw new Error("Unsupported previous source map format: " + t6.toString());
            }
            if (this.inline)
              return this.decodeInline(this.annotation);
            if (this.annotation) {
              var s3 = this.annotation;
              return e6 && (s3 = o2.default.join(o2.default.dirname(e6), s3)), this.root = o2.default.dirname(s3), !(!i2.default.existsSync || !i2.default.existsSync(s3)) && i2.default.readFileSync(s3, "utf-8").toString().trim();
            }
          }, t5.isMap = function(e6) {
            return typeof e6 == "object" && (typeof e6.mappings == "string" || typeof e6._mappings == "string");
          }, e5;
        }();
        t4.default = u2, e4.exports = t4.default;
      }, 9429: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(6992)) && n2.__esModule ? n2 : { default: n2 };
        function i2(e5, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
            if (Array.isArray(e5) || (r4 = function(e6, t6) {
              if (e6) {
                if (typeof e6 == "string")
                  return s2(e6, t6);
                var r5 = Object.prototype.toString.call(e6).slice(8, -1);
                return r5 === "Object" && e6.constructor && (r5 = e6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? s2(e6, t6) : void 0;
              }
            }(e5)) || t5 && e5 && typeof e5.length == "number") {
              r4 && (e5 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e5.length ? { done: true } : { done: false, value: e5[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e5[Symbol.iterator]()).next.bind(r4);
        }
        function s2(e5, t5) {
          (t5 == null || t5 > e5.length) && (t5 = e5.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e5[r4];
          return n3;
        }
        var u2 = function() {
          function e5(e6) {
            e6 === void 0 && (e6 = []), this.version = "7.0.36", this.plugins = this.normalize(e6);
          }
          var t5 = e5.prototype;
          return t5.use = function(e6) {
            return this.plugins = this.plugins.concat(this.normalize([e6])), this;
          }, t5.process = function(e6) {
            function t6(t7) {
              return e6.apply(this, arguments);
            }
            return t6.toString = function() {
              return e6.toString();
            }, t6;
          }(function(e6, t6) {
            return t6 === void 0 && (t6 = {}), this.plugins.length === 0 && (t6.parser, t6.stringifier), new o2.default(this, e6, t6);
          }), t5.normalize = function(e6) {
            for (var t6, r4 = [], n3 = i2(e6); !(t6 = n3()).done; ) {
              var o3 = t6.value;
              if (o3.postcss === true) {
                var s3 = o3();
                throw new Error("PostCSS plugin " + s3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users");
              }
              if (o3.postcss && (o3 = o3.postcss), typeof o3 == "object" && Array.isArray(o3.plugins))
                r4 = r4.concat(o3.plugins);
              else if (typeof o3 == "function")
                r4.push(o3);
              else if (typeof o3 != "object" || !o3.parse && !o3.stringify)
                throw typeof o3 == "object" && o3.postcssPlugin ? new Error("PostCSS plugin " + o3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users") : new Error(o3 + " is not a PostCSS plugin");
            }
            return r4;
          }, e5;
        }();
        t4.default = u2, e4.exports = t4.default;
      }, 6865: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(1662)) && n2.__esModule ? n2 : { default: n2 };
        function i2(e5, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e5, n3.key, n3);
          }
        }
        var s2 = function() {
          function e5(e6, t6, r5) {
            this.processor = e6, this.messages = [], this.root = t6, this.opts = r5, this.css = void 0, this.map = void 0;
          }
          var t5, r4 = e5.prototype;
          return r4.toString = function() {
            return this.css;
          }, r4.warn = function(e6, t6) {
            t6 === void 0 && (t6 = {}), t6.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t6.plugin = this.lastPlugin.postcssPlugin);
            var r5 = new o2.default(e6, t6);
            return this.messages.push(r5), r5;
          }, r4.warnings = function() {
            return this.messages.filter(function(e6) {
              return e6.type === "warning";
            });
          }, (t5 = [{ key: "content", get: function() {
            return this.css;
          } }]) && i2(e5.prototype, t5), e5;
        }();
        t4.default = s2, e4.exports = t4.default;
      }, 7563: (e4, t4, r3) => {
        var n2;
        function o2(e5, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
            if (Array.isArray(e5) || (r4 = function(e6, t6) {
              if (e6) {
                if (typeof e6 == "string")
                  return i2(e6, t6);
                var r5 = Object.prototype.toString.call(e6).slice(8, -1);
                return r5 === "Object" && e6.constructor && (r5 = e6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? i2(e6, t6) : void 0;
              }
            }(e5)) || t5 && e5 && typeof e5.length == "number") {
              r4 && (e5 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e5.length ? { done: true } : { done: false, value: e5[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e5[Symbol.iterator]()).next.bind(r4);
        }
        function i2(e5, t5) {
          (t5 == null || t5 > e5.length) && (t5 = e5.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e5[r4];
          return n3;
        }
        t4.__esModule = true, t4.default = void 0;
        var s2 = function(e5) {
          var t5, n3;
          function i3(t6) {
            var r4;
            return (r4 = e5.call(this, t6) || this).type = "root", r4.nodes || (r4.nodes = []), r4;
          }
          n3 = e5, (t5 = i3).prototype = Object.create(n3.prototype), t5.prototype.constructor = t5, t5.__proto__ = n3;
          var s3 = i3.prototype;
          return s3.removeChild = function(t6, r4) {
            var n4 = this.index(t6);
            return !r4 && n4 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n4].raws.before), e5.prototype.removeChild.call(this, t6);
          }, s3.normalize = function(t6, r4, n4) {
            var i4 = e5.prototype.normalize.call(this, t6);
            if (r4) {
              if (n4 === "prepend")
                this.nodes.length > 1 ? r4.raws.before = this.nodes[1].raws.before : delete r4.raws.before;
              else if (this.first !== r4)
                for (var s4, u2 = o2(i4); !(s4 = u2()).done; )
                  s4.value.raws.before = r4.raws.before;
            }
            return i4;
          }, s3.toResult = function(e6) {
            return e6 === void 0 && (e6 = {}), new (r3(6992))(new (r3(9429))(), this, e6).stringify();
          }, i3;
        }(((n2 = r3(1204)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = s2, e4.exports = t4.default;
      }, 6621: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(1204)), o2 = i2(r3(6136));
        function i2(e5) {
          return e5 && e5.__esModule ? e5 : { default: e5 };
        }
        function s2(e5, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e5, n3.key, n3);
          }
        }
        var u2 = function(e5) {
          var t5, r4, n3;
          function i3(t6) {
            var r5;
            return (r5 = e5.call(this, t6) || this).type = "rule", r5.nodes || (r5.nodes = []), r5;
          }
          return r4 = e5, (t5 = i3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, (n3 = [{ key: "selectors", get: function() {
            return o2.default.comma(this.selector);
          }, set: function(e6) {
            var t6 = this.selector ? this.selector.match(/,\s*/) : null, r5 = t6 ? t6[0] : "," + this.raw("between", "beforeOpen");
            this.selector = e6.join(r5);
          } }]) && s2(i3.prototype, n3), i3;
        }(n2.default);
        t4.default = u2, e4.exports = t4.default;
      }, 5701: (e4, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = { colon: ": ", indent: "    ", beforeDecl: "\n", beforeRule: "\n", beforeOpen: " ", beforeClose: "\n", beforeComment: "\n", after: "\n", emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false }, n2 = function() {
          function e5(e6) {
            this.builder = e6;
          }
          var t5 = e5.prototype;
          return t5.stringify = function(e6, t6) {
            this[e6.type](e6, t6);
          }, t5.root = function(e6) {
            this.body(e6), e6.raws.after && this.builder(e6.raws.after);
          }, t5.comment = function(e6) {
            var t6 = this.raw(e6, "left", "commentLeft"), r4 = this.raw(e6, "right", "commentRight");
            this.builder("/*" + t6 + e6.text + r4 + "*/", e6);
          }, t5.decl = function(e6, t6) {
            var r4 = this.raw(e6, "between", "colon"), n3 = e6.prop + r4 + this.rawValue(e6, "value");
            e6.important && (n3 += e6.raws.important || " !important"), t6 && (n3 += ";"), this.builder(n3, e6);
          }, t5.rule = function(e6) {
            this.block(e6, this.rawValue(e6, "selector")), e6.raws.ownSemicolon && this.builder(e6.raws.ownSemicolon, e6, "end");
          }, t5.atrule = function(e6, t6) {
            var r4 = "@" + e6.name, n3 = e6.params ? this.rawValue(e6, "params") : "";
            if (e6.raws.afterName !== void 0 ? r4 += e6.raws.afterName : n3 && (r4 += " "), e6.nodes)
              this.block(e6, r4 + n3);
            else {
              var o2 = (e6.raws.between || "") + (t6 ? ";" : "");
              this.builder(r4 + n3 + o2, e6);
            }
          }, t5.body = function(e6) {
            for (var t6 = e6.nodes.length - 1; t6 > 0 && e6.nodes[t6].type === "comment"; )
              t6 -= 1;
            for (var r4 = this.raw(e6, "semicolon"), n3 = 0; n3 < e6.nodes.length; n3++) {
              var o2 = e6.nodes[n3], i2 = this.raw(o2, "before");
              i2 && this.builder(i2), this.stringify(o2, t6 !== n3 || r4);
            }
          }, t5.block = function(e6, t6) {
            var r4, n3 = this.raw(e6, "between", "beforeOpen");
            this.builder(t6 + n3 + "{", e6, "start"), e6.nodes && e6.nodes.length ? (this.body(e6), r4 = this.raw(e6, "after")) : r4 = this.raw(e6, "after", "emptyBody"), r4 && this.builder(r4), this.builder("}", e6, "end");
          }, t5.raw = function(e6, t6, n3) {
            var o2;
            if (n3 || (n3 = t6), t6 && (o2 = e6.raws[t6]) !== void 0)
              return o2;
            var i2 = e6.parent;
            if (n3 === "before" && (!i2 || i2.type === "root" && i2.first === e6))
              return "";
            if (!i2)
              return r3[n3];
            var s2 = e6.root();
            if (s2.rawCache || (s2.rawCache = {}), s2.rawCache[n3] !== void 0)
              return s2.rawCache[n3];
            if (n3 === "before" || n3 === "after")
              return this.beforeAfter(e6, n3);
            var u2, a2 = "raw" + ((u2 = n3)[0].toUpperCase() + u2.slice(1));
            return this[a2] ? o2 = this[a2](s2, e6) : s2.walk(function(e7) {
              if ((o2 = e7.raws[t6]) !== void 0)
                return false;
            }), o2 === void 0 && (o2 = r3[n3]), s2.rawCache[n3] = o2, o2;
          }, t5.rawSemicolon = function(e6) {
            var t6;
            return e6.walk(function(e7) {
              if (e7.nodes && e7.nodes.length && e7.last.type === "decl" && (t6 = e7.raws.semicolon) !== void 0)
                return false;
            }), t6;
          }, t5.rawEmptyBody = function(e6) {
            var t6;
            return e6.walk(function(e7) {
              if (e7.nodes && e7.nodes.length === 0 && (t6 = e7.raws.after) !== void 0)
                return false;
            }), t6;
          }, t5.rawIndent = function(e6) {
            return e6.raws.indent ? e6.raws.indent : (e6.walk(function(r4) {
              var n3 = r4.parent;
              if (n3 && n3 !== e6 && n3.parent && n3.parent === e6 && r4.raws.before !== void 0) {
                var o2 = r4.raws.before.split("\n");
                return t6 = (t6 = o2[o2.length - 1]).replace(/[^\s]/g, ""), false;
              }
            }), t6);
            var t6;
          }, t5.rawBeforeComment = function(e6, t6) {
            var r4;
            return e6.walkComments(function(e7) {
              if (e7.raws.before !== void 0)
                return (r4 = e7.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
            }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeDecl") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
          }, t5.rawBeforeDecl = function(e6, t6) {
            var r4;
            return e6.walkDecls(function(e7) {
              if (e7.raws.before !== void 0)
                return (r4 = e7.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
            }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeRule") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
          }, t5.rawBeforeRule = function(e6) {
            var t6;
            return e6.walk(function(r4) {
              if (r4.nodes && (r4.parent !== e6 || e6.first !== r4) && r4.raws.before !== void 0)
                return (t6 = r4.raws.before).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
            }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
          }, t5.rawBeforeClose = function(e6) {
            var t6;
            return e6.walk(function(e7) {
              if (e7.nodes && e7.nodes.length > 0 && e7.raws.after !== void 0)
                return (t6 = e7.raws.after).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
            }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
          }, t5.rawBeforeOpen = function(e6) {
            var t6;
            return e6.walk(function(e7) {
              if (e7.type !== "decl" && (t6 = e7.raws.between) !== void 0)
                return false;
            }), t6;
          }, t5.rawColon = function(e6) {
            var t6;
            return e6.walkDecls(function(e7) {
              if (e7.raws.between !== void 0)
                return t6 = e7.raws.between.replace(/[^\s:]/g, ""), false;
            }), t6;
          }, t5.beforeAfter = function(e6, t6) {
            var r4;
            r4 = e6.type === "decl" ? this.raw(e6, null, "beforeDecl") : e6.type === "comment" ? this.raw(e6, null, "beforeComment") : t6 === "before" ? this.raw(e6, null, "beforeRule") : this.raw(e6, null, "beforeClose");
            for (var n3 = e6.parent, o2 = 0; n3 && n3.type !== "root"; )
              o2 += 1, n3 = n3.parent;
            if (r4.indexOf("\n") !== -1) {
              var i2 = this.raw(e6, null, "indent");
              if (i2.length)
                for (var s2 = 0; s2 < o2; s2++)
                  r4 += i2;
            }
            return r4;
          }, t5.rawValue = function(e6, t6) {
            var r4 = e6[t6], n3 = e6.raws[t6];
            return n3 && n3.value === r4 ? n3.raw : r4;
          }, e5;
        }();
        t4.default = n2, e4.exports = t4.default;
      }, 6157: (e4, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(5701)) && n2.__esModule ? n2 : { default: n2 }, i2 = function(e5, t5) {
          new o2.default(t5).stringify(e5);
        };
        t4.default = i2, e4.exports = t4.default;
      }, 1157: (e4, t4) => {
        t4.__esModule = true, t4.default = function(e5, t5) {
          t5 === void 0 && (t5 = {});
          var x2, A2, k2, O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2 = e5.css.valueOf(), $2 = t5.ignoreErrors, U2 = P2.length, G2 = -1, W2 = 1, z2 = 0, V2 = [], q2 = [];
          function X2(t6) {
            throw e5.error("Unclosed " + t6, W2, z2 - G2);
          }
          return { back: function(e6) {
            q2.push(e6);
          }, nextToken: function(e6) {
            if (q2.length)
              return q2.pop();
            if (!(z2 >= U2)) {
              var t6 = !!e6 && e6.ignoreUnclosed;
              switch (((x2 = P2.charCodeAt(z2)) === s2 || x2 === a2 || x2 === l2 && P2.charCodeAt(z2 + 1) !== s2) && (G2 = z2, W2 += 1), x2) {
                case s2:
                case u2:
                case c2:
                case l2:
                case a2:
                  A2 = z2;
                  do {
                    A2 += 1, (x2 = P2.charCodeAt(A2)) === s2 && (G2 = A2, W2 += 1);
                  } while (x2 === u2 || x2 === s2 || x2 === c2 || x2 === l2 || x2 === a2);
                  B2 = ["space", P2.slice(z2, A2)], z2 = A2 - 1;
                  break;
                case f2:
                case p2:
                case D2:
                case g2:
                case y2:
                case m2:
                case d2:
                  var J2 = String.fromCharCode(x2);
                  B2 = [J2, J2, W2, z2 - G2];
                  break;
                case h2:
                  if (j2 = V2.length ? V2.pop()[1] : "", L2 = P2.charCodeAt(z2 + 1), j2 === "url" && L2 !== r3 && L2 !== n2 && L2 !== u2 && L2 !== s2 && L2 !== c2 && L2 !== a2 && L2 !== l2) {
                    A2 = z2;
                    do {
                      if (M2 = false, (A2 = P2.indexOf(")", A2 + 1)) === -1) {
                        if ($2 || t6) {
                          A2 = z2;
                          break;
                        }
                        X2("bracket");
                      }
                      for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                        R2 -= 1, M2 = !M2;
                    } while (M2);
                    B2 = ["brackets", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                  } else
                    A2 = P2.indexOf(")", z2 + 1), S2 = P2.slice(z2, A2 + 1), A2 === -1 || E2.test(S2) ? B2 = ["(", "(", W2, z2 - G2] : (B2 = ["brackets", S2, W2, z2 - G2, W2, A2 - G2], z2 = A2);
                  break;
                case r3:
                case n2:
                  k2 = x2 === r3 ? "'" : '"', A2 = z2;
                  do {
                    if (M2 = false, (A2 = P2.indexOf(k2, A2 + 1)) === -1) {
                      if ($2 || t6) {
                        A2 = z2 + 1;
                        break;
                      }
                      X2("string");
                    }
                    for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                      R2 -= 1, M2 = !M2;
                  } while (M2);
                  S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = ["string", P2.slice(z2, A2 + 1), W2, z2 - G2, I2, A2 - N2], G2 = N2, W2 = I2, z2 = A2;
                  break;
                case w2:
                  b2.lastIndex = z2 + 1, b2.test(P2), A2 = b2.lastIndex === 0 ? P2.length - 1 : b2.lastIndex - 2, B2 = ["at-word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                  break;
                case o2:
                  for (A2 = z2, T2 = true; P2.charCodeAt(A2 + 1) === o2; )
                    A2 += 1, T2 = !T2;
                  if (x2 = P2.charCodeAt(A2 + 1), T2 && x2 !== i2 && x2 !== u2 && x2 !== s2 && x2 !== c2 && x2 !== l2 && x2 !== a2 && (A2 += 1, F2.test(P2.charAt(A2)))) {
                    for (; F2.test(P2.charAt(A2 + 1)); )
                      A2 += 1;
                    P2.charCodeAt(A2 + 1) === u2 && (A2 += 1);
                  }
                  B2 = ["word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                  break;
                default:
                  x2 === i2 && P2.charCodeAt(z2 + 1) === v2 ? ((A2 = P2.indexOf("*/", z2 + 2) + 1) === 0 && ($2 || t6 ? A2 = P2.length : X2("comment")), S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = ["comment", S2, W2, z2 - G2, I2, A2 - N2], G2 = N2, W2 = I2, z2 = A2) : (C2.lastIndex = z2 + 1, C2.test(P2), A2 = C2.lastIndex === 0 ? P2.length - 1 : C2.lastIndex - 2, B2 = ["word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], V2.push(B2), z2 = A2);
              }
              return z2++, B2;
            }
          }, endOfFile: function() {
            return q2.length === 0 && z2 >= U2;
          }, position: function() {
            return z2;
          } };
        };
        var r3 = "'".charCodeAt(0), n2 = '"'.charCodeAt(0), o2 = "\\".charCodeAt(0), i2 = "/".charCodeAt(0), s2 = "\n".charCodeAt(0), u2 = " ".charCodeAt(0), a2 = "\f".charCodeAt(0), c2 = "	".charCodeAt(0), l2 = "\r".charCodeAt(0), f2 = "[".charCodeAt(0), p2 = "]".charCodeAt(0), h2 = "(".charCodeAt(0), d2 = ")".charCodeAt(0), D2 = "{".charCodeAt(0), g2 = "}".charCodeAt(0), m2 = ";".charCodeAt(0), v2 = "*".charCodeAt(0), y2 = ":".charCodeAt(0), w2 = "@".charCodeAt(0), b2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, C2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, E2 = /.[\\/("'\n]/, F2 = /[a-f0-9]/i;
        e4.exports = t4.default;
      }, 6574: (e4, t4) => {
        t4.__esModule = true, t4.default = function(e5) {
          r3[e5] || (r3[e5] = true, typeof console != "undefined" && console.warn && console.warn(e5));
        };
        var r3 = {};
        e4.exports = t4.default;
      }, 1662: (e4, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = function() {
          function e5(e6, t5) {
            if (t5 === void 0 && (t5 = {}), this.type = "warning", this.text = e6, t5.node && t5.node.source) {
              var r4 = t5.node.positionBy(t5);
              this.line = r4.line, this.column = r4.column;
            }
            for (var n2 in t5)
              this[n2] = t5[n2];
          }
          return e5.prototype.toString = function() {
            return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
          }, e5;
        }();
        t4.default = r3, e4.exports = t4.default;
      }, 6210: (e4, t4, r3) => {
        const n2 = r3(895), { MAX_LENGTH: o2, MAX_SAFE_INTEGER: i2 } = r3(8523), { re: s2, t: u2 } = r3(3443), a2 = r3(8077), { compareIdentifiers: c2 } = r3(8337);
        class l2 {
          constructor(e5, t5) {
            if (t5 = a2(t5), e5 instanceof l2) {
              if (e5.loose === !!t5.loose && e5.includePrerelease === !!t5.includePrerelease)
                return e5;
              e5 = e5.version;
            } else if (typeof e5 != "string")
              throw new TypeError(`Invalid Version: ${e5}`);
            if (e5.length > o2)
              throw new TypeError(`version is longer than ${o2} characters`);
            n2("SemVer", e5, t5), this.options = t5, this.loose = !!t5.loose, this.includePrerelease = !!t5.includePrerelease;
            const r4 = e5.trim().match(t5.loose ? s2[u2.LOOSE] : s2[u2.FULL]);
            if (!r4)
              throw new TypeError(`Invalid Version: ${e5}`);
            if (this.raw = e5, this.major = +r4[1], this.minor = +r4[2], this.patch = +r4[3], this.major > i2 || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > i2 || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > i2 || this.patch < 0)
              throw new TypeError("Invalid patch version");
            r4[4] ? this.prerelease = r4[4].split(".").map((e6) => {
              if (/^[0-9]+$/.test(e6)) {
                const t6 = +e6;
                if (t6 >= 0 && t6 < i2)
                  return t6;
              }
              return e6;
            }) : this.prerelease = [], this.build = r4[5] ? r4[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(e5) {
            if (n2("SemVer.compare", this.version, this.options, e5), !(e5 instanceof l2)) {
              if (typeof e5 == "string" && e5 === this.version)
                return 0;
              e5 = new l2(e5, this.options);
            }
            return e5.version === this.version ? 0 : this.compareMain(e5) || this.comparePre(e5);
          }
          compareMain(e5) {
            return e5 instanceof l2 || (e5 = new l2(e5, this.options)), c2(this.major, e5.major) || c2(this.minor, e5.minor) || c2(this.patch, e5.patch);
          }
          comparePre(e5) {
            if (e5 instanceof l2 || (e5 = new l2(e5, this.options)), this.prerelease.length && !e5.prerelease.length)
              return -1;
            if (!this.prerelease.length && e5.prerelease.length)
              return 1;
            if (!this.prerelease.length && !e5.prerelease.length)
              return 0;
            let t5 = 0;
            do {
              const r4 = this.prerelease[t5], o3 = e5.prerelease[t5];
              if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
                return 0;
              if (o3 === void 0)
                return 1;
              if (r4 === void 0)
                return -1;
              if (r4 !== o3)
                return c2(r4, o3);
            } while (++t5);
          }
          compareBuild(e5) {
            e5 instanceof l2 || (e5 = new l2(e5, this.options));
            let t5 = 0;
            do {
              const r4 = this.build[t5], o3 = e5.build[t5];
              if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
                return 0;
              if (o3 === void 0)
                return 1;
              if (r4 === void 0)
                return -1;
              if (r4 !== o3)
                return c2(r4, o3);
            } while (++t5);
          }
          inc(e5, t5) {
            switch (e5) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t5);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t5);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t5), this.inc("pre", t5);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", t5), this.inc("pre", t5);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let e6 = this.prerelease.length;
                  for (; --e6 >= 0; )
                    typeof this.prerelease[e6] == "number" && (this.prerelease[e6]++, e6 = -2);
                  e6 === -1 && this.prerelease.push(0);
                }
                t5 && (this.prerelease[0] === t5 ? isNaN(this.prerelease[1]) && (this.prerelease = [t5, 0]) : this.prerelease = [t5, 0]);
                break;
              default:
                throw new Error(`invalid increment argument: ${e5}`);
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        e4.exports = l2;
      }, 2828: (e4, t4, r3) => {
        const n2 = r3(6210);
        e4.exports = (e5, t5, r4) => new n2(e5, r4).compare(new n2(t5, r4));
      }, 9195: (e4, t4, r3) => {
        const n2 = r3(2828);
        e4.exports = (e5, t5, r4) => n2(e5, t5, r4) >= 0;
      }, 3725: (e4, t4, r3) => {
        const n2 = r3(2828);
        e4.exports = (e5, t5, r4) => n2(e5, t5, r4) < 0;
      }, 8523: (e4) => {
        const t4 = Number.MAX_SAFE_INTEGER || 9007199254740991;
        e4.exports = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: t4, MAX_SAFE_COMPONENT_LENGTH: 16 };
      }, 895: (e4) => {
        const t4 = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...e5) => console.error("SEMVER", ...e5) : () => {
        };
        e4.exports = t4;
      }, 8337: (e4) => {
        const t4 = /^[0-9]+$/, r3 = (e5, r4) => {
          const n2 = t4.test(e5), o2 = t4.test(r4);
          return n2 && o2 && (e5 = +e5, r4 = +r4), e5 === r4 ? 0 : n2 && !o2 ? -1 : o2 && !n2 ? 1 : e5 < r4 ? -1 : 1;
        };
        e4.exports = { compareIdentifiers: r3, rcompareIdentifiers: (e5, t5) => r3(t5, e5) };
      }, 8077: (e4) => {
        const t4 = ["includePrerelease", "loose", "rtl"];
        e4.exports = (e5) => e5 ? typeof e5 != "object" ? { loose: true } : t4.filter((t5) => e5[t5]).reduce((e6, t5) => (e6[t5] = true, e6), {}) : {};
      }, 3443: (e4, t4, r3) => {
        const { MAX_SAFE_COMPONENT_LENGTH: n2 } = r3(8523), o2 = r3(895), i2 = (t4 = e4.exports = {}).re = [], s2 = t4.src = [], u2 = t4.t = {};
        let a2 = 0;
        const c2 = (e5, t5, r4) => {
          const n3 = a2++;
          o2(n3, t5), u2[e5] = n3, s2[n3] = t5, i2[n3] = new RegExp(t5, r4 ? "g" : void 0);
        };
        c2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c2("MAINVERSION", `(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})`), c2("MAINVERSIONLOOSE", `(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})`), c2("PRERELEASEIDENTIFIER", `(?:${s2[u2.NUMERICIDENTIFIER]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASEIDENTIFIERLOOSE", `(?:${s2[u2.NUMERICIDENTIFIERLOOSE]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASE", `(?:-(${s2[u2.PRERELEASEIDENTIFIER]}(?:\\.${s2[u2.PRERELEASEIDENTIFIER]})*))`), c2("PRERELEASELOOSE", `(?:-?(${s2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), c2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c2("BUILD", `(?:\\+(${s2[u2.BUILDIDENTIFIER]}(?:\\.${s2[u2.BUILDIDENTIFIER]})*))`), c2("FULLPLAIN", `v?${s2[u2.MAINVERSION]}${s2[u2.PRERELEASE]}?${s2[u2.BUILD]}?`), c2("FULL", `^${s2[u2.FULLPLAIN]}$`), c2("LOOSEPLAIN", `[v=\\s]*${s2[u2.MAINVERSIONLOOSE]}${s2[u2.PRERELEASELOOSE]}?${s2[u2.BUILD]}?`), c2("LOOSE", `^${s2[u2.LOOSEPLAIN]}$`), c2("GTLT", "((?:<|>)?=?)"), c2("XRANGEIDENTIFIERLOOSE", `${s2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), c2("XRANGEIDENTIFIER", `${s2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), c2("XRANGEPLAIN", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:${s2[u2.PRERELEASE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGEPLAINLOOSE", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:${s2[u2.PRERELEASELOOSE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAIN]}$`), c2("XRANGELOOSE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), c2("COERCERTL", s2[u2.COERCE], true), c2("LONETILDE", "(?:~>?)"), c2("TILDETRIM", `(\\s*)${s2[u2.LONETILDE]}\\s+`, true), t4.tildeTrimReplace = "$1~", c2("TILDE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAIN]}$`), c2("TILDELOOSE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("LONECARET", "(?:\\^)"), c2("CARETTRIM", `(\\s*)${s2[u2.LONECARET]}\\s+`, true), t4.caretTrimReplace = "$1^", c2("CARET", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAIN]}$`), c2("CARETLOOSE", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COMPARATORLOOSE", `^${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]})$|^$`), c2("COMPARATOR", `^${s2[u2.GTLT]}\\s*(${s2[u2.FULLPLAIN]})$|^$`), c2("COMPARATORTRIM", `(\\s*)${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]}|${s2[u2.XRANGEPLAIN]})`, true), t4.comparatorTrimReplace = "$1$2$3", c2("HYPHENRANGE", `^\\s*(${s2[u2.XRANGEPLAIN]})\\s+-\\s+(${s2[u2.XRANGEPLAIN]})\\s*$`), c2("HYPHENRANGELOOSE", `^\\s*(${s2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${s2[u2.XRANGEPLAINLOOSE]})\\s*$`), c2("STAR", "(<|>)?=?\\s*\\*"), c2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      }, 6715: (e4, t4, r3) => {
        var n2 = r3(7837), o2 = Object.prototype.hasOwnProperty, i2 = typeof Map != "undefined";
        function s2() {
          this._array = [], this._set = i2 ? new Map() : Object.create(null);
        }
        s2.fromArray = function(e5, t5) {
          for (var r4 = new s2(), n3 = 0, o3 = e5.length; n3 < o3; n3++)
            r4.add(e5[n3], t5);
          return r4;
        }, s2.prototype.size = function() {
          return i2 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        }, s2.prototype.add = function(e5, t5) {
          var r4 = i2 ? e5 : n2.toSetString(e5), s3 = i2 ? this.has(e5) : o2.call(this._set, r4), u2 = this._array.length;
          s3 && !t5 || this._array.push(e5), s3 || (i2 ? this._set.set(e5, u2) : this._set[r4] = u2);
        }, s2.prototype.has = function(e5) {
          if (i2)
            return this._set.has(e5);
          var t5 = n2.toSetString(e5);
          return o2.call(this._set, t5);
        }, s2.prototype.indexOf = function(e5) {
          if (i2) {
            var t5 = this._set.get(e5);
            if (t5 >= 0)
              return t5;
          } else {
            var r4 = n2.toSetString(e5);
            if (o2.call(this._set, r4))
              return this._set[r4];
          }
          throw new Error('"' + e5 + '" is not in the set.');
        }, s2.prototype.at = function(e5) {
          if (e5 >= 0 && e5 < this._array.length)
            return this._array[e5];
          throw new Error("No element indexed by " + e5);
        }, s2.prototype.toArray = function() {
          return this._array.slice();
        }, t4.I = s2;
      }, 4886: (e4, t4, r3) => {
        var n2 = r3(4122);
        t4.encode = function(e5) {
          var t5, r4 = "", o2 = function(e6) {
            return e6 < 0 ? 1 + (-e6 << 1) : 0 + (e6 << 1);
          }(e5);
          do {
            t5 = 31 & o2, (o2 >>>= 5) > 0 && (t5 |= 32), r4 += n2.encode(t5);
          } while (o2 > 0);
          return r4;
        }, t4.decode = function(e5, t5, r4) {
          var o2, i2, s2, u2, a2 = e5.length, c2 = 0, l2 = 0;
          do {
            if (t5 >= a2)
              throw new Error("Expected more digits in base 64 VLQ value.");
            if ((i2 = n2.decode(e5.charCodeAt(t5++))) === -1)
              throw new Error("Invalid base64 digit: " + e5.charAt(t5 - 1));
            o2 = !!(32 & i2), c2 += (i2 &= 31) << l2, l2 += 5;
          } while (o2);
          r4.value = (u2 = (s2 = c2) >> 1, (1 & s2) == 1 ? -u2 : u2), r4.rest = t5;
        };
      }, 4122: (e4, t4) => {
        var r3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        t4.encode = function(e5) {
          if (0 <= e5 && e5 < r3.length)
            return r3[e5];
          throw new TypeError("Must be between 0 and 63: " + e5);
        }, t4.decode = function(e5) {
          return 65 <= e5 && e5 <= 90 ? e5 - 65 : 97 <= e5 && e5 <= 122 ? e5 - 97 + 26 : 48 <= e5 && e5 <= 57 ? e5 - 48 + 52 : e5 == 43 ? 62 : e5 == 47 ? 63 : -1;
        };
      }, 8593: (e4, t4) => {
        function r3(e5, n2, o2, i2, s2, u2) {
          var a2 = Math.floor((n2 - e5) / 2) + e5, c2 = s2(o2, i2[a2], true);
          return c2 === 0 ? a2 : c2 > 0 ? n2 - a2 > 1 ? r3(a2, n2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? n2 < i2.length ? n2 : -1 : a2 : a2 - e5 > 1 ? r3(e5, a2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? a2 : e5 < 0 ? -1 : e5;
        }
        t4.GREATEST_LOWER_BOUND = 1, t4.LEAST_UPPER_BOUND = 2, t4.search = function(e5, n2, o2, i2) {
          if (n2.length === 0)
            return -1;
          var s2 = r3(-1, n2.length, e5, n2, o2, i2 || t4.GREATEST_LOWER_BOUND);
          if (s2 < 0)
            return -1;
          for (; s2 - 1 >= 0 && o2(n2[s2], n2[s2 - 1], true) === 0; )
            --s2;
          return s2;
        };
      }, 1028: (e4, t4, r3) => {
        r3(4070);
        var n2 = r3(7837);
        function o2() {
          this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
        }
        o2.prototype.unsortedForEach = function(e5, t5) {
          this._array.forEach(e5, t5);
        }, o2.prototype.add = function(e5) {
          var t5, r4, o3, i2, s2, u2;
          r4 = e5, o3 = (t5 = this._last).generatedLine, i2 = r4.generatedLine, s2 = t5.generatedColumn, u2 = r4.generatedColumn, i2 > o3 || i2 == o3 && u2 >= s2 || n2.compareByGeneratedPositionsInflated(t5, r4) <= 0 ? (this._last = e5, this._array.push(e5)) : (this._sorted = false, this._array.push(e5));
        }, o2.prototype.toArray = function() {
          return this._sorted || (this._array.sort(n2.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
        }, t4.H = o2;
      }, 6711: (e4, t4) => {
        function r3(e5, t5, r4) {
          var n3 = e5[t5];
          e5[t5] = e5[r4], e5[r4] = n3;
        }
        function n2(e5, t5, o2, i2) {
          if (o2 < i2) {
            var s2 = o2 - 1;
            r3(e5, (l2 = o2, f2 = i2, Math.round(l2 + Math.random() * (f2 - l2))), i2);
            for (var u2 = e5[i2], a2 = o2; a2 < i2; a2++)
              t5(e5[a2], u2) <= 0 && r3(e5, s2 += 1, a2);
            r3(e5, s2 + 1, a2);
            var c2 = s2 + 1;
            n2(e5, t5, o2, c2 - 1), n2(e5, t5, c2 + 1, i2);
          }
          var l2, f2;
        }
        t4.U = function(e5, t5) {
          n2(e5, t5, 0, e5.length - 1);
        };
      }, 8985: (e4, t4, r3) => {
        var n2 = r3(7837), o2 = r3(8593), i2 = r3(6715).I, s2 = r3(4886), u2 = r3(6711).U;
        function a2(e5, t5) {
          var r4 = e5;
          return typeof e5 == "string" && (r4 = n2.parseSourceMapInput(e5)), r4.sections != null ? new f2(r4, t5) : new c2(r4, t5);
        }
        function c2(e5, t5) {
          var r4 = e5;
          typeof e5 == "string" && (r4 = n2.parseSourceMapInput(e5));
          var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sources"), u3 = n2.getArg(r4, "names", []), a3 = n2.getArg(r4, "sourceRoot", null), c3 = n2.getArg(r4, "sourcesContent", null), l3 = n2.getArg(r4, "mappings"), f3 = n2.getArg(r4, "file", null);
          if (o3 != this._version)
            throw new Error("Unsupported version: " + o3);
          a3 && (a3 = n2.normalize(a3)), s3 = s3.map(String).map(n2.normalize).map(function(e6) {
            return a3 && n2.isAbsolute(a3) && n2.isAbsolute(e6) ? n2.relative(a3, e6) : e6;
          }), this._names = i2.fromArray(u3.map(String), true), this._sources = i2.fromArray(s3, true), this._absoluteSources = this._sources.toArray().map(function(e6) {
            return n2.computeSourceURL(a3, e6, t5);
          }), this.sourceRoot = a3, this.sourcesContent = c3, this._mappings = l3, this._sourceMapURL = t5, this.file = f3;
        }
        function l2() {
          this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
        }
        function f2(e5, t5) {
          var r4 = e5;
          typeof e5 == "string" && (r4 = n2.parseSourceMapInput(e5));
          var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sections");
          if (o3 != this._version)
            throw new Error("Unsupported version: " + o3);
          this._sources = new i2(), this._names = new i2();
          var u3 = { line: -1, column: 0 };
          this._sections = s3.map(function(e6) {
            if (e6.url)
              throw new Error("Support for url field in sections not implemented.");
            var r5 = n2.getArg(e6, "offset"), o4 = n2.getArg(r5, "line"), i3 = n2.getArg(r5, "column");
            if (o4 < u3.line || o4 === u3.line && i3 < u3.column)
              throw new Error("Section offsets must be ordered and non-overlapping.");
            return u3 = r5, { generatedOffset: { generatedLine: o4 + 1, generatedColumn: i3 + 1 }, consumer: new a2(n2.getArg(e6, "map"), t5) };
          });
        }
        a2.fromSourceMap = function(e5, t5) {
          return c2.fromSourceMap(e5, t5);
        }, a2.prototype._version = 3, a2.prototype.__generatedMappings = null, Object.defineProperty(a2.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function() {
          return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
        } }), a2.prototype.__originalMappings = null, Object.defineProperty(a2.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function() {
          return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
        } }), a2.prototype._charIsMappingSeparator = function(e5, t5) {
          var r4 = e5.charAt(t5);
          return r4 === ";" || r4 === ",";
        }, a2.prototype._parseMappings = function(e5, t5) {
          throw new Error("Subclasses must implement _parseMappings");
        }, a2.GENERATED_ORDER = 1, a2.ORIGINAL_ORDER = 2, a2.GREATEST_LOWER_BOUND = 1, a2.LEAST_UPPER_BOUND = 2, a2.prototype.eachMapping = function(e5, t5, r4) {
          var o3, i3 = t5 || null;
          switch (r4 || a2.GENERATED_ORDER) {
            case a2.GENERATED_ORDER:
              o3 = this._generatedMappings;
              break;
            case a2.ORIGINAL_ORDER:
              o3 = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var s3 = this.sourceRoot;
          o3.map(function(e6) {
            var t6 = e6.source === null ? null : this._sources.at(e6.source);
            return { source: t6 = n2.computeSourceURL(s3, t6, this._sourceMapURL), generatedLine: e6.generatedLine, generatedColumn: e6.generatedColumn, originalLine: e6.originalLine, originalColumn: e6.originalColumn, name: e6.name === null ? null : this._names.at(e6.name) };
          }, this).forEach(e5, i3);
        }, a2.prototype.allGeneratedPositionsFor = function(e5) {
          var t5 = n2.getArg(e5, "line"), r4 = { source: n2.getArg(e5, "source"), originalLine: t5, originalColumn: n2.getArg(e5, "column", 0) };
          if (r4.source = this._findSourceIndex(r4.source), r4.source < 0)
            return [];
          var i3 = [], s3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, o2.LEAST_UPPER_BOUND);
          if (s3 >= 0) {
            var u3 = this._originalMappings[s3];
            if (e5.column === void 0)
              for (var a3 = u3.originalLine; u3 && u3.originalLine === a3; )
                i3.push({ line: n2.getArg(u3, "generatedLine", null), column: n2.getArg(u3, "generatedColumn", null), lastColumn: n2.getArg(u3, "lastGeneratedColumn", null) }), u3 = this._originalMappings[++s3];
            else
              for (var c3 = u3.originalColumn; u3 && u3.originalLine === t5 && u3.originalColumn == c3; )
                i3.push({ line: n2.getArg(u3, "generatedLine", null), column: n2.getArg(u3, "generatedColumn", null), lastColumn: n2.getArg(u3, "lastGeneratedColumn", null) }), u3 = this._originalMappings[++s3];
          }
          return i3;
        }, t4.SourceMapConsumer = a2, c2.prototype = Object.create(a2.prototype), c2.prototype.consumer = a2, c2.prototype._findSourceIndex = function(e5) {
          var t5, r4 = e5;
          if (this.sourceRoot != null && (r4 = n2.relative(this.sourceRoot, r4)), this._sources.has(r4))
            return this._sources.indexOf(r4);
          for (t5 = 0; t5 < this._absoluteSources.length; ++t5)
            if (this._absoluteSources[t5] == e5)
              return t5;
          return -1;
        }, c2.fromSourceMap = function(e5, t5) {
          var r4 = Object.create(c2.prototype), o3 = r4._names = i2.fromArray(e5._names.toArray(), true), s3 = r4._sources = i2.fromArray(e5._sources.toArray(), true);
          r4.sourceRoot = e5._sourceRoot, r4.sourcesContent = e5._generateSourcesContent(r4._sources.toArray(), r4.sourceRoot), r4.file = e5._file, r4._sourceMapURL = t5, r4._absoluteSources = r4._sources.toArray().map(function(e6) {
            return n2.computeSourceURL(r4.sourceRoot, e6, t5);
          });
          for (var a3 = e5._mappings.toArray().slice(), f3 = r4.__generatedMappings = [], p2 = r4.__originalMappings = [], h2 = 0, d2 = a3.length; h2 < d2; h2++) {
            var D2 = a3[h2], g2 = new l2();
            g2.generatedLine = D2.generatedLine, g2.generatedColumn = D2.generatedColumn, D2.source && (g2.source = s3.indexOf(D2.source), g2.originalLine = D2.originalLine, g2.originalColumn = D2.originalColumn, D2.name && (g2.name = o3.indexOf(D2.name)), p2.push(g2)), f3.push(g2);
          }
          return u2(r4.__originalMappings, n2.compareByOriginalPositions), r4;
        }, c2.prototype._version = 3, Object.defineProperty(c2.prototype, "sources", { get: function() {
          return this._absoluteSources.slice();
        } }), c2.prototype._parseMappings = function(e5, t5) {
          for (var r4, o3, i3, a3, c3, f3 = 1, p2 = 0, h2 = 0, d2 = 0, D2 = 0, g2 = 0, m2 = e5.length, v2 = 0, y2 = {}, w2 = {}, b2 = [], C2 = []; v2 < m2; )
            if (e5.charAt(v2) === ";")
              f3++, v2++, p2 = 0;
            else if (e5.charAt(v2) === ",")
              v2++;
            else {
              for ((r4 = new l2()).generatedLine = f3, a3 = v2; a3 < m2 && !this._charIsMappingSeparator(e5, a3); a3++)
                ;
              if (i3 = y2[o3 = e5.slice(v2, a3)])
                v2 += o3.length;
              else {
                for (i3 = []; v2 < a3; )
                  s2.decode(e5, v2, w2), c3 = w2.value, v2 = w2.rest, i3.push(c3);
                if (i3.length === 2)
                  throw new Error("Found a source, but no line and column");
                if (i3.length === 3)
                  throw new Error("Found a source and line, but no column");
                y2[o3] = i3;
              }
              r4.generatedColumn = p2 + i3[0], p2 = r4.generatedColumn, i3.length > 1 && (r4.source = D2 + i3[1], D2 += i3[1], r4.originalLine = h2 + i3[2], h2 = r4.originalLine, r4.originalLine += 1, r4.originalColumn = d2 + i3[3], d2 = r4.originalColumn, i3.length > 4 && (r4.name = g2 + i3[4], g2 += i3[4])), C2.push(r4), typeof r4.originalLine == "number" && b2.push(r4);
            }
          u2(C2, n2.compareByGeneratedPositionsDeflated), this.__generatedMappings = C2, u2(b2, n2.compareByOriginalPositions), this.__originalMappings = b2;
        }, c2.prototype._findMapping = function(e5, t5, r4, n3, i3, s3) {
          if (e5[r4] <= 0)
            throw new TypeError("Line must be greater than or equal to 1, got " + e5[r4]);
          if (e5[n3] < 0)
            throw new TypeError("Column must be greater than or equal to 0, got " + e5[n3]);
          return o2.search(e5, t5, i3, s3);
        }, c2.prototype.computeColumnSpans = function() {
          for (var e5 = 0; e5 < this._generatedMappings.length; ++e5) {
            var t5 = this._generatedMappings[e5];
            if (e5 + 1 < this._generatedMappings.length) {
              var r4 = this._generatedMappings[e5 + 1];
              if (t5.generatedLine === r4.generatedLine) {
                t5.lastGeneratedColumn = r4.generatedColumn - 1;
                continue;
              }
            }
            t5.lastGeneratedColumn = 1 / 0;
          }
        }, c2.prototype.originalPositionFor = function(e5) {
          var t5 = { generatedLine: n2.getArg(e5, "line"), generatedColumn: n2.getArg(e5, "column") }, r4 = this._findMapping(t5, this._generatedMappings, "generatedLine", "generatedColumn", n2.compareByGeneratedPositionsDeflated, n2.getArg(e5, "bias", a2.GREATEST_LOWER_BOUND));
          if (r4 >= 0) {
            var o3 = this._generatedMappings[r4];
            if (o3.generatedLine === t5.generatedLine) {
              var i3 = n2.getArg(o3, "source", null);
              i3 !== null && (i3 = this._sources.at(i3), i3 = n2.computeSourceURL(this.sourceRoot, i3, this._sourceMapURL));
              var s3 = n2.getArg(o3, "name", null);
              return s3 !== null && (s3 = this._names.at(s3)), { source: i3, line: n2.getArg(o3, "originalLine", null), column: n2.getArg(o3, "originalColumn", null), name: s3 };
            }
          }
          return { source: null, line: null, column: null, name: null };
        }, c2.prototype.hasContentsOfAllSources = function() {
          return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e5) {
            return e5 == null;
          });
        }, c2.prototype.sourceContentFor = function(e5, t5) {
          if (!this.sourcesContent)
            return null;
          var r4 = this._findSourceIndex(e5);
          if (r4 >= 0)
            return this.sourcesContent[r4];
          var o3, i3 = e5;
          if (this.sourceRoot != null && (i3 = n2.relative(this.sourceRoot, i3)), this.sourceRoot != null && (o3 = n2.urlParse(this.sourceRoot))) {
            var s3 = i3.replace(/^file:\/\//, "");
            if (o3.scheme == "file" && this._sources.has(s3))
              return this.sourcesContent[this._sources.indexOf(s3)];
            if ((!o3.path || o3.path == "/") && this._sources.has("/" + i3))
              return this.sourcesContent[this._sources.indexOf("/" + i3)];
          }
          if (t5)
            return null;
          throw new Error('"' + i3 + '" is not in the SourceMap.');
        }, c2.prototype.generatedPositionFor = function(e5) {
          var t5 = n2.getArg(e5, "source");
          if ((t5 = this._findSourceIndex(t5)) < 0)
            return { line: null, column: null, lastColumn: null };
          var r4 = { source: t5, originalLine: n2.getArg(e5, "line"), originalColumn: n2.getArg(e5, "column") }, o3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, n2.getArg(e5, "bias", a2.GREATEST_LOWER_BOUND));
          if (o3 >= 0) {
            var i3 = this._originalMappings[o3];
            if (i3.source === r4.source)
              return { line: n2.getArg(i3, "generatedLine", null), column: n2.getArg(i3, "generatedColumn", null), lastColumn: n2.getArg(i3, "lastGeneratedColumn", null) };
          }
          return { line: null, column: null, lastColumn: null };
        }, f2.prototype = Object.create(a2.prototype), f2.prototype.constructor = a2, f2.prototype._version = 3, Object.defineProperty(f2.prototype, "sources", { get: function() {
          for (var e5 = [], t5 = 0; t5 < this._sections.length; t5++)
            for (var r4 = 0; r4 < this._sections[t5].consumer.sources.length; r4++)
              e5.push(this._sections[t5].consumer.sources[r4]);
          return e5;
        } }), f2.prototype.originalPositionFor = function(e5) {
          var t5 = { generatedLine: n2.getArg(e5, "line"), generatedColumn: n2.getArg(e5, "column") }, r4 = o2.search(t5, this._sections, function(e6, t6) {
            return e6.generatedLine - t6.generatedOffset.generatedLine || e6.generatedColumn - t6.generatedOffset.generatedColumn;
          }), i3 = this._sections[r4];
          return i3 ? i3.consumer.originalPositionFor({ line: t5.generatedLine - (i3.generatedOffset.generatedLine - 1), column: t5.generatedColumn - (i3.generatedOffset.generatedLine === t5.generatedLine ? i3.generatedOffset.generatedColumn - 1 : 0), bias: e5.bias }) : { source: null, line: null, column: null, name: null };
        }, f2.prototype.hasContentsOfAllSources = function() {
          return this._sections.every(function(e5) {
            return e5.consumer.hasContentsOfAllSources();
          });
        }, f2.prototype.sourceContentFor = function(e5, t5) {
          for (var r4 = 0; r4 < this._sections.length; r4++) {
            var n3 = this._sections[r4].consumer.sourceContentFor(e5, true);
            if (n3)
              return n3;
          }
          if (t5)
            return null;
          throw new Error('"' + e5 + '" is not in the SourceMap.');
        }, f2.prototype.generatedPositionFor = function(e5) {
          for (var t5 = 0; t5 < this._sections.length; t5++) {
            var r4 = this._sections[t5];
            if (r4.consumer._findSourceIndex(n2.getArg(e5, "source")) !== -1) {
              var o3 = r4.consumer.generatedPositionFor(e5);
              if (o3)
                return { line: o3.line + (r4.generatedOffset.generatedLine - 1), column: o3.column + (r4.generatedOffset.generatedLine === o3.line ? r4.generatedOffset.generatedColumn - 1 : 0) };
            }
          }
          return { line: null, column: null };
        }, f2.prototype._parseMappings = function(e5, t5) {
          this.__generatedMappings = [], this.__originalMappings = [];
          for (var r4 = 0; r4 < this._sections.length; r4++)
            for (var o3 = this._sections[r4], i3 = o3.consumer._generatedMappings, s3 = 0; s3 < i3.length; s3++) {
              var a3 = i3[s3], c3 = o3.consumer._sources.at(a3.source);
              c3 = n2.computeSourceURL(o3.consumer.sourceRoot, c3, this._sourceMapURL), this._sources.add(c3), c3 = this._sources.indexOf(c3);
              var l3 = null;
              a3.name && (l3 = o3.consumer._names.at(a3.name), this._names.add(l3), l3 = this._names.indexOf(l3));
              var f3 = { source: c3, generatedLine: a3.generatedLine + (o3.generatedOffset.generatedLine - 1), generatedColumn: a3.generatedColumn + (o3.generatedOffset.generatedLine === a3.generatedLine ? o3.generatedOffset.generatedColumn - 1 : 0), originalLine: a3.originalLine, originalColumn: a3.originalColumn, name: l3 };
              this.__generatedMappings.push(f3), typeof f3.originalLine == "number" && this.__originalMappings.push(f3);
            }
          u2(this.__generatedMappings, n2.compareByGeneratedPositionsDeflated), u2(this.__originalMappings, n2.compareByOriginalPositions);
        };
      }, 2400: (e4, t4, r3) => {
        var n2 = r3(4886), o2 = r3(7837), i2 = r3(6715).I, s2 = r3(1028).H;
        function u2(e5) {
          e5 || (e5 = {}), this._file = o2.getArg(e5, "file", null), this._sourceRoot = o2.getArg(e5, "sourceRoot", null), this._skipValidation = o2.getArg(e5, "skipValidation", false), this._sources = new i2(), this._names = new i2(), this._mappings = new s2(), this._sourcesContents = null;
        }
        u2.prototype._version = 3, u2.fromSourceMap = function(e5) {
          var t5 = e5.sourceRoot, r4 = new u2({ file: e5.file, sourceRoot: t5 });
          return e5.eachMapping(function(e6) {
            var n3 = { generated: { line: e6.generatedLine, column: e6.generatedColumn } };
            e6.source != null && (n3.source = e6.source, t5 != null && (n3.source = o2.relative(t5, n3.source)), n3.original = { line: e6.originalLine, column: e6.originalColumn }, e6.name != null && (n3.name = e6.name)), r4.addMapping(n3);
          }), e5.sources.forEach(function(n3) {
            var i3 = n3;
            t5 !== null && (i3 = o2.relative(t5, n3)), r4._sources.has(i3) || r4._sources.add(i3);
            var s3 = e5.sourceContentFor(n3);
            s3 != null && r4.setSourceContent(n3, s3);
          }), r4;
        }, u2.prototype.addMapping = function(e5) {
          var t5 = o2.getArg(e5, "generated"), r4 = o2.getArg(e5, "original", null), n3 = o2.getArg(e5, "source", null), i3 = o2.getArg(e5, "name", null);
          this._skipValidation || this._validateMapping(t5, r4, n3, i3), n3 != null && (n3 = String(n3), this._sources.has(n3) || this._sources.add(n3)), i3 != null && (i3 = String(i3), this._names.has(i3) || this._names.add(i3)), this._mappings.add({ generatedLine: t5.line, generatedColumn: t5.column, originalLine: r4 != null && r4.line, originalColumn: r4 != null && r4.column, source: n3, name: i3 });
        }, u2.prototype.setSourceContent = function(e5, t5) {
          var r4 = e5;
          this._sourceRoot != null && (r4 = o2.relative(this._sourceRoot, r4)), t5 != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o2.toSetString(r4)] = t5) : this._sourcesContents && (delete this._sourcesContents[o2.toSetString(r4)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
        }, u2.prototype.applySourceMap = function(e5, t5, r4) {
          var n3 = t5;
          if (t5 == null) {
            if (e5.file == null)
              throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
            n3 = e5.file;
          }
          var s3 = this._sourceRoot;
          s3 != null && (n3 = o2.relative(s3, n3));
          var u3 = new i2(), a2 = new i2();
          this._mappings.unsortedForEach(function(t6) {
            if (t6.source === n3 && t6.originalLine != null) {
              var i3 = e5.originalPositionFor({ line: t6.originalLine, column: t6.originalColumn });
              i3.source != null && (t6.source = i3.source, r4 != null && (t6.source = o2.join(r4, t6.source)), s3 != null && (t6.source = o2.relative(s3, t6.source)), t6.originalLine = i3.line, t6.originalColumn = i3.column, i3.name != null && (t6.name = i3.name));
            }
            var c2 = t6.source;
            c2 == null || u3.has(c2) || u3.add(c2);
            var l2 = t6.name;
            l2 == null || a2.has(l2) || a2.add(l2);
          }, this), this._sources = u3, this._names = a2, e5.sources.forEach(function(t6) {
            var n4 = e5.sourceContentFor(t6);
            n4 != null && (r4 != null && (t6 = o2.join(r4, t6)), s3 != null && (t6 = o2.relative(s3, t6)), this.setSourceContent(t6, n4));
          }, this);
        }, u2.prototype._validateMapping = function(e5, t5, r4, n3) {
          if (t5 && typeof t5.line != "number" && typeof t5.column != "number")
            throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
          if ((!(e5 && "line" in e5 && "column" in e5 && e5.line > 0 && e5.column >= 0) || t5 || r4 || n3) && !(e5 && "line" in e5 && "column" in e5 && t5 && "line" in t5 && "column" in t5 && e5.line > 0 && e5.column >= 0 && t5.line > 0 && t5.column >= 0 && r4))
            throw new Error("Invalid mapping: " + JSON.stringify({ generated: e5, source: r4, original: t5, name: n3 }));
        }, u2.prototype._serializeMappings = function() {
          for (var e5, t5, r4, i3, s3 = 0, u3 = 1, a2 = 0, c2 = 0, l2 = 0, f2 = 0, p2 = "", h2 = this._mappings.toArray(), d2 = 0, D2 = h2.length; d2 < D2; d2++) {
            if (e5 = "", (t5 = h2[d2]).generatedLine !== u3)
              for (s3 = 0; t5.generatedLine !== u3; )
                e5 += ";", u3++;
            else if (d2 > 0) {
              if (!o2.compareByGeneratedPositionsInflated(t5, h2[d2 - 1]))
                continue;
              e5 += ",";
            }
            e5 += n2.encode(t5.generatedColumn - s3), s3 = t5.generatedColumn, t5.source != null && (i3 = this._sources.indexOf(t5.source), e5 += n2.encode(i3 - f2), f2 = i3, e5 += n2.encode(t5.originalLine - 1 - c2), c2 = t5.originalLine - 1, e5 += n2.encode(t5.originalColumn - a2), a2 = t5.originalColumn, t5.name != null && (r4 = this._names.indexOf(t5.name), e5 += n2.encode(r4 - l2), l2 = r4)), p2 += e5;
          }
          return p2;
        }, u2.prototype._generateSourcesContent = function(e5, t5) {
          return e5.map(function(e6) {
            if (!this._sourcesContents)
              return null;
            t5 != null && (e6 = o2.relative(t5, e6));
            var r4 = o2.toSetString(e6);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, r4) ? this._sourcesContents[r4] : null;
          }, this);
        }, u2.prototype.toJSON = function() {
          var e5 = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
          return this._file != null && (e5.file = this._file), this._sourceRoot != null && (e5.sourceRoot = this._sourceRoot), this._sourcesContents && (e5.sourcesContent = this._generateSourcesContent(e5.sources, e5.sourceRoot)), e5;
        }, u2.prototype.toString = function() {
          return JSON.stringify(this.toJSON());
        }, t4.SourceMapGenerator = u2;
      }, 6270: (e4, t4, r3) => {
        var n2 = r3(2400).SourceMapGenerator, o2 = r3(7837), i2 = /(\r?\n)/, s2 = "$$$isSourceNode$$$";
        function u2(e5, t5, r4, n3, o3) {
          this.children = [], this.sourceContents = {}, this.line = e5 == null ? null : e5, this.column = t5 == null ? null : t5, this.source = r4 == null ? null : r4, this.name = o3 == null ? null : o3, this[s2] = true, n3 != null && this.add(n3);
        }
        u2.fromStringWithSourceMap = function(e5, t5, r4) {
          var n3 = new u2(), s3 = e5.split(i2), a2 = 0, c2 = function() {
            return e6() + (e6() || "");
            function e6() {
              return a2 < s3.length ? s3[a2++] : void 0;
            }
          }, l2 = 1, f2 = 0, p2 = null;
          return t5.eachMapping(function(e6) {
            if (p2 !== null) {
              if (!(l2 < e6.generatedLine)) {
                var t6 = (r5 = s3[a2] || "").substr(0, e6.generatedColumn - f2);
                return s3[a2] = r5.substr(e6.generatedColumn - f2), f2 = e6.generatedColumn, h2(p2, t6), void (p2 = e6);
              }
              h2(p2, c2()), l2++, f2 = 0;
            }
            for (; l2 < e6.generatedLine; )
              n3.add(c2()), l2++;
            if (f2 < e6.generatedColumn) {
              var r5 = s3[a2] || "";
              n3.add(r5.substr(0, e6.generatedColumn)), s3[a2] = r5.substr(e6.generatedColumn), f2 = e6.generatedColumn;
            }
            p2 = e6;
          }, this), a2 < s3.length && (p2 && h2(p2, c2()), n3.add(s3.splice(a2).join(""))), t5.sources.forEach(function(e6) {
            var i3 = t5.sourceContentFor(e6);
            i3 != null && (r4 != null && (e6 = o2.join(r4, e6)), n3.setSourceContent(e6, i3));
          }), n3;
          function h2(e6, t6) {
            if (e6 === null || e6.source === void 0)
              n3.add(t6);
            else {
              var i3 = r4 ? o2.join(r4, e6.source) : e6.source;
              n3.add(new u2(e6.originalLine, e6.originalColumn, i3, t6, e6.name));
            }
          }
        }, u2.prototype.add = function(e5) {
          if (Array.isArray(e5))
            e5.forEach(function(e6) {
              this.add(e6);
            }, this);
          else {
            if (!e5[s2] && typeof e5 != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e5);
            e5 && this.children.push(e5);
          }
          return this;
        }, u2.prototype.prepend = function(e5) {
          if (Array.isArray(e5))
            for (var t5 = e5.length - 1; t5 >= 0; t5--)
              this.prepend(e5[t5]);
          else {
            if (!e5[s2] && typeof e5 != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e5);
            this.children.unshift(e5);
          }
          return this;
        }, u2.prototype.walk = function(e5) {
          for (var t5, r4 = 0, n3 = this.children.length; r4 < n3; r4++)
            (t5 = this.children[r4])[s2] ? t5.walk(e5) : t5 !== "" && e5(t5, { source: this.source, line: this.line, column: this.column, name: this.name });
        }, u2.prototype.join = function(e5) {
          var t5, r4, n3 = this.children.length;
          if (n3 > 0) {
            for (t5 = [], r4 = 0; r4 < n3 - 1; r4++)
              t5.push(this.children[r4]), t5.push(e5);
            t5.push(this.children[r4]), this.children = t5;
          }
          return this;
        }, u2.prototype.replaceRight = function(e5, t5) {
          var r4 = this.children[this.children.length - 1];
          return r4[s2] ? r4.replaceRight(e5, t5) : typeof r4 == "string" ? this.children[this.children.length - 1] = r4.replace(e5, t5) : this.children.push("".replace(e5, t5)), this;
        }, u2.prototype.setSourceContent = function(e5, t5) {
          this.sourceContents[o2.toSetString(e5)] = t5;
        }, u2.prototype.walkSourceContents = function(e5) {
          for (var t5 = 0, r4 = this.children.length; t5 < r4; t5++)
            this.children[t5][s2] && this.children[t5].walkSourceContents(e5);
          var n3 = Object.keys(this.sourceContents);
          for (t5 = 0, r4 = n3.length; t5 < r4; t5++)
            e5(o2.fromSetString(n3[t5]), this.sourceContents[n3[t5]]);
        }, u2.prototype.toString = function() {
          var e5 = "";
          return this.walk(function(t5) {
            e5 += t5;
          }), e5;
        }, u2.prototype.toStringWithSourceMap = function(e5) {
          var t5 = { code: "", line: 1, column: 0 }, r4 = new n2(e5), o3 = false, i3 = null, s3 = null, u3 = null, a2 = null;
          return this.walk(function(e6, n3) {
            t5.code += e6, n3.source !== null && n3.line !== null && n3.column !== null ? (i3 === n3.source && s3 === n3.line && u3 === n3.column && a2 === n3.name || r4.addMapping({ source: n3.source, original: { line: n3.line, column: n3.column }, generated: { line: t5.line, column: t5.column }, name: n3.name }), i3 = n3.source, s3 = n3.line, u3 = n3.column, a2 = n3.name, o3 = true) : o3 && (r4.addMapping({ generated: { line: t5.line, column: t5.column } }), i3 = null, o3 = false);
            for (var c2 = 0, l2 = e6.length; c2 < l2; c2++)
              e6.charCodeAt(c2) === 10 ? (t5.line++, t5.column = 0, c2 + 1 === l2 ? (i3 = null, o3 = false) : o3 && r4.addMapping({ source: n3.source, original: { line: n3.line, column: n3.column }, generated: { line: t5.line, column: t5.column }, name: n3.name })) : t5.column++;
          }), this.walkSourceContents(function(e6, t6) {
            r4.setSourceContent(e6, t6);
          }), { code: t5.code, map: r4 };
        }, t4.SourceNode = u2;
      }, 7837: (e4, t4) => {
        t4.getArg = function(e5, t5, r4) {
          if (t5 in e5)
            return e5[t5];
          if (arguments.length === 3)
            return r4;
          throw new Error('"' + t5 + '" is a required argument.');
        };
        var r3 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, n2 = /^data:.+\,.+$/;
        function o2(e5) {
          var t5 = e5.match(r3);
          return t5 ? { scheme: t5[1], auth: t5[2], host: t5[3], port: t5[4], path: t5[5] } : null;
        }
        function i2(e5) {
          var t5 = "";
          return e5.scheme && (t5 += e5.scheme + ":"), t5 += "//", e5.auth && (t5 += e5.auth + "@"), e5.host && (t5 += e5.host), e5.port && (t5 += ":" + e5.port), e5.path && (t5 += e5.path), t5;
        }
        function s2(e5) {
          var r4 = e5, n3 = o2(e5);
          if (n3) {
            if (!n3.path)
              return e5;
            r4 = n3.path;
          }
          for (var s3, u3 = t4.isAbsolute(r4), a3 = r4.split(/\/+/), c3 = 0, l3 = a3.length - 1; l3 >= 0; l3--)
            (s3 = a3[l3]) === "." ? a3.splice(l3, 1) : s3 === ".." ? c3++ : c3 > 0 && (s3 === "" ? (a3.splice(l3 + 1, c3), c3 = 0) : (a3.splice(l3, 2), c3--));
          return (r4 = a3.join("/")) === "" && (r4 = u3 ? "/" : "."), n3 ? (n3.path = r4, i2(n3)) : r4;
        }
        function u2(e5, t5) {
          e5 === "" && (e5 = "."), t5 === "" && (t5 = ".");
          var r4 = o2(t5), u3 = o2(e5);
          if (u3 && (e5 = u3.path || "/"), r4 && !r4.scheme)
            return u3 && (r4.scheme = u3.scheme), i2(r4);
          if (r4 || t5.match(n2))
            return t5;
          if (u3 && !u3.host && !u3.path)
            return u3.host = t5, i2(u3);
          var a3 = t5.charAt(0) === "/" ? t5 : s2(e5.replace(/\/+$/, "") + "/" + t5);
          return u3 ? (u3.path = a3, i2(u3)) : a3;
        }
        t4.urlParse = o2, t4.urlGenerate = i2, t4.normalize = s2, t4.join = u2, t4.isAbsolute = function(e5) {
          return e5.charAt(0) === "/" || r3.test(e5);
        }, t4.relative = function(e5, t5) {
          e5 === "" && (e5 = "."), e5 = e5.replace(/\/$/, "");
          for (var r4 = 0; t5.indexOf(e5 + "/") !== 0; ) {
            var n3 = e5.lastIndexOf("/");
            if (n3 < 0)
              return t5;
            if ((e5 = e5.slice(0, n3)).match(/^([^\/]+:\/)?\/*$/))
              return t5;
            ++r4;
          }
          return Array(r4 + 1).join("../") + t5.substr(e5.length + 1);
        };
        var a2 = !("__proto__" in Object.create(null));
        function c2(e5) {
          return e5;
        }
        function l2(e5) {
          if (!e5)
            return false;
          var t5 = e5.length;
          if (t5 < 9)
            return false;
          if (e5.charCodeAt(t5 - 1) !== 95 || e5.charCodeAt(t5 - 2) !== 95 || e5.charCodeAt(t5 - 3) !== 111 || e5.charCodeAt(t5 - 4) !== 116 || e5.charCodeAt(t5 - 5) !== 111 || e5.charCodeAt(t5 - 6) !== 114 || e5.charCodeAt(t5 - 7) !== 112 || e5.charCodeAt(t5 - 8) !== 95 || e5.charCodeAt(t5 - 9) !== 95)
            return false;
          for (var r4 = t5 - 10; r4 >= 0; r4--)
            if (e5.charCodeAt(r4) !== 36)
              return false;
          return true;
        }
        function f2(e5, t5) {
          return e5 === t5 ? 0 : e5 === null ? 1 : t5 === null ? -1 : e5 > t5 ? 1 : -1;
        }
        t4.toSetString = a2 ? c2 : function(e5) {
          return l2(e5) ? "$" + e5 : e5;
        }, t4.fromSetString = a2 ? c2 : function(e5) {
          return l2(e5) ? e5.slice(1) : e5;
        }, t4.compareByOriginalPositions = function(e5, t5, r4) {
          var n3 = f2(e5.source, t5.source);
          return n3 !== 0 || (n3 = e5.originalLine - t5.originalLine) != 0 || (n3 = e5.originalColumn - t5.originalColumn) != 0 || r4 || (n3 = e5.generatedColumn - t5.generatedColumn) != 0 || (n3 = e5.generatedLine - t5.generatedLine) != 0 ? n3 : f2(e5.name, t5.name);
        }, t4.compareByGeneratedPositionsDeflated = function(e5, t5, r4) {
          var n3 = e5.generatedLine - t5.generatedLine;
          return n3 !== 0 || (n3 = e5.generatedColumn - t5.generatedColumn) != 0 || r4 || (n3 = f2(e5.source, t5.source)) !== 0 || (n3 = e5.originalLine - t5.originalLine) != 0 || (n3 = e5.originalColumn - t5.originalColumn) != 0 ? n3 : f2(e5.name, t5.name);
        }, t4.compareByGeneratedPositionsInflated = function(e5, t5) {
          var r4 = e5.generatedLine - t5.generatedLine;
          return r4 !== 0 || (r4 = e5.generatedColumn - t5.generatedColumn) != 0 || (r4 = f2(e5.source, t5.source)) !== 0 || (r4 = e5.originalLine - t5.originalLine) != 0 || (r4 = e5.originalColumn - t5.originalColumn) != 0 ? r4 : f2(e5.name, t5.name);
        }, t4.parseSourceMapInput = function(e5) {
          return JSON.parse(e5.replace(/^\)]}'[^\n]*\n/, ""));
        }, t4.computeSourceURL = function(e5, t5, r4) {
          if (t5 = t5 || "", e5 && (e5[e5.length - 1] !== "/" && t5[0] !== "/" && (e5 += "/"), t5 = e5 + t5), r4) {
            var n3 = o2(r4);
            if (!n3)
              throw new Error("sourceMapURL could not be parsed");
            if (n3.path) {
              var a3 = n3.path.lastIndexOf("/");
              a3 >= 0 && (n3.path = n3.path.substring(0, a3 + 1));
            }
            t5 = u2(i2(n3), t5);
          }
          return s2(t5);
        };
      }, 2447: (e4, t4, r3) => {
        t4.SourceMapGenerator = r3(2400).SourceMapGenerator, t4.SourceMapConsumer = r3(8985).SourceMapConsumer, t4.SourceNode = r3(6270).SourceNode;
      }, 6549: (e4, t4, r3) => {
        const n2 = r3(9992), o2 = r3(8528), i2 = r3(541), s2 = (e5) => {
          if (typeof e5 != "string" || e5.length === 0)
            return 0;
          if ((e5 = n2(e5)).length === 0)
            return 0;
          e5 = e5.replace(i2(), "  ");
          let t5 = 0;
          for (let r4 = 0; r4 < e5.length; r4++) {
            const n3 = e5.codePointAt(r4);
            n3 <= 31 || n3 >= 127 && n3 <= 159 || n3 >= 768 && n3 <= 879 || (n3 > 65535 && r4++, t5 += o2(n3) ? 2 : 1);
          }
          return t5;
        };
        e4.exports = s2, e4.exports.default = s2;
      }, 9992: (e4, t4, r3) => {
        const n2 = r3(2426);
        e4.exports = (e5) => typeof e5 == "string" ? e5.replace(n2(), "") : e5;
      }, 3210: (e4, t4, r3) => {
        r3(4070), e4.exports = function(e5, t5, r4) {
          return e5.length === 0 ? e5 : t5 ? (r4 || e5.sort(t5), function(e6, t6) {
            for (var r5 = 1, n2 = e6.length, o2 = e6[0], i2 = e6[0], s2 = 1; s2 < n2; ++s2)
              if (i2 = o2, t6(o2 = e6[s2], i2)) {
                if (s2 === r5) {
                  r5++;
                  continue;
                }
                e6[r5++] = o2;
              }
            return e6.length = r5, e6;
          }(e5, t5)) : (r4 || e5.sort(), function(e6) {
            for (var t6 = 1, r5 = e6.length, n2 = e6[0], o2 = e6[0], i2 = 1; i2 < r5; ++i2, o2 = n2)
              if (o2 = n2, (n2 = e6[i2]) !== o2) {
                if (i2 === t6) {
                  t6++;
                  continue;
                }
                e6[t6++] = n2;
              }
            return e6.length = t6, e6;
          }(e5));
        };
      }, 7933: (e4) => {
        e4.exports = { guessEndOfLine: function(e5) {
          const t4 = e5.indexOf("\r");
          return t4 >= 0 ? e5.charAt(t4 + 1) === "\n" ? "crlf" : "cr" : "lf";
        }, convertEndOfLineToChars: function(e5) {
          switch (e5) {
            case "cr":
              return "\r";
            case "crlf":
              return "\r\n";
            default:
              return "\n";
          }
        }, countEndOfLineChars: function(e5, t4) {
          let r3;
          if (t4 === "\n")
            r3 = /\n/g;
          else if (t4 === "\r")
            r3 = /\r/g;
          else {
            if (t4 !== "\r\n")
              throw new Error(`Unexpected "eol" ${JSON.stringify(t4)}.`);
            r3 = /\r\n/g;
          }
          const n2 = e5.match(r3);
          return n2 ? n2.length : 0;
        }, normalizeEndOfLine: function(e5) {
          return e5.replace(/\r\n?/g, "\n");
        } };
      }, 47: (e4) => {
        e4.exports = function(e5, t4) {
          const r3 = new SyntaxError(e5 + " (" + t4.start.line + ":" + t4.start.column + ")");
          return r3.loc = t4, r3;
        };
      }, 9428: (e4, t4, r3) => {
        const n2 = r3(6549), o2 = r3(2240), i2 = r3(4652), { getSupportInfo: s2 } = r3(7290), u2 = /[^\x20-\x7F]/;
        function a2(e5) {
          return (t5, r4, n3) => {
            const o3 = n3 && n3.backwards;
            if (r4 === false)
              return false;
            const { length: i3 } = t5;
            let s3 = r4;
            for (; s3 >= 0 && s3 < i3; ) {
              const r5 = t5.charAt(s3);
              if (e5 instanceof RegExp) {
                if (!e5.test(r5))
                  return s3;
              } else if (!e5.includes(r5))
                return s3;
              o3 ? s3-- : s3++;
            }
            return (s3 === -1 || s3 === i3) && s3;
          };
        }
        const c2 = a2(/\s/), l2 = a2(" 	"), f2 = a2(",; 	"), p2 = a2(/[^\n\r]/);
        function h2(e5, t5) {
          if (t5 === false)
            return false;
          if (e5.charAt(t5) === "/" && e5.charAt(t5 + 1) === "*") {
            for (let r4 = t5 + 2; r4 < e5.length; ++r4)
              if (e5.charAt(r4) === "*" && e5.charAt(r4 + 1) === "/")
                return r4 + 2;
          }
          return t5;
        }
        function d2(e5, t5) {
          return t5 !== false && (e5.charAt(t5) === "/" && e5.charAt(t5 + 1) === "/" ? p2(e5, t5) : t5);
        }
        function D2(e5, t5, r4) {
          const n3 = r4 && r4.backwards;
          if (t5 === false)
            return false;
          const o3 = e5.charAt(t5);
          if (n3) {
            if (e5.charAt(t5 - 1) === "\r" && o3 === "\n")
              return t5 - 2;
            if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
              return t5 - 1;
          } else {
            if (o3 === "\r" && e5.charAt(t5 + 1) === "\n")
              return t5 + 2;
            if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
              return t5 + 1;
          }
          return t5;
        }
        function g2(e5, t5, r4 = {}) {
          const n3 = l2(e5, r4.backwards ? t5 - 1 : t5, r4);
          return n3 !== D2(e5, n3, r4);
        }
        function m2(e5, t5) {
          let r4 = null, n3 = t5;
          for (; n3 !== r4; )
            r4 = n3, n3 = f2(e5, n3), n3 = h2(e5, n3), n3 = l2(e5, n3);
          return n3 = d2(e5, n3), n3 = D2(e5, n3), n3 !== false && g2(e5, n3);
        }
        function v2(e5, t5) {
          let r4 = null, n3 = t5;
          for (; n3 !== r4; )
            r4 = n3, n3 = l2(e5, n3), n3 = h2(e5, n3), n3 = d2(e5, n3), n3 = D2(e5, n3);
          return n3;
        }
        function y2(e5, t5, r4) {
          return v2(e5, r4(t5));
        }
        function w2(e5, t5, r4 = 0) {
          let n3 = 0;
          for (let o3 = r4; o3 < e5.length; ++o3)
            e5[o3] === "	" ? n3 = n3 + t5 - n3 % t5 : n3++;
          return n3;
        }
        function b2(e5, t5) {
          const r4 = e5.slice(1, -1), n3 = { quote: '"', regex: /"/g }, o3 = { quote: "'", regex: /'/g }, i3 = t5 === "'" ? o3 : n3, s3 = i3 === o3 ? n3 : o3;
          let u3 = i3.quote;
          return (r4.includes(i3.quote) || r4.includes(s3.quote)) && (u3 = (r4.match(i3.regex) || []).length > (r4.match(s3.regex) || []).length ? s3.quote : i3.quote), u3;
        }
        function C2(e5, t5, r4) {
          const n3 = t5 === '"' ? "'" : '"', o3 = e5.replace(/\\(.)|(["'])/gs, (e6, o4, i3) => o4 === n3 ? o4 : i3 === t5 ? "\\" + i3 : i3 || (r4 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o4) ? o4 : "\\" + o4));
          return t5 + o3 + t5;
        }
        function E2(e5, t5) {
          (e5.comments || (e5.comments = [])).push(t5), t5.printed = false, t5.nodeDescription = function(e6) {
            const t6 = e6.type || e6.kind || "(unknown type)";
            let r4 = String(e6.name || e6.id && (typeof e6.id == "object" ? e6.id.name : e6.id) || e6.key && (typeof e6.key == "object" ? e6.key.name : e6.key) || e6.value && (typeof e6.value == "object" ? "" : String(e6.value)) || e6.operator || "");
            return r4.length > 20 && (r4 = r4.slice(0, 19) + "\u2026"), t6 + (r4 ? " " + r4 : "");
          }(e5);
        }
        e4.exports = { inferParserByLanguage: function(e5, t5) {
          const { languages: r4 } = s2({ plugins: t5.plugins }), n3 = r4.find(({ name: t6 }) => t6.toLowerCase() === e5) || r4.find(({ aliases: t6 }) => Array.isArray(t6) && t6.includes(e5)) || r4.find(({ extensions: t6 }) => Array.isArray(t6) && t6.includes(`.${e5}`));
          return n3 && n3.parsers[0];
        }, getStringWidth: function(e5) {
          return e5 ? u2.test(e5) ? n2(e5) : e5.length : 0;
        }, getMaxContinuousCount: function(e5, t5) {
          const r4 = e5.match(new RegExp(`(${o2(t5)})+`, "g"));
          return r4 === null ? 0 : r4.reduce((e6, r5) => Math.max(e6, r5.length / t5.length), 0);
        }, getMinNotPresentContinuousCount: function(e5, t5) {
          const r4 = e5.match(new RegExp(`(${o2(t5)})+`, "g"));
          if (r4 === null)
            return 0;
          const n3 = new Map();
          let i3 = 0;
          for (const e6 of r4) {
            const r5 = e6.length / t5.length;
            n3.set(r5, true), r5 > i3 && (i3 = r5);
          }
          for (let e6 = 1; e6 < i3; e6++)
            if (!n3.get(e6))
              return e6;
          return i3 + 1;
        }, getPenultimate: (e5) => e5[e5.length - 2], getLast: i2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: v2, getNextNonSpaceNonCommentCharacterIndex: y2, getNextNonSpaceNonCommentCharacter: function(e5, t5, r4) {
          return e5.charAt(y2(e5, t5, r4));
        }, skip: a2, skipWhitespace: c2, skipSpaces: l2, skipToLineEnd: f2, skipEverythingButNewLine: p2, skipInlineComment: h2, skipTrailingComment: d2, skipNewline: D2, isNextLineEmptyAfterIndex: m2, isNextLineEmpty: function(e5, t5, r4) {
          return m2(e5, r4(t5));
        }, isPreviousLineEmpty: function(e5, t5, r4) {
          let n3 = r4(t5) - 1;
          return n3 = l2(e5, n3, { backwards: true }), n3 = D2(e5, n3, { backwards: true }), n3 = l2(e5, n3, { backwards: true }), n3 !== D2(e5, n3, { backwards: true });
        }, hasNewline: g2, hasNewlineInRange: function(e5, t5, r4) {
          for (let n3 = t5; n3 < r4; ++n3)
            if (e5.charAt(n3) === "\n")
              return true;
          return false;
        }, hasSpaces: function(e5, t5, r4 = {}) {
          return l2(e5, r4.backwards ? t5 - 1 : t5, r4) !== t5;
        }, getAlignmentSize: w2, getIndentSize: function(e5, t5) {
          const r4 = e5.lastIndexOf("\n");
          return r4 === -1 ? 0 : w2(e5.slice(r4 + 1).match(/^[\t ]*/)[0], t5);
        }, getPreferredQuote: b2, printString: function(e5, t5) {
          return C2(e5.slice(1, -1), t5.parser === "json" || t5.parser === "json5" && t5.quoteProps === "preserve" && !t5.singleQuote ? '"' : t5.__isInHtmlAttribute ? "'" : b2(e5, t5.singleQuote ? "'" : '"'), !(t5.parser === "css" || t5.parser === "less" || t5.parser === "scss" || t5.__embeddedInHtml));
        }, printNumber: function(e5) {
          return e5.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
        }, makeString: C2, addLeadingComment: function(e5, t5) {
          t5.leading = true, t5.trailing = false, E2(e5, t5);
        }, addDanglingComment: function(e5, t5, r4) {
          t5.leading = false, t5.trailing = false, r4 && (t5.marker = r4), E2(e5, t5);
        }, addTrailingComment: function(e5, t5) {
          t5.leading = false, t5.trailing = true, E2(e5, t5);
        }, isFrontMatterNode: function(e5) {
          return e5 && e5.type === "front-matter";
        }, getShebang: function(e5) {
          if (!e5.startsWith("#!"))
            return "";
          const t5 = e5.indexOf("\n");
          return t5 === -1 ? e5 : e5.slice(0, t5);
        }, isNonEmptyArray: function(e5) {
          return Array.isArray(e5) && e5.length > 0;
        }, createGroupIdMapper: function(e5) {
          const t5 = new WeakMap();
          return function(r4) {
            return t5.has(r4) || t5.set(r4, Symbol(e5)), t5.get(r4);
          };
        } };
      }, 9355: (e4, t4, r3) => {
        const n2 = r3(6920), { getLast: o2, skipEverythingButNewLine: i2 } = r3(9428);
        function s2(e5, t5) {
          return typeof e5.sourceIndex == "number" ? e5.sourceIndex : e5.source ? n2(e5.source.start, t5) - 1 : null;
        }
        function u2(e5, t5) {
          if (e5.type === "css-comment" && e5.inline)
            return i2(t5, e5.source.startOffset);
          const r4 = e5.nodes && o2(e5.nodes);
          return r4 && e5.source && !e5.source.end && (e5 = r4), e5.source && e5.source.end ? n2(e5.source.end, t5) : null;
        }
        function a2(e5, t5, r4) {
          e5.source && (e5.source.startOffset = s2(e5, r4) + t5, e5.source.endOffset = u2(e5, r4) + t5);
          for (const n3 in e5) {
            const o3 = e5[n3];
            n3 !== "source" && o3 && typeof o3 == "object" && a2(o3, t5, r4);
          }
        }
        function c2(e5) {
          let t5 = e5.source.startOffset;
          return typeof e5.prop == "string" && (t5 += e5.prop.length), e5.type === "css-atrule" && typeof e5.name == "string" && (t5 += 1 + e5.name.length + e5.raws.afterName.match(/^\s*:?\s*/)[0].length), e5.type !== "css-atrule" && e5.raws && typeof e5.raws.between == "string" && (t5 += e5.raws.between.length), t5;
        }
        e4.exports = { locStart: function(e5) {
          return e5.source.startOffset;
        }, locEnd: function(e5) {
          return e5.source.endOffset;
        }, calculateLoc: function e5(t5, r4) {
          t5.source && (t5.source.startOffset = s2(t5, r4), t5.source.endOffset = u2(t5, r4));
          for (const n3 in t5) {
            const o3 = t5[n3];
            n3 !== "source" && o3 && typeof o3 == "object" && (o3.type === "value-root" || o3.type === "value-unknown" ? a2(o3, c2(t5), o3.text || o3.value) : e5(o3, r4));
          }
        }, replaceQuotesInInlineComments: function(e5) {
          let t5, r4 = "initial", n3 = "initial", o3 = false;
          const i3 = [];
          for (let s3 = 0; s3 < e5.length; s3++) {
            const u3 = e5[s3];
            switch (r4) {
              case "initial":
                if (u3 === "'") {
                  r4 = "single-quotes";
                  continue;
                }
                if (u3 === '"') {
                  r4 = "double-quotes";
                  continue;
                }
                if ((u3 === "u" || u3 === "U") && e5.slice(s3, s3 + 4).toLowerCase() === "url(") {
                  r4 = "url", s3 += 3;
                  continue;
                }
                if (u3 === "*" && e5[s3 - 1] === "/") {
                  r4 = "comment-block";
                  continue;
                }
                if (u3 === "/" && e5[s3 - 1] === "/") {
                  r4 = "comment-inline", t5 = s3 - 1;
                  continue;
                }
                continue;
              case "single-quotes":
                if (u3 === "'" && e5[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                  return e5;
                continue;
              case "double-quotes":
                if (u3 === '"' && e5[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                  return e5;
                continue;
              case "url":
                if (u3 === ")" && (r4 = "initial"), u3 === "\n" || u3 === "\r")
                  return e5;
                if (u3 === "'") {
                  r4 = "single-quotes", n3 = "url";
                  continue;
                }
                if (u3 === '"') {
                  r4 = "double-quotes", n3 = "url";
                  continue;
                }
                continue;
              case "comment-block":
                u3 === "/" && e5[s3 - 1] === "*" && (r4 = "initial");
                continue;
              case "comment-inline":
                u3 !== '"' && u3 !== "'" && u3 !== "*" || (o3 = true), u3 !== "\n" && u3 !== "\r" || (o3 && i3.push([t5, s3]), r4 = "initial", o3 = false);
                continue;
            }
          }
          for (const [t6, r5] of i3)
            e5 = e5.slice(0, t6) + e5.slice(t6, r5).replace(/["'*]/g, " ") + e5.slice(r5);
          return e5;
        } };
      }, 738: (e4, t4, r3) => {
        const n2 = r3(47), o2 = r3(4652), i2 = r3(5115), { hasPragma: s2 } = r3(8850), { hasSCSSInterpolation: u2, hasStringOrFunction: a2, isLessParser: c2, isSCSS: l2, isSCSSNestedPropertyNode: f2, isSCSSVariable: p2, stringifyNode: h2, isModuleRuleName: d2 } = r3(5244), { locStart: D2, locEnd: g2 } = r3(9355), { calculateLoc: m2, replaceQuotesInInlineComments: v2 } = r3(9355), y2 = (e5) => {
          for (; e5.parent; )
            e5 = e5.parent;
          return e5;
        };
        function w2(e5, t5) {
          const { nodes: r4 } = e5;
          let n3 = { open: null, close: null, groups: [], type: "paren_group" };
          const i3 = [n3], s3 = n3;
          let c3 = { groups: [], type: "comma_group" };
          const f3 = [c3];
          for (let s4 = 0; s4 < r4.length; ++s4) {
            const d3 = r4[s4];
            if (l2(t5.parser, d3.value) && d3.type === "number" && d3.unit === ".." && o2(d3.value) === "." && (d3.value = d3.value.slice(0, -1), d3.unit = "..."), d3.type === "func" && d3.value === "selector" && (d3.group.groups = [A2(y2(e5).text.slice(d3.group.open.sourceIndex + 1, d3.group.close.sourceIndex))]), d3.type === "func" && d3.value === "url") {
              const e6 = d3.group && d3.group.groups || [];
              let t6 = [];
              for (let r5 = 0; r5 < e6.length; r5++) {
                const n4 = e6[r5];
                n4.type === "comma_group" ? t6 = [...t6, ...n4.groups] : t6.push(n4);
              }
              if (u2(t6) || !a2(t6) && !p2(t6[0])) {
                const e7 = h2({ groups: d3.group.groups });
                d3.group.groups = [e7.trim()];
              }
            }
            if (d3.type === "paren" && d3.value === "(")
              n3 = { open: d3, close: null, groups: [], type: "paren_group" }, i3.push(n3), c3 = { groups: [], type: "comma_group" }, f3.push(c3);
            else if (d3.type === "paren" && d3.value === ")") {
              if (c3.groups.length > 0 && n3.groups.push(c3), n3.close = d3, f3.length === 1)
                throw new Error("Unbalanced parenthesis");
              f3.pop(), c3 = o2(f3), c3.groups.push(n3), i3.pop(), n3 = o2(i3);
            } else
              d3.type === "comma" ? (n3.groups.push(c3), c3 = { groups: [], type: "comma_group" }, f3[f3.length - 1] = c3) : c3.groups.push(d3);
          }
          return c3.groups.length > 0 && n3.groups.push(c3), s3;
        }
        function b2(e5) {
          return e5.type !== "paren_group" || e5.open || e5.close || e5.groups.length !== 1 ? e5.type === "comma_group" && e5.groups.length === 1 ? b2(e5.groups[0]) : e5.type === "paren_group" || e5.type === "comma_group" ? Object.assign(Object.assign({}, e5), {}, { groups: e5.groups.map(b2) }) : e5 : b2(e5.groups[0]);
        }
        function C2(e5, t5, r4) {
          if (e5 && typeof e5 == "object") {
            delete e5.parent;
            for (const n3 in e5)
              C2(e5[n3], t5, r4), n3 === "type" && typeof e5[n3] == "string" && (e5[n3].startsWith(t5) || r4 && r4.test(e5[n3]) || (e5[n3] = t5 + e5[n3]));
          }
          return e5;
        }
        function E2(e5) {
          if (e5 && typeof e5 == "object") {
            delete e5.parent;
            for (const t5 in e5)
              E2(e5[t5]);
            Array.isArray(e5) || !e5.value || e5.type || (e5.type = "unknown");
          }
          return e5;
        }
        function F2(e5, t5) {
          if (e5 && typeof e5 == "object") {
            for (const r4 in e5)
              r4 !== "parent" && (F2(e5[r4], t5), r4 === "nodes" && (e5.group = b2(w2(e5, t5)), delete e5[r4]));
            delete e5.parent;
          }
          return e5;
        }
        function x2(e5, t5) {
          const n3 = r3(9962);
          let o3 = null;
          try {
            o3 = n3(e5, { loose: true }).parse();
          } catch (e6) {
            return { type: "value-unknown", value: e5 };
          }
          return o3.text = e5, C2(F2(o3, t5), "value-", /^selector-/);
        }
        function A2(e5) {
          if (/\/\/|\/\*/.test(e5))
            return { type: "selector-unknown", value: e5.trim() };
          const t5 = r3(1264);
          let n3 = null;
          try {
            t5((e6) => {
              n3 = e6;
            }).process(e5);
          } catch (e6) {
            return { type: "selector-unknown", value: e5 };
          }
          return C2(n3, "selector-");
        }
        function k2(e5) {
          const t5 = r3(8322).Z;
          let n3 = null;
          try {
            n3 = t5(e5);
          } catch (e6) {
            return { type: "selector-unknown", value: e5 };
          }
          return C2(E2(n3), "media-");
        }
        const O2 = /(\s*?)(!default).*$/, _2 = /(\s*?)(!global).*$/;
        function S2(e5, t5) {
          if (e5 && typeof e5 == "object") {
            delete e5.parent;
            for (const r5 in e5)
              S2(e5[r5], t5);
            if (!e5.type)
              return e5;
            e5.raws || (e5.raws = {});
            let r4 = "";
            typeof e5.selector == "string" && (r4 = e5.raws.selector ? e5.raws.selector.scss ? e5.raws.selector.scss : e5.raws.selector.raw : e5.selector, e5.raws.between && e5.raws.between.trim().length > 0 && (r4 += e5.raws.between), e5.raws.selector = r4);
            let n3 = "";
            typeof e5.value == "string" && (n3 = e5.raws.value ? e5.raws.value.scss ? e5.raws.value.scss : e5.raws.value.raw : e5.value, n3 = n3.trim(), e5.raws.value = n3);
            let o3 = "";
            if (typeof e5.params == "string" && (o3 = e5.raws.params ? e5.raws.params.scss ? e5.raws.params.scss : e5.raws.params.raw : e5.params, e5.raws.afterName && e5.raws.afterName.trim().length > 0 && (o3 = e5.raws.afterName + o3), e5.raws.between && e5.raws.between.trim().length > 0 && (o3 += e5.raws.between), o3 = o3.trim(), e5.raws.params = o3), r4.trim().length > 0)
              return r4.startsWith("@") && r4.endsWith(":") ? e5 : e5.mixin ? (e5.selector = x2(r4, t5), e5) : (f2(e5) && (e5.isSCSSNesterProperty = true), e5.selector = A2(r4), e5);
            if (n3.length > 0) {
              const r5 = n3.match(O2);
              r5 && (n3 = n3.slice(0, r5.index), e5.scssDefault = true, r5[0].trim() !== "!default" && (e5.raws.scssDefault = r5[0]));
              const o4 = n3.match(_2);
              if (o4 && (n3 = n3.slice(0, o4.index), e5.scssGlobal = true, o4[0].trim() !== "!global" && (e5.raws.scssGlobal = o4[0])), n3.startsWith("progid:"))
                return { type: "value-unknown", value: n3 };
              e5.value = x2(n3, t5);
            }
            if (c2(t5) && e5.type === "css-decl" && n3.startsWith("extend(") && (e5.extend || (e5.extend = e5.raws.between === ":"), e5.extend && !e5.selector && (delete e5.value, e5.selector = A2(n3.slice("extend(".length, -1)))), e5.type === "css-atrule") {
              if (c2(t5)) {
                if (e5.mixin) {
                  const t6 = e5.raws.identifier + e5.name + e5.raws.afterName + e5.raws.params;
                  return e5.selector = A2(t6), delete e5.params, e5;
                }
                if (e5.function)
                  return e5;
              }
              if (t5.parser === "css" && e5.name === "custom-selector") {
                const t6 = e5.params.match(/:--\S+?\s+/)[0].trim();
                return e5.customSelector = t6, e5.selector = A2(e5.params.slice(t6.length).trim()), delete e5.params, e5;
              }
              if (c2(t5)) {
                if (e5.name.includes(":") && !e5.params) {
                  e5.variable = true;
                  const r5 = e5.name.split(":");
                  e5.name = r5[0], e5.value = x2(r5.slice(1).join(":"), t5);
                }
                if (!["page", "nest", "keyframes"].includes(e5.name) && e5.params && e5.params[0] === ":" && (e5.variable = true, e5.value = x2(e5.params.slice(1), t5), e5.raws.afterName += ":"), e5.variable)
                  return delete e5.params, e5;
              }
            }
            if (e5.type === "css-atrule" && o3.length > 0) {
              const { name: r5 } = e5, n4 = e5.name.toLowerCase();
              return r5 === "warn" || r5 === "error" ? (e5.params = { type: "media-unknown", value: o3 }, e5) : r5 === "extend" || r5 === "nest" ? (e5.selector = A2(o3), delete e5.params, e5) : r5 === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(o3) ? e5.params = x2(o3, t5) : (e5.selector = A2(o3), delete e5.params), e5) : d2(n4) ? (e5.import = true, delete e5.filename, e5.params = x2(o3, t5), e5) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(r5) ? (o3 = o3.replace(/(\$\S+?)\s+?\.{3}/, "$1..."), o3 = o3.replace(/^(?!if)(\S+)\s+\(/, "$1("), e5.value = x2(o3, t5), delete e5.params, e5) : ["media", "custom-media"].includes(n4) ? o3.includes("#{") ? { type: "media-unknown", value: o3 } : (e5.params = k2(o3), e5) : (e5.params = o3, e5);
            }
          }
          return e5;
        }
        function T2(e5, t5, r4) {
          const o3 = i2(t5), { frontMatter: s3 } = o3;
          let u3;
          t5 = o3.content;
          try {
            u3 = e5(t5);
          } catch (e6) {
            const { name: t6, reason: r5, line: o4, column: i3 } = e6;
            if (typeof o4 != "number")
              throw e6;
            throw n2(`${t6}: ${r5}`, { start: { line: o4, column: i3 } });
          }
          return u3 = S2(C2(u3, "css-"), r4), m2(u3, t5), s3 && (s3.source = { startOffset: 0, endOffset: s3.raw.length }, u3.nodes.unshift(s3)), u3;
        }
        function I2(e5, t5, n3) {
          const o3 = r3(7371);
          return T2((e6) => o3.parse(v2(e6)), e5, n3);
        }
        function N2(e5, t5, n3) {
          const { parse: o3 } = r3(304);
          return T2(o3, e5, n3);
        }
        const M2 = { astFormat: "postcss", hasPragma: s2, locStart: D2, locEnd: g2 };
        e4.exports = { parsers: { css: Object.assign(Object.assign({}, M2), {}, { parse: function(e5, t5, r4) {
          const n3 = l2(r4.parser, e5) ? [N2, I2] : [I2, N2];
          let o3;
          for (const i3 of n3)
            try {
              return i3(e5, t5, r4);
            } catch (e6) {
              o3 = o3 || e6;
            }
          if (o3)
            throw o3;
        } }), less: Object.assign(Object.assign({}, M2), {}, { parse: I2 }), scss: Object.assign(Object.assign({}, M2), {}, { parse: N2 }) } };
      }, 8850: (e4, t4, r3) => {
        const n2 = r3(3831), o2 = r3(5115);
        e4.exports = { hasPragma: function(e5) {
          return n2.hasPragma(o2(e5).content);
        }, insertPragma: function(e5) {
          const { frontMatter: t5, content: r4 } = o2(e5);
          return (t5 ? t5.raw + "\n\n" : "") + n2.insertPragma(r4);
        } };
      }, 5244: (e4, t4, r3) => {
        const { isNonEmptyArray: n2 } = r3(9428), o2 = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), i2 = new Set(["import", "use", "forward"]);
        function s2(e5, t5) {
          const r4 = Array.isArray(t5) ? t5 : [t5];
          let n3, o3 = -1;
          for (; n3 = e5.getParentNode(++o3); )
            if (r4.includes(n3.type))
              return o3;
          return -1;
        }
        function u2(e5, t5) {
          const r4 = s2(e5, t5);
          return r4 === -1 ? null : e5.getParentNode(r4);
        }
        function a2(e5) {
          return e5.type === "value-operator" && e5.value === "*";
        }
        function c2(e5) {
          return e5.type === "value-operator" && e5.value === "/";
        }
        function l2(e5) {
          return e5.type === "value-operator" && e5.value === "+";
        }
        function f2(e5) {
          return e5.type === "value-operator" && e5.value === "-";
        }
        function p2(e5) {
          return e5.type === "value-operator" && e5.value === "%";
        }
        function h2(e5) {
          return e5.type === "value-comma_group" && e5.groups && e5.groups[1] && e5.groups[1].type === "value-colon";
        }
        function d2(e5) {
          return e5.type === "value-paren_group" && e5.groups && e5.groups[0] && h2(e5.groups[0]);
        }
        function D2(e5) {
          return e5 && e5.type === "value-colon";
        }
        e4.exports = { getAncestorCounter: s2, getAncestorNode: u2, getPropOfDeclNode: function(e5) {
          const t5 = u2(e5, "css-decl");
          return t5 && t5.prop && t5.prop.toLowerCase();
        }, hasSCSSInterpolation: function(e5) {
          if (n2(e5)) {
            for (let t5 = e5.length - 1; t5 > 0; t5--)
              if (e5[t5].type === "word" && e5[t5].value === "{" && e5[t5 - 1].type === "word" && e5[t5 - 1].value.endsWith("#"))
                return true;
          }
          return false;
        }, hasStringOrFunction: function(e5) {
          if (n2(e5)) {
            for (let t5 = 0; t5 < e5.length; t5++)
              if (e5[t5].type === "string" || e5[t5].type === "func")
                return true;
          }
          return false;
        }, maybeToLowerCase: function(e5) {
          return e5.includes("$") || e5.includes("@") || e5.includes("#") || e5.startsWith("%") || e5.startsWith("--") || e5.startsWith(":--") || e5.includes("(") && e5.includes(")") ? e5 : e5.toLowerCase();
        }, insideValueFunctionNode: function(e5, t5) {
          const r4 = u2(e5, "value-func");
          return r4 && r4.value && r4.value.toLowerCase() === t5;
        }, insideICSSRuleNode: function(e5) {
          const t5 = u2(e5, "css-rule");
          return t5 && t5.raws && t5.raws.selector && (t5.raws.selector.startsWith(":import") || t5.raws.selector.startsWith(":export"));
        }, insideAtRuleNode: function(e5, t5) {
          const r4 = Array.isArray(t5) ? t5 : [t5], n3 = u2(e5, "css-atrule");
          return n3 && r4.includes(n3.name.toLowerCase());
        }, insideURLFunctionInImportAtRuleNode: function(e5) {
          const t5 = e5.getValue(), r4 = u2(e5, "css-atrule");
          return r4 && r4.name === "import" && t5.groups[0].value === "url" && t5.groups.length === 2;
        }, isKeyframeAtRuleKeywords: function(e5, t5) {
          const r4 = u2(e5, "css-atrule");
          return r4 && r4.name && r4.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t5.toLowerCase());
        }, isWideKeywords: function(e5) {
          return ["initial", "inherit", "unset", "revert"].includes(e5.toLowerCase());
        }, isSCSS: function(e5, t5) {
          return e5 === "less" || e5 === "scss" ? e5 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t5);
        }, isSCSSVariable: function(e5) {
          return Boolean(e5 && e5.type === "word" && e5.value.startsWith("$"));
        }, isLastNode: function(e5, t5) {
          const r4 = e5.getParentNode();
          if (!r4)
            return false;
          const { nodes: n3 } = r4;
          return n3 && n3.indexOf(t5) === n3.length - 1;
        }, isLessParser: function(e5) {
          return e5.parser === "css" || e5.parser === "less";
        }, isSCSSControlDirectiveNode: function(e5) {
          return e5.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e5.name);
        }, isDetachedRulesetDeclarationNode: function(e5) {
          return !!e5.selector && (typeof e5.selector == "string" && /^@.+:.*$/.test(e5.selector) || e5.selector.value && /^@.+:.*$/.test(e5.selector.value));
        }, isRelationalOperatorNode: function(e5) {
          return e5.type === "value-word" && ["<", ">", "<=", ">="].includes(e5.value);
        }, isEqualityOperatorNode: function(e5) {
          return e5.type === "value-word" && ["==", "!="].includes(e5.value);
        }, isMultiplicationNode: a2, isDivisionNode: c2, isAdditionNode: l2, isSubtractionNode: f2, isModuloNode: p2, isMathOperatorNode: function(e5) {
          return a2(e5) || c2(e5) || l2(e5) || f2(e5) || p2(e5);
        }, isEachKeywordNode: function(e5) {
          return e5.type === "value-word" && e5.value === "in";
        }, isForKeywordNode: function(e5) {
          return e5.type === "value-word" && ["from", "through", "end"].includes(e5.value);
        }, isURLFunctionNode: function(e5) {
          return e5.type === "value-func" && e5.value.toLowerCase() === "url";
        }, isIfElseKeywordNode: function(e5) {
          return e5.type === "value-word" && ["and", "or", "not"].includes(e5.value);
        }, hasComposesNode: function(e5) {
          return e5.value && e5.value.type === "value-root" && e5.value.group && e5.value.group.type === "value-value" && e5.prop.toLowerCase() === "composes";
        }, hasParensAroundNode: function(e5) {
          return e5.value && e5.value.group && e5.value.group.group && e5.value.group.group.type === "value-paren_group" && e5.value.group.group.open !== null && e5.value.group.group.close !== null;
        }, hasEmptyRawBefore: function(e5) {
          return e5.raws && e5.raws.before === "";
        }, isSCSSNestedPropertyNode: function(e5) {
          return !!e5.selector && e5.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
        }, isDetachedRulesetCallNode: function(e5) {
          return e5.raws && e5.raws.params && /^\(\s*\)$/.test(e5.raws.params);
        }, isTemplatePlaceholderNode: function(e5) {
          return e5.name.startsWith("prettier-placeholder");
        }, isTemplatePropNode: function(e5) {
          return e5.prop.startsWith("@prettier-placeholder");
        }, isPostcssSimpleVarNode: function(e5, t5) {
          return e5.value === "$$" && e5.type === "value-func" && t5 && t5.type === "value-word" && !t5.raws.before;
        }, isKeyValuePairNode: h2, isKeyValuePairInParenGroupNode: d2, isKeyInValuePairNode: function(e5, t5) {
          if (!h2(t5))
            return false;
          const { groups: r4 } = t5, n3 = r4.indexOf(e5);
          return n3 !== -1 && D2(r4[n3 + 1]);
        }, isSCSSMapItemNode: function(e5) {
          const t5 = e5.getValue();
          if (t5.groups.length === 0)
            return false;
          const r4 = e5.getParentNode(1);
          if (!(d2(t5) || r4 && d2(r4)))
            return false;
          const n3 = u2(e5, "css-decl");
          return !!(n3 && n3.prop && n3.prop.startsWith("$")) || !!d2(r4) || r4.type === "value-func";
        }, isInlineValueCommentNode: function(e5) {
          return e5.type === "value-comment" && e5.inline;
        }, isHashNode: function(e5) {
          return e5.type === "value-word" && e5.value === "#";
        }, isLeftCurlyBraceNode: function(e5) {
          return e5.type === "value-word" && e5.value === "{";
        }, isRightCurlyBraceNode: function(e5) {
          return e5.type === "value-word" && e5.value === "}";
        }, isWordNode: function(e5) {
          return ["value-word", "value-atword"].includes(e5.type);
        }, isColonNode: D2, isMediaAndSupportsKeywords: function(e5) {
          return e5.value && ["not", "and", "or"].includes(e5.value.toLowerCase());
        }, isColorAdjusterFuncNode: function(e5) {
          return e5.type === "value-func" && o2.has(e5.value.toLowerCase());
        }, lastLineHasInlineComment: function(e5) {
          return /\/\//.test(e5.split(/[\n\r]/).pop());
        }, stringifyNode: function e5(t5) {
          if (t5.groups)
            return (t5.open && t5.open.value ? t5.open.value : "") + t5.groups.reduce((r5, n4, o3) => r5 + e5(n4) + (t5.groups[0].type === "comma_group" && o3 !== t5.groups.length - 1 ? "," : ""), "") + (t5.close && t5.close.value ? t5.close.value : "");
          const r4 = t5.raws && t5.raws.before ? t5.raws.before : "", n3 = t5.raws && t5.raws.quote ? t5.raws.quote : "";
          return r4 + n3 + (t5.type === "atword" ? "@" : "") + (t5.value ? t5.value : "") + n3 + (t5.unit ? t5.unit : "") + (t5.group ? e5(t5.group) : "") + (t5.raws && t5.raws.after ? t5.raws.after : "");
        }, isAtWordPlaceholderNode: function(e5) {
          return e5 && e5.type === "value-atword" && e5.value.startsWith("prettier-placeholder-");
        }, isModuleRuleName: function(e5) {
          return i2.has(e5);
        } };
      }, 3831: (e4, t4, r3) => {
        const { parseWithComments: n2, strip: o2, extract: i2, print: s2 } = r3(9234), { getShebang: u2 } = r3(9428), { normalizeEndOfLine: a2 } = r3(7933);
        function c2(e5) {
          const t5 = u2(e5);
          t5 && (e5 = e5.slice(t5.length + 1));
          const r4 = i2(e5), { pragmas: o3, comments: s3 } = n2(r4);
          return { shebang: t5, text: e5, pragmas: o3, comments: s3 };
        }
        e4.exports = { hasPragma: function(e5) {
          const t5 = Object.keys(c2(e5).pragmas);
          return t5.includes("prettier") || t5.includes("format");
        }, insertPragma: function(e5) {
          const { shebang: t5, text: r4, pragmas: n3, comments: i3 } = c2(e5), u3 = o2(r4), l2 = s2({ pragmas: Object.assign({ format: "" }, n3), comments: i3.trimStart() });
          return (t5 ? `${t5}
` : "") + a2(l2) + (u3.startsWith("\n") ? "\n" : "\n\n") + u3;
        } };
      }, 8988: (e4, t4, r3) => {
        const { outdent: n2 } = r3(5311), o2 = "Config", i2 = "Editor", s2 = "Other", u2 = "Global", a2 = "Special", c2 = { cursorOffset: { since: "1.4.0", category: a2, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: n2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: i2 }, endOfLine: { since: "1.15.0", category: u2, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: n2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: a2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: s2, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: a2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: s2 }, parser: { since: "0.0.10", category: u2, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e5) => typeof e5 == "string" || typeof e5 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: u2, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e5) => typeof e5 == "string" || typeof e5 == "object", cliName: "plugin", cliCategory: o2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: u2, description: n2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e5) => typeof e5 == "string" || typeof e5 == "object", cliName: "plugin-search-dir", cliCategory: o2 }, printWidth: { since: "0.0.0", category: u2, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: a2, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: n2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: i2 }, rangeStart: { since: "1.4.0", category: a2, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: n2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: i2 }, requirePragma: { since: "1.7.0", category: a2, type: "boolean", default: false, description: n2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: s2 }, tabWidth: { type: "int", category: u2, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: u2, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: u2, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
        e4.exports = { CATEGORY_CONFIG: o2, CATEGORY_EDITOR: i2, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: s2, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: u2, CATEGORY_SPECIAL: a2, options: c2 };
      }, 7290: (e4, t4, r3) => {
        const n2 = ["cliName", "cliCategory", "cliDescription"];
        function o2(e5, t5) {
          if (e5 == null)
            return {};
          var r4, n3, o3 = function(e6, t6) {
            if (e6 == null)
              return {};
            var r5, n4, o4 = {}, i4 = Object.keys(e6);
            for (n4 = 0; n4 < i4.length; n4++)
              r5 = i4[n4], t6.indexOf(r5) >= 0 || (o4[r5] = e6[r5]);
            return o4;
          }(e5, t5);
          if (Object.getOwnPropertySymbols) {
            var i3 = Object.getOwnPropertySymbols(e5);
            for (n3 = 0; n3 < i3.length; n3++)
              r4 = i3[n3], t5.indexOf(r4) >= 0 || Object.prototype.propertyIsEnumerable.call(e5, r4) && (o3[r4] = e5[r4]);
          }
          return o3;
        }
        r3(4304), r3(4070), r3(2612);
        const i2 = { compare: r3(2828), lt: r3(3725), gte: r3(9195) }, s2 = r3(9077), u2 = r3(4147).i8, a2 = r3(8988).options;
        e4.exports = { getSupportInfo: function({ plugins: e5 = [], showUnreleased: t5 = false, showDeprecated: r4 = false, showInternal: c2 = false } = {}) {
          const l2 = u2.split("-", 1)[0], f2 = e5.flatMap((e6) => e6.languages || []).filter(h2), p2 = s2(Object.assign({}, ...e5.map(({ options: e6 }) => e6), a2), "name").filter((e6) => h2(e6) && d2(e6)).sort((e6, t6) => e6.name === t6.name ? 0 : e6.name < t6.name ? -1 : 1).map(function(e6) {
            return c2 ? e6 : o2(e6, n2);
          }).map((t6) => {
            t6 = Object.assign({}, t6), Array.isArray(t6.default) && (t6.default = t6.default.length === 1 ? t6.default[0].value : t6.default.filter(h2).sort((e6, t7) => i2.compare(t7.since, e6.since))[0].value), Array.isArray(t6.choices) && (t6.choices = t6.choices.filter((e6) => h2(e6) && d2(e6)), t6.name === "parser" && function(e6, t7, r6) {
              const n3 = new Set(e6.choices.map((e7) => e7.value));
              for (const o3 of t7)
                if (o3.parsers) {
                  for (const t8 of o3.parsers)
                    if (!n3.has(t8)) {
                      n3.add(t8);
                      const i3 = r6.find((e7) => e7.parsers && e7.parsers[t8]);
                      let s3 = o3.name;
                      i3 && i3.name && (s3 += ` (plugin: ${i3.name})`), e6.choices.push({ value: t8, description: s3 });
                    }
                }
            }(t6, f2, e5));
            const r5 = Object.fromEntries(e5.filter((e6) => e6.defaultOptions && e6.defaultOptions[t6.name] !== void 0).map((e6) => [e6.name, e6.defaultOptions[t6.name]]));
            return Object.assign(Object.assign({}, t6), {}, { pluginDefaults: r5 });
          });
          return { languages: f2, options: p2 };
          function h2(e6) {
            return t5 || !("since" in e6) || e6.since && i2.gte(l2, e6.since);
          }
          function d2(e6) {
            return r4 || !("deprecated" in e6) || e6.deprecated && i2.lt(l2, e6.deprecated);
          }
        } };
      }, 9077: (e4) => {
        e4.exports = (e5, t4) => Object.entries(e5).map(([e6, r3]) => Object.assign({ [t4]: e6 }, r3));
      }, 5115: (e4) => {
        const t4 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
        e4.exports = function(e5) {
          const r3 = e5.match(t4);
          if (!r3)
            return { content: e5 };
          const { startDelimiter: n2, language: o2, value: i2 = "", endDelimiter: s2 } = r3.groups;
          let u2 = o2.trim() || "yaml";
          if (n2 === "+++" && (u2 = "toml"), u2 !== "yaml" && n2 !== s2)
            return { content: e5 };
          const [a2] = r3;
          return { frontMatter: { type: "front-matter", lang: u2, value: i2, startDelimiter: n2, endDelimiter: s2, raw: a2.replace(/\n$/, "") }, content: a2.replace(/[^\n]/g, " ") + e5.slice(a2.length) };
        };
      }, 4652: (e4) => {
        e4.exports = (e5) => e5[e5.length - 1];
      }, 6920: (e4) => {
        e4.exports = function(e5, t4) {
          let r3 = 0;
          for (let n2 = 0; n2 < e5.line - 1; ++n2)
            r3 = t4.indexOf("\n", r3) + 1;
          return r3 + e5.column;
        };
      }, 8472: () => {
      }, 2868: () => {
      }, 3248: () => {
      }, 6083: () => {
      }, 4940: (e4, t4, r3) => {
        r3.r(t4), r3.d(t4, { existsSync: () => n2, readFileSync: () => o2, default: () => i2 });
        const n2 = () => false, o2 = () => "", i2 = { existsSync: n2, readFileSync: o2 };
      }, 4372: (e4, t4, r3) => {
        r3.r(t4), r3.d(t4, { default: () => n2 });
        const n2 = { EOL: "\n", platform: () => "browser", cpus: () => [{ model: "Prettier" }] };
      }, 3974: (e4, t4, r3) => {
        r3.r(t4), r3.d(t4, { default: () => n2 });
        var n2 = r3(5724), o2 = {};
        for (const e5 in n2)
          e5 !== "default" && (o2[e5] = () => n2[e5]);
        r3.d(t4, o2);
      }, 4147: (e4) => {
        e4.exports = { i8: "2.4.1" };
      } }, t3 = {};
      function r2(n2) {
        var o2 = t3[n2];
        if (o2 !== void 0)
          return o2.exports;
        var i2 = t3[n2] = { id: n2, loaded: false, exports: {} };
        return e3[n2](i2, i2.exports, r2), i2.loaded = true, i2.exports;
      }
      return r2.d = (e4, t4) => {
        for (var n2 in t4)
          r2.o(t4, n2) && !r2.o(e4, n2) && Object.defineProperty(e4, n2, { enumerable: true, get: t4[n2] });
      }, r2.g = function() {
        if (typeof globalThis == "object")
          return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e4) {
          if (typeof window == "object")
            return window;
        }
      }(), r2.hmd = (e4) => ((e4 = Object.create(e4)).children || (e4.children = []), Object.defineProperty(e4, "exports", { enumerable: true, set: () => {
        throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + e4.id);
      } }), e4), r2.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), r2.r = (e4) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
      }, r2(738);
    })();
  }));
  var standalone$1 = { exports: {} };
  var standalone = { exports: {} };
  (function(module, exports) {
    !function(e2, t2) {
      module.exports = t2();
    }(commonjsGlobal, function() {
      var e2 = { version: "2.4.1" }, t2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
      function n2(e3) {
        return e3 && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
      }
      function r2(e3) {
        var t3 = { exports: {} };
        return e3(t3, t3.exports), t3.exports;
      }
      var i2 = r2(function(e3, t3) {
        function n3() {
        }
        function r3(e4, t4, n4, r4, i4) {
          for (var u3 = 0, o3 = t4.length, s3 = 0, a3 = 0; u3 < o3; u3++) {
            var c3 = t4[u3];
            if (c3.removed) {
              if (c3.value = e4.join(r4.slice(a3, a3 + c3.count)), a3 += c3.count, u3 && t4[u3 - 1].added) {
                var l3 = t4[u3 - 1];
                t4[u3 - 1] = t4[u3], t4[u3] = l3;
              }
            } else {
              if (!c3.added && i4) {
                var p3 = n4.slice(s3, s3 + c3.count);
                p3 = p3.map(function(e5, t5) {
                  var n5 = r4[a3 + t5];
                  return n5.length > e5.length ? n5 : e5;
                }), c3.value = e4.join(p3);
              } else
                c3.value = e4.join(n4.slice(s3, s3 + c3.count));
              s3 += c3.count, c3.added || (a3 += c3.count);
            }
          }
          var f3 = t4[o3 - 1];
          return o3 > 1 && typeof f3.value == "string" && (f3.added || f3.removed) && e4.equals("", f3.value) && (t4[o3 - 2].value += f3.value, t4.pop()), t4;
        }
        function i3(e4) {
          return { newPos: e4.newPos, components: e4.components.slice(0) };
        }
        Object.defineProperty(t3, "__esModule", { value: true }), t3.default = n3, n3.prototype = { diff: function(e4, t4) {
          var n4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u3 = n4.callback;
          typeof n4 == "function" && (u3 = n4, n4 = {}), this.options = n4;
          var o3 = this;
          function s3(e5) {
            return u3 ? (setTimeout(function() {
              u3(void 0, e5);
            }, 0), true) : e5;
          }
          e4 = this.castInput(e4), t4 = this.castInput(t4), e4 = this.removeEmpty(this.tokenize(e4));
          var a3 = (t4 = this.removeEmpty(this.tokenize(t4))).length, c3 = e4.length, l3 = 1, p3 = a3 + c3, f3 = [{ newPos: -1, components: [] }], d3 = this.extractCommon(f3[0], t4, e4, 0);
          if (f3[0].newPos + 1 >= a3 && d3 + 1 >= c3)
            return s3([{ value: this.join(t4), count: t4.length }]);
          function h3() {
            for (var n5 = -1 * l3; n5 <= l3; n5 += 2) {
              var u4 = void 0, p4 = f3[n5 - 1], d4 = f3[n5 + 1], h4 = (d4 ? d4.newPos : 0) - n5;
              p4 && (f3[n5 - 1] = void 0);
              var g4 = p4 && p4.newPos + 1 < a3, m3 = d4 && 0 <= h4 && h4 < c3;
              if (g4 || m3) {
                if (!g4 || m3 && p4.newPos < d4.newPos ? (u4 = i3(d4), o3.pushComponent(u4.components, void 0, true)) : ((u4 = p4).newPos++, o3.pushComponent(u4.components, true, void 0)), h4 = o3.extractCommon(u4, t4, e4, n5), u4.newPos + 1 >= a3 && h4 + 1 >= c3)
                  return s3(r3(o3, u4.components, t4, e4, o3.useLongestToken));
                f3[n5] = u4;
              } else
                f3[n5] = void 0;
            }
            l3++;
          }
          if (u3)
            !function e5() {
              setTimeout(function() {
                if (l3 > p3)
                  return u3();
                h3() || e5();
              }, 0);
            }();
          else
            for (; l3 <= p3; ) {
              var g3 = h3();
              if (g3)
                return g3;
            }
        }, pushComponent: function(e4, t4, n4) {
          var r4 = e4[e4.length - 1];
          r4 && r4.added === t4 && r4.removed === n4 ? e4[e4.length - 1] = { count: r4.count + 1, added: t4, removed: n4 } : e4.push({ count: 1, added: t4, removed: n4 });
        }, extractCommon: function(e4, t4, n4, r4) {
          for (var i4 = t4.length, u3 = n4.length, o3 = e4.newPos, s3 = o3 - r4, a3 = 0; o3 + 1 < i4 && s3 + 1 < u3 && this.equals(t4[o3 + 1], n4[s3 + 1]); )
            o3++, s3++, a3++;
          return a3 && e4.components.push({ count: a3 }), e4.newPos = o3, s3;
        }, equals: function(e4, t4) {
          return this.options.comparator ? this.options.comparator(e4, t4) : e4 === t4 || this.options.ignoreCase && e4.toLowerCase() === t4.toLowerCase();
        }, removeEmpty: function(e4) {
          for (var t4 = [], n4 = 0; n4 < e4.length; n4++)
            e4[n4] && t4.push(e4[n4]);
          return t4;
        }, castInput: function(e4) {
          return e4;
        }, tokenize: function(e4) {
          return e4.split("");
        }, join: function(e4) {
          return e4.join("");
        } };
      }), u2 = r2(function(e3, t3) {
        var n3;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.diffChars = function(e4, t4, n4) {
          return r3.diff(e4, t4, n4);
        }, t3.characterDiff = void 0;
        var r3 = new ((n3 = i2) && n3.__esModule ? n3 : { default: n3 }).default();
        t3.characterDiff = r3;
      }), o2 = function(e3, t3) {
        if (typeof e3 == "function")
          t3.callback = e3;
        else if (e3)
          for (var n3 in e3)
            e3.hasOwnProperty(n3) && (t3[n3] = e3[n3]);
        return t3;
      };
      var s2, a2, c2 = Object.defineProperty({ generateOptions: o2 }, "__esModule", { value: true }), l2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.diffWords = function(e4, t4, n4) {
          return n4 = (0, c2.generateOptions)(n4, { ignoreWhitespace: true }), s3.diff(e4, t4, n4);
        }, t3.diffWordsWithSpace = function(e4, t4, n4) {
          return s3.diff(e4, t4, n4);
        }, t3.wordDiff = void 0;
        var n3, r3 = (n3 = i2) && n3.__esModule ? n3 : { default: n3 };
        var u3 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, o3 = /\S/, s3 = new r3.default();
        t3.wordDiff = s3, s3.equals = function(e4, t4) {
          return this.options.ignoreCase && (e4 = e4.toLowerCase(), t4 = t4.toLowerCase()), e4 === t4 || this.options.ignoreWhitespace && !o3.test(e4) && !o3.test(t4);
        }, s3.tokenize = function(e4) {
          for (var t4 = e4.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n4 = 0; n4 < t4.length - 1; n4++)
            !t4[n4 + 1] && t4[n4 + 2] && u3.test(t4[n4]) && u3.test(t4[n4 + 2]) && (t4[n4] += t4[n4 + 2], t4.splice(n4 + 1, 2), n4--);
          return t4;
        };
      }), p2 = r2(function(e3, t3) {
        var n3;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.diffLines = function(e4, t4, n4) {
          return r3.diff(e4, t4, n4);
        }, t3.diffTrimmedLines = function(e4, t4, n4) {
          var i3 = (0, c2.generateOptions)(n4, { ignoreWhitespace: true });
          return r3.diff(e4, t4, i3);
        }, t3.lineDiff = void 0;
        var r3 = new ((n3 = i2) && n3.__esModule ? n3 : { default: n3 }).default();
        t3.lineDiff = r3, r3.tokenize = function(e4) {
          var t4 = [], n4 = e4.split(/(\n|\r\n)/);
          n4[n4.length - 1] || n4.pop();
          for (var r4 = 0; r4 < n4.length; r4++) {
            var i3 = n4[r4];
            r4 % 2 && !this.options.newlineIsToken ? t4[t4.length - 1] += i3 : (this.options.ignoreWhitespace && (i3 = i3.trim()), t4.push(i3));
          }
          return t4;
        };
      }), f2 = r2(function(e3, t3) {
        var n3;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.diffSentences = function(e4, t4, n4) {
          return r3.diff(e4, t4, n4);
        }, t3.sentenceDiff = void 0;
        var r3 = new ((n3 = i2) && n3.__esModule ? n3 : { default: n3 }).default();
        t3.sentenceDiff = r3, r3.tokenize = function(e4) {
          return e4.split(/(\S.+?[.!?])(?=\s+|$)/);
        };
      }), d2 = r2(function(e3, t3) {
        var n3;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.diffCss = function(e4, t4, n4) {
          return r3.diff(e4, t4, n4);
        }, t3.cssDiff = void 0;
        var r3 = new ((n3 = i2) && n3.__esModule ? n3 : { default: n3 }).default();
        t3.cssDiff = r3, r3.tokenize = function(e4) {
          return e4.split(/([{}:;,]|\s+)/);
        };
      }), h2 = function(e3) {
        return e3 && e3.Math == Math && e3;
      }, g2 = h2(typeof globalThis == "object" && globalThis) || h2(typeof window == "object" && window) || h2(typeof self == "object" && self) || h2(typeof t2 == "object" && t2) || function() {
        return this;
      }() || Function("return this")(), m2 = function(e3) {
        try {
          return !!e3();
        } catch (e4) {
          return true;
        }
      }, y2 = !m2(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      }), D2 = {}.propertyIsEnumerable, E2 = Object.getOwnPropertyDescriptor, C2 = { f: E2 && !D2.call({ 1: 2 }, 1) ? function(e3) {
        var t3 = E2(this, e3);
        return !!t3 && t3.enumerable;
      } : D2 }, b2 = function(e3, t3) {
        return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t3 };
      }, A2 = {}.toString, v2 = function(e3) {
        return A2.call(e3).slice(8, -1);
      }, F2 = "".split, x2 = m2(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(e3) {
        return v2(e3) == "String" ? F2.call(e3, "") : Object(e3);
      } : Object, S2 = function(e3) {
        if (e3 == null)
          throw TypeError("Can't call method on " + e3);
        return e3;
      }, w2 = function(e3) {
        return x2(S2(e3));
      }, T2 = function(e3) {
        return typeof e3 == "object" ? e3 !== null : typeof e3 == "function";
      }, B2 = function(e3) {
        return typeof e3 == "function" ? e3 : void 0;
      }, N2 = function(e3, t3) {
        return arguments.length < 2 ? B2(g2[e3]) : g2[e3] && g2[e3][t3];
      }, k2 = N2("navigator", "userAgent") || "", P2 = g2.process, O2 = g2.Deno, I2 = P2 && P2.versions || O2 && O2.version, L2 = I2 && I2.v8;
      L2 ? a2 = (s2 = L2.split("."))[0] < 4 ? 1 : s2[0] + s2[1] : k2 && (!(s2 = k2.match(/Edge\/(\d+)/)) || s2[1] >= 74) && (s2 = k2.match(/Chrome\/(\d+)/)) && (a2 = s2[1]);
      var j2 = a2 && +a2, _2 = !!Object.getOwnPropertySymbols && !m2(function() {
        var e3 = Symbol();
        return !String(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && j2 && j2 < 41;
      }), M2 = _2 && !Symbol.sham && typeof Symbol.iterator == "symbol", R2 = M2 ? function(e3) {
        return typeof e3 == "symbol";
      } : function(e3) {
        var t3 = N2("Symbol");
        return typeof t3 == "function" && Object(e3) instanceof t3;
      }, $2 = function(e3, t3) {
        try {
          Object.defineProperty(g2, e3, { value: t3, configurable: true, writable: true });
        } catch (n3) {
          g2[e3] = t3;
        }
        return t3;
      }, V2 = "__core-js_shared__", W2 = g2[V2] || $2(V2, {}), q2 = r2(function(e3) {
        (e3.exports = function(e4, t3) {
          return W2[e4] || (W2[e4] = t3 !== void 0 ? t3 : {});
        })("versions", []).push({ version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
      }), U2 = function(e3) {
        return Object(S2(e3));
      }, z2 = {}.hasOwnProperty, G2 = Object.hasOwn || function(e3, t3) {
        return z2.call(U2(e3), t3);
      }, H2 = 0, J2 = Math.random(), X2 = function(e3) {
        return "Symbol(" + String(e3 === void 0 ? "" : e3) + ")_" + (++H2 + J2).toString(36);
      }, Y2 = q2("wks"), K2 = g2.Symbol, Q2 = M2 ? K2 : K2 && K2.withoutSetter || X2, Z2 = function(e3) {
        return G2(Y2, e3) && (_2 || typeof Y2[e3] == "string") || (_2 && G2(K2, e3) ? Y2[e3] = K2[e3] : Y2[e3] = Q2("Symbol." + e3)), Y2[e3];
      }, ee2 = Z2("toPrimitive"), te2 = function(e3, t3) {
        if (!T2(e3) || R2(e3))
          return e3;
        var n3, r3 = e3[ee2];
        if (r3 !== void 0) {
          if (t3 === void 0 && (t3 = "default"), n3 = r3.call(e3, t3), !T2(n3) || R2(n3))
            return n3;
          throw TypeError("Can't convert object to primitive value");
        }
        return t3 === void 0 && (t3 = "number"), function(e4, t4) {
          var n4, r4;
          if (t4 === "string" && typeof (n4 = e4.toString) == "function" && !T2(r4 = n4.call(e4)))
            return r4;
          if (typeof (n4 = e4.valueOf) == "function" && !T2(r4 = n4.call(e4)))
            return r4;
          if (t4 !== "string" && typeof (n4 = e4.toString) == "function" && !T2(r4 = n4.call(e4)))
            return r4;
          throw TypeError("Can't convert object to primitive value");
        }(e3, t3);
      }, ne2 = function(e3) {
        var t3 = te2(e3, "string");
        return R2(t3) ? t3 : String(t3);
      }, re2 = g2.document, ie2 = T2(re2) && T2(re2.createElement), ue2 = !y2 && !m2(function() {
        return Object.defineProperty((e3 = "div", ie2 ? re2.createElement(e3) : {}), "a", { get: function() {
          return 7;
        } }).a != 7;
        var e3;
      }), oe2 = Object.getOwnPropertyDescriptor, se2 = { f: y2 ? oe2 : function(e3, t3) {
        if (e3 = w2(e3), t3 = ne2(t3), ue2)
          try {
            return oe2(e3, t3);
          } catch (e4) {
          }
        if (G2(e3, t3))
          return b2(!C2.f.call(e3, t3), e3[t3]);
      } }, ae2 = function(e3) {
        if (!T2(e3))
          throw TypeError(String(e3) + " is not an object");
        return e3;
      }, ce2 = Object.defineProperty, le2 = { f: y2 ? ce2 : function(e3, t3, n3) {
        if (ae2(e3), t3 = ne2(t3), ae2(n3), ue2)
          try {
            return ce2(e3, t3, n3);
          } catch (e4) {
          }
        if ("get" in n3 || "set" in n3)
          throw TypeError("Accessors not supported");
        return "value" in n3 && (e3[t3] = n3.value), e3;
      } }, pe2 = y2 ? function(e3, t3, n3) {
        return le2.f(e3, t3, b2(1, n3));
      } : function(e3, t3, n3) {
        return e3[t3] = n3, e3;
      }, fe2 = Function.toString;
      typeof W2.inspectSource != "function" && (W2.inspectSource = function(e3) {
        return fe2.call(e3);
      });
      var de2, he2, ge2, me2, ye2 = W2.inspectSource, De2 = g2.WeakMap, Ee2 = typeof De2 == "function" && /native code/.test(ye2(De2)), Ce2 = q2("keys"), be2 = {}, Ae2 = "Object already initialized", ve2 = g2.WeakMap;
      if (Ee2 || W2.state) {
        var Fe2 = W2.state || (W2.state = new ve2()), xe2 = Fe2.get, Se2 = Fe2.has, we2 = Fe2.set;
        de2 = function(e3, t3) {
          if (Se2.call(Fe2, e3))
            throw new TypeError(Ae2);
          return t3.facade = e3, we2.call(Fe2, e3, t3), t3;
        }, he2 = function(e3) {
          return xe2.call(Fe2, e3) || {};
        }, ge2 = function(e3) {
          return Se2.call(Fe2, e3);
        };
      } else {
        var Te2 = Ce2[me2 = "state"] || (Ce2[me2] = X2(me2));
        be2[Te2] = true, de2 = function(e3, t3) {
          if (G2(e3, Te2))
            throw new TypeError(Ae2);
          return t3.facade = e3, pe2(e3, Te2, t3), t3;
        }, he2 = function(e3) {
          return G2(e3, Te2) ? e3[Te2] : {};
        }, ge2 = function(e3) {
          return G2(e3, Te2);
        };
      }
      var Be2, Ne2, ke2 = { set: de2, get: he2, has: ge2, enforce: function(e3) {
        return ge2(e3) ? he2(e3) : de2(e3, {});
      }, getterFor: function(e3) {
        return function(t3) {
          var n3;
          if (!T2(t3) || (n3 = he2(t3)).type !== e3)
            throw TypeError("Incompatible receiver, " + e3 + " required");
          return n3;
        };
      } }, Pe2 = r2(function(e3) {
        var t3 = ke2.get, n3 = ke2.enforce, r3 = String(String).split("String");
        (e3.exports = function(e4, t4, i3, u3) {
          var o3, s3 = !!u3 && !!u3.unsafe, a3 = !!u3 && !!u3.enumerable, c3 = !!u3 && !!u3.noTargetGet;
          typeof i3 == "function" && (typeof t4 != "string" || G2(i3, "name") || pe2(i3, "name", t4), (o3 = n3(i3)).source || (o3.source = r3.join(typeof t4 == "string" ? t4 : ""))), e4 !== g2 ? (s3 ? !c3 && e4[t4] && (a3 = true) : delete e4[t4], a3 ? e4[t4] = i3 : pe2(e4, t4, i3)) : a3 ? e4[t4] = i3 : $2(t4, i3);
        })(Function.prototype, "toString", function() {
          return typeof this == "function" && t3(this).source || ye2(this);
        });
      }), Oe2 = Math.ceil, Ie2 = Math.floor, Le2 = function(e3) {
        return isNaN(e3 = +e3) ? 0 : (e3 > 0 ? Ie2 : Oe2)(e3);
      }, je2 = Math.min, _e2 = function(e3) {
        return e3 > 0 ? je2(Le2(e3), 9007199254740991) : 0;
      }, Me2 = Math.max, Re2 = Math.min, $e2 = function(e3) {
        return function(t3, n3, r3) {
          var i3, u3 = w2(t3), o3 = _e2(u3.length), s3 = function(e4, t4) {
            var n4 = Le2(e4);
            return n4 < 0 ? Me2(n4 + t4, 0) : Re2(n4, t4);
          }(r3, o3);
          if (e3 && n3 != n3) {
            for (; o3 > s3; )
              if ((i3 = u3[s3++]) != i3)
                return true;
          } else
            for (; o3 > s3; s3++)
              if ((e3 || s3 in u3) && u3[s3] === n3)
                return e3 || s3 || 0;
          return !e3 && -1;
        };
      }, Ve2 = { includes: $e2(true), indexOf: $e2(false) }.indexOf, We2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), qe2 = { f: Object.getOwnPropertyNames || function(e3) {
        return function(e4, t3) {
          var n3, r3 = w2(e4), i3 = 0, u3 = [];
          for (n3 in r3)
            !G2(be2, n3) && G2(r3, n3) && u3.push(n3);
          for (; t3.length > i3; )
            G2(r3, n3 = t3[i3++]) && (~Ve2(u3, n3) || u3.push(n3));
          return u3;
        }(e3, We2);
      } }, Ue2 = { f: Object.getOwnPropertySymbols }, ze2 = N2("Reflect", "ownKeys") || function(e3) {
        var t3 = qe2.f(ae2(e3)), n3 = Ue2.f;
        return n3 ? t3.concat(n3(e3)) : t3;
      }, Ge2 = function(e3, t3) {
        for (var n3 = ze2(t3), r3 = le2.f, i3 = se2.f, u3 = 0; u3 < n3.length; u3++) {
          var o3 = n3[u3];
          G2(e3, o3) || r3(e3, o3, i3(t3, o3));
        }
      }, He2 = /#|\.prototype\./, Je2 = function(e3, t3) {
        var n3 = Ye2[Xe2(e3)];
        return n3 == Qe2 || n3 != Ke2 && (typeof t3 == "function" ? m2(t3) : !!t3);
      }, Xe2 = Je2.normalize = function(e3) {
        return String(e3).replace(He2, ".").toLowerCase();
      }, Ye2 = Je2.data = {}, Ke2 = Je2.NATIVE = "N", Qe2 = Je2.POLYFILL = "P", Ze2 = Je2, et2 = se2.f, tt2 = function(e3, t3) {
        var n3, r3, i3, u3, o3, s3 = e3.target, a3 = e3.global, c3 = e3.stat;
        if (n3 = a3 ? g2 : c3 ? g2[s3] || $2(s3, {}) : (g2[s3] || {}).prototype)
          for (r3 in t3) {
            if (u3 = t3[r3], i3 = e3.noTargetGet ? (o3 = et2(n3, r3)) && o3.value : n3[r3], !Ze2(a3 ? r3 : s3 + (c3 ? "." : "#") + r3, e3.forced) && i3 !== void 0) {
              if (typeof u3 == typeof i3)
                continue;
              Ge2(u3, i3);
            }
            (e3.sham || i3 && i3.sham) && pe2(u3, "sham", true), Pe2(n3, r3, u3, e3);
          }
      }, nt2 = function(e3) {
        if (typeof e3 != "function")
          throw TypeError(String(e3) + " is not a function");
        return e3;
      }, rt2 = function(e3) {
        if (R2(e3))
          throw TypeError("Cannot convert a Symbol value to a string");
        return String(e3);
      }, it2 = Math.floor, ut2 = function(e3, t3) {
        var n3 = e3.length, r3 = it2(n3 / 2);
        return n3 < 8 ? ot2(e3, t3) : st2(ut2(e3.slice(0, r3), t3), ut2(e3.slice(r3), t3), t3);
      }, ot2 = function(e3, t3) {
        for (var n3, r3, i3 = e3.length, u3 = 1; u3 < i3; ) {
          for (r3 = u3, n3 = e3[u3]; r3 && t3(e3[r3 - 1], n3) > 0; )
            e3[r3] = e3[--r3];
          r3 !== u3++ && (e3[r3] = n3);
        }
        return e3;
      }, st2 = function(e3, t3, n3) {
        for (var r3 = e3.length, i3 = t3.length, u3 = 0, o3 = 0, s3 = []; u3 < r3 || o3 < i3; )
          u3 < r3 && o3 < i3 ? s3.push(n3(e3[u3], t3[o3]) <= 0 ? e3[u3++] : t3[o3++]) : s3.push(u3 < r3 ? e3[u3++] : t3[o3++]);
        return s3;
      }, at2 = ut2, ct2 = k2.match(/firefox\/(\d+)/i), lt2 = !!ct2 && +ct2[1], pt2 = /MSIE|Trident/.test(k2), ft2 = k2.match(/AppleWebKit\/(\d+)\./), dt2 = !!ft2 && +ft2[1], ht2 = [], gt2 = ht2.sort, mt2 = m2(function() {
        ht2.sort(void 0);
      }), yt2 = m2(function() {
        ht2.sort(null);
      }), Dt2 = !!(Ne2 = []["sort"]) && m2(function() {
        Ne2.call(null, Be2 || function() {
          throw 1;
        }, 1);
      }), Et2 = !m2(function() {
        if (j2)
          return j2 < 70;
        if (!(lt2 && lt2 > 3)) {
          if (pt2)
            return true;
          if (dt2)
            return dt2 < 603;
          var e3, t3, n3, r3, i3 = "";
          for (e3 = 65; e3 < 76; e3++) {
            switch (t3 = String.fromCharCode(e3), e3) {
              case 66:
              case 69:
              case 70:
              case 72:
                n3 = 3;
                break;
              case 68:
              case 71:
                n3 = 4;
                break;
              default:
                n3 = 2;
            }
            for (r3 = 0; r3 < 47; r3++)
              ht2.push({ k: t3 + r3, v: n3 });
          }
          for (ht2.sort(function(e4, t4) {
            return t4.v - e4.v;
          }), r3 = 0; r3 < ht2.length; r3++)
            t3 = ht2[r3].k.charAt(0), i3.charAt(i3.length - 1) !== t3 && (i3 += t3);
          return i3 !== "DGBEFHACIJK";
        }
      });
      tt2({ target: "Array", proto: true, forced: mt2 || !yt2 || !Dt2 || !Et2 }, { sort: function(e3) {
        e3 !== void 0 && nt2(e3);
        var t3 = U2(this);
        if (Et2)
          return e3 === void 0 ? gt2.call(t3) : gt2.call(t3, e3);
        var n3, r3, i3 = [], u3 = _e2(t3.length);
        for (r3 = 0; r3 < u3; r3++)
          r3 in t3 && i3.push(t3[r3]);
        for (n3 = (i3 = at2(i3, function(e4) {
          return function(t4, n4) {
            return n4 === void 0 ? -1 : t4 === void 0 ? 1 : e4 !== void 0 ? +e4(t4, n4) || 0 : rt2(t4) > rt2(n4) ? 1 : -1;
          };
        }(e3))).length, r3 = 0; r3 < n3; )
          t3[r3] = i3[r3++];
        for (; r3 < u3; )
          delete t3[r3++];
        return t3;
      } });
      var Ct2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.diffJson = function(e4, t4, n4) {
          return s3.diff(e4, t4, n4);
        }, t3.canonicalize = a3, t3.jsonDiff = void 0;
        var n3, r3 = (n3 = i2) && n3.__esModule ? n3 : { default: n3 };
        function u3(e4) {
          return (u3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
            return typeof e5;
          } : function(e5) {
            return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
          })(e4);
        }
        var o3 = Object.prototype.toString, s3 = new r3.default();
        function a3(e4, t4, n4, r4, i3) {
          var s4, c3;
          for (t4 = t4 || [], n4 = n4 || [], r4 && (e4 = r4(i3, e4)), s4 = 0; s4 < t4.length; s4 += 1)
            if (t4[s4] === e4)
              return n4[s4];
          if (o3.call(e4) === "[object Array]") {
            for (t4.push(e4), c3 = new Array(e4.length), n4.push(c3), s4 = 0; s4 < e4.length; s4 += 1)
              c3[s4] = a3(e4[s4], t4, n4, r4, i3);
            return t4.pop(), n4.pop(), c3;
          }
          if (e4 && e4.toJSON && (e4 = e4.toJSON()), u3(e4) === "object" && e4 !== null) {
            t4.push(e4), c3 = {}, n4.push(c3);
            var l3, p3 = [];
            for (l3 in e4)
              e4.hasOwnProperty(l3) && p3.push(l3);
            for (p3.sort(), s4 = 0; s4 < p3.length; s4 += 1)
              c3[l3 = p3[s4]] = a3(e4[l3], t4, n4, r4, l3);
            t4.pop(), n4.pop();
          } else
            c3 = e4;
          return c3;
        }
        t3.jsonDiff = s3, s3.useLongestToken = true, s3.tokenize = p2.lineDiff.tokenize, s3.castInput = function(e4) {
          var t4 = this.options, n4 = t4.undefinedReplacement, r4 = t4.stringifyReplacer, i3 = r4 === void 0 ? function(e5, t5) {
            return t5 === void 0 ? n4 : t5;
          } : r4;
          return typeof e4 == "string" ? e4 : JSON.stringify(a3(e4, null, null, i3), i3, "  ");
        }, s3.equals = function(e4, t4) {
          return r3.default.prototype.equals.call(s3, e4.replace(/,([\r\n])/g, "$1"), t4.replace(/,([\r\n])/g, "$1"));
        };
      }), bt2 = r2(function(e3, t3) {
        var n3;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.diffArrays = function(e4, t4, n4) {
          return r3.diff(e4, t4, n4);
        }, t3.arrayDiff = void 0;
        var r3 = new ((n3 = i2) && n3.__esModule ? n3 : { default: n3 }).default();
        t3.arrayDiff = r3, r3.tokenize = function(e4) {
          return e4.slice();
        }, r3.join = r3.removeEmpty = function(e4) {
          return e4;
        };
      }), At2 = function(e3) {
        var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n3 = e3.split(/\r\n|[\n\v\f\r\x85]/), r3 = e3.match(/\r\n|[\n\v\f\r\x85]/g) || [], i3 = [], u3 = 0;
        function o3() {
          var e4 = {};
          for (i3.push(e4); u3 < n3.length; ) {
            var r4 = n3[u3];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(r4))
              break;
            var o4 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r4);
            o4 && (e4.index = o4[1]), u3++;
          }
          for (s3(e4), s3(e4), e4.hunks = []; u3 < n3.length; ) {
            var c3 = n3[u3];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c3))
              break;
            if (/^@@/.test(c3))
              e4.hunks.push(a3());
            else {
              if (c3 && t3.strict)
                throw new Error("Unknown line " + (u3 + 1) + " " + JSON.stringify(c3));
              u3++;
            }
          }
        }
        function s3(e4) {
          var t4 = /^(---|\+\+\+)\s+(.*)$/.exec(n3[u3]);
          if (t4) {
            var r4 = t4[1] === "---" ? "old" : "new", i4 = t4[2].split("	", 2), o4 = i4[0].replace(/\\\\/g, "\\");
            /^".*"$/.test(o4) && (o4 = o4.substr(1, o4.length - 2)), e4[r4 + "FileName"] = o4, e4[r4 + "Header"] = (i4[1] || "").trim(), u3++;
          }
        }
        function a3() {
          var e4 = u3, i4 = n3[u3++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), o4 = { oldStart: +i4[1], oldLines: i4[2] === void 0 ? 1 : +i4[2], newStart: +i4[3], newLines: i4[4] === void 0 ? 1 : +i4[4], lines: [], linedelimiters: [] };
          o4.oldLines === 0 && (o4.oldStart += 1), o4.newLines === 0 && (o4.newStart += 1);
          for (var s4 = 0, a4 = 0; u3 < n3.length && !(n3[u3].indexOf("--- ") === 0 && u3 + 2 < n3.length && n3[u3 + 1].indexOf("+++ ") === 0 && n3[u3 + 2].indexOf("@@") === 0); u3++) {
            var c3 = n3[u3].length == 0 && u3 != n3.length - 1 ? " " : n3[u3][0];
            if (c3 !== "+" && c3 !== "-" && c3 !== " " && c3 !== "\\")
              break;
            o4.lines.push(n3[u3]), o4.linedelimiters.push(r3[u3] || "\n"), c3 === "+" ? s4++ : c3 === "-" ? a4++ : c3 === " " && (s4++, a4++);
          }
          if (s4 || o4.newLines !== 1 || (o4.newLines = 0), a4 || o4.oldLines !== 1 || (o4.oldLines = 0), t3.strict) {
            if (s4 !== o4.newLines)
              throw new Error("Added line count did not match for hunk at line " + (e4 + 1));
            if (a4 !== o4.oldLines)
              throw new Error("Removed line count did not match for hunk at line " + (e4 + 1));
          }
          return o4;
        }
        for (; u3 < n3.length; )
          o3();
        return i3;
      };
      var vt2, Ft2 = Object.defineProperty({ parsePatch: At2 }, "__esModule", { value: true }), xt2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.default = function(e4, t4, n3) {
          var r3 = true, i3 = false, u3 = false, o3 = 1;
          return function s3() {
            if (r3 && !u3) {
              if (i3 ? o3++ : r3 = false, e4 + o3 <= n3)
                return o3;
              u3 = true;
            }
            if (!i3)
              return u3 || (r3 = true), t4 <= e4 - o3 ? -o3++ : (i3 = true, s3());
          };
        };
      }), St2 = Bt2, wt2 = function(e3, t3) {
        typeof e3 == "string" && (e3 = (0, Ft2.parsePatch)(e3));
        var n3 = 0;
        !function r3() {
          var i3 = e3[n3++];
          if (!i3)
            return t3.complete();
          t3.loadFile(i3, function(e4, n4) {
            if (e4)
              return t3.complete(e4);
            var u3 = Bt2(n4, i3, t3);
            t3.patched(i3, u3, function(e5) {
              if (e5)
                return t3.complete(e5);
              r3();
            });
          });
        }();
      }, Tt2 = (vt2 = xt2) && vt2.__esModule ? vt2 : { default: vt2 };
      function Bt2(e3, t3) {
        var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (typeof t3 == "string" && (t3 = (0, Ft2.parsePatch)(t3)), Array.isArray(t3)) {
          if (t3.length > 1)
            throw new Error("applyPatch only works with a single input.");
          t3 = t3[0];
        }
        var r3, i3, u3 = e3.split(/\r\n|[\n\v\f\r\x85]/), o3 = e3.match(/\r\n|[\n\v\f\r\x85]/g) || [], s3 = t3.hunks, a3 = n3.compareLine || function(e4, t4, n4, r4) {
          return t4 === r4;
        }, c3 = 0, l3 = n3.fuzzFactor || 0, p3 = 0, f3 = 0;
        function d3(e4, t4) {
          for (var n4 = 0; n4 < e4.lines.length; n4++) {
            var r4 = e4.lines[n4], i4 = r4.length > 0 ? r4[0] : " ", o4 = r4.length > 0 ? r4.substr(1) : r4;
            if (i4 === " " || i4 === "-") {
              if (!a3(t4 + 1, u3[t4], i4, o4) && ++c3 > l3)
                return false;
              t4++;
            }
          }
          return true;
        }
        for (var h3 = 0; h3 < s3.length; h3++) {
          for (var g3 = s3[h3], m3 = u3.length - g3.oldLines, y3 = 0, D3 = f3 + g3.oldStart - 1, E3 = (0, Tt2.default)(D3, p3, m3); y3 !== void 0; y3 = E3())
            if (d3(g3, D3 + y3)) {
              g3.offset = f3 += y3;
              break;
            }
          if (y3 === void 0)
            return false;
          p3 = g3.offset + g3.oldStart + g3.oldLines;
        }
        for (var C3 = 0, b3 = 0; b3 < s3.length; b3++) {
          var A3 = s3[b3], v3 = A3.oldStart + A3.offset + C3 - 1;
          C3 += A3.newLines - A3.oldLines;
          for (var F3 = 0; F3 < A3.lines.length; F3++) {
            var x3 = A3.lines[F3], S3 = x3.length > 0 ? x3[0] : " ", w3 = x3.length > 0 ? x3.substr(1) : x3, T3 = A3.linedelimiters[F3];
            if (S3 === " ")
              v3++;
            else if (S3 === "-")
              u3.splice(v3, 1), o3.splice(v3, 1);
            else if (S3 === "+")
              u3.splice(v3, 0, w3), o3.splice(v3, 0, T3), v3++;
            else if (S3 === "\\") {
              var B3 = A3.lines[F3 - 1] ? A3.lines[F3 - 1][0] : null;
              B3 === "+" ? r3 = true : B3 === "-" && (i3 = true);
            }
          }
        }
        if (r3)
          for (; !u3[u3.length - 1]; )
            u3.pop(), o3.pop();
        else
          i3 && (u3.push(""), o3.push("\n"));
        for (var N3 = 0; N3 < u3.length - 1; N3++)
          u3[N3] = u3[N3] + o3[N3];
        return u3.join("");
      }
      var Nt2 = Object.defineProperty({ applyPatch: St2, applyPatches: wt2 }, "__esModule", { value: true }), kt2 = _t2, Pt2 = Mt2, Ot2 = Rt2, It2 = function(e3, t3, n3, r3, i3, u3) {
        return Rt2(e3, e3, t3, n3, r3, i3, u3);
      };
      function Lt2(e3) {
        return function(e4) {
          if (Array.isArray(e4))
            return jt2(e4);
        }(e3) || function(e4) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(e4))
            return Array.from(e4);
        }(e3) || function(e4, t3) {
          if (!e4)
            return;
          if (typeof e4 == "string")
            return jt2(e4, t3);
          var n3 = Object.prototype.toString.call(e4).slice(8, -1);
          n3 === "Object" && e4.constructor && (n3 = e4.constructor.name);
          if (n3 === "Map" || n3 === "Set")
            return Array.from(e4);
          if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
            return jt2(e4, t3);
        }(e3) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function jt2(e3, t3) {
        (t3 == null || t3 > e3.length) && (t3 = e3.length);
        for (var n3 = 0, r3 = new Array(t3); n3 < t3; n3++)
          r3[n3] = e3[n3];
        return r3;
      }
      function _t2(e3, t3, n3, r3, i3, u3, o3) {
        o3 || (o3 = {}), o3.context === void 0 && (o3.context = 4);
        var s3 = (0, p2.diffLines)(n3, r3, o3);
        function a3(e4) {
          return e4.map(function(e5) {
            return " " + e5;
          });
        }
        s3.push({ value: "", lines: [] });
        for (var c3 = [], l3 = 0, f3 = 0, d3 = [], h3 = 1, g3 = 1, m3 = function(e4) {
          var t4 = s3[e4], i4 = t4.lines || t4.value.replace(/\n$/, "").split("\n");
          if (t4.lines = i4, t4.added || t4.removed) {
            var u4;
            if (!l3) {
              var p3 = s3[e4 - 1];
              l3 = h3, f3 = g3, p3 && (d3 = o3.context > 0 ? a3(p3.lines.slice(-o3.context)) : [], l3 -= d3.length, f3 -= d3.length);
            }
            (u4 = d3).push.apply(u4, Lt2(i4.map(function(e5) {
              return (t4.added ? "+" : "-") + e5;
            }))), t4.added ? g3 += i4.length : h3 += i4.length;
          } else {
            if (l3)
              if (i4.length <= 2 * o3.context && e4 < s3.length - 2) {
                var m4;
                (m4 = d3).push.apply(m4, Lt2(a3(i4)));
              } else {
                var y4, D3 = Math.min(i4.length, o3.context);
                (y4 = d3).push.apply(y4, Lt2(a3(i4.slice(0, D3))));
                var E3 = { oldStart: l3, oldLines: h3 - l3 + D3, newStart: f3, newLines: g3 - f3 + D3, lines: d3 };
                if (e4 >= s3.length - 2 && i4.length <= o3.context) {
                  var C3 = /\n$/.test(n3), b3 = /\n$/.test(r3), A3 = i4.length == 0 && d3.length > E3.oldLines;
                  !C3 && A3 && n3.length > 0 && d3.splice(E3.oldLines, 0, "\\ No newline at end of file"), (C3 || A3) && b3 || d3.push("\\ No newline at end of file");
                }
                c3.push(E3), l3 = 0, f3 = 0, d3 = [];
              }
            h3 += i4.length, g3 += i4.length;
          }
        }, y3 = 0; y3 < s3.length; y3++)
          m3(y3);
        return { oldFileName: e3, newFileName: t3, oldHeader: i3, newHeader: u3, hunks: c3 };
      }
      function Mt2(e3) {
        var t3 = [];
        e3.oldFileName == e3.newFileName && t3.push("Index: " + e3.oldFileName), t3.push("==================================================================="), t3.push("--- " + e3.oldFileName + (e3.oldHeader === void 0 ? "" : "	" + e3.oldHeader)), t3.push("+++ " + e3.newFileName + (e3.newHeader === void 0 ? "" : "	" + e3.newHeader));
        for (var n3 = 0; n3 < e3.hunks.length; n3++) {
          var r3 = e3.hunks[n3];
          r3.oldLines === 0 && (r3.oldStart -= 1), r3.newLines === 0 && (r3.newStart -= 1), t3.push("@@ -" + r3.oldStart + "," + r3.oldLines + " +" + r3.newStart + "," + r3.newLines + " @@"), t3.push.apply(t3, r3.lines);
        }
        return t3.join("\n") + "\n";
      }
      function Rt2(e3, t3, n3, r3, i3, u3, o3) {
        return Mt2(_t2(e3, t3, n3, r3, i3, u3, o3));
      }
      var $t2 = Object.defineProperty({ structuredPatch: kt2, formatPatch: Pt2, createTwoFilesPatch: Ot2, createPatch: It2 }, "__esModule", { value: true }), Vt2 = function(e3, t3) {
        if (e3.length !== t3.length)
          return false;
        return qt2(e3, t3);
      }, Wt2 = qt2;
      function qt2(e3, t3) {
        if (t3.length > e3.length)
          return false;
        for (var n3 = 0; n3 < t3.length; n3++)
          if (t3[n3] !== e3[n3])
            return false;
        return true;
      }
      var Ut2 = Object.defineProperty({ arrayEqual: Vt2, arrayStartsWith: Wt2 }, "__esModule", { value: true }), zt2 = Xt2, Gt2 = function(e3, t3, n3) {
        e3 = Yt2(e3, n3), t3 = Yt2(t3, n3);
        var r3 = {};
        (e3.index || t3.index) && (r3.index = e3.index || t3.index);
        (e3.newFileName || t3.newFileName) && (Kt2(e3) ? Kt2(t3) ? (r3.oldFileName = Qt2(r3, e3.oldFileName, t3.oldFileName), r3.newFileName = Qt2(r3, e3.newFileName, t3.newFileName), r3.oldHeader = Qt2(r3, e3.oldHeader, t3.oldHeader), r3.newHeader = Qt2(r3, e3.newHeader, t3.newHeader)) : (r3.oldFileName = e3.oldFileName, r3.newFileName = e3.newFileName, r3.oldHeader = e3.oldHeader, r3.newHeader = e3.newHeader) : (r3.oldFileName = t3.oldFileName || e3.oldFileName, r3.newFileName = t3.newFileName || e3.newFileName, r3.oldHeader = t3.oldHeader || e3.oldHeader, r3.newHeader = t3.newHeader || e3.newHeader));
        r3.hunks = [];
        var i3 = 0, u3 = 0, o3 = 0, s3 = 0;
        for (; i3 < e3.hunks.length || u3 < t3.hunks.length; ) {
          var a3 = e3.hunks[i3] || { oldStart: 1 / 0 }, c3 = t3.hunks[u3] || { oldStart: 1 / 0 };
          if (Zt2(a3, c3))
            r3.hunks.push(en2(a3, o3)), i3++, s3 += a3.newLines - a3.oldLines;
          else if (Zt2(c3, a3))
            r3.hunks.push(en2(c3, s3)), u3++, o3 += c3.newLines - c3.oldLines;
          else {
            var l3 = { oldStart: Math.min(a3.oldStart, c3.oldStart), oldLines: 0, newStart: Math.min(a3.newStart + o3, c3.oldStart + s3), newLines: 0, lines: [] };
            tn2(l3, a3.oldStart, a3.lines, c3.oldStart, c3.lines), u3++, i3++, r3.hunks.push(l3);
          }
        }
        return r3;
      };
      function Ht2(e3) {
        return function(e4) {
          if (Array.isArray(e4))
            return Jt2(e4);
        }(e3) || function(e4) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(e4))
            return Array.from(e4);
        }(e3) || function(e4, t3) {
          if (!e4)
            return;
          if (typeof e4 == "string")
            return Jt2(e4, t3);
          var n3 = Object.prototype.toString.call(e4).slice(8, -1);
          n3 === "Object" && e4.constructor && (n3 = e4.constructor.name);
          if (n3 === "Map" || n3 === "Set")
            return Array.from(e4);
          if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
            return Jt2(e4, t3);
        }(e3) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function Jt2(e3, t3) {
        (t3 == null || t3 > e3.length) && (t3 = e3.length);
        for (var n3 = 0, r3 = new Array(t3); n3 < t3; n3++)
          r3[n3] = e3[n3];
        return r3;
      }
      function Xt2(e3) {
        var t3 = pn2(e3.lines), n3 = t3.oldLines, r3 = t3.newLines;
        n3 !== void 0 ? e3.oldLines = n3 : delete e3.oldLines, r3 !== void 0 ? e3.newLines = r3 : delete e3.newLines;
      }
      function Yt2(e3, t3) {
        if (typeof e3 == "string") {
          if (/^@@/m.test(e3) || /^Index:/m.test(e3))
            return (0, Ft2.parsePatch)(e3)[0];
          if (!t3)
            throw new Error("Must provide a base reference or pass in a patch");
          return (0, $t2.structuredPatch)(void 0, void 0, t3, e3);
        }
        return e3;
      }
      function Kt2(e3) {
        return e3.newFileName && e3.newFileName !== e3.oldFileName;
      }
      function Qt2(e3, t3, n3) {
        return t3 === n3 ? t3 : (e3.conflict = true, { mine: t3, theirs: n3 });
      }
      function Zt2(e3, t3) {
        return e3.oldStart < t3.oldStart && e3.oldStart + e3.oldLines < t3.oldStart;
      }
      function en2(e3, t3) {
        return { oldStart: e3.oldStart, oldLines: e3.oldLines, newStart: e3.newStart + t3, newLines: e3.newLines, lines: e3.lines };
      }
      function tn2(e3, t3, n3, r3, i3) {
        var u3 = { offset: t3, lines: n3, index: 0 }, o3 = { offset: r3, lines: i3, index: 0 };
        for (on2(e3, u3, o3), on2(e3, o3, u3); u3.index < u3.lines.length && o3.index < o3.lines.length; ) {
          var s3 = u3.lines[u3.index], a3 = o3.lines[o3.index];
          if (s3[0] !== "-" && s3[0] !== "+" || a3[0] !== "-" && a3[0] !== "+")
            if (s3[0] === "+" && a3[0] === " ") {
              var c3;
              (c3 = e3.lines).push.apply(c3, Ht2(an2(u3)));
            } else if (a3[0] === "+" && s3[0] === " ") {
              var l3;
              (l3 = e3.lines).push.apply(l3, Ht2(an2(o3)));
            } else
              s3[0] === "-" && a3[0] === " " ? rn2(e3, u3, o3) : a3[0] === "-" && s3[0] === " " ? rn2(e3, o3, u3, true) : s3 === a3 ? (e3.lines.push(s3), u3.index++, o3.index++) : un2(e3, an2(u3), an2(o3));
          else
            nn2(e3, u3, o3);
        }
        sn2(e3, u3), sn2(e3, o3), Xt2(e3);
      }
      function nn2(e3, t3, n3) {
        var r3 = an2(t3), i3 = an2(n3);
        if (cn2(r3) && cn2(i3)) {
          var u3, o3;
          if ((0, Ut2.arrayStartsWith)(r3, i3) && ln2(n3, r3, r3.length - i3.length))
            return void (u3 = e3.lines).push.apply(u3, Ht2(r3));
          if ((0, Ut2.arrayStartsWith)(i3, r3) && ln2(t3, i3, i3.length - r3.length))
            return void (o3 = e3.lines).push.apply(o3, Ht2(i3));
        } else if ((0, Ut2.arrayEqual)(r3, i3)) {
          var s3;
          return void (s3 = e3.lines).push.apply(s3, Ht2(r3));
        }
        un2(e3, r3, i3);
      }
      function rn2(e3, t3, n3, r3) {
        var i3, u3 = an2(t3), o3 = function(e4, t4) {
          var n4 = [], r4 = [], i4 = 0, u4 = false, o4 = false;
          for (; i4 < t4.length && e4.index < e4.lines.length; ) {
            var s3 = e4.lines[e4.index], a3 = t4[i4];
            if (a3[0] === "+")
              break;
            if (u4 = u4 || s3[0] !== " ", r4.push(a3), i4++, s3[0] === "+")
              for (o4 = true; s3[0] === "+"; )
                n4.push(s3), s3 = e4.lines[++e4.index];
            a3.substr(1) === s3.substr(1) ? (n4.push(s3), e4.index++) : o4 = true;
          }
          (t4[i4] || "")[0] === "+" && u4 && (o4 = true);
          if (o4)
            return n4;
          for (; i4 < t4.length; )
            r4.push(t4[i4++]);
          return { merged: r4, changes: n4 };
        }(n3, u3);
        o3.merged ? (i3 = e3.lines).push.apply(i3, Ht2(o3.merged)) : un2(e3, r3 ? o3 : u3, r3 ? u3 : o3);
      }
      function un2(e3, t3, n3) {
        e3.conflict = true, e3.lines.push({ conflict: true, mine: t3, theirs: n3 });
      }
      function on2(e3, t3, n3) {
        for (; t3.offset < n3.offset && t3.index < t3.lines.length; ) {
          var r3 = t3.lines[t3.index++];
          e3.lines.push(r3), t3.offset++;
        }
      }
      function sn2(e3, t3) {
        for (; t3.index < t3.lines.length; ) {
          var n3 = t3.lines[t3.index++];
          e3.lines.push(n3);
        }
      }
      function an2(e3) {
        for (var t3 = [], n3 = e3.lines[e3.index][0]; e3.index < e3.lines.length; ) {
          var r3 = e3.lines[e3.index];
          if (n3 === "-" && r3[0] === "+" && (n3 = "+"), n3 !== r3[0])
            break;
          t3.push(r3), e3.index++;
        }
        return t3;
      }
      function cn2(e3) {
        return e3.reduce(function(e4, t3) {
          return e4 && t3[0] === "-";
        }, true);
      }
      function ln2(e3, t3, n3) {
        for (var r3 = 0; r3 < n3; r3++) {
          var i3 = t3[t3.length - n3 + r3].substr(1);
          if (e3.lines[e3.index + r3] !== " " + i3)
            return false;
        }
        return e3.index += n3, true;
      }
      function pn2(e3) {
        var t3 = 0, n3 = 0;
        return e3.forEach(function(e4) {
          if (typeof e4 != "string") {
            var r3 = pn2(e4.mine), i3 = pn2(e4.theirs);
            t3 !== void 0 && (r3.oldLines === i3.oldLines ? t3 += r3.oldLines : t3 = void 0), n3 !== void 0 && (r3.newLines === i3.newLines ? n3 += r3.newLines : n3 = void 0);
          } else
            n3 === void 0 || e4[0] !== "+" && e4[0] !== " " || n3++, t3 === void 0 || e4[0] !== "-" && e4[0] !== " " || t3++;
        }), { oldLines: t3, newLines: n3 };
      }
      var fn2 = Object.defineProperty({ calcLineCount: zt2, merge: Gt2 }, "__esModule", { value: true }), dn2 = function(e3) {
        for (var t3, n3, r3 = [], i3 = 0; i3 < e3.length; i3++)
          t3 = e3[i3], n3 = t3.added ? 1 : t3.removed ? -1 : 0, r3.push([n3, t3.value]);
        return r3;
      };
      var hn2 = Object.defineProperty({ convertChangesToDMP: dn2 }, "__esModule", { value: true }), gn2 = function(e3) {
        for (var t3 = [], n3 = 0; n3 < e3.length; n3++) {
          var r3 = e3[n3];
          r3.added ? t3.push("<ins>") : r3.removed && t3.push("<del>"), t3.push(mn2(r3.value)), r3.added ? t3.push("</ins>") : r3.removed && t3.push("</del>");
        }
        return t3.join("");
      };
      function mn2(e3) {
        var t3 = e3;
        return t3 = (t3 = (t3 = (t3 = t3.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
      }
      var yn2 = Object.defineProperty({ convertChangesToXML: gn2 }, "__esModule", { value: true }), Dn2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Object.defineProperty(t3, "Diff", { enumerable: true, get: function() {
          return n3.default;
        } }), Object.defineProperty(t3, "diffChars", { enumerable: true, get: function() {
          return u2.diffChars;
        } }), Object.defineProperty(t3, "diffWords", { enumerable: true, get: function() {
          return l2.diffWords;
        } }), Object.defineProperty(t3, "diffWordsWithSpace", { enumerable: true, get: function() {
          return l2.diffWordsWithSpace;
        } }), Object.defineProperty(t3, "diffLines", { enumerable: true, get: function() {
          return p2.diffLines;
        } }), Object.defineProperty(t3, "diffTrimmedLines", { enumerable: true, get: function() {
          return p2.diffTrimmedLines;
        } }), Object.defineProperty(t3, "diffSentences", { enumerable: true, get: function() {
          return f2.diffSentences;
        } }), Object.defineProperty(t3, "diffCss", { enumerable: true, get: function() {
          return d2.diffCss;
        } }), Object.defineProperty(t3, "diffJson", { enumerable: true, get: function() {
          return Ct2.diffJson;
        } }), Object.defineProperty(t3, "canonicalize", { enumerable: true, get: function() {
          return Ct2.canonicalize;
        } }), Object.defineProperty(t3, "diffArrays", { enumerable: true, get: function() {
          return bt2.diffArrays;
        } }), Object.defineProperty(t3, "applyPatch", { enumerable: true, get: function() {
          return Nt2.applyPatch;
        } }), Object.defineProperty(t3, "applyPatches", { enumerable: true, get: function() {
          return Nt2.applyPatches;
        } }), Object.defineProperty(t3, "parsePatch", { enumerable: true, get: function() {
          return Ft2.parsePatch;
        } }), Object.defineProperty(t3, "merge", { enumerable: true, get: function() {
          return fn2.merge;
        } }), Object.defineProperty(t3, "structuredPatch", { enumerable: true, get: function() {
          return $t2.structuredPatch;
        } }), Object.defineProperty(t3, "createTwoFilesPatch", { enumerable: true, get: function() {
          return $t2.createTwoFilesPatch;
        } }), Object.defineProperty(t3, "createPatch", { enumerable: true, get: function() {
          return $t2.createPatch;
        } }), Object.defineProperty(t3, "convertChangesToDMP", { enumerable: true, get: function() {
          return hn2.convertChangesToDMP;
        } }), Object.defineProperty(t3, "convertChangesToXML", { enumerable: true, get: function() {
          return yn2.convertChangesToXML;
        } });
        var n3 = function(e4) {
          return e4 && e4.__esModule ? e4 : { default: e4 };
        }(i2);
      });
      function En2(e3) {
        return { type: "concat", parts: e3 };
      }
      function Cn2(e3) {
        return { type: "indent", contents: e3 };
      }
      function bn2(e3, t3) {
        return { type: "align", contents: t3, n: e3 };
      }
      function An2(e3, t3 = {}) {
        return { type: "group", id: t3.id, contents: e3, break: Boolean(t3.shouldBreak), expandedStates: t3.expandedStates };
      }
      const vn2 = { type: "break-parent" }, Fn2 = { type: "line", hard: true }, xn2 = { type: "line", hard: true, literal: true }, Sn2 = En2([Fn2, vn2]), wn2 = En2([xn2, vn2]);
      var Tn2 = { concat: En2, join: function(e3, t3) {
        const n3 = [];
        for (let r3 = 0; r3 < t3.length; r3++)
          r3 !== 0 && n3.push(e3), n3.push(t3[r3]);
        return En2(n3);
      }, line: { type: "line" }, softline: { type: "line", soft: true }, hardline: Sn2, literalline: wn2, group: An2, conditionalGroup: function(e3, t3) {
        return An2(e3[0], Object.assign(Object.assign({}, t3), {}, { expandedStates: e3 }));
      }, fill: function(e3) {
        return { type: "fill", parts: e3 };
      }, lineSuffix: function(e3) {
        return { type: "line-suffix", contents: e3 };
      }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: vn2, ifBreak: function(e3, t3, n3 = {}) {
        return { type: "if-break", breakContents: e3, flatContents: t3, groupId: n3.groupId };
      }, trim: { type: "trim" }, indent: Cn2, indentIfBreak: function(e3, t3) {
        return { type: "indent-if-break", contents: e3, groupId: t3.groupId, negate: t3.negate };
      }, align: bn2, addAlignmentToDoc: function(e3, t3, n3) {
        let r3 = e3;
        if (t3 > 0) {
          for (let e4 = 0; e4 < Math.floor(t3 / n3); ++e4)
            r3 = Cn2(r3);
          r3 = bn2(t3 % n3, r3), r3 = bn2(Number.NEGATIVE_INFINITY, r3);
        }
        return r3;
      }, markAsRoot: function(e3) {
        return bn2({ type: "root" }, e3);
      }, dedentToRoot: function(e3) {
        return bn2(Number.NEGATIVE_INFINITY, e3);
      }, dedent: function(e3) {
        return bn2(-1, e3);
      }, hardlineWithoutBreakParent: Fn2, literallineWithoutBreakParent: xn2, label: function(e3, t3) {
        return { type: "label", label: e3, contents: t3 };
      } }, Bn2 = (e3) => typeof e3 == "string" ? e3.replace((({ onlyFirst: e4 = false } = {}) => {
        const t3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(t3, e4 ? void 0 : "g");
      })(), "") : e3;
      const Nn2 = (e3) => !Number.isNaN(e3) && (e3 >= 4352 && (e3 <= 4447 || e3 === 9001 || e3 === 9002 || 11904 <= e3 && e3 <= 12871 && e3 !== 12351 || 12880 <= e3 && e3 <= 19903 || 19968 <= e3 && e3 <= 42182 || 43360 <= e3 && e3 <= 43388 || 44032 <= e3 && e3 <= 55203 || 63744 <= e3 && e3 <= 64255 || 65040 <= e3 && e3 <= 65049 || 65072 <= e3 && e3 <= 65131 || 65281 <= e3 && e3 <= 65376 || 65504 <= e3 && e3 <= 65510 || 110592 <= e3 && e3 <= 110593 || 127488 <= e3 && e3 <= 127569 || 131072 <= e3 && e3 <= 262141));
      var kn2 = Nn2, Pn2 = Nn2;
      kn2.default = Pn2;
      const On2 = (e3) => {
        if (typeof e3 != "string" || e3.length === 0)
          return 0;
        if ((e3 = Bn2(e3)).length === 0)
          return 0;
        e3 = e3.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
        let t3 = 0;
        for (let n3 = 0; n3 < e3.length; n3++) {
          const r3 = e3.codePointAt(n3);
          r3 <= 31 || r3 >= 127 && r3 <= 159 || (r3 >= 768 && r3 <= 879 || (r3 > 65535 && n3++, t3 += kn2(r3) ? 2 : 1));
        }
        return t3;
      };
      var In2 = On2, Ln2 = On2;
      In2.default = Ln2;
      var jn2 = (e3) => {
        if (typeof e3 != "string")
          throw new TypeError("Expected a string");
        return e3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      };
      var _n2 = (e3) => e3[e3.length - 1];
      function Mn2(e3, t3) {
        if (e3 == null)
          return {};
        var n3, r3, i3 = function(e4, t4) {
          if (e4 == null)
            return {};
          var n4, r4, i4 = {}, u4 = Object.keys(e4);
          for (r4 = 0; r4 < u4.length; r4++)
            n4 = u4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
          return i4;
        }(e3, t3);
        if (Object.getOwnPropertySymbols) {
          var u3 = Object.getOwnPropertySymbols(e3);
          for (r3 = 0; r3 < u3.length; r3++)
            n3 = u3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
        }
        return i3;
      }
      var Rn2 = Array.isArray || function(e3) {
        return v2(e3) == "Array";
      }, $n2 = function(e3, t3, n3) {
        if (nt2(e3), t3 === void 0)
          return e3;
        switch (n3) {
          case 0:
            return function() {
              return e3.call(t3);
            };
          case 1:
            return function(n4) {
              return e3.call(t3, n4);
            };
          case 2:
            return function(n4, r3) {
              return e3.call(t3, n4, r3);
            };
          case 3:
            return function(n4, r3, i3) {
              return e3.call(t3, n4, r3, i3);
            };
        }
        return function() {
          return e3.apply(t3, arguments);
        };
      }, Vn2 = function(e3, t3, n3, r3, i3, u3, o3, s3) {
        for (var a3, c3 = i3, l3 = 0, p3 = !!o3 && $n2(o3, s3, 3); l3 < r3; ) {
          if (l3 in n3) {
            if (a3 = p3 ? p3(n3[l3], l3, t3) : n3[l3], u3 > 0 && Rn2(a3))
              c3 = Vn2(e3, t3, a3, _e2(a3.length), c3, u3 - 1) - 1;
            else {
              if (c3 >= 9007199254740991)
                throw TypeError("Exceed the acceptable array length");
              e3[c3] = a3;
            }
            c3++;
          }
          l3++;
        }
        return c3;
      }, Wn2 = Vn2, qn2 = Z2("species"), Un2 = function(e3, t3) {
        return new (function(e4) {
          var t4;
          return Rn2(e4) && (typeof (t4 = e4.constructor) != "function" || t4 !== Array && !Rn2(t4.prototype) ? T2(t4) && (t4 = t4[qn2]) === null && (t4 = void 0) : t4 = void 0), t4 === void 0 ? Array : t4;
        }(e3))(t3 === 0 ? 0 : t3);
      };
      tt2({ target: "Array", proto: true }, { flatMap: function(e3) {
        var t3, n3 = U2(this), r3 = _e2(n3.length);
        return nt2(e3), (t3 = Un2(n3, 0)).length = Wn2(t3, n3, n3, r3, 0, 1, e3, arguments.length > 1 ? arguments[1] : void 0), t3;
      } });
      var zn2 = {}, Gn2 = Z2("iterator"), Hn2 = Array.prototype, Jn2 = {};
      Jn2[Z2("toStringTag")] = "z";
      var Xn2 = String(Jn2) === "[object z]", Yn2 = Z2("toStringTag"), Kn2 = v2(function() {
        return arguments;
      }()) == "Arguments", Qn2 = Xn2 ? v2 : function(e3) {
        var t3, n3, r3;
        return e3 === void 0 ? "Undefined" : e3 === null ? "Null" : typeof (n3 = function(e4, t4) {
          try {
            return e4[t4];
          } catch (e5) {
          }
        }(t3 = Object(e3), Yn2)) == "string" ? n3 : Kn2 ? v2(t3) : (r3 = v2(t3)) == "Object" && typeof t3.callee == "function" ? "Arguments" : r3;
      }, Zn2 = Z2("iterator"), er2 = function(e3) {
        if (e3 != null)
          return e3[Zn2] || e3["@@iterator"] || zn2[Qn2(e3)];
      }, tr2 = function(e3, t3, n3) {
        var r3, i3;
        ae2(e3);
        try {
          if ((r3 = e3.return) === void 0) {
            if (t3 === "throw")
              throw n3;
            return n3;
          }
          r3 = r3.call(e3);
        } catch (e4) {
          i3 = true, r3 = e4;
        }
        if (t3 === "throw")
          throw n3;
        if (i3)
          throw r3;
        return ae2(r3), n3;
      }, nr2 = function(e3, t3) {
        this.stopped = e3, this.result = t3;
      }, rr2 = function(e3, t3, n3) {
        var r3, i3, u3, o3, s3, a3, c3, l3, p3 = n3 && n3.that, f3 = !(!n3 || !n3.AS_ENTRIES), d3 = !(!n3 || !n3.IS_ITERATOR), h3 = !(!n3 || !n3.INTERRUPTED), g3 = $n2(t3, p3, 1 + f3 + h3), m3 = function(e4) {
          return r3 && tr2(r3, "normal", e4), new nr2(true, e4);
        }, y3 = function(e4) {
          return f3 ? (ae2(e4), h3 ? g3(e4[0], e4[1], m3) : g3(e4[0], e4[1])) : h3 ? g3(e4, m3) : g3(e4);
        };
        if (d3)
          r3 = e3;
        else {
          if (typeof (i3 = er2(e3)) != "function")
            throw TypeError("Target is not iterable");
          if ((l3 = i3) !== void 0 && (zn2.Array === l3 || Hn2[Gn2] === l3)) {
            for (u3 = 0, o3 = _e2(e3.length); o3 > u3; u3++)
              if ((s3 = y3(e3[u3])) && s3 instanceof nr2)
                return s3;
            return new nr2(false);
          }
          r3 = function(e4, t4) {
            var n4 = arguments.length < 2 ? er2(e4) : t4;
            if (typeof n4 != "function")
              throw TypeError(String(e4) + " is not iterable");
            return ae2(n4.call(e4));
          }(e3, i3);
        }
        for (a3 = r3.next; !(c3 = a3.call(r3)).done; ) {
          try {
            s3 = y3(c3.value);
          } catch (e4) {
            tr2(r3, "throw", e4);
          }
          if (typeof s3 == "object" && s3 && s3 instanceof nr2)
            return s3;
        }
        return new nr2(false);
      };
      tt2({ target: "Object", stat: true }, { fromEntries: function(e3) {
        var t3 = {};
        return rr2(e3, function(e4, n3) {
          !function(e5, t4, n4) {
            var r3 = ne2(t4);
            r3 in e5 ? le2.f(e5, r3, b2(0, n4)) : e5[r3] = n4;
          }(t3, e4, n3);
        }, { AS_ENTRIES: true }), t3;
      } });
      var ir2 = ir2 !== void 0 ? ir2 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
      function ur2() {
        throw new Error("setTimeout has not been defined");
      }
      function or2() {
        throw new Error("clearTimeout has not been defined");
      }
      var sr2 = ur2, ar2 = or2;
      function cr2(e3) {
        if (sr2 === setTimeout)
          return setTimeout(e3, 0);
        if ((sr2 === ur2 || !sr2) && setTimeout)
          return sr2 = setTimeout, setTimeout(e3, 0);
        try {
          return sr2(e3, 0);
        } catch (t3) {
          try {
            return sr2.call(null, e3, 0);
          } catch (t4) {
            return sr2.call(this, e3, 0);
          }
        }
      }
      typeof ir2.setTimeout == "function" && (sr2 = setTimeout), typeof ir2.clearTimeout == "function" && (ar2 = clearTimeout);
      var lr2, pr2 = [], fr2 = false, dr2 = -1;
      function hr2() {
        fr2 && lr2 && (fr2 = false, lr2.length ? pr2 = lr2.concat(pr2) : dr2 = -1, pr2.length && gr2());
      }
      function gr2() {
        if (!fr2) {
          var e3 = cr2(hr2);
          fr2 = true;
          for (var t3 = pr2.length; t3; ) {
            for (lr2 = pr2, pr2 = []; ++dr2 < t3; )
              lr2 && lr2[dr2].run();
            dr2 = -1, t3 = pr2.length;
          }
          lr2 = null, fr2 = false, function(e4) {
            if (ar2 === clearTimeout)
              return clearTimeout(e4);
            if ((ar2 === or2 || !ar2) && clearTimeout)
              return ar2 = clearTimeout, clearTimeout(e4);
            try {
              ar2(e4);
            } catch (t4) {
              try {
                return ar2.call(null, e4);
              } catch (t5) {
                return ar2.call(this, e4);
              }
            }
          }(e3);
        }
      }
      function mr2(e3, t3) {
        this.fun = e3, this.array = t3;
      }
      mr2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      function yr2() {
      }
      var Dr2 = yr2, Er2 = yr2, Cr2 = yr2, br2 = yr2, Ar2 = yr2, vr2 = yr2, Fr2 = yr2;
      var xr2 = ir2.performance || {}, Sr2 = xr2.now || xr2.mozNow || xr2.msNow || xr2.oNow || xr2.webkitNow || function() {
        return new Date().getTime();
      };
      var wr2 = new Date();
      var Tr2 = { nextTick: function(e3) {
        var t3 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n3 = 1; n3 < arguments.length; n3++)
            t3[n3 - 1] = arguments[n3];
        pr2.push(new mr2(e3, t3)), pr2.length !== 1 || fr2 || cr2(gr2);
      }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Dr2, addListener: Er2, once: Cr2, off: br2, removeListener: Ar2, removeAllListeners: vr2, emit: Fr2, binding: function(e3) {
        throw new Error("process.binding is not supported");
      }, cwd: function() {
        return "/";
      }, chdir: function(e3) {
        throw new Error("process.chdir is not supported");
      }, umask: function() {
        return 0;
      }, hrtime: function(e3) {
        var t3 = 1e-3 * Sr2.call(xr2), n3 = Math.floor(t3), r3 = Math.floor(t3 % 1 * 1e9);
        return e3 && (n3 -= e3[0], (r3 -= e3[1]) < 0 && (n3--, r3 += 1e9)), [n3, r3];
      }, platform: "browser", release: {}, config: {}, uptime: function() {
        return (new Date() - wr2) / 1e3;
      } };
      var Br2 = typeof Tr2 == "object" && Tr2.env && Tr2.env.NODE_DEBUG && /\bsemver\b/i.test(Tr2.env.NODE_DEBUG) ? (...e3) => console.error("SEMVER", ...e3) : () => {
      };
      var Nr2 = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, kr2 = r2(function(e3, t3) {
        const { MAX_SAFE_COMPONENT_LENGTH: n3 } = Nr2, r3 = (t3 = e3.exports = {}).re = [], i3 = t3.src = [], u3 = t3.t = {};
        let o3 = 0;
        const s3 = (e4, t4, n4) => {
          const s4 = o3++;
          Br2(s4, t4), u3[e4] = s4, i3[s4] = t4, r3[s4] = new RegExp(t4, n4 ? "g" : void 0);
        };
        s3("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s3("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s3("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s3("MAINVERSION", `(${i3[u3.NUMERICIDENTIFIER]})\\.(${i3[u3.NUMERICIDENTIFIER]})\\.(${i3[u3.NUMERICIDENTIFIER]})`), s3("MAINVERSIONLOOSE", `(${i3[u3.NUMERICIDENTIFIERLOOSE]})\\.(${i3[u3.NUMERICIDENTIFIERLOOSE]})\\.(${i3[u3.NUMERICIDENTIFIERLOOSE]})`), s3("PRERELEASEIDENTIFIER", `(?:${i3[u3.NUMERICIDENTIFIER]}|${i3[u3.NONNUMERICIDENTIFIER]})`), s3("PRERELEASEIDENTIFIERLOOSE", `(?:${i3[u3.NUMERICIDENTIFIERLOOSE]}|${i3[u3.NONNUMERICIDENTIFIER]})`), s3("PRERELEASE", `(?:-(${i3[u3.PRERELEASEIDENTIFIER]}(?:\\.${i3[u3.PRERELEASEIDENTIFIER]})*))`), s3("PRERELEASELOOSE", `(?:-?(${i3[u3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i3[u3.PRERELEASEIDENTIFIERLOOSE]})*))`), s3("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s3("BUILD", `(?:\\+(${i3[u3.BUILDIDENTIFIER]}(?:\\.${i3[u3.BUILDIDENTIFIER]})*))`), s3("FULLPLAIN", `v?${i3[u3.MAINVERSION]}${i3[u3.PRERELEASE]}?${i3[u3.BUILD]}?`), s3("FULL", `^${i3[u3.FULLPLAIN]}$`), s3("LOOSEPLAIN", `[v=\\s]*${i3[u3.MAINVERSIONLOOSE]}${i3[u3.PRERELEASELOOSE]}?${i3[u3.BUILD]}?`), s3("LOOSE", `^${i3[u3.LOOSEPLAIN]}$`), s3("GTLT", "((?:<|>)?=?)"), s3("XRANGEIDENTIFIERLOOSE", `${i3[u3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s3("XRANGEIDENTIFIER", `${i3[u3.NUMERICIDENTIFIER]}|x|X|\\*`), s3("XRANGEPLAIN", `[v=\\s]*(${i3[u3.XRANGEIDENTIFIER]})(?:\\.(${i3[u3.XRANGEIDENTIFIER]})(?:\\.(${i3[u3.XRANGEIDENTIFIER]})(?:${i3[u3.PRERELEASE]})?${i3[u3.BUILD]}?)?)?`), s3("XRANGEPLAINLOOSE", `[v=\\s]*(${i3[u3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i3[u3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i3[u3.XRANGEIDENTIFIERLOOSE]})(?:${i3[u3.PRERELEASELOOSE]})?${i3[u3.BUILD]}?)?)?`), s3("XRANGE", `^${i3[u3.GTLT]}\\s*${i3[u3.XRANGEPLAIN]}$`), s3("XRANGELOOSE", `^${i3[u3.GTLT]}\\s*${i3[u3.XRANGEPLAINLOOSE]}$`), s3("COERCE", `(^|[^\\d])(\\d{1,${n3}})(?:\\.(\\d{1,${n3}}))?(?:\\.(\\d{1,${n3}}))?(?:$|[^\\d])`), s3("COERCERTL", i3[u3.COERCE], true), s3("LONETILDE", "(?:~>?)"), s3("TILDETRIM", `(\\s*)${i3[u3.LONETILDE]}\\s+`, true), t3.tildeTrimReplace = "$1~", s3("TILDE", `^${i3[u3.LONETILDE]}${i3[u3.XRANGEPLAIN]}$`), s3("TILDELOOSE", `^${i3[u3.LONETILDE]}${i3[u3.XRANGEPLAINLOOSE]}$`), s3("LONECARET", "(?:\\^)"), s3("CARETTRIM", `(\\s*)${i3[u3.LONECARET]}\\s+`, true), t3.caretTrimReplace = "$1^", s3("CARET", `^${i3[u3.LONECARET]}${i3[u3.XRANGEPLAIN]}$`), s3("CARETLOOSE", `^${i3[u3.LONECARET]}${i3[u3.XRANGEPLAINLOOSE]}$`), s3("COMPARATORLOOSE", `^${i3[u3.GTLT]}\\s*(${i3[u3.LOOSEPLAIN]})$|^$`), s3("COMPARATOR", `^${i3[u3.GTLT]}\\s*(${i3[u3.FULLPLAIN]})$|^$`), s3("COMPARATORTRIM", `(\\s*)${i3[u3.GTLT]}\\s*(${i3[u3.LOOSEPLAIN]}|${i3[u3.XRANGEPLAIN]})`, true), t3.comparatorTrimReplace = "$1$2$3", s3("HYPHENRANGE", `^\\s*(${i3[u3.XRANGEPLAIN]})\\s+-\\s+(${i3[u3.XRANGEPLAIN]})\\s*$`), s3("HYPHENRANGELOOSE", `^\\s*(${i3[u3.XRANGEPLAINLOOSE]})\\s+-\\s+(${i3[u3.XRANGEPLAINLOOSE]})\\s*$`), s3("STAR", "(<|>)?=?\\s*\\*"), s3("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), s3("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      });
      const Pr2 = ["includePrerelease", "loose", "rtl"];
      var Or2 = (e3) => e3 ? typeof e3 != "object" ? { loose: true } : Pr2.filter((t3) => e3[t3]).reduce((e4, t3) => (e4[t3] = true, e4), {}) : {};
      const Ir2 = /^[0-9]+$/, Lr2 = (e3, t3) => {
        const n3 = Ir2.test(e3), r3 = Ir2.test(t3);
        return n3 && r3 && (e3 = +e3, t3 = +t3), e3 === t3 ? 0 : n3 && !r3 ? -1 : r3 && !n3 ? 1 : e3 < t3 ? -1 : 1;
      };
      var jr2 = { compareIdentifiers: Lr2, rcompareIdentifiers: (e3, t3) => Lr2(t3, e3) };
      const { MAX_LENGTH: _r2, MAX_SAFE_INTEGER: Mr2 } = Nr2, { re: Rr2, t: $r2 } = kr2, { compareIdentifiers: Vr2 } = jr2;
      class Wr2 {
        constructor(e3, t3) {
          if (t3 = Or2(t3), e3 instanceof Wr2) {
            if (e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease)
              return e3;
            e3 = e3.version;
          } else if (typeof e3 != "string")
            throw new TypeError(`Invalid Version: ${e3}`);
          if (e3.length > _r2)
            throw new TypeError(`version is longer than ${_r2} characters`);
          Br2("SemVer", e3, t3), this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease;
          const n3 = e3.trim().match(t3.loose ? Rr2[$r2.LOOSE] : Rr2[$r2.FULL]);
          if (!n3)
            throw new TypeError(`Invalid Version: ${e3}`);
          if (this.raw = e3, this.major = +n3[1], this.minor = +n3[2], this.patch = +n3[3], this.major > Mr2 || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > Mr2 || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > Mr2 || this.patch < 0)
            throw new TypeError("Invalid patch version");
          n3[4] ? this.prerelease = n3[4].split(".").map((e4) => {
            if (/^[0-9]+$/.test(e4)) {
              const t4 = +e4;
              if (t4 >= 0 && t4 < Mr2)
                return t4;
            }
            return e4;
          }) : this.prerelease = [], this.build = n3[5] ? n3[5].split(".") : [], this.format();
        }
        format() {
          return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
        }
        toString() {
          return this.version;
        }
        compare(e3) {
          if (Br2("SemVer.compare", this.version, this.options, e3), !(e3 instanceof Wr2)) {
            if (typeof e3 == "string" && e3 === this.version)
              return 0;
            e3 = new Wr2(e3, this.options);
          }
          return e3.version === this.version ? 0 : this.compareMain(e3) || this.comparePre(e3);
        }
        compareMain(e3) {
          return e3 instanceof Wr2 || (e3 = new Wr2(e3, this.options)), Vr2(this.major, e3.major) || Vr2(this.minor, e3.minor) || Vr2(this.patch, e3.patch);
        }
        comparePre(e3) {
          if (e3 instanceof Wr2 || (e3 = new Wr2(e3, this.options)), this.prerelease.length && !e3.prerelease.length)
            return -1;
          if (!this.prerelease.length && e3.prerelease.length)
            return 1;
          if (!this.prerelease.length && !e3.prerelease.length)
            return 0;
          let t3 = 0;
          do {
            const n3 = this.prerelease[t3], r3 = e3.prerelease[t3];
            if (Br2("prerelease compare", t3, n3, r3), n3 === void 0 && r3 === void 0)
              return 0;
            if (r3 === void 0)
              return 1;
            if (n3 === void 0)
              return -1;
            if (n3 !== r3)
              return Vr2(n3, r3);
          } while (++t3);
        }
        compareBuild(e3) {
          e3 instanceof Wr2 || (e3 = new Wr2(e3, this.options));
          let t3 = 0;
          do {
            const n3 = this.build[t3], r3 = e3.build[t3];
            if (Br2("prerelease compare", t3, n3, r3), n3 === void 0 && r3 === void 0)
              return 0;
            if (r3 === void 0)
              return 1;
            if (n3 === void 0)
              return -1;
            if (n3 !== r3)
              return Vr2(n3, r3);
          } while (++t3);
        }
        inc(e3, t3) {
          switch (e3) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", t3), this.inc("pre", t3);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", t3), this.inc("pre", t3);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0)
                this.prerelease = [0];
              else {
                let e4 = this.prerelease.length;
                for (; --e4 >= 0; )
                  typeof this.prerelease[e4] == "number" && (this.prerelease[e4]++, e4 = -2);
                e4 === -1 && this.prerelease.push(0);
              }
              t3 && (this.prerelease[0] === t3 ? isNaN(this.prerelease[1]) && (this.prerelease = [t3, 0]) : this.prerelease = [t3, 0]);
              break;
            default:
              throw new Error(`invalid increment argument: ${e3}`);
          }
          return this.format(), this.raw = this.version, this;
        }
      }
      var qr2 = Wr2;
      var Ur2 = (e3, t3, n3) => new qr2(e3, n3).compare(new qr2(t3, n3));
      var zr2 = (e3, t3, n3) => Ur2(e3, t3, n3) < 0;
      var Gr2 = (e3, t3, n3) => Ur2(e3, t3, n3) >= 0, Hr2 = r2(function(e3, t3) {
        function n3() {
          for (var e4 = [], t4 = 0; t4 < arguments.length; t4++)
            e4[t4] = arguments[t4];
        }
        function r3() {
          return typeof WeakMap != "undefined" ? new WeakMap() : { add: n3, delete: n3, get: n3, set: n3, has: function(e4) {
            return false;
          } };
        }
        Object.defineProperty(t3, "__esModule", { value: true }), t3.outdent = void 0;
        var i3 = Object.prototype.hasOwnProperty, u3 = function(e4, t4) {
          return i3.call(e4, t4);
        };
        function o3(e4, t4) {
          for (var n4 in t4)
            u3(t4, n4) && (e4[n4] = t4[n4]);
          return e4;
        }
        var s3 = /^[ \t]*(?:\r\n|\r|\n)/, a3 = /(?:\r\n|\r|\n)[ \t]*$/, c3 = /^(?:[\r\n]|$)/, l3 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p3 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function f3(e4, t4, n4) {
          var r4 = 0, i4 = e4[0].match(l3);
          i4 && (r4 = i4[1].length);
          var u4 = new RegExp("(\\r\\n|\\r|\\n).{0," + r4 + "}", "g");
          t4 && (e4 = e4.slice(1));
          var o4 = n4.newline, c4 = n4.trimLeadingNewline, p4 = n4.trimTrailingNewline, f4 = typeof o4 == "string", d4 = e4.length;
          return e4.map(function(e5, t5) {
            return e5 = e5.replace(u4, "$1"), t5 === 0 && c4 && (e5 = e5.replace(s3, "")), t5 === d4 - 1 && p4 && (e5 = e5.replace(a3, "")), f4 && (e5 = e5.replace(/\r\n|\n|\r/g, function(e6) {
              return o4;
            })), e5;
          });
        }
        function d3(e4, t4) {
          for (var n4 = "", r4 = 0, i4 = e4.length; r4 < i4; r4++)
            n4 += e4[r4], r4 < i4 - 1 && (n4 += t4[r4]);
          return n4;
        }
        function h3(e4) {
          return u3(e4, "raw") && u3(e4, "length");
        }
        var g3 = function e4(t4) {
          var n4 = r3(), i4 = r3();
          return o3(function r4(u4) {
            for (var s4 = [], a4 = 1; a4 < arguments.length; a4++)
              s4[a4 - 1] = arguments[a4];
            if (h3(u4)) {
              var l4 = u4, m3 = (s4[0] === r4 || s4[0] === g3) && p3.test(l4[0]) && c3.test(l4[1]), y3 = m3 ? i4 : n4, D3 = y3.get(l4);
              if (D3 || (D3 = f3(l4, m3, t4), y3.set(l4, D3)), s4.length === 0)
                return D3[0];
              var E3 = d3(D3, m3 ? s4.slice(1) : s4);
              return E3;
            }
            return e4(o3(o3({}, t4), u4 || {}));
          }, { string: function(e5) {
            return f3([e5], false, t4)[0];
          } });
        }({ trimLeadingNewline: true, trimTrailingNewline: true });
        t3.outdent = g3, t3.default = g3;
        try {
          e3.exports = g3, Object.defineProperty(g3, "__esModule", { value: true }), g3.default = g3, g3.outdent = g3;
        } catch (e4) {
        }
      });
      const { outdent: Jr2 } = Hr2, Xr2 = "Config", Yr2 = "Editor", Kr2 = "Other", Qr2 = "Global", Zr2 = "Special", ei2 = { cursorOffset: { since: "1.4.0", category: Zr2, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Jr2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: Yr2 }, endOfLine: { since: "1.15.0", category: Qr2, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Jr2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: Zr2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: Kr2, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: Zr2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: Kr2 }, parser: { since: "0.0.10", category: Qr2, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e3) => typeof e3 == "string" || typeof e3 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: Qr2, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e3) => typeof e3 == "string" || typeof e3 == "object", cliName: "plugin", cliCategory: Xr2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: Qr2, description: Jr2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e3) => typeof e3 == "string" || typeof e3 == "object", cliName: "plugin-search-dir", cliCategory: Xr2 }, printWidth: { since: "0.0.0", category: Qr2, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: Zr2, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Jr2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: Yr2 }, rangeStart: { since: "1.4.0", category: Zr2, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Jr2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: Yr2 }, requirePragma: { since: "1.7.0", category: Zr2, type: "boolean", default: false, description: Jr2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: Kr2 }, tabWidth: { type: "int", category: Qr2, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: Qr2, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: Qr2, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
      const ti2 = ["cliName", "cliCategory", "cliDescription"], ni2 = { compare: Ur2, lt: zr2, gte: Gr2 }, ri2 = e2.version, ii2 = { CATEGORY_CONFIG: Xr2, CATEGORY_EDITOR: Yr2, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: Kr2, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: Qr2, CATEGORY_SPECIAL: Zr2, options: ei2 }.options;
      var ui2 = { getSupportInfo: function({ plugins: e3 = [], showUnreleased: t3 = false, showDeprecated: n3 = false, showInternal: r3 = false } = {}) {
        const i3 = ri2.split("-", 1)[0], u3 = e3.flatMap((e4) => e4.languages || []).filter(s3), o3 = ((e4, t4) => Object.entries(e4).map(([e5, n4]) => Object.assign({ [t4]: e5 }, n4)))(Object.assign({}, ...e3.map(({ options: e4 }) => e4), ii2), "name").filter((e4) => s3(e4) && a3(e4)).sort((e4, t4) => e4.name === t4.name ? 0 : e4.name < t4.name ? -1 : 1).map(function(e4) {
          if (r3)
            return e4;
          return Mn2(e4, ti2);
        }).map((t4) => {
          t4 = Object.assign({}, t4), Array.isArray(t4.default) && (t4.default = t4.default.length === 1 ? t4.default[0].value : t4.default.filter(s3).sort((e4, t5) => ni2.compare(t5.since, e4.since))[0].value), Array.isArray(t4.choices) && (t4.choices = t4.choices.filter((e4) => s3(e4) && a3(e4)), t4.name === "parser" && function(e4, t5, n5) {
            const r4 = new Set(e4.choices.map((e5) => e5.value));
            for (const i4 of t5)
              if (i4.parsers) {
                for (const t6 of i4.parsers)
                  if (!r4.has(t6)) {
                    r4.add(t6);
                    const u4 = n5.find((e5) => e5.parsers && e5.parsers[t6]);
                    let o4 = i4.name;
                    u4 && u4.name && (o4 += ` (plugin: ${u4.name})`), e4.choices.push({ value: t6, description: o4 });
                  }
              }
          }(t4, u3, e3));
          const n4 = Object.fromEntries(e3.filter((e4) => e4.defaultOptions && e4.defaultOptions[t4.name] !== void 0).map((e4) => [e4.name, e4.defaultOptions[t4.name]]));
          return Object.assign(Object.assign({}, t4), {}, { pluginDefaults: n4 });
        });
        return { languages: u3, options: o3 };
        function s3(e4) {
          return t3 || !("since" in e4) || e4.since && ni2.gte(i3, e4.since);
        }
        function a3(e4) {
          return n3 || !("deprecated" in e4) || e4.deprecated && ni2.lt(i3, e4.deprecated);
        }
      } };
      const { getSupportInfo: oi2 } = ui2, si2 = /[^\x20-\x7F]/;
      function ai2(e3) {
        return (t3, n3, r3) => {
          const i3 = r3 && r3.backwards;
          if (n3 === false)
            return false;
          const { length: u3 } = t3;
          let o3 = n3;
          for (; o3 >= 0 && o3 < u3; ) {
            const n4 = t3.charAt(o3);
            if (e3 instanceof RegExp) {
              if (!e3.test(n4))
                return o3;
            } else if (!e3.includes(n4))
              return o3;
            i3 ? o3-- : o3++;
          }
          return (o3 === -1 || o3 === u3) && o3;
        };
      }
      const ci2 = ai2(/\s/), li2 = ai2(" 	"), pi2 = ai2(",; 	"), fi2 = ai2(/[^\n\r]/);
      function di2(e3, t3) {
        if (t3 === false)
          return false;
        if (e3.charAt(t3) === "/" && e3.charAt(t3 + 1) === "*") {
          for (let n3 = t3 + 2; n3 < e3.length; ++n3)
            if (e3.charAt(n3) === "*" && e3.charAt(n3 + 1) === "/")
              return n3 + 2;
        }
        return t3;
      }
      function hi2(e3, t3) {
        return t3 !== false && (e3.charAt(t3) === "/" && e3.charAt(t3 + 1) === "/" ? fi2(e3, t3) : t3);
      }
      function gi2(e3, t3, n3) {
        const r3 = n3 && n3.backwards;
        if (t3 === false)
          return false;
        const i3 = e3.charAt(t3);
        if (r3) {
          if (e3.charAt(t3 - 1) === "\r" && i3 === "\n")
            return t3 - 2;
          if (i3 === "\n" || i3 === "\r" || i3 === "\u2028" || i3 === "\u2029")
            return t3 - 1;
        } else {
          if (i3 === "\r" && e3.charAt(t3 + 1) === "\n")
            return t3 + 2;
          if (i3 === "\n" || i3 === "\r" || i3 === "\u2028" || i3 === "\u2029")
            return t3 + 1;
        }
        return t3;
      }
      function mi2(e3, t3, n3 = {}) {
        const r3 = li2(e3, n3.backwards ? t3 - 1 : t3, n3);
        return r3 !== gi2(e3, r3, n3);
      }
      function yi2(e3, t3) {
        let n3 = null, r3 = t3;
        for (; r3 !== n3; )
          n3 = r3, r3 = pi2(e3, r3), r3 = di2(e3, r3), r3 = li2(e3, r3);
        return r3 = hi2(e3, r3), r3 = gi2(e3, r3), r3 !== false && mi2(e3, r3);
      }
      function Di2(e3, t3) {
        let n3 = null, r3 = t3;
        for (; r3 !== n3; )
          n3 = r3, r3 = li2(e3, r3), r3 = di2(e3, r3), r3 = hi2(e3, r3), r3 = gi2(e3, r3);
        return r3;
      }
      function Ei2(e3, t3, n3) {
        return Di2(e3, n3(t3));
      }
      function Ci2(e3, t3, n3 = 0) {
        let r3 = 0;
        for (let i3 = n3; i3 < e3.length; ++i3)
          e3[i3] === "	" ? r3 = r3 + t3 - r3 % t3 : r3++;
        return r3;
      }
      function bi2(e3, t3) {
        const n3 = e3.slice(1, -1), r3 = { quote: '"', regex: /"/g }, i3 = { quote: "'", regex: /'/g }, u3 = t3 === "'" ? i3 : r3, o3 = u3 === i3 ? r3 : i3;
        let s3 = u3.quote;
        if (n3.includes(u3.quote) || n3.includes(o3.quote)) {
          s3 = (n3.match(u3.regex) || []).length > (n3.match(o3.regex) || []).length ? o3.quote : u3.quote;
        }
        return s3;
      }
      function Ai2(e3, t3, n3) {
        const r3 = t3 === '"' ? "'" : '"', i3 = e3.replace(/\\(.)|(["'])/gs, (e4, i4, u3) => i4 === r3 ? i4 : u3 === t3 ? "\\" + u3 : u3 || (n3 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i4) ? i4 : "\\" + i4));
        return t3 + i3 + t3;
      }
      function vi2(e3, t3) {
        (e3.comments || (e3.comments = [])).push(t3), t3.printed = false, t3.nodeDescription = function(e4) {
          const t4 = e4.type || e4.kind || "(unknown type)";
          let n3 = String(e4.name || e4.id && (typeof e4.id == "object" ? e4.id.name : e4.id) || e4.key && (typeof e4.key == "object" ? e4.key.name : e4.key) || e4.value && (typeof e4.value == "object" ? "" : String(e4.value)) || e4.operator || "");
          n3.length > 20 && (n3 = n3.slice(0, 19) + "\u2026");
          return t4 + (n3 ? " " + n3 : "");
        }(e3);
      }
      var Fi2 = { inferParserByLanguage: function(e3, t3) {
        const { languages: n3 } = oi2({ plugins: t3.plugins }), r3 = n3.find(({ name: t4 }) => t4.toLowerCase() === e3) || n3.find(({ aliases: t4 }) => Array.isArray(t4) && t4.includes(e3)) || n3.find(({ extensions: t4 }) => Array.isArray(t4) && t4.includes(`.${e3}`));
        return r3 && r3.parsers[0];
      }, getStringWidth: function(e3) {
        return e3 ? si2.test(e3) ? In2(e3) : e3.length : 0;
      }, getMaxContinuousCount: function(e3, t3) {
        const n3 = e3.match(new RegExp(`(${jn2(t3)})+`, "g"));
        return n3 === null ? 0 : n3.reduce((e4, n4) => Math.max(e4, n4.length / t3.length), 0);
      }, getMinNotPresentContinuousCount: function(e3, t3) {
        const n3 = e3.match(new RegExp(`(${jn2(t3)})+`, "g"));
        if (n3 === null)
          return 0;
        const r3 = new Map();
        let i3 = 0;
        for (const e4 of n3) {
          const n4 = e4.length / t3.length;
          r3.set(n4, true), n4 > i3 && (i3 = n4);
        }
        for (let e4 = 1; e4 < i3; e4++)
          if (!r3.get(e4))
            return e4;
        return i3 + 1;
      }, getPenultimate: (e3) => e3[e3.length - 2], getLast: _n2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Di2, getNextNonSpaceNonCommentCharacterIndex: Ei2, getNextNonSpaceNonCommentCharacter: function(e3, t3, n3) {
        return e3.charAt(Ei2(e3, t3, n3));
      }, skip: ai2, skipWhitespace: ci2, skipSpaces: li2, skipToLineEnd: pi2, skipEverythingButNewLine: fi2, skipInlineComment: di2, skipTrailingComment: hi2, skipNewline: gi2, isNextLineEmptyAfterIndex: yi2, isNextLineEmpty: function(e3, t3, n3) {
        return yi2(e3, n3(t3));
      }, isPreviousLineEmpty: function(e3, t3, n3) {
        let r3 = n3(t3) - 1;
        return r3 = li2(e3, r3, { backwards: true }), r3 = gi2(e3, r3, { backwards: true }), r3 = li2(e3, r3, { backwards: true }), r3 !== gi2(e3, r3, { backwards: true });
      }, hasNewline: mi2, hasNewlineInRange: function(e3, t3, n3) {
        for (let r3 = t3; r3 < n3; ++r3)
          if (e3.charAt(r3) === "\n")
            return true;
        return false;
      }, hasSpaces: function(e3, t3, n3 = {}) {
        return li2(e3, n3.backwards ? t3 - 1 : t3, n3) !== t3;
      }, getAlignmentSize: Ci2, getIndentSize: function(e3, t3) {
        const n3 = e3.lastIndexOf("\n");
        return n3 === -1 ? 0 : Ci2(e3.slice(n3 + 1).match(/^[\t ]*/)[0], t3);
      }, getPreferredQuote: bi2, printString: function(e3, t3) {
        return Ai2(e3.slice(1, -1), t3.parser === "json" || t3.parser === "json5" && t3.quoteProps === "preserve" && !t3.singleQuote ? '"' : t3.__isInHtmlAttribute ? "'" : bi2(e3, t3.singleQuote ? "'" : '"'), !(t3.parser === "css" || t3.parser === "less" || t3.parser === "scss" || t3.__embeddedInHtml));
      }, printNumber: function(e3) {
        return e3.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
      }, makeString: Ai2, addLeadingComment: function(e3, t3) {
        t3.leading = true, t3.trailing = false, vi2(e3, t3);
      }, addDanglingComment: function(e3, t3, n3) {
        t3.leading = false, t3.trailing = false, n3 && (t3.marker = n3), vi2(e3, t3);
      }, addTrailingComment: function(e3, t3) {
        t3.leading = false, t3.trailing = true, vi2(e3, t3);
      }, isFrontMatterNode: function(e3) {
        return e3 && e3.type === "front-matter";
      }, getShebang: function(e3) {
        if (!e3.startsWith("#!"))
          return "";
        const t3 = e3.indexOf("\n");
        return t3 === -1 ? e3 : e3.slice(0, t3);
      }, isNonEmptyArray: function(e3) {
        return Array.isArray(e3) && e3.length > 0;
      }, createGroupIdMapper: function(e3) {
        const t3 = new WeakMap();
        return function(n3) {
          return t3.has(n3) || t3.set(n3, Symbol(e3)), t3.get(n3);
        };
      } };
      var xi2 = { guessEndOfLine: function(e3) {
        const t3 = e3.indexOf("\r");
        return t3 >= 0 ? e3.charAt(t3 + 1) === "\n" ? "crlf" : "cr" : "lf";
      }, convertEndOfLineToChars: function(e3) {
        switch (e3) {
          case "cr":
            return "\r";
          case "crlf":
            return "\r\n";
          default:
            return "\n";
        }
      }, countEndOfLineChars: function(e3, t3) {
        let n3;
        if (t3 === "\n")
          n3 = /\n/g;
        else if (t3 === "\r")
          n3 = /\r/g;
        else {
          if (t3 !== "\r\n")
            throw new Error(`Unexpected "eol" ${JSON.stringify(t3)}.`);
          n3 = /\r\n/g;
        }
        const r3 = e3.match(n3);
        return r3 ? r3.length : 0;
      }, normalizeEndOfLine: function(e3) {
        return e3.replace(/\r\n?/g, "\n");
      } };
      const { literalline: Si2, join: wi2 } = Tn2, Ti2 = (e3) => Array.isArray(e3) || e3 && e3.type === "concat", Bi2 = (e3) => {
        if (Array.isArray(e3))
          return e3;
        if (e3.type !== "concat" && e3.type !== "fill")
          throw new Error("Expect doc type to be `concat` or `fill`.");
        return e3.parts;
      }, Ni2 = {};
      function ki2(e3, t3, n3, r3) {
        const i3 = [e3];
        for (; i3.length > 0; ) {
          const e4 = i3.pop();
          if (e4 !== Ni2) {
            if (n3 && i3.push(e4, Ni2), !t3 || t3(e4) !== false)
              if (Ti2(e4) || e4.type === "fill") {
                const t4 = Bi2(e4);
                for (let e5 = t4.length - 1; e5 >= 0; --e5)
                  i3.push(t4[e5]);
              } else if (e4.type === "if-break")
                e4.flatContents && i3.push(e4.flatContents), e4.breakContents && i3.push(e4.breakContents);
              else if (e4.type === "group" && e4.expandedStates)
                if (r3)
                  for (let t4 = e4.expandedStates.length - 1; t4 >= 0; --t4)
                    i3.push(e4.expandedStates[t4]);
                else
                  i3.push(e4.contents);
              else
                e4.contents && i3.push(e4.contents);
          } else
            n3(i3.pop());
        }
      }
      function Pi2(e3, t3) {
        const n3 = new Map();
        return r3(e3);
        function r3(e4) {
          if (n3.has(e4))
            return n3.get(e4);
          const i3 = function(e5) {
            if (Array.isArray(e5))
              return t3(e5.map(r3));
            if (e5.type === "concat" || e5.type === "fill") {
              const n4 = e5.parts.map(r3);
              return t3(Object.assign(Object.assign({}, e5), {}, { parts: n4 }));
            }
            if (e5.type === "if-break") {
              const n4 = e5.breakContents && r3(e5.breakContents), i4 = e5.flatContents && r3(e5.flatContents);
              return t3(Object.assign(Object.assign({}, e5), {}, { breakContents: n4, flatContents: i4 }));
            }
            if (e5.type === "group" && e5.expandedStates) {
              const n4 = e5.expandedStates.map(r3), i4 = n4[0];
              return t3(Object.assign(Object.assign({}, e5), {}, { contents: i4, expandedStates: n4 }));
            }
            if (e5.contents) {
              const n4 = r3(e5.contents);
              return t3(Object.assign(Object.assign({}, e5), {}, { contents: n4 }));
            }
            return t3(e5);
          }(e4);
          return n3.set(e4, i3), i3;
        }
      }
      function Oi2(e3, t3, n3) {
        let r3 = n3, i3 = false;
        return ki2(e3, function(e4) {
          const n4 = t3(e4);
          if (n4 !== void 0 && (i3 = true, r3 = n4), i3)
            return false;
        }), r3;
      }
      function Ii2(e3) {
        return !(e3.type !== "group" || !e3.break) || (!(e3.type !== "line" || !e3.hard) || (e3.type === "break-parent" || void 0));
      }
      function Li2(e3) {
        if (e3.length > 0) {
          const t3 = _n2(e3);
          t3.expandedStates || t3.break || (t3.break = "propagated");
        }
        return null;
      }
      function ji2(e3) {
        return e3.type !== "line" || e3.hard ? e3.type === "if-break" ? e3.flatContents || "" : e3 : e3.soft ? "" : " ";
      }
      const _i2 = (e3, t3) => e3 && e3.type === "line" && e3.hard && t3 && t3.type === "break-parent";
      function Mi2(e3) {
        if (!e3)
          return e3;
        if (Ti2(e3) || e3.type === "fill") {
          const t3 = Bi2(e3);
          for (; t3.length > 1 && _i2(...t3.slice(-2)); )
            t3.length -= 2;
          if (t3.length > 0) {
            const e4 = Mi2(_n2(t3));
            t3[t3.length - 1] = e4;
          }
          return Array.isArray(e3) ? t3 : Object.assign(Object.assign({}, e3), {}, { parts: t3 });
        }
        switch (e3.type) {
          case "align":
          case "indent":
          case "indent-if-break":
          case "group":
          case "line-suffix":
          case "label": {
            const t3 = Mi2(e3.contents);
            return Object.assign(Object.assign({}, e3), {}, { contents: t3 });
          }
          case "if-break": {
            const t3 = Mi2(e3.breakContents), n3 = Mi2(e3.flatContents);
            return Object.assign(Object.assign({}, e3), {}, { breakContents: t3, flatContents: n3 });
          }
        }
        return e3;
      }
      function Ri2(e3) {
        return Pi2(e3, (e4) => function(e5) {
          switch (e5.type) {
            case "fill":
              if (e5.parts.length === 0 || e5.parts.every((e6) => e6 === ""))
                return "";
              break;
            case "group":
              if (!(e5.contents || e5.id || e5.break || e5.expandedStates))
                return "";
              if (e5.contents.type === "group" && e5.contents.id === e5.id && e5.contents.break === e5.break && e5.contents.expandedStates === e5.expandedStates)
                return e5.contents;
              break;
            case "align":
            case "indent":
            case "indent-if-break":
            case "line-suffix":
              if (!e5.contents)
                return "";
              break;
            case "if-break":
              if (!e5.flatContents && !e5.breakContents)
                return "";
          }
          if (!Ti2(e5))
            return e5;
          const t3 = [];
          for (const n3 of Bi2(e5)) {
            if (!n3)
              continue;
            const [e6, ...r3] = Ti2(n3) ? Bi2(n3) : [n3];
            typeof e6 == "string" && typeof _n2(t3) == "string" ? t3[t3.length - 1] += e6 : t3.push(e6), t3.push(...r3);
          }
          return t3.length === 0 ? "" : t3.length === 1 ? t3[0] : Array.isArray(e5) ? t3 : Object.assign(Object.assign({}, e5), {}, { parts: t3 });
        }(e4));
      }
      function $i2(e3) {
        const t3 = [], n3 = e3.filter(Boolean);
        for (; n3.length > 0; ) {
          const e4 = n3.shift();
          e4 && (Ti2(e4) ? n3.unshift(...Bi2(e4)) : t3.length > 0 && typeof _n2(t3) == "string" && typeof e4 == "string" ? t3[t3.length - 1] += e4 : t3.push(e4));
        }
        return t3;
      }
      function Vi2(e3, t3 = Si2) {
        return wi2(t3, e3.split("\n")).parts;
      }
      var Wi2 = { isConcat: Ti2, getDocParts: Bi2, willBreak: function(e3) {
        return Oi2(e3, Ii2, false);
      }, traverseDoc: ki2, findInDoc: Oi2, mapDoc: Pi2, propagateBreaks: function(e3) {
        const t3 = new Set(), n3 = [];
        ki2(e3, function(e4) {
          if (e4.type === "break-parent" && Li2(n3), e4.type === "group") {
            if (n3.push(e4), t3.has(e4))
              return false;
            t3.add(e4);
          }
        }, function(e4) {
          if (e4.type === "group") {
            n3.pop().break && Li2(n3);
          }
        }, true);
      }, removeLines: function(e3) {
        return Pi2(e3, ji2);
      }, stripTrailingHardline: function(e3) {
        return Mi2(Ri2(e3));
      }, normalizeParts: $i2, normalizeDoc: function(e3) {
        return Pi2(e3, (e4) => Array.isArray(e4) ? $i2(e4) : e4.parts ? Object.assign(Object.assign({}, e4), {}, { parts: $i2(e4.parts) }) : e4);
      }, cleanDoc: Ri2, replaceTextEndOfLine: Vi2, replaceEndOfLine: function(e3) {
        return Pi2(e3, (e4) => typeof e4 == "string" && e4.includes("\n") ? Vi2(e4) : e4);
      } };
      const { getStringWidth: qi2, getLast: Ui2 } = Fi2, { convertEndOfLineToChars: zi2 } = xi2, { fill: Gi2, cursor: Hi2, indent: Ji2 } = Tn2, { isConcat: Xi2, getDocParts: Yi2 } = Wi2;
      let Ki2;
      function Qi2(e3, t3) {
        return eu2(e3, { type: "indent" }, t3);
      }
      function Zi2(e3, t3, n3) {
        if (t3 === Number.NEGATIVE_INFINITY)
          return e3.root || { value: "", length: 0, queue: [] };
        if (t3 < 0)
          return eu2(e3, { type: "dedent" }, n3);
        if (!t3)
          return e3;
        if (t3.type === "root")
          return Object.assign(Object.assign({}, e3), {}, { root: e3 });
        return eu2(e3, { type: typeof t3 == "string" ? "stringAlign" : "numberAlign", n: t3 }, n3);
      }
      function eu2(e3, t3, n3) {
        const r3 = t3.type === "dedent" ? e3.queue.slice(0, -1) : [...e3.queue, t3];
        let i3 = "", u3 = 0, o3 = 0, s3 = 0;
        for (const e4 of r3)
          switch (e4.type) {
            case "indent":
              l3(), n3.useTabs ? a3(1) : c3(n3.tabWidth);
              break;
            case "stringAlign":
              l3(), i3 += e4.n, u3 += e4.n.length;
              break;
            case "numberAlign":
              o3 += 1, s3 += e4.n;
              break;
            default:
              throw new Error(`Unexpected type '${e4.type}'`);
          }
        return p3(), Object.assign(Object.assign({}, e3), {}, { value: i3, length: u3, queue: r3 });
        function a3(e4) {
          i3 += "	".repeat(e4), u3 += n3.tabWidth * e4;
        }
        function c3(e4) {
          i3 += " ".repeat(e4), u3 += e4;
        }
        function l3() {
          n3.useTabs ? function() {
            o3 > 0 && a3(o3);
            f3();
          }() : p3();
        }
        function p3() {
          s3 > 0 && c3(s3), f3();
        }
        function f3() {
          o3 = 0, s3 = 0;
        }
      }
      function tu2(e3) {
        if (e3.length === 0)
          return 0;
        let t3 = 0;
        for (; e3.length > 0 && typeof Ui2(e3) == "string" && /^[\t ]*$/.test(Ui2(e3)); )
          t3 += e3.pop().length;
        if (e3.length > 0 && typeof Ui2(e3) == "string") {
          const n3 = Ui2(e3).replace(/[\t ]*$/, "");
          t3 += Ui2(e3).length - n3.length, e3[e3.length - 1] = n3;
        }
        return t3;
      }
      function nu2(e3, t3, n3, r3, i3, u3) {
        let o3 = t3.length;
        const s3 = [e3], a3 = [];
        for (; n3 >= 0; ) {
          if (s3.length === 0) {
            if (o3 === 0)
              return true;
            s3.push(t3[o3 - 1]), o3--;
            continue;
          }
          const [e4, c3, l3] = s3.pop();
          if (typeof l3 == "string")
            a3.push(l3), n3 -= qi2(l3);
          else if (Xi2(l3)) {
            const t4 = Yi2(l3);
            for (let n4 = t4.length - 1; n4 >= 0; n4--)
              s3.push([e4, c3, t4[n4]]);
          } else
            switch (l3.type) {
              case "indent":
                s3.push([Qi2(e4, r3), c3, l3.contents]);
                break;
              case "align":
                s3.push([Zi2(e4, l3.n, r3), c3, l3.contents]);
                break;
              case "trim":
                n3 += tu2(a3);
                break;
              case "group": {
                if (u3 && l3.break)
                  return false;
                const t4 = l3.break ? 1 : c3;
                s3.push([e4, t4, l3.expandedStates && t4 === 1 ? Ui2(l3.expandedStates) : l3.contents]), l3.id && (Ki2[l3.id] = t4);
                break;
              }
              case "fill":
                for (let t4 = l3.parts.length - 1; t4 >= 0; t4--)
                  s3.push([e4, c3, l3.parts[t4]]);
                break;
              case "if-break":
              case "indent-if-break": {
                const t4 = l3.groupId ? Ki2[l3.groupId] : c3;
                if (t4 === 1) {
                  const t5 = l3.type === "if-break" ? l3.breakContents : l3.negate ? l3.contents : Ji2(l3.contents);
                  t5 && s3.push([e4, c3, t5]);
                }
                if (t4 === 2) {
                  const t5 = l3.type === "if-break" ? l3.flatContents : l3.negate ? Ji2(l3.contents) : l3.contents;
                  t5 && s3.push([e4, c3, t5]);
                }
                break;
              }
              case "line":
                switch (c3) {
                  case 2:
                    if (!l3.hard) {
                      l3.soft || (a3.push(" "), n3 -= 1);
                      break;
                    }
                    return true;
                  case 1:
                    return true;
                }
                break;
              case "line-suffix":
                i3 = true;
                break;
              case "line-suffix-boundary":
                if (i3)
                  return false;
                break;
              case "label":
                s3.push([e4, c3, l3.contents]);
            }
        }
        return false;
      }
      var ru2 = { printDocToString: function(e3, t3) {
        Ki2 = {};
        const n3 = t3.printWidth, r3 = zi2(t3.endOfLine);
        let i3 = 0;
        const u3 = [[{ value: "", length: 0, queue: [] }, 1, e3]], o3 = [];
        let s3 = false, a3 = [];
        for (; u3.length > 0; ) {
          const [e4, c4, l3] = u3.pop();
          if (typeof l3 == "string") {
            const e5 = r3 !== "\n" ? l3.replace(/\n/g, r3) : l3;
            o3.push(e5), i3 += qi2(e5);
          } else if (Xi2(l3)) {
            const t4 = Yi2(l3);
            for (let n4 = t4.length - 1; n4 >= 0; n4--)
              u3.push([e4, c4, t4[n4]]);
          } else
            switch (l3.type) {
              case "cursor":
                o3.push(Hi2.placeholder);
                break;
              case "indent":
                u3.push([Qi2(e4, t3), c4, l3.contents]);
                break;
              case "align":
                u3.push([Zi2(e4, l3.n, t3), c4, l3.contents]);
                break;
              case "trim":
                i3 -= tu2(o3);
                break;
              case "group":
                switch (c4) {
                  case 2:
                    if (!s3) {
                      u3.push([e4, l3.break ? 1 : 2, l3.contents]);
                      break;
                    }
                  case 1: {
                    s3 = false;
                    const r4 = [e4, 2, l3.contents], o4 = n3 - i3, c5 = a3.length > 0;
                    if (!l3.break && nu2(r4, u3, o4, t3, c5))
                      u3.push(r4);
                    else if (l3.expandedStates) {
                      const n4 = Ui2(l3.expandedStates);
                      if (l3.break) {
                        u3.push([e4, 1, n4]);
                        break;
                      }
                      for (let r5 = 1; r5 < l3.expandedStates.length + 1; r5++) {
                        if (r5 >= l3.expandedStates.length) {
                          u3.push([e4, 1, n4]);
                          break;
                        }
                        {
                          const n5 = [e4, 2, l3.expandedStates[r5]];
                          if (nu2(n5, u3, o4, t3, c5)) {
                            u3.push(n5);
                            break;
                          }
                        }
                      }
                    } else
                      u3.push([e4, 1, l3.contents]);
                    break;
                  }
                }
                l3.id && (Ki2[l3.id] = Ui2(u3)[1]);
                break;
              case "fill": {
                const r4 = n3 - i3, { parts: o4 } = l3;
                if (o4.length === 0)
                  break;
                const [s4, p3] = o4, f3 = [e4, 2, s4], d3 = [e4, 1, s4], h3 = nu2(f3, [], r4, t3, a3.length > 0, true);
                if (o4.length === 1) {
                  h3 ? u3.push(f3) : u3.push(d3);
                  break;
                }
                const g3 = [e4, 2, p3], m3 = [e4, 1, p3];
                if (o4.length === 2) {
                  h3 ? u3.push(g3, f3) : u3.push(m3, d3);
                  break;
                }
                o4.splice(0, 2);
                const y3 = [e4, c4, Gi2(o4)];
                nu2([e4, 2, [s4, p3, o4[0]]], [], r4, t3, a3.length > 0, true) ? u3.push(y3, g3, f3) : h3 ? u3.push(y3, m3, f3) : u3.push(y3, m3, d3);
                break;
              }
              case "if-break":
              case "indent-if-break": {
                const t4 = l3.groupId ? Ki2[l3.groupId] : c4;
                if (t4 === 1) {
                  const t5 = l3.type === "if-break" ? l3.breakContents : l3.negate ? l3.contents : Ji2(l3.contents);
                  t5 && u3.push([e4, c4, t5]);
                }
                if (t4 === 2) {
                  const t5 = l3.type === "if-break" ? l3.flatContents : l3.negate ? Ji2(l3.contents) : l3.contents;
                  t5 && u3.push([e4, c4, t5]);
                }
                break;
              }
              case "line-suffix":
                a3.push([e4, c4, l3.contents]);
                break;
              case "line-suffix-boundary":
                a3.length > 0 && u3.push([e4, c4, { type: "line", hard: true }]);
                break;
              case "line":
                switch (c4) {
                  case 2:
                    if (!l3.hard) {
                      l3.soft || (o3.push(" "), i3 += 1);
                      break;
                    }
                    s3 = true;
                  case 1:
                    if (a3.length > 0) {
                      u3.push([e4, c4, l3], ...a3.reverse()), a3 = [];
                      break;
                    }
                    l3.literal ? e4.root ? (o3.push(r3, e4.root.value), i3 = e4.root.length) : (o3.push(r3), i3 = 0) : (i3 -= tu2(o3), o3.push(r3 + e4.value), i3 = e4.length);
                }
                break;
              case "label":
                u3.push([e4, c4, l3.contents]);
            }
          u3.length === 0 && a3.length > 0 && (u3.push(...a3.reverse()), a3 = []);
        }
        const c3 = o3.indexOf(Hi2.placeholder);
        if (c3 !== -1) {
          const e4 = o3.indexOf(Hi2.placeholder, c3 + 1), t4 = o3.slice(0, c3).join(""), n4 = o3.slice(c3 + 1, e4).join("");
          return { formatted: t4 + n4 + o3.slice(e4 + 1).join(""), cursorNodeStart: t4.length, cursorNodeText: n4 };
        }
        return { formatted: o3.join("") };
      } };
      const { isConcat: iu2, getDocParts: uu2 } = Wi2;
      function ou2(e3) {
        if (!e3)
          return "";
        if (iu2(e3)) {
          const t3 = [];
          for (const n3 of uu2(e3))
            if (iu2(n3))
              t3.push(...ou2(n3).parts);
            else {
              const e4 = ou2(n3);
              e4 !== "" && t3.push(e4);
            }
          return { type: "concat", parts: t3 };
        }
        return e3.type === "if-break" ? Object.assign(Object.assign({}, e3), {}, { breakContents: ou2(e3.breakContents), flatContents: ou2(e3.flatContents) }) : e3.type === "group" ? Object.assign(Object.assign({}, e3), {}, { contents: ou2(e3.contents), expandedStates: e3.expandedStates && e3.expandedStates.map(ou2) }) : e3.type === "fill" ? { type: "fill", parts: e3.parts.map(ou2) } : e3.contents ? Object.assign(Object.assign({}, e3), {}, { contents: ou2(e3.contents) }) : e3;
      }
      var su2 = { builders: Tn2, printer: ru2, utils: Wi2, debug: { printDocToDebug: function(e3) {
        const t3 = Object.create(null), n3 = new Set();
        return function e4(t4, n4, i3) {
          if (typeof t4 == "string")
            return JSON.stringify(t4);
          if (iu2(t4)) {
            const n5 = uu2(t4).map(e4).filter(Boolean);
            return n5.length === 1 ? n5[0] : `[${n5.join(", ")}]`;
          }
          if (t4.type === "line") {
            const e5 = Array.isArray(i3) && i3[n4 + 1] && i3[n4 + 1].type === "break-parent";
            return t4.literal ? e5 ? "literalline" : "literallineWithoutBreakParent" : t4.hard ? e5 ? "hardline" : "hardlineWithoutBreakParent" : t4.soft ? "softline" : "line";
          }
          if (t4.type === "break-parent") {
            return Array.isArray(i3) && i3[n4 - 1] && i3[n4 - 1].type === "line" && i3[n4 - 1].hard ? void 0 : "breakParent";
          }
          if (t4.type === "trim")
            return "trim";
          if (t4.type === "indent")
            return "indent(" + e4(t4.contents) + ")";
          if (t4.type === "align")
            return t4.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e4(t4.contents) + ")" : t4.n < 0 ? "dedent(" + e4(t4.contents) + ")" : t4.n.type === "root" ? "markAsRoot(" + e4(t4.contents) + ")" : "align(" + JSON.stringify(t4.n) + ", " + e4(t4.contents) + ")";
          if (t4.type === "if-break")
            return "ifBreak(" + e4(t4.breakContents) + (t4.flatContents ? ", " + e4(t4.flatContents) : "") + (t4.groupId ? (t4.flatContents ? "" : ', ""') + `, { groupId: ${r3(t4.groupId)} }` : "") + ")";
          if (t4.type === "indent-if-break") {
            const n5 = [];
            t4.negate && n5.push("negate: true"), t4.groupId && n5.push(`groupId: ${r3(t4.groupId)}`);
            const i4 = n5.length > 0 ? `, { ${n5.join(", ")} }` : "";
            return `indentIfBreak(${e4(t4.contents)}${i4})`;
          }
          if (t4.type === "group") {
            const n5 = [];
            t4.break && t4.break !== "propagated" && n5.push("shouldBreak: true"), t4.id && n5.push(`id: ${r3(t4.id)}`);
            const i4 = n5.length > 0 ? `, { ${n5.join(", ")} }` : "";
            return t4.expandedStates ? `conditionalGroup([${t4.expandedStates.map((t5) => e4(t5)).join(",")}]${i4})` : `group(${e4(t4.contents)}${i4})`;
          }
          if (t4.type === "fill")
            return `fill([${t4.parts.map((t5) => e4(t5)).join(", ")}])`;
          if (t4.type === "line-suffix")
            return "lineSuffix(" + e4(t4.contents) + ")";
          if (t4.type === "line-suffix-boundary")
            return "lineSuffixBoundary";
          if (t4.type === "label")
            return `label(${JSON.stringify(t4.label)}, ${e4(t4.contents)})`;
          throw new Error("Unknown doc type " + t4.type);
        }(ou2(e3));
        function r3(e4) {
          if (typeof e4 != "symbol")
            return JSON.stringify(String(e4));
          if (e4 in t3)
            return t3[e4];
          const r4 = String(e4).slice(7, -1) || "symbol";
          for (let i3 = 0; ; i3++) {
            const u3 = r4 + (i3 > 0 ? ` #${i3}` : "");
            if (!n3.has(u3))
              return n3.add(u3), t3[e4] = `Symbol.for(${JSON.stringify(u3)})`;
          }
        }
      } } }, au2 = Object.freeze({ __proto__: null, default: {} });
      function cu2(e3, t3) {
        for (var n3 = 0, r3 = e3.length - 1; r3 >= 0; r3--) {
          var i3 = e3[r3];
          i3 === "." ? e3.splice(r3, 1) : i3 === ".." ? (e3.splice(r3, 1), n3++) : n3 && (e3.splice(r3, 1), n3--);
        }
        if (t3)
          for (; n3--; n3)
            e3.unshift("..");
        return e3;
      }
      var lu2 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, pu2 = function(e3) {
        return lu2.exec(e3).slice(1);
      };
      function fu2() {
        for (var e3 = "", t3 = false, n3 = arguments.length - 1; n3 >= -1 && !t3; n3--) {
          var r3 = n3 >= 0 ? arguments[n3] : "/";
          if (typeof r3 != "string")
            throw new TypeError("Arguments to path.resolve must be strings");
          r3 && (e3 = r3 + "/" + e3, t3 = r3.charAt(0) === "/");
        }
        return (t3 ? "/" : "") + (e3 = cu2(bu2(e3.split("/"), function(e4) {
          return !!e4;
        }), !t3).join("/")) || ".";
      }
      function du2(e3) {
        var t3 = hu2(e3), n3 = Au2(e3, -1) === "/";
        return (e3 = cu2(bu2(e3.split("/"), function(e4) {
          return !!e4;
        }), !t3).join("/")) || t3 || (e3 = "."), e3 && n3 && (e3 += "/"), (t3 ? "/" : "") + e3;
      }
      function hu2(e3) {
        return e3.charAt(0) === "/";
      }
      function gu2() {
        var e3 = Array.prototype.slice.call(arguments, 0);
        return du2(bu2(e3, function(e4, t3) {
          if (typeof e4 != "string")
            throw new TypeError("Arguments to path.join must be strings");
          return e4;
        }).join("/"));
      }
      function mu2(e3, t3) {
        function n3(e4) {
          for (var t4 = 0; t4 < e4.length && e4[t4] === ""; t4++)
            ;
          for (var n4 = e4.length - 1; n4 >= 0 && e4[n4] === ""; n4--)
            ;
          return t4 > n4 ? [] : e4.slice(t4, n4 - t4 + 1);
        }
        e3 = fu2(e3).substr(1), t3 = fu2(t3).substr(1);
        for (var r3 = n3(e3.split("/")), i3 = n3(t3.split("/")), u3 = Math.min(r3.length, i3.length), o3 = u3, s3 = 0; s3 < u3; s3++)
          if (r3[s3] !== i3[s3]) {
            o3 = s3;
            break;
          }
        var a3 = [];
        for (s3 = o3; s3 < r3.length; s3++)
          a3.push("..");
        return (a3 = a3.concat(i3.slice(o3))).join("/");
      }
      function yu2(e3) {
        var t3 = pu2(e3), n3 = t3[0], r3 = t3[1];
        return n3 || r3 ? (r3 && (r3 = r3.substr(0, r3.length - 1)), n3 + r3) : ".";
      }
      function Du2(e3, t3) {
        var n3 = pu2(e3)[2];
        return t3 && n3.substr(-1 * t3.length) === t3 && (n3 = n3.substr(0, n3.length - t3.length)), n3;
      }
      function Eu2(e3) {
        return pu2(e3)[3];
      }
      var Cu2 = { extname: Eu2, basename: Du2, dirname: yu2, sep: "/", delimiter: ":", relative: mu2, join: gu2, isAbsolute: hu2, normalize: du2, resolve: fu2 };
      function bu2(e3, t3) {
        if (e3.filter)
          return e3.filter(t3);
        for (var n3 = [], r3 = 0; r3 < e3.length; r3++)
          t3(e3[r3], r3, e3) && n3.push(e3[r3]);
        return n3;
      }
      var Au2 = "ab".substr(-1) === "b" ? function(e3, t3, n3) {
        return e3.substr(t3, n3);
      } : function(e3, t3, n3) {
        return t3 < 0 && (t3 = e3.length + t3), e3.substr(t3, n3);
      }, vu2 = Object.freeze({ __proto__: null, resolve: fu2, normalize: du2, isAbsolute: hu2, join: gu2, relative: mu2, sep: "/", delimiter: ":", dirname: yu2, basename: Du2, extname: Eu2, default: Cu2 }), Fu2 = [], xu2 = [], Su2 = typeof Uint8Array != "undefined" ? Uint8Array : Array, wu2 = false;
      function Tu2() {
        wu2 = true;
        for (var e3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t3 = 0, n3 = e3.length; t3 < n3; ++t3)
          Fu2[t3] = e3[t3], xu2[e3.charCodeAt(t3)] = t3;
        xu2["-".charCodeAt(0)] = 62, xu2["_".charCodeAt(0)] = 63;
      }
      function Bu2(e3, t3, n3) {
        for (var r3, i3, u3 = [], o3 = t3; o3 < n3; o3 += 3)
          r3 = (e3[o3] << 16) + (e3[o3 + 1] << 8) + e3[o3 + 2], u3.push(Fu2[(i3 = r3) >> 18 & 63] + Fu2[i3 >> 12 & 63] + Fu2[i3 >> 6 & 63] + Fu2[63 & i3]);
        return u3.join("");
      }
      function Nu2(e3) {
        var t3;
        wu2 || Tu2();
        for (var n3 = e3.length, r3 = n3 % 3, i3 = "", u3 = [], o3 = 16383, s3 = 0, a3 = n3 - r3; s3 < a3; s3 += o3)
          u3.push(Bu2(e3, s3, s3 + o3 > a3 ? a3 : s3 + o3));
        return r3 === 1 ? (t3 = e3[n3 - 1], i3 += Fu2[t3 >> 2], i3 += Fu2[t3 << 4 & 63], i3 += "==") : r3 === 2 && (t3 = (e3[n3 - 2] << 8) + e3[n3 - 1], i3 += Fu2[t3 >> 10], i3 += Fu2[t3 >> 4 & 63], i3 += Fu2[t3 << 2 & 63], i3 += "="), u3.push(i3), u3.join("");
      }
      function ku2(e3, t3, n3, r3, i3) {
        var u3, o3, s3 = 8 * i3 - r3 - 1, a3 = (1 << s3) - 1, c3 = a3 >> 1, l3 = -7, p3 = n3 ? i3 - 1 : 0, f3 = n3 ? -1 : 1, d3 = e3[t3 + p3];
        for (p3 += f3, u3 = d3 & (1 << -l3) - 1, d3 >>= -l3, l3 += s3; l3 > 0; u3 = 256 * u3 + e3[t3 + p3], p3 += f3, l3 -= 8)
          ;
        for (o3 = u3 & (1 << -l3) - 1, u3 >>= -l3, l3 += r3; l3 > 0; o3 = 256 * o3 + e3[t3 + p3], p3 += f3, l3 -= 8)
          ;
        if (u3 === 0)
          u3 = 1 - c3;
        else {
          if (u3 === a3)
            return o3 ? NaN : 1 / 0 * (d3 ? -1 : 1);
          o3 += Math.pow(2, r3), u3 -= c3;
        }
        return (d3 ? -1 : 1) * o3 * Math.pow(2, u3 - r3);
      }
      function Pu2(e3, t3, n3, r3, i3, u3) {
        var o3, s3, a3, c3 = 8 * u3 - i3 - 1, l3 = (1 << c3) - 1, p3 = l3 >> 1, f3 = i3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d3 = r3 ? 0 : u3 - 1, h3 = r3 ? 1 : -1, g3 = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
        for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (s3 = isNaN(t3) ? 1 : 0, o3 = l3) : (o3 = Math.floor(Math.log(t3) / Math.LN2), t3 * (a3 = Math.pow(2, -o3)) < 1 && (o3--, a3 *= 2), (t3 += o3 + p3 >= 1 ? f3 / a3 : f3 * Math.pow(2, 1 - p3)) * a3 >= 2 && (o3++, a3 /= 2), o3 + p3 >= l3 ? (s3 = 0, o3 = l3) : o3 + p3 >= 1 ? (s3 = (t3 * a3 - 1) * Math.pow(2, i3), o3 += p3) : (s3 = t3 * Math.pow(2, p3 - 1) * Math.pow(2, i3), o3 = 0)); i3 >= 8; e3[n3 + d3] = 255 & s3, d3 += h3, s3 /= 256, i3 -= 8)
          ;
        for (o3 = o3 << i3 | s3, c3 += i3; c3 > 0; e3[n3 + d3] = 255 & o3, d3 += h3, o3 /= 256, c3 -= 8)
          ;
        e3[n3 + d3 - h3] |= 128 * g3;
      }
      var Ou2 = {}.toString, Iu2 = Array.isArray || function(e3) {
        return Ou2.call(e3) == "[object Array]";
      };
      function Lu2() {
        return _u2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function ju2(e3, t3) {
        if (Lu2() < t3)
          throw new RangeError("Invalid typed array length");
        return _u2.TYPED_ARRAY_SUPPORT ? (e3 = new Uint8Array(t3)).__proto__ = _u2.prototype : (e3 === null && (e3 = new _u2(t3)), e3.length = t3), e3;
      }
      function _u2(e3, t3, n3) {
        if (!(_u2.TYPED_ARRAY_SUPPORT || this instanceof _u2))
          return new _u2(e3, t3, n3);
        if (typeof e3 == "number") {
          if (typeof t3 == "string")
            throw new Error("If encoding is specified then the first argument must be a string");
          return $u2(this, e3);
        }
        return Mu2(this, e3, t3, n3);
      }
      function Mu2(e3, t3, n3, r3) {
        if (typeof t3 == "number")
          throw new TypeError('"value" argument must not be a number');
        return typeof ArrayBuffer != "undefined" && t3 instanceof ArrayBuffer ? function(e4, t4, n4, r4) {
          if (t4.byteLength, n4 < 0 || t4.byteLength < n4)
            throw new RangeError("'offset' is out of bounds");
          if (t4.byteLength < n4 + (r4 || 0))
            throw new RangeError("'length' is out of bounds");
          t4 = n4 === void 0 && r4 === void 0 ? new Uint8Array(t4) : r4 === void 0 ? new Uint8Array(t4, n4) : new Uint8Array(t4, n4, r4);
          _u2.TYPED_ARRAY_SUPPORT ? (e4 = t4).__proto__ = _u2.prototype : e4 = Vu2(e4, t4);
          return e4;
        }(e3, t3, n3, r3) : typeof t3 == "string" ? function(e4, t4, n4) {
          typeof n4 == "string" && n4 !== "" || (n4 = "utf8");
          if (!_u2.isEncoding(n4))
            throw new TypeError('"encoding" must be a valid string encoding');
          var r4 = 0 | Uu2(t4, n4), i3 = (e4 = ju2(e4, r4)).write(t4, n4);
          i3 !== r4 && (e4 = e4.slice(0, i3));
          return e4;
        }(e3, t3, n3) : function(e4, t4) {
          if (qu2(t4)) {
            var n4 = 0 | Wu2(t4.length);
            return (e4 = ju2(e4, n4)).length === 0 || t4.copy(e4, 0, 0, n4), e4;
          }
          if (t4) {
            if (typeof ArrayBuffer != "undefined" && t4.buffer instanceof ArrayBuffer || "length" in t4)
              return typeof t4.length != "number" || (r4 = t4.length) != r4 ? ju2(e4, 0) : Vu2(e4, t4);
            if (t4.type === "Buffer" && Iu2(t4.data))
              return Vu2(e4, t4.data);
          }
          var r4;
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }(e3, t3);
      }
      function Ru2(e3) {
        if (typeof e3 != "number")
          throw new TypeError('"size" argument must be a number');
        if (e3 < 0)
          throw new RangeError('"size" argument must not be negative');
      }
      function $u2(e3, t3) {
        if (Ru2(t3), e3 = ju2(e3, t3 < 0 ? 0 : 0 | Wu2(t3)), !_u2.TYPED_ARRAY_SUPPORT)
          for (var n3 = 0; n3 < t3; ++n3)
            e3[n3] = 0;
        return e3;
      }
      function Vu2(e3, t3) {
        var n3 = t3.length < 0 ? 0 : 0 | Wu2(t3.length);
        e3 = ju2(e3, n3);
        for (var r3 = 0; r3 < n3; r3 += 1)
          e3[r3] = 255 & t3[r3];
        return e3;
      }
      function Wu2(e3) {
        if (e3 >= Lu2())
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Lu2().toString(16) + " bytes");
        return 0 | e3;
      }
      function qu2(e3) {
        return !(e3 == null || !e3._isBuffer);
      }
      function Uu2(e3, t3) {
        if (qu2(e3))
          return e3.length;
        if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e3) || e3 instanceof ArrayBuffer))
          return e3.byteLength;
        typeof e3 != "string" && (e3 = "" + e3);
        var n3 = e3.length;
        if (n3 === 0)
          return 0;
        for (var r3 = false; ; )
          switch (t3) {
            case "ascii":
            case "latin1":
            case "binary":
              return n3;
            case "utf8":
            case "utf-8":
            case void 0:
              return Do2(e3).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * n3;
            case "hex":
              return n3 >>> 1;
            case "base64":
              return Eo2(e3).length;
            default:
              if (r3)
                return Do2(e3).length;
              t3 = ("" + t3).toLowerCase(), r3 = true;
          }
      }
      function zu2(e3, t3, n3) {
        var r3 = false;
        if ((t3 === void 0 || t3 < 0) && (t3 = 0), t3 > this.length)
          return "";
        if ((n3 === void 0 || n3 > this.length) && (n3 = this.length), n3 <= 0)
          return "";
        if ((n3 >>>= 0) <= (t3 >>>= 0))
          return "";
        for (e3 || (e3 = "utf8"); ; )
          switch (e3) {
            case "hex":
              return oo2(this, t3, n3);
            case "utf8":
            case "utf-8":
              return no2(this, t3, n3);
            case "ascii":
              return io2(this, t3, n3);
            case "latin1":
            case "binary":
              return uo2(this, t3, n3);
            case "base64":
              return to2(this, t3, n3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return so2(this, t3, n3);
            default:
              if (r3)
                throw new TypeError("Unknown encoding: " + e3);
              e3 = (e3 + "").toLowerCase(), r3 = true;
          }
      }
      function Gu2(e3, t3, n3) {
        var r3 = e3[t3];
        e3[t3] = e3[n3], e3[n3] = r3;
      }
      function Hu2(e3, t3, n3, r3, i3) {
        if (e3.length === 0)
          return -1;
        if (typeof n3 == "string" ? (r3 = n3, n3 = 0) : n3 > 2147483647 ? n3 = 2147483647 : n3 < -2147483648 && (n3 = -2147483648), n3 = +n3, isNaN(n3) && (n3 = i3 ? 0 : e3.length - 1), n3 < 0 && (n3 = e3.length + n3), n3 >= e3.length) {
          if (i3)
            return -1;
          n3 = e3.length - 1;
        } else if (n3 < 0) {
          if (!i3)
            return -1;
          n3 = 0;
        }
        if (typeof t3 == "string" && (t3 = _u2.from(t3, r3)), qu2(t3))
          return t3.length === 0 ? -1 : Ju2(e3, t3, n3, r3, i3);
        if (typeof t3 == "number")
          return t3 &= 255, _u2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i3 ? Uint8Array.prototype.indexOf.call(e3, t3, n3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, n3) : Ju2(e3, [t3], n3, r3, i3);
        throw new TypeError("val must be string, number or Buffer");
      }
      function Ju2(e3, t3, n3, r3, i3) {
        var u3, o3 = 1, s3 = e3.length, a3 = t3.length;
        if (r3 !== void 0 && ((r3 = String(r3).toLowerCase()) === "ucs2" || r3 === "ucs-2" || r3 === "utf16le" || r3 === "utf-16le")) {
          if (e3.length < 2 || t3.length < 2)
            return -1;
          o3 = 2, s3 /= 2, a3 /= 2, n3 /= 2;
        }
        function c3(e4, t4) {
          return o3 === 1 ? e4[t4] : e4.readUInt16BE(t4 * o3);
        }
        if (i3) {
          var l3 = -1;
          for (u3 = n3; u3 < s3; u3++)
            if (c3(e3, u3) === c3(t3, l3 === -1 ? 0 : u3 - l3)) {
              if (l3 === -1 && (l3 = u3), u3 - l3 + 1 === a3)
                return l3 * o3;
            } else
              l3 !== -1 && (u3 -= u3 - l3), l3 = -1;
        } else
          for (n3 + a3 > s3 && (n3 = s3 - a3), u3 = n3; u3 >= 0; u3--) {
            for (var p3 = true, f3 = 0; f3 < a3; f3++)
              if (c3(e3, u3 + f3) !== c3(t3, f3)) {
                p3 = false;
                break;
              }
            if (p3)
              return u3;
          }
        return -1;
      }
      function Xu2(e3, t3, n3, r3) {
        n3 = Number(n3) || 0;
        var i3 = e3.length - n3;
        r3 ? (r3 = Number(r3)) > i3 && (r3 = i3) : r3 = i3;
        var u3 = t3.length;
        if (u3 % 2 != 0)
          throw new TypeError("Invalid hex string");
        r3 > u3 / 2 && (r3 = u3 / 2);
        for (var o3 = 0; o3 < r3; ++o3) {
          var s3 = parseInt(t3.substr(2 * o3, 2), 16);
          if (isNaN(s3))
            return o3;
          e3[n3 + o3] = s3;
        }
        return o3;
      }
      function Yu2(e3, t3, n3, r3) {
        return Co2(Do2(t3, e3.length - n3), e3, n3, r3);
      }
      function Ku2(e3, t3, n3, r3) {
        return Co2(function(e4) {
          for (var t4 = [], n4 = 0; n4 < e4.length; ++n4)
            t4.push(255 & e4.charCodeAt(n4));
          return t4;
        }(t3), e3, n3, r3);
      }
      function Qu2(e3, t3, n3, r3) {
        return Ku2(e3, t3, n3, r3);
      }
      function Zu2(e3, t3, n3, r3) {
        return Co2(Eo2(t3), e3, n3, r3);
      }
      function eo2(e3, t3, n3, r3) {
        return Co2(function(e4, t4) {
          for (var n4, r4, i3, u3 = [], o3 = 0; o3 < e4.length && !((t4 -= 2) < 0); ++o3)
            r4 = (n4 = e4.charCodeAt(o3)) >> 8, i3 = n4 % 256, u3.push(i3), u3.push(r4);
          return u3;
        }(t3, e3.length - n3), e3, n3, r3);
      }
      function to2(e3, t3, n3) {
        return t3 === 0 && n3 === e3.length ? Nu2(e3) : Nu2(e3.slice(t3, n3));
      }
      function no2(e3, t3, n3) {
        n3 = Math.min(e3.length, n3);
        for (var r3 = [], i3 = t3; i3 < n3; ) {
          var u3, o3, s3, a3, c3 = e3[i3], l3 = null, p3 = c3 > 239 ? 4 : c3 > 223 ? 3 : c3 > 191 ? 2 : 1;
          if (i3 + p3 <= n3)
            switch (p3) {
              case 1:
                c3 < 128 && (l3 = c3);
                break;
              case 2:
                (192 & (u3 = e3[i3 + 1])) == 128 && (a3 = (31 & c3) << 6 | 63 & u3) > 127 && (l3 = a3);
                break;
              case 3:
                u3 = e3[i3 + 1], o3 = e3[i3 + 2], (192 & u3) == 128 && (192 & o3) == 128 && (a3 = (15 & c3) << 12 | (63 & u3) << 6 | 63 & o3) > 2047 && (a3 < 55296 || a3 > 57343) && (l3 = a3);
                break;
              case 4:
                u3 = e3[i3 + 1], o3 = e3[i3 + 2], s3 = e3[i3 + 3], (192 & u3) == 128 && (192 & o3) == 128 && (192 & s3) == 128 && (a3 = (15 & c3) << 18 | (63 & u3) << 12 | (63 & o3) << 6 | 63 & s3) > 65535 && a3 < 1114112 && (l3 = a3);
            }
          l3 === null ? (l3 = 65533, p3 = 1) : l3 > 65535 && (l3 -= 65536, r3.push(l3 >>> 10 & 1023 | 55296), l3 = 56320 | 1023 & l3), r3.push(l3), i3 += p3;
        }
        return function(e4) {
          var t4 = e4.length;
          if (t4 <= ro2)
            return String.fromCharCode.apply(String, e4);
          var n4 = "", r4 = 0;
          for (; r4 < t4; )
            n4 += String.fromCharCode.apply(String, e4.slice(r4, r4 += ro2));
          return n4;
        }(r3);
      }
      _u2.TYPED_ARRAY_SUPPORT = ir2.TYPED_ARRAY_SUPPORT === void 0 || ir2.TYPED_ARRAY_SUPPORT, _u2.poolSize = 8192, _u2._augment = function(e3) {
        return e3.__proto__ = _u2.prototype, e3;
      }, _u2.from = function(e3, t3, n3) {
        return Mu2(null, e3, t3, n3);
      }, _u2.TYPED_ARRAY_SUPPORT && (_u2.prototype.__proto__ = Uint8Array.prototype, _u2.__proto__ = Uint8Array), _u2.alloc = function(e3, t3, n3) {
        return function(e4, t4, n4, r3) {
          return Ru2(t4), t4 <= 0 ? ju2(e4, t4) : n4 !== void 0 ? typeof r3 == "string" ? ju2(e4, t4).fill(n4, r3) : ju2(e4, t4).fill(n4) : ju2(e4, t4);
        }(null, e3, t3, n3);
      }, _u2.allocUnsafe = function(e3) {
        return $u2(null, e3);
      }, _u2.allocUnsafeSlow = function(e3) {
        return $u2(null, e3);
      }, _u2.isBuffer = bo2, _u2.compare = function(e3, t3) {
        if (!qu2(e3) || !qu2(t3))
          throw new TypeError("Arguments must be Buffers");
        if (e3 === t3)
          return 0;
        for (var n3 = e3.length, r3 = t3.length, i3 = 0, u3 = Math.min(n3, r3); i3 < u3; ++i3)
          if (e3[i3] !== t3[i3]) {
            n3 = e3[i3], r3 = t3[i3];
            break;
          }
        return n3 < r3 ? -1 : r3 < n3 ? 1 : 0;
      }, _u2.isEncoding = function(e3) {
        switch (String(e3).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, _u2.concat = function(e3, t3) {
        if (!Iu2(e3))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (e3.length === 0)
          return _u2.alloc(0);
        var n3;
        if (t3 === void 0)
          for (t3 = 0, n3 = 0; n3 < e3.length; ++n3)
            t3 += e3[n3].length;
        var r3 = _u2.allocUnsafe(t3), i3 = 0;
        for (n3 = 0; n3 < e3.length; ++n3) {
          var u3 = e3[n3];
          if (!qu2(u3))
            throw new TypeError('"list" argument must be an Array of Buffers');
          u3.copy(r3, i3), i3 += u3.length;
        }
        return r3;
      }, _u2.byteLength = Uu2, _u2.prototype._isBuffer = true, _u2.prototype.swap16 = function() {
        var e3 = this.length;
        if (e3 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t3 = 0; t3 < e3; t3 += 2)
          Gu2(this, t3, t3 + 1);
        return this;
      }, _u2.prototype.swap32 = function() {
        var e3 = this.length;
        if (e3 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t3 = 0; t3 < e3; t3 += 4)
          Gu2(this, t3, t3 + 3), Gu2(this, t3 + 1, t3 + 2);
        return this;
      }, _u2.prototype.swap64 = function() {
        var e3 = this.length;
        if (e3 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t3 = 0; t3 < e3; t3 += 8)
          Gu2(this, t3, t3 + 7), Gu2(this, t3 + 1, t3 + 6), Gu2(this, t3 + 2, t3 + 5), Gu2(this, t3 + 3, t3 + 4);
        return this;
      }, _u2.prototype.toString = function() {
        var e3 = 0 | this.length;
        return e3 === 0 ? "" : arguments.length === 0 ? no2(this, 0, e3) : zu2.apply(this, arguments);
      }, _u2.prototype.equals = function(e3) {
        if (!qu2(e3))
          throw new TypeError("Argument must be a Buffer");
        return this === e3 || _u2.compare(this, e3) === 0;
      }, _u2.prototype.inspect = function() {
        var e3 = "";
        return this.length > 0 && (e3 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e3 += " ... ")), "<Buffer " + e3 + ">";
      }, _u2.prototype.compare = function(e3, t3, n3, r3, i3) {
        if (!qu2(e3))
          throw new TypeError("Argument must be a Buffer");
        if (t3 === void 0 && (t3 = 0), n3 === void 0 && (n3 = e3 ? e3.length : 0), r3 === void 0 && (r3 = 0), i3 === void 0 && (i3 = this.length), t3 < 0 || n3 > e3.length || r3 < 0 || i3 > this.length)
          throw new RangeError("out of range index");
        if (r3 >= i3 && t3 >= n3)
          return 0;
        if (r3 >= i3)
          return -1;
        if (t3 >= n3)
          return 1;
        if (this === e3)
          return 0;
        for (var u3 = (i3 >>>= 0) - (r3 >>>= 0), o3 = (n3 >>>= 0) - (t3 >>>= 0), s3 = Math.min(u3, o3), a3 = this.slice(r3, i3), c3 = e3.slice(t3, n3), l3 = 0; l3 < s3; ++l3)
          if (a3[l3] !== c3[l3]) {
            u3 = a3[l3], o3 = c3[l3];
            break;
          }
        return u3 < o3 ? -1 : o3 < u3 ? 1 : 0;
      }, _u2.prototype.includes = function(e3, t3, n3) {
        return this.indexOf(e3, t3, n3) !== -1;
      }, _u2.prototype.indexOf = function(e3, t3, n3) {
        return Hu2(this, e3, t3, n3, true);
      }, _u2.prototype.lastIndexOf = function(e3, t3, n3) {
        return Hu2(this, e3, t3, n3, false);
      }, _u2.prototype.write = function(e3, t3, n3, r3) {
        if (t3 === void 0)
          r3 = "utf8", n3 = this.length, t3 = 0;
        else if (n3 === void 0 && typeof t3 == "string")
          r3 = t3, n3 = this.length, t3 = 0;
        else {
          if (!isFinite(t3))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          t3 |= 0, isFinite(n3) ? (n3 |= 0, r3 === void 0 && (r3 = "utf8")) : (r3 = n3, n3 = void 0);
        }
        var i3 = this.length - t3;
        if ((n3 === void 0 || n3 > i3) && (n3 = i3), e3.length > 0 && (n3 < 0 || t3 < 0) || t3 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        r3 || (r3 = "utf8");
        for (var u3 = false; ; )
          switch (r3) {
            case "hex":
              return Xu2(this, e3, t3, n3);
            case "utf8":
            case "utf-8":
              return Yu2(this, e3, t3, n3);
            case "ascii":
              return Ku2(this, e3, t3, n3);
            case "latin1":
            case "binary":
              return Qu2(this, e3, t3, n3);
            case "base64":
              return Zu2(this, e3, t3, n3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return eo2(this, e3, t3, n3);
            default:
              if (u3)
                throw new TypeError("Unknown encoding: " + r3);
              r3 = ("" + r3).toLowerCase(), u3 = true;
          }
      }, _u2.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var ro2 = 4096;
      function io2(e3, t3, n3) {
        var r3 = "";
        n3 = Math.min(e3.length, n3);
        for (var i3 = t3; i3 < n3; ++i3)
          r3 += String.fromCharCode(127 & e3[i3]);
        return r3;
      }
      function uo2(e3, t3, n3) {
        var r3 = "";
        n3 = Math.min(e3.length, n3);
        for (var i3 = t3; i3 < n3; ++i3)
          r3 += String.fromCharCode(e3[i3]);
        return r3;
      }
      function oo2(e3, t3, n3) {
        var r3 = e3.length;
        (!t3 || t3 < 0) && (t3 = 0), (!n3 || n3 < 0 || n3 > r3) && (n3 = r3);
        for (var i3 = "", u3 = t3; u3 < n3; ++u3)
          i3 += yo2(e3[u3]);
        return i3;
      }
      function so2(e3, t3, n3) {
        for (var r3 = e3.slice(t3, n3), i3 = "", u3 = 0; u3 < r3.length; u3 += 2)
          i3 += String.fromCharCode(r3[u3] + 256 * r3[u3 + 1]);
        return i3;
      }
      function ao2(e3, t3, n3) {
        if (e3 % 1 != 0 || e3 < 0)
          throw new RangeError("offset is not uint");
        if (e3 + t3 > n3)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function co2(e3, t3, n3, r3, i3, u3) {
        if (!qu2(e3))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t3 > i3 || t3 < u3)
          throw new RangeError('"value" argument is out of bounds');
        if (n3 + r3 > e3.length)
          throw new RangeError("Index out of range");
      }
      function lo2(e3, t3, n3, r3) {
        t3 < 0 && (t3 = 65535 + t3 + 1);
        for (var i3 = 0, u3 = Math.min(e3.length - n3, 2); i3 < u3; ++i3)
          e3[n3 + i3] = (t3 & 255 << 8 * (r3 ? i3 : 1 - i3)) >>> 8 * (r3 ? i3 : 1 - i3);
      }
      function po2(e3, t3, n3, r3) {
        t3 < 0 && (t3 = 4294967295 + t3 + 1);
        for (var i3 = 0, u3 = Math.min(e3.length - n3, 4); i3 < u3; ++i3)
          e3[n3 + i3] = t3 >>> 8 * (r3 ? i3 : 3 - i3) & 255;
      }
      function fo2(e3, t3, n3, r3, i3, u3) {
        if (n3 + r3 > e3.length)
          throw new RangeError("Index out of range");
        if (n3 < 0)
          throw new RangeError("Index out of range");
      }
      function ho2(e3, t3, n3, r3, i3) {
        return i3 || fo2(e3, 0, n3, 4), Pu2(e3, t3, n3, r3, 23, 4), n3 + 4;
      }
      function go2(e3, t3, n3, r3, i3) {
        return i3 || fo2(e3, 0, n3, 8), Pu2(e3, t3, n3, r3, 52, 8), n3 + 8;
      }
      _u2.prototype.slice = function(e3, t3) {
        var n3, r3 = this.length;
        if ((e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = t3 === void 0 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3), _u2.TYPED_ARRAY_SUPPORT)
          (n3 = this.subarray(e3, t3)).__proto__ = _u2.prototype;
        else {
          var i3 = t3 - e3;
          n3 = new _u2(i3, void 0);
          for (var u3 = 0; u3 < i3; ++u3)
            n3[u3] = this[u3 + e3];
        }
        return n3;
      }, _u2.prototype.readUIntLE = function(e3, t3, n3) {
        e3 |= 0, t3 |= 0, n3 || ao2(e3, t3, this.length);
        for (var r3 = this[e3], i3 = 1, u3 = 0; ++u3 < t3 && (i3 *= 256); )
          r3 += this[e3 + u3] * i3;
        return r3;
      }, _u2.prototype.readUIntBE = function(e3, t3, n3) {
        e3 |= 0, t3 |= 0, n3 || ao2(e3, t3, this.length);
        for (var r3 = this[e3 + --t3], i3 = 1; t3 > 0 && (i3 *= 256); )
          r3 += this[e3 + --t3] * i3;
        return r3;
      }, _u2.prototype.readUInt8 = function(e3, t3) {
        return t3 || ao2(e3, 1, this.length), this[e3];
      }, _u2.prototype.readUInt16LE = function(e3, t3) {
        return t3 || ao2(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
      }, _u2.prototype.readUInt16BE = function(e3, t3) {
        return t3 || ao2(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
      }, _u2.prototype.readUInt32LE = function(e3, t3) {
        return t3 || ao2(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
      }, _u2.prototype.readUInt32BE = function(e3, t3) {
        return t3 || ao2(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
      }, _u2.prototype.readIntLE = function(e3, t3, n3) {
        e3 |= 0, t3 |= 0, n3 || ao2(e3, t3, this.length);
        for (var r3 = this[e3], i3 = 1, u3 = 0; ++u3 < t3 && (i3 *= 256); )
          r3 += this[e3 + u3] * i3;
        return r3 >= (i3 *= 128) && (r3 -= Math.pow(2, 8 * t3)), r3;
      }, _u2.prototype.readIntBE = function(e3, t3, n3) {
        e3 |= 0, t3 |= 0, n3 || ao2(e3, t3, this.length);
        for (var r3 = t3, i3 = 1, u3 = this[e3 + --r3]; r3 > 0 && (i3 *= 256); )
          u3 += this[e3 + --r3] * i3;
        return u3 >= (i3 *= 128) && (u3 -= Math.pow(2, 8 * t3)), u3;
      }, _u2.prototype.readInt8 = function(e3, t3) {
        return t3 || ao2(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
      }, _u2.prototype.readInt16LE = function(e3, t3) {
        t3 || ao2(e3, 2, this.length);
        var n3 = this[e3] | this[e3 + 1] << 8;
        return 32768 & n3 ? 4294901760 | n3 : n3;
      }, _u2.prototype.readInt16BE = function(e3, t3) {
        t3 || ao2(e3, 2, this.length);
        var n3 = this[e3 + 1] | this[e3] << 8;
        return 32768 & n3 ? 4294901760 | n3 : n3;
      }, _u2.prototype.readInt32LE = function(e3, t3) {
        return t3 || ao2(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
      }, _u2.prototype.readInt32BE = function(e3, t3) {
        return t3 || ao2(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
      }, _u2.prototype.readFloatLE = function(e3, t3) {
        return t3 || ao2(e3, 4, this.length), ku2(this, e3, true, 23, 4);
      }, _u2.prototype.readFloatBE = function(e3, t3) {
        return t3 || ao2(e3, 4, this.length), ku2(this, e3, false, 23, 4);
      }, _u2.prototype.readDoubleLE = function(e3, t3) {
        return t3 || ao2(e3, 8, this.length), ku2(this, e3, true, 52, 8);
      }, _u2.prototype.readDoubleBE = function(e3, t3) {
        return t3 || ao2(e3, 8, this.length), ku2(this, e3, false, 52, 8);
      }, _u2.prototype.writeUIntLE = function(e3, t3, n3, r3) {
        (e3 = +e3, t3 |= 0, n3 |= 0, r3) || co2(this, e3, t3, n3, Math.pow(2, 8 * n3) - 1, 0);
        var i3 = 1, u3 = 0;
        for (this[t3] = 255 & e3; ++u3 < n3 && (i3 *= 256); )
          this[t3 + u3] = e3 / i3 & 255;
        return t3 + n3;
      }, _u2.prototype.writeUIntBE = function(e3, t3, n3, r3) {
        (e3 = +e3, t3 |= 0, n3 |= 0, r3) || co2(this, e3, t3, n3, Math.pow(2, 8 * n3) - 1, 0);
        var i3 = n3 - 1, u3 = 1;
        for (this[t3 + i3] = 255 & e3; --i3 >= 0 && (u3 *= 256); )
          this[t3 + i3] = e3 / u3 & 255;
        return t3 + n3;
      }, _u2.prototype.writeUInt8 = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 1, 255, 0), _u2.TYPED_ARRAY_SUPPORT || (e3 = Math.floor(e3)), this[t3] = 255 & e3, t3 + 1;
      }, _u2.prototype.writeUInt16LE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 2, 65535, 0), _u2.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8) : lo2(this, e3, t3, true), t3 + 2;
      }, _u2.prototype.writeUInt16BE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 2, 65535, 0), _u2.TYPED_ARRAY_SUPPORT ? (this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3) : lo2(this, e3, t3, false), t3 + 2;
      }, _u2.prototype.writeUInt32LE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 4, 4294967295, 0), _u2.TYPED_ARRAY_SUPPORT ? (this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3) : po2(this, e3, t3, true), t3 + 4;
      }, _u2.prototype.writeUInt32BE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 4, 4294967295, 0), _u2.TYPED_ARRAY_SUPPORT ? (this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3) : po2(this, e3, t3, false), t3 + 4;
      }, _u2.prototype.writeIntLE = function(e3, t3, n3, r3) {
        if (e3 = +e3, t3 |= 0, !r3) {
          var i3 = Math.pow(2, 8 * n3 - 1);
          co2(this, e3, t3, n3, i3 - 1, -i3);
        }
        var u3 = 0, o3 = 1, s3 = 0;
        for (this[t3] = 255 & e3; ++u3 < n3 && (o3 *= 256); )
          e3 < 0 && s3 === 0 && this[t3 + u3 - 1] !== 0 && (s3 = 1), this[t3 + u3] = (e3 / o3 >> 0) - s3 & 255;
        return t3 + n3;
      }, _u2.prototype.writeIntBE = function(e3, t3, n3, r3) {
        if (e3 = +e3, t3 |= 0, !r3) {
          var i3 = Math.pow(2, 8 * n3 - 1);
          co2(this, e3, t3, n3, i3 - 1, -i3);
        }
        var u3 = n3 - 1, o3 = 1, s3 = 0;
        for (this[t3 + u3] = 255 & e3; --u3 >= 0 && (o3 *= 256); )
          e3 < 0 && s3 === 0 && this[t3 + u3 + 1] !== 0 && (s3 = 1), this[t3 + u3] = (e3 / o3 >> 0) - s3 & 255;
        return t3 + n3;
      }, _u2.prototype.writeInt8 = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 1, 127, -128), _u2.TYPED_ARRAY_SUPPORT || (e3 = Math.floor(e3)), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
      }, _u2.prototype.writeInt16LE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 2, 32767, -32768), _u2.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8) : lo2(this, e3, t3, true), t3 + 2;
      }, _u2.prototype.writeInt16BE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 2, 32767, -32768), _u2.TYPED_ARRAY_SUPPORT ? (this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3) : lo2(this, e3, t3, false), t3 + 2;
      }, _u2.prototype.writeInt32LE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 4, 2147483647, -2147483648), _u2.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24) : po2(this, e3, t3, true), t3 + 4;
      }, _u2.prototype.writeInt32BE = function(e3, t3, n3) {
        return e3 = +e3, t3 |= 0, n3 || co2(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), _u2.TYPED_ARRAY_SUPPORT ? (this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3) : po2(this, e3, t3, false), t3 + 4;
      }, _u2.prototype.writeFloatLE = function(e3, t3, n3) {
        return ho2(this, e3, t3, true, n3);
      }, _u2.prototype.writeFloatBE = function(e3, t3, n3) {
        return ho2(this, e3, t3, false, n3);
      }, _u2.prototype.writeDoubleLE = function(e3, t3, n3) {
        return go2(this, e3, t3, true, n3);
      }, _u2.prototype.writeDoubleBE = function(e3, t3, n3) {
        return go2(this, e3, t3, false, n3);
      }, _u2.prototype.copy = function(e3, t3, n3, r3) {
        if (n3 || (n3 = 0), r3 || r3 === 0 || (r3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), r3 > 0 && r3 < n3 && (r3 = n3), r3 === n3)
          return 0;
        if (e3.length === 0 || this.length === 0)
          return 0;
        if (t3 < 0)
          throw new RangeError("targetStart out of bounds");
        if (n3 < 0 || n3 >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (r3 < 0)
          throw new RangeError("sourceEnd out of bounds");
        r3 > this.length && (r3 = this.length), e3.length - t3 < r3 - n3 && (r3 = e3.length - t3 + n3);
        var i3, u3 = r3 - n3;
        if (this === e3 && n3 < t3 && t3 < r3)
          for (i3 = u3 - 1; i3 >= 0; --i3)
            e3[i3 + t3] = this[i3 + n3];
        else if (u3 < 1e3 || !_u2.TYPED_ARRAY_SUPPORT)
          for (i3 = 0; i3 < u3; ++i3)
            e3[i3 + t3] = this[i3 + n3];
        else
          Uint8Array.prototype.set.call(e3, this.subarray(n3, n3 + u3), t3);
        return u3;
      }, _u2.prototype.fill = function(e3, t3, n3, r3) {
        if (typeof e3 == "string") {
          if (typeof t3 == "string" ? (r3 = t3, t3 = 0, n3 = this.length) : typeof n3 == "string" && (r3 = n3, n3 = this.length), e3.length === 1) {
            var i3 = e3.charCodeAt(0);
            i3 < 256 && (e3 = i3);
          }
          if (r3 !== void 0 && typeof r3 != "string")
            throw new TypeError("encoding must be a string");
          if (typeof r3 == "string" && !_u2.isEncoding(r3))
            throw new TypeError("Unknown encoding: " + r3);
        } else
          typeof e3 == "number" && (e3 &= 255);
        if (t3 < 0 || this.length < t3 || this.length < n3)
          throw new RangeError("Out of range index");
        if (n3 <= t3)
          return this;
        var u3;
        if (t3 >>>= 0, n3 = n3 === void 0 ? this.length : n3 >>> 0, e3 || (e3 = 0), typeof e3 == "number")
          for (u3 = t3; u3 < n3; ++u3)
            this[u3] = e3;
        else {
          var o3 = qu2(e3) ? e3 : Do2(new _u2(e3, r3).toString()), s3 = o3.length;
          for (u3 = 0; u3 < n3 - t3; ++u3)
            this[u3 + t3] = o3[u3 % s3];
        }
        return this;
      };
      var mo2 = /[^+\/0-9A-Za-z-_]/g;
      function yo2(e3) {
        return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
      }
      function Do2(e3, t3) {
        var n3;
        t3 = t3 || 1 / 0;
        for (var r3 = e3.length, i3 = null, u3 = [], o3 = 0; o3 < r3; ++o3) {
          if ((n3 = e3.charCodeAt(o3)) > 55295 && n3 < 57344) {
            if (!i3) {
              if (n3 > 56319) {
                (t3 -= 3) > -1 && u3.push(239, 191, 189);
                continue;
              }
              if (o3 + 1 === r3) {
                (t3 -= 3) > -1 && u3.push(239, 191, 189);
                continue;
              }
              i3 = n3;
              continue;
            }
            if (n3 < 56320) {
              (t3 -= 3) > -1 && u3.push(239, 191, 189), i3 = n3;
              continue;
            }
            n3 = 65536 + (i3 - 55296 << 10 | n3 - 56320);
          } else
            i3 && (t3 -= 3) > -1 && u3.push(239, 191, 189);
          if (i3 = null, n3 < 128) {
            if ((t3 -= 1) < 0)
              break;
            u3.push(n3);
          } else if (n3 < 2048) {
            if ((t3 -= 2) < 0)
              break;
            u3.push(n3 >> 6 | 192, 63 & n3 | 128);
          } else if (n3 < 65536) {
            if ((t3 -= 3) < 0)
              break;
            u3.push(n3 >> 12 | 224, n3 >> 6 & 63 | 128, 63 & n3 | 128);
          } else {
            if (!(n3 < 1114112))
              throw new Error("Invalid code point");
            if ((t3 -= 4) < 0)
              break;
            u3.push(n3 >> 18 | 240, n3 >> 12 & 63 | 128, n3 >> 6 & 63 | 128, 63 & n3 | 128);
          }
        }
        return u3;
      }
      function Eo2(e3) {
        return function(e4) {
          var t3, n3, r3, i3, u3, o3;
          wu2 || Tu2();
          var s3 = e4.length;
          if (s3 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          u3 = e4[s3 - 2] === "=" ? 2 : e4[s3 - 1] === "=" ? 1 : 0, o3 = new Su2(3 * s3 / 4 - u3), r3 = u3 > 0 ? s3 - 4 : s3;
          var a3 = 0;
          for (t3 = 0, n3 = 0; t3 < r3; t3 += 4, n3 += 3)
            i3 = xu2[e4.charCodeAt(t3)] << 18 | xu2[e4.charCodeAt(t3 + 1)] << 12 | xu2[e4.charCodeAt(t3 + 2)] << 6 | xu2[e4.charCodeAt(t3 + 3)], o3[a3++] = i3 >> 16 & 255, o3[a3++] = i3 >> 8 & 255, o3[a3++] = 255 & i3;
          return u3 === 2 ? (i3 = xu2[e4.charCodeAt(t3)] << 2 | xu2[e4.charCodeAt(t3 + 1)] >> 4, o3[a3++] = 255 & i3) : u3 === 1 && (i3 = xu2[e4.charCodeAt(t3)] << 10 | xu2[e4.charCodeAt(t3 + 1)] << 4 | xu2[e4.charCodeAt(t3 + 2)] >> 2, o3[a3++] = i3 >> 8 & 255, o3[a3++] = 255 & i3), o3;
        }(function(e4) {
          if ((e4 = function(e5) {
            return e5.trim ? e5.trim() : e5.replace(/^\s+|\s+$/g, "");
          }(e4).replace(mo2, "")).length < 2)
            return "";
          for (; e4.length % 4 != 0; )
            e4 += "=";
          return e4;
        }(e3));
      }
      function Co2(e3, t3, n3, r3) {
        for (var i3 = 0; i3 < r3 && !(i3 + n3 >= t3.length || i3 >= e3.length); ++i3)
          t3[i3 + n3] = e3[i3];
        return i3;
      }
      function bo2(e3) {
        return e3 != null && (!!e3._isBuffer || Ao2(e3) || function(e4) {
          return typeof e4.readFloatLE == "function" && typeof e4.slice == "function" && Ao2(e4.slice(0, 0));
        }(e3));
      }
      function Ao2(e3) {
        return !!e3.constructor && typeof e3.constructor.isBuffer == "function" && e3.constructor.isBuffer(e3);
      }
      var vo2 = n2(au2);
      var Fo2 = class {
        constructor(e3, t3) {
          (t3 = t3 || {}).readChunk || (t3.readChunk = 1024), t3.newLineCharacter ? t3.newLineCharacter = t3.newLineCharacter.charCodeAt(0) : t3.newLineCharacter = 10, this.fd = typeof e3 == "number" ? e3 : vo2.openSync(e3, "r"), this.options = t3, this.newLineCharacter = t3.newLineCharacter, this.reset();
        }
        _searchInBuffer(e3, t3) {
          let n3 = -1;
          for (let r3 = 0; r3 <= e3.length; r3++) {
            if (e3[r3] === t3) {
              n3 = r3;
              break;
            }
          }
          return n3;
        }
        reset() {
          this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
        }
        close() {
          vo2.closeSync(this.fd), this.fd = null;
        }
        _extractLines(e3) {
          let t3;
          const n3 = [];
          let r3 = 0, i3 = 0;
          for (; ; ) {
            let u4 = e3[r3++];
            if (u4 === this.newLineCharacter)
              t3 = e3.slice(i3, r3), n3.push(t3), i3 = r3;
            else if (u4 === void 0)
              break;
          }
          let u3 = e3.slice(i3, r3);
          return u3.length && n3.push(u3), n3;
        }
        _readChunk(e3) {
          let t3, n3 = 0;
          const r3 = [];
          do {
            const e4 = new _u2(this.options.readChunk);
            t3 = vo2.readSync(this.fd, e4, 0, this.options.readChunk, this.fdPosition), n3 += t3, this.fdPosition = this.fdPosition + t3, r3.push(e4);
          } while (t3 && this._searchInBuffer(r3[r3.length - 1], this.options.newLineCharacter) === -1);
          let i3 = _u2.concat(r3);
          return t3 < this.options.readChunk && (this.eofReached = true, i3 = i3.slice(0, n3)), n3 && (this.linesCache = this._extractLines(i3), e3 && (this.linesCache[0] = _u2.concat([e3, this.linesCache[0]]))), n3;
        }
        next() {
          if (!this.fd)
            return false;
          let e3, t3 = false;
          if (this.eofReached && this.linesCache.length === 0)
            return t3;
          if (this.linesCache.length || (e3 = this._readChunk()), this.linesCache.length) {
            t3 = this.linesCache.shift();
            t3[t3.length - 1] !== this.newLineCharacter && (e3 = this._readChunk(t3), e3 && (t3 = this.linesCache.shift()));
          }
          return this.eofReached && this.linesCache.length === 0 && this.close(), t3 && t3[t3.length - 1] === this.newLineCharacter && (t3 = t3.slice(0, t3.length - 1)), t3;
        }
      };
      class xo2 extends Error {
      }
      class So2 extends Error {
      }
      class wo2 extends Error {
      }
      class To2 extends Error {
      }
      var Bo2 = { ConfigError: xo2, DebugError: So2, UndefinedParserError: wo2, ArgExpansionBailout: To2 }, No2 = function(e3, t3) {
        return (No2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
          e4.__proto__ = t4;
        } || function(e4, t4) {
          for (var n3 in t4)
            t4.hasOwnProperty(n3) && (e4[n3] = t4[n3]);
        })(e3, t3);
      };
      /*! *****************************************************************************
      	Copyright (c) Microsoft Corporation.
      
      	Permission to use, copy, modify, and/or distribute this software for any
      	purpose with or without fee is hereby granted.
      
      	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      	PERFORMANCE OF THIS SOFTWARE.
      	***************************************************************************** */
      var ko2 = function() {
        return (ko2 = Object.assign || function(e3) {
          for (var t3, n3 = 1, r3 = arguments.length; n3 < r3; n3++)
            for (var i3 in t3 = arguments[n3])
              Object.prototype.hasOwnProperty.call(t3, i3) && (e3[i3] = t3[i3]);
          return e3;
        }).apply(this, arguments);
      };
      function Po2(e3) {
        var t3 = typeof Symbol == "function" && Symbol.iterator, n3 = t3 && e3[t3], r3 = 0;
        if (n3)
          return n3.call(e3);
        if (e3 && typeof e3.length == "number")
          return { next: function() {
            return e3 && r3 >= e3.length && (e3 = void 0), { value: e3 && e3[r3++], done: !e3 };
          } };
        throw new TypeError(t3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function Oo2(e3, t3) {
        var n3 = typeof Symbol == "function" && e3[Symbol.iterator];
        if (!n3)
          return e3;
        var r3, i3, u3 = n3.call(e3), o3 = [];
        try {
          for (; (t3 === void 0 || t3-- > 0) && !(r3 = u3.next()).done; )
            o3.push(r3.value);
        } catch (e4) {
          i3 = { error: e4 };
        } finally {
          try {
            r3 && !r3.done && (n3 = u3.return) && n3.call(u3);
          } finally {
            if (i3)
              throw i3.error;
          }
        }
        return o3;
      }
      function Io2(e3) {
        return this instanceof Io2 ? (this.v = e3, this) : new Io2(e3);
      }
      var Lo2 = Object.freeze({ __proto__: null, __extends: function(e3, t3) {
        function n3() {
          this.constructor = e3;
        }
        No2(e3, t3), e3.prototype = t3 === null ? Object.create(t3) : (n3.prototype = t3.prototype, new n3());
      }, get __assign() {
        return ko2;
      }, __rest: function(e3, t3) {
        var n3 = {};
        for (var r3 in e3)
          Object.prototype.hasOwnProperty.call(e3, r3) && t3.indexOf(r3) < 0 && (n3[r3] = e3[r3]);
        if (e3 != null && typeof Object.getOwnPropertySymbols == "function") {
          var i3 = 0;
          for (r3 = Object.getOwnPropertySymbols(e3); i3 < r3.length; i3++)
            t3.indexOf(r3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, r3[i3]) && (n3[r3[i3]] = e3[r3[i3]]);
        }
        return n3;
      }, __decorate: function(e3, t3, n3, r3) {
        var i3, u3 = arguments.length, o3 = u3 < 3 ? t3 : r3 === null ? r3 = Object.getOwnPropertyDescriptor(t3, n3) : r3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o3 = Reflect.decorate(e3, t3, n3, r3);
        else
          for (var s3 = e3.length - 1; s3 >= 0; s3--)
            (i3 = e3[s3]) && (o3 = (u3 < 3 ? i3(o3) : u3 > 3 ? i3(t3, n3, o3) : i3(t3, n3)) || o3);
        return u3 > 3 && o3 && Object.defineProperty(t3, n3, o3), o3;
      }, __param: function(e3, t3) {
        return function(n3, r3) {
          t3(n3, r3, e3);
        };
      }, __metadata: function(e3, t3) {
        if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
          return Reflect.metadata(e3, t3);
      }, __awaiter: function(e3, t3, n3, r3) {
        return new (n3 || (n3 = Promise))(function(i3, u3) {
          function o3(e4) {
            try {
              a3(r3.next(e4));
            } catch (e5) {
              u3(e5);
            }
          }
          function s3(e4) {
            try {
              a3(r3.throw(e4));
            } catch (e5) {
              u3(e5);
            }
          }
          function a3(e4) {
            var t4;
            e4.done ? i3(e4.value) : (t4 = e4.value, t4 instanceof n3 ? t4 : new n3(function(e5) {
              e5(t4);
            })).then(o3, s3);
          }
          a3((r3 = r3.apply(e3, t3 || [])).next());
        });
      }, __generator: function(e3, t3) {
        var n3, r3, i3, u3, o3 = { label: 0, sent: function() {
          if (1 & i3[0])
            throw i3[1];
          return i3[1];
        }, trys: [], ops: [] };
        return u3 = { next: s3(0), throw: s3(1), return: s3(2) }, typeof Symbol == "function" && (u3[Symbol.iterator] = function() {
          return this;
        }), u3;
        function s3(u4) {
          return function(s4) {
            return function(u5) {
              if (n3)
                throw new TypeError("Generator is already executing.");
              for (; o3; )
                try {
                  if (n3 = 1, r3 && (i3 = 2 & u5[0] ? r3.return : u5[0] ? r3.throw || ((i3 = r3.return) && i3.call(r3), 0) : r3.next) && !(i3 = i3.call(r3, u5[1])).done)
                    return i3;
                  switch (r3 = 0, i3 && (u5 = [2 & u5[0], i3.value]), u5[0]) {
                    case 0:
                    case 1:
                      i3 = u5;
                      break;
                    case 4:
                      return o3.label++, { value: u5[1], done: false };
                    case 5:
                      o3.label++, r3 = u5[1], u5 = [0];
                      continue;
                    case 7:
                      u5 = o3.ops.pop(), o3.trys.pop();
                      continue;
                    default:
                      if (!(i3 = o3.trys, (i3 = i3.length > 0 && i3[i3.length - 1]) || u5[0] !== 6 && u5[0] !== 2)) {
                        o3 = 0;
                        continue;
                      }
                      if (u5[0] === 3 && (!i3 || u5[1] > i3[0] && u5[1] < i3[3])) {
                        o3.label = u5[1];
                        break;
                      }
                      if (u5[0] === 6 && o3.label < i3[1]) {
                        o3.label = i3[1], i3 = u5;
                        break;
                      }
                      if (i3 && o3.label < i3[2]) {
                        o3.label = i3[2], o3.ops.push(u5);
                        break;
                      }
                      i3[2] && o3.ops.pop(), o3.trys.pop();
                      continue;
                  }
                  u5 = t3.call(e3, o3);
                } catch (e4) {
                  u5 = [6, e4], r3 = 0;
                } finally {
                  n3 = i3 = 0;
                }
              if (5 & u5[0])
                throw u5[1];
              return { value: u5[0] ? u5[1] : void 0, done: true };
            }([u4, s4]);
          };
        }
      }, __createBinding: function(e3, t3, n3, r3) {
        r3 === void 0 && (r3 = n3), e3[r3] = t3[n3];
      }, __exportStar: function(e3, t3) {
        for (var n3 in e3)
          n3 === "default" || t3.hasOwnProperty(n3) || (t3[n3] = e3[n3]);
      }, __values: Po2, __read: Oo2, __spread: function() {
        for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
          e3 = e3.concat(Oo2(arguments[t3]));
        return e3;
      }, __spreadArrays: function() {
        for (var e3 = 0, t3 = 0, n3 = arguments.length; t3 < n3; t3++)
          e3 += arguments[t3].length;
        var r3 = Array(e3), i3 = 0;
        for (t3 = 0; t3 < n3; t3++)
          for (var u3 = arguments[t3], o3 = 0, s3 = u3.length; o3 < s3; o3++, i3++)
            r3[i3] = u3[o3];
        return r3;
      }, __await: Io2, __asyncGenerator: function(e3, t3, n3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var r3, i3 = n3.apply(e3, t3 || []), u3 = [];
        return r3 = {}, o3("next"), o3("throw"), o3("return"), r3[Symbol.asyncIterator] = function() {
          return this;
        }, r3;
        function o3(e4) {
          i3[e4] && (r3[e4] = function(t4) {
            return new Promise(function(n4, r4) {
              u3.push([e4, t4, n4, r4]) > 1 || s3(e4, t4);
            });
          });
        }
        function s3(e4, t4) {
          try {
            (n4 = i3[e4](t4)).value instanceof Io2 ? Promise.resolve(n4.value.v).then(a3, c3) : l3(u3[0][2], n4);
          } catch (e5) {
            l3(u3[0][3], e5);
          }
          var n4;
        }
        function a3(e4) {
          s3("next", e4);
        }
        function c3(e4) {
          s3("throw", e4);
        }
        function l3(e4, t4) {
          e4(t4), u3.shift(), u3.length && s3(u3[0][0], u3[0][1]);
        }
      }, __asyncDelegator: function(e3) {
        var t3, n3;
        return t3 = {}, r3("next"), r3("throw", function(e4) {
          throw e4;
        }), r3("return"), t3[Symbol.iterator] = function() {
          return this;
        }, t3;
        function r3(r4, i3) {
          t3[r4] = e3[r4] ? function(t4) {
            return (n3 = !n3) ? { value: Io2(e3[r4](t4)), done: r4 === "return" } : i3 ? i3(t4) : t4;
          } : i3;
        }
      }, __asyncValues: function(e3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t3, n3 = e3[Symbol.asyncIterator];
        return n3 ? n3.call(e3) : (e3 = Po2(e3), t3 = {}, r3("next"), r3("throw"), r3("return"), t3[Symbol.asyncIterator] = function() {
          return this;
        }, t3);
        function r3(n4) {
          t3[n4] = e3[n4] && function(t4) {
            return new Promise(function(r4, i3) {
              (function(e4, t5, n5, r5) {
                Promise.resolve(r5).then(function(t6) {
                  e4({ value: t6, done: n5 });
                }, t5);
              })(r4, i3, (t4 = e3[n4](t4)).done, t4.value);
            });
          };
        }
      }, __makeTemplateObject: function(e3, t3) {
        return Object.defineProperty ? Object.defineProperty(e3, "raw", { value: t3 }) : e3.raw = t3, e3;
      }, __importStar: function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (e3 != null)
          for (var n3 in e3)
            Object.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }, __importDefault: function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }, __classPrivateFieldGet: function(e3, t3) {
        if (!t3.has(e3))
          throw new TypeError("attempted to get private field on non-instance");
        return t3.get(e3);
      }, __classPrivateFieldSet: function(e3, t3, n3) {
        if (!t3.has(e3))
          throw new TypeError("attempted to set private field on non-instance");
        return t3.set(e3, n3), n3;
      } }), jo2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.apiDescriptor = { key: (e4) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e4) ? e4 : JSON.stringify(e4), value(e4) {
          if (e4 === null || typeof e4 != "object")
            return JSON.stringify(e4);
          if (Array.isArray(e4))
            return `[${e4.map((e5) => t3.apiDescriptor.value(e5)).join(", ")}]`;
          const n3 = Object.keys(e4);
          return n3.length === 0 ? "{}" : `{ ${n3.map((n4) => `${t3.apiDescriptor.key(n4)}: ${t3.apiDescriptor.value(e4[n4])}`).join(", ")} }`;
        }, pair: ({ key: e4, value: n3 }) => t3.apiDescriptor.value({ [e4]: n3 }) };
      }), _o2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Lo2.__exportStar(jo2, t3);
      }), Mo2 = /[|\\{}()[\]^$+*?.]/g, Ro2 = function(e3) {
        if (typeof e3 != "string")
          throw new TypeError("Expected a string");
        return e3.replace(Mo2, "\\$&");
      }, $o2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Vo2 = r2(function(e3) {
        var t3 = {};
        for (var n3 in $o2)
          $o2.hasOwnProperty(n3) && (t3[$o2[n3]] = n3);
        var r3 = e3.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
        for (var i3 in r3)
          if (r3.hasOwnProperty(i3)) {
            if (!("channels" in r3[i3]))
              throw new Error("missing channels property: " + i3);
            if (!("labels" in r3[i3]))
              throw new Error("missing channel labels property: " + i3);
            if (r3[i3].labels.length !== r3[i3].channels)
              throw new Error("channel and label counts mismatch: " + i3);
            var u3 = r3[i3].channels, o3 = r3[i3].labels;
            delete r3[i3].channels, delete r3[i3].labels, Object.defineProperty(r3[i3], "channels", { value: u3 }), Object.defineProperty(r3[i3], "labels", { value: o3 });
          }
        r3.rgb.hsl = function(e4) {
          var t4, n4, r4 = e4[0] / 255, i4 = e4[1] / 255, u4 = e4[2] / 255, o4 = Math.min(r4, i4, u4), s3 = Math.max(r4, i4, u4), a3 = s3 - o4;
          return s3 === o4 ? t4 = 0 : r4 === s3 ? t4 = (i4 - u4) / a3 : i4 === s3 ? t4 = 2 + (u4 - r4) / a3 : u4 === s3 && (t4 = 4 + (r4 - i4) / a3), (t4 = Math.min(60 * t4, 360)) < 0 && (t4 += 360), n4 = (o4 + s3) / 2, [t4, 100 * (s3 === o4 ? 0 : n4 <= 0.5 ? a3 / (s3 + o4) : a3 / (2 - s3 - o4)), 100 * n4];
        }, r3.rgb.hsv = function(e4) {
          var t4, n4, r4, i4, u4, o4 = e4[0] / 255, s3 = e4[1] / 255, a3 = e4[2] / 255, c3 = Math.max(o4, s3, a3), l3 = c3 - Math.min(o4, s3, a3), p3 = function(e5) {
            return (c3 - e5) / 6 / l3 + 0.5;
          };
          return l3 === 0 ? i4 = u4 = 0 : (u4 = l3 / c3, t4 = p3(o4), n4 = p3(s3), r4 = p3(a3), o4 === c3 ? i4 = r4 - n4 : s3 === c3 ? i4 = 1 / 3 + t4 - r4 : a3 === c3 && (i4 = 2 / 3 + n4 - t4), i4 < 0 ? i4 += 1 : i4 > 1 && (i4 -= 1)), [360 * i4, 100 * u4, 100 * c3];
        }, r3.rgb.hwb = function(e4) {
          var t4 = e4[0], n4 = e4[1], i4 = e4[2];
          return [r3.rgb.hsl(e4)[0], 100 * (1 / 255 * Math.min(t4, Math.min(n4, i4))), 100 * (i4 = 1 - 1 / 255 * Math.max(t4, Math.max(n4, i4)))];
        }, r3.rgb.cmyk = function(e4) {
          var t4, n4 = e4[0] / 255, r4 = e4[1] / 255, i4 = e4[2] / 255;
          return [100 * ((1 - n4 - (t4 = Math.min(1 - n4, 1 - r4, 1 - i4))) / (1 - t4) || 0), 100 * ((1 - r4 - t4) / (1 - t4) || 0), 100 * ((1 - i4 - t4) / (1 - t4) || 0), 100 * t4];
        }, r3.rgb.keyword = function(e4) {
          var n4 = t3[e4];
          if (n4)
            return n4;
          var r4, i4, u4, o4 = 1 / 0;
          for (var s3 in $o2)
            if ($o2.hasOwnProperty(s3)) {
              var a3 = $o2[s3], c3 = (i4 = e4, u4 = a3, Math.pow(i4[0] - u4[0], 2) + Math.pow(i4[1] - u4[1], 2) + Math.pow(i4[2] - u4[2], 2));
              c3 < o4 && (o4 = c3, r4 = s3);
            }
          return r4;
        }, r3.keyword.rgb = function(e4) {
          return $o2[e4];
        }, r3.rgb.xyz = function(e4) {
          var t4 = e4[0] / 255, n4 = e4[1] / 255, r4 = e4[2] / 255;
          return [100 * (0.4124 * (t4 = t4 > 0.04045 ? Math.pow((t4 + 0.055) / 1.055, 2.4) : t4 / 12.92) + 0.3576 * (n4 = n4 > 0.04045 ? Math.pow((n4 + 0.055) / 1.055, 2.4) : n4 / 12.92) + 0.1805 * (r4 = r4 > 0.04045 ? Math.pow((r4 + 0.055) / 1.055, 2.4) : r4 / 12.92)), 100 * (0.2126 * t4 + 0.7152 * n4 + 0.0722 * r4), 100 * (0.0193 * t4 + 0.1192 * n4 + 0.9505 * r4)];
        }, r3.rgb.lab = function(e4) {
          var t4 = r3.rgb.xyz(e4), n4 = t4[0], i4 = t4[1], u4 = t4[2];
          return i4 /= 100, u4 /= 108.883, n4 = (n4 /= 95.047) > 8856e-6 ? Math.pow(n4, 1 / 3) : 7.787 * n4 + 16 / 116, [116 * (i4 = i4 > 8856e-6 ? Math.pow(i4, 1 / 3) : 7.787 * i4 + 16 / 116) - 16, 500 * (n4 - i4), 200 * (i4 - (u4 = u4 > 8856e-6 ? Math.pow(u4, 1 / 3) : 7.787 * u4 + 16 / 116))];
        }, r3.hsl.rgb = function(e4) {
          var t4, n4, r4, i4, u4, o4 = e4[0] / 360, s3 = e4[1] / 100, a3 = e4[2] / 100;
          if (s3 === 0)
            return [u4 = 255 * a3, u4, u4];
          t4 = 2 * a3 - (n4 = a3 < 0.5 ? a3 * (1 + s3) : a3 + s3 - a3 * s3), i4 = [0, 0, 0];
          for (var c3 = 0; c3 < 3; c3++)
            (r4 = o4 + 1 / 3 * -(c3 - 1)) < 0 && r4++, r4 > 1 && r4--, u4 = 6 * r4 < 1 ? t4 + 6 * (n4 - t4) * r4 : 2 * r4 < 1 ? n4 : 3 * r4 < 2 ? t4 + (n4 - t4) * (2 / 3 - r4) * 6 : t4, i4[c3] = 255 * u4;
          return i4;
        }, r3.hsl.hsv = function(e4) {
          var t4 = e4[0], n4 = e4[1] / 100, r4 = e4[2] / 100, i4 = n4, u4 = Math.max(r4, 0.01);
          return n4 *= (r4 *= 2) <= 1 ? r4 : 2 - r4, i4 *= u4 <= 1 ? u4 : 2 - u4, [t4, 100 * (r4 === 0 ? 2 * i4 / (u4 + i4) : 2 * n4 / (r4 + n4)), 100 * ((r4 + n4) / 2)];
        }, r3.hsv.rgb = function(e4) {
          var t4 = e4[0] / 60, n4 = e4[1] / 100, r4 = e4[2] / 100, i4 = Math.floor(t4) % 6, u4 = t4 - Math.floor(t4), o4 = 255 * r4 * (1 - n4), s3 = 255 * r4 * (1 - n4 * u4), a3 = 255 * r4 * (1 - n4 * (1 - u4));
          switch (r4 *= 255, i4) {
            case 0:
              return [r4, a3, o4];
            case 1:
              return [s3, r4, o4];
            case 2:
              return [o4, r4, a3];
            case 3:
              return [o4, s3, r4];
            case 4:
              return [a3, o4, r4];
            case 5:
              return [r4, o4, s3];
          }
        }, r3.hsv.hsl = function(e4) {
          var t4, n4, r4, i4 = e4[0], u4 = e4[1] / 100, o4 = e4[2] / 100, s3 = Math.max(o4, 0.01);
          return r4 = (2 - u4) * o4, n4 = u4 * s3, [i4, 100 * (n4 = (n4 /= (t4 = (2 - u4) * s3) <= 1 ? t4 : 2 - t4) || 0), 100 * (r4 /= 2)];
        }, r3.hwb.rgb = function(e4) {
          var t4, n4, r4, i4, u4, o4, s3, a3 = e4[0] / 360, c3 = e4[1] / 100, l3 = e4[2] / 100, p3 = c3 + l3;
          switch (p3 > 1 && (c3 /= p3, l3 /= p3), r4 = 6 * a3 - (t4 = Math.floor(6 * a3)), (1 & t4) != 0 && (r4 = 1 - r4), i4 = c3 + r4 * ((n4 = 1 - l3) - c3), t4) {
            default:
            case 6:
            case 0:
              u4 = n4, o4 = i4, s3 = c3;
              break;
            case 1:
              u4 = i4, o4 = n4, s3 = c3;
              break;
            case 2:
              u4 = c3, o4 = n4, s3 = i4;
              break;
            case 3:
              u4 = c3, o4 = i4, s3 = n4;
              break;
            case 4:
              u4 = i4, o4 = c3, s3 = n4;
              break;
            case 5:
              u4 = n4, o4 = c3, s3 = i4;
          }
          return [255 * u4, 255 * o4, 255 * s3];
        }, r3.cmyk.rgb = function(e4) {
          var t4 = e4[0] / 100, n4 = e4[1] / 100, r4 = e4[2] / 100, i4 = e4[3] / 100;
          return [255 * (1 - Math.min(1, t4 * (1 - i4) + i4)), 255 * (1 - Math.min(1, n4 * (1 - i4) + i4)), 255 * (1 - Math.min(1, r4 * (1 - i4) + i4))];
        }, r3.xyz.rgb = function(e4) {
          var t4, n4, r4, i4 = e4[0] / 100, u4 = e4[1] / 100, o4 = e4[2] / 100;
          return n4 = -0.9689 * i4 + 1.8758 * u4 + 0.0415 * o4, r4 = 0.0557 * i4 + -0.204 * u4 + 1.057 * o4, t4 = (t4 = 3.2406 * i4 + -1.5372 * u4 + -0.4986 * o4) > 31308e-7 ? 1.055 * Math.pow(t4, 1 / 2.4) - 0.055 : 12.92 * t4, n4 = n4 > 31308e-7 ? 1.055 * Math.pow(n4, 1 / 2.4) - 0.055 : 12.92 * n4, r4 = r4 > 31308e-7 ? 1.055 * Math.pow(r4, 1 / 2.4) - 0.055 : 12.92 * r4, [255 * (t4 = Math.min(Math.max(0, t4), 1)), 255 * (n4 = Math.min(Math.max(0, n4), 1)), 255 * (r4 = Math.min(Math.max(0, r4), 1))];
        }, r3.xyz.lab = function(e4) {
          var t4 = e4[0], n4 = e4[1], r4 = e4[2];
          return n4 /= 100, r4 /= 108.883, t4 = (t4 /= 95.047) > 8856e-6 ? Math.pow(t4, 1 / 3) : 7.787 * t4 + 16 / 116, [116 * (n4 = n4 > 8856e-6 ? Math.pow(n4, 1 / 3) : 7.787 * n4 + 16 / 116) - 16, 500 * (t4 - n4), 200 * (n4 - (r4 = r4 > 8856e-6 ? Math.pow(r4, 1 / 3) : 7.787 * r4 + 16 / 116))];
        }, r3.lab.xyz = function(e4) {
          var t4, n4, r4, i4 = e4[0];
          t4 = e4[1] / 500 + (n4 = (i4 + 16) / 116), r4 = n4 - e4[2] / 200;
          var u4 = Math.pow(n4, 3), o4 = Math.pow(t4, 3), s3 = Math.pow(r4, 3);
          return n4 = u4 > 8856e-6 ? u4 : (n4 - 16 / 116) / 7.787, t4 = o4 > 8856e-6 ? o4 : (t4 - 16 / 116) / 7.787, r4 = s3 > 8856e-6 ? s3 : (r4 - 16 / 116) / 7.787, [t4 *= 95.047, n4 *= 100, r4 *= 108.883];
        }, r3.lab.lch = function(e4) {
          var t4, n4 = e4[0], r4 = e4[1], i4 = e4[2];
          return (t4 = 360 * Math.atan2(i4, r4) / 2 / Math.PI) < 0 && (t4 += 360), [n4, Math.sqrt(r4 * r4 + i4 * i4), t4];
        }, r3.lch.lab = function(e4) {
          var t4, n4 = e4[0], r4 = e4[1];
          return t4 = e4[2] / 360 * 2 * Math.PI, [n4, r4 * Math.cos(t4), r4 * Math.sin(t4)];
        }, r3.rgb.ansi16 = function(e4) {
          var t4 = e4[0], n4 = e4[1], i4 = e4[2], u4 = 1 in arguments ? arguments[1] : r3.rgb.hsv(e4)[2];
          if ((u4 = Math.round(u4 / 50)) === 0)
            return 30;
          var o4 = 30 + (Math.round(i4 / 255) << 2 | Math.round(n4 / 255) << 1 | Math.round(t4 / 255));
          return u4 === 2 && (o4 += 60), o4;
        }, r3.hsv.ansi16 = function(e4) {
          return r3.rgb.ansi16(r3.hsv.rgb(e4), e4[2]);
        }, r3.rgb.ansi256 = function(e4) {
          var t4 = e4[0], n4 = e4[1], r4 = e4[2];
          return t4 === n4 && n4 === r4 ? t4 < 8 ? 16 : t4 > 248 ? 231 : Math.round((t4 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t4 / 255 * 5) + 6 * Math.round(n4 / 255 * 5) + Math.round(r4 / 255 * 5);
        }, r3.ansi16.rgb = function(e4) {
          var t4 = e4 % 10;
          if (t4 === 0 || t4 === 7)
            return e4 > 50 && (t4 += 3.5), [t4 = t4 / 10.5 * 255, t4, t4];
          var n4 = 0.5 * (1 + ~~(e4 > 50));
          return [(1 & t4) * n4 * 255, (t4 >> 1 & 1) * n4 * 255, (t4 >> 2 & 1) * n4 * 255];
        }, r3.ansi256.rgb = function(e4) {
          if (e4 >= 232) {
            var t4 = 10 * (e4 - 232) + 8;
            return [t4, t4, t4];
          }
          var n4;
          return e4 -= 16, [Math.floor(e4 / 36) / 5 * 255, Math.floor((n4 = e4 % 36) / 6) / 5 * 255, n4 % 6 / 5 * 255];
        }, r3.rgb.hex = function(e4) {
          var t4 = (((255 & Math.round(e4[0])) << 16) + ((255 & Math.round(e4[1])) << 8) + (255 & Math.round(e4[2]))).toString(16).toUpperCase();
          return "000000".substring(t4.length) + t4;
        }, r3.hex.rgb = function(e4) {
          var t4 = e4.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!t4)
            return [0, 0, 0];
          var n4 = t4[0];
          t4[0].length === 3 && (n4 = n4.split("").map(function(e5) {
            return e5 + e5;
          }).join(""));
          var r4 = parseInt(n4, 16);
          return [r4 >> 16 & 255, r4 >> 8 & 255, 255 & r4];
        }, r3.rgb.hcg = function(e4) {
          var t4, n4 = e4[0] / 255, r4 = e4[1] / 255, i4 = e4[2] / 255, u4 = Math.max(Math.max(n4, r4), i4), o4 = Math.min(Math.min(n4, r4), i4), s3 = u4 - o4;
          return t4 = s3 <= 0 ? 0 : u4 === n4 ? (r4 - i4) / s3 % 6 : u4 === r4 ? 2 + (i4 - n4) / s3 : 4 + (n4 - r4) / s3 + 4, t4 /= 6, [360 * (t4 %= 1), 100 * s3, 100 * (s3 < 1 ? o4 / (1 - s3) : 0)];
        }, r3.hsl.hcg = function(e4) {
          var t4 = e4[1] / 100, n4 = e4[2] / 100, r4 = 1, i4 = 0;
          return (r4 = n4 < 0.5 ? 2 * t4 * n4 : 2 * t4 * (1 - n4)) < 1 && (i4 = (n4 - 0.5 * r4) / (1 - r4)), [e4[0], 100 * r4, 100 * i4];
        }, r3.hsv.hcg = function(e4) {
          var t4 = e4[1] / 100, n4 = e4[2] / 100, r4 = t4 * n4, i4 = 0;
          return r4 < 1 && (i4 = (n4 - r4) / (1 - r4)), [e4[0], 100 * r4, 100 * i4];
        }, r3.hcg.rgb = function(e4) {
          var t4 = e4[0] / 360, n4 = e4[1] / 100, r4 = e4[2] / 100;
          if (n4 === 0)
            return [255 * r4, 255 * r4, 255 * r4];
          var i4, u4 = [0, 0, 0], o4 = t4 % 1 * 6, s3 = o4 % 1, a3 = 1 - s3;
          switch (Math.floor(o4)) {
            case 0:
              u4[0] = 1, u4[1] = s3, u4[2] = 0;
              break;
            case 1:
              u4[0] = a3, u4[1] = 1, u4[2] = 0;
              break;
            case 2:
              u4[0] = 0, u4[1] = 1, u4[2] = s3;
              break;
            case 3:
              u4[0] = 0, u4[1] = a3, u4[2] = 1;
              break;
            case 4:
              u4[0] = s3, u4[1] = 0, u4[2] = 1;
              break;
            default:
              u4[0] = 1, u4[1] = 0, u4[2] = a3;
          }
          return i4 = (1 - n4) * r4, [255 * (n4 * u4[0] + i4), 255 * (n4 * u4[1] + i4), 255 * (n4 * u4[2] + i4)];
        }, r3.hcg.hsv = function(e4) {
          var t4 = e4[1] / 100, n4 = t4 + e4[2] / 100 * (1 - t4), r4 = 0;
          return n4 > 0 && (r4 = t4 / n4), [e4[0], 100 * r4, 100 * n4];
        }, r3.hcg.hsl = function(e4) {
          var t4 = e4[1] / 100, n4 = e4[2] / 100 * (1 - t4) + 0.5 * t4, r4 = 0;
          return n4 > 0 && n4 < 0.5 ? r4 = t4 / (2 * n4) : n4 >= 0.5 && n4 < 1 && (r4 = t4 / (2 * (1 - n4))), [e4[0], 100 * r4, 100 * n4];
        }, r3.hcg.hwb = function(e4) {
          var t4 = e4[1] / 100, n4 = t4 + e4[2] / 100 * (1 - t4);
          return [e4[0], 100 * (n4 - t4), 100 * (1 - n4)];
        }, r3.hwb.hcg = function(e4) {
          var t4 = e4[1] / 100, n4 = 1 - e4[2] / 100, r4 = n4 - t4, i4 = 0;
          return r4 < 1 && (i4 = (n4 - r4) / (1 - r4)), [e4[0], 100 * r4, 100 * i4];
        }, r3.apple.rgb = function(e4) {
          return [e4[0] / 65535 * 255, e4[1] / 65535 * 255, e4[2] / 65535 * 255];
        }, r3.rgb.apple = function(e4) {
          return [e4[0] / 255 * 65535, e4[1] / 255 * 65535, e4[2] / 255 * 65535];
        }, r3.gray.rgb = function(e4) {
          return [e4[0] / 100 * 255, e4[0] / 100 * 255, e4[0] / 100 * 255];
        }, r3.gray.hsl = r3.gray.hsv = function(e4) {
          return [0, 0, e4[0]];
        }, r3.gray.hwb = function(e4) {
          return [0, 100, e4[0]];
        }, r3.gray.cmyk = function(e4) {
          return [0, 0, 0, e4[0]];
        }, r3.gray.lab = function(e4) {
          return [e4[0], 0, 0];
        }, r3.gray.hex = function(e4) {
          var t4 = 255 & Math.round(e4[0] / 100 * 255), n4 = ((t4 << 16) + (t4 << 8) + t4).toString(16).toUpperCase();
          return "000000".substring(n4.length) + n4;
        }, r3.rgb.gray = function(e4) {
          return [(e4[0] + e4[1] + e4[2]) / 3 / 255 * 100];
        };
      });
      function Wo2(e3) {
        var t3 = function() {
          for (var e4 = {}, t4 = Object.keys(Vo2), n4 = t4.length, r4 = 0; r4 < n4; r4++)
            e4[t4[r4]] = { distance: -1, parent: null };
          return e4;
        }(), n3 = [e3];
        for (t3[e3].distance = 0; n3.length; )
          for (var r3 = n3.pop(), i3 = Object.keys(Vo2[r3]), u3 = i3.length, o3 = 0; o3 < u3; o3++) {
            var s3 = i3[o3], a3 = t3[s3];
            a3.distance === -1 && (a3.distance = t3[r3].distance + 1, a3.parent = r3, n3.unshift(s3));
          }
        return t3;
      }
      function qo2(e3, t3) {
        return function(n3) {
          return t3(e3(n3));
        };
      }
      function Uo2(e3, t3) {
        for (var n3 = [t3[e3].parent, e3], r3 = Vo2[t3[e3].parent][e3], i3 = t3[e3].parent; t3[i3].parent; )
          n3.unshift(t3[i3].parent), r3 = qo2(Vo2[t3[i3].parent][i3], r3), i3 = t3[i3].parent;
        return r3.conversion = n3, r3;
      }
      var zo2 = {};
      Object.keys(Vo2).forEach(function(e3) {
        zo2[e3] = {}, Object.defineProperty(zo2[e3], "channels", { value: Vo2[e3].channels }), Object.defineProperty(zo2[e3], "labels", { value: Vo2[e3].labels });
        var t3 = function(e4) {
          for (var t4 = Wo2(e4), n3 = {}, r3 = Object.keys(t4), i3 = r3.length, u3 = 0; u3 < i3; u3++) {
            var o3 = r3[u3];
            t4[o3].parent !== null && (n3[o3] = Uo2(o3, t4));
          }
          return n3;
        }(e3);
        Object.keys(t3).forEach(function(n3) {
          var r3 = t3[n3];
          zo2[e3][n3] = function(e4) {
            var t4 = function(t5) {
              if (t5 == null)
                return t5;
              arguments.length > 1 && (t5 = Array.prototype.slice.call(arguments));
              var n4 = e4(t5);
              if (typeof n4 == "object")
                for (var r4 = n4.length, i3 = 0; i3 < r4; i3++)
                  n4[i3] = Math.round(n4[i3]);
              return n4;
            };
            return "conversion" in e4 && (t4.conversion = e4.conversion), t4;
          }(r3), zo2[e3][n3].raw = function(e4) {
            var t4 = function(t5) {
              return t5 == null ? t5 : (arguments.length > 1 && (t5 = Array.prototype.slice.call(arguments)), e4(t5));
            };
            return "conversion" in e4 && (t4.conversion = e4.conversion), t4;
          }(r3);
        });
      });
      var Go2, Ho2 = zo2, Jo2 = r2(function(e3) {
        const t3 = (e4, t4) => function() {
          const n4 = e4.apply(Ho2, arguments);
          return `[${n4 + t4}m`;
        }, n3 = (e4, t4) => function() {
          const n4 = e4.apply(Ho2, arguments);
          return `[${38 + t4};5;${n4}m`;
        }, r3 = (e4, t4) => function() {
          const n4 = e4.apply(Ho2, arguments);
          return `[${38 + t4};2;${n4[0]};${n4[1]};${n4[2]}m`;
        };
        Object.defineProperty(e3, "exports", { enumerable: true, get: function() {
          const e4 = new Map(), i3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
          i3.color.grey = i3.color.gray;
          for (const t4 of Object.keys(i3)) {
            const n4 = i3[t4];
            for (const t5 of Object.keys(n4)) {
              const r4 = n4[t5];
              i3[t5] = { open: `[${r4[0]}m`, close: `[${r4[1]}m` }, n4[t5] = i3[t5], e4.set(r4[0], r4[1]);
            }
            Object.defineProperty(i3, t4, { value: n4, enumerable: false }), Object.defineProperty(i3, "codes", { value: e4, enumerable: false });
          }
          const u3 = (e5) => e5, o3 = (e5, t4, n4) => [e5, t4, n4];
          i3.color.close = "[39m", i3.bgColor.close = "[49m", i3.color.ansi = { ansi: t3(u3, 0) }, i3.color.ansi256 = { ansi256: n3(u3, 0) }, i3.color.ansi16m = { rgb: r3(o3, 0) }, i3.bgColor.ansi = { ansi: t3(u3, 10) }, i3.bgColor.ansi256 = { ansi256: n3(u3, 10) }, i3.bgColor.ansi16m = { rgb: r3(o3, 10) };
          for (let e5 of Object.keys(Ho2)) {
            if (typeof Ho2[e5] != "object")
              continue;
            const u4 = Ho2[e5];
            e5 === "ansi16" && (e5 = "ansi"), "ansi16" in u4 && (i3.color.ansi[e5] = t3(u4.ansi16, 0), i3.bgColor.ansi[e5] = t3(u4.ansi16, 10)), "ansi256" in u4 && (i3.color.ansi256[e5] = n3(u4.ansi256, 0), i3.bgColor.ansi256[e5] = n3(u4.ansi256, 10)), "rgb" in u4 && (i3.color.ansi16m[e5] = r3(u4.rgb, 0), i3.bgColor.ansi16m[e5] = r3(u4.rgb, 10));
          }
          return i3;
        } });
      });
      function Xo2() {
        if (Go2 === void 0) {
          var e3 = new ArrayBuffer(2), t3 = new Uint8Array(e3), n3 = new Uint16Array(e3);
          if (t3[0] = 1, t3[1] = 2, n3[0] === 258)
            Go2 = "BE";
          else {
            if (n3[0] !== 513)
              throw new Error("unable to figure out endianess");
            Go2 = "LE";
          }
        }
        return Go2;
      }
      function Yo2() {
        return ir2.location !== void 0 ? ir2.location.hostname : "";
      }
      function Ko2() {
        return [];
      }
      function Qo2() {
        return 0;
      }
      function Zo2() {
        return Number.MAX_VALUE;
      }
      function es2() {
        return Number.MAX_VALUE;
      }
      function ts2() {
        return [];
      }
      function ns2() {
        return "Browser";
      }
      function rs2() {
        return ir2.navigator !== void 0 ? ir2.navigator.appVersion : "";
      }
      function is2() {
      }
      function us2() {
      }
      function os2() {
        return "javascript";
      }
      function ss2() {
        return "browser";
      }
      function as2() {
        return "/tmp";
      }
      var cs2 = as2, ls2 = { EOL: "\n", arch: os2, platform: ss2, tmpdir: cs2, tmpDir: as2, networkInterfaces: is2, getNetworkInterfaces: us2, release: rs2, type: ns2, cpus: ts2, totalmem: es2, freemem: Zo2, uptime: Qo2, loadavg: Ko2, hostname: Yo2, endianness: Xo2 }, ps2 = (e3, t3) => {
        t3 = t3 || Tr2.argv;
        const n3 = e3.startsWith("-") ? "" : e3.length === 1 ? "-" : "--", r3 = t3.indexOf(n3 + e3), i3 = t3.indexOf("--");
        return r3 !== -1 && (i3 === -1 || r3 < i3);
      }, fs2 = n2(Object.freeze({ __proto__: null, endianness: Xo2, hostname: Yo2, loadavg: Ko2, uptime: Qo2, freemem: Zo2, totalmem: es2, cpus: ts2, type: ns2, release: rs2, networkInterfaces: is2, getNetworkInterfaces: us2, arch: os2, platform: ss2, tmpDir: as2, tmpdir: cs2, EOL: "\n", default: ls2 }));
      const ds2 = Tr2.env;
      let hs2;
      function gs2(e3) {
        return function(e4) {
          return e4 !== 0 && { level: e4, hasBasic: true, has256: e4 >= 2, has16m: e4 >= 3 };
        }(function(e4) {
          if (hs2 === false)
            return 0;
          if (ps2("color=16m") || ps2("color=full") || ps2("color=truecolor"))
            return 3;
          if (ps2("color=256"))
            return 2;
          if (e4 && !e4.isTTY && hs2 !== true)
            return 0;
          const t3 = hs2 ? 1 : 0;
          if ("CI" in ds2)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e5) => e5 in ds2) || ds2.CI_NAME === "codeship" ? 1 : t3;
          if ("TEAMCITY_VERSION" in ds2)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ds2.TEAMCITY_VERSION) ? 1 : 0;
          if (ds2.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in ds2) {
            const e5 = parseInt((ds2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (ds2.TERM_PROGRAM) {
              case "iTerm.app":
                return e5 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(ds2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ds2.TERM) || "COLORTERM" in ds2 ? 1 : (ds2.TERM, t3);
        }(e3));
      }
      ps2("no-color") || ps2("no-colors") || ps2("color=false") ? hs2 = false : (ps2("color") || ps2("colors") || ps2("color=true") || ps2("color=always")) && (hs2 = true), "FORCE_COLOR" in ds2 && (hs2 = ds2.FORCE_COLOR.length === 0 || parseInt(ds2.FORCE_COLOR, 10) !== 0);
      var ms2 = { supportsColor: gs2, stdout: gs2(Tr2.stdout), stderr: gs2(Tr2.stderr) };
      const ys2 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Ds2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Es2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Cs2 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, bs2 = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function As2(e3) {
        return e3[0] === "u" && e3.length === 5 || e3[0] === "x" && e3.length === 3 ? String.fromCharCode(parseInt(e3.slice(1), 16)) : bs2.get(e3) || e3;
      }
      function vs2(e3, t3) {
        const n3 = [], r3 = t3.trim().split(/\s*,\s*/g);
        let i3;
        for (const t4 of r3)
          if (isNaN(t4)) {
            if (!(i3 = t4.match(Es2)))
              throw new Error(`Invalid Chalk template style argument: ${t4} (in style '${e3}')`);
            n3.push(i3[2].replace(Cs2, (e4, t5, n4) => t5 ? As2(t5) : n4));
          } else
            n3.push(Number(t4));
        return n3;
      }
      function Fs2(e3) {
        Ds2.lastIndex = 0;
        const t3 = [];
        let n3;
        for (; (n3 = Ds2.exec(e3)) !== null; ) {
          const e4 = n3[1];
          if (n3[2]) {
            const r3 = vs2(e4, n3[2]);
            t3.push([e4].concat(r3));
          } else
            t3.push([e4]);
        }
        return t3;
      }
      function xs2(e3, t3) {
        const n3 = {};
        for (const e4 of t3)
          for (const t4 of e4.styles)
            n3[t4[0]] = e4.inverse ? null : t4.slice(1);
        let r3 = e3;
        for (const e4 of Object.keys(n3))
          if (Array.isArray(n3[e4])) {
            if (!(e4 in r3))
              throw new Error(`Unknown Chalk style: ${e4}`);
            r3 = n3[e4].length > 0 ? r3[e4].apply(r3, n3[e4]) : r3[e4];
          }
        return r3;
      }
      var Ss2 = (e3, t3) => {
        const n3 = [], r3 = [];
        let i3 = [];
        if (t3.replace(ys2, (t4, u3, o3, s3, a3, c3) => {
          if (u3)
            i3.push(As2(u3));
          else if (s3) {
            const t5 = i3.join("");
            i3 = [], r3.push(n3.length === 0 ? t5 : xs2(e3, n3)(t5)), n3.push({ inverse: o3, styles: Fs2(s3) });
          } else if (a3) {
            if (n3.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r3.push(xs2(e3, n3)(i3.join(""))), i3 = [], n3.pop();
          } else
            i3.push(c3);
        }), r3.push(i3.join("")), n3.length > 0) {
          const e4 = `Chalk template literal is missing ${n3.length} closing bracket${n3.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(e4);
        }
        return r3.join("");
      }, ws2 = r2(function(e3) {
        const t3 = ms2.stdout, r3 = ["ansi", "ansi", "ansi256", "ansi16m"], i3 = new Set(["gray"]), u3 = Object.create(null);
        function o3(e4, n3) {
          n3 = n3 || {};
          const r4 = t3 ? t3.level : 0;
          e4.level = n3.level === void 0 ? r4 : n3.level, e4.enabled = "enabled" in n3 ? n3.enabled : e4.level > 0;
        }
        function s3(e4) {
          if (!this || !(this instanceof s3) || this.template) {
            const t4 = {};
            return o3(t4, e4), t4.template = function() {
              const e5 = [].slice.call(arguments);
              return p3.apply(null, [t4.template].concat(e5));
            }, Object.setPrototypeOf(t4, s3.prototype), Object.setPrototypeOf(t4.template, t4), t4.template.constructor = s3, t4.template;
          }
          o3(this, e4);
        }
        for (const e4 of Object.keys(Jo2))
          Jo2[e4].closeRe = new RegExp(Ro2(Jo2[e4].close), "g"), u3[e4] = { get() {
            const t4 = Jo2[e4];
            return c3.call(this, this._styles ? this._styles.concat(t4) : [t4], this._empty, e4);
          } };
        u3.visible = { get() {
          return c3.call(this, this._styles || [], true, "visible");
        } }, Jo2.color.closeRe = new RegExp(Ro2(Jo2.color.close), "g");
        for (const e4 of Object.keys(Jo2.color.ansi))
          i3.has(e4) || (u3[e4] = { get() {
            const t4 = this.level;
            return function() {
              const n3 = Jo2.color[r3[t4]][e4].apply(null, arguments), i4 = { open: n3, close: Jo2.color.close, closeRe: Jo2.color.closeRe };
              return c3.call(this, this._styles ? this._styles.concat(i4) : [i4], this._empty, e4);
            };
          } });
        Jo2.bgColor.closeRe = new RegExp(Ro2(Jo2.bgColor.close), "g");
        for (const e4 of Object.keys(Jo2.bgColor.ansi)) {
          if (i3.has(e4))
            continue;
          u3["bg" + e4[0].toUpperCase() + e4.slice(1)] = { get() {
            const t4 = this.level;
            return function() {
              const n3 = Jo2.bgColor[r3[t4]][e4].apply(null, arguments), i4 = { open: n3, close: Jo2.bgColor.close, closeRe: Jo2.bgColor.closeRe };
              return c3.call(this, this._styles ? this._styles.concat(i4) : [i4], this._empty, e4);
            };
          } };
        }
        const a3 = Object.defineProperties(() => {
        }, u3);
        function c3(e4, t4, n3) {
          const r4 = function() {
            return l3.apply(r4, arguments);
          };
          r4._styles = e4, r4._empty = t4;
          const i4 = this;
          return Object.defineProperty(r4, "level", { enumerable: true, get: () => i4.level, set(e5) {
            i4.level = e5;
          } }), Object.defineProperty(r4, "enabled", { enumerable: true, get: () => i4.enabled, set(e5) {
            i4.enabled = e5;
          } }), r4.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r4.__proto__ = a3, r4;
        }
        function l3() {
          const e4 = arguments, t4 = e4.length;
          let r4 = String(arguments[0]);
          if (t4 === 0)
            return "";
          if (t4 > 1)
            for (let n3 = 1; n3 < t4; n3++)
              r4 += " " + e4[n3];
          if (!this.enabled || this.level <= 0 || !r4)
            return this._empty ? "" : r4;
          const i4 = Jo2.dim.open;
          for (const e5 of this._styles.slice().reverse())
            r4 = e5.open + r4.replace(e5.closeRe, e5.open) + e5.close, r4 = r4.replace(/\r?\n/g, `${e5.close}$&${e5.open}`);
          return Jo2.dim.open = i4, r4;
        }
        function p3(e4, t4) {
          if (!Array.isArray(t4))
            return [].slice.call(arguments, 1).join(" ");
          const n3 = [].slice.call(arguments, 2), r4 = [t4.raw[0]];
          for (let e5 = 1; e5 < t4.length; e5++)
            r4.push(String(n3[e5 - 1]).replace(/[{}\\]/g, "\\$&")), r4.push(String(t4.raw[e5]));
          return Ss2(e4, r4.join(""));
        }
        Object.defineProperties(s3.prototype, u3), e3.exports = s3(), e3.exports.supportsColor = t3, e3.exports.default = e3.exports;
      }), Ts2 = Object.defineProperty({ commonDeprecatedHandler: (e3, t3, { descriptor: n3 }) => {
        const r3 = [`${ws2.default.yellow(typeof e3 == "string" ? n3.key(e3) : n3.pair(e3))} is deprecated`];
        return t3 && r3.push(`we now treat it as ${ws2.default.blue(typeof t3 == "string" ? n3.key(t3) : n3.pair(t3))}`), r3.join("; ") + ".";
      } }, "__esModule", { value: true }), Bs2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Lo2.__exportStar(Ts2, t3);
      }), Ns2 = Object.defineProperty({ commonInvalidHandler: (e3, t3, n3) => [`Invalid ${ws2.default.red(n3.descriptor.key(e3))} value.`, `Expected ${ws2.default.blue(n3.schemas[e3].expected(n3))},`, `but received ${ws2.default.red(n3.descriptor.value(t3))}.`].join(" ") }, "__esModule", { value: true }), ks2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Lo2.__exportStar(Ns2, t3);
      }), Ps2 = [], Os2 = [], Is2 = Object.defineProperty({ levenUnknownHandler: (e3, t3, { descriptor: n3, logger: r3, schemas: i3 }) => {
        const u3 = [`Ignored unknown option ${ws2.default.yellow(n3.pair({ key: e3, value: t3 }))}.`], o3 = Object.keys(i3).sort().find((t4) => function(e4, t5) {
          if (e4 === t5)
            return 0;
          var n4 = e4;
          e4.length > t5.length && (e4 = t5, t5 = n4);
          var r4 = e4.length, i4 = t5.length;
          if (r4 === 0)
            return i4;
          if (i4 === 0)
            return r4;
          for (; r4 > 0 && e4.charCodeAt(~-r4) === t5.charCodeAt(~-i4); )
            r4--, i4--;
          if (r4 === 0)
            return i4;
          for (var u4, o4, s3, a3, c3 = 0; c3 < r4 && e4.charCodeAt(c3) === t5.charCodeAt(c3); )
            c3++;
          if (i4 -= c3, (r4 -= c3) == 0)
            return i4;
          for (var l3 = 0, p3 = 0; l3 < r4; )
            Os2[c3 + l3] = e4.charCodeAt(c3 + l3), Ps2[l3] = ++l3;
          for (; p3 < i4; )
            for (u4 = t5.charCodeAt(c3 + p3), s3 = p3++, o4 = p3, l3 = 0; l3 < r4; l3++)
              a3 = u4 === Os2[c3 + l3] ? s3 : s3 + 1, s3 = Ps2[l3], o4 = Ps2[l3] = s3 > o4 ? a3 > o4 ? o4 + 1 : a3 : a3 > s3 ? s3 + 1 : a3;
          return o4;
        }(e3, t4) < 3);
        o3 && u3.push(`Did you mean ${ws2.default.blue(n3.key(o3))}?`), r3.warn(u3.join(" "));
      } }, "__esModule", { value: true }), Ls2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Lo2.__exportStar(Is2, t3);
      }), js2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Lo2.__exportStar(Bs2, t3), Lo2.__exportStar(ks2, t3), Lo2.__exportStar(Ls2, t3);
      });
      const _s2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
      function Ms2(e3, t3) {
        const n3 = new e3(t3), r3 = Object.create(n3);
        for (const e4 of _s2)
          e4 in t3 && (r3[e4] = Ws2(t3[e4], n3, $s2.prototype[e4].length));
        return r3;
      }
      var Rs2 = Ms2;
      class $s2 {
        constructor(e3) {
          this.name = e3.name;
        }
        static create(e3) {
          return Ms2(this, e3);
        }
        default(e3) {
        }
        expected(e3) {
          return "nothing";
        }
        validate(e3, t3) {
          return false;
        }
        deprecated(e3, t3) {
          return false;
        }
        forward(e3, t3) {
        }
        redirect(e3, t3) {
        }
        overlap(e3, t3, n3) {
          return e3;
        }
        preprocess(e3, t3) {
          return e3;
        }
        postprocess(e3, t3) {
          return e3;
        }
      }
      var Vs2 = $s2;
      function Ws2(e3, t3, n3) {
        return typeof e3 == "function" ? (...r3) => e3(...r3.slice(0, n3 - 1), t3, ...r3.slice(n3 - 1)) : () => e3;
      }
      var qs2 = Object.defineProperty({ createSchema: Rs2, Schema: Vs2 }, "__esModule", { value: true });
      class Us2 extends qs2.Schema {
        constructor(e3) {
          super(e3), this._sourceName = e3.sourceName;
        }
        expected(e3) {
          return e3.schemas[this._sourceName].expected(e3);
        }
        validate(e3, t3) {
          return t3.schemas[this._sourceName].validate(e3, t3);
        }
        redirect(e3, t3) {
          return this._sourceName;
        }
      }
      var zs2 = Us2, Gs2 = Object.defineProperty({ AliasSchema: zs2 }, "__esModule", { value: true });
      class Hs2 extends qs2.Schema {
        expected() {
          return "anything";
        }
        validate() {
          return true;
        }
      }
      var Js2 = Hs2, Xs2 = Object.defineProperty({ AnySchema: Js2 }, "__esModule", { value: true });
      class Ys2 extends qs2.Schema {
        constructor(e3) {
          var { valueSchema: t3, name: n3 = t3.name } = e3, r3 = Lo2.__rest(e3, ["valueSchema", "name"]);
          super(Object.assign({}, r3, { name: n3 })), this._valueSchema = t3;
        }
        expected(e3) {
          return `an array of ${this._valueSchema.expected(e3)}`;
        }
        validate(e3, t3) {
          if (!Array.isArray(e3))
            return false;
          const n3 = [];
          for (const r3 of e3) {
            const e4 = t3.normalizeValidateResult(this._valueSchema.validate(r3, t3), r3);
            e4 !== true && n3.push(e4.value);
          }
          return n3.length === 0 || { value: n3 };
        }
        deprecated(e3, t3) {
          const n3 = [];
          for (const r3 of e3) {
            const e4 = t3.normalizeDeprecatedResult(this._valueSchema.deprecated(r3, t3), r3);
            e4 !== false && n3.push(...e4.map(({ value: e5 }) => ({ value: [e5] })));
          }
          return n3;
        }
        forward(e3, t3) {
          const n3 = [];
          for (const r3 of e3) {
            const e4 = t3.normalizeForwardResult(this._valueSchema.forward(r3, t3), r3);
            n3.push(...e4.map(Qs2));
          }
          return n3;
        }
        redirect(e3, t3) {
          const n3 = [], r3 = [];
          for (const i3 of e3) {
            const e4 = t3.normalizeRedirectResult(this._valueSchema.redirect(i3, t3), i3);
            "remain" in e4 && n3.push(e4.remain), r3.push(...e4.redirect.map(Qs2));
          }
          return n3.length === 0 ? { redirect: r3 } : { redirect: r3, remain: n3 };
        }
        overlap(e3, t3) {
          return e3.concat(t3);
        }
      }
      var Ks2 = Ys2;
      function Qs2({ from: e3, to: t3 }) {
        return { from: [e3], to: t3 };
      }
      var Zs2 = Object.defineProperty({ ArraySchema: Ks2 }, "__esModule", { value: true });
      class ea2 extends qs2.Schema {
        expected() {
          return "true or false";
        }
        validate(e3) {
          return typeof e3 == "boolean";
        }
      }
      var ta2 = ea2, na2 = Object.defineProperty({ BooleanSchema: ta2 }, "__esModule", { value: true });
      var ra2 = function(e3, t3) {
        const n3 = Object.create(null);
        for (const r3 of e3) {
          const e4 = r3[t3];
          if (n3[e4])
            throw new Error(`Duplicate ${t3} ${JSON.stringify(e4)}`);
          n3[e4] = r3;
        }
        return n3;
      };
      var ia2 = function(e3, t3) {
        const n3 = new Map();
        for (const r3 of e3) {
          const e4 = r3[t3];
          if (n3.has(e4))
            throw new Error(`Duplicate ${t3} ${JSON.stringify(e4)}`);
          n3.set(e4, r3);
        }
        return n3;
      };
      var ua2 = function() {
        const e3 = Object.create(null);
        return (t3) => {
          const n3 = JSON.stringify(t3);
          return !!e3[n3] || (e3[n3] = true, false);
        };
      };
      var oa2 = function(e3, t3) {
        const n3 = [], r3 = [];
        for (const i3 of e3)
          t3(i3) ? n3.push(i3) : r3.push(i3);
        return [n3, r3];
      };
      var sa2 = function(e3) {
        return e3 === Math.floor(e3);
      };
      var aa2 = function(e3, t3) {
        if (e3 === t3)
          return 0;
        const n3 = typeof e3, r3 = typeof t3, i3 = ["undefined", "object", "boolean", "number", "string"];
        return n3 !== r3 ? i3.indexOf(n3) - i3.indexOf(r3) : n3 !== "string" ? Number(e3) - Number(t3) : e3.localeCompare(t3);
      };
      var ca2 = function(e3) {
        return e3 === void 0 ? {} : e3;
      };
      var la2 = function(e3, t3) {
        return e3 === true || (e3 === false ? { value: t3 } : e3);
      };
      var pa2 = function(e3, t3, n3 = false) {
        return e3 !== false && (e3 === true ? !!n3 || [{ value: t3 }] : "value" in e3 ? [e3] : e3.length !== 0 && e3);
      };
      function fa2(e3, t3) {
        return typeof e3 == "string" || "key" in e3 ? { from: t3, to: e3 } : "from" in e3 ? { from: e3.from, to: e3.to } : { from: t3, to: e3.to };
      }
      var da2 = fa2;
      function ha2(e3, t3) {
        return e3 === void 0 ? [] : Array.isArray(e3) ? e3.map((e4) => fa2(e4, t3)) : [fa2(e3, t3)];
      }
      var ga2 = ha2;
      var ma2 = function(e3, t3) {
        const n3 = ha2(typeof e3 == "object" && "redirect" in e3 ? e3.redirect : e3, t3);
        return n3.length === 0 ? { remain: t3, redirect: n3 } : typeof e3 == "object" && "remain" in e3 ? { remain: e3.remain, redirect: n3 } : { redirect: n3 };
      }, ya2 = Object.defineProperty({ recordFromArray: ra2, mapFromArray: ia2, createAutoChecklist: ua2, partition: oa2, isInt: sa2, comparePrimitive: aa2, normalizeDefaultResult: ca2, normalizeValidateResult: la2, normalizeDeprecatedResult: pa2, normalizeTransferResult: da2, normalizeForwardResult: ga2, normalizeRedirectResult: ma2 }, "__esModule", { value: true });
      class Da2 extends qs2.Schema {
        constructor(e3) {
          super(e3), this._choices = ya2.mapFromArray(e3.choices.map((e4) => e4 && typeof e4 == "object" ? e4 : { value: e4 }), "value");
        }
        expected({ descriptor: e3 }) {
          const t3 = Array.from(this._choices.keys()).map((e4) => this._choices.get(e4)).filter((e4) => !e4.deprecated).map((e4) => e4.value).sort(ya2.comparePrimitive).map(e3.value), n3 = t3.slice(0, -2), r3 = t3.slice(-2);
          return n3.concat(r3.join(" or ")).join(", ");
        }
        validate(e3) {
          return this._choices.has(e3);
        }
        deprecated(e3) {
          const t3 = this._choices.get(e3);
          return !(!t3 || !t3.deprecated) && { value: e3 };
        }
        forward(e3) {
          const t3 = this._choices.get(e3);
          return t3 ? t3.forward : void 0;
        }
        redirect(e3) {
          const t3 = this._choices.get(e3);
          return t3 ? t3.redirect : void 0;
        }
      }
      var Ea2 = Da2, Ca2 = Object.defineProperty({ ChoiceSchema: Ea2 }, "__esModule", { value: true });
      class ba2 extends qs2.Schema {
        expected() {
          return "a number";
        }
        validate(e3, t3) {
          return typeof e3 == "number";
        }
      }
      var Aa2 = ba2, va2 = Object.defineProperty({ NumberSchema: Aa2 }, "__esModule", { value: true });
      class Fa2 extends va2.NumberSchema {
        expected() {
          return "an integer";
        }
        validate(e3, t3) {
          return t3.normalizeValidateResult(super.validate(e3, t3), e3) === true && ya2.isInt(e3);
        }
      }
      var xa2 = Fa2, Sa2 = Object.defineProperty({ IntegerSchema: xa2 }, "__esModule", { value: true });
      class wa2 extends qs2.Schema {
        expected() {
          return "a string";
        }
        validate(e3) {
          return typeof e3 == "string";
        }
      }
      var Ta2 = wa2, Ba2 = Object.defineProperty({ StringSchema: Ta2 }, "__esModule", { value: true }), Na2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Lo2.__exportStar(Gs2, t3), Lo2.__exportStar(Xs2, t3), Lo2.__exportStar(Zs2, t3), Lo2.__exportStar(na2, t3), Lo2.__exportStar(Ca2, t3), Lo2.__exportStar(Sa2, t3), Lo2.__exportStar(va2, t3), Lo2.__exportStar(Ba2, t3);
      }), ka2 = jo2.apiDescriptor, Pa2 = Is2.levenUnknownHandler, Oa2 = ks2.commonInvalidHandler, Ia2 = Ts2.commonDeprecatedHandler, La2 = Object.defineProperty({ defaultDescriptor: ka2, defaultUnknownHandler: Pa2, defaultInvalidHandler: Oa2, defaultDeprecatedHandler: Ia2 }, "__esModule", { value: true });
      class ja2 {
        constructor(e3, t3) {
          const { logger: n3 = console, descriptor: r3 = La2.defaultDescriptor, unknown: i3 = La2.defaultUnknownHandler, invalid: u3 = La2.defaultInvalidHandler, deprecated: o3 = La2.defaultDeprecatedHandler } = t3 || {};
          this._utils = { descriptor: r3, logger: n3 || { warn: () => {
          } }, schemas: ya2.recordFromArray(e3, "name"), normalizeDefaultResult: ya2.normalizeDefaultResult, normalizeDeprecatedResult: ya2.normalizeDeprecatedResult, normalizeForwardResult: ya2.normalizeForwardResult, normalizeRedirectResult: ya2.normalizeRedirectResult, normalizeValidateResult: ya2.normalizeValidateResult }, this._unknownHandler = i3, this._invalidHandler = u3, this._deprecatedHandler = o3, this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = ya2.createAutoChecklist();
        }
        normalize(e3) {
          const t3 = {}, n3 = [e3], r3 = () => {
            for (; n3.length !== 0; ) {
              const e4 = n3.shift(), r4 = this._applyNormalization(e4, t3);
              n3.push(...r4);
            }
          };
          r3();
          for (const e4 of Object.keys(this._utils.schemas)) {
            const r4 = this._utils.schemas[e4];
            if (!(e4 in t3)) {
              const t4 = ya2.normalizeDefaultResult(r4.default(this._utils));
              "value" in t4 && n3.push({ [e4]: t4.value });
            }
          }
          r3();
          for (const e4 of Object.keys(this._utils.schemas)) {
            const n4 = this._utils.schemas[e4];
            e4 in t3 && (t3[e4] = n4.postprocess(t3[e4], this._utils));
          }
          return t3;
        }
        _applyNormalization(e3, t3) {
          const n3 = [], [r3, i3] = ya2.partition(Object.keys(e3), (e4) => e4 in this._utils.schemas);
          for (const i4 of r3) {
            const r4 = this._utils.schemas[i4], u3 = r4.preprocess(e3[i4], this._utils), o3 = ya2.normalizeValidateResult(r4.validate(u3, this._utils), u3);
            if (o3 !== true) {
              const { value: e4 } = o3, t4 = this._invalidHandler(i4, e4, this._utils);
              throw typeof t4 == "string" ? new Error(t4) : t4;
            }
            const s3 = ({ from: e4, to: t4 }) => {
              n3.push(typeof t4 == "string" ? { [t4]: e4 } : { [t4.key]: t4.value });
            }, a3 = ({ value: e4, redirectTo: t4 }) => {
              const n4 = ya2.normalizeDeprecatedResult(r4.deprecated(e4, this._utils), u3, true);
              if (n4 !== false)
                if (n4 === true)
                  this._hasDeprecationWarned(i4) || this._utils.logger.warn(this._deprecatedHandler(i4, t4, this._utils));
                else
                  for (const { value: e5 } of n4) {
                    const n5 = { key: i4, value: e5 };
                    if (!this._hasDeprecationWarned(n5)) {
                      const r5 = typeof t4 == "string" ? { key: t4, value: e5 } : t4;
                      this._utils.logger.warn(this._deprecatedHandler(n5, r5, this._utils));
                    }
                  }
            };
            ya2.normalizeForwardResult(r4.forward(u3, this._utils), u3).forEach(s3);
            const c3 = ya2.normalizeRedirectResult(r4.redirect(u3, this._utils), u3);
            if (c3.redirect.forEach(s3), "remain" in c3) {
              const e4 = c3.remain;
              t3[i4] = i4 in t3 ? r4.overlap(t3[i4], e4, this._utils) : e4, a3({ value: e4 });
            }
            for (const { from: e4, to: t4 } of c3.redirect)
              a3({ value: e4, redirectTo: t4 });
          }
          for (const r4 of i3) {
            const i4 = e3[r4], u3 = this._unknownHandler(r4, i4, this._utils);
            if (u3)
              for (const e4 of Object.keys(u3)) {
                const r5 = { [e4]: u3[e4] };
                e4 in this._utils.schemas ? n3.push(r5) : Object.assign(t3, r5);
              }
          }
          return n3;
        }
      }
      var _a2 = ja2, Ma2 = Object.defineProperty({ normalize: (e3, t3, n3) => new ja2(t3, n3).normalize(e3), Normalizer: _a2 }, "__esModule", { value: true }), Ra2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Lo2.__exportStar(_o2, t3), Lo2.__exportStar(js2, t3), Lo2.__exportStar(Na2, t3), Lo2.__exportStar(Ma2, t3), Lo2.__exportStar(qs2, t3);
      });
      const $a2 = [], Va2 = [], Wa2 = (e3, t3) => {
        if (e3 === t3)
          return 0;
        const n3 = e3;
        e3.length > t3.length && (e3 = t3, t3 = n3);
        let r3 = e3.length, i3 = t3.length;
        for (; r3 > 0 && e3.charCodeAt(~-r3) === t3.charCodeAt(~-i3); )
          r3--, i3--;
        let u3, o3, s3, a3, c3 = 0;
        for (; c3 < r3 && e3.charCodeAt(c3) === t3.charCodeAt(c3); )
          c3++;
        if (r3 -= c3, i3 -= c3, r3 === 0)
          return i3;
        let l3 = 0, p3 = 0;
        for (; l3 < r3; )
          Va2[l3] = e3.charCodeAt(c3 + l3), $a2[l3] = ++l3;
        for (; p3 < i3; )
          for (u3 = t3.charCodeAt(c3 + p3), s3 = p3++, o3 = p3, l3 = 0; l3 < r3; l3++)
            a3 = u3 === Va2[l3] ? s3 : s3 + 1, s3 = $a2[l3], o3 = $a2[l3] = s3 > o3 ? a3 > o3 ? o3 + 1 : a3 : a3 > s3 ? s3 + 1 : a3;
        return o3;
      };
      var qa2 = Wa2, Ua2 = Wa2;
      qa2.default = Ua2;
      var za2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      const Ga2 = {};
      for (const e3 of Object.keys(za2))
        Ga2[za2[e3]] = e3;
      const Ha2 = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      var Ja2 = Ha2;
      for (const e3 of Object.keys(Ha2)) {
        if (!("channels" in Ha2[e3]))
          throw new Error("missing channels property: " + e3);
        if (!("labels" in Ha2[e3]))
          throw new Error("missing channel labels property: " + e3);
        if (Ha2[e3].labels.length !== Ha2[e3].channels)
          throw new Error("channel and label counts mismatch: " + e3);
        const { channels: t3, labels: n3 } = Ha2[e3];
        delete Ha2[e3].channels, delete Ha2[e3].labels, Object.defineProperty(Ha2[e3], "channels", { value: t3 }), Object.defineProperty(Ha2[e3], "labels", { value: n3 });
      }
      function Xa2(e3) {
        const t3 = function() {
          const e4 = {}, t4 = Object.keys(Ja2);
          for (let n4 = t4.length, r3 = 0; r3 < n4; r3++)
            e4[t4[r3]] = { distance: -1, parent: null };
          return e4;
        }(), n3 = [e3];
        for (t3[e3].distance = 0; n3.length; ) {
          const e4 = n3.pop(), r3 = Object.keys(Ja2[e4]);
          for (let i3 = r3.length, u3 = 0; u3 < i3; u3++) {
            const i4 = r3[u3], o3 = t3[i4];
            o3.distance === -1 && (o3.distance = t3[e4].distance + 1, o3.parent = e4, n3.unshift(i4));
          }
        }
        return t3;
      }
      function Ya2(e3, t3) {
        return function(n3) {
          return t3(e3(n3));
        };
      }
      function Ka2(e3, t3) {
        const n3 = [t3[e3].parent, e3];
        let r3 = Ja2[t3[e3].parent][e3], i3 = t3[e3].parent;
        for (; t3[i3].parent; )
          n3.unshift(t3[i3].parent), r3 = Ya2(Ja2[t3[i3].parent][i3], r3), i3 = t3[i3].parent;
        return r3.conversion = n3, r3;
      }
      Ha2.rgb.hsl = function(e3) {
        const t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255, i3 = Math.min(t3, n3, r3), u3 = Math.max(t3, n3, r3), o3 = u3 - i3;
        let s3, a3;
        u3 === i3 ? s3 = 0 : t3 === u3 ? s3 = (n3 - r3) / o3 : n3 === u3 ? s3 = 2 + (r3 - t3) / o3 : r3 === u3 && (s3 = 4 + (t3 - n3) / o3), s3 = Math.min(60 * s3, 360), s3 < 0 && (s3 += 360);
        const c3 = (i3 + u3) / 2;
        return a3 = u3 === i3 ? 0 : c3 <= 0.5 ? o3 / (u3 + i3) : o3 / (2 - u3 - i3), [s3, 100 * a3, 100 * c3];
      }, Ha2.rgb.hsv = function(e3) {
        let t3, n3, r3, i3, u3;
        const o3 = e3[0] / 255, s3 = e3[1] / 255, a3 = e3[2] / 255, c3 = Math.max(o3, s3, a3), l3 = c3 - Math.min(o3, s3, a3), p3 = function(e4) {
          return (c3 - e4) / 6 / l3 + 0.5;
        };
        return l3 === 0 ? (i3 = 0, u3 = 0) : (u3 = l3 / c3, t3 = p3(o3), n3 = p3(s3), r3 = p3(a3), o3 === c3 ? i3 = r3 - n3 : s3 === c3 ? i3 = 1 / 3 + t3 - r3 : a3 === c3 && (i3 = 2 / 3 + n3 - t3), i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1)), [360 * i3, 100 * u3, 100 * c3];
      }, Ha2.rgb.hwb = function(e3) {
        const t3 = e3[0], n3 = e3[1];
        let r3 = e3[2];
        const i3 = Ha2.rgb.hsl(e3)[0], u3 = 1 / 255 * Math.min(t3, Math.min(n3, r3));
        return r3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, r3)), [i3, 100 * u3, 100 * r3];
      }, Ha2.rgb.cmyk = function(e3) {
        const t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255, i3 = Math.min(1 - t3, 1 - n3, 1 - r3);
        return [100 * ((1 - t3 - i3) / (1 - i3) || 0), 100 * ((1 - n3 - i3) / (1 - i3) || 0), 100 * ((1 - r3 - i3) / (1 - i3) || 0), 100 * i3];
      }, Ha2.rgb.keyword = function(e3) {
        const t3 = Ga2[e3];
        if (t3)
          return t3;
        let n3, r3 = 1 / 0;
        for (const t4 of Object.keys(za2)) {
          const o3 = (u3 = za2[t4], __pow((i3 = e3)[0] - u3[0], 2) + __pow(i3[1] - u3[1], 2) + __pow(i3[2] - u3[2], 2));
          o3 < r3 && (r3 = o3, n3 = t4);
        }
        var i3, u3;
        return n3;
      }, Ha2.keyword.rgb = function(e3) {
        return za2[e3];
      }, Ha2.rgb.xyz = function(e3) {
        let t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255;
        t3 = t3 > 0.04045 ? __pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92, n3 = n3 > 0.04045 ? __pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92, r3 = r3 > 0.04045 ? __pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92;
        return [100 * (0.4124 * t3 + 0.3576 * n3 + 0.1805 * r3), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
      }, Ha2.rgb.lab = function(e3) {
        const t3 = Ha2.rgb.xyz(e3);
        let n3 = t3[0], r3 = t3[1], i3 = t3[2];
        n3 /= 95.047, r3 /= 100, i3 /= 108.883, n3 = n3 > 8856e-6 ? __pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, r3 = r3 > 8856e-6 ? __pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116, i3 = i3 > 8856e-6 ? __pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116;
        return [116 * r3 - 16, 500 * (n3 - r3), 200 * (r3 - i3)];
      }, Ha2.hsl.rgb = function(e3) {
        const t3 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
        let i3, u3, o3;
        if (n3 === 0)
          return o3 = 255 * r3, [o3, o3, o3];
        i3 = r3 < 0.5 ? r3 * (1 + n3) : r3 + n3 - r3 * n3;
        const s3 = 2 * r3 - i3, a3 = [0, 0, 0];
        for (let e4 = 0; e4 < 3; e4++)
          u3 = t3 + 1 / 3 * -(e4 - 1), u3 < 0 && u3++, u3 > 1 && u3--, o3 = 6 * u3 < 1 ? s3 + 6 * (i3 - s3) * u3 : 2 * u3 < 1 ? i3 : 3 * u3 < 2 ? s3 + (i3 - s3) * (2 / 3 - u3) * 6 : s3, a3[e4] = 255 * o3;
        return a3;
      }, Ha2.hsl.hsv = function(e3) {
        const t3 = e3[0];
        let n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = n3;
        const u3 = Math.max(r3, 0.01);
        r3 *= 2, n3 *= r3 <= 1 ? r3 : 2 - r3, i3 *= u3 <= 1 ? u3 : 2 - u3;
        return [t3, 100 * (r3 === 0 ? 2 * i3 / (u3 + i3) : 2 * n3 / (r3 + n3)), 100 * ((r3 + n3) / 2)];
      }, Ha2.hsv.rgb = function(e3) {
        const t3 = e3[0] / 60, n3 = e3[1] / 100;
        let r3 = e3[2] / 100;
        const i3 = Math.floor(t3) % 6, u3 = t3 - Math.floor(t3), o3 = 255 * r3 * (1 - n3), s3 = 255 * r3 * (1 - n3 * u3), a3 = 255 * r3 * (1 - n3 * (1 - u3));
        switch (r3 *= 255, i3) {
          case 0:
            return [r3, a3, o3];
          case 1:
            return [s3, r3, o3];
          case 2:
            return [o3, r3, a3];
          case 3:
            return [o3, s3, r3];
          case 4:
            return [a3, o3, r3];
          case 5:
            return [r3, o3, s3];
        }
      }, Ha2.hsv.hsl = function(e3) {
        const t3 = e3[0], n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = Math.max(r3, 0.01);
        let u3, o3;
        o3 = (2 - n3) * r3;
        const s3 = (2 - n3) * i3;
        return u3 = n3 * i3, u3 /= s3 <= 1 ? s3 : 2 - s3, u3 = u3 || 0, o3 /= 2, [t3, 100 * u3, 100 * o3];
      }, Ha2.hwb.rgb = function(e3) {
        const t3 = e3[0] / 360;
        let n3 = e3[1] / 100, r3 = e3[2] / 100;
        const i3 = n3 + r3;
        let u3;
        i3 > 1 && (n3 /= i3, r3 /= i3);
        const o3 = Math.floor(6 * t3), s3 = 1 - r3;
        u3 = 6 * t3 - o3, (1 & o3) != 0 && (u3 = 1 - u3);
        const a3 = n3 + u3 * (s3 - n3);
        let c3, l3, p3;
        switch (o3) {
          default:
          case 6:
          case 0:
            c3 = s3, l3 = a3, p3 = n3;
            break;
          case 1:
            c3 = a3, l3 = s3, p3 = n3;
            break;
          case 2:
            c3 = n3, l3 = s3, p3 = a3;
            break;
          case 3:
            c3 = n3, l3 = a3, p3 = s3;
            break;
          case 4:
            c3 = a3, l3 = n3, p3 = s3;
            break;
          case 5:
            c3 = s3, l3 = n3, p3 = a3;
        }
        return [255 * c3, 255 * l3, 255 * p3];
      }, Ha2.cmyk.rgb = function(e3) {
        const t3 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = e3[3] / 100;
        return [255 * (1 - Math.min(1, t3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, n3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, r3 * (1 - i3) + i3))];
      }, Ha2.xyz.rgb = function(e3) {
        const t3 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100;
        let i3, u3, o3;
        return i3 = 3.2406 * t3 + -1.5372 * n3 + -0.4986 * r3, u3 = -0.9689 * t3 + 1.8758 * n3 + 0.0415 * r3, o3 = 0.0557 * t3 + -0.204 * n3 + 1.057 * r3, i3 = i3 > 31308e-7 ? 1.055 * __pow(i3, 1 / 2.4) - 0.055 : 12.92 * i3, u3 = u3 > 31308e-7 ? 1.055 * __pow(u3, 1 / 2.4) - 0.055 : 12.92 * u3, o3 = o3 > 31308e-7 ? 1.055 * __pow(o3, 1 / 2.4) - 0.055 : 12.92 * o3, i3 = Math.min(Math.max(0, i3), 1), u3 = Math.min(Math.max(0, u3), 1), o3 = Math.min(Math.max(0, o3), 1), [255 * i3, 255 * u3, 255 * o3];
      }, Ha2.xyz.lab = function(e3) {
        let t3 = e3[0], n3 = e3[1], r3 = e3[2];
        t3 /= 95.047, n3 /= 100, r3 /= 108.883, t3 = t3 > 8856e-6 ? __pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, n3 = n3 > 8856e-6 ? __pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, r3 = r3 > 8856e-6 ? __pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116;
        return [116 * n3 - 16, 500 * (t3 - n3), 200 * (n3 - r3)];
      }, Ha2.lab.xyz = function(e3) {
        let t3, n3, r3;
        n3 = (e3[0] + 16) / 116, t3 = e3[1] / 500 + n3, r3 = n3 - e3[2] / 200;
        const i3 = __pow(n3, 3), u3 = __pow(t3, 3), o3 = __pow(r3, 3);
        return n3 = i3 > 8856e-6 ? i3 : (n3 - 16 / 116) / 7.787, t3 = u3 > 8856e-6 ? u3 : (t3 - 16 / 116) / 7.787, r3 = o3 > 8856e-6 ? o3 : (r3 - 16 / 116) / 7.787, t3 *= 95.047, n3 *= 100, r3 *= 108.883, [t3, n3, r3];
      }, Ha2.lab.lch = function(e3) {
        const t3 = e3[0], n3 = e3[1], r3 = e3[2];
        let i3;
        i3 = 360 * Math.atan2(r3, n3) / 2 / Math.PI, i3 < 0 && (i3 += 360);
        return [t3, Math.sqrt(n3 * n3 + r3 * r3), i3];
      }, Ha2.lch.lab = function(e3) {
        const t3 = e3[0], n3 = e3[1], r3 = e3[2] / 360 * 2 * Math.PI;
        return [t3, n3 * Math.cos(r3), n3 * Math.sin(r3)];
      }, Ha2.rgb.ansi16 = function(e3, t3 = null) {
        const [n3, r3, i3] = e3;
        let u3 = t3 === null ? Ha2.rgb.hsv(e3)[2] : t3;
        if (u3 = Math.round(u3 / 50), u3 === 0)
          return 30;
        let o3 = 30 + (Math.round(i3 / 255) << 2 | Math.round(r3 / 255) << 1 | Math.round(n3 / 255));
        return u3 === 2 && (o3 += 60), o3;
      }, Ha2.hsv.ansi16 = function(e3) {
        return Ha2.rgb.ansi16(Ha2.hsv.rgb(e3), e3[2]);
      }, Ha2.rgb.ansi256 = function(e3) {
        const t3 = e3[0], n3 = e3[1], r3 = e3[2];
        if (t3 === n3 && n3 === r3)
          return t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
      }, Ha2.ansi16.rgb = function(e3) {
        let t3 = e3 % 10;
        if (t3 === 0 || t3 === 7)
          return e3 > 50 && (t3 += 3.5), t3 = t3 / 10.5 * 255, [t3, t3, t3];
        const n3 = 0.5 * (1 + ~~(e3 > 50));
        return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
      }, Ha2.ansi256.rgb = function(e3) {
        if (e3 >= 232) {
          const t4 = 10 * (e3 - 232) + 8;
          return [t4, t4, t4];
        }
        let t3;
        e3 -= 16;
        return [Math.floor(e3 / 36) / 5 * 255, Math.floor((t3 = e3 % 36) / 6) / 5 * 255, t3 % 6 / 5 * 255];
      }, Ha2.rgb.hex = function(e3) {
        const t3 = (((255 & Math.round(e3[0])) << 16) + ((255 & Math.round(e3[1])) << 8) + (255 & Math.round(e3[2]))).toString(16).toUpperCase();
        return "000000".substring(t3.length) + t3;
      }, Ha2.hex.rgb = function(e3) {
        const t3 = e3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t3)
          return [0, 0, 0];
        let n3 = t3[0];
        t3[0].length === 3 && (n3 = n3.split("").map((e4) => e4 + e4).join(""));
        const r3 = parseInt(n3, 16);
        return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
      }, Ha2.rgb.hcg = function(e3) {
        const t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255, i3 = Math.max(Math.max(t3, n3), r3), u3 = Math.min(Math.min(t3, n3), r3), o3 = i3 - u3;
        let s3, a3;
        return s3 = o3 < 1 ? u3 / (1 - o3) : 0, a3 = o3 <= 0 ? 0 : i3 === t3 ? (n3 - r3) / o3 % 6 : i3 === n3 ? 2 + (r3 - t3) / o3 : 4 + (t3 - n3) / o3, a3 /= 6, a3 %= 1, [360 * a3, 100 * o3, 100 * s3];
      }, Ha2.hsl.hcg = function(e3) {
        const t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3);
        let i3 = 0;
        return r3 < 1 && (i3 = (n3 - 0.5 * r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
      }, Ha2.hsv.hcg = function(e3) {
        const t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = t3 * n3;
        let i3 = 0;
        return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
      }, Ha2.hcg.rgb = function(e3) {
        const t3 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
        if (n3 === 0)
          return [255 * r3, 255 * r3, 255 * r3];
        const i3 = [0, 0, 0], u3 = t3 % 1 * 6, o3 = u3 % 1, s3 = 1 - o3;
        let a3 = 0;
        switch (Math.floor(u3)) {
          case 0:
            i3[0] = 1, i3[1] = o3, i3[2] = 0;
            break;
          case 1:
            i3[0] = s3, i3[1] = 1, i3[2] = 0;
            break;
          case 2:
            i3[0] = 0, i3[1] = 1, i3[2] = o3;
            break;
          case 3:
            i3[0] = 0, i3[1] = s3, i3[2] = 1;
            break;
          case 4:
            i3[0] = o3, i3[1] = 0, i3[2] = 1;
            break;
          default:
            i3[0] = 1, i3[1] = 0, i3[2] = s3;
        }
        return a3 = (1 - n3) * r3, [255 * (n3 * i3[0] + a3), 255 * (n3 * i3[1] + a3), 255 * (n3 * i3[2] + a3)];
      }, Ha2.hcg.hsv = function(e3) {
        const t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3);
        let r3 = 0;
        return n3 > 0 && (r3 = t3 / n3), [e3[0], 100 * r3, 100 * n3];
      }, Ha2.hcg.hsl = function(e3) {
        const t3 = e3[1] / 100, n3 = e3[2] / 100 * (1 - t3) + 0.5 * t3;
        let r3 = 0;
        return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e3[0], 100 * r3, 100 * n3];
      }, Ha2.hcg.hwb = function(e3) {
        const t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3);
        return [e3[0], 100 * (n3 - t3), 100 * (1 - n3)];
      }, Ha2.hwb.hcg = function(e3) {
        const t3 = e3[1] / 100, n3 = 1 - e3[2] / 100, r3 = n3 - t3;
        let i3 = 0;
        return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
      }, Ha2.apple.rgb = function(e3) {
        return [e3[0] / 65535 * 255, e3[1] / 65535 * 255, e3[2] / 65535 * 255];
      }, Ha2.rgb.apple = function(e3) {
        return [e3[0] / 255 * 65535, e3[1] / 255 * 65535, e3[2] / 255 * 65535];
      }, Ha2.gray.rgb = function(e3) {
        return [e3[0] / 100 * 255, e3[0] / 100 * 255, e3[0] / 100 * 255];
      }, Ha2.gray.hsl = function(e3) {
        return [0, 0, e3[0]];
      }, Ha2.gray.hsv = Ha2.gray.hsl, Ha2.gray.hwb = function(e3) {
        return [0, 100, e3[0]];
      }, Ha2.gray.cmyk = function(e3) {
        return [0, 0, 0, e3[0]];
      }, Ha2.gray.lab = function(e3) {
        return [e3[0], 0, 0];
      }, Ha2.gray.hex = function(e3) {
        const t3 = 255 & Math.round(e3[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
        return "000000".substring(n3.length) + n3;
      }, Ha2.rgb.gray = function(e3) {
        return [(e3[0] + e3[1] + e3[2]) / 3 / 255 * 100];
      };
      const Qa2 = {};
      Object.keys(Ja2).forEach((e3) => {
        Qa2[e3] = {}, Object.defineProperty(Qa2[e3], "channels", { value: Ja2[e3].channels }), Object.defineProperty(Qa2[e3], "labels", { value: Ja2[e3].labels });
        const t3 = function(e4) {
          const t4 = Xa2(e4), n3 = {}, r3 = Object.keys(t4);
          for (let e5 = r3.length, i3 = 0; i3 < e5; i3++) {
            const e6 = r3[i3];
            t4[e6].parent !== null && (n3[e6] = Ka2(e6, t4));
          }
          return n3;
        }(e3);
        Object.keys(t3).forEach((n3) => {
          const r3 = t3[n3];
          Qa2[e3][n3] = function(e4) {
            const t4 = function(...t5) {
              const n4 = t5[0];
              if (n4 == null)
                return n4;
              n4.length > 1 && (t5 = n4);
              const r4 = e4(t5);
              if (typeof r4 == "object")
                for (let e5 = r4.length, t6 = 0; t6 < e5; t6++)
                  r4[t6] = Math.round(r4[t6]);
              return r4;
            };
            return "conversion" in e4 && (t4.conversion = e4.conversion), t4;
          }(r3), Qa2[e3][n3].raw = function(e4) {
            const t4 = function(...t5) {
              const n4 = t5[0];
              return n4 == null ? n4 : (n4.length > 1 && (t5 = n4), e4(t5));
            };
            return "conversion" in e4 && (t4.conversion = e4.conversion), t4;
          }(r3);
        });
      });
      var Za2 = Qa2, ec2 = r2(function(e3) {
        const t3 = (e4, t4) => (...n4) => `[${e4(...n4) + t4}m`, n3 = (e4, t4) => (...n4) => {
          const r4 = e4(...n4);
          return `[${38 + t4};5;${r4}m`;
        }, r3 = (e4, t4) => (...n4) => {
          const r4 = e4(...n4);
          return `[${38 + t4};2;${r4[0]};${r4[1]};${r4[2]}m`;
        }, i3 = (e4) => e4, u3 = (e4, t4, n4) => [e4, t4, n4], o3 = (e4, t4, n4) => {
          Object.defineProperty(e4, t4, { get: () => {
            const r4 = n4();
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true }), r4;
          }, enumerable: true, configurable: true });
        };
        let s3;
        const a3 = (e4, t4, n4, r4) => {
          s3 === void 0 && (s3 = Za2);
          const i4 = r4 ? 10 : 0, u4 = {};
          for (const [r5, o4] of Object.entries(s3)) {
            const s4 = r5 === "ansi16" ? "ansi" : r5;
            r5 === t4 ? u4[s4] = e4(n4, i4) : typeof o4 == "object" && (u4[s4] = e4(o4[t4], i4));
          }
          return u4;
        };
        Object.defineProperty(e3, "exports", { enumerable: true, get: function() {
          const e4 = new Map(), s4 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
          s4.color.gray = s4.color.blackBright, s4.bgColor.bgGray = s4.bgColor.bgBlackBright, s4.color.grey = s4.color.blackBright, s4.bgColor.bgGrey = s4.bgColor.bgBlackBright;
          for (const [t4, n4] of Object.entries(s4)) {
            for (const [t5, r4] of Object.entries(n4))
              s4[t5] = { open: `[${r4[0]}m`, close: `[${r4[1]}m` }, n4[t5] = s4[t5], e4.set(r4[0], r4[1]);
            Object.defineProperty(s4, t4, { value: n4, enumerable: false });
          }
          return Object.defineProperty(s4, "codes", { value: e4, enumerable: false }), s4.color.close = "[39m", s4.bgColor.close = "[49m", o3(s4.color, "ansi", () => a3(t3, "ansi16", i3, false)), o3(s4.color, "ansi256", () => a3(n3, "ansi256", i3, false)), o3(s4.color, "ansi16m", () => a3(r3, "rgb", u3, false)), o3(s4.bgColor, "ansi", () => a3(t3, "ansi16", i3, true)), o3(s4.bgColor, "ansi256", () => a3(n3, "ansi256", i3, true)), o3(s4.bgColor, "ansi16m", () => a3(r3, "rgb", u3, true)), s4;
        } });
      });
      function tc2() {
        return false;
      }
      function nc2() {
        throw new Error("tty.ReadStream is not implemented");
      }
      function rc2() {
        throw new Error("tty.ReadStream is not implemented");
      }
      var ic2 = { isatty: tc2, ReadStream: nc2, WriteStream: rc2 }, uc2 = (e3, t3 = Tr2.argv) => {
        const n3 = e3.startsWith("-") ? "" : e3.length === 1 ? "-" : "--", r3 = t3.indexOf(n3 + e3), i3 = t3.indexOf("--");
        return r3 !== -1 && (i3 === -1 || r3 < i3);
      }, oc2 = n2(Object.freeze({ __proto__: null, isatty: tc2, ReadStream: nc2, WriteStream: rc2, default: ic2 }));
      const { env: sc2 } = Tr2;
      let ac2;
      function cc2(e3) {
        return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
      }
      function lc2(e3, t3) {
        if (ac2 === 0)
          return 0;
        if (uc2("color=16m") || uc2("color=full") || uc2("color=truecolor"))
          return 3;
        if (uc2("color=256"))
          return 2;
        if (e3 && !t3 && ac2 === void 0)
          return 0;
        const n3 = ac2 || 0;
        if (sc2.TERM === "dumb")
          return n3;
        if ("CI" in sc2)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e4) => e4 in sc2) || sc2.CI_NAME === "codeship" ? 1 : n3;
        if ("TEAMCITY_VERSION" in sc2)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(sc2.TEAMCITY_VERSION) ? 1 : 0;
        if (sc2.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in sc2) {
          const e4 = parseInt((sc2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (sc2.TERM_PROGRAM) {
            case "iTerm.app":
              return e4 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(sc2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(sc2.TERM) || "COLORTERM" in sc2 ? 1 : n3;
      }
      uc2("no-color") || uc2("no-colors") || uc2("color=false") || uc2("color=never") ? ac2 = 0 : (uc2("color") || uc2("colors") || uc2("color=true") || uc2("color=always")) && (ac2 = 1), "FORCE_COLOR" in sc2 && (ac2 = sc2.FORCE_COLOR === "true" ? 1 : sc2.FORCE_COLOR === "false" ? 0 : sc2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(sc2.FORCE_COLOR, 10), 3));
      var pc2 = { supportsColor: function(e3) {
        return cc2(lc2(e3, e3 && e3.isTTY));
      }, stdout: cc2(lc2(true, oc2.isatty(1))), stderr: cc2(lc2(true, oc2.isatty(2))) };
      var fc2 = { stringReplaceAll: (e3, t3, n3) => {
        let r3 = e3.indexOf(t3);
        if (r3 === -1)
          return e3;
        const i3 = t3.length;
        let u3 = 0, o3 = "";
        do {
          o3 += e3.substr(u3, r3 - u3) + t3 + n3, u3 = r3 + i3, r3 = e3.indexOf(t3, u3);
        } while (r3 !== -1);
        return o3 += e3.substr(u3), o3;
      }, stringEncaseCRLFWithFirstIndex: (e3, t3, n3, r3) => {
        let i3 = 0, u3 = "";
        do {
          const o3 = e3[r3 - 1] === "\r";
          u3 += e3.substr(i3, (o3 ? r3 - 1 : r3) - i3) + t3 + (o3 ? "\r\n" : "\n") + n3, i3 = r3 + 1, r3 = e3.indexOf("\n", i3);
        } while (r3 !== -1);
        return u3 += e3.substr(i3), u3;
      } };
      const dc2 = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, hc2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, gc2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, mc2 = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, yc2 = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function Dc2(e3) {
        const t3 = e3[0] === "u", n3 = e3[1] === "{";
        return t3 && !n3 && e3.length === 5 || e3[0] === "x" && e3.length === 3 ? String.fromCharCode(parseInt(e3.slice(1), 16)) : t3 && n3 ? String.fromCodePoint(parseInt(e3.slice(2, -1), 16)) : yc2.get(e3) || e3;
      }
      function Ec2(e3, t3) {
        const n3 = [], r3 = t3.trim().split(/\s*,\s*/g);
        let i3;
        for (const t4 of r3) {
          const r4 = Number(t4);
          if (Number.isNaN(r4)) {
            if (!(i3 = t4.match(gc2)))
              throw new Error(`Invalid Chalk template style argument: ${t4} (in style '${e3}')`);
            n3.push(i3[2].replace(mc2, (e4, t5, n4) => t5 ? Dc2(t5) : n4));
          } else
            n3.push(r4);
        }
        return n3;
      }
      function Cc2(e3) {
        hc2.lastIndex = 0;
        const t3 = [];
        let n3;
        for (; (n3 = hc2.exec(e3)) !== null; ) {
          const e4 = n3[1];
          if (n3[2]) {
            const r3 = Ec2(e4, n3[2]);
            t3.push([e4].concat(r3));
          } else
            t3.push([e4]);
        }
        return t3;
      }
      function bc2(e3, t3) {
        const n3 = {};
        for (const e4 of t3)
          for (const t4 of e4.styles)
            n3[t4[0]] = e4.inverse ? null : t4.slice(1);
        let r3 = e3;
        for (const [e4, t4] of Object.entries(n3))
          if (Array.isArray(t4)) {
            if (!(e4 in r3))
              throw new Error(`Unknown Chalk style: ${e4}`);
            r3 = t4.length > 0 ? r3[e4](...t4) : r3[e4];
          }
        return r3;
      }
      var Ac2 = (e3, t3) => {
        const n3 = [], r3 = [];
        let i3 = [];
        if (t3.replace(dc2, (t4, u3, o3, s3, a3, c3) => {
          if (u3)
            i3.push(Dc2(u3));
          else if (s3) {
            const t5 = i3.join("");
            i3 = [], r3.push(n3.length === 0 ? t5 : bc2(e3, n3)(t5)), n3.push({ inverse: o3, styles: Cc2(s3) });
          } else if (a3) {
            if (n3.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r3.push(bc2(e3, n3)(i3.join(""))), i3 = [], n3.pop();
          } else
            i3.push(c3);
        }), r3.push(i3.join("")), n3.length > 0) {
          const e4 = `Chalk template literal is missing ${n3.length} closing bracket${n3.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(e4);
        }
        return r3.join("");
      };
      const { stdout: vc2, stderr: Fc2 } = pc2, { stringReplaceAll: xc2, stringEncaseCRLFWithFirstIndex: Sc2 } = fc2, { isArray: wc2 } = Array, Tc2 = ["ansi", "ansi", "ansi256", "ansi16m"], Bc2 = Object.create(null);
      class Nc2 {
        constructor(e3) {
          return kc2(e3);
        }
      }
      const kc2 = (e3) => {
        const t3 = {};
        return ((e4, t4 = {}) => {
          if (t4.level && !(Number.isInteger(t4.level) && t4.level >= 0 && t4.level <= 3))
            throw new Error("The `level` option should be an integer from 0 to 3");
          const n3 = vc2 ? vc2.level : 0;
          e4.level = t4.level === void 0 ? n3 : t4.level;
        })(t3, e3), t3.template = (...e4) => Rc2(t3.template, ...e4), Object.setPrototypeOf(t3, Pc2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        }, t3.template.Instance = Nc2, t3.template;
      };
      function Pc2(e3) {
        return kc2(e3);
      }
      for (const [e3, t3] of Object.entries(ec2))
        Bc2[e3] = { get() {
          const n3 = jc2(this, Lc2(t3.open, t3.close, this._styler), this._isEmpty);
          return Object.defineProperty(this, e3, { value: n3 }), n3;
        } };
      Bc2.visible = { get() {
        const e3 = jc2(this, this._styler, true);
        return Object.defineProperty(this, "visible", { value: e3 }), e3;
      } };
      const Oc2 = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const e3 of Oc2)
        Bc2[e3] = { get() {
          const { level: t3 } = this;
          return function(...n3) {
            const r3 = Lc2(ec2.color[Tc2[t3]][e3](...n3), ec2.color.close, this._styler);
            return jc2(this, r3, this._isEmpty);
          };
        } };
      for (const e3 of Oc2) {
        Bc2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
          const { level: t3 } = this;
          return function(...n3) {
            const r3 = Lc2(ec2.bgColor[Tc2[t3]][e3](...n3), ec2.bgColor.close, this._styler);
            return jc2(this, r3, this._isEmpty);
          };
        } };
      }
      const Ic2 = Object.defineProperties(() => {
      }, Object.assign(Object.assign({}, Bc2), {}, { level: { enumerable: true, get() {
        return this._generator.level;
      }, set(e3) {
        this._generator.level = e3;
      } } })), Lc2 = (e3, t3, n3) => {
        let r3, i3;
        return n3 === void 0 ? (r3 = e3, i3 = t3) : (r3 = n3.openAll + e3, i3 = t3 + n3.closeAll), { open: e3, close: t3, openAll: r3, closeAll: i3, parent: n3 };
      }, jc2 = (e3, t3, n3) => {
        const r3 = (...e4) => wc2(e4[0]) && wc2(e4[0].raw) ? _c2(r3, Rc2(r3, ...e4)) : _c2(r3, e4.length === 1 ? "" + e4[0] : e4.join(" "));
        return Object.setPrototypeOf(r3, Ic2), r3._generator = e3, r3._styler = t3, r3._isEmpty = n3, r3;
      }, _c2 = (e3, t3) => {
        if (e3.level <= 0 || !t3)
          return e3._isEmpty ? "" : t3;
        let n3 = e3._styler;
        if (n3 === void 0)
          return t3;
        const { openAll: r3, closeAll: i3 } = n3;
        if (t3.indexOf("") !== -1)
          for (; n3 !== void 0; )
            t3 = xc2(t3, n3.close, n3.open), n3 = n3.parent;
        const u3 = t3.indexOf("\n");
        return u3 !== -1 && (t3 = Sc2(t3, i3, r3, u3)), r3 + t3 + i3;
      };
      let Mc2;
      const Rc2 = (e3, ...t3) => {
        const [n3] = t3;
        if (!wc2(n3) || !wc2(n3.raw))
          return t3.join(" ");
        const r3 = t3.slice(1), i3 = [n3.raw[0]];
        for (let e4 = 1; e4 < n3.length; e4++)
          i3.push(String(r3[e4 - 1]).replace(/[{}\\]/g, "\\$&"), String(n3.raw[e4]));
        return Mc2 === void 0 && (Mc2 = Ac2), Mc2(e3, i3.join(""));
      };
      Object.defineProperties(Pc2.prototype, Bc2);
      const $c2 = Pc2();
      $c2.supportsColor = vc2, $c2.stderr = Pc2({ level: Fc2 ? Fc2.level : 0 }), $c2.stderr.supportsColor = Fc2;
      var Vc2 = $c2;
      const Wc2 = ["_"], qc2 = { key: (e3) => e3.length === 1 ? `-${e3}` : `--${e3}`, value: (e3) => Ra2.apiDescriptor.value(e3), pair: ({ key: e3, value: t3 }) => t3 === false ? `--no-${e3}` : t3 === true ? qc2.key(e3) : t3 === "" ? `${qc2.key(e3)} without an argument` : `${qc2.key(e3)}=${t3}` };
      class Uc2 extends Ra2.ChoiceSchema {
        constructor({ name: e3, flags: t3 }) {
          super({ name: e3, choices: t3 }), this._flags = [...t3].sort();
        }
        preprocess(e3, t3) {
          if (typeof e3 == "string" && e3.length > 0 && !this._flags.includes(e3)) {
            const n3 = this._flags.find((t4) => qa2(t4, e3) < 3);
            if (n3)
              return t3.logger.warn([`Unknown flag ${Vc2.yellow(t3.descriptor.value(e3))},`, `did you mean ${Vc2.blue(t3.descriptor.value(n3))}?`].join(" ")), n3;
          }
          return e3;
        }
        expected() {
          return "a flag";
        }
      }
      let zc2;
      function Gc2(e3, t3, { logger: n3, isCLI: r3 = false, passThrough: i3 = false } = {}) {
        const u3 = i3 ? Array.isArray(i3) ? (e4, t4) => i3.includes(e4) ? { [e4]: t4 } : void 0 : (e4, t4) => ({ [e4]: t4 }) : (e4, t4, n4) => {
          const r4 = Mn2(n4.schemas, Wc2);
          return Ra2.levenUnknownHandler(e4, t4, Object.assign(Object.assign({}, n4), {}, { schemas: r4 }));
        }, o3 = r3 ? qc2 : Ra2.apiDescriptor, s3 = function(e4, { isCLI: t4 }) {
          const n4 = [];
          t4 && n4.push(Ra2.AnySchema.create({ name: "_" }));
          for (const r4 of e4)
            n4.push(Hc2(r4, { isCLI: t4, optionInfos: e4 })), r4.alias && t4 && n4.push(Ra2.AliasSchema.create({ name: r4.alias, sourceName: r4.name }));
          return n4;
        }(t3, { isCLI: r3 }), a3 = new Ra2.Normalizer(s3, { logger: n3, unknown: u3, descriptor: o3 }), c3 = n3 !== false;
        c3 && zc2 && (a3._hasDeprecationWarned = zc2);
        const l3 = a3.normalize(e3);
        return c3 && (zc2 = a3._hasDeprecationWarned), l3;
      }
      function Hc2(e3, { isCLI: t3, optionInfos: n3 }) {
        let r3;
        const i3 = { name: e3.name }, u3 = {};
        switch (e3.type) {
          case "int":
            r3 = Ra2.IntegerSchema, t3 && (i3.preprocess = (e4) => Number(e4));
            break;
          case "string":
            r3 = Ra2.StringSchema;
            break;
          case "choice":
            r3 = Ra2.ChoiceSchema, i3.choices = e3.choices.map((t4) => typeof t4 == "object" && t4.redirect ? Object.assign(Object.assign({}, t4), {}, { redirect: { to: { key: e3.name, value: t4.redirect } } }) : t4);
            break;
          case "boolean":
            r3 = Ra2.BooleanSchema;
            break;
          case "flag":
            r3 = Uc2, i3.flags = n3.flatMap((e4) => [e4.alias, e4.description && e4.name, e4.oppositeDescription && `no-${e4.name}`].filter(Boolean));
            break;
          case "path":
            r3 = Ra2.StringSchema;
            break;
          default:
            throw new Error(`Unexpected type ${e3.type}`);
        }
        if (e3.exception ? i3.validate = (t4, n4, r4) => e3.exception(t4) || n4.validate(t4, r4) : i3.validate = (e4, t4, n4) => e4 === void 0 || t4.validate(e4, n4), e3.redirect && (u3.redirect = (t4) => t4 ? { to: { key: e3.redirect.option, value: e3.redirect.value } } : void 0), e3.deprecated && (u3.deprecated = true), t3 && !e3.array) {
          const e4 = i3.preprocess || ((e5) => e5);
          i3.preprocess = (t4, n4, r4) => n4.preprocess(e4(Array.isArray(t4) ? _n2(t4) : t4), r4);
        }
        return e3.array ? Ra2.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, t3 ? { preprocess: (e4) => Array.isArray(e4) ? e4 : [e4] } : {}), u3), {}, { valueSchema: r3.create(i3) })) : r3.create(Object.assign(Object.assign({}, i3), u3));
      }
      var Jc2 = { normalizeApiOptions: function(e3, t3, n3) {
        return Gc2(e3, t3, n3);
      }, normalizeCliOptions: function(e3, t3, n3) {
        return Gc2(e3, t3, Object.assign({ isCLI: true }, n3));
      } };
      const { isNonEmptyArray: Xc2 } = Fi2;
      function Yc2(e3, t3) {
        const { ignoreDecorators: n3 } = t3 || {};
        if (!n3) {
          const t4 = e3.declaration && e3.declaration.decorators || e3.decorators;
          if (Xc2(t4))
            return Yc2(t4[0]);
        }
        return e3.range ? e3.range[0] : e3.start;
      }
      function Kc2(e3) {
        return e3.range ? e3.range[1] : e3.end;
      }
      function Qc2(e3, t3) {
        return Yc2(e3) === Yc2(t3);
      }
      var Zc2 = { locStart: Yc2, locEnd: Kc2, hasSameLocStart: Qc2, hasSameLoc: function(e3, t3) {
        return Qc2(e3, t3) && function(e4, t4) {
          return Kc2(e4) === Kc2(t4);
        }(e3, t3);
      } }, el2 = Object.defineProperty({ default: /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, matchToToken: function(e3) {
        var t3 = { type: "invalid", value: e3[0], closed: void 0 };
        return e3[1] ? (t3.type = "string", t3.closed = !(!e3[3] && !e3[4])) : e3[5] ? t3.type = "comment" : e3[6] ? (t3.type = "comment", t3.closed = !!e3[7]) : e3[8] ? t3.type = "regex" : e3[9] ? t3.type = "number" : e3[10] ? t3.type = "name" : e3[11] ? t3.type = "punctuator" : e3[12] && (t3.type = "whitespace"), t3;
      } }, "__esModule", { value: true }), tl2 = pl2, nl2 = fl2, rl2 = function(e3) {
        let t3 = true;
        for (let n3 = 0; n3 < e3.length; n3++) {
          let r3 = e3.charCodeAt(n3);
          if ((64512 & r3) == 55296 && n3 + 1 < e3.length) {
            const t4 = e3.charCodeAt(++n3);
            (64512 & t4) == 56320 && (r3 = 65536 + ((1023 & r3) << 10) + (1023 & t4));
          }
          if (t3) {
            if (t3 = false, !pl2(r3))
              return false;
          } else if (!fl2(r3))
            return false;
        }
        return !t3;
      };
      let il2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", ul2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      const ol2 = new RegExp("[" + il2 + "]"), sl2 = new RegExp("[" + il2 + ul2 + "]");
      il2 = ul2 = null;
      const al2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], cl2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function ll2(e3, t3) {
        let n3 = 65536;
        for (let r3 = 0, i3 = t3.length; r3 < i3; r3 += 2) {
          if (n3 += t3[r3], n3 > e3)
            return false;
          if (n3 += t3[r3 + 1], n3 >= e3)
            return true;
        }
        return false;
      }
      function pl2(e3) {
        return e3 < 65 ? e3 === 36 : e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && ol2.test(String.fromCharCode(e3)) : ll2(e3, al2)));
      }
      function fl2(e3) {
        return e3 < 48 ? e3 === 36 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && sl2.test(String.fromCharCode(e3)) : ll2(e3, al2) || ll2(e3, cl2))));
      }
      var dl2 = Object.defineProperty({ isIdentifierStart: tl2, isIdentifierChar: nl2, isIdentifierName: rl2 }, "__esModule", { value: true }), hl2 = Fl2, gl2 = xl2, ml2 = Sl2, yl2 = function(e3, t3) {
        return xl2(e3, t3) || Sl2(e3);
      }, Dl2 = function(e3) {
        return bl2.has(e3);
      };
      const El2 = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Cl2 = ["eval", "arguments"], bl2 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), Al2 = new Set(El2), vl2 = new Set(Cl2);
      function Fl2(e3, t3) {
        return t3 && e3 === "await" || e3 === "enum";
      }
      function xl2(e3, t3) {
        return Fl2(e3, t3) || Al2.has(e3);
      }
      function Sl2(e3) {
        return vl2.has(e3);
      }
      var wl2 = Object.defineProperty({ isReservedWord: hl2, isStrictReservedWord: gl2, isStrictBindOnlyReservedWord: ml2, isStrictBindReservedWord: yl2, isKeyword: Dl2 }, "__esModule", { value: true }), Tl2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), Object.defineProperty(t3, "isIdentifierName", { enumerable: true, get: function() {
          return dl2.isIdentifierName;
        } }), Object.defineProperty(t3, "isIdentifierChar", { enumerable: true, get: function() {
          return dl2.isIdentifierChar;
        } }), Object.defineProperty(t3, "isIdentifierStart", { enumerable: true, get: function() {
          return dl2.isIdentifierStart;
        } }), Object.defineProperty(t3, "isReservedWord", { enumerable: true, get: function() {
          return wl2.isReservedWord;
        } }), Object.defineProperty(t3, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
          return wl2.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(t3, "isStrictBindReservedWord", { enumerable: true, get: function() {
          return wl2.isStrictBindReservedWord;
        } }), Object.defineProperty(t3, "isStrictReservedWord", { enumerable: true, get: function() {
          return wl2.isStrictReservedWord;
        } }), Object.defineProperty(t3, "isKeyword", { enumerable: true, get: function() {
          return wl2.isKeyword;
        } });
      }), Bl2 = /[|\\{}()[\]^$+*?.]/g, Nl2 = function(e3) {
        if (typeof e3 != "string")
          throw new TypeError("Expected a string");
        return e3.replace(Bl2, "\\$&");
      }, kl2 = r2(function(e3) {
        const t3 = (e4, t4) => function() {
          const n4 = e4.apply(Ho2, arguments);
          return `[${n4 + t4}m`;
        }, n3 = (e4, t4) => function() {
          const n4 = e4.apply(Ho2, arguments);
          return `[${38 + t4};5;${n4}m`;
        }, r3 = (e4, t4) => function() {
          const n4 = e4.apply(Ho2, arguments);
          return `[${38 + t4};2;${n4[0]};${n4[1]};${n4[2]}m`;
        };
        Object.defineProperty(e3, "exports", { enumerable: true, get: function() {
          const e4 = new Map(), i3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
          i3.color.grey = i3.color.gray;
          for (const t4 of Object.keys(i3)) {
            const n4 = i3[t4];
            for (const t5 of Object.keys(n4)) {
              const r4 = n4[t5];
              i3[t5] = { open: `[${r4[0]}m`, close: `[${r4[1]}m` }, n4[t5] = i3[t5], e4.set(r4[0], r4[1]);
            }
            Object.defineProperty(i3, t4, { value: n4, enumerable: false }), Object.defineProperty(i3, "codes", { value: e4, enumerable: false });
          }
          const u3 = (e5) => e5, o3 = (e5, t4, n4) => [e5, t4, n4];
          i3.color.close = "[39m", i3.bgColor.close = "[49m", i3.color.ansi = { ansi: t3(u3, 0) }, i3.color.ansi256 = { ansi256: n3(u3, 0) }, i3.color.ansi16m = { rgb: r3(o3, 0) }, i3.bgColor.ansi = { ansi: t3(u3, 10) }, i3.bgColor.ansi256 = { ansi256: n3(u3, 10) }, i3.bgColor.ansi16m = { rgb: r3(o3, 10) };
          for (let e5 of Object.keys(Ho2)) {
            if (typeof Ho2[e5] != "object")
              continue;
            const u4 = Ho2[e5];
            e5 === "ansi16" && (e5 = "ansi"), "ansi16" in u4 && (i3.color.ansi[e5] = t3(u4.ansi16, 0), i3.bgColor.ansi[e5] = t3(u4.ansi16, 10)), "ansi256" in u4 && (i3.color.ansi256[e5] = n3(u4.ansi256, 0), i3.bgColor.ansi256[e5] = n3(u4.ansi256, 10)), "rgb" in u4 && (i3.color.ansi16m[e5] = r3(u4.rgb, 0), i3.bgColor.ansi16m[e5] = r3(u4.rgb, 10));
          }
          return i3;
        } });
      }), Pl2 = (e3, t3) => {
        t3 = t3 || Tr2.argv;
        const n3 = e3.startsWith("-") ? "" : e3.length === 1 ? "-" : "--", r3 = t3.indexOf(n3 + e3), i3 = t3.indexOf("--");
        return r3 !== -1 && (i3 === -1 || r3 < i3);
      };
      const Ol2 = Tr2.env;
      let Il2;
      function Ll2(e3) {
        return function(e4) {
          return e4 !== 0 && { level: e4, hasBasic: true, has256: e4 >= 2, has16m: e4 >= 3 };
        }(function(e4) {
          if (Il2 === false)
            return 0;
          if (Pl2("color=16m") || Pl2("color=full") || Pl2("color=truecolor"))
            return 3;
          if (Pl2("color=256"))
            return 2;
          if (e4 && !e4.isTTY && Il2 !== true)
            return 0;
          const t3 = Il2 ? 1 : 0;
          if ("CI" in Ol2)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e5) => e5 in Ol2) || Ol2.CI_NAME === "codeship" ? 1 : t3;
          if ("TEAMCITY_VERSION" in Ol2)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Ol2.TEAMCITY_VERSION) ? 1 : 0;
          if (Ol2.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in Ol2) {
            const e5 = parseInt((Ol2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (Ol2.TERM_PROGRAM) {
              case "iTerm.app":
                return e5 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(Ol2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Ol2.TERM) || "COLORTERM" in Ol2 ? 1 : (Ol2.TERM, t3);
        }(e3));
      }
      Pl2("no-color") || Pl2("no-colors") || Pl2("color=false") ? Il2 = false : (Pl2("color") || Pl2("colors") || Pl2("color=true") || Pl2("color=always")) && (Il2 = true), "FORCE_COLOR" in Ol2 && (Il2 = Ol2.FORCE_COLOR.length === 0 || parseInt(Ol2.FORCE_COLOR, 10) !== 0);
      var jl2 = { supportsColor: Ll2, stdout: Ll2(Tr2.stdout), stderr: Ll2(Tr2.stderr) };
      const _l2 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Ml2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Rl2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, $l2 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Vl2 = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function Wl2(e3) {
        return e3[0] === "u" && e3.length === 5 || e3[0] === "x" && e3.length === 3 ? String.fromCharCode(parseInt(e3.slice(1), 16)) : Vl2.get(e3) || e3;
      }
      function ql2(e3, t3) {
        const n3 = [], r3 = t3.trim().split(/\s*,\s*/g);
        let i3;
        for (const t4 of r3)
          if (isNaN(t4)) {
            if (!(i3 = t4.match(Rl2)))
              throw new Error(`Invalid Chalk template style argument: ${t4} (in style '${e3}')`);
            n3.push(i3[2].replace($l2, (e4, t5, n4) => t5 ? Wl2(t5) : n4));
          } else
            n3.push(Number(t4));
        return n3;
      }
      function Ul2(e3) {
        Ml2.lastIndex = 0;
        const t3 = [];
        let n3;
        for (; (n3 = Ml2.exec(e3)) !== null; ) {
          const e4 = n3[1];
          if (n3[2]) {
            const r3 = ql2(e4, n3[2]);
            t3.push([e4].concat(r3));
          } else
            t3.push([e4]);
        }
        return t3;
      }
      function zl2(e3, t3) {
        const n3 = {};
        for (const e4 of t3)
          for (const t4 of e4.styles)
            n3[t4[0]] = e4.inverse ? null : t4.slice(1);
        let r3 = e3;
        for (const e4 of Object.keys(n3))
          if (Array.isArray(n3[e4])) {
            if (!(e4 in r3))
              throw new Error(`Unknown Chalk style: ${e4}`);
            r3 = n3[e4].length > 0 ? r3[e4].apply(r3, n3[e4]) : r3[e4];
          }
        return r3;
      }
      var Gl2 = (e3, t3) => {
        const n3 = [], r3 = [];
        let i3 = [];
        if (t3.replace(_l2, (t4, u3, o3, s3, a3, c3) => {
          if (u3)
            i3.push(Wl2(u3));
          else if (s3) {
            const t5 = i3.join("");
            i3 = [], r3.push(n3.length === 0 ? t5 : zl2(e3, n3)(t5)), n3.push({ inverse: o3, styles: Ul2(s3) });
          } else if (a3) {
            if (n3.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r3.push(zl2(e3, n3)(i3.join(""))), i3 = [], n3.pop();
          } else
            i3.push(c3);
        }), r3.push(i3.join("")), n3.length > 0) {
          const e4 = `Chalk template literal is missing ${n3.length} closing bracket${n3.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(e4);
        }
        return r3.join("");
      }, Hl2 = r2(function(e3) {
        const t3 = jl2.stdout, r3 = ["ansi", "ansi", "ansi256", "ansi16m"], i3 = new Set(["gray"]), u3 = Object.create(null);
        function o3(e4, n3) {
          n3 = n3 || {};
          const r4 = t3 ? t3.level : 0;
          e4.level = n3.level === void 0 ? r4 : n3.level, e4.enabled = "enabled" in n3 ? n3.enabled : e4.level > 0;
        }
        function s3(e4) {
          if (!this || !(this instanceof s3) || this.template) {
            const t4 = {};
            return o3(t4, e4), t4.template = function() {
              const e5 = [].slice.call(arguments);
              return p3.apply(null, [t4.template].concat(e5));
            }, Object.setPrototypeOf(t4, s3.prototype), Object.setPrototypeOf(t4.template, t4), t4.template.constructor = s3, t4.template;
          }
          o3(this, e4);
        }
        for (const e4 of Object.keys(kl2))
          kl2[e4].closeRe = new RegExp(Nl2(kl2[e4].close), "g"), u3[e4] = { get() {
            const t4 = kl2[e4];
            return c3.call(this, this._styles ? this._styles.concat(t4) : [t4], this._empty, e4);
          } };
        u3.visible = { get() {
          return c3.call(this, this._styles || [], true, "visible");
        } }, kl2.color.closeRe = new RegExp(Nl2(kl2.color.close), "g");
        for (const e4 of Object.keys(kl2.color.ansi))
          i3.has(e4) || (u3[e4] = { get() {
            const t4 = this.level;
            return function() {
              const n3 = kl2.color[r3[t4]][e4].apply(null, arguments), i4 = { open: n3, close: kl2.color.close, closeRe: kl2.color.closeRe };
              return c3.call(this, this._styles ? this._styles.concat(i4) : [i4], this._empty, e4);
            };
          } });
        kl2.bgColor.closeRe = new RegExp(Nl2(kl2.bgColor.close), "g");
        for (const e4 of Object.keys(kl2.bgColor.ansi)) {
          if (i3.has(e4))
            continue;
          u3["bg" + e4[0].toUpperCase() + e4.slice(1)] = { get() {
            const t4 = this.level;
            return function() {
              const n3 = kl2.bgColor[r3[t4]][e4].apply(null, arguments), i4 = { open: n3, close: kl2.bgColor.close, closeRe: kl2.bgColor.closeRe };
              return c3.call(this, this._styles ? this._styles.concat(i4) : [i4], this._empty, e4);
            };
          } };
        }
        const a3 = Object.defineProperties(() => {
        }, u3);
        function c3(e4, t4, n3) {
          const r4 = function() {
            return l3.apply(r4, arguments);
          };
          r4._styles = e4, r4._empty = t4;
          const i4 = this;
          return Object.defineProperty(r4, "level", { enumerable: true, get: () => i4.level, set(e5) {
            i4.level = e5;
          } }), Object.defineProperty(r4, "enabled", { enumerable: true, get: () => i4.enabled, set(e5) {
            i4.enabled = e5;
          } }), r4.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r4.__proto__ = a3, r4;
        }
        function l3() {
          const e4 = arguments, t4 = e4.length;
          let r4 = String(arguments[0]);
          if (t4 === 0)
            return "";
          if (t4 > 1)
            for (let n3 = 1; n3 < t4; n3++)
              r4 += " " + e4[n3];
          if (!this.enabled || this.level <= 0 || !r4)
            return this._empty ? "" : r4;
          const i4 = kl2.dim.open;
          for (const e5 of this._styles.slice().reverse())
            r4 = e5.open + r4.replace(e5.closeRe, e5.open) + e5.close, r4 = r4.replace(/\r?\n/g, `${e5.close}$&${e5.open}`);
          return kl2.dim.open = i4, r4;
        }
        function p3(e4, t4) {
          if (!Array.isArray(t4))
            return [].slice.call(arguments, 1).join(" ");
          const n3 = [].slice.call(arguments, 2), r4 = [t4.raw[0]];
          for (let e5 = 1; e5 < t4.length; e5++)
            r4.push(String(n3[e5 - 1]).replace(/[{}\\]/g, "\\$&")), r4.push(String(t4.raw[e5]));
          return Gl2(e4, r4.join(""));
        }
        Object.defineProperties(s3.prototype, u3), e3.exports = s3(), e3.exports.supportsColor = t3, e3.exports.default = e3.exports;
      }), Jl2 = tp2, Xl2 = np2, Yl2 = function(e3, t3 = {}) {
        if (tp2(t3)) {
          const n3 = np2(t3);
          return function(e4, t4) {
            let n4 = "";
            for (const { type: r3, value: i3 } of ep2(t4)) {
              const t5 = e4[r3];
              n4 += t5 ? i3.split(Ql2).map((e5) => t5(e5)).join("\n") : i3;
            }
            return n4;
          }(function(e4) {
            return { keyword: e4.cyan, capitalized: e4.yellow, jsxIdentifier: e4.yellow, punctuator: e4.yellow, number: e4.magenta, string: e4.green, regex: e4.magenta, comment: e4.grey, invalid: e4.white.bgRed.bold };
          }(n3), e3);
        }
        return e3;
      };
      const Kl2 = new Set(["as", "async", "from", "get", "of", "set"]);
      const Ql2 = /\r\n|[\n\r\u2028\u2029]/, Zl2 = /^[()[\]{}]$/;
      let ep2;
      {
        const e3 = /^[a-z][\w-]*$/i, t3 = function(t4, n3, r3) {
          if (t4.type === "name") {
            if ((0, Tl2.isKeyword)(t4.value) || (0, Tl2.isStrictReservedWord)(t4.value, true) || Kl2.has(t4.value))
              return "keyword";
            if (e3.test(t4.value) && (r3[n3 - 1] === "<" || r3.substr(n3 - 2, 2) == "</"))
              return "jsxIdentifier";
            if (t4.value[0] !== t4.value[0].toLowerCase())
              return "capitalized";
          }
          return t4.type === "punctuator" && Zl2.test(t4.value) ? "bracket" : t4.type !== "invalid" || t4.value !== "@" && t4.value !== "#" ? t4.type : "punctuator";
        };
        ep2 = function* (e4) {
          let n3;
          for (; n3 = el2.default.exec(e4); ) {
            const r3 = el2.matchToToken(n3);
            yield { type: t3(r3, n3.index, e4), value: r3.value };
          }
        };
      }
      function tp2(e3) {
        return !!Hl2.supportsColor || e3.forceColor;
      }
      function np2(e3) {
        return e3.forceColor ? new Hl2.constructor({ enabled: true, level: 1 }) : Hl2;
      }
      var rp2 = Object.defineProperty({ shouldHighlight: Jl2, getChalk: Xl2, default: Yl2 }, "__esModule", { value: true }), ip2 = ap2, up2 = function(e3, t3, n3, r3 = {}) {
        if (!op2) {
          op2 = true;
          const e4 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
          {
            new Error(e4).name = "DeprecationWarning", console.warn(new Error(e4));
          }
        }
        n3 = Math.max(n3, 0);
        return ap2(e3, { start: { column: n3, line: t3 } }, r3);
      };
      let op2 = false;
      const sp2 = /\r\n|[\n\r\u2028\u2029]/;
      function ap2(e3, t3, n3 = {}) {
        const r3 = (n3.highlightCode || n3.forceColor) && (0, rp2.shouldHighlight)(n3), i3 = (0, rp2.getChalk)(n3), u3 = function(e4) {
          return { gutter: e4.grey, marker: e4.red.bold, message: e4.red.bold };
        }(i3), o3 = (e4, t4) => r3 ? e4(t4) : t4, s3 = e3.split(sp2), { start: a3, end: c3, markerLines: l3 } = function(e4, t4, n4) {
          const r4 = Object.assign({ column: 0, line: -1 }, e4.start), i4 = Object.assign({}, r4, e4.end), { linesAbove: u4 = 2, linesBelow: o4 = 3 } = n4 || {}, s4 = r4.line, a4 = r4.column, c4 = i4.line, l4 = i4.column;
          let p4 = Math.max(s4 - (u4 + 1), 0), f4 = Math.min(t4.length, c4 + o4);
          s4 === -1 && (p4 = 0), c4 === -1 && (f4 = t4.length);
          const d4 = c4 - s4, h3 = {};
          if (d4)
            for (let e5 = 0; e5 <= d4; e5++) {
              const n5 = e5 + s4;
              if (a4)
                if (e5 === 0) {
                  const e6 = t4[n5 - 1].length;
                  h3[n5] = [a4, e6 - a4 + 1];
                } else if (e5 === d4)
                  h3[n5] = [0, l4];
                else {
                  const r5 = t4[n5 - e5].length;
                  h3[n5] = [0, r5];
                }
              else
                h3[n5] = true;
            }
          else
            h3[s4] = a4 === l4 ? !a4 || [a4, 0] : [a4, l4 - a4];
          return { start: p4, end: f4, markerLines: h3 };
        }(t3, s3, n3), p3 = t3.start && typeof t3.start.column == "number", f3 = String(c3).length;
        let d3 = (r3 ? (0, rp2.default)(e3, n3) : e3).split(sp2).slice(a3, c3).map((e4, t4) => {
          const r4 = a3 + 1 + t4, i4 = ` ${` ${r4}`.slice(-f3)} |`, s4 = l3[r4], c4 = !l3[r4 + 1];
          if (s4) {
            let t5 = "";
            if (Array.isArray(s4)) {
              const r5 = e4.slice(0, Math.max(s4[0] - 1, 0)).replace(/[^\t]/g, " "), a4 = s4[1] || 1;
              t5 = ["\n ", o3(u3.gutter, i4.replace(/\d/g, " ")), " ", r5, o3(u3.marker, "^").repeat(a4)].join(""), c4 && n3.message && (t5 += " " + o3(u3.message, n3.message));
            }
            return [o3(u3.marker, ">"), o3(u3.gutter, i4), e4.length > 0 ? ` ${e4}` : "", t5].join("");
          }
          return ` ${o3(u3.gutter, i4)}${e4.length > 0 ? ` ${e4}` : ""}`;
        }).join("\n");
        return n3.message && !p3 && (d3 = `${" ".repeat(f3 + 1)}${n3.message}
${d3}`), r3 ? i3.reset(d3) : d3;
      }
      var cp2 = Object.defineProperty({ codeFrameColumns: ip2, default: up2 }, "__esModule", { value: true }), lp2 = n2(vu2);
      const { ConfigError: pp2 } = Bo2, { locStart: fp2, locEnd: dp2 } = Zc2, hp2 = Object.getOwnPropertyNames, gp2 = Object.getOwnPropertyDescriptor;
      function mp2(e3) {
        const t3 = {};
        for (const n3 of e3.plugins)
          if (n3.parsers)
            for (const e4 of hp2(n3.parsers))
              Object.defineProperty(t3, e4, gp2(n3.parsers, e4));
        return t3;
      }
      function yp2(e3, t3 = mp2(e3)) {
        if (typeof e3.parser == "function")
          return { parse: e3.parser, astFormat: "estree", locStart: fp2, locEnd: dp2 };
        if (typeof e3.parser == "string") {
          if (Object.prototype.hasOwnProperty.call(t3, e3.parser))
            return t3[e3.parser];
          throw new pp2(`Couldn't resolve parser "${e3.parser}". Parsers must be explicitly added to the standalone bundle.`);
        }
      }
      var Dp2 = { parse: function(e3, t3) {
        const n3 = mp2(t3), r3 = Object.defineProperties({}, Object.fromEntries(Object.keys(n3).map((e4) => [e4, { enumerable: true, get: () => n3[e4].parse }]))), i3 = yp2(t3, n3);
        try {
          return i3.preprocess && (e3 = i3.preprocess(e3, t3)), { text: e3, ast: i3.parse(e3, r3, t3) };
        } catch (t4) {
          const { loc: n4 } = t4;
          if (n4) {
            const { codeFrameColumns: r4 } = cp2;
            throw t4.codeFrame = r4(e3, n4, { highlightCode: true }), t4.message += "\n" + t4.codeFrame, t4;
          }
          throw t4.stack;
        }
      }, resolveParser: yp2 };
      const { UndefinedParserError: Ep2 } = Bo2, { getSupportInfo: Cp2 } = ui2, { resolveParser: bp2 } = Dp2, Ap2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
      function vp2(e3, t3) {
        const n3 = lp2.basename(e3).toLowerCase(), r3 = Cp2({ plugins: t3 }).languages.filter((e4) => e4.since !== null);
        let i3 = r3.find((e4) => e4.extensions && e4.extensions.some((e5) => n3.endsWith(e5)) || e4.filenames && e4.filenames.some((e5) => e5.toLowerCase() === n3));
        if (!i3 && !n3.includes(".")) {
          const t4 = function(e4) {
            if (typeof e4 != "string")
              return "";
            let t5;
            try {
              t5 = vo2.openSync(e4, "r");
            } catch (e5) {
              return "";
            }
            try {
              const e5 = new Fo2(t5).next().toString("utf8"), n4 = e5.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
              if (n4)
                return n4[1];
              const r4 = e5.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
              return r4 ? r4[1] : "";
            } catch (e5) {
              return "";
            } finally {
              try {
                vo2.closeSync(t5);
              } catch (e5) {
              }
            }
          }(e3);
          i3 = r3.find((e4) => e4.interpreters && e4.interpreters.includes(t4));
        }
        return i3 && i3.parsers[0];
      }
      var Fp2 = { normalize: function(e3, t3 = {}) {
        const n3 = Object.assign({}, e3), r3 = Cp2({ plugins: e3.plugins, showUnreleased: true, showDeprecated: true }).options, i3 = Object.assign(Object.assign({}, Ap2), Object.fromEntries(r3.filter((e4) => e4.default !== void 0).map((e4) => [e4.name, e4.default])));
        if (!n3.parser)
          if (n3.filepath) {
            if (n3.parser = vp2(n3.filepath, n3.plugins), !n3.parser)
              throw new Ep2(`No parser could be inferred for file: ${n3.filepath}`);
          } else {
            (t3.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n3.parser = "babel";
          }
        const u3 = bp2(Jc2.normalizeApiOptions(n3, [r3.find((e4) => e4.name === "parser")], { passThrough: true, logger: false }));
        n3.astFormat = u3.astFormat, n3.locEnd = u3.locEnd, n3.locStart = u3.locStart;
        const o3 = function(e4) {
          const { astFormat: t4 } = e4;
          if (!t4)
            throw new Error("getPlugin() requires astFormat to be set");
          const n4 = e4.plugins.find((e5) => e5.printers && e5.printers[t4]);
          if (!n4)
            throw new Error(`Couldn't find plugin for AST format "${t4}"`);
          return n4;
        }(n3);
        n3.printer = o3.printers[n3.astFormat];
        const s3 = Object.fromEntries(r3.filter((e4) => e4.pluginDefaults && e4.pluginDefaults[o3.name] !== void 0).map((e4) => [e4.name, e4.pluginDefaults[o3.name]])), a3 = Object.assign(Object.assign({}, i3), s3);
        for (const [e4, t4] of Object.entries(a3))
          n3[e4] !== null && n3[e4] !== void 0 || (n3[e4] = t4);
        return n3.parser === "json" && (n3.trailingComma = "none"), Jc2.normalizeApiOptions(n3, r3, Object.assign({ passThrough: Object.keys(Ap2) }, t3));
      }, hiddenDefaults: Ap2, inferParser: vp2 };
      var xp2 = function e3(t3, n3, r3) {
        if (Array.isArray(t3))
          return t3.map((t4) => e3(t4, n3, r3)).filter(Boolean);
        if (!t3 || typeof t3 != "object")
          return t3;
        const i3 = n3.printer.massageAstNode;
        let u3;
        u3 = i3 && i3.ignoredProperties ? i3.ignoredProperties : new Set();
        const o3 = {};
        for (const [r4, i4] of Object.entries(t3))
          u3.has(r4) || typeof i4 == "function" || (o3[r4] = e3(i4, n3, t3));
        if (i3) {
          const e4 = i3(t3, o3, r3);
          if (e4 === null)
            return;
          if (e4)
            return e4;
        }
        return o3;
      }, Sp2 = typeof Object.create == "function" ? function(e3, t3) {
        e3.super_ = t3, e3.prototype = Object.create(t3.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } });
      } : function(e3, t3) {
        e3.super_ = t3;
        var n3 = function() {
        };
        n3.prototype = t3.prototype, e3.prototype = new n3(), e3.prototype.constructor = e3;
      };
      function wp2(e3, t3) {
        var n3 = { seen: [], stylize: Bp2 };
        return arguments.length >= 3 && (n3.depth = arguments[2]), arguments.length >= 4 && (n3.colors = arguments[3]), Op2(t3) ? n3.showHidden = t3 : t3 && Up2(n3, t3), jp2(n3.showHidden) && (n3.showHidden = false), jp2(n3.depth) && (n3.depth = 2), jp2(n3.colors) && (n3.colors = false), jp2(n3.customInspect) && (n3.customInspect = true), n3.colors && (n3.stylize = Tp2), Np2(n3, e3, n3.depth);
      }
      function Tp2(e3, t3) {
        var n3 = wp2.styles[t3];
        return n3 ? "[" + wp2.colors[n3][0] + "m" + e3 + "[" + wp2.colors[n3][1] + "m" : e3;
      }
      function Bp2(e3, t3) {
        return e3;
      }
      function Np2(e3, t3, n3) {
        if (e3.customInspect && t3 && Vp2(t3.inspect) && t3.inspect !== wp2 && (!t3.constructor || t3.constructor.prototype !== t3)) {
          var r3 = t3.inspect(n3, e3);
          return Lp2(r3) || (r3 = Np2(e3, r3, n3)), r3;
        }
        var i3 = function(e4, t4) {
          if (jp2(t4))
            return e4.stylize("undefined", "undefined");
          if (Lp2(t4)) {
            var n4 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e4.stylize(n4, "string");
          }
          if (r4 = t4, typeof r4 == "number")
            return e4.stylize("" + t4, "number");
          var r4;
          if (Op2(t4))
            return e4.stylize("" + t4, "boolean");
          if (Ip2(t4))
            return e4.stylize("null", "null");
        }(e3, t3);
        if (i3)
          return i3;
        var u3 = Object.keys(t3), o3 = function(e4) {
          var t4 = {};
          return e4.forEach(function(e5, n4) {
            t4[e5] = true;
          }), t4;
        }(u3);
        if (e3.showHidden && (u3 = Object.getOwnPropertyNames(t3)), $p2(t3) && (u3.indexOf("message") >= 0 || u3.indexOf("description") >= 0))
          return kp2(t3);
        if (u3.length === 0) {
          if (Vp2(t3)) {
            var s3 = t3.name ? ": " + t3.name : "";
            return e3.stylize("[Function" + s3 + "]", "special");
          }
          if (_p2(t3))
            return e3.stylize(RegExp.prototype.toString.call(t3), "regexp");
          if (Rp2(t3))
            return e3.stylize(Date.prototype.toString.call(t3), "date");
          if ($p2(t3))
            return kp2(t3);
        }
        var a3, c3, l3 = "", p3 = false, f3 = ["{", "}"];
        (a3 = t3, Array.isArray(a3) && (p3 = true, f3 = ["[", "]"]), Vp2(t3)) && (l3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
        return _p2(t3) && (l3 = " " + RegExp.prototype.toString.call(t3)), Rp2(t3) && (l3 = " " + Date.prototype.toUTCString.call(t3)), $p2(t3) && (l3 = " " + kp2(t3)), u3.length !== 0 || p3 && t3.length != 0 ? n3 < 0 ? _p2(t3) ? e3.stylize(RegExp.prototype.toString.call(t3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(t3), c3 = p3 ? function(e4, t4, n4, r4, i4) {
          for (var u4 = [], o4 = 0, s4 = t4.length; o4 < s4; ++o4)
            zp2(t4, String(o4)) ? u4.push(Pp2(e4, t4, n4, r4, String(o4), true)) : u4.push("");
          return i4.forEach(function(i5) {
            i5.match(/^\d+$/) || u4.push(Pp2(e4, t4, n4, r4, i5, true));
          }), u4;
        }(e3, t3, n3, o3, u3) : u3.map(function(r4) {
          return Pp2(e3, t3, n3, o3, r4, p3);
        }), e3.seen.pop(), function(e4, t4, n4) {
          if (e4.reduce(function(e5, t5) {
            return t5.indexOf("\n"), e5 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0) > 60)
            return n4[0] + (t4 === "" ? "" : t4 + "\n ") + " " + e4.join(",\n  ") + " " + n4[1];
          return n4[0] + t4 + " " + e4.join(", ") + " " + n4[1];
        }(c3, l3, f3)) : f3[0] + l3 + f3[1];
      }
      function kp2(e3) {
        return "[" + Error.prototype.toString.call(e3) + "]";
      }
      function Pp2(e3, t3, n3, r3, i3, u3) {
        var o3, s3, a3;
        if ((a3 = Object.getOwnPropertyDescriptor(t3, i3) || { value: t3[i3] }).get ? s3 = a3.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : a3.set && (s3 = e3.stylize("[Setter]", "special")), zp2(r3, i3) || (o3 = "[" + i3 + "]"), s3 || (e3.seen.indexOf(a3.value) < 0 ? (s3 = Ip2(n3) ? Np2(e3, a3.value, null) : Np2(e3, a3.value, n3 - 1)).indexOf("\n") > -1 && (s3 = u3 ? s3.split("\n").map(function(e4) {
          return "  " + e4;
        }).join("\n").substr(2) : "\n" + s3.split("\n").map(function(e4) {
          return "   " + e4;
        }).join("\n")) : s3 = e3.stylize("[Circular]", "special")), jp2(o3)) {
          if (u3 && i3.match(/^\d+$/))
            return s3;
          (o3 = JSON.stringify("" + i3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o3 = o3.substr(1, o3.length - 2), o3 = e3.stylize(o3, "name")) : (o3 = o3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o3 = e3.stylize(o3, "string"));
        }
        return o3 + ": " + s3;
      }
      function Op2(e3) {
        return typeof e3 == "boolean";
      }
      function Ip2(e3) {
        return e3 === null;
      }
      function Lp2(e3) {
        return typeof e3 == "string";
      }
      function jp2(e3) {
        return e3 === void 0;
      }
      function _p2(e3) {
        return Mp2(e3) && qp2(e3) === "[object RegExp]";
      }
      function Mp2(e3) {
        return typeof e3 == "object" && e3 !== null;
      }
      function Rp2(e3) {
        return Mp2(e3) && qp2(e3) === "[object Date]";
      }
      function $p2(e3) {
        return Mp2(e3) && (qp2(e3) === "[object Error]" || e3 instanceof Error);
      }
      function Vp2(e3) {
        return typeof e3 == "function";
      }
      function Wp2(e3) {
        return e3 === null || typeof e3 == "boolean" || typeof e3 == "number" || typeof e3 == "string" || typeof e3 == "symbol" || e3 === void 0;
      }
      function qp2(e3) {
        return Object.prototype.toString.call(e3);
      }
      function Up2(e3, t3) {
        if (!t3 || !Mp2(t3))
          return e3;
        for (var n3 = Object.keys(t3), r3 = n3.length; r3--; )
          e3[n3[r3]] = t3[n3[r3]];
        return e3;
      }
      function zp2(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }
      function Gp2(e3, t3) {
        if (e3 === t3)
          return 0;
        for (var n3 = e3.length, r3 = t3.length, i3 = 0, u3 = Math.min(n3, r3); i3 < u3; ++i3)
          if (e3[i3] !== t3[i3]) {
            n3 = e3[i3], r3 = t3[i3];
            break;
          }
        return n3 < r3 ? -1 : r3 < n3 ? 1 : 0;
      }
      wp2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, wp2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
      var Hp2, Jp2 = Object.prototype.hasOwnProperty, Xp2 = Object.keys || function(e3) {
        var t3 = [];
        for (var n3 in e3)
          Jp2.call(e3, n3) && t3.push(n3);
        return t3;
      }, Yp2 = Array.prototype.slice;
      function Kp2() {
        return Hp2 !== void 0 ? Hp2 : Hp2 = function() {
        }.name === "foo";
      }
      function Qp2(e3) {
        return Object.prototype.toString.call(e3);
      }
      function Zp2(e3) {
        return !bo2(e3) && (typeof ir2.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e3) : !!e3 && (e3 instanceof DataView || !!(e3.buffer && e3.buffer instanceof ArrayBuffer))));
      }
      function ef2(e3, t3) {
        e3 || sf2(e3, true, t3, "==", af2);
      }
      var tf2 = /\s*function\s+([^\(\s]*)\s*/;
      function nf2(e3) {
        if (Vp2(e3)) {
          if (Kp2())
            return e3.name;
          var t3 = e3.toString().match(tf2);
          return t3 && t3[1];
        }
      }
      function rf2(e3) {
        this.name = "AssertionError", this.actual = e3.actual, this.expected = e3.expected, this.operator = e3.operator, e3.message ? (this.message = e3.message, this.generatedMessage = false) : (this.message = function(e4) {
          return uf2(of2(e4.actual), 128) + " " + e4.operator + " " + uf2(of2(e4.expected), 128);
        }(this), this.generatedMessage = true);
        var t3 = e3.stackStartFunction || sf2;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, t3);
        else {
          var n3 = new Error();
          if (n3.stack) {
            var r3 = n3.stack, i3 = nf2(t3), u3 = r3.indexOf("\n" + i3);
            if (u3 >= 0) {
              var o3 = r3.indexOf("\n", u3 + 1);
              r3 = r3.substring(o3 + 1);
            }
            this.stack = r3;
          }
        }
      }
      function uf2(e3, t3) {
        return typeof e3 == "string" ? e3.length < t3 ? e3 : e3.slice(0, t3) : e3;
      }
      function of2(e3) {
        if (Kp2() || !Vp2(e3))
          return wp2(e3);
        var t3 = nf2(e3);
        return "[Function" + (t3 ? ": " + t3 : "") + "]";
      }
      function sf2(e3, t3, n3, r3, i3) {
        throw new rf2({ message: n3, actual: e3, expected: t3, operator: r3, stackStartFunction: i3 });
      }
      function af2(e3, t3) {
        e3 || sf2(e3, true, t3, "==", af2);
      }
      function cf2(e3, t3, n3) {
        e3 != t3 && sf2(e3, t3, n3, "==", cf2);
      }
      function lf2(e3, t3, n3) {
        e3 == t3 && sf2(e3, t3, n3, "!=", lf2);
      }
      function pf2(e3, t3, n3) {
        df2(e3, t3, false) || sf2(e3, t3, n3, "deepEqual", pf2);
      }
      function ff2(e3, t3, n3) {
        df2(e3, t3, true) || sf2(e3, t3, n3, "deepStrictEqual", ff2);
      }
      function df2(e3, t3, n3, r3) {
        if (e3 === t3)
          return true;
        if (bo2(e3) && bo2(t3))
          return Gp2(e3, t3) === 0;
        if (Rp2(e3) && Rp2(t3))
          return e3.getTime() === t3.getTime();
        if (_p2(e3) && _p2(t3))
          return e3.source === t3.source && e3.global === t3.global && e3.multiline === t3.multiline && e3.lastIndex === t3.lastIndex && e3.ignoreCase === t3.ignoreCase;
        if (e3 !== null && typeof e3 == "object" || t3 !== null && typeof t3 == "object") {
          if (Zp2(e3) && Zp2(t3) && Qp2(e3) === Qp2(t3) && !(e3 instanceof Float32Array || e3 instanceof Float64Array))
            return Gp2(new Uint8Array(e3.buffer), new Uint8Array(t3.buffer)) === 0;
          if (bo2(e3) !== bo2(t3))
            return false;
          var i3 = (r3 = r3 || { actual: [], expected: [] }).actual.indexOf(e3);
          return i3 !== -1 && i3 === r3.expected.indexOf(t3) || (r3.actual.push(e3), r3.expected.push(t3), function(e4, t4, n4, r4) {
            if (e4 == null || t4 == null)
              return false;
            if (Wp2(e4) || Wp2(t4))
              return e4 === t4;
            if (n4 && Object.getPrototypeOf(e4) !== Object.getPrototypeOf(t4))
              return false;
            var i4 = hf2(e4), u3 = hf2(t4);
            if (i4 && !u3 || !i4 && u3)
              return false;
            if (i4)
              return df2(e4 = Yp2.call(e4), t4 = Yp2.call(t4), n4);
            var o3, s3, a3 = Xp2(e4), c3 = Xp2(t4);
            if (a3.length !== c3.length)
              return false;
            for (a3.sort(), c3.sort(), s3 = a3.length - 1; s3 >= 0; s3--)
              if (a3[s3] !== c3[s3])
                return false;
            for (s3 = a3.length - 1; s3 >= 0; s3--)
              if (!df2(e4[o3 = a3[s3]], t4[o3], n4, r4))
                return false;
            return true;
          }(e3, t3, n3, r3));
        }
        return n3 ? e3 === t3 : e3 == t3;
      }
      function hf2(e3) {
        return Object.prototype.toString.call(e3) == "[object Arguments]";
      }
      function gf2(e3, t3, n3) {
        df2(e3, t3, false) && sf2(e3, t3, n3, "notDeepEqual", gf2);
      }
      function mf2(e3, t3, n3) {
        df2(e3, t3, true) && sf2(e3, t3, n3, "notDeepStrictEqual", mf2);
      }
      function yf2(e3, t3, n3) {
        e3 !== t3 && sf2(e3, t3, n3, "===", yf2);
      }
      function Df2(e3, t3, n3) {
        e3 === t3 && sf2(e3, t3, n3, "!==", Df2);
      }
      function Ef2(e3, t3) {
        if (!e3 || !t3)
          return false;
        if (Object.prototype.toString.call(t3) == "[object RegExp]")
          return t3.test(e3);
        try {
          if (e3 instanceof t3)
            return true;
        } catch (e4) {
        }
        return !Error.isPrototypeOf(t3) && t3.call({}, e3) === true;
      }
      function Cf2(e3, t3, n3, r3) {
        var i3;
        if (typeof t3 != "function")
          throw new TypeError('"block" argument must be a function');
        typeof n3 == "string" && (r3 = n3, n3 = null), i3 = function(e4) {
          var t4;
          try {
            e4();
          } catch (e5) {
            t4 = e5;
          }
          return t4;
        }(t3), r3 = (n3 && n3.name ? " (" + n3.name + ")." : ".") + (r3 ? " " + r3 : "."), e3 && !i3 && sf2(i3, n3, "Missing expected exception" + r3);
        var u3 = typeof r3 == "string", o3 = !e3 && i3 && !n3;
        if ((!e3 && $p2(i3) && u3 && Ef2(i3, n3) || o3) && sf2(i3, n3, "Got unwanted exception" + r3), e3 && i3 && n3 && !Ef2(i3, n3) || !e3 && i3)
          throw i3;
      }
      function bf2(e3, t3, n3) {
        Cf2(true, e3, t3, n3);
      }
      function Af2(e3, t3, n3) {
        Cf2(false, e3, t3, n3);
      }
      function vf2(e3) {
        if (e3)
          throw e3;
      }
      ef2.AssertionError = rf2, Sp2(rf2, Error), ef2.fail = sf2, ef2.ok = af2, ef2.equal = cf2, ef2.notEqual = lf2, ef2.deepEqual = pf2, ef2.deepStrictEqual = ff2, ef2.notDeepEqual = gf2, ef2.notDeepStrictEqual = mf2, ef2.strictEqual = yf2, ef2.notStrictEqual = Df2, ef2.throws = bf2, ef2.doesNotThrow = Af2, ef2.ifError = vf2;
      var Ff2 = n2(Object.freeze({ __proto__: null, default: ef2, AssertionError: rf2, fail: sf2, ok: af2, assert: af2, equal: cf2, notEqual: lf2, deepEqual: pf2, deepStrictEqual: ff2, notDeepEqual: gf2, notDeepStrictEqual: mf2, strictEqual: yf2, notStrictEqual: Df2, throws: bf2, doesNotThrow: Af2, ifError: vf2 }));
      const { builders: { line: xf2, hardline: Sf2, breakParent: wf2, indent: Tf2, lineSuffix: Bf2, join: Nf2, cursor: kf2 } } = su2, { hasNewline: Pf2, skipNewline: Of2, skipSpaces: If2, isPreviousLineEmpty: Lf2, addLeadingComment: jf2, addDanglingComment: _f2, addTrailingComment: Mf2 } = Fi2, Rf2 = new WeakMap();
      function $f2(e3, t3, n3) {
        if (!e3)
          return;
        const { printer: r3, locStart: i3, locEnd: u3 } = t3;
        if (n3) {
          if (r3.canAttachComment && r3.canAttachComment(e3)) {
            let t4;
            for (t4 = n3.length - 1; t4 >= 0 && !(i3(n3[t4]) <= i3(e3) && u3(n3[t4]) <= u3(e3)); --t4)
              ;
            return void n3.splice(t4 + 1, 0, e3);
          }
        } else if (Rf2.has(e3))
          return Rf2.get(e3);
        const o3 = r3.getCommentChildNodes && r3.getCommentChildNodes(e3, t3) || typeof e3 == "object" && Object.entries(e3).filter(([e4]) => e4 !== "enclosingNode" && e4 !== "precedingNode" && e4 !== "followingNode" && e4 !== "tokens" && e4 !== "comments").map(([, e4]) => e4);
        if (o3) {
          n3 || (n3 = [], Rf2.set(e3, n3));
          for (const e4 of o3)
            $f2(e4, t3, n3);
          return n3;
        }
      }
      function Vf2(e3, t3, n3, r3) {
        const { locStart: i3, locEnd: u3 } = n3, o3 = i3(t3), s3 = u3(t3), a3 = $f2(e3, n3);
        let c3, l3, p3 = 0, f3 = a3.length;
        for (; p3 < f3; ) {
          const e4 = p3 + f3 >> 1, r4 = a3[e4], d3 = i3(r4), h3 = u3(r4);
          if (d3 <= o3 && s3 <= h3)
            return Vf2(r4, t3, n3, r4);
          if (h3 <= o3)
            c3 = r4, p3 = e4 + 1;
          else {
            if (!(s3 <= d3))
              throw new Error("Comment location overlaps with node location");
            l3 = r4, f3 = e4;
          }
        }
        if (r3 && r3.type === "TemplateLiteral") {
          const { quasis: e4 } = r3, i4 = Jf2(e4, t3, n3);
          c3 && Jf2(e4, c3, n3) !== i4 && (c3 = null), l3 && Jf2(e4, l3, n3) !== i4 && (l3 = null);
        }
        return { enclosingNode: r3, precedingNode: c3, followingNode: l3 };
      }
      const Wf2 = () => false;
      const qf2 = (e3) => !/[\S\n\u2028\u2029]/.test(e3);
      function Uf2(e3, t3, n3, r3) {
        const { comment: i3, precedingNode: u3 } = n3[r3], { locStart: o3, locEnd: s3 } = t3;
        let a3 = o3(i3);
        if (u3)
          for (let t4 = r3 - 1; t4 >= 0; t4--) {
            const { comment: r4, precedingNode: i4 } = n3[t4];
            if (i4 !== u3 || !qf2(e3.slice(s3(r4), a3)))
              break;
            a3 = o3(r4);
          }
        return Pf2(e3, a3, { backwards: true });
      }
      function zf2(e3, t3, n3, r3) {
        const { comment: i3, followingNode: u3 } = n3[r3], { locStart: o3, locEnd: s3 } = t3;
        let a3 = s3(i3);
        if (u3)
          for (let t4 = r3 + 1; t4 < n3.length; t4++) {
            const { comment: r4, followingNode: i4 } = n3[t4];
            if (i4 !== u3 || !qf2(e3.slice(a3, o3(r4))))
              break;
            a3 = s3(r4);
          }
        return Pf2(e3, a3);
      }
      function Gf2(e3, t3, n3) {
        const r3 = e3.length;
        if (r3 === 0)
          return;
        const { precedingNode: i3, followingNode: u3, enclosingNode: o3 } = e3[0], s3 = n3.printer.getGapRegex && n3.printer.getGapRegex(o3) || /^[\s(]*$/;
        let a3, c3 = n3.locStart(u3);
        for (a3 = r3; a3 > 0; --a3) {
          const { comment: r4, precedingNode: o4, followingNode: l3 } = e3[a3 - 1];
          Ff2.strictEqual(o4, i3), Ff2.strictEqual(l3, u3);
          const p3 = t3.slice(n3.locEnd(r4), c3);
          if (!s3.test(p3))
            break;
          c3 = n3.locStart(r4);
        }
        for (const [t4, { comment: n4 }] of e3.entries())
          t4 < a3 ? Mf2(i3, n4) : jf2(u3, n4);
        for (const e4 of [i3, u3])
          e4.comments && e4.comments.length > 1 && e4.comments.sort((e5, t4) => n3.locStart(e5) - n3.locStart(t4));
        e3.length = 0;
      }
      function Hf2(e3, t3) {
        return e3.getValue().printed = true, t3.printer.printComment(e3, t3);
      }
      function Jf2(e3, t3, n3) {
        const r3 = n3.locStart(t3) - 1;
        for (let t4 = 1; t4 < e3.length; ++t4)
          if (r3 < n3.locStart(e3[t4]))
            return t4 - 1;
        return 0;
      }
      function Xf2(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!r3)
          return {};
        let i3 = r3.comments || [];
        n3 && (i3 = i3.filter((e4) => !n3.has(e4)));
        const u3 = r3 === t3.cursorNode;
        if (i3.length === 0) {
          const e4 = u3 ? kf2 : "";
          return { leading: e4, trailing: e4 };
        }
        const o3 = [], s3 = [];
        return e3.each(() => {
          const r4 = e3.getValue();
          if (n3 && n3.has(r4))
            return;
          const { leading: i4, trailing: u4 } = r4;
          i4 ? o3.push(function(e4, t4) {
            const n4 = e4.getValue(), r5 = [Hf2(e4, t4)], { printer: i5, originalText: u5, locStart: o4, locEnd: s4 } = t4;
            if (i5.isBlockComment && i5.isBlockComment(n4)) {
              const e5 = Pf2(u5, s4(n4)) ? Pf2(u5, o4(n4), { backwards: true }) ? Sf2 : xf2 : " ";
              r5.push(e5);
            } else
              r5.push(Sf2);
            const a3 = Of2(u5, If2(u5, s4(n4)));
            return a3 !== false && Pf2(u5, a3) && r5.push(Sf2), r5;
          }(e3, t3)) : u4 && s3.push(function(e4, t4) {
            const n4 = e4.getValue(), r5 = Hf2(e4, t4), { printer: i5, originalText: u5, locStart: o4 } = t4, s4 = i5.isBlockComment && i5.isBlockComment(n4);
            if (Pf2(u5, o4(n4), { backwards: true })) {
              const e5 = Lf2(u5, n4, o4);
              return Bf2([Sf2, e5 ? Sf2 : "", r5]);
            }
            let a3 = [" ", r5];
            return s4 || (a3 = [Bf2(a3), wf2]), a3;
          }(e3, t3));
        }, "comments"), u3 && (o3.unshift(kf2), s3.push(kf2)), { leading: o3, trailing: s3 };
      }
      var Yf2 = { attach: function(e3, t3, n3, r3) {
        if (!Array.isArray(e3))
          return;
        const i3 = [], { locStart: u3, locEnd: o3, printer: { handleComments: s3 = {} } } = r3, { avoidAstMutation: a3, ownLine: c3 = Wf2, endOfLine: l3 = Wf2, remaining: p3 = Wf2 } = s3, f3 = e3.map((i4, u4) => Object.assign(Object.assign({}, Vf2(t3, i4, r3)), {}, { comment: i4, text: n3, options: r3, ast: t3, isLastComment: e3.length - 1 === u4 }));
        for (const [e4, t4] of f3.entries()) {
          const { comment: n4, precedingNode: r4, enclosingNode: s4, followingNode: d3, text: h3, options: g3, ast: m3, isLastComment: y3 } = t4;
          if (g3.parser === "json" || g3.parser === "json5" || g3.parser === "__js_expression" || g3.parser === "__vue_expression") {
            if (u3(n4) - u3(m3) <= 0) {
              jf2(m3, n4);
              continue;
            }
            if (o3(n4) - o3(m3) >= 0) {
              Mf2(m3, n4);
              continue;
            }
          }
          let D3;
          if (a3 ? D3 = [t4] : (n4.enclosingNode = s4, n4.precedingNode = r4, n4.followingNode = d3, D3 = [n4, h3, g3, m3, y3]), Uf2(h3, g3, f3, e4))
            n4.placement = "ownLine", c3(...D3) || (d3 ? jf2(d3, n4) : r4 ? Mf2(r4, n4) : _f2(s4 || m3, n4));
          else if (zf2(h3, g3, f3, e4))
            n4.placement = "endOfLine", l3(...D3) || (r4 ? Mf2(r4, n4) : d3 ? jf2(d3, n4) : _f2(s4 || m3, n4));
          else if (n4.placement = "remaining", p3(...D3))
            ;
          else if (r4 && d3) {
            const e5 = i3.length;
            if (e5 > 0) {
              i3[e5 - 1].followingNode !== d3 && Gf2(i3, h3, g3);
            }
            i3.push(t4);
          } else
            r4 ? Mf2(r4, n4) : d3 ? jf2(d3, n4) : _f2(s4 || m3, n4);
        }
        if (Gf2(i3, n3, r3), !a3)
          for (const t4 of e3)
            delete t4.precedingNode, delete t4.enclosingNode, delete t4.followingNode;
      }, printComments: function(e3, t3, n3, r3) {
        const { leading: i3, trailing: u3 } = Xf2(e3, n3, r3);
        return i3 || u3 ? [i3, t3, u3] : t3;
      }, printCommentsSeparately: Xf2, printDanglingComments: function(e3, t3, n3, r3) {
        const i3 = [], u3 = e3.getValue();
        return u3 && u3.comments ? (e3.each(() => {
          const n4 = e3.getValue();
          n4.leading || n4.trailing || r3 && !r3(n4) || i3.push(Hf2(e3, t3));
        }, "comments"), i3.length === 0 ? "" : n3 ? Nf2(Sf2, i3) : Tf2([Sf2, Nf2(Sf2, i3)])) : "";
      }, getSortedChildNodes: $f2, ensureAllCommentsPrinted: function(e3) {
        if (e3)
          for (const t3 of e3) {
            if (!t3.printed)
              throw new Error('Comment "' + t3.value.trim() + '" was not printed. Please report this error!');
            delete t3.printed;
          }
      } };
      function Kf2(e3, t3) {
        const n3 = Qf2(e3.stack, t3);
        return n3 === -1 ? null : e3.stack[n3];
      }
      function Qf2(e3, t3) {
        for (let n3 = e3.length - 1; n3 >= 0; n3 -= 2) {
          const r3 = e3[n3];
          if (r3 && !Array.isArray(r3) && --t3 < 0)
            return n3;
        }
        return -1;
      }
      var Zf2 = class {
        constructor(e3) {
          this.stack = [e3];
        }
        getName() {
          const { stack: e3 } = this, { length: t3 } = e3;
          return t3 > 1 ? e3[t3 - 2] : null;
        }
        getValue() {
          return _n2(this.stack);
        }
        getNode(e3 = 0) {
          return Kf2(this, e3);
        }
        getParentNode(e3 = 0) {
          return Kf2(this, e3 + 1);
        }
        call(e3, ...t3) {
          const { stack: n3 } = this, { length: r3 } = n3;
          let i3 = _n2(n3);
          for (const e4 of t3)
            i3 = i3[e4], n3.push(e4, i3);
          const u3 = e3(this);
          return n3.length = r3, u3;
        }
        callParent(e3, t3 = 0) {
          const n3 = Qf2(this.stack, t3 + 1), r3 = this.stack.splice(n3 + 1), i3 = e3(this);
          return this.stack.push(...r3), i3;
        }
        each(e3, ...t3) {
          const { stack: n3 } = this, { length: r3 } = n3;
          let i3 = _n2(n3);
          for (const e4 of t3)
            i3 = i3[e4], n3.push(e4, i3);
          for (let t4 = 0; t4 < i3.length; ++t4)
            n3.push(t4, i3[t4]), e3(this, t4, i3), n3.length -= 2;
          n3.length = r3;
        }
        map(e3, ...t3) {
          const n3 = [];
          return this.each((t4, r3, i3) => {
            n3[r3] = e3(t4, r3, i3);
          }, ...t3), n3;
        }
        try(e3) {
          const { stack: t3 } = this, n3 = [...t3];
          try {
            return e3();
          } finally {
            t3.length = 0, t3.push(...n3);
          }
        }
        match(...e3) {
          let t3 = this.stack.length - 1, n3 = null, r3 = this.stack[t3--];
          for (const i3 of e3) {
            if (r3 === void 0)
              return false;
            let e4 = null;
            if (typeof n3 == "number" && (e4 = n3, n3 = this.stack[t3--], r3 = this.stack[t3--]), i3 && !i3(r3, n3, e4))
              return false;
            n3 = this.stack[t3--], r3 = this.stack[t3--];
          }
          return true;
        }
        findAncestor(e3) {
          let t3 = this.stack.length - 1, n3 = null, r3 = this.stack[t3--];
          for (; r3; ) {
            let i3 = null;
            if (typeof n3 == "number" && (i3 = n3, n3 = this.stack[t3--], r3 = this.stack[t3--]), n3 !== null && e3(r3, n3, i3))
              return r3;
            n3 = this.stack[t3--], r3 = this.stack[t3--];
          }
        }
      };
      const { utils: { stripTrailingHardline: ed2 } } = su2, { normalize: td2 } = Fp2;
      var nd2 = { printSubtree: function(e3, t3, n3, r3) {
        if (n3.printer.embed && n3.embeddedLanguageFormatting === "auto")
          return n3.printer.embed(e3, t3, (e4, t4, i3) => function(e5, t5, n4, r4, { stripTrailingHardline: i4 = false } = {}) {
            const u3 = td2(Object.assign(Object.assign(Object.assign({}, n4), t5), {}, { parentParser: n4.parser, originalText: e5 }), { passThrough: true }), o3 = Dp2.parse(e5, u3), { ast: s3 } = o3;
            e5 = o3.text;
            const a3 = s3.comments;
            delete s3.comments, Yf2.attach(a3, s3, e5, u3), u3[Symbol.for("comments")] = a3 || [], u3[Symbol.for("tokens")] = s3.tokens || [];
            const c3 = r4(s3, u3);
            if (Yf2.ensureAllCommentsPrinted(a3), i4)
              return typeof c3 == "string" ? c3.replace(/(?:\r?\n)*$/, "") : ed2(c3);
            return c3;
          }(e4, t4, n3, r3, i3), n3);
      } };
      const { builders: { hardline: rd2, addAlignmentToDoc: id2 }, utils: { propagateBreaks: ud2 } } = su2, { printComments: od2 } = Yf2;
      function sd2(e3, n3, r3 = 0) {
        const { printer: i3 } = n3;
        i3.preprocess && (e3 = i3.preprocess(e3, n3));
        const u3 = new Map(), o3 = new Zf2(e3);
        let s3 = a3();
        return r3 > 0 && (s3 = id2([rd2, s3], r3, n3.tabWidth)), ud2(s3), s3;
        function a3(e4, t3) {
          return e4 === void 0 || e4 === o3 ? c3(t3) : Array.isArray(e4) ? o3.call(() => c3(t3), ...e4) : o3.call(() => c3(t3), e4);
        }
        function c3(e4) {
          const r4 = o3.getValue(), i4 = r4 && typeof r4 == "object" && e4 === void 0;
          if (i4 && u3.has(r4))
            return u3.get(r4);
          const s4 = function(e5, n4, r5, i5) {
            const u4 = e5.getValue(), { printer: o4 } = n4;
            let s5, a4;
            if (o4.hasPrettierIgnore && o4.hasPrettierIgnore(e5))
              ({ doc: s5, printedComments: a4 } = function(e6, t3) {
                const { originalText: n5, [Symbol.for("comments")]: r6, locStart: i6, locEnd: u5 } = t3, o5 = i6(e6), s6 = u5(e6), a5 = new Set();
                for (const e7 of r6)
                  i6(e7) >= o5 && u5(e7) <= s6 && (e7.printed = true, a5.add(e7));
                return { doc: n5.slice(o5, s6), printedComments: a5 };
              }(u4, n4));
            else {
              if (u4)
                try {
                  s5 = nd2.printSubtree(e5, r5, n4, sd2);
                } catch (e6) {
                  if (t2.PRETTIER_DEBUG)
                    throw e6;
                }
              s5 || (s5 = o4.print(e5, n4, r5, i5));
            }
            o4.willPrintOwnComments && o4.willPrintOwnComments(e5, n4) || (s5 = od2(e5, s5, n4, a4));
            return s5;
          }(o3, n3, a3, e4);
          return i4 && u3.set(r4, s4), s4;
        }
      }
      var ad2 = sd2;
      function cd2(e3) {
        let t3 = e3.length - 1;
        for (; ; ) {
          const n3 = e3[t3];
          if (!n3 || n3.type !== "Program" && n3.type !== "File")
            break;
          t3--;
        }
        return e3.slice(0, t3 + 1);
      }
      function ld2(e3, t3, n3, r3, i3 = [], u3) {
        const { locStart: o3, locEnd: s3 } = n3, a3 = o3(e3), c3 = s3(e3);
        if (!(t3 > c3 || t3 < a3 || u3 === "rangeEnd" && t3 === a3 || u3 === "rangeStart" && t3 === c3)) {
          for (const o4 of Yf2.getSortedChildNodes(e3, n3)) {
            const s4 = ld2(o4, t3, n3, r3, [e3, ...i3], u3);
            if (s4)
              return s4;
          }
          return !r3 || r3(e3, i3[0]) ? { node: e3, parentNodes: i3 } : void 0;
        }
      }
      const pd2 = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), fd2 = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
      function dd2(e3, t3, n3) {
        if (!t3)
          return false;
        switch (e3.parser) {
          case "flow":
          case "babel":
          case "babel-flow":
          case "babel-ts":
          case "typescript":
          case "espree":
          case "meriyah":
          case "__babel_estree":
            return function(e4, t4) {
              return t4 !== "DeclareExportDeclaration" && e4 !== "TypeParameterDeclaration" && (e4 === "Directive" || e4 === "TypeAlias" || e4 === "TSExportAssignment" || e4.startsWith("Declare") || e4.startsWith("TSDeclare") || e4.endsWith("Statement") || e4.endsWith("Declaration"));
            }(t3.type, n3 && n3.type);
          case "json":
          case "json5":
          case "json-stringify":
            return pd2.has(t3.type);
          case "graphql":
            return fd2.has(t3.kind);
          case "vue":
            return t3.tag !== "root";
        }
        return false;
      }
      var hd2 = { calculateRange: function(e3, t3, n3) {
        let { rangeStart: r3, rangeEnd: i3, locStart: u3, locEnd: o3 } = t3;
        Ff2.ok(i3 > r3);
        const s3 = e3.slice(r3, i3).search(/\S/), a3 = s3 === -1;
        if (!a3)
          for (r3 += s3; i3 > r3 && !/\S/.test(e3[i3 - 1]); --i3)
            ;
        const c3 = ld2(n3, r3, t3, (e4, n4) => dd2(t3, e4, n4), [], "rangeStart"), l3 = a3 ? c3 : ld2(n3, i3, t3, (e4) => dd2(t3, e4), [], "rangeEnd");
        if (!c3 || !l3)
          return { rangeStart: 0, rangeEnd: 0 };
        let p3, f3;
        if ((({ parser: e4 }) => e4 === "json" || e4 === "json5" || e4 === "json-stringify")(t3)) {
          const e4 = function(e5, t4) {
            const n4 = [e5.node, ...e5.parentNodes], r4 = new Set([t4.node, ...t4.parentNodes]);
            return n4.find((e6) => pd2.has(e6.type) && r4.has(e6));
          }(c3, l3);
          p3 = e4, f3 = e4;
        } else
          ({ startNode: p3, endNode: f3 } = function(e4, t4, { locStart: n4, locEnd: r4 }) {
            let i4 = e4.node, u4 = t4.node;
            if (i4 === u4)
              return { startNode: i4, endNode: u4 };
            const o4 = n4(e4.node);
            for (const e5 of cd2(t4.parentNodes)) {
              if (!(n4(e5) >= o4))
                break;
              u4 = e5;
            }
            const s4 = r4(t4.node);
            for (const t5 of cd2(e4.parentNodes)) {
              if (!(r4(t5) <= s4))
                break;
              i4 = t5;
            }
            return { startNode: i4, endNode: u4 };
          }(c3, l3, t3));
        return { rangeStart: Math.min(u3(p3), u3(f3)), rangeEnd: Math.max(o3(p3), o3(f3)) };
      }, findNodeAtOffset: ld2 };
      const { printer: { printDocToString: gd2 }, debug: { printDocToDebug: md2 } } = su2, { getAlignmentSize: yd2 } = Fi2, { guessEndOfLine: Dd2, convertEndOfLineToChars: Ed2, countEndOfLineChars: Cd2, normalizeEndOfLine: bd2 } = xi2, Ad2 = Fp2.normalize, vd2 = Symbol("cursor");
      function Fd2(e3, t3, n3) {
        const r3 = t3.comments;
        return r3 && (delete t3.comments, Yf2.attach(r3, t3, e3, n3)), n3[Symbol.for("comments")] = r3 || [], n3[Symbol.for("tokens")] = t3.tokens || [], n3.originalText = e3, r3;
      }
      function xd2(e3, t3, n3 = 0) {
        if (!e3 || e3.trim().length === 0)
          return { formatted: "", cursorOffset: -1, comments: [] };
        const { ast: r3, text: i3 } = Dp2.parse(e3, t3);
        if (t3.cursorOffset >= 0) {
          const e4 = hd2.findNodeAtOffset(r3, t3.cursorOffset, t3);
          e4 && e4.node && (t3.cursorNode = e4.node);
        }
        const u3 = Fd2(i3, r3, t3), o3 = ad2(r3, t3, n3), s3 = gd2(o3, t3);
        if (Yf2.ensureAllCommentsPrinted(u3), n3 > 0) {
          const e4 = s3.formatted.trim();
          s3.cursorNodeStart !== void 0 && (s3.cursorNodeStart -= s3.formatted.indexOf(e4)), s3.formatted = e4 + Ed2(t3.endOfLine);
        }
        if (t3.cursorOffset >= 0) {
          let e4, n4, r4, o4, a3;
          if (t3.cursorNode && s3.cursorNodeText ? (e4 = t3.locStart(t3.cursorNode), n4 = i3.slice(e4, t3.locEnd(t3.cursorNode)), r4 = t3.cursorOffset - e4, o4 = s3.cursorNodeStart, a3 = s3.cursorNodeText) : (e4 = 0, n4 = i3, r4 = t3.cursorOffset, o4 = 0, a3 = s3.formatted), n4 === a3)
            return { formatted: s3.formatted, cursorOffset: o4 + r4, comments: u3 };
          const c3 = [...n4];
          c3.splice(r4, 0, vd2);
          const l3 = [...a3], p3 = Dn2.diffArrays(c3, l3);
          let f3 = o4;
          for (const e5 of p3)
            if (e5.removed) {
              if (e5.value.includes(vd2))
                break;
            } else
              f3 += e5.count;
          return { formatted: s3.formatted, cursorOffset: f3, comments: u3 };
        }
        return { formatted: s3.formatted, cursorOffset: -1, comments: u3 };
      }
      function Sd2(e3, t3, n3) {
        return typeof t3 != "number" || Number.isNaN(t3) || t3 < 0 || t3 > e3.length ? n3 : t3;
      }
      function wd2(e3, t3) {
        let { cursorOffset: n3, rangeStart: r3, rangeEnd: i3 } = t3;
        return n3 = Sd2(e3, n3, -1), r3 = Sd2(e3, r3, 0), i3 = Sd2(e3, i3, e3.length), Object.assign(Object.assign({}, t3), {}, { cursorOffset: n3, rangeStart: r3, rangeEnd: i3 });
      }
      function Td2(e3, t3) {
        let { cursorOffset: n3, rangeStart: r3, rangeEnd: i3, endOfLine: u3 } = wd2(e3, t3);
        const o3 = e3.charAt(0) === "\uFEFF";
        if (o3 && (e3 = e3.slice(1), n3--, r3--, i3--), u3 === "auto" && (u3 = Dd2(e3)), e3.includes("\r")) {
          const t4 = (t5) => Cd2(e3.slice(0, Math.max(t5, 0)), "\r\n");
          n3 -= t4(n3), r3 -= t4(r3), i3 -= t4(i3), e3 = bd2(e3);
        }
        return { hasBOM: o3, text: e3, options: wd2(e3, Object.assign(Object.assign({}, t3), {}, { cursorOffset: n3, rangeStart: r3, rangeEnd: i3, endOfLine: u3 })) };
      }
      function Bd2(e3, t3) {
        const n3 = Dp2.resolveParser(t3);
        return !n3.hasPragma || n3.hasPragma(e3);
      }
      function Nd2(e3, t3) {
        let n3, { hasBOM: r3, text: i3, options: u3 } = Td2(e3, Ad2(t3));
        return u3.rangeStart >= u3.rangeEnd && i3 !== "" || u3.requirePragma && !Bd2(i3, u3) ? { formatted: e3, cursorOffset: t3.cursorOffset, comments: [] } : (u3.rangeStart > 0 || u3.rangeEnd < i3.length ? n3 = function(e4, t4) {
          const { ast: n4, text: r4 } = Dp2.parse(e4, t4), { rangeStart: i4, rangeEnd: u4 } = hd2.calculateRange(r4, t4, n4), o3 = r4.slice(i4, u4), s3 = Math.min(i4, r4.lastIndexOf("\n", i4) + 1), a3 = r4.slice(s3, i4).match(/^\s*/)[0], c3 = yd2(a3, t4.tabWidth), l3 = xd2(o3, Object.assign(Object.assign({}, t4), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t4.cursorOffset > i4 && t4.cursorOffset <= u4 ? t4.cursorOffset - i4 : -1, endOfLine: "lf" }), c3), p3 = l3.formatted.trimEnd();
          let { cursorOffset: f3 } = t4;
          f3 > u4 ? f3 += p3.length - o3.length : l3.cursorOffset >= 0 && (f3 = l3.cursorOffset + i4);
          let d3 = r4.slice(0, i4) + p3 + r4.slice(u4);
          if (t4.endOfLine !== "lf") {
            const e5 = Ed2(t4.endOfLine);
            f3 >= 0 && e5 === "\r\n" && (f3 += Cd2(d3.slice(0, f3), "\n")), d3 = d3.replace(/\n/g, e5);
          }
          return { formatted: d3, cursorOffset: f3, comments: l3.comments };
        }(i3, u3) : (!u3.requirePragma && u3.insertPragma && u3.printer.insertPragma && !Bd2(i3, u3) && (i3 = u3.printer.insertPragma(i3)), n3 = xd2(i3, u3)), r3 && (n3.formatted = "\uFEFF" + n3.formatted, n3.cursorOffset >= 0 && n3.cursorOffset++), n3);
      }
      var kd2 = { formatWithCursor: Nd2, parse(e3, t3, n3) {
        const { text: r3, options: i3 } = Td2(e3, Ad2(t3)), u3 = Dp2.parse(r3, i3);
        return n3 && (u3.ast = xp2(u3.ast, i3)), u3;
      }, formatAST(e3, t3) {
        t3 = Ad2(t3);
        const n3 = ad2(e3, t3);
        return gd2(n3, t3);
      }, formatDoc: (e3, t3) => Nd2(md2(e3), Object.assign(Object.assign({}, t3), {}, { parser: "__js_expression" })).formatted, printToDoc(e3, t3) {
        t3 = Ad2(t3);
        const { ast: n3, text: r3 } = Dp2.parse(e3, t3);
        return Fd2(r3, n3, t3), ad2(n3, t3);
      }, printDocToString: (e3, t3) => gd2(e3, Ad2(t3)) };
      const { getMaxContinuousCount: Pd2, getStringWidth: Od2, getAlignmentSize: Id2, getIndentSize: Ld2, skip: jd2, skipWhitespace: _d2, skipSpaces: Md2, skipNewline: Rd2, skipToLineEnd: $d2, skipEverythingButNewLine: Vd2, skipInlineComment: Wd2, skipTrailingComment: qd2, hasNewline: Ud2, hasNewlineInRange: zd2, hasSpaces: Gd2, isNextLineEmpty: Hd2, isNextLineEmptyAfterIndex: Jd2, isPreviousLineEmpty: Xd2, getNextNonSpaceNonCommentCharacterIndex: Yd2, makeString: Kd2, addLeadingComment: Qd2, addDanglingComment: Zd2, addTrailingComment: eh2 } = Fi2;
      var th2 = { getMaxContinuousCount: Pd2, getStringWidth: Od2, getAlignmentSize: Id2, getIndentSize: Ld2, skip: jd2, skipWhitespace: _d2, skipSpaces: Md2, skipNewline: Rd2, skipToLineEnd: $d2, skipEverythingButNewLine: Vd2, skipInlineComment: Wd2, skipTrailingComment: qd2, hasNewline: Ud2, hasNewlineInRange: zd2, hasSpaces: Gd2, isNextLineEmpty: Hd2, isNextLineEmptyAfterIndex: Jd2, isPreviousLineEmpty: Xd2, getNextNonSpaceNonCommentCharacterIndex: Yd2, makeString: Kd2, addLeadingComment: Qd2, addDanglingComment: Zd2, addTrailingComment: eh2 };
      const nh2 = ["languageId"];
      var rh2 = function(e3, t3) {
        const { languageId: n3 } = e3, r3 = Mn2(e3, nh2);
        return Object.assign(Object.assign({ linguistLanguageId: n3 }, r3), t3(e3));
      }, ih2 = r2(function(e3) {
        !function() {
          function t3(e4) {
            if (e4 == null)
              return false;
            switch (e4.type) {
              case "BlockStatement":
              case "BreakStatement":
              case "ContinueStatement":
              case "DebuggerStatement":
              case "DoWhileStatement":
              case "EmptyStatement":
              case "ExpressionStatement":
              case "ForInStatement":
              case "ForStatement":
              case "IfStatement":
              case "LabeledStatement":
              case "ReturnStatement":
              case "SwitchStatement":
              case "ThrowStatement":
              case "TryStatement":
              case "VariableDeclaration":
              case "WhileStatement":
              case "WithStatement":
                return true;
            }
            return false;
          }
          function n3(e4) {
            switch (e4.type) {
              case "IfStatement":
                return e4.alternate != null ? e4.alternate : e4.consequent;
              case "LabeledStatement":
              case "ForStatement":
              case "ForInStatement":
              case "WhileStatement":
              case "WithStatement":
                return e4.body;
            }
            return null;
          }
          e3.exports = { isExpression: function(e4) {
            if (e4 == null)
              return false;
            switch (e4.type) {
              case "ArrayExpression":
              case "AssignmentExpression":
              case "BinaryExpression":
              case "CallExpression":
              case "ConditionalExpression":
              case "FunctionExpression":
              case "Identifier":
              case "Literal":
              case "LogicalExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ObjectExpression":
              case "SequenceExpression":
              case "ThisExpression":
              case "UnaryExpression":
              case "UpdateExpression":
                return true;
            }
            return false;
          }, isStatement: t3, isIterationStatement: function(e4) {
            if (e4 == null)
              return false;
            switch (e4.type) {
              case "DoWhileStatement":
              case "ForInStatement":
              case "ForStatement":
              case "WhileStatement":
                return true;
            }
            return false;
          }, isSourceElement: function(e4) {
            return t3(e4) || e4 != null && e4.type === "FunctionDeclaration";
          }, isProblematicIfStatement: function(e4) {
            var t4;
            if (e4.type !== "IfStatement")
              return false;
            if (e4.alternate == null)
              return false;
            t4 = e4.consequent;
            do {
              if (t4.type === "IfStatement" && t4.alternate == null)
                return true;
              t4 = n3(t4);
            } while (t4);
            return false;
          }, trailingStatement: n3 };
        }();
      }), uh2 = r2(function(e3) {
        !function() {
          var t3, n3, r3, i3, u3, o3;
          function s3(e4) {
            return e4 <= 65535 ? String.fromCharCode(e4) : String.fromCharCode(Math.floor((e4 - 65536) / 1024) + 55296) + String.fromCharCode((e4 - 65536) % 1024 + 56320);
          }
          for (n3 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t3 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, r3 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i3 = new Array(128), o3 = 0; o3 < 128; ++o3)
            i3[o3] = o3 >= 97 && o3 <= 122 || o3 >= 65 && o3 <= 90 || o3 === 36 || o3 === 95;
          for (u3 = new Array(128), o3 = 0; o3 < 128; ++o3)
            u3[o3] = o3 >= 97 && o3 <= 122 || o3 >= 65 && o3 <= 90 || o3 >= 48 && o3 <= 57 || o3 === 36 || o3 === 95;
          e3.exports = { isDecimalDigit: function(e4) {
            return 48 <= e4 && e4 <= 57;
          }, isHexDigit: function(e4) {
            return 48 <= e4 && e4 <= 57 || 97 <= e4 && e4 <= 102 || 65 <= e4 && e4 <= 70;
          }, isOctalDigit: function(e4) {
            return e4 >= 48 && e4 <= 55;
          }, isWhiteSpace: function(e4) {
            return e4 === 32 || e4 === 9 || e4 === 11 || e4 === 12 || e4 === 160 || e4 >= 5760 && r3.indexOf(e4) >= 0;
          }, isLineTerminator: function(e4) {
            return e4 === 10 || e4 === 13 || e4 === 8232 || e4 === 8233;
          }, isIdentifierStartES5: function(e4) {
            return e4 < 128 ? i3[e4] : n3.NonAsciiIdentifierStart.test(s3(e4));
          }, isIdentifierPartES5: function(e4) {
            return e4 < 128 ? u3[e4] : n3.NonAsciiIdentifierPart.test(s3(e4));
          }, isIdentifierStartES6: function(e4) {
            return e4 < 128 ? i3[e4] : t3.NonAsciiIdentifierStart.test(s3(e4));
          }, isIdentifierPartES6: function(e4) {
            return e4 < 128 ? u3[e4] : t3.NonAsciiIdentifierPart.test(s3(e4));
          } };
        }();
      }), oh2 = r2(function(e3) {
        !function() {
          var t3 = uh2;
          function n3(e4, t4) {
            return !(!t4 && e4 === "yield") && r3(e4, t4);
          }
          function r3(e4, t4) {
            if (t4 && function(e5) {
              switch (e5) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }(e4))
              return true;
            switch (e4.length) {
              case 2:
                return e4 === "if" || e4 === "in" || e4 === "do";
              case 3:
                return e4 === "var" || e4 === "for" || e4 === "new" || e4 === "try";
              case 4:
                return e4 === "this" || e4 === "else" || e4 === "case" || e4 === "void" || e4 === "with" || e4 === "enum";
              case 5:
                return e4 === "while" || e4 === "break" || e4 === "catch" || e4 === "throw" || e4 === "const" || e4 === "yield" || e4 === "class" || e4 === "super";
              case 6:
                return e4 === "return" || e4 === "typeof" || e4 === "delete" || e4 === "switch" || e4 === "export" || e4 === "import";
              case 7:
                return e4 === "default" || e4 === "finally" || e4 === "extends";
              case 8:
                return e4 === "function" || e4 === "continue" || e4 === "debugger";
              case 10:
                return e4 === "instanceof";
              default:
                return false;
            }
          }
          function i3(e4, t4) {
            return e4 === "null" || e4 === "true" || e4 === "false" || n3(e4, t4);
          }
          function u3(e4, t4) {
            return e4 === "null" || e4 === "true" || e4 === "false" || r3(e4, t4);
          }
          function o3(e4) {
            var n4, r4, i4;
            if (e4.length === 0)
              return false;
            if (i4 = e4.charCodeAt(0), !t3.isIdentifierStartES5(i4))
              return false;
            for (n4 = 1, r4 = e4.length; n4 < r4; ++n4)
              if (i4 = e4.charCodeAt(n4), !t3.isIdentifierPartES5(i4))
                return false;
            return true;
          }
          function s3(e4) {
            var n4, r4, i4, u4, o4;
            if (e4.length === 0)
              return false;
            for (o4 = t3.isIdentifierStartES6, n4 = 0, r4 = e4.length; n4 < r4; ++n4) {
              if (55296 <= (i4 = e4.charCodeAt(n4)) && i4 <= 56319) {
                if (++n4 >= r4)
                  return false;
                if (!(56320 <= (u4 = e4.charCodeAt(n4)) && u4 <= 57343))
                  return false;
                i4 = 1024 * (i4 - 55296) + (u4 - 56320) + 65536;
              }
              if (!o4(i4))
                return false;
              o4 = t3.isIdentifierPartES6;
            }
            return true;
          }
          e3.exports = { isKeywordES5: n3, isKeywordES6: r3, isReservedWordES5: i3, isReservedWordES6: u3, isRestrictedWord: function(e4) {
            return e4 === "eval" || e4 === "arguments";
          }, isIdentifierNameES5: o3, isIdentifierNameES6: s3, isIdentifierES5: function(e4, t4) {
            return o3(e4) && !i3(e4, t4);
          }, isIdentifierES6: function(e4, t4) {
            return s3(e4) && !u3(e4, t4);
          } };
        }();
      });
      const sh2 = r2(function(e3, t3) {
        t3.ast = ih2, t3.code = uh2, t3.keyword = oh2;
      }).keyword.isIdentifierNameES5, { getLast: ah2, hasNewline: ch2, skipWhitespace: lh2, isNonEmptyArray: ph2, isNextLineEmptyAfterIndex: fh2, getStringWidth: dh2 } = Fi2, { locStart: hh2, locEnd: gh2, hasSameLocStart: mh2 } = Zc2, yh2 = new RegExp("^(?:(?=.)\\s)*:"), Dh2 = new RegExp("^(?:(?=.)\\s)*::");
      function Eh2(e3) {
        return e3.type === "Block" || e3.type === "CommentBlock" || e3.type === "MultiLine";
      }
      function Ch2(e3) {
        return e3.type === "Line" || e3.type === "CommentLine" || e3.type === "SingleLine" || e3.type === "HashbangComment" || e3.type === "HTMLOpen" || e3.type === "HTMLClose";
      }
      const bh2 = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
      function Ah2(e3) {
        return e3 && bh2.has(e3.type);
      }
      function vh2(e3) {
        return e3.type === "NumericLiteral" || e3.type === "Literal" && typeof e3.value == "number";
      }
      function Fh2(e3) {
        return e3.type === "StringLiteral" || e3.type === "Literal" && typeof e3.value == "string";
      }
      function xh2(e3) {
        return e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression";
      }
      function Sh2(e3) {
        return Oh2(e3) && e3.callee.type === "Identifier" && (e3.callee.name === "async" || e3.callee.name === "inject" || e3.callee.name === "fakeAsync");
      }
      function wh2(e3) {
        return e3.type === "JSXElement" || e3.type === "JSXFragment";
      }
      function Th2(e3) {
        return e3.kind === "get" || e3.kind === "set";
      }
      function Bh2(e3) {
        return Th2(e3) || mh2(e3, e3.value);
      }
      const Nh2 = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
      const kh2 = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
      const Ph2 = /^(?:skip|[fx]?(?:it|describe|test))$/;
      function Oh2(e3) {
        return e3 && (e3.type === "CallExpression" || e3.type === "OptionalCallExpression");
      }
      function Ih2(e3) {
        return e3 && (e3.type === "MemberExpression" || e3.type === "OptionalMemberExpression");
      }
      function Lh2(e3) {
        return /^(?:\d+|\d+\.\d+)$/.test(e3);
      }
      function jh2(e3) {
        return e3.quasis.some((e4) => e4.value.raw.includes("\n"));
      }
      function _h2(e3) {
        return e3.extra ? e3.extra.raw : e3.raw;
      }
      const Mh2 = { "==": true, "!=": true, "===": true, "!==": true }, Rh2 = { "*": true, "/": true, "%": true }, $h2 = { ">>": true, ">>>": true, "<<": true };
      const Vh2 = {};
      for (const [e3, t3] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
        for (const n3 of t3)
          Vh2[n3] = e3;
      function Wh2(e3) {
        return Vh2[e3];
      }
      const qh2 = new WeakMap();
      function Uh2(e3) {
        if (qh2.has(e3))
          return qh2.get(e3);
        const t3 = [];
        return e3.this && t3.push(e3.this), Array.isArray(e3.parameters) ? t3.push(...e3.parameters) : Array.isArray(e3.params) && t3.push(...e3.params), e3.rest && t3.push(e3.rest), qh2.set(e3, t3), t3;
      }
      const zh2 = new WeakMap();
      function Gh2(e3) {
        if (zh2.has(e3))
          return zh2.get(e3);
        let t3 = e3.arguments;
        return e3.type === "ImportExpression" && (t3 = [e3.source], e3.attributes && t3.push(e3.attributes)), zh2.set(e3, t3), t3;
      }
      function Hh2(e3) {
        return e3.value.trim() === "prettier-ignore" && !e3.unignore;
      }
      function Jh2(e3) {
        return e3 && (e3.prettierIgnore || Kh2(e3, Xh2.PrettierIgnore));
      }
      const Xh2 = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Yh2 = (e3, t3) => {
        if (typeof e3 == "function" && (t3 = e3, e3 = 0), e3 || t3)
          return (n3, r3, i3) => !(e3 & Xh2.Leading && !n3.leading || e3 & Xh2.Trailing && !n3.trailing || e3 & Xh2.Dangling && (n3.leading || n3.trailing) || e3 & Xh2.Block && !Eh2(n3) || e3 & Xh2.Line && !Ch2(n3) || e3 & Xh2.First && r3 !== 0 || e3 & Xh2.Last && r3 !== i3.length - 1 || e3 & Xh2.PrettierIgnore && !Hh2(n3) || t3 && !t3(n3));
      };
      function Kh2(e3, t3, n3) {
        if (!e3 || !ph2(e3.comments))
          return false;
        const r3 = Yh2(t3, n3);
        return !r3 || e3.comments.some(r3);
      }
      function Qh2(e3, t3, n3) {
        if (!e3 || !Array.isArray(e3.comments))
          return [];
        const r3 = Yh2(t3, n3);
        return r3 ? e3.comments.filter(r3) : e3.comments;
      }
      function Zh2(e3) {
        return Oh2(e3) || e3.type === "NewExpression" || e3.type === "ImportExpression";
      }
      var eg2 = { getFunctionParameters: Uh2, iterateFunctionParametersPath: function(e3, t3) {
        const n3 = e3.getValue();
        let r3 = 0;
        const i3 = (e4) => t3(e4, r3++);
        n3.this && e3.call(i3, "this"), Array.isArray(n3.parameters) ? e3.each(i3, "parameters") : Array.isArray(n3.params) && e3.each(i3, "params"), n3.rest && e3.call(i3, "rest");
      }, getCallArguments: Gh2, iterateCallArgumentsPath: function(e3, t3) {
        const n3 = e3.getValue();
        n3.type === "ImportExpression" ? (e3.call((e4) => t3(e4, 0), "source"), n3.attributes && e3.call((e4) => t3(e4, 1), "attributes")) : e3.each(t3, "arguments");
      }, hasRestParameter: function(e3) {
        if (e3.rest)
          return true;
        const t3 = Uh2(e3);
        return t3.length > 0 && ah2(t3).type === "RestElement";
      }, getLeftSide: function(e3) {
        return e3.expressions ? e3.expressions[0] : e3.left || e3.test || e3.callee || e3.object || e3.tag || e3.argument || e3.expression;
      }, getLeftSidePathName: function(e3, t3) {
        if (t3.expressions)
          return ["expressions", 0];
        if (t3.left)
          return ["left"];
        if (t3.test)
          return ["test"];
        if (t3.object)
          return ["object"];
        if (t3.callee)
          return ["callee"];
        if (t3.tag)
          return ["tag"];
        if (t3.argument)
          return ["argument"];
        if (t3.expression)
          return ["expression"];
        throw new Error("Unexpected node has no left side.");
      }, getParentExportDeclaration: function(e3) {
        const t3 = e3.getParentNode();
        return e3.getName() === "declaration" && Ah2(t3) ? t3 : null;
      }, getTypeScriptMappedTypeModifier: function(e3, t3) {
        return e3 === "+" ? "+" + t3 : e3 === "-" ? "-" + t3 : t3;
      }, hasFlowAnnotationComment: function(e3) {
        return ph2(e3) && Eh2(e3[0]) && Dh2.test(e3[0].value);
      }, hasFlowShorthandAnnotationComment: function(e3) {
        return e3.extra && e3.extra.parenthesized && ph2(e3.trailingComments) && Eh2(e3.trailingComments[0]) && yh2.test(e3.trailingComments[0].value);
      }, hasLeadingOwnLineComment: function(e3, t3) {
        return wh2(t3) ? Jh2(t3) : Kh2(t3, Xh2.Leading, (t4) => ch2(e3, gh2(t4)));
      }, hasNakedLeftSide: function(e3) {
        return e3.type === "AssignmentExpression" || e3.type === "BinaryExpression" || e3.type === "LogicalExpression" || e3.type === "NGPipeExpression" || e3.type === "ConditionalExpression" || Oh2(e3) || Ih2(e3) || e3.type === "SequenceExpression" || e3.type === "TaggedTemplateExpression" || e3.type === "BindExpression" || e3.type === "UpdateExpression" && !e3.prefix || e3.type === "TSAsExpression" || e3.type === "TSNonNullExpression";
      }, hasNode: function e3(t3, n3) {
        if (!t3 || typeof t3 != "object")
          return false;
        if (Array.isArray(t3))
          return t3.some((t4) => e3(t4, n3));
        const r3 = n3(t3);
        return typeof r3 == "boolean" ? r3 : Object.values(t3).some((t4) => e3(t4, n3));
      }, hasIgnoreComment: function(e3) {
        return Jh2(e3.getValue());
      }, hasNodeIgnoreComment: Jh2, identity: function(e3) {
        return e3;
      }, isBinaryish: function(e3) {
        return Nh2.has(e3.type);
      }, isBlockComment: Eh2, isCallLikeExpression: Zh2, isLineComment: Ch2, isPrettierIgnoreComment: Hh2, isCallExpression: Oh2, isMemberExpression: Ih2, isExportDeclaration: Ah2, isFlowAnnotationComment: function(e3, t3) {
        const n3 = hh2(t3), r3 = lh2(e3, gh2(t3));
        return r3 !== false && e3.slice(n3, n3 + 2) === "/*" && e3.slice(r3, r3 + 2) === "*/";
      }, isFunctionCompositionArgs: function(e3) {
        if (e3.length <= 1)
          return false;
        let t3 = 0;
        for (const n3 of e3)
          if (xh2(n3)) {
            if (t3 += 1, t3 > 1)
              return true;
          } else if (Oh2(n3)) {
            for (const e4 of n3.arguments)
              if (xh2(e4))
                return true;
          }
        return false;
      }, isFunctionNotation: Bh2, isFunctionOrArrowExpression: xh2, isGetterOrSetter: Th2, isJestEachTemplateLiteral: function(e3, t3) {
        const n3 = /^[fx]?(?:describe|it|test)$/;
        return t3.type === "TaggedTemplateExpression" && t3.quasi === e3 && t3.tag.type === "MemberExpression" && t3.tag.property.type === "Identifier" && t3.tag.property.name === "each" && (t3.tag.object.type === "Identifier" && n3.test(t3.tag.object.name) || t3.tag.object.type === "MemberExpression" && t3.tag.object.property.type === "Identifier" && (t3.tag.object.property.name === "only" || t3.tag.object.property.name === "skip") && t3.tag.object.object.type === "Identifier" && n3.test(t3.tag.object.object.name));
      }, isJsxNode: wh2, isLiteral: function(e3) {
        return e3.type === "BooleanLiteral" || e3.type === "DirectiveLiteral" || e3.type === "Literal" || e3.type === "NullLiteral" || e3.type === "NumericLiteral" || e3.type === "BigIntLiteral" || e3.type === "DecimalLiteral" || e3.type === "RegExpLiteral" || e3.type === "StringLiteral" || e3.type === "TemplateLiteral" || e3.type === "TSTypeLiteral" || e3.type === "JSXText";
      }, isLongCurriedCallExpression: function(e3) {
        const t3 = e3.getValue(), n3 = e3.getParentNode();
        return Oh2(t3) && Oh2(n3) && n3.callee === t3 && t3.arguments.length > n3.arguments.length && n3.arguments.length > 0;
      }, isSimpleCallArgument: function e3(t3, n3) {
        if (n3 >= 2)
          return false;
        const r3 = (t4) => e3(t4, n3 + 1), i3 = t3.type === "Literal" && "regex" in t3 && t3.regex.pattern || t3.type === "RegExpLiteral" && t3.pattern;
        return !(i3 && dh2(i3) > 5) && (t3.type === "Literal" || t3.type === "BigIntLiteral" || t3.type === "DecimalLiteral" || t3.type === "BooleanLiteral" || t3.type === "NullLiteral" || t3.type === "NumericLiteral" || t3.type === "RegExpLiteral" || t3.type === "StringLiteral" || t3.type === "Identifier" || t3.type === "ThisExpression" || t3.type === "Super" || t3.type === "PrivateName" || t3.type === "PrivateIdentifier" || t3.type === "ArgumentPlaceholder" || t3.type === "Import" || (t3.type === "TemplateLiteral" ? t3.quasis.every((e4) => !e4.value.raw.includes("\n")) && t3.expressions.every(r3) : t3.type === "ObjectExpression" ? t3.properties.every((e4) => !e4.computed && (e4.shorthand || e4.value && r3(e4.value))) : t3.type === "ArrayExpression" ? t3.elements.every((e4) => e4 === null || r3(e4)) : Zh2(t3) ? (t3.type === "ImportExpression" || e3(t3.callee, n3)) && Gh2(t3).every(r3) : Ih2(t3) ? e3(t3.object, n3) && e3(t3.property, n3) : t3.type !== "UnaryExpression" || t3.operator !== "!" && t3.operator !== "-" ? t3.type === "TSNonNullExpression" && e3(t3.expression, n3) : e3(t3.argument, n3)));
      }, isMemberish: function(e3) {
        return Ih2(e3) || e3.type === "BindExpression" && Boolean(e3.object);
      }, isNumericLiteral: vh2, isSignedNumericLiteral: function(e3) {
        return e3.type === "UnaryExpression" && (e3.operator === "+" || e3.operator === "-") && vh2(e3.argument);
      }, isObjectProperty: function(e3) {
        return e3 && (e3.type === "ObjectProperty" || e3.type === "Property" && !e3.method && e3.kind === "init");
      }, isObjectType: function(e3) {
        return e3.type === "ObjectTypeAnnotation" || e3.type === "TSTypeLiteral" || e3.type === "TSMappedType";
      }, isObjectTypePropertyAFunction: function(e3) {
        return !(e3.type !== "ObjectTypeProperty" && e3.type !== "ObjectTypeInternalSlot" || e3.value.type !== "FunctionTypeAnnotation" || e3.static || Bh2(e3));
      }, isSimpleType: function(e3) {
        return !!e3 && (!(e3.type !== "GenericTypeAnnotation" && e3.type !== "TSTypeReference" || e3.typeParameters) || !!kh2.has(e3.type));
      }, isSimpleNumber: Lh2, isSimpleTemplateLiteral: function(e3) {
        let t3 = "expressions";
        e3.type === "TSTemplateLiteralType" && (t3 = "types");
        const n3 = e3[t3];
        return n3.length !== 0 && n3.every((e4) => {
          if (Kh2(e4))
            return false;
          if (e4.type === "Identifier" || e4.type === "ThisExpression")
            return true;
          if (Ih2(e4)) {
            let t4 = e4;
            for (; Ih2(t4); ) {
              if (t4.property.type !== "Identifier" && t4.property.type !== "Literal" && t4.property.type !== "StringLiteral" && t4.property.type !== "NumericLiteral")
                return false;
              if (t4 = t4.object, Kh2(t4))
                return false;
            }
            return t4.type === "Identifier" || t4.type === "ThisExpression";
          }
          return false;
        });
      }, isStringLiteral: Fh2, isStringPropSafeToUnquote: function(e3, t3) {
        return t3.parser !== "json" && Fh2(e3.key) && _h2(e3.key).slice(1, -1) === e3.key.value && (sh2(e3.key.value) && !((t3.parser === "typescript" || t3.parser === "babel-ts") && e3.type === "ClassProperty") || Lh2(e3.key.value) && String(Number(e3.key.value)) === e3.key.value && (t3.parser === "babel" || t3.parser === "espree" || t3.parser === "meriyah" || t3.parser === "__babel_estree"));
      }, isTemplateOnItsOwnLine: function(e3, t3) {
        return (e3.type === "TemplateLiteral" && jh2(e3) || e3.type === "TaggedTemplateExpression" && jh2(e3.quasi)) && !ch2(t3, hh2(e3), { backwards: true });
      }, isTestCall: function e3(t3, n3) {
        if (t3.type !== "CallExpression")
          return false;
        if (t3.arguments.length === 1) {
          if (Sh2(t3) && n3 && e3(n3))
            return xh2(t3.arguments[0]);
          if (function(e4) {
            return e4.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e4.callee.name) && e4.arguments.length === 1;
          }(t3))
            return Sh2(t3.arguments[0]);
        } else if ((t3.arguments.length === 2 || t3.arguments.length === 3) && (t3.callee.type === "Identifier" && Ph2.test(t3.callee.name) || function(e4) {
          return Ih2(e4.callee) && e4.callee.object.type === "Identifier" && e4.callee.property.type === "Identifier" && Ph2.test(e4.callee.object.name) && (e4.callee.property.name === "only" || e4.callee.property.name === "skip");
        }(t3)) && (function(e4) {
          return e4.type === "TemplateLiteral";
        }(t3.arguments[0]) || Fh2(t3.arguments[0])))
          return !(t3.arguments[2] && !vh2(t3.arguments[2])) && ((t3.arguments.length === 2 ? xh2(t3.arguments[1]) : function(e4) {
            return e4.type === "FunctionExpression" || e4.type === "ArrowFunctionExpression" && e4.body.type === "BlockStatement";
          }(t3.arguments[1]) && Uh2(t3.arguments[1]).length <= 1) || Sh2(t3.arguments[1]));
        return false;
      }, isTheOnlyJsxElementInMarkdown: function(e3, t3) {
        if (e3.parentParser !== "markdown" && e3.parentParser !== "mdx")
          return false;
        const n3 = t3.getNode();
        if (!n3.expression || !wh2(n3.expression))
          return false;
        const r3 = t3.getParentNode();
        return r3.type === "Program" && r3.body.length === 1;
      }, isTSXFile: function(e3) {
        return e3.filepath && /\.tsx$/i.test(e3.filepath);
      }, isTypeAnnotationAFunction: function(e3) {
        return !(e3.type !== "TypeAnnotation" && e3.type !== "TSTypeAnnotation" || e3.typeAnnotation.type !== "FunctionTypeAnnotation" || e3.static || mh2(e3, e3.typeAnnotation));
      }, isNextLineEmpty: (e3, { originalText: t3 }) => fh2(t3, gh2(e3)), needsHardlineAfterDanglingComment: function(e3) {
        if (!Kh2(e3))
          return false;
        const t3 = ah2(Qh2(e3, Xh2.Dangling));
        return t3 && !Eh2(t3);
      }, rawText: _h2, shouldPrintComma: function(e3, t3 = "es5") {
        return e3.trailingComma === "es5" && t3 === "es5" || e3.trailingComma === "all" && (t3 === "all" || t3 === "es5");
      }, isBitwiseOperator: function(e3) {
        return Boolean($h2[e3]) || e3 === "|" || e3 === "^" || e3 === "&";
      }, shouldFlatten: function(e3, t3) {
        return Wh2(t3) === Wh2(e3) && (e3 !== "**" && ((!Mh2[e3] || !Mh2[t3]) && (!(t3 === "%" && Rh2[e3] || e3 === "%" && Rh2[t3]) && ((t3 === e3 || !Rh2[t3] || !Rh2[e3]) && (!$h2[e3] || !$h2[t3])))));
      }, startsWithNoLookaheadToken: function e3(t3, n3) {
        switch ((t3 = function(e4) {
          for (; e4.left; )
            e4 = e4.left;
          return e4;
        }(t3)).type) {
          case "FunctionExpression":
          case "ClassExpression":
          case "DoExpression":
            return n3;
          case "ObjectExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return e3(t3.object, n3);
          case "TaggedTemplateExpression":
            return t3.tag.type !== "FunctionExpression" && e3(t3.tag, n3);
          case "CallExpression":
          case "OptionalCallExpression":
            return t3.callee.type !== "FunctionExpression" && e3(t3.callee, n3);
          case "ConditionalExpression":
            return e3(t3.test, n3);
          case "UpdateExpression":
            return !t3.prefix && e3(t3.argument, n3);
          case "BindExpression":
            return t3.object && e3(t3.object, n3);
          case "SequenceExpression":
            return e3(t3.expressions[0], n3);
          case "TSAsExpression":
          case "TSNonNullExpression":
            return e3(t3.expression, n3);
          default:
            return false;
        }
      }, getPrecedence: Wh2, hasComment: Kh2, getComments: Qh2, CommentCheckFlags: Xh2 };
      const { getStringWidth: tg2, getIndentSize: ng2 } = Fi2, { builders: { join: rg2, hardline: ig2, softline: ug2, group: og2, indent: sg2, align: ag2, lineSuffixBoundary: cg2, addAlignmentToDoc: lg2 }, printer: { printDocToString: pg2 }, utils: { mapDoc: fg2 } } = su2, { isBinaryish: dg2, isJestEachTemplateLiteral: hg2, isSimpleTemplateLiteral: gg2, hasComment: mg2, isMemberExpression: yg2 } = eg2;
      function Dg2(e3) {
        return e3.replace(/([\\`]|\${)/g, "\\$1");
      }
      var Eg2 = { printTemplateLiteral: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (r3.type === "TemplateLiteral" && hg2(r3, e3.getParentNode())) {
          const r4 = function(e4, t4, n4) {
            const r5 = e4.getNode(), i4 = r5.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (i4.length > 1 || i4.some((e5) => e5.length > 0)) {
              t4.__inJestEach = true;
              const u4 = e4.map(n4, "expressions");
              t4.__inJestEach = false;
              const o4 = [], s4 = u4.map((e5) => "${" + pg2(e5, Object.assign(Object.assign({}, t4), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), a3 = [{ hasLineBreak: false, cells: [] }];
              for (let e5 = 1; e5 < r5.quasis.length; e5++) {
                const t5 = _n2(a3), n5 = s4[e5 - 1];
                t5.cells.push(n5), n5.includes("\n") && (t5.hasLineBreak = true), r5.quasis[e5].value.raw.includes("\n") && a3.push({ hasLineBreak: false, cells: [] });
              }
              const c3 = Math.max(i4.length, ...a3.map((e5) => e5.cells.length)), l3 = Array.from({ length: c3 }).fill(0), p3 = [{ cells: i4 }, ...a3.filter((e5) => e5.cells.length > 0)];
              for (const { cells: e5 } of p3.filter((e6) => !e6.hasLineBreak))
                for (const [t5, n5] of e5.entries())
                  l3[t5] = Math.max(l3[t5], tg2(n5));
              return o4.push(cg2, "`", sg2([ig2, rg2(ig2, p3.map((e5) => rg2(" | ", e5.cells.map((t5, n5) => e5.hasLineBreak ? t5 : t5 + " ".repeat(l3[n5] - tg2(t5))))))]), ig2, "`"), o4;
            }
          }(e3, n3, t3);
          if (r4)
            return r4;
        }
        let i3 = "expressions";
        r3.type === "TSTemplateLiteralType" && (i3 = "types");
        const u3 = [];
        let o3 = e3.map(t3, i3);
        const s3 = gg2(r3);
        return s3 && (o3 = o3.map((e4) => pg2(e4, Object.assign(Object.assign({}, n3), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), u3.push(cg2, "`"), e3.each((e4) => {
          const a3 = e4.getName();
          if (u3.push(t3()), a3 < o3.length) {
            const { tabWidth: t4 } = n3, c3 = e4.getValue(), l3 = ng2(c3.value.raw, t4);
            let p3 = o3[a3];
            if (!s3) {
              const e5 = r3[i3][a3];
              (mg2(e5) || yg2(e5) || e5.type === "ConditionalExpression" || e5.type === "SequenceExpression" || e5.type === "TSAsExpression" || dg2(e5)) && (p3 = [sg2([ug2, p3]), ug2]);
            }
            const f3 = l3 === 0 && c3.value.raw.endsWith("\n") ? ag2(Number.NEGATIVE_INFINITY, p3) : lg2(p3, l3, t4);
            u3.push(og2(["${", f3, cg2, "}"]));
          }
        }, "quasis"), u3.push("`"), u3;
      }, printTemplateExpressions: function(e3, t3) {
        return e3.map((e4) => function(e5, t4) {
          const n3 = e5.getValue();
          let r3 = t4();
          return mg2(n3) && (r3 = og2([sg2([ug2, r3]), ug2])), ["${", r3, cg2, "}"];
        }(e4, t3), "expressions");
      }, escapeTemplateCharacters: function(e3, t3) {
        return fg2(e3, (e4) => typeof e4 == "string" ? t3 ? e4.replace(/(\\*)`/g, "$1$1\\`") : Dg2(e4) : e4);
      }, uncookTemplateElementValue: Dg2 };
      const { builders: { indent: Cg2, softline: bg2, literalline: Ag2, dedentToRoot: vg2 } } = su2, { escapeTemplateCharacters: Fg2 } = Eg2;
      var xg2 = function(e3, t3, n3) {
        let r3 = e3.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e4, t4) => "\\".repeat(t4.length / 2) + "`");
        const i3 = function(e4) {
          const t4 = e4.match(/^([^\S\n]*)\S/m);
          return t4 === null ? "" : t4[1];
        }(r3), u3 = i3 !== "";
        u3 && (r3 = r3.replace(new RegExp(`^${i3}`, "gm"), ""));
        const o3 = Fg2(n3(r3, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
        return ["`", u3 ? Cg2([bg2, o3]) : [Ag2, vg2(o3)], bg2, "`"];
      };
      const { isNonEmptyArray: Sg2 } = Fi2, { builders: { indent: wg2, hardline: Tg2, softline: Bg2 }, utils: { mapDoc: Ng2, replaceEndOfLine: kg2, cleanDoc: Pg2 } } = su2, { printTemplateExpressions: Og2 } = Eg2;
      var Ig2 = function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.quasis.map((e4) => e4.value.raw);
        let u3 = 0;
        return function(e4, t4, n4) {
          if (t4.quasis.length === 1 && !t4.quasis[0].value.raw.trim())
            return "``";
          const r4 = function(e5, t5) {
            if (!Sg2(t5))
              return e5;
            let n5 = 0;
            const r5 = Ng2(Pg2(e5), (e6) => typeof e6 == "string" && e6.includes("@prettier-placeholder") ? e6.split(/@prettier-placeholder-(\d+)-id/).map((e7, r6) => r6 % 2 == 0 ? kg2(e7) : (n5++, t5[e7])) : e6);
            return t5.length === n5 ? r5 : null;
          }(e4, n4);
          if (!r4)
            throw new Error("Couldn't insert all the expressions");
          return ["`", wg2([Tg2, r4]), Bg2, "`"];
        }(n3(i3.reduce((e4, t4, n4) => n4 === 0 ? t4 : e4 + "@prettier-placeholder-" + u3++ + "-id" + t4, ""), { parser: "scss" }, { stripTrailingHardline: true }), r3, Og2(e3, t3));
      };
      const { builders: { indent: Lg2, join: jg2, hardline: _g2 } } = su2, { escapeTemplateCharacters: Mg2, printTemplateExpressions: Rg2 } = Eg2;
      function $g2(e3) {
        const t3 = [];
        let n3 = false;
        const r3 = e3.map((e4) => e4.trim());
        for (const [e4, i3] of r3.entries())
          i3 !== "" && (r3[e4 - 1] === "" && n3 ? t3.push([_g2, i3]) : t3.push(i3), n3 = true);
        return t3.length === 0 ? null : jg2(_g2, t3);
      }
      var Vg2 = function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.quasis.length;
        if (i3 === 1 && r3.quasis[0].value.raw.trim() === "")
          return "``";
        const u3 = Rg2(e3, t3), o3 = [];
        for (let e4 = 0; e4 < i3; e4++) {
          const t4 = e4 === 0, s3 = e4 === i3 - 1, a3 = r3.quasis[e4].value.cooked, c3 = a3.split("\n"), l3 = c3.length, p3 = u3[e4], f3 = l3 > 2 && c3[0].trim() === "" && c3[1].trim() === "", d3 = l3 > 2 && c3[l3 - 1].trim() === "" && c3[l3 - 2].trim() === "", h3 = c3.every((e5) => /^\s*(?:#[^\n\r]*)?$/.test(e5));
          if (!s3 && /#[^\n\r]*$/.test(c3[l3 - 1]))
            return null;
          let g3 = null;
          g3 = h3 ? $g2(c3) : n3(a3, { parser: "graphql" }, { stripTrailingHardline: true }), g3 ? (g3 = Mg2(g3, false), !t4 && f3 && o3.push(""), o3.push(g3), !s3 && d3 && o3.push("")) : t4 || s3 || !f3 || o3.push(""), p3 && o3.push(p3);
        }
        return ["`", Lg2([_g2, jg2(_g2, o3)]), _g2, "`"];
      };
      const { builders: { indent: Wg2, line: qg2, hardline: Ug2, group: zg2 }, utils: { mapDoc: Gg2 } } = su2, { printTemplateExpressions: Hg2, uncookTemplateElementValue: Jg2 } = Eg2;
      let Xg2 = 0;
      var Yg2 = function(e3, t3, n3, r3, { parser: i3 }) {
        const u3 = e3.getValue(), o3 = Xg2;
        Xg2 = Xg2 + 1 >>> 0;
        const s3 = (e4) => `PRETTIER_HTML_PLACEHOLDER_${e4}_${o3}_IN_JS`, a3 = u3.quasis.map((e4, t4, n4) => t4 === n4.length - 1 ? e4.value.cooked : e4.value.cooked + s3(t4)).join(""), c3 = Hg2(e3, t3);
        if (c3.length === 0 && a3.trim().length === 0)
          return "``";
        const l3 = new RegExp(s3("(\\d+)"), "g");
        let p3 = 0;
        const f3 = n3(a3, { parser: i3, __onHtmlRoot(e4) {
          p3 = e4.children.length;
        } }, { stripTrailingHardline: true }), d3 = Gg2(f3, (e4) => {
          if (typeof e4 != "string")
            return e4;
          const t4 = [], n4 = e4.split(l3);
          for (let e5 = 0; e5 < n4.length; e5++) {
            let i4 = n4[e5];
            if (e5 % 2 == 0) {
              i4 && (i4 = Jg2(i4), r3.__embeddedInHtml && (i4 = i4.replace(/<\/(script)\b/gi, "<\\/$1")), t4.push(i4));
              continue;
            }
            const u4 = Number(i4);
            t4.push(c3[u4]);
          }
          return t4;
        }), h3 = /^\s/.test(a3) ? " " : "", g3 = /\s$/.test(a3) ? " " : "", m3 = r3.htmlWhitespaceSensitivity === "ignore" ? Ug2 : h3 && g3 ? qg2 : null;
        return zg2(m3 ? ["`", Wg2([m3, zg2(d3)]), m3, "`"] : ["`", h3, p3 > 1 ? Wg2(zg2(d3)) : zg2(d3), g3, "`"]);
      };
      const { hasComment: Kg2, CommentCheckFlags: Qg2, isObjectProperty: Zg2 } = eg2;
      function em2(e3) {
        return function(e4) {
          const t3 = e4.getValue(), n3 = e4.getParentNode(), r3 = e4.getParentNode(1);
          return r3 && t3.quasis && n3.type === "JSXExpressionContainer" && r3.type === "JSXElement" && r3.openingElement.name.name === "style" && r3.openingElement.attributes.some((e5) => e5.name.name === "jsx") || n3 && n3.type === "TaggedTemplateExpression" && n3.tag.type === "Identifier" && n3.tag.name === "css" || n3 && n3.type === "TaggedTemplateExpression" && n3.tag.type === "MemberExpression" && n3.tag.object.name === "css" && (n3.tag.property.name === "global" || n3.tag.property.name === "resolve");
        }(e3) || function(e4) {
          const t3 = e4.getParentNode();
          if (!t3 || t3.type !== "TaggedTemplateExpression")
            return false;
          const n3 = t3.tag.type === "ParenthesizedExpression" ? t3.tag.expression : t3.tag;
          switch (n3.type) {
            case "MemberExpression":
              return nm2(n3.object) || rm2(n3);
            case "CallExpression":
              return nm2(n3.callee) || n3.callee.type === "MemberExpression" && (n3.callee.object.type === "MemberExpression" && (nm2(n3.callee.object.object) || rm2(n3.callee.object)) || n3.callee.object.type === "CallExpression" && nm2(n3.callee.object.callee));
            case "Identifier":
              return n3.name === "css";
            default:
              return false;
          }
        }(e3) || function(e4) {
          const t3 = e4.getParentNode(), n3 = e4.getParentNode(1);
          return n3 && t3.type === "JSXExpressionContainer" && n3.type === "JSXAttribute" && n3.name.type === "JSXIdentifier" && n3.name.name === "css";
        }(e3) || function(e4) {
          return e4.match((e5) => e5.type === "TemplateLiteral", (e5, t3) => e5.type === "ArrayExpression" && t3 === "elements", (e5, t3) => Zg2(e5) && e5.key.type === "Identifier" && e5.key.name === "styles" && t3 === "value", ...tm2);
        }(e3) ? "css" : function(e4) {
          const t3 = e4.getValue(), n3 = e4.getParentNode();
          return im2(t3, "GraphQL") || n3 && (n3.type === "TaggedTemplateExpression" && (n3.tag.type === "MemberExpression" && n3.tag.object.name === "graphql" && n3.tag.property.name === "experimental" || n3.tag.type === "Identifier" && (n3.tag.name === "gql" || n3.tag.name === "graphql")) || n3.type === "CallExpression" && n3.callee.type === "Identifier" && n3.callee.name === "graphql");
        }(e3) ? "graphql" : function(e4) {
          return im2(e4.getValue(), "HTML") || e4.match((e5) => e5.type === "TemplateLiteral", (e5, t3) => e5.type === "TaggedTemplateExpression" && e5.tag.type === "Identifier" && e5.tag.name === "html" && t3 === "quasi");
        }(e3) ? "html" : function(e4) {
          return e4.match((e5) => e5.type === "TemplateLiteral", (e5, t3) => Zg2(e5) && e5.key.type === "Identifier" && e5.key.name === "template" && t3 === "value", ...tm2);
        }(e3) ? "angular" : function(e4) {
          const t3 = e4.getValue(), n3 = e4.getParentNode();
          return n3 && n3.type === "TaggedTemplateExpression" && t3.quasis.length === 1 && n3.tag.type === "Identifier" && (n3.tag.name === "md" || n3.tag.name === "markdown");
        }(e3) ? "markdown" : void 0;
      }
      const tm2 = [(e3, t3) => e3.type === "ObjectExpression" && t3 === "properties", (e3, t3) => e3.type === "CallExpression" && e3.callee.type === "Identifier" && e3.callee.name === "Component" && t3 === "arguments", (e3, t3) => e3.type === "Decorator" && t3 === "expression"];
      function nm2(e3) {
        return e3.type === "Identifier" && e3.name === "styled";
      }
      function rm2(e3) {
        return /^[A-Z]/.test(e3.object.name) && e3.property.name === "extend";
      }
      function im2(e3, t3) {
        return Kg2(e3, Qg2.Block | Qg2.Leading, ({ value: e4 }) => e4 === ` ${t3} `);
      }
      var um2 = function(e3, t3, n3, r3) {
        const i3 = e3.getValue();
        if (i3.type !== "TemplateLiteral" || function({ quasis: e4 }) {
          return e4.some(({ value: { cooked: e5 } }) => e5 === null);
        }(i3))
          return;
        const u3 = em2(e3);
        return u3 ? u3 === "markdown" ? xg2(e3, t3, n3) : u3 === "css" ? Ig2(e3, t3, n3) : u3 === "graphql" ? Vg2(e3, t3, n3) : u3 === "html" || u3 === "angular" ? Yg2(e3, t3, n3, r3, { parser: u3 }) : void 0 : void 0;
      };
      const { isBlockComment: om2 } = eg2, sm2 = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), am2 = (e3) => {
        for (const t3 of e3.quasis)
          delete t3.value;
      };
      function cm2(e3, t3, n3) {
        if (e3.type === "Program" && delete t3.sourceType, e3.type !== "BigIntLiteral" && e3.type !== "BigIntLiteralTypeAnnotation" || t3.value && (t3.value = t3.value.toLowerCase()), e3.type !== "BigIntLiteral" && e3.type !== "Literal" || t3.bigint && (t3.bigint = t3.bigint.toLowerCase()), e3.type === "DecimalLiteral" && (t3.value = Number(t3.value)), e3.type === "Literal" && t3.decimal && (t3.decimal = Number(t3.decimal)), e3.type === "EmptyStatement")
          return null;
        if (e3.type === "JSXText")
          return null;
        if (e3.type === "JSXExpressionContainer" && (e3.expression.type === "Literal" || e3.expression.type === "StringLiteral") && e3.expression.value === " ")
          return null;
        if (e3.type !== "Property" && e3.type !== "ObjectProperty" && e3.type !== "MethodDefinition" && e3.type !== "ClassProperty" && e3.type !== "ClassMethod" && e3.type !== "PropertyDefinition" && e3.type !== "TSDeclareMethod" && e3.type !== "TSPropertySignature" && e3.type !== "ObjectTypeProperty" || typeof e3.key != "object" || !e3.key || e3.key.type !== "Literal" && e3.key.type !== "NumericLiteral" && e3.key.type !== "StringLiteral" && e3.key.type !== "Identifier" || delete t3.key, e3.type === "JSXElement" && e3.openingElement.name.name === "style" && e3.openingElement.attributes.some((e4) => e4.name.name === "jsx"))
          for (const { type: e4, expression: n4 } of t3.children)
            e4 === "JSXExpressionContainer" && n4.type === "TemplateLiteral" && am2(n4);
        e3.type === "JSXAttribute" && e3.name.name === "css" && e3.value.type === "JSXExpressionContainer" && e3.value.expression.type === "TemplateLiteral" && am2(t3.value.expression), e3.type === "JSXAttribute" && e3.value && e3.value.type === "Literal" && /["']|&quot;|&apos;/.test(e3.value.value) && (t3.value.value = t3.value.value.replace(/["']|&quot;|&apos;/g, '"'));
        const r3 = e3.expression || e3.callee;
        if (e3.type === "Decorator" && r3.type === "CallExpression" && r3.callee.name === "Component" && r3.arguments.length === 1) {
          const n4 = e3.expression.arguments[0].properties;
          for (const [e4, r4] of t3.expression.arguments[0].properties.entries())
            switch (n4[e4].key.name) {
              case "styles":
                r4.value.type === "ArrayExpression" && am2(r4.value.elements[0]);
                break;
              case "template":
                r4.value.type === "TemplateLiteral" && am2(r4.value);
            }
        }
        if (e3.type !== "TaggedTemplateExpression" || e3.tag.type !== "MemberExpression" && (e3.tag.type !== "Identifier" || e3.tag.name !== "gql" && e3.tag.name !== "graphql" && e3.tag.name !== "css" && e3.tag.name !== "md" && e3.tag.name !== "markdown" && e3.tag.name !== "html") && e3.tag.type !== "CallExpression" || am2(t3.quasi), e3.type === "TemplateLiteral") {
          (e3.leadingComments && e3.leadingComments.some((e4) => om2(e4) && ["GraphQL", "HTML"].some((t4) => e4.value === ` ${t4} `)) || n3.type === "CallExpression" && n3.callee.name === "graphql" || !e3.leadingComments) && am2(t3);
        }
        return e3.type === "InterpreterDirective" && (t3.value = t3.value.trimEnd()), e3.type !== "TSIntersectionType" && e3.type !== "TSUnionType" || e3.types.length !== 1 ? void 0 : t3.types[0];
      }
      cm2.ignoredProperties = sm2;
      var lm2 = cm2;
      const pm2 = (e3) => {
        if (typeof e3 != "string")
          throw new TypeError("Expected a string");
        const t3 = e3.match(/(?:\r?\n)/g) || [];
        if (t3.length === 0)
          return;
        const n3 = t3.filter((e4) => e4 === "\r\n").length;
        return n3 > t3.length - n3 ? "\r\n" : "\n";
      };
      var fm2 = pm2;
      fm2.graceful = (e3) => typeof e3 == "string" && pm2(e3) || "\n";
      var dm2 = function(e3) {
        const t3 = e3.match(Am2);
        return t3 ? t3[0].trimLeft() : "";
      }, hm2 = function(e3) {
        const t3 = e3.match(Am2);
        return t3 && t3[0] ? e3.substring(t3[0].length) : e3;
      }, gm2 = function(e3) {
        return Bm2(e3).pragmas;
      }, mm2 = Bm2, ym2 = function({ comments: e3 = "", pragmas: t3 = {} }) {
        const n3 = (0, Em2().default)(e3) || Dm2().EOL, r3 = " *", i3 = Object.keys(t3), u3 = i3.map((e4) => Nm2(e4, t3[e4])).reduce((e4, t4) => e4.concat(t4), []).map((e4) => " * " + e4 + n3).join("");
        if (!e3) {
          if (i3.length === 0)
            return "";
          if (i3.length === 1 && !Array.isArray(t3[i3[0]])) {
            const e4 = t3[i3[0]];
            return `/** ${Nm2(i3[0], e4)[0]} */`;
          }
        }
        const o3 = e3.split(n3).map((e4) => ` * ${e4}`).join(n3) + n3;
        return "/**" + n3 + (e3 ? o3 : "") + (e3 && i3.length ? r3 + n3 : "") + u3 + " */";
      };
      function Dm2() {
        const e3 = fs2;
        return Dm2 = function() {
          return e3;
        }, e3;
      }
      function Em2() {
        const e3 = function(e4) {
          return e4 && e4.__esModule ? e4 : { default: e4 };
        }(fm2);
        return Em2 = function() {
          return e3;
        }, e3;
      }
      const Cm2 = /\*\/$/, bm2 = /^\/\*\*/, Am2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, vm2 = /(^|\s+)\/\/([^\r\n]*)/g, Fm2 = /^(\r?\n)+/, xm2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Sm2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, wm2 = /(\r?\n|^) *\* ?/g, Tm2 = [];
      function Bm2(e3) {
        const t3 = (0, Em2().default)(e3) || Dm2().EOL;
        e3 = e3.replace(bm2, "").replace(Cm2, "").replace(wm2, "$1");
        let n3 = "";
        for (; n3 !== e3; )
          n3 = e3, e3 = e3.replace(xm2, `${t3}$1 $2${t3}`);
        e3 = e3.replace(Fm2, "").trimRight();
        const r3 = Object.create(null), i3 = e3.replace(Sm2, "").replace(Fm2, "").trimRight();
        let u3;
        for (; u3 = Sm2.exec(e3); ) {
          const e4 = u3[2].replace(vm2, "");
          typeof r3[u3[1]] == "string" || Array.isArray(r3[u3[1]]) ? r3[u3[1]] = Tm2.concat(r3[u3[1]], e4) : r3[u3[1]] = e4;
        }
        return { comments: i3, pragmas: r3 };
      }
      function Nm2(e3, t3) {
        return Tm2.concat(t3).map((t4) => `@${e3} ${t4}`.trim());
      }
      var km2 = Object.defineProperty({ extract: dm2, strip: hm2, parse: gm2, parseWithComments: mm2, print: ym2 }, "__esModule", { value: true });
      const { parseWithComments: Pm2, strip: Om2, extract: Im2, print: Lm2 } = km2, { getShebang: jm2 } = Fi2, { normalizeEndOfLine: _m2 } = xi2;
      function Mm2(e3) {
        const t3 = jm2(e3);
        t3 && (e3 = e3.slice(t3.length + 1));
        const n3 = Im2(e3), { pragmas: r3, comments: i3 } = Pm2(n3);
        return { shebang: t3, text: e3, pragmas: r3, comments: i3 };
      }
      var Rm2 = { hasPragma: function(e3) {
        const t3 = Object.keys(Mm2(e3).pragmas);
        return t3.includes("prettier") || t3.includes("format");
      }, insertPragma: function(e3) {
        const { shebang: t3, text: n3, pragmas: r3, comments: i3 } = Mm2(e3), u3 = Om2(n3), o3 = Lm2({ pragmas: Object.assign({ format: "" }, r3), comments: i3.trimStart() });
        return (t3 ? `${t3}
` : "") + _m2(o3) + (u3.startsWith("\n") ? "\n" : "\n\n") + u3;
      } };
      const { getLast: $m2, hasNewline: Vm2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Wm2, getNextNonSpaceNonCommentCharacter: qm2, hasNewlineInRange: Um2, addLeadingComment: zm2, addTrailingComment: Gm2, addDanglingComment: Hm2, getNextNonSpaceNonCommentCharacterIndex: Jm2, isNonEmptyArray: Xm2 } = Fi2, { isBlockComment: Ym2, getFunctionParameters: Km2, isPrettierIgnoreComment: Qm2, isJsxNode: Zm2, hasFlowShorthandAnnotationComment: ey2, hasFlowAnnotationComment: ty2, hasIgnoreComment: ny2, isCallLikeExpression: ry2, getCallArguments: iy2, isCallExpression: uy2, isMemberExpression: oy2, isObjectProperty: sy2, getComments: ay2, CommentCheckFlags: cy2 } = eg2, { locStart: ly2, locEnd: py2 } = Zc2;
      function fy2(e3, t3) {
        const n3 = (e3.body || e3.properties).find(({ type: e4 }) => e4 !== "EmptyStatement");
        n3 ? zm2(n3, t3) : Hm2(e3, t3);
      }
      function dy2(e3, t3) {
        e3.type === "BlockStatement" ? fy2(e3, t3) : zm2(e3, t3);
      }
      function hy2({ comment: e3, followingNode: t3 }) {
        return !(!t3 || !qy2(e3)) && (zm2(t3, e3), true);
      }
      function gy2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3, text: i3 }) {
        if (!n3 || n3.type !== "IfStatement" || !r3)
          return false;
        return qm2(i3, e3, py2) === ")" ? (Gm2(t3, e3), true) : t3 === n3.consequent && r3 === n3.alternate ? (t3.type === "BlockStatement" ? Gm2(t3, e3) : Hm2(n3, e3), true) : r3.type === "BlockStatement" ? (fy2(r3, e3), true) : r3.type === "IfStatement" ? (dy2(r3.consequent, e3), true) : n3.consequent === r3 && (zm2(r3, e3), true);
      }
      function my2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3, text: i3 }) {
        if (!n3 || n3.type !== "WhileStatement" || !r3)
          return false;
        return qm2(i3, e3, py2) === ")" ? (Gm2(t3, e3), true) : r3.type === "BlockStatement" ? (fy2(r3, e3), true) : n3.body === r3 && (zm2(r3, e3), true);
      }
      function yy2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3 }) {
        return !(!n3 || n3.type !== "TryStatement" && n3.type !== "CatchClause" || !r3) && (n3.type === "CatchClause" && t3 ? (Gm2(t3, e3), true) : r3.type === "BlockStatement" ? (fy2(r3, e3), true) : r3.type === "TryStatement" ? (dy2(r3.finalizer, e3), true) : r3.type === "CatchClause" && (dy2(r3.body, e3), true));
      }
      function Dy2({ comment: e3, enclosingNode: t3, followingNode: n3 }) {
        return !(!oy2(t3) || !n3 || n3.type !== "Identifier") && (zm2(t3, e3), true);
      }
      function Ey2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3, text: i3 }) {
        const u3 = t3 && !Um2(i3, py2(t3), ly2(e3));
        return !(t3 && u3 || !n3 || n3.type !== "ConditionalExpression" && n3.type !== "TSConditionalType" || !r3) && (zm2(r3, e3), true);
      }
      function Cy2({ comment: e3, precedingNode: t3, enclosingNode: n3 }) {
        return !(!sy2(n3) || !n3.shorthand || n3.key !== t3 || n3.value.type !== "AssignmentPattern") && (Gm2(n3.value.left, e3), true);
      }
      function by2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3 }) {
        if (n3 && (n3.type === "ClassDeclaration" || n3.type === "ClassExpression" || n3.type === "DeclareClass" || n3.type === "DeclareInterface" || n3.type === "InterfaceDeclaration" || n3.type === "TSInterfaceDeclaration")) {
          if (Xm2(n3.decorators) && (!r3 || r3.type !== "Decorator"))
            return Gm2($m2(n3.decorators), e3), true;
          if (n3.body && r3 === n3.body)
            return fy2(n3.body, e3), true;
          if (r3) {
            for (const i3 of ["implements", "extends", "mixins"])
              if (n3[i3] && r3 === n3[i3][0])
                return !t3 || t3 !== n3.id && t3 !== n3.typeParameters && t3 !== n3.superClass ? Hm2(n3, e3, i3) : Gm2(t3, e3), true;
          }
        }
        return false;
      }
      function Ay2({ comment: e3, precedingNode: t3, enclosingNode: n3, text: r3 }) {
        return (n3 && t3 && (n3.type === "Property" || n3.type === "TSDeclareMethod" || n3.type === "TSAbstractMethodDefinition") && t3.type === "Identifier" && n3.key === t3 && qm2(r3, t3, py2) !== ":" || !(!t3 || !n3 || t3.type !== "Decorator" || n3.type !== "ClassMethod" && n3.type !== "ClassProperty" && n3.type !== "PropertyDefinition" && n3.type !== "TSAbstractClassProperty" && n3.type !== "TSAbstractMethodDefinition" && n3.type !== "TSDeclareMethod" && n3.type !== "MethodDefinition")) && (Gm2(t3, e3), true);
      }
      function vy2({ comment: e3, precedingNode: t3, enclosingNode: n3, text: r3 }) {
        return qm2(r3, e3, py2) === "(" && (!(!t3 || !n3 || n3.type !== "FunctionDeclaration" && n3.type !== "FunctionExpression" && n3.type !== "ClassMethod" && n3.type !== "MethodDefinition" && n3.type !== "ObjectMethod") && (Gm2(t3, e3), true));
      }
      function Fy2({ comment: e3, enclosingNode: t3, text: n3 }) {
        if (!t3 || t3.type !== "ArrowFunctionExpression")
          return false;
        const r3 = Jm2(n3, e3, py2);
        return r3 !== false && n3.slice(r3, r3 + 2) === "=>" && (Hm2(t3, e3), true);
      }
      function xy2({ comment: e3, enclosingNode: t3, text: n3 }) {
        return qm2(n3, e3, py2) === ")" && (t3 && (Wy2(t3) && Km2(t3).length === 0 || ry2(t3) && iy2(t3).length === 0) ? (Hm2(t3, e3), true) : !(!t3 || t3.type !== "MethodDefinition" && t3.type !== "TSAbstractMethodDefinition" || Km2(t3.value).length !== 0) && (Hm2(t3.value, e3), true));
      }
      function Sy2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3, text: i3 }) {
        if (t3 && t3.type === "FunctionTypeParam" && n3 && n3.type === "FunctionTypeAnnotation" && r3 && r3.type !== "FunctionTypeParam")
          return Gm2(t3, e3), true;
        if (t3 && (t3.type === "Identifier" || t3.type === "AssignmentPattern") && n3 && Wy2(n3) && qm2(i3, e3, py2) === ")")
          return Gm2(t3, e3), true;
        if (n3 && n3.type === "FunctionDeclaration" && r3 && r3.type === "BlockStatement") {
          const t4 = (() => {
            const e4 = Km2(n3);
            if (e4.length > 0)
              return Wm2(i3, py2($m2(e4)));
            const t5 = Wm2(i3, py2(n3.id));
            return t5 !== false && Wm2(i3, t5 + 1);
          })();
          if (ly2(e3) > t4)
            return fy2(r3, e3), true;
        }
        return false;
      }
      function wy2({ comment: e3, enclosingNode: t3 }) {
        return !(!t3 || t3.type !== "ImportSpecifier") && (zm2(t3, e3), true);
      }
      function Ty2({ comment: e3, enclosingNode: t3 }) {
        return !(!t3 || t3.type !== "LabeledStatement") && (zm2(t3, e3), true);
      }
      function By2({ comment: e3, enclosingNode: t3 }) {
        return !(!t3 || t3.type !== "ContinueStatement" && t3.type !== "BreakStatement" || t3.label) && (Gm2(t3, e3), true);
      }
      function Ny2({ comment: e3, precedingNode: t3, enclosingNode: n3 }) {
        return !!(uy2(n3) && t3 && n3.callee === t3 && n3.arguments.length > 0) && (zm2(n3.arguments[0], e3), true);
      }
      function ky2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3 }) {
        return !n3 || n3.type !== "UnionTypeAnnotation" && n3.type !== "TSUnionType" ? (r3 && (r3.type === "UnionTypeAnnotation" || r3.type === "TSUnionType") && Qm2(e3) && (r3.types[0].prettierIgnore = true, e3.unignore = true), false) : (Qm2(e3) && (r3.prettierIgnore = true, e3.unignore = true), !!t3 && (Gm2(t3, e3), true));
      }
      function Py2({ comment: e3, enclosingNode: t3 }) {
        return !!sy2(t3) && (zm2(t3, e3), true);
      }
      function Oy2({ comment: e3, enclosingNode: t3, followingNode: n3, ast: r3, isLastComment: i3 }) {
        return r3 && r3.body && r3.body.length === 0 ? (i3 ? Hm2(r3, e3) : zm2(r3, e3), true) : t3 && t3.type === "Program" && t3.body.length === 0 && !Xm2(t3.directives) ? (i3 ? Hm2(t3, e3) : zm2(t3, e3), true) : !(!n3 || n3.type !== "Program" || n3.body.length !== 0 || !t3 || t3.type !== "ModuleExpression") && (Hm2(n3, e3), true);
      }
      function Iy2({ comment: e3, enclosingNode: t3 }) {
        return !(!t3 || t3.type !== "ForInStatement" && t3.type !== "ForOfStatement") && (zm2(t3, e3), true);
      }
      function Ly2({ comment: e3, precedingNode: t3, enclosingNode: n3, text: r3 }) {
        return !!(t3 && t3.type === "ImportSpecifier" && n3 && n3.type === "ImportDeclaration" && Vm2(r3, py2(e3))) && (Gm2(t3, e3), true);
      }
      function jy2({ comment: e3, enclosingNode: t3 }) {
        return !(!t3 || t3.type !== "AssignmentPattern") && (zm2(t3, e3), true);
      }
      function _y2({ comment: e3, enclosingNode: t3 }) {
        return !(!t3 || t3.type !== "TypeAlias") && (zm2(t3, e3), true);
      }
      function My2({ comment: e3, enclosingNode: t3, followingNode: n3 }) {
        return !(!t3 || t3.type !== "VariableDeclarator" && t3.type !== "AssignmentExpression" || !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && n3.type !== "TemplateLiteral" && n3.type !== "TaggedTemplateExpression" && !Ym2(e3)) && (zm2(n3, e3), true);
      }
      function Ry2({ comment: e3, enclosingNode: t3, followingNode: n3, text: r3 }) {
        return !(n3 || !t3 || t3.type !== "TSMethodSignature" && t3.type !== "TSDeclareFunction" && t3.type !== "TSAbstractMethodDefinition" || qm2(r3, e3, py2) !== ";") && (Gm2(t3, e3), true);
      }
      function $y2({ comment: e3, enclosingNode: t3, followingNode: n3 }) {
        if (Qm2(e3) && t3 && t3.type === "TSMappedType" && n3 && n3.type === "TSTypeParameter" && n3.constraint)
          return t3.prettierIgnore = true, e3.unignore = true, true;
      }
      function Vy2({ comment: e3, precedingNode: t3, enclosingNode: n3, followingNode: r3 }) {
        return !(!n3 || n3.type !== "TSMappedType") && (r3 && r3.type === "TSTypeParameter" && r3.name ? (zm2(r3.name, e3), true) : !(!t3 || t3.type !== "TSTypeParameter" || !t3.constraint) && (Gm2(t3.constraint, e3), true));
      }
      function Wy2(e3) {
        return e3.type === "ArrowFunctionExpression" || e3.type === "FunctionExpression" || e3.type === "FunctionDeclaration" || e3.type === "ObjectMethod" || e3.type === "ClassMethod" || e3.type === "TSDeclareFunction" || e3.type === "TSCallSignatureDeclaration" || e3.type === "TSConstructSignatureDeclaration" || e3.type === "TSMethodSignature" || e3.type === "TSConstructorType" || e3.type === "TSFunctionType" || e3.type === "TSDeclareMethod";
      }
      function qy2(e3) {
        return Ym2(e3) && e3.value[0] === "*" && /@type\b/.test(e3.value);
      }
      var Uy2 = { handleOwnLineComment: function(e3) {
        return [$y2, Sy2, Dy2, gy2, my2, yy2, by2, wy2, Iy2, ky2, Oy2, Ly2, jy2, Ay2, Ty2].some((t3) => t3(e3));
      }, handleEndOfLineComment: function(e3) {
        return [hy2, Sy2, Ey2, wy2, gy2, my2, yy2, by2, Ty2, Ny2, Py2, Oy2, _y2, My2].some((t3) => t3(e3));
      }, handleRemainingComment: function(e3) {
        return [$y2, gy2, my2, Cy2, xy2, Ay2, Oy2, Fy2, vy2, Vy2, By2, Ry2].some((t3) => t3(e3));
      }, isTypeCastComment: qy2, getCommentChildNodes: function(e3, t3) {
        if ((t3.parser === "typescript" || t3.parser === "flow" || t3.parser === "espree" || t3.parser === "meriyah" || t3.parser === "__babel_estree") && e3.type === "MethodDefinition" && e3.value && e3.value.type === "FunctionExpression" && Km2(e3.value).length === 0 && !e3.value.returnType && !Xm2(e3.value.typeParameters) && e3.value.body)
          return [...e3.decorators || [], e3.key, e3.value.body];
      }, willPrintOwnComments: function(e3) {
        const t3 = e3.getValue(), n3 = e3.getParentNode();
        return (t3 && (Zm2(t3) || ey2(t3) || uy2(n3) && ((e4) => ty2(ay2(e4, cy2.Leading)) || ty2(ay2(e4, cy2.Trailing)))(t3)) || n3 && (n3.type === "JSXSpreadAttribute" || n3.type === "JSXSpreadChild" || n3.type === "UnionTypeAnnotation" || n3.type === "TSUnionType" || (n3.type === "ClassDeclaration" || n3.type === "ClassExpression") && n3.superClass === t3)) && (!ny2(e3) || n3.type === "UnionTypeAnnotation" || n3.type === "TSUnionType");
      } };
      const { getFunctionParameters: zy2, getLeftSidePathName: Gy2, hasFlowShorthandAnnotationComment: Hy2, hasNakedLeftSide: Jy2, hasNode: Xy2, isBitwiseOperator: Yy2, startsWithNoLookaheadToken: Ky2, shouldFlatten: Qy2, getPrecedence: Zy2, isCallExpression: eD2, isMemberExpression: tD2, isObjectProperty: nD2 } = eg2;
      function rD2(e3, t3) {
        const n3 = e3.getParentNode();
        if (!n3)
          return false;
        const r3 = e3.getName(), i3 = e3.getNode();
        if (t3.__isInHtmlInterpolation && !t3.bracketSpacing && function(e4) {
          switch (e4.type) {
            case "ObjectExpression":
              return true;
            default:
              return false;
          }
        }(i3) && iD2(e3))
          return true;
        if (function(e4) {
          return e4.type === "BlockStatement" || e4.type === "BreakStatement" || e4.type === "ClassBody" || e4.type === "ClassDeclaration" || e4.type === "ClassMethod" || e4.type === "ClassProperty" || e4.type === "PropertyDefinition" || e4.type === "ClassPrivateProperty" || e4.type === "ContinueStatement" || e4.type === "DebuggerStatement" || e4.type === "DeclareClass" || e4.type === "DeclareExportAllDeclaration" || e4.type === "DeclareExportDeclaration" || e4.type === "DeclareFunction" || e4.type === "DeclareInterface" || e4.type === "DeclareModule" || e4.type === "DeclareModuleExports" || e4.type === "DeclareVariable" || e4.type === "DoWhileStatement" || e4.type === "EnumDeclaration" || e4.type === "ExportAllDeclaration" || e4.type === "ExportDefaultDeclaration" || e4.type === "ExportNamedDeclaration" || e4.type === "ExpressionStatement" || e4.type === "ForInStatement" || e4.type === "ForOfStatement" || e4.type === "ForStatement" || e4.type === "FunctionDeclaration" || e4.type === "IfStatement" || e4.type === "ImportDeclaration" || e4.type === "InterfaceDeclaration" || e4.type === "LabeledStatement" || e4.type === "MethodDefinition" || e4.type === "ReturnStatement" || e4.type === "SwitchStatement" || e4.type === "ThrowStatement" || e4.type === "TryStatement" || e4.type === "TSDeclareFunction" || e4.type === "TSEnumDeclaration" || e4.type === "TSImportEqualsDeclaration" || e4.type === "TSInterfaceDeclaration" || e4.type === "TSModuleDeclaration" || e4.type === "TSNamespaceExportDeclaration" || e4.type === "TypeAlias" || e4.type === "VariableDeclaration" || e4.type === "WhileStatement" || e4.type === "WithStatement";
        }(i3))
          return false;
        if (t3.parser !== "flow" && Hy2(e3.getValue()))
          return true;
        if (i3.type === "Identifier")
          return !!(i3.extra && i3.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(i3.name)) || r3 === "left" && i3.name === "async" && n3.type === "ForOfStatement" && !n3.await;
        switch (n3.type) {
          case "ParenthesizedExpression":
            return false;
          case "ClassDeclaration":
          case "ClassExpression":
            if (r3 === "superClass" && (i3.type === "ArrowFunctionExpression" || i3.type === "AssignmentExpression" || i3.type === "AwaitExpression" || i3.type === "BinaryExpression" || i3.type === "ConditionalExpression" || i3.type === "LogicalExpression" || i3.type === "NewExpression" || i3.type === "ObjectExpression" || i3.type === "ParenthesizedExpression" || i3.type === "SequenceExpression" || i3.type === "TaggedTemplateExpression" || i3.type === "UnaryExpression" || i3.type === "UpdateExpression" || i3.type === "YieldExpression" || i3.type === "TSNonNullExpression"))
              return true;
            break;
          case "ExportDefaultDeclaration":
            return uD2(e3, t3) || i3.type === "SequenceExpression";
          case "Decorator":
            if (r3 === "expression") {
              let e4 = false, t4 = false, n4 = i3;
              for (; n4; )
                switch (n4.type) {
                  case "MemberExpression":
                    t4 = true, n4 = n4.object;
                    break;
                  case "CallExpression":
                    if (t4 || e4)
                      return true;
                    e4 = true, n4 = n4.callee;
                    break;
                  case "Identifier":
                    return false;
                  default:
                    return true;
                }
              return true;
            }
            break;
          case "ExpressionStatement":
            if (Ky2(i3, true))
              return true;
            break;
          case "ArrowFunctionExpression":
            if (r3 === "body" && i3.type !== "SequenceExpression" && Ky2(i3, false))
              return true;
        }
        switch (i3.type) {
          case "UpdateExpression":
            if (n3.type === "UnaryExpression")
              return i3.prefix && (i3.operator === "++" && n3.operator === "+" || i3.operator === "--" && n3.operator === "-");
          case "UnaryExpression":
            switch (n3.type) {
              case "UnaryExpression":
                return i3.operator === n3.operator && (i3.operator === "+" || i3.operator === "-");
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r3 === "object";
              case "TaggedTemplateExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r3 === "callee";
              case "BinaryExpression":
                return r3 === "left" && n3.operator === "**";
              case "TSNonNullExpression":
                return true;
              default:
                return false;
            }
          case "BinaryExpression":
            if (n3.type === "UpdateExpression" || n3.type === "PipelineTopicExpression" && i3.operator === "|>")
              return true;
            if (i3.operator === "in" && function(e4) {
              let t4 = 0, n4 = e4.getValue();
              for (; n4; ) {
                const r4 = e4.getParentNode(t4++);
                if (r4 && r4.type === "ForStatement" && r4.init === n4)
                  return true;
                n4 = r4;
              }
              return false;
            }(e3))
              return true;
            if (i3.operator === "|>" && i3.extra && i3.extra.parenthesized) {
              const t4 = e3.getParentNode(1);
              if (t4.type === "BinaryExpression" && t4.operator === "|>")
                return true;
            }
          case "TSTypeAssertion":
          case "TSAsExpression":
          case "LogicalExpression":
            switch (n3.type) {
              case "TSAsExpression":
                return i3.type !== "TSAsExpression";
              case "ConditionalExpression":
                return i3.type === "TSAsExpression";
              case "CallExpression":
              case "NewExpression":
              case "OptionalCallExpression":
                return r3 === "callee";
              case "ClassExpression":
              case "ClassDeclaration":
                return r3 === "superClass";
              case "TSTypeAssertion":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "JSXSpreadAttribute":
              case "SpreadElement":
              case "SpreadProperty":
              case "BindExpression":
              case "AwaitExpression":
              case "TSNonNullExpression":
              case "UpdateExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r3 === "object";
              case "AssignmentExpression":
              case "AssignmentPattern":
                return r3 === "left" && (i3.type === "TSTypeAssertion" || i3.type === "TSAsExpression");
              case "LogicalExpression":
                if (i3.type === "LogicalExpression")
                  return n3.operator !== i3.operator;
              case "BinaryExpression": {
                const { operator: e4, type: t4 } = i3;
                if (!e4 && t4 !== "TSTypeAssertion")
                  return true;
                const u3 = Zy2(e4), o3 = n3.operator, s3 = Zy2(o3);
                return s3 > u3 || (r3 === "right" && s3 === u3 || (s3 === u3 && !Qy2(o3, e4) || (s3 < u3 && e4 === "%" ? o3 === "+" || o3 === "-" : !!Yy2(o3))));
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (n3.type) {
              case "ReturnStatement":
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return r3 !== "expression";
              case "ArrowFunctionExpression":
                return r3 !== "body";
              default:
                return true;
            }
          case "YieldExpression":
            if (n3.type === "UnaryExpression" || n3.type === "AwaitExpression" || n3.type === "TSAsExpression" || n3.type === "TSNonNullExpression")
              return true;
            if (r3 === "expression" && i3.argument && i3.argument.type === "PipelinePrimaryTopicReference" && n3.type === "PipelineTopicExpression")
              return true;
          case "AwaitExpression":
            switch (n3.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r3 === "object";
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r3 === "callee";
              case "ConditionalExpression":
                return r3 === "test";
              case "BinaryExpression":
                return !(!i3.argument && n3.operator === "|>");
              default:
                return false;
            }
          case "TSConditionalType":
            if (r3 === "extendsType" && n3.type === "TSConditionalType")
              return true;
          case "TSFunctionType":
          case "TSConstructorType":
            if (r3 === "checkType" && n3.type === "TSConditionalType")
              return true;
          case "TSUnionType":
          case "TSIntersectionType":
            if ((n3.type === "TSUnionType" || n3.type === "TSIntersectionType") && n3.types.length > 1 && (!i3.types || i3.types.length > 1))
              return true;
          case "TSInferType":
            if (i3.type === "TSInferType" && n3.type === "TSRestType")
              return false;
          case "TSTypeOperator":
            return n3.type === "TSArrayType" || n3.type === "TSOptionalType" || n3.type === "TSRestType" || r3 === "objectType" && n3.type === "TSIndexedAccessType" || n3.type === "TSTypeOperator" || n3.type === "TSTypeAnnotation" && /^TSJSDoc/.test(e3.getParentNode(1).type);
          case "ArrayTypeAnnotation":
            return n3.type === "NullableTypeAnnotation";
          case "IntersectionTypeAnnotation":
          case "UnionTypeAnnotation":
            return n3.type === "ArrayTypeAnnotation" || n3.type === "NullableTypeAnnotation" || n3.type === "IntersectionTypeAnnotation" || n3.type === "UnionTypeAnnotation" || r3 === "objectType" && (n3.type === "IndexedAccessType" || n3.type === "OptionalIndexedAccessType");
          case "NullableTypeAnnotation":
            return n3.type === "ArrayTypeAnnotation" || r3 === "objectType" && (n3.type === "IndexedAccessType" || n3.type === "OptionalIndexedAccessType");
          case "FunctionTypeAnnotation": {
            const t4 = n3.type === "NullableTypeAnnotation" ? e3.getParentNode(1) : n3;
            return t4.type === "UnionTypeAnnotation" || t4.type === "IntersectionTypeAnnotation" || t4.type === "ArrayTypeAnnotation" || r3 === "objectType" && (t4.type === "IndexedAccessType" || t4.type === "OptionalIndexedAccessType") || t4.type === "NullableTypeAnnotation" || n3.type === "FunctionTypeParam" && n3.name === null && zy2(i3).some((e4) => e4.typeAnnotation && e4.typeAnnotation.type === "NullableTypeAnnotation");
          }
          case "OptionalIndexedAccessType":
            return r3 === "objectType" && n3.type === "IndexedAccessType";
          case "TypeofTypeAnnotation":
            return r3 === "objectType" && (n3.type === "IndexedAccessType" || n3.type === "OptionalIndexedAccessType");
          case "StringLiteral":
          case "NumericLiteral":
          case "Literal":
            if (typeof i3.value == "string" && n3.type === "ExpressionStatement" && !n3.directive) {
              const t4 = e3.getParentNode(1);
              return t4.type === "Program" || t4.type === "BlockStatement";
            }
            return r3 === "object" && n3.type === "MemberExpression" && typeof i3.value == "number";
          case "AssignmentExpression": {
            const t4 = e3.getParentNode(1);
            return r3 === "body" && n3.type === "ArrowFunctionExpression" || (r3 !== "key" || n3.type !== "ClassProperty" && n3.type !== "PropertyDefinition" || !n3.computed) && ((r3 !== "init" && r3 !== "update" || n3.type !== "ForStatement") && (n3.type === "ExpressionStatement" ? i3.left.type === "ObjectPattern" : (r3 !== "key" || n3.type !== "TSPropertySignature") && (n3.type !== "AssignmentExpression" && ((n3.type !== "SequenceExpression" || !t4 || t4.type !== "ForStatement" || t4.init !== n3 && t4.update !== n3) && ((r3 !== "value" || n3.type !== "Property" || !t4 || t4.type !== "ObjectPattern" || !t4.properties.includes(n3)) && n3.type !== "NGChainedExpression")))));
          }
          case "ConditionalExpression":
            switch (n3.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
              case "NGPipeExpression":
              case "ExportDefaultDeclaration":
              case "AwaitExpression":
              case "JSXSpreadAttribute":
              case "TSTypeAssertion":
              case "TypeCastExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r3 === "callee";
              case "ConditionalExpression":
                return r3 === "test";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r3 === "object";
              default:
                return false;
            }
          case "FunctionExpression":
            switch (n3.type) {
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r3 === "callee";
              case "TaggedTemplateExpression":
                return true;
              default:
                return false;
            }
          case "ArrowFunctionExpression":
            switch (n3.type) {
              case "PipelineTopicExpression":
                return Boolean(i3.extra && i3.extra.parenthesized);
              case "BinaryExpression":
                return n3.operator !== "|>" || i3.extra && i3.extra.parenthesized;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r3 === "callee";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r3 === "object";
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "BindExpression":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "AwaitExpression":
              case "TSTypeAssertion":
                return true;
              case "ConditionalExpression":
                return r3 === "test";
              default:
                return false;
            }
          case "ClassExpression":
            switch (n3.type) {
              case "NewExpression":
                return r3 === "callee";
              default:
                return false;
            }
          case "OptionalMemberExpression":
          case "OptionalCallExpression": {
            const t4 = e3.getParentNode(1);
            if (r3 === "object" && n3.type === "MemberExpression" || r3 === "callee" && (n3.type === "CallExpression" || n3.type === "NewExpression") || n3.type === "TSNonNullExpression" && t4.type === "MemberExpression" && t4.object === n3)
              return true;
          }
          case "CallExpression":
          case "MemberExpression":
          case "TaggedTemplateExpression":
          case "TSNonNullExpression":
            if (r3 === "callee" && (n3.type === "BindExpression" || n3.type === "NewExpression")) {
              let e4 = i3;
              for (; e4; )
                switch (e4.type) {
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                  case "BindExpression":
                    e4 = e4.object;
                    break;
                  case "TaggedTemplateExpression":
                    e4 = e4.tag;
                    break;
                  case "TSNonNullExpression":
                    e4 = e4.expression;
                    break;
                  default:
                    return false;
                }
            }
            return false;
          case "BindExpression":
            return r3 === "callee" && (n3.type === "BindExpression" || n3.type === "NewExpression") || r3 === "object" && tD2(n3);
          case "NGPipeExpression":
            return !(n3.type === "NGRoot" || n3.type === "NGMicrosyntaxExpression" || n3.type === "ObjectProperty" && (!i3.extra || !i3.extra.parenthesized) || n3.type === "ArrayExpression" || eD2(n3) && n3.arguments[r3] === i3 || r3 === "right" && n3.type === "NGPipeExpression" || r3 === "property" && n3.type === "MemberExpression" || n3.type === "AssignmentExpression");
          case "JSXFragment":
          case "JSXElement":
            return r3 === "callee" || r3 === "left" && n3.type === "BinaryExpression" && n3.operator === "<" || n3.type !== "ArrayExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "AssignmentExpression" && n3.type !== "AssignmentPattern" && n3.type !== "BinaryExpression" && n3.type !== "NewExpression" && n3.type !== "ConditionalExpression" && n3.type !== "ExpressionStatement" && n3.type !== "JsExpressionRoot" && n3.type !== "JSXAttribute" && n3.type !== "JSXElement" && n3.type !== "JSXExpressionContainer" && n3.type !== "JSXFragment" && n3.type !== "LogicalExpression" && !eD2(n3) && !nD2(n3) && n3.type !== "ReturnStatement" && n3.type !== "ThrowStatement" && n3.type !== "TypeCastExpression" && n3.type !== "VariableDeclarator" && n3.type !== "YieldExpression";
          case "TypeAnnotation":
            return r3 === "returnType" && n3.type === "ArrowFunctionExpression" && function(e4) {
              return Xy2(e4, (e5) => e5.type === "ObjectTypeAnnotation" && Xy2(e5, (e6) => e6.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }(i3);
        }
        return false;
      }
      function iD2(e3) {
        const t3 = e3.getValue(), n3 = e3.getParentNode(), r3 = e3.getName();
        switch (n3.type) {
          case "NGPipeExpression":
            if (typeof r3 == "number" && n3.arguments[r3] === t3 && n3.arguments.length - 1 === r3)
              return e3.callParent(iD2);
            break;
          case "ObjectProperty":
            if (r3 === "value") {
              const t4 = e3.getParentNode(1);
              return _n2(t4.properties) === n3;
            }
            break;
          case "BinaryExpression":
          case "LogicalExpression":
            if (r3 === "right")
              return e3.callParent(iD2);
            break;
          case "ConditionalExpression":
            if (r3 === "alternate")
              return e3.callParent(iD2);
            break;
          case "UnaryExpression":
            if (n3.prefix)
              return e3.callParent(iD2);
        }
        return false;
      }
      function uD2(e3, t3) {
        const n3 = e3.getValue(), r3 = e3.getParentNode();
        return n3.type === "FunctionExpression" || n3.type === "ClassExpression" ? r3.type === "ExportDefaultDeclaration" || !rD2(e3, t3) : !(!Jy2(n3) || r3.type !== "ExportDefaultDeclaration" && rD2(e3, t3)) && e3.call((e4) => uD2(e4, t3), ...Gy2(e3, n3));
      }
      var oD2 = rD2;
      var sD2 = function(e3, t3) {
        switch (t3.parser) {
          case "json":
          case "json5":
          case "json-stringify":
          case "__js_expression":
          case "__vue_expression":
            return Object.assign(Object.assign({}, e3), {}, { type: t3.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e3, comments: [], rootMarker: t3.rootMarker });
          default:
            return e3;
        }
      };
      const { builders: { join: aD2, line: cD2, group: lD2, softline: pD2, indent: fD2 } } = su2;
      var dD2 = { isVueEventBindingExpression: function e3(t3) {
        switch (t3.type) {
          case "MemberExpression":
            switch (t3.property.type) {
              case "Identifier":
              case "NumericLiteral":
              case "StringLiteral":
                return e3(t3.object);
            }
            return false;
          case "Identifier":
            return true;
          default:
            return false;
        }
      }, printHtmlBinding: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (t3.__onHtmlBindingRoot && e3.getName() === null && t3.__onHtmlBindingRoot(r3, t3), r3.type === "File")
          return t3.__isVueForBindingLeft ? e3.call((e4) => {
            const t4 = aD2([",", cD2], e4.map(n3, "params")), { params: r4 } = e4.getValue();
            return r4.length === 1 ? t4 : ["(", fD2([pD2, lD2(t4)]), pD2, ")"];
          }, "program", "body", 0) : t3.__isVueBindings ? e3.call((e4) => aD2([",", cD2], e4.map(n3, "params")), "program", "body", 0) : void 0;
      } };
      const { printComments: hD2 } = Yf2, { getLast: gD2 } = Fi2, { builders: { join: mD2, line: yD2, softline: DD2, group: ED2, indent: CD2, align: bD2, ifBreak: AD2, indentIfBreak: vD2 }, utils: { cleanDoc: FD2, getDocParts: xD2, isConcat: SD2 } } = su2, { hasLeadingOwnLineComment: wD2, isBinaryish: TD2, isJsxNode: BD2, shouldFlatten: ND2, hasComment: kD2, CommentCheckFlags: PD2, isCallExpression: OD2, isMemberExpression: ID2, isObjectProperty: LD2 } = eg2;
      let jD2 = 0;
      function _D2(e3, t3, n3, r3, i3) {
        let u3 = [];
        const o3 = e3.getValue();
        if (TD2(o3)) {
          ND2(o3.operator, o3.left.operator) ? u3 = [...u3, ...e3.call((e4) => _D2(e4, t3, n3, true, i3), "left")] : u3.push(ED2(t3("left")));
          const s3 = MD2(o3), a3 = (o3.operator === "|>" || o3.type === "NGPipeExpression" || o3.operator === "|" && n3.parser === "__vue_expression") && !wD2(n3.originalText, o3.right), c3 = o3.type === "NGPipeExpression" ? "|" : o3.operator, l3 = o3.type === "NGPipeExpression" && o3.arguments.length > 0 ? ED2(CD2([DD2, ": ", mD2([DD2, ":", AD2(" ")], e3.map(t3, "arguments").map((e4) => bD2(2, ED2(e4))))])) : "", p3 = s3 ? [c3, " ", t3("right"), l3] : [a3 ? yD2 : "", c3, a3 ? " " : yD2, t3("right"), l3], f3 = e3.getParentNode(), d3 = kD2(o3.left, PD2.Trailing | PD2.Line), h3 = d3 || !(i3 && o3.type === "LogicalExpression") && f3.type !== o3.type && o3.left.type !== o3.type && o3.right.type !== o3.type;
          if (u3.push(a3 ? "" : " ", h3 ? ED2(p3, { shouldBreak: d3 }) : p3), r3 && kD2(o3)) {
            const t4 = FD2(hD2(e3, u3, n3));
            u3 = SD2(t4) || t4.type === "fill" ? xD2(t4) : [t4];
          }
        } else
          u3.push(ED2(t3()));
        return u3;
      }
      function MD2(e3) {
        return e3.type === "LogicalExpression" && (e3.right.type === "ObjectExpression" && e3.right.properties.length > 0 || (e3.right.type === "ArrayExpression" && e3.right.elements.length > 0 || !!BD2(e3.right)));
      }
      var RD2 = { printBinaryishExpression: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = e3.getParentNode(), u3 = e3.getParentNode(1), o3 = r3 !== i3.body && (i3.type === "IfStatement" || i3.type === "WhileStatement" || i3.type === "SwitchStatement" || i3.type === "DoWhileStatement"), s3 = _D2(e3, n3, t3, false, o3);
        if (o3)
          return s3;
        if (OD2(i3) && i3.callee === r3 || i3.type === "UnaryExpression" || ID2(i3) && !i3.computed)
          return ED2([CD2([DD2, ...s3]), DD2]);
        const a3 = i3.type === "ReturnStatement" || i3.type === "ThrowStatement" || i3.type === "JSXExpressionContainer" && u3.type === "JSXAttribute" || r3.operator !== "|" && i3.type === "JsExpressionRoot" || r3.type !== "NGPipeExpression" && (i3.type === "NGRoot" && t3.parser === "__ng_binding" || i3.type === "NGMicrosyntaxExpression" && u3.type === "NGMicrosyntax" && u3.body.length === 1) || r3 === i3.body && i3.type === "ArrowFunctionExpression" || r3 !== i3.body && i3.type === "ForStatement" || i3.type === "ConditionalExpression" && u3.type !== "ReturnStatement" && u3.type !== "ThrowStatement" && !OD2(u3) || i3.type === "TemplateLiteral", c3 = i3.type === "AssignmentExpression" || i3.type === "VariableDeclarator" || i3.type === "ClassProperty" || i3.type === "PropertyDefinition" || i3.type === "TSAbstractClassProperty" || i3.type === "ClassPrivateProperty" || LD2(i3), l3 = TD2(r3.left) && ND2(r3.operator, r3.left.operator);
        if (a3 || MD2(r3) && !l3 || !MD2(r3) && c3)
          return ED2(s3);
        if (s3.length === 0)
          return "";
        const p3 = BD2(r3.right), f3 = s3.findIndex((e4) => typeof e4 != "string" && !Array.isArray(e4) && e4.type === "group"), d3 = s3.slice(0, f3 === -1 ? 1 : f3 + 1), h3 = s3.slice(d3.length, p3 ? -1 : void 0), g3 = Symbol("logicalChain-" + ++jD2), m3 = ED2([...d3, CD2(h3)], { id: g3 });
        if (!p3)
          return m3;
        const y3 = gD2(s3);
        return ED2([m3, vD2(y3, { groupId: g3 })]);
      }, shouldInlineLogicalExpression: MD2 };
      const { builders: { join: $D2, line: VD2, group: WD2 } } = su2, { hasNode: qD2, hasComment: UD2, getComments: zD2 } = eg2, { printBinaryishExpression: GD2 } = RD2;
      function HD2(e3, t3, n3) {
        return e3.type === "NGMicrosyntaxKeyedExpression" && e3.key.name === "of" && t3 === 1 && n3.body[0].type === "NGMicrosyntaxLet" && n3.body[0].value === null;
      }
      var JD2 = { printAngular: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (r3.type.startsWith("NG"))
          switch (r3.type) {
            case "NGRoot":
              return [n3("node"), UD2(r3.node) ? " //" + zD2(r3.node)[0].value.trimEnd() : ""];
            case "NGPipeExpression":
              return GD2(e3, t3, n3);
            case "NGChainedExpression":
              return WD2($D2([";", VD2], e3.map((e4) => function(e5) {
                return qD2(e5.getValue(), (e6) => {
                  switch (e6.type) {
                    case void 0:
                      return false;
                    case "CallExpression":
                    case "OptionalCallExpression":
                    case "AssignmentExpression":
                      return true;
                  }
                });
              }(e4) ? n3() : ["(", n3(), ")"], "expressions")));
            case "NGEmptyExpression":
              return "";
            case "NGQuotedExpression":
              return [r3.prefix, ": ", r3.value.trim()];
            case "NGMicrosyntax":
              return e3.map((e4, t4) => [t4 === 0 ? "" : HD2(e4.getValue(), t4, r3) ? " " : [";", VD2], n3()], "body");
            case "NGMicrosyntaxKey":
              return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r3.name) ? r3.name : JSON.stringify(r3.name);
            case "NGMicrosyntaxExpression":
              return [n3("expression"), r3.alias === null ? "" : [" as ", n3("alias")]];
            case "NGMicrosyntaxKeyedExpression": {
              const t4 = e3.getName(), i3 = e3.getParentNode(), u3 = HD2(r3, t4, i3) || (t4 === 1 && (r3.key.name === "then" || r3.key.name === "else") || t4 === 2 && r3.key.name === "else" && i3.body[t4 - 1].type === "NGMicrosyntaxKeyedExpression" && i3.body[t4 - 1].key.name === "then") && i3.body[0].type === "NGMicrosyntaxExpression";
              return [n3("key"), u3 ? " " : ": ", n3("expression")];
            }
            case "NGMicrosyntaxLet":
              return ["let ", n3("key"), r3.value === null ? "" : [" = ", n3("value")]];
            case "NGMicrosyntaxAs":
              return [n3("key"), " as ", n3("alias")];
            default:
              throw new Error(`Unknown Angular node type: ${JSON.stringify(r3.type)}.`);
          }
      } };
      const { printComments: XD2, printDanglingComments: YD2 } = Yf2, { builders: { line: KD2, hardline: QD2, softline: ZD2, group: eE2, indent: tE2, conditionalGroup: nE2, fill: rE2, ifBreak: iE2, lineSuffixBoundary: uE2, join: oE2 }, utils: { willBreak: sE2 } } = su2, { getLast: aE2, getPreferredQuote: cE2 } = Fi2, { isJsxNode: lE2, rawText: pE2, isLiteral: fE2, isCallExpression: dE2, isStringLiteral: hE2, isBinaryish: gE2, hasComment: mE2, CommentCheckFlags: yE2, hasNodeIgnoreComment: DE2 } = eg2, { willPrintOwnComments: EE2 } = Uy2, CE2 = (e3) => e3 === "" || e3 === KD2 || e3 === QD2 || e3 === ZD2;
      function bE2(e3, t3, n3) {
        const r3 = e3.getValue();
        if (r3.type === "JSXElement" && function(e4) {
          if (e4.children.length === 0)
            return true;
          if (e4.children.length > 1)
            return false;
          const t4 = e4.children[0];
          return fE2(t4) && !BE2(t4);
        }(r3))
          return [n3("openingElement"), n3("closingElement")];
        const i3 = r3.type === "JSXElement" ? n3("openingElement") : n3("openingFragment"), u3 = r3.type === "JSXElement" ? n3("closingElement") : n3("closingFragment");
        if (r3.children.length === 1 && r3.children[0].type === "JSXExpressionContainer" && (r3.children[0].expression.type === "TemplateLiteral" || r3.children[0].expression.type === "TaggedTemplateExpression"))
          return [i3, ...e3.map(n3, "children"), u3];
        r3.children = r3.children.map((e4) => function(e5) {
          return e5.type === "JSXExpressionContainer" && fE2(e5.expression) && e5.expression.value === " " && !mE2(e5.expression);
        }(e4) ? { type: "JSXText", value: " ", raw: " " } : e4);
        const o3 = r3.children.filter(lE2).length > 0, s3 = r3.children.filter((e4) => e4.type === "JSXExpressionContainer").length > 1, a3 = r3.type === "JSXElement" && r3.openingElement.attributes.length > 1;
        let c3 = sE2(i3) || o3 || a3 || s3;
        const l3 = e3.getParentNode().rootMarker === "mdx", p3 = t3.singleQuote ? "{' '}" : '{" "}', f3 = l3 ? " " : iE2([p3, ZD2], " "), d3 = function(e4, t4, n4, r4, i4) {
          const u4 = [];
          return e4.each((e5, t5, o4) => {
            const s4 = e5.getValue();
            if (fE2(s4)) {
              const e6 = pE2(s4);
              if (BE2(s4)) {
                const n5 = e6.split(SE2);
                if (n5[0] === "") {
                  if (u4.push(""), n5.shift(), /\n/.test(n5[0])) {
                    const e7 = o4[t5 + 1];
                    u4.push(vE2(i4, n5[1], s4, e7));
                  } else
                    u4.push(r4);
                  n5.shift();
                }
                let a4;
                if (aE2(n5) === "" && (n5.pop(), a4 = n5.pop()), n5.length === 0)
                  return;
                for (const [e7, t6] of n5.entries())
                  e7 % 2 == 1 ? u4.push(KD2) : u4.push(t6);
                if (a4 !== void 0)
                  if (/\n/.test(a4)) {
                    const e7 = o4[t5 + 1];
                    u4.push(vE2(i4, aE2(u4), s4, e7));
                  } else
                    u4.push(r4);
                else {
                  const e7 = o4[t5 + 1];
                  u4.push(AE2(i4, aE2(u4), s4, e7));
                }
              } else
                /\n/.test(e6) ? e6.match(/\n/g).length > 1 && u4.push("", QD2) : u4.push("", r4);
            } else {
              const e6 = n4();
              u4.push(e6);
              const r5 = o4[t5 + 1];
              if (r5 && BE2(r5)) {
                const e7 = TE2(pE2(r5)).split(SE2)[0];
                u4.push(AE2(i4, e7, s4, r5));
              } else
                u4.push(QD2);
            }
          }, "children"), u4;
        }(e3, 0, n3, f3, r3.openingElement && r3.openingElement.name && r3.openingElement.name.name === "fbt"), h3 = r3.children.some((e4) => BE2(e4));
        for (let e4 = d3.length - 2; e4 >= 0; e4--) {
          const t4 = d3[e4] === "" && d3[e4 + 1] === "", n4 = d3[e4] === QD2 && d3[e4 + 1] === "" && d3[e4 + 2] === QD2, r4 = (d3[e4] === ZD2 || d3[e4] === QD2) && d3[e4 + 1] === "" && d3[e4 + 2] === f3, i4 = d3[e4] === f3 && d3[e4 + 1] === "" && (d3[e4 + 2] === ZD2 || d3[e4 + 2] === QD2), u4 = d3[e4] === f3 && d3[e4 + 1] === "" && d3[e4 + 2] === f3, o4 = d3[e4] === ZD2 && d3[e4 + 1] === "" && d3[e4 + 2] === QD2 || d3[e4] === QD2 && d3[e4 + 1] === "" && d3[e4 + 2] === ZD2;
          n4 && h3 || t4 || r4 || u4 || o4 ? d3.splice(e4, 2) : i4 && d3.splice(e4 + 1, 2);
        }
        for (; d3.length > 0 && CE2(aE2(d3)); )
          d3.pop();
        for (; d3.length > 1 && CE2(d3[0]) && CE2(d3[1]); )
          d3.shift(), d3.shift();
        const g3 = [];
        for (const [e4, t4] of d3.entries()) {
          if (t4 === f3) {
            if (e4 === 1 && d3[e4 - 1] === "") {
              if (d3.length === 2) {
                g3.push(p3);
                continue;
              }
              g3.push([p3, QD2]);
              continue;
            }
            if (e4 === d3.length - 1) {
              g3.push(p3);
              continue;
            }
            if (d3[e4 - 1] === "" && d3[e4 - 2] === QD2) {
              g3.push(p3);
              continue;
            }
          }
          g3.push(t4), sE2(t4) && (c3 = true);
        }
        const m3 = h3 ? rE2(g3) : eE2(g3, { shouldBreak: true });
        if (l3)
          return m3;
        const y3 = eE2([i3, tE2([QD2, m3]), QD2, u3]);
        return c3 ? y3 : nE2([eE2([i3, ...d3, u3]), y3]);
      }
      function AE2(e3, t3, n3, r3) {
        return e3 ? "" : n3.type === "JSXElement" && !n3.closingElement || r3 && r3.type === "JSXElement" && !r3.closingElement ? t3.length === 1 ? ZD2 : QD2 : ZD2;
      }
      function vE2(e3, t3, n3, r3) {
        return e3 ? QD2 : t3.length === 1 ? n3.type === "JSXElement" && !n3.closingElement || r3 && r3.type === "JSXElement" && !r3.closingElement ? QD2 : ZD2 : QD2;
      }
      function FE2(e3, t3, n3) {
        return function(e4, t4, n4) {
          const r3 = e4.getParentNode();
          if (!r3)
            return t4;
          if ({ ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[r3.type])
            return t4;
          const i3 = e4.match(void 0, (e5) => e5.type === "ArrowFunctionExpression", dE2, (e5) => e5.type === "JSXExpressionContainer"), u3 = oD2(e4, n4);
          return eE2([u3 ? "" : iE2("("), tE2([ZD2, t4]), ZD2, u3 ? "" : iE2(")")], { shouldBreak: i3 });
        }(e3, XD2(e3, bE2(e3, t3, n3), t3), t3);
      }
      function xE2(e3, t3, n3) {
        const r3 = e3.getValue();
        return ["{", e3.call((e4) => {
          const r4 = ["...", n3()], i3 = e4.getValue();
          return mE2(i3) && EE2(e4) ? [tE2([ZD2, XD2(e4, r4, t3)]), ZD2] : r4;
        }, r3.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
      }
      const SE2 = new RegExp("([ \n\r	]+)"), wE2 = new RegExp("[^ \n\r	]"), TE2 = (e3) => e3.replace(new RegExp("(?:^" + SE2.source + "|" + SE2.source + "$)"), "");
      function BE2(e3) {
        return fE2(e3) && (wE2.test(pE2(e3)) || !/\n/.test(pE2(e3)));
      }
      var NE2 = { hasJsxIgnoreComment: function(e3) {
        const t3 = e3.getValue(), n3 = e3.getParentNode();
        if (!(n3 && t3 && lE2(t3) && lE2(n3)))
          return false;
        let r3 = null;
        for (let e4 = n3.children.indexOf(t3); e4 > 0; e4--) {
          const t4 = n3.children[e4 - 1];
          if (t4.type !== "JSXText" || BE2(t4)) {
            r3 = t4;
            break;
          }
        }
        return r3 && r3.type === "JSXExpressionContainer" && r3.expression.type === "JSXEmptyExpression" && DE2(r3.expression);
      }, printJsx: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (r3.type.startsWith("JSX"))
          switch (r3.type) {
            case "JSXAttribute":
              return function(e4, t4, n4) {
                const r4 = e4.getValue(), i3 = [];
                if (i3.push(n4("name")), r4.value) {
                  let e5;
                  if (hE2(r4.value)) {
                    let n5 = pE2(r4.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                    const i4 = cE2(n5, t4.jsxSingleQuote ? "'" : '"'), u3 = i4 === "'" ? "&apos;" : "&quot;";
                    n5 = n5.slice(1, -1).replace(new RegExp(i4, "g"), u3), e5 = [i4, n5, i4];
                  } else
                    e5 = n4("value");
                  i3.push("=", e5);
                }
                return i3;
              }(e3, t3, n3);
            case "JSXIdentifier":
              return String(r3.name);
            case "JSXNamespacedName":
              return oE2(":", [n3("namespace"), n3("name")]);
            case "JSXMemberExpression":
              return oE2(".", [n3("object"), n3("property")]);
            case "JSXSpreadAttribute":
              return xE2(e3, t3, n3);
            case "JSXSpreadChild":
              return xE2(e3, t3, n3);
            case "JSXExpressionContainer":
              return function(e4, t4, n4) {
                const r4 = e4.getValue(), i3 = e4.getParentNode(0), u3 = r4.expression.type === "JSXEmptyExpression" || !mE2(r4.expression) && (r4.expression.type === "ArrayExpression" || r4.expression.type === "ObjectExpression" || r4.expression.type === "ArrowFunctionExpression" || dE2(r4.expression) || r4.expression.type === "FunctionExpression" || r4.expression.type === "TemplateLiteral" || r4.expression.type === "TaggedTemplateExpression" || r4.expression.type === "DoExpression" || lE2(i3) && (r4.expression.type === "ConditionalExpression" || gE2(r4.expression)));
                return eE2(u3 ? ["{", n4("expression"), uE2, "}"] : ["{", tE2([ZD2, n4("expression")]), ZD2, uE2, "}"]);
              }(e3, 0, n3);
            case "JSXFragment":
            case "JSXElement":
              return FE2(e3, t3, n3);
            case "JSXOpeningElement":
              return function(e4, t4, n4) {
                const r4 = e4.getValue(), i3 = r4.name && mE2(r4.name) || r4.typeParameters && mE2(r4.typeParameters);
                if (r4.selfClosing && r4.attributes.length === 0 && !i3)
                  return ["<", n4("name"), n4("typeParameters"), " />"];
                if (r4.attributes && r4.attributes.length === 1 && r4.attributes[0].value && hE2(r4.attributes[0].value) && !r4.attributes[0].value.value.includes("\n") && !i3 && !mE2(r4.attributes[0]))
                  return eE2(["<", n4("name"), n4("typeParameters"), " ", ...e4.map(n4, "attributes"), r4.selfClosing ? " />" : ">"]);
                const u3 = r4.attributes.length > 0 && mE2(aE2(r4.attributes), yE2.Trailing), o3 = r4.attributes.length === 0 && !i3 || (t4.bracketSameLine || t4.jsxBracketSameLine) && (!i3 || r4.attributes.length > 0) && !u3, s3 = r4.attributes && r4.attributes.some((e5) => e5.value && hE2(e5.value) && e5.value.value.includes("\n"));
                return eE2(["<", n4("name"), n4("typeParameters"), tE2(e4.map(() => [KD2, n4()], "attributes")), r4.selfClosing ? KD2 : o3 ? ">" : ZD2, r4.selfClosing ? "/>" : o3 ? "" : ">"], { shouldBreak: s3 });
              }(e3, t3, n3);
            case "JSXClosingElement":
              return function(e4, t4, n4) {
                const r4 = e4.getValue(), i3 = [];
                i3.push("</");
                const u3 = n4("name");
                return mE2(r4.name, yE2.Leading | yE2.Line) ? i3.push(tE2([QD2, u3]), QD2) : mE2(r4.name, yE2.Leading | yE2.Block) ? i3.push(" ", u3) : i3.push(u3), i3.push(">"), i3;
              }(e3, 0, n3);
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              return function(e4, t4) {
                const n4 = e4.getValue(), r4 = mE2(n4), i3 = mE2(n4, yE2.Line), u3 = n4.type === "JSXOpeningFragment";
                return [u3 ? "<" : "</", tE2([i3 ? QD2 : r4 && !u3 ? " " : "", YD2(e4, t4, true)]), i3 ? QD2 : "", ">"];
              }(e3, t3);
            case "JSXEmptyExpression":
              return function(e4, t4) {
                const n4 = e4.getValue(), r4 = mE2(n4, yE2.Line);
                return [YD2(e4, t4, !r4), r4 ? QD2 : ""];
              }(e3, t3);
            case "JSXText":
              throw new Error("JSXTest should be handled by JSXElement");
            default:
              throw new Error(`Unknown JSX node type: ${JSON.stringify(r3.type)}.`);
          }
      } };
      tt2({ target: "Array", proto: true }, { flat: function() {
        var e3 = arguments.length ? arguments[0] : void 0, t3 = U2(this), n3 = _e2(t3.length), r3 = Un2(t3, 0);
        return r3.length = Wn2(r3, t3, t3, n3, 0, e3 === void 0 ? 1 : Le2(e3)), r3;
      } });
      const { isNonEmptyArray: kE2 } = Fi2, { builders: { indent: PE2, join: OE2, line: IE2 } } = su2, { isFlowAnnotationComment: LE2 } = eg2;
      function jE2(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!r3.typeAnnotation)
          return "";
        const i3 = e3.getParentNode(), u3 = r3.definite || i3 && i3.type === "VariableDeclarator" && i3.definite, o3 = i3.type === "DeclareFunction" && i3.id === r3;
        return LE2(t3.originalText, r3.typeAnnotation) ? [" /*: ", n3("typeAnnotation"), " */"] : [o3 ? "" : u3 ? "!: " : ": ", n3("typeAnnotation")];
      }
      var _E2 = { printOptionalToken: function(e3) {
        const t3 = e3.getValue();
        return !t3.optional || t3.type === "Identifier" && t3 === e3.getParentNode().key ? "" : t3.type === "OptionalCallExpression" || t3.type === "OptionalMemberExpression" && t3.computed ? "?." : "?";
      }, printFunctionTypeParameters: function(e3, t3, n3) {
        const r3 = e3.getValue();
        return r3.typeArguments ? n3("typeArguments") : r3.typeParameters ? n3("typeParameters") : "";
      }, printBindExpressionCallee: function(e3, t3, n3) {
        return ["::", n3("callee")];
      }, printTypeScriptModifiers: function(e3, t3, n3) {
        const r3 = e3.getValue();
        return kE2(r3.modifiers) ? [OE2(" ", e3.map(n3, "modifiers")), " "] : "";
      }, printTypeAnnotation: jE2, printRestSpread: function(e3, t3, n3) {
        return ["...", n3("argument"), jE2(e3, t3, n3)];
      }, adjustClause: function(e3, t3, n3) {
        return e3.type === "EmptyStatement" ? ";" : e3.type === "BlockStatement" || n3 ? [" ", t3] : PE2([IE2, t3]);
      } };
      const { printDanglingComments: ME2 } = Yf2, { builders: { line: RE2, softline: $E2, hardline: VE2, group: WE2, indent: qE2, ifBreak: UE2, fill: zE2 } } = su2, { getLast: GE2, hasNewline: HE2 } = Fi2, { shouldPrintComma: JE2, hasComment: XE2, CommentCheckFlags: YE2, isNextLineEmpty: KE2, isNumericLiteral: QE2, isSignedNumericLiteral: ZE2 } = eg2, { locStart: eC2 } = Zc2, { printOptionalToken: tC2, printTypeAnnotation: nC2 } = _E2;
      function rC2(e3, t3) {
        return e3.elements.length > 1 && e3.elements.every((e4) => e4 && (QE2(e4) || ZE2(e4) && !XE2(e4.argument)) && !XE2(e4, YE2.Trailing | YE2.Line, (e5) => !HE2(t3.originalText, eC2(e5), { backwards: true })));
      }
      function iC2(e3, t3, n3, r3) {
        const i3 = [];
        let u3 = [];
        return e3.each((e4) => {
          i3.push(u3, WE2(r3())), u3 = [",", RE2], e4.getValue() && KE2(e4.getValue(), t3) && u3.push($E2);
        }, n3), i3;
      }
      function uC2(e3, t3, n3, r3) {
        const i3 = [];
        return e3.each((e4, u3, o3) => {
          const s3 = u3 === o3.length - 1;
          i3.push([n3(), s3 ? r3 : ","]), s3 || i3.push(KE2(e4.getValue(), t3) ? [VE2, VE2] : XE2(o3[u3 + 1], YE2.Leading | YE2.Line) ? VE2 : RE2);
        }, "elements"), zE2(i3);
      }
      var oC2 = { printArray: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [], u3 = r3.type === "TupleExpression" ? "#[" : "[";
        if (r3.elements.length === 0)
          XE2(r3, YE2.Dangling) ? i3.push(WE2([u3, ME2(e3, t3), $E2, "]"])) : i3.push(u3, "]");
        else {
          const o3 = GE2(r3.elements), s3 = !(o3 && o3.type === "RestElement"), a3 = o3 === null, c3 = Symbol("array"), l3 = !t3.__inJestEach && r3.elements.length > 1 && r3.elements.every((e4, t4, n4) => {
            const r4 = e4 && e4.type;
            if (r4 !== "ArrayExpression" && r4 !== "ObjectExpression")
              return false;
            const i4 = n4[t4 + 1];
            if (i4 && r4 !== i4.type)
              return false;
            const u4 = r4 === "ArrayExpression" ? "elements" : "properties";
            return e4[u4] && e4[u4].length > 1;
          }), p3 = rC2(r3, t3), f3 = s3 ? a3 ? "," : JE2(t3) ? p3 ? UE2(",", "", { groupId: c3 }) : UE2(",") : "" : "";
          i3.push(WE2([u3, qE2([$E2, p3 ? uC2(e3, t3, n3, f3) : [iC2(e3, t3, "elements", n3), f3], ME2(e3, t3, true)]), $E2, "]"], { shouldBreak: l3, id: c3 }));
        }
        return i3.push(tC2(e3), nC2(e3, t3, n3)), i3;
      }, printArrayItems: iC2, isConciselyPrintedArray: rC2 };
      const { printDanglingComments: sC2 } = Yf2, { getLast: aC2, getPenultimate: cC2 } = Fi2, { getFunctionParameters: lC2, hasComment: pC2, CommentCheckFlags: fC2, isFunctionCompositionArgs: dC2, isJsxNode: hC2, isLongCurriedCallExpression: gC2, shouldPrintComma: mC2, getCallArguments: yC2, iterateCallArgumentsPath: DC2, isNextLineEmpty: EC2, isCallExpression: CC2, isStringLiteral: bC2, isObjectProperty: AC2 } = eg2, { builders: { line: vC2, hardline: FC2, softline: xC2, group: SC2, indent: wC2, conditionalGroup: TC2, ifBreak: BC2, breakParent: NC2 }, utils: { willBreak: kC2 } } = su2, { ArgExpansionBailout: PC2 } = Bo2, { isConciselyPrintedArray: OC2 } = oC2;
      function IC2(e3, t3 = false) {
        return e3.type === "ObjectExpression" && (e3.properties.length > 0 || pC2(e3)) || e3.type === "ArrayExpression" && (e3.elements.length > 0 || pC2(e3)) || e3.type === "TSTypeAssertion" && IC2(e3.expression) || e3.type === "TSAsExpression" && IC2(e3.expression) || e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression" && (!e3.returnType || !e3.returnType.typeAnnotation || e3.returnType.typeAnnotation.type !== "TSTypeReference" || (n3 = e3.body).type === "BlockStatement" && (n3.body.some((e4) => e4.type !== "EmptyStatement") || pC2(n3, fC2.Dangling))) && (e3.body.type === "BlockStatement" || e3.body.type === "ArrowFunctionExpression" && IC2(e3.body, true) || e3.body.type === "ObjectExpression" || e3.body.type === "ArrayExpression" || !t3 && (CC2(e3.body) || e3.body.type === "ConditionalExpression") || hC2(e3.body)) || e3.type === "DoExpression" || e3.type === "ModuleExpression";
        var n3;
      }
      var LC2 = function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.type === "ImportExpression", u3 = yC2(r3);
        if (u3.length === 0)
          return ["(", sC2(e3, t3, true), ")"];
        if (function(e4) {
          return e4.length === 2 && e4[0].type === "ArrowFunctionExpression" && lC2(e4[0]).length === 0 && e4[0].body.type === "BlockStatement" && e4[1].type === "ArrayExpression" && !e4.some((e5) => pC2(e5));
        }(u3))
          return ["(", n3(["arguments", 0]), ", ", n3(["arguments", 1]), ")"];
        let o3 = false, s3 = false;
        const a3 = u3.length - 1, c3 = [];
        DC2(e3, (e4, r4) => {
          const i4 = e4.getNode(), u4 = [n3()];
          r4 === a3 || (EC2(i4, t3) ? (r4 === 0 && (s3 = true), o3 = true, u4.push(",", FC2, FC2)) : u4.push(",", vC2)), c3.push(u4);
        });
        const l3 = i3 || r3.callee && r3.callee.type === "Import" || !mC2(t3, "all") ? "" : ",";
        function p3() {
          return SC2(["(", wC2([vC2, ...c3]), l3, vC2, ")"], { shouldBreak: true });
        }
        if (o3 || e3.getParentNode().type !== "Decorator" && dC2(u3))
          return p3();
        const f3 = function(e4) {
          if (e4.length !== 2)
            return false;
          const [t4, n4] = e4;
          if (t4.type === "ModuleExpression" && function(e5) {
            return e5.type === "ObjectExpression" && e5.properties.length === 1 && AC2(e5.properties[0]) && e5.properties[0].key.type === "Identifier" && e5.properties[0].key.name === "type" && bC2(e5.properties[0].value) && e5.properties[0].value.value === "module";
          }(n4))
            return true;
          return !pC2(t4) && (t4.type === "FunctionExpression" || t4.type === "ArrowFunctionExpression" && t4.body.type === "BlockStatement") && n4.type !== "FunctionExpression" && n4.type !== "ArrowFunctionExpression" && n4.type !== "ConditionalExpression" && !IC2(n4);
        }(u3), d3 = function(e4, t4) {
          const n4 = aC2(e4), r4 = cC2(e4);
          return !pC2(n4, fC2.Leading) && !pC2(n4, fC2.Trailing) && IC2(n4) && (!r4 || r4.type !== n4.type) && (e4.length !== 2 || r4.type !== "ArrowFunctionExpression" || n4.type !== "ArrayExpression") && !(e4.length > 1 && n4.type === "ArrayExpression" && OC2(n4, t4));
        }(u3, t3);
        if (f3 || d3) {
          if (f3 ? c3.slice(1).some(kC2) : c3.slice(0, -1).some(kC2))
            return p3();
          let t4 = [];
          try {
            e3.try(() => {
              DC2(e3, (e4, r4) => {
                f3 && r4 === 0 && (t4 = [[n3([], { expandFirstArg: true }), c3.length > 1 ? "," : "", s3 ? FC2 : vC2, s3 ? FC2 : ""], ...c3.slice(1)]), d3 && r4 === a3 && (t4 = [...c3.slice(0, -1), n3([], { expandLastArg: true })]);
              });
            });
          } catch (e4) {
            if (e4 instanceof PC2)
              return p3();
            throw e4;
          }
          return [c3.some(kC2) ? NC2 : "", TC2([["(", ...t4, ")"], f3 ? ["(", SC2(t4[0], { shouldBreak: true }), ...t4.slice(1), ")"] : ["(", ...c3.slice(0, -1), SC2(aC2(t4), { shouldBreak: true }), ")"], p3()])];
        }
        const h3 = ["(", wC2([xC2, ...c3]), BC2(l3), xC2, ")"];
        return gC2(e3) ? h3 : SC2(h3, { shouldBreak: c3.some(kC2) || o3 });
      };
      const { builders: { softline: jC2, group: _C2, indent: MC2, label: RC2 } } = su2, { isNumericLiteral: $C2, isMemberExpression: VC2, isCallExpression: WC2 } = eg2, { printOptionalToken: qC2 } = _E2;
      function UC2(e3, t3, n3) {
        const r3 = n3("property"), i3 = e3.getValue(), u3 = qC2(e3);
        return i3.computed ? !i3.property || $C2(i3.property) ? [u3, "[", r3, "]"] : _C2([u3, "[", MC2([jC2, r3]), jC2, "]"]) : [u3, ".", r3];
      }
      var zC2 = { printMemberExpression: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = e3.getParentNode();
        let u3, o3 = 0;
        do {
          u3 = e3.getParentNode(o3), o3++;
        } while (u3 && (VC2(u3) || u3.type === "TSNonNullExpression"));
        const s3 = n3("object"), a3 = UC2(e3, t3, n3), c3 = u3 && (u3.type === "NewExpression" || u3.type === "BindExpression" || u3.type === "AssignmentExpression" && u3.left.type !== "Identifier") || r3.computed || r3.object.type === "Identifier" && r3.property.type === "Identifier" && !VC2(i3) || (i3.type === "AssignmentExpression" || i3.type === "VariableDeclarator") && (WC2(r3.object) && r3.object.arguments.length > 0 || r3.object.type === "TSNonNullExpression" && WC2(r3.object.expression) && r3.object.expression.arguments.length > 0 || s3.label === "member-chain");
        return RC2(s3.label === "member-chain" ? "member-chain" : "member", [s3, c3 ? a3 : _C2(MC2([jC2, a3]))]);
      }, printMemberLookup: UC2 };
      const { printComments: GC2 } = Yf2, { getLast: HC2, isNextLineEmptyAfterIndex: JC2, getNextNonSpaceNonCommentCharacterIndex: XC2 } = Fi2, { isCallExpression: YC2, isMemberExpression: KC2, isFunctionOrArrowExpression: QC2, isLongCurriedCallExpression: ZC2, isMemberish: eb2, isNumericLiteral: tb2, isSimpleCallArgument: nb2, hasComment: rb2, CommentCheckFlags: ib2, isNextLineEmpty: ub2 } = eg2, { locEnd: ob2 } = Zc2, { builders: { join: sb2, hardline: ab2, group: cb2, indent: lb2, conditionalGroup: pb2, breakParent: fb2, label: db2 }, utils: { willBreak: hb2 } } = su2, { printMemberLookup: gb2 } = zC2, { printOptionalToken: mb2, printFunctionTypeParameters: yb2, printBindExpressionCallee: Db2 } = _E2;
      var Eb2 = function(e3, t3, n3) {
        const r3 = e3.getParentNode(), i3 = !r3 || r3.type === "ExpressionStatement", u3 = [];
        function o3(e4) {
          const { originalText: n4 } = t3, r4 = XC2(n4, e4, ob2);
          return n4.charAt(r4) === ")" ? r4 !== false && JC2(n4, r4 + 1) : ub2(e4, t3);
        }
        function s3(e4) {
          const r4 = e4.getValue();
          YC2(r4) && (eb2(r4.callee) || YC2(r4.callee)) ? (u3.unshift({ node: r4, printed: [GC2(e4, [mb2(e4), yb2(e4, t3, n3), LC2(e4, t3, n3)], t3), o3(r4) ? ab2 : ""] }), e4.call((e5) => s3(e5), "callee")) : eb2(r4) ? (u3.unshift({ node: r4, needsParens: oD2(e4, t3), printed: GC2(e4, KC2(r4) ? gb2(e4, t3, n3) : Db2(e4, t3, n3), t3) }), e4.call((e5) => s3(e5), "object")) : r4.type === "TSNonNullExpression" ? (u3.unshift({ node: r4, printed: GC2(e4, "!", t3) }), e4.call((e5) => s3(e5), "expression")) : u3.unshift({ node: r4, printed: n3() });
        }
        const a3 = e3.getValue();
        u3.unshift({ node: a3, printed: [mb2(e3), yb2(e3, t3, n3), LC2(e3, t3, n3)] }), a3.callee && e3.call((e4) => s3(e4), "callee");
        const c3 = [];
        let l3 = [u3[0]], p3 = 1;
        for (; p3 < u3.length && (u3[p3].node.type === "TSNonNullExpression" || YC2(u3[p3].node) || KC2(u3[p3].node) && u3[p3].node.computed && tb2(u3[p3].node.property)); ++p3)
          l3.push(u3[p3]);
        if (!YC2(u3[0].node))
          for (; p3 + 1 < u3.length && (eb2(u3[p3].node) && eb2(u3[p3 + 1].node)); ++p3)
            l3.push(u3[p3]);
        c3.push(l3), l3 = [];
        let f3 = false;
        for (; p3 < u3.length; ++p3) {
          if (f3 && eb2(u3[p3].node)) {
            if (u3[p3].node.computed && tb2(u3[p3].node.property)) {
              l3.push(u3[p3]);
              continue;
            }
            c3.push(l3), l3 = [], f3 = false;
          }
          (YC2(u3[p3].node) || u3[p3].node.type === "ImportExpression") && (f3 = true), l3.push(u3[p3]), rb2(u3[p3].node, ib2.Trailing) && (c3.push(l3), l3 = [], f3 = false);
        }
        function d3(e4) {
          return /^[A-Z]|^[$_]+$/.test(e4);
        }
        l3.length > 0 && c3.push(l3);
        const h3 = c3.length >= 2 && !rb2(c3[1][0].node) && function(e4) {
          const n4 = e4[1].length > 0 && e4[1][0].node.computed;
          if (e4[0].length === 1) {
            const r5 = e4[0][0].node;
            return r5.type === "ThisExpression" || r5.type === "Identifier" && (d3(r5.name) || i3 && function(e5) {
              return e5.length <= t3.tabWidth;
            }(r5.name) || n4);
          }
          const r4 = HC2(e4[0]).node;
          return KC2(r4) && r4.property.type === "Identifier" && (d3(r4.property.name) || n4);
        }(c3);
        function g3(e4) {
          const t4 = e4.map((e5) => e5.printed);
          return e4.length > 0 && HC2(e4).needsParens ? ["(", ...t4, ")"] : t4;
        }
        const m3 = c3.map(g3), y3 = m3, D3 = h3 ? 3 : 2, E3 = c3.flat(), C3 = E3.slice(1, -1).some((e4) => rb2(e4.node, ib2.Leading)) || E3.slice(0, -1).some((e4) => rb2(e4.node, ib2.Trailing)) || c3[D3] && rb2(c3[D3][0].node, ib2.Leading);
        if (c3.length <= D3 && !C3)
          return ZC2(e3) ? y3 : cb2(y3);
        const b3 = HC2(c3[h3 ? 1 : 0]).node, A3 = !YC2(b3) && o3(b3), v3 = [g3(c3[0]), h3 ? c3.slice(1, 2).map(g3) : "", A3 ? ab2 : "", function(e4) {
          return e4.length === 0 ? "" : lb2(cb2([ab2, sb2(ab2, e4.map(g3))]));
        }(c3.slice(h3 ? 2 : 1))], F3 = u3.map(({ node: e4 }) => e4).filter(YC2);
        let x3;
        return x3 = C3 || F3.length > 2 && F3.some((e4) => !e4.arguments.every((e5) => nb2(e5, 0))) || m3.slice(0, -1).some(hb2) || function() {
          const e4 = HC2(HC2(c3)).node, t4 = HC2(m3);
          return YC2(e4) && hb2(t4) && F3.slice(0, -1).some((e5) => e5.arguments.some(QC2));
        }() ? cb2(v3) : [hb2(y3) || A3 ? fb2 : "", pb2([y3, v3])], db2("member-chain", x3);
      };
      const { builders: { join: Cb2, group: bb2 } } = su2, { getCallArguments: Ab2, hasFlowAnnotationComment: vb2, isCallExpression: Fb2, isMemberish: xb2, isStringLiteral: Sb2, isTemplateOnItsOwnLine: wb2, isTestCall: Tb2, iterateCallArgumentsPath: Bb2 } = eg2, { printOptionalToken: Nb2, printFunctionTypeParameters: kb2 } = _E2;
      var Pb2 = { printCallExpression: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = e3.getParentNode(), u3 = r3.type === "NewExpression", o3 = r3.type === "ImportExpression", s3 = Nb2(e3), a3 = Ab2(r3);
        if (a3.length > 0 && (!o3 && !u3 && function(e4, t4) {
          if (e4.callee.type !== "Identifier")
            return false;
          if (e4.callee.name === "require")
            return true;
          if (e4.callee.name === "define") {
            const n4 = Ab2(e4);
            return t4.type === "ExpressionStatement" && (n4.length === 1 || n4.length === 2 && n4[0].type === "ArrayExpression" || n4.length === 3 && Sb2(n4[0]) && n4[1].type === "ArrayExpression");
          }
          return false;
        }(r3, i3) || a3.length === 1 && wb2(a3[0], t3.originalText) || !u3 && Tb2(r3, i3))) {
          const r4 = [];
          return Bb2(e3, () => {
            r4.push(n3());
          }), [u3 ? "new " : "", n3("callee"), s3, kb2(e3, t3, n3), "(", Cb2(", ", r4), ")"];
        }
        const c3 = (t3.parser === "babel" || t3.parser === "babel-flow") && r3.callee && r3.callee.type === "Identifier" && vb2(r3.callee.trailingComments);
        if (c3 && (r3.callee.trailingComments[0].printed = true), !o3 && !u3 && xb2(r3.callee) && !e3.call((e4) => oD2(e4, t3), "callee"))
          return Eb2(e3, t3, n3);
        const l3 = [u3 ? "new " : "", o3 ? "import" : n3("callee"), s3, c3 ? `/*:: ${r3.callee.trailingComments[0].value.slice(2).trim()} */` : "", kb2(e3, t3, n3), LC2(e3, t3, n3)];
        return o3 || Fb2(r3.callee) ? bb2(l3) : l3;
      } };
      const { isNonEmptyArray: Ob2, getStringWidth: Ib2 } = Fi2, { builders: { line: Lb2, group: jb2, indent: _b2, indentIfBreak: Mb2 }, utils: { cleanDoc: Rb2, willBreak: $b2 } } = su2, { hasLeadingOwnLineComment: Vb2, isBinaryish: Wb2, isStringLiteral: qb2, isLiteral: Ub2, isNumericLiteral: zb2, isCallExpression: Gb2, isMemberExpression: Hb2, getCallArguments: Jb2, rawText: Xb2, hasComment: Yb2, isSignedNumericLiteral: Kb2, isObjectProperty: Qb2 } = eg2, { shouldInlineLogicalExpression: Zb2 } = RD2, { printCallExpression: eA2 } = Pb2;
      function tA2(e3, t3, n3, r3, i3, u3) {
        const o3 = function(e4, t4, n4, r4, i4) {
          const u4 = e4.getValue(), o4 = u4[i4];
          if (!o4)
            return "only-left";
          const s4 = !nA2(o4);
          if (e4.match(nA2, rA2, (e5) => !s4 || e5.type !== "ExpressionStatement" && e5.type !== "VariableDeclaration"))
            return s4 ? o4.type === "ArrowFunctionExpression" && o4.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
          if (!s4 && nA2(o4.right) || Vb2(t4.originalText, o4))
            return "break-after-operator";
          if (o4.type === "CallExpression" && o4.callee.name === "require" || t4.parser === "json5" || t4.parser === "json")
            return "never-break-after-operator";
          if (function(e5) {
            if (rA2(e5)) {
              const t5 = e5.left || e5.id;
              return t5.type === "ObjectPattern" && t5.properties.length > 2 && t5.properties.some((e6) => Qb2(e6) && (!e6.shorthand || e6.value && e6.value.type === "AssignmentPattern"));
            }
            return false;
          }(u4) || function(e5) {
            const t5 = function(e6) {
              if (function(e7) {
                return e7.type === "TSTypeAliasDeclaration" || e7.type === "TypeAlias";
              }(e6) && e6.typeParameters && e6.typeParameters.params)
                return e6.typeParameters.params;
              return null;
            }(e5);
            if (Ob2(t5)) {
              const n5 = e5.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (t5.length > 1 && t5.some((e6) => e6[n5] || e6.default))
                return true;
            }
            return false;
          }(u4) || function(e5) {
            if (e5.type !== "VariableDeclarator")
              return false;
            const { typeAnnotation: t5 } = e5.id;
            if (!t5 || !t5.typeAnnotation)
              return false;
            const n5 = iA2(t5.typeAnnotation);
            return Ob2(n5) && n5.length > 1 && n5.some((e6) => Ob2(iA2(e6)) || e6.type === "TSConditionalType");
          }(u4))
            return "break-lhs";
          const a3 = function(e5, t5, n5) {
            if (!Qb2(e5))
              return false;
            t5 = Rb2(t5);
            const r5 = 3;
            return typeof t5 == "string" && Ib2(t5) < n5.tabWidth + r5;
          }(u4, r4, t4);
          if (e4.call(() => function(e5, t5, n5, r5) {
            const i5 = e5.getValue();
            if (Wb2(i5) && !Zb2(i5))
              return true;
            switch (i5.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                const { test: e6 } = i5;
                return Wb2(e6) && !Zb2(e6);
              }
              case "ClassExpression":
                return Ob2(i5.decorators);
            }
            if (r5)
              return false;
            let u5 = i5;
            const o5 = [];
            for (; ; )
              if (u5.type === "UnaryExpression")
                u5 = u5.argument, o5.push("argument");
              else {
                if (u5.type !== "TSNonNullExpression")
                  break;
                u5 = u5.expression, o5.push("expression");
              }
            if (qb2(u5) || e5.call(() => uA2(e5, t5, n5), ...o5))
              return true;
            return false;
          }(e4, t4, n4, a3), i4))
            return "break-after-operator";
          if (a3 || o4.type === "TemplateLiteral" || o4.type === "TaggedTemplateExpression" || o4.type === "BooleanLiteral" || zb2(o4) || o4.type === "ClassExpression")
            return "never-break-after-operator";
          return "fluid";
        }(e3, t3, n3, r3, u3), s3 = n3(u3, { assignmentLayout: o3 });
        switch (o3) {
          case "break-after-operator":
            return jb2([jb2(r3), i3, jb2(_b2([Lb2, s3]))]);
          case "never-break-after-operator":
            return jb2([jb2(r3), i3, " ", s3]);
          case "fluid": {
            const e4 = Symbol("assignment");
            return jb2([jb2(r3), i3, jb2(_b2(Lb2), { id: e4 }), Mb2(s3, { groupId: e4 })]);
          }
          case "break-lhs":
            return jb2([r3, i3, " ", jb2(s3)]);
          case "chain":
            return [jb2(r3), i3, Lb2, s3];
          case "chain-tail":
            return [jb2(r3), i3, _b2([Lb2, s3])];
          case "chain-tail-arrow-chain":
            return [jb2(r3), i3, s3];
          case "only-left":
            return r3;
        }
      }
      function nA2(e3) {
        return e3.type === "AssignmentExpression";
      }
      function rA2(e3) {
        return nA2(e3) || e3.type === "VariableDeclarator";
      }
      function iA2(e3) {
        return function(e4) {
          return e4.type === "TSTypeReference" || e4.type === "GenericTypeAnnotation";
        }(e3) && e3.typeParameters && e3.typeParameters.params ? e3.typeParameters.params : null;
      }
      function uA2(e3, t3, n3, r3 = false) {
        const i3 = e3.getValue(), u3 = () => uA2(e3, t3, n3, true);
        if (i3.type === "TSNonNullExpression")
          return e3.call(u3, "expression");
        if (Gb2(i3)) {
          if (eA2(e3, t3, n3).label === "member-chain")
            return false;
          const r4 = Jb2(i3);
          return !!(r4.length === 0 || r4.length === 1 && function(e4, { printWidth: t4 }) {
            if (Yb2(e4))
              return false;
            const n4 = 0.25 * t4;
            if (e4.type === "ThisExpression" || e4.type === "Identifier" && e4.name.length <= n4 || Kb2(e4) && !Yb2(e4.argument))
              return true;
            const r5 = e4.type === "Literal" && "regex" in e4 && e4.regex.pattern || e4.type === "RegExpLiteral" && e4.pattern;
            if (r5)
              return r5.length <= n4;
            if (qb2(e4))
              return Xb2(e4).length <= n4;
            if (e4.type === "TemplateLiteral")
              return e4.expressions.length === 0 && e4.quasis[0].value.raw.length <= n4 && !e4.quasis[0].value.raw.includes("\n");
            return Ub2(e4);
          }(r4[0], t3)) && (!function(e4, t4) {
            const n4 = function(e5) {
              return e5.typeParameters && e5.typeParameters.params || e5.typeArguments && e5.typeArguments.params;
            }(e4);
            if (Ob2(n4)) {
              if (n4.length > 1)
                return true;
              if (n4.length === 1) {
                const e5 = n4[0];
                if (e5.type === "TSUnionType" || e5.type === "UnionTypeAnnotation" || e5.type === "TSIntersectionType" || e5.type === "IntersectionTypeAnnotation")
                  return true;
              }
              const r5 = e4.typeParameters ? "typeParameters" : "typeArguments";
              if ($b2(t4(r5)))
                return true;
            }
            return false;
          }(i3, n3) && e3.call(u3, "callee"));
        }
        return Hb2(i3) ? e3.call(u3, "object") : r3 && (i3.type === "Identifier" || i3.type === "ThisExpression");
      }
      var oA2 = { printVariableDeclarator: function(e3, t3, n3) {
        return tA2(e3, t3, n3, n3("id"), " =", "init");
      }, printAssignmentExpression: function(e3, t3, n3) {
        const r3 = e3.getValue();
        return tA2(e3, t3, n3, n3("left"), [" ", r3.operator], "right");
      }, printAssignment: tA2 };
      const { getNextNonSpaceNonCommentCharacter: sA2 } = Fi2, { printDanglingComments: aA2 } = Yf2, { builders: { line: cA2, hardline: lA2, softline: pA2, group: fA2, indent: dA2, ifBreak: hA2 }, utils: { removeLines: gA2, willBreak: mA2 } } = su2, { getFunctionParameters: yA2, iterateFunctionParametersPath: DA2, isSimpleType: EA2, isTestCall: CA2, isTypeAnnotationAFunction: bA2, isObjectType: AA2, isObjectTypePropertyAFunction: vA2, hasRestParameter: FA2, shouldPrintComma: xA2, hasComment: SA2, isNextLineEmpty: wA2 } = eg2, { locEnd: TA2 } = Zc2, { ArgExpansionBailout: BA2 } = Bo2, { printFunctionTypeParameters: NA2 } = _E2;
      function kA2(e3) {
        if (!e3)
          return false;
        const t3 = yA2(e3);
        if (t3.length !== 1)
          return false;
        const [n3] = t3;
        return !SA2(n3) && (n3.type === "ObjectPattern" || n3.type === "ArrayPattern" || n3.type === "Identifier" && n3.typeAnnotation && (n3.typeAnnotation.type === "TypeAnnotation" || n3.typeAnnotation.type === "TSTypeAnnotation") && AA2(n3.typeAnnotation.typeAnnotation) || n3.type === "FunctionTypeParam" && AA2(n3.typeAnnotation) || n3.type === "AssignmentPattern" && (n3.left.type === "ObjectPattern" || n3.left.type === "ArrayPattern") && (n3.right.type === "Identifier" || n3.right.type === "ObjectExpression" && n3.right.properties.length === 0 || n3.right.type === "ArrayExpression" && n3.right.elements.length === 0));
      }
      var PA2 = { printFunctionParameters: function(e3, t3, n3, r3, i3) {
        const u3 = e3.getValue(), o3 = yA2(u3), s3 = i3 ? NA2(e3, n3, t3) : "";
        if (o3.length === 0)
          return [s3, "(", aA2(e3, n3, true, (e4) => sA2(n3.originalText, e4, TA2) === ")"), ")"];
        const a3 = e3.getParentNode(), c3 = CA2(a3), l3 = kA2(u3), p3 = [];
        if (DA2(e3, (e4, r4) => {
          const i4 = r4 === o3.length - 1;
          i4 && u3.rest && p3.push("..."), p3.push(t3()), i4 || (p3.push(","), c3 || l3 ? p3.push(" ") : wA2(o3[r4], n3) ? p3.push(lA2, lA2) : p3.push(cA2));
        }), r3) {
          if (mA2(s3) || mA2(p3))
            throw new BA2();
          return fA2([gA2(s3), "(", gA2(p3), ")"]);
        }
        const f3 = o3.every((e4) => !e4.decorators);
        return l3 && f3 || c3 ? [s3, "(", ...p3, ")"] : (vA2(a3) || bA2(a3) || a3.type === "TypeAlias" || a3.type === "UnionTypeAnnotation" || a3.type === "TSUnionType" || a3.type === "IntersectionTypeAnnotation" || a3.type === "FunctionTypeAnnotation" && a3.returnType === u3) && o3.length === 1 && o3[0].name === null && u3.this !== o3[0] && o3[0].typeAnnotation && u3.typeParameters === null && EA2(o3[0].typeAnnotation) && !u3.rest ? n3.arrowParens === "always" ? ["(", ...p3, ")"] : p3 : [s3, "(", dA2([pA2, ...p3]), hA2(!FA2(u3) && xA2(n3, "all") ? "," : ""), pA2, ")"];
      }, shouldHugFunctionParameters: kA2, shouldGroupFunctionParameters: function(e3, t3) {
        const n3 = function(e4) {
          let t4;
          return e4.returnType ? (t4 = e4.returnType, t4.typeAnnotation && (t4 = t4.typeAnnotation)) : e4.typeAnnotation && (t4 = e4.typeAnnotation), t4;
        }(e3);
        if (!n3)
          return false;
        const r3 = e3.typeParameters && e3.typeParameters.params;
        if (r3) {
          if (r3.length > 1)
            return false;
          if (r3.length === 1) {
            const e4 = r3[0];
            if (e4.constraint || e4.default)
              return false;
          }
        }
        return yA2(e3).length === 1 && (AA2(n3) || mA2(t3));
      } };
      const { printComments: OA2, printDanglingComments: IA2 } = Yf2, { getLast: LA2 } = Fi2, { builders: { group: jA2, join: _A2, line: MA2, softline: RA2, indent: $A2, align: VA2, ifBreak: WA2 } } = su2, { locStart: qA2 } = Zc2, { isSimpleType: UA2, isObjectType: zA2, hasLeadingOwnLineComment: GA2, isObjectTypePropertyAFunction: HA2, shouldPrintComma: JA2 } = eg2, { printAssignment: XA2 } = oA2, { printFunctionParameters: YA2, shouldGroupFunctionParameters: KA2 } = PA2, { printArrayItems: QA2 } = oC2;
      function ZA2(e3) {
        if (UA2(e3) || zA2(e3))
          return true;
        if (e3.type === "UnionTypeAnnotation" || e3.type === "TSUnionType") {
          const t3 = e3.types.filter((e4) => e4.type === "VoidTypeAnnotation" || e4.type === "TSVoidKeyword" || e4.type === "NullLiteralTypeAnnotation" || e4.type === "TSNullKeyword").length, n3 = e3.types.some((e4) => e4.type === "ObjectTypeAnnotation" || e4.type === "TSTypeLiteral" || e4.type === "GenericTypeAnnotation" || e4.type === "TSTypeReference");
          if (e3.types.length - 1 === t3 && n3)
            return true;
        }
        return false;
      }
      var ev2 = { printOpaqueType: function(e3, t3, n3) {
        const r3 = t3.semi ? ";" : "", i3 = e3.getValue(), u3 = [];
        return u3.push("opaque type ", n3("id"), n3("typeParameters")), i3.supertype && u3.push(": ", n3("supertype")), i3.impltype && u3.push(" = ", n3("impltype")), u3.push(r3), u3;
      }, printTypeAlias: function(e3, t3, n3) {
        const r3 = t3.semi ? ";" : "", i3 = e3.getValue(), u3 = [];
        i3.declare && u3.push("declare "), u3.push("type ", n3("id"), n3("typeParameters"));
        const o3 = i3.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
        return [XA2(e3, t3, n3, u3, " =", o3), r3];
      }, printIntersectionType: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = e3.map(n3, "types"), u3 = [];
        let o3 = false;
        for (let e4 = 0; e4 < i3.length; ++e4)
          e4 === 0 ? u3.push(i3[e4]) : zA2(r3.types[e4 - 1]) && zA2(r3.types[e4]) ? u3.push([" & ", o3 ? $A2(i3[e4]) : i3[e4]]) : zA2(r3.types[e4 - 1]) || zA2(r3.types[e4]) ? (e4 > 1 && (o3 = true), u3.push(" & ", e4 > 1 ? $A2(i3[e4]) : i3[e4])) : u3.push($A2([" &", MA2, i3[e4]]));
        return jA2(u3);
      }, printUnionType: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = e3.getParentNode(), u3 = !(i3.type === "TypeParameterInstantiation" || i3.type === "TSTypeParameterInstantiation" || i3.type === "GenericTypeAnnotation" || i3.type === "TSTypeReference" || i3.type === "TSTypeAssertion" || i3.type === "TupleTypeAnnotation" || i3.type === "TSTupleType" || i3.type === "FunctionTypeParam" && !i3.name && e3.getParentNode(1).this !== i3 || (i3.type === "TypeAlias" || i3.type === "VariableDeclarator" || i3.type === "TSTypeAliasDeclaration") && GA2(t3.originalText, r3)), o3 = ZA2(r3), s3 = e3.map((e4) => {
          let r4 = n3();
          return o3 || (r4 = VA2(2, r4)), OA2(e4, r4, t3);
        }, "types");
        if (o3)
          return _A2(" | ", s3);
        const a3 = u3 && !GA2(t3.originalText, r3), c3 = [WA2([a3 ? MA2 : "", "| "]), _A2([MA2, "| "], s3)];
        return oD2(e3, t3) ? jA2([$A2(c3), RA2]) : i3.type === "TupleTypeAnnotation" && i3.types.length > 1 || i3.type === "TSTupleType" && i3.elementTypes.length > 1 ? jA2([$A2([WA2(["(", RA2]), c3]), RA2, WA2(")")]) : jA2(u3 ? $A2(c3) : c3);
      }, printFunctionType: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [], u3 = e3.getParentNode(0), o3 = e3.getParentNode(1), s3 = e3.getParentNode(2);
        let a3 = r3.type === "TSFunctionType" || !((u3.type === "ObjectTypeProperty" || u3.type === "ObjectTypeInternalSlot") && !u3.variance && !u3.optional && qA2(u3) === qA2(r3) || u3.type === "ObjectTypeCallProperty" || s3 && s3.type === "DeclareFunction"), c3 = a3 && (u3.type === "TypeAnnotation" || u3.type === "TSTypeAnnotation");
        const l3 = c3 && a3 && (u3.type === "TypeAnnotation" || u3.type === "TSTypeAnnotation") && o3.type === "ArrowFunctionExpression";
        HA2(u3) && (a3 = true, c3 = true), l3 && i3.push("(");
        const p3 = YA2(e3, n3, t3, false, true), f3 = r3.returnType || r3.predicate || r3.typeAnnotation ? [a3 ? " => " : ": ", n3("returnType"), n3("predicate"), n3("typeAnnotation")] : "", d3 = KA2(r3, f3);
        return i3.push(d3 ? jA2(p3) : p3), f3 && i3.push(f3), l3 && i3.push(")"), jA2(i3);
      }, printTupleType: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.type === "TSTupleType" ? "elementTypes" : "types", u3 = r3[i3].length > 0 && LA2(r3[i3]).type === "TSRestType";
        return jA2(["[", $A2([RA2, QA2(e3, t3, i3, n3)]), WA2(JA2(t3, "all") && !u3 ? "," : ""), IA2(e3, t3, true), RA2, "]"]);
      }, printIndexedAccessType: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.type === "OptionalIndexedAccessType" && r3.optional ? "?.[" : "[";
        return [n3("objectType"), i3, n3("indexType"), "]"];
      }, shouldHugType: ZA2 };
      const { printDanglingComments: tv2 } = Yf2, { builders: { join: nv2, line: rv2, hardline: iv2, softline: uv2, group: ov2, indent: sv2, ifBreak: av2 } } = su2, { isTestCall: cv2, hasComment: lv2, CommentCheckFlags: pv2, isTSXFile: fv2, shouldPrintComma: dv2, getFunctionParameters: hv2 } = eg2, { createGroupIdMapper: gv2 } = Fi2, { shouldHugType: mv2 } = ev2, yv2 = gv2("typeParameters");
      function Dv2(e3, t3) {
        const n3 = e3.getValue();
        if (!lv2(n3, pv2.Dangling))
          return "";
        const r3 = !lv2(n3, pv2.Line), i3 = tv2(e3, t3, r3);
        return r3 ? i3 : [i3, iv2];
      }
      var Ev2 = { printTypeParameter: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [], u3 = e3.getParentNode();
        return u3.type === "TSMappedType" ? (i3.push("[", n3("name")), r3.constraint && i3.push(" in ", n3("constraint")), u3.nameType && i3.push(" as ", e3.callParent(() => n3("nameType"))), i3.push("]"), i3) : (r3.variance && i3.push(n3("variance")), i3.push(n3("name")), r3.bound && i3.push(": ", n3("bound")), r3.constraint && i3.push(" extends ", n3("constraint")), r3.default && i3.push(" = ", n3("default")), i3);
      }, printTypeParameters: function(e3, t3, n3, r3) {
        const i3 = e3.getValue();
        if (!i3[r3])
          return "";
        if (!Array.isArray(i3[r3]))
          return n3(r3);
        const u3 = e3.getNode(2);
        if (u3 && cv2(u3) || i3[r3].length === 0 || i3[r3].length === 1 && (mv2(i3[r3][0]) || i3[r3][0].type === "NullableTypeAnnotation"))
          return ["<", nv2(", ", e3.map(n3, r3)), Dv2(e3, t3), ">"];
        const o3 = i3.type === "TSTypeParameterInstantiation" ? "" : hv2(i3).length === 1 && fv2(t3) && !i3[r3][0].constraint && e3.getParentNode().type === "ArrowFunctionExpression" ? "," : dv2(t3, "all") ? av2(",") : "";
        return ov2(["<", sv2([uv2, nv2([",", rv2], e3.map(n3, r3))]), o3, uv2, ">"], { id: yv2(i3) });
      }, getTypeParametersGroupId: yv2 };
      const { printComments: Cv2 } = Yf2, { printString: bv2, printNumber: Av2 } = Fi2, { isNumericLiteral: vv2, isSimpleNumber: Fv2, isStringLiteral: xv2, isStringPropSafeToUnquote: Sv2, rawText: wv2 } = eg2, { printAssignment: Tv2 } = oA2, Bv2 = new WeakMap();
      function Nv2(e3, t3, n3) {
        const r3 = e3.getNode();
        if (r3.computed)
          return ["[", n3("key"), "]"];
        const i3 = e3.getParentNode(), { key: u3 } = r3;
        if (r3.type === "ClassPrivateProperty" && u3.type === "Identifier")
          return ["#", n3("key")];
        if (t3.quoteProps === "consistent" && !Bv2.has(i3)) {
          const e4 = (i3.properties || i3.body || i3.members).some((e5) => !e5.computed && e5.key && xv2(e5.key) && !Sv2(e5, t3));
          Bv2.set(i3, e4);
        }
        if ((u3.type === "Identifier" || vv2(u3) && Fv2(Av2(wv2(u3))) && String(u3.value) === Av2(wv2(u3)) && t3.parser !== "typescript" && t3.parser !== "babel-ts") && (t3.parser === "json" || t3.quoteProps === "consistent" && Bv2.get(i3))) {
          const n4 = bv2(JSON.stringify(u3.type === "Identifier" ? u3.name : u3.value.toString()), t3);
          return e3.call((e4) => Cv2(e4, n4, t3), "key");
        }
        return Sv2(r3, t3) && (t3.quoteProps === "as-needed" || t3.quoteProps === "consistent" && !Bv2.get(i3)) ? e3.call((e4) => Cv2(e4, /^\d/.test(u3.value) ? Av2(u3.value) : u3.value, t3), "key") : n3("key");
      }
      var kv2 = { printProperty: function(e3, t3, n3) {
        return e3.getValue().shorthand ? n3("value") : Tv2(e3, t3, n3, Nv2(e3, t3, n3), ":", "value");
      }, printPropertyKey: Nv2 };
      const { printDanglingComments: Pv2, printCommentsSeparately: Ov2 } = Yf2, { getNextNonSpaceNonCommentCharacterIndex: Iv2 } = Fi2, { builders: { line: Lv2, softline: jv2, group: _v2, indent: Mv2, ifBreak: Rv2, hardline: $v2, join: Vv2, indentIfBreak: Wv2 }, utils: { removeLines: qv2, willBreak: Uv2 } } = su2, { ArgExpansionBailout: zv2 } = Bo2, { getFunctionParameters: Gv2, hasLeadingOwnLineComment: Hv2, isFlowAnnotationComment: Jv2, isJsxNode: Xv2, isTemplateOnItsOwnLine: Yv2, shouldPrintComma: Kv2, startsWithNoLookaheadToken: Qv2, isBinaryish: Zv2, isLineComment: eF2, hasComment: tF2, getComments: nF2, CommentCheckFlags: rF2, isCallLikeExpression: iF2, isCallExpression: uF2, getCallArguments: oF2, hasNakedLeftSide: sF2, getLeftSide: aF2 } = eg2, { locEnd: cF2 } = Zc2, { printFunctionParameters: lF2, shouldGroupFunctionParameters: pF2 } = PA2, { printPropertyKey: fF2 } = kv2, { printFunctionTypeParameters: dF2 } = _E2;
      function hF2(e3, t3, n3) {
        const r3 = e3.getNode(), i3 = lF2(e3, n3, t3), u3 = mF2(e3, n3, t3), o3 = pF2(r3, u3), s3 = [dF2(e3, t3, n3), _v2([o3 ? _v2(i3) : i3, u3])];
        return r3.body ? s3.push(" ", n3("body")) : s3.push(t3.semi ? ";" : ""), s3;
      }
      function gF2(e3, t3) {
        if (t3.arrowParens === "always")
          return false;
        if (t3.arrowParens === "avoid") {
          return function(e4) {
            const t4 = Gv2(e4);
            return !(t4.length !== 1 || e4.typeParameters || tF2(e4, rF2.Dangling) || t4[0].type !== "Identifier" || t4[0].typeAnnotation || tF2(t4[0]) || t4[0].optional || e4.predicate || e4.returnType);
          }(e3.getValue());
        }
        return false;
      }
      function mF2(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = t3("returnType");
        if (r3.returnType && Jv2(n3.originalText, r3.returnType))
          return [" /*: ", i3, " */"];
        const u3 = [i3];
        return r3.returnType && r3.returnType.typeAnnotation && u3.unshift(": "), r3.predicate && u3.push(r3.returnType ? " " : ": ", t3("predicate")), u3;
      }
      function yF2(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = t3.semi ? ";" : "", u3 = [];
        r3.argument && (!function(e4, t4) {
          if (Hv2(e4.originalText, t4))
            return true;
          if (sF2(t4)) {
            let n4, r4 = t4;
            for (; n4 = aF2(r4); )
              if (r4 = n4, Hv2(e4.originalText, r4))
                return true;
          }
          return false;
        }(t3, r3.argument) ? Zv2(r3.argument) || r3.argument.type === "SequenceExpression" ? u3.push(_v2([Rv2(" (", " "), Mv2([jv2, n3("argument")]), jv2, Rv2(")")])) : u3.push(" ", n3("argument")) : u3.push([" (", Mv2([$v2, n3("argument")]), $v2, ")"]));
        const o3 = nF2(r3), s3 = _n2(o3), a3 = s3 && eF2(s3);
        return a3 && u3.push(i3), tF2(r3, rF2.Dangling) && u3.push(" ", Pv2(e3, t3, true)), a3 || u3.push(i3), u3;
      }
      var DF2 = { printFunction: function(e3, t3, n3, r3) {
        const i3 = e3.getValue();
        let u3 = false;
        if ((i3.type === "FunctionDeclaration" || i3.type === "FunctionExpression") && r3 && r3.expandLastArg) {
          const t4 = e3.getParentNode();
          uF2(t4) && oF2(t4).length > 1 && (u3 = true);
        }
        const o3 = [];
        i3.type === "TSDeclareFunction" && i3.declare && o3.push("declare "), i3.async && o3.push("async "), i3.generator ? o3.push("function* ") : o3.push("function "), i3.id && o3.push(t3("id"));
        const s3 = lF2(e3, t3, n3, u3), a3 = mF2(e3, t3, n3), c3 = pF2(i3, a3);
        return o3.push(dF2(e3, n3, t3), _v2([c3 ? _v2(s3) : s3, a3]), i3.body ? " " : "", t3("body")), !n3.semi || !i3.declare && i3.body || o3.push(";"), o3;
      }, printArrowFunction: function(e3, t3, n3, r3) {
        let i3 = e3.getValue();
        const u3 = [], o3 = [];
        let s3 = false;
        if (function a4() {
          const c4 = function(e4, t4, n4, r4) {
            const i4 = [];
            if (e4.getValue().async && i4.push("async "), gF2(e4, t4))
              i4.push(n4(["params", 0]));
            else {
              const u5 = r4 && (r4.expandLastArg || r4.expandFirstArg);
              let o4 = mF2(e4, n4, t4);
              if (u5) {
                if (Uv2(o4))
                  throw new zv2();
                o4 = _v2(qv2(o4));
              }
              i4.push(_v2([lF2(e4, n4, t4, u5, true), o4]));
            }
            const u4 = Pv2(e4, t4, true, (e5) => {
              const n5 = Iv2(t4.originalText, e5, cF2);
              return n5 !== false && t4.originalText.slice(n5, n5 + 2) === "=>";
            });
            return u4 && i4.push(" ", u4), i4;
          }(e3, t3, n3, r3);
          if (u3.length === 0)
            u3.push(c4);
          else {
            const { leading: n4, trailing: r4 } = Ov2(e3, t3);
            u3.push([n4, c4]), o3.unshift(r4);
          }
          s3 = s3 || i3.returnType && Gv2(i3).length > 0 || i3.typeParameters || Gv2(i3).some((e4) => e4.type !== "Identifier"), i3.body.type !== "ArrowFunctionExpression" || r3 && r3.expandLastArg ? o3.unshift(n3("body", r3)) : (i3 = i3.body, e3.call(a4, "body"));
        }(), u3.length > 1)
          return function(e4, t4, n4, r4, i4, u4) {
            const o4 = e4.getName(), s4 = e4.getParentNode(), a4 = iF2(s4) && o4 === "callee", c4 = Boolean(t4 && t4.assignmentLayout), l4 = u4.body.type !== "BlockStatement" && u4.body.type !== "ObjectExpression", p4 = a4 && l4 || t4 && t4.assignmentLayout === "chain-tail-arrow-chain", f3 = Symbol("arrow-chain");
            return _v2([_v2(Mv2([a4 || c4 ? jv2 : "", _v2(Vv2([" =>", Lv2], n4), { shouldBreak: r4 })]), { id: f3, shouldBreak: p4 }), " =>", Wv2(l4 ? Mv2([Lv2, i4]) : [" ", i4], { groupId: f3 }), a4 ? Rv2(jv2, "", { groupId: f3 }) : ""]);
          }(e3, r3, u3, s3, o3, i3);
        const a3 = u3;
        if (a3.push(" =>"), !Hv2(t3.originalText, i3.body) && (i3.body.type === "ArrayExpression" || i3.body.type === "ObjectExpression" || i3.body.type === "BlockStatement" || Xv2(i3.body) || Yv2(i3.body, t3.originalText) || i3.body.type === "ArrowFunctionExpression" || i3.body.type === "DoExpression"))
          return _v2([...a3, " ", o3]);
        if (i3.body.type === "SequenceExpression")
          return _v2([...a3, _v2([" (", Mv2([jv2, o3]), jv2, ")"])]);
        const c3 = (r3 && r3.expandLastArg || e3.getParentNode().type === "JSXExpressionContainer") && !tF2(i3), l3 = r3 && r3.expandLastArg && Kv2(t3, "all"), p3 = i3.body.type === "ConditionalExpression" && !Qv2(i3.body, false);
        return _v2([...a3, _v2([Mv2([Lv2, p3 ? Rv2("", "(") : "", o3, p3 ? Rv2("", ")") : ""]), c3 ? [Rv2(l3 ? "," : ""), jv2] : ""])]);
      }, printMethod: function(e3, t3, n3) {
        const r3 = e3.getNode(), { kind: i3 } = r3, u3 = r3.value || r3, o3 = [];
        return i3 && i3 !== "init" && i3 !== "method" && i3 !== "constructor" ? (Ff2.ok(i3 === "get" || i3 === "set"), o3.push(i3, " ")) : u3.async && o3.push("async "), u3.generator && o3.push("*"), o3.push(fF2(e3, t3, n3), r3.optional || r3.key.optional ? "?" : ""), r3 === u3 ? o3.push(hF2(e3, t3, n3)) : u3.type === "FunctionExpression" ? o3.push(e3.call((e4) => hF2(e4, t3, n3), "value")) : o3.push(n3("value")), o3;
      }, printReturnStatement: function(e3, t3, n3) {
        return ["return", yF2(e3, t3, n3)];
      }, printThrowStatement: function(e3, t3, n3) {
        return ["throw", yF2(e3, t3, n3)];
      }, printMethodInternal: hF2, shouldPrintParamsWithoutParens: gF2 };
      const { isNonEmptyArray: EF2, hasNewline: CF2 } = Fi2, { builders: { line: bF2, hardline: AF2, join: vF2, breakParent: FF2, group: xF2 } } = su2, { locStart: SF2, locEnd: wF2 } = Zc2, { getParentExportDeclaration: TF2 } = eg2;
      function BF2(e3, t3) {
        return e3.decorators.some((e4) => CF2(t3.originalText, wF2(e4)));
      }
      function NF2(e3) {
        if (e3.type !== "ExportDefaultDeclaration" && e3.type !== "ExportNamedDeclaration" && e3.type !== "DeclareExportDeclaration")
          return false;
        const t3 = e3.declaration && e3.declaration.decorators;
        return EF2(t3) && SF2(e3, { ignoreDecorators: true }) > SF2(t3[0]);
      }
      var kF2 = { printDecorators: function(e3, t3, n3) {
        const r3 = e3.getValue(), { decorators: i3 } = r3;
        if (!EF2(i3) || NF2(e3.getParentNode()))
          return;
        const u3 = r3.type === "ClassExpression" || r3.type === "ClassDeclaration" || BF2(r3, t3);
        return [TF2(e3) ? AF2 : u3 ? FF2 : "", vF2(bF2, e3.map(n3, "decorators")), bF2];
      }, printClassMemberDecorators: function(e3, t3, n3) {
        const r3 = e3.getValue();
        return xF2([vF2(bF2, e3.map(n3, "decorators")), BF2(r3, t3) ? AF2 : bF2]);
      }, printDecoratorsBeforeExport: function(e3, t3, n3) {
        return [vF2(AF2, e3.map(n3, "declaration", "decorators")), AF2];
      }, hasDecoratorsBeforeExport: NF2 };
      const { isNonEmptyArray: PF2, createGroupIdMapper: OF2 } = Fi2, { printComments: IF2, printDanglingComments: LF2 } = Yf2, { builders: { join: jF2, line: _F2, hardline: MF2, softline: RF2, group: $F2, indent: VF2, ifBreak: WF2 } } = su2, { hasComment: qF2, CommentCheckFlags: UF2 } = eg2, { getTypeParametersGroupId: zF2 } = Ev2, { printMethod: GF2 } = DF2, { printOptionalToken: HF2, printTypeAnnotation: JF2 } = _E2, { printPropertyKey: XF2 } = kv2, { printAssignment: YF2 } = oA2, { printClassMemberDecorators: KF2 } = kF2;
      const QF2 = OF2("heritageGroup");
      function ZF2(e3) {
        return e3.typeParameters && !qF2(e3.typeParameters, UF2.Trailing | UF2.Line) && !function(e4) {
          return ["superClass", "extends", "mixins", "implements"].filter((t3) => Boolean(e4[t3])).length > 1;
        }(e3);
      }
      function ex2(e3, t3, n3, r3) {
        const i3 = e3.getValue();
        if (!PF2(i3[r3]))
          return "";
        const u3 = LF2(e3, t3, true, ({ marker: e4 }) => e4 === r3);
        return [ZF2(i3) ? WF2(" ", _F2, { groupId: zF2(i3.typeParameters) }) : _F2, u3, u3 && MF2, r3, $F2(VF2([_F2, jF2([",", _F2], e3.map(n3, r3))]))];
      }
      function tx2(e3, t3, n3) {
        const r3 = n3("superClass");
        return e3.getParentNode().type === "AssignmentExpression" ? $F2(WF2(["(", VF2([RF2, r3]), RF2, ")"], r3)) : r3;
      }
      var nx2 = { printClass: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [];
        r3.declare && i3.push("declare "), r3.abstract && i3.push("abstract "), i3.push("class");
        const u3 = r3.id && qF2(r3.id, UF2.Trailing) || r3.superClass && qF2(r3.superClass) || PF2(r3.extends) || PF2(r3.mixins) || PF2(r3.implements), o3 = [], s3 = [];
        if (r3.id && o3.push(" ", n3("id")), o3.push(n3("typeParameters")), r3.superClass) {
          const r4 = ["extends ", tx2(e3, t3, n3), n3("superTypeParameters")], i4 = e3.call((e4) => IF2(e4, r4, t3), "superClass");
          u3 ? s3.push(_F2, $F2(i4)) : s3.push(" ", i4);
        } else
          s3.push(ex2(e3, t3, n3, "extends"));
        if (s3.push(ex2(e3, t3, n3, "mixins"), ex2(e3, t3, n3, "implements")), u3) {
          let e4;
          e4 = ZF2(r3) ? [...o3, VF2(s3)] : VF2([...o3, s3]), i3.push($F2(e4, { id: QF2(r3) }));
        } else
          i3.push(...o3, ...s3);
        return i3.push(" ", n3("body")), i3;
      }, printClassMethod: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [];
        return PF2(r3.decorators) && i3.push(KF2(e3, t3, n3)), r3.accessibility && i3.push(r3.accessibility + " "), r3.readonly && i3.push("readonly "), r3.declare && i3.push("declare "), r3.static && i3.push("static "), (r3.type === "TSAbstractMethodDefinition" || r3.abstract) && i3.push("abstract "), r3.override && i3.push("override "), i3.push(GF2(e3, t3, n3)), i3;
      }, printClassProperty: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [], u3 = t3.semi ? ";" : "";
        return PF2(r3.decorators) && i3.push(KF2(e3, t3, n3)), r3.accessibility && i3.push(r3.accessibility + " "), r3.declare && i3.push("declare "), r3.static && i3.push("static "), (r3.type === "TSAbstractClassProperty" || r3.abstract) && i3.push("abstract "), r3.override && i3.push("override "), r3.readonly && i3.push("readonly "), r3.variance && i3.push(n3("variance")), i3.push(XF2(e3, t3, n3), HF2(e3), JF2(e3, t3, n3)), [YF2(e3, t3, n3, i3, " =", "value"), u3];
      }, printHardlineAfterHeritage: function(e3) {
        return WF2(MF2, "", { groupId: QF2(e3) });
      } };
      const { isNonEmptyArray: rx2 } = Fi2, { builders: { join: ix2, line: ux2, group: ox2, indent: sx2, ifBreak: ax2 } } = su2, { hasComment: cx2, identity: lx2, CommentCheckFlags: px2 } = eg2, { getTypeParametersGroupId: fx2 } = Ev2, { printTypeScriptModifiers: dx2 } = _E2;
      var hx2 = { printInterface: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [];
        r3.declare && i3.push("declare "), r3.type === "TSInterfaceDeclaration" && i3.push(r3.abstract ? "abstract " : "", dx2(e3, t3, n3)), i3.push("interface");
        const u3 = [], o3 = [];
        r3.type !== "InterfaceTypeAnnotation" && u3.push(" ", n3("id"), n3("typeParameters"));
        const s3 = r3.typeParameters && !cx2(r3.typeParameters, px2.Trailing | px2.Line);
        return rx2(r3.extends) && o3.push(s3 ? ax2(" ", ux2, { groupId: fx2(r3.typeParameters) }) : ux2, "extends ", (r3.extends.length === 1 ? lx2 : sx2)(ix2([",", ux2], e3.map(n3, "extends")))), r3.id && cx2(r3.id, px2.Trailing) || rx2(r3.extends) ? s3 ? i3.push(ox2([...u3, sx2(o3)])) : i3.push(ox2(sx2([...u3, ...o3]))) : i3.push(...u3, ...o3), i3.push(" ", n3("body")), ox2(i3);
      } };
      const { isNonEmptyArray: gx2 } = Fi2, { builders: { softline: mx2, group: yx2, indent: Dx2, join: Ex2, line: Cx2, ifBreak: bx2, hardline: Ax2 } } = su2, { printDanglingComments: vx2 } = Yf2, { hasComment: Fx2, CommentCheckFlags: xx2, shouldPrintComma: Sx2, needsHardlineAfterDanglingComment: wx2 } = eg2, { locStart: Tx2, hasSameLoc: Bx2 } = Zc2, { hasDecoratorsBeforeExport: Nx2, printDecoratorsBeforeExport: kx2 } = kF2;
      function Px2(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!r3.source)
          return "";
        const i3 = [];
        return Ix2(r3, t3) || i3.push(" from"), i3.push(" ", n3("source")), i3;
      }
      function Ox2(e3, t3, n3) {
        const r3 = e3.getValue();
        if (Ix2(r3, t3))
          return "";
        const i3 = [" "];
        if (gx2(r3.specifiers)) {
          const u3 = [], o3 = [];
          if (e3.each(() => {
            const t4 = e3.getValue().type;
            if (t4 === "ExportNamespaceSpecifier" || t4 === "ExportDefaultSpecifier" || t4 === "ImportNamespaceSpecifier" || t4 === "ImportDefaultSpecifier")
              u3.push(n3());
            else {
              if (t4 !== "ExportSpecifier" && t4 !== "ImportSpecifier")
                throw new Error(`Unknown specifier type ${JSON.stringify(t4)}`);
              o3.push(n3());
            }
          }, "specifiers"), i3.push(Ex2(", ", u3)), o3.length > 0) {
            u3.length > 0 && i3.push(", ");
            o3.length > 1 || u3.length > 0 || r3.specifiers.some((e4) => Fx2(e4)) ? i3.push(yx2(["{", Dx2([t3.bracketSpacing ? Cx2 : mx2, Ex2([",", Cx2], o3)]), bx2(Sx2(t3) ? "," : ""), t3.bracketSpacing ? Cx2 : mx2, "}"])) : i3.push(["{", t3.bracketSpacing ? " " : "", ...o3, t3.bracketSpacing ? " " : "", "}"]);
          }
        } else
          i3.push("{}");
        return i3;
      }
      function Ix2(e3, t3) {
        const { type: n3, importKind: r3, source: i3, specifiers: u3 } = e3;
        return n3 === "ImportDeclaration" && !gx2(u3) && r3 !== "type" && !/{\s*}/.test(t3.originalText.slice(Tx2(e3), Tx2(i3)));
      }
      function Lx2(e3, t3, n3) {
        const r3 = e3.getNode();
        return gx2(r3.assertions) ? [" assert {", t3.bracketSpacing ? " " : "", Ex2(", ", e3.map(n3, "assertions")), t3.bracketSpacing ? " " : "", "}"] : "";
      }
      var jx2 = { printImportDeclaration: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = t3.semi ? ";" : "", u3 = [], { importKind: o3 } = r3;
        return u3.push("import"), o3 && o3 !== "value" && u3.push(" ", o3), u3.push(Ox2(e3, t3, n3), Px2(e3, t3, n3), Lx2(e3, t3, n3), i3), u3;
      }, printExportDeclaration: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [];
        Nx2(r3) && i3.push(kx2(e3, t3, n3));
        const { type: u3, exportKind: o3, declaration: s3 } = r3;
        return i3.push("export"), (r3.default || u3 === "ExportDefaultDeclaration") && i3.push(" default"), Fx2(r3, xx2.Dangling) && (i3.push(" ", vx2(e3, t3, true)), wx2(r3) && i3.push(Ax2)), s3 ? i3.push(" ", n3("declaration")) : i3.push(o3 === "type" ? " type" : "", Ox2(e3, t3, n3), Px2(e3, t3, n3), Lx2(e3, t3, n3)), function(e4, t4) {
          if (!t4.semi)
            return false;
          const { type: n4, declaration: r4 } = e4, i4 = e4.default || n4 === "ExportDefaultDeclaration";
          if (!r4)
            return true;
          const { type: u4 } = r4;
          if (i4 && u4 !== "ClassDeclaration" && u4 !== "FunctionDeclaration" && u4 !== "TSInterfaceDeclaration" && u4 !== "DeclareClass" && u4 !== "DeclareFunction" && u4 !== "TSDeclareFunction" && u4 !== "EnumDeclaration")
            return true;
          return false;
        }(r3, t3) && i3.push(";"), i3;
      }, printExportAllDeclaration: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = t3.semi ? ";" : "", u3 = [], { exportKind: o3, exported: s3 } = r3;
        return u3.push("export"), o3 === "type" && u3.push(" type"), u3.push(" *"), s3 && u3.push(" as ", n3("exported")), u3.push(Px2(e3, t3, n3), Lx2(e3, t3, n3), i3), u3;
      }, printModuleSpecifier: function(e3, t3, n3) {
        const r3 = e3.getNode(), { type: i3, importKind: u3 } = r3, o3 = [];
        i3 === "ImportSpecifier" && u3 && o3.push(u3, " ");
        const s3 = i3.startsWith("Import"), a3 = s3 ? "imported" : "local", c3 = s3 ? "local" : "exported";
        let l3 = "", p3 = "";
        return i3 === "ExportNamespaceSpecifier" || i3 === "ImportNamespaceSpecifier" ? l3 = "*" : r3[a3] && (l3 = n3(a3)), !r3[c3] || r3[a3] && Bx2(r3[a3], r3[c3]) || (p3 = n3(c3)), o3.push(l3, l3 && p3 ? " as " : "", p3), o3;
      } };
      const { printDanglingComments: _x2 } = Yf2, { builders: { line: Mx2, softline: Rx2, group: $x2, indent: Vx2, ifBreak: Wx2, hardline: qx2 } } = su2, { getLast: Ux2, hasNewlineInRange: zx2, hasNewline: Gx2, isNonEmptyArray: Hx2 } = Fi2, { shouldPrintComma: Jx2, hasComment: Xx2, getComments: Yx2, CommentCheckFlags: Kx2, isNextLineEmpty: Qx2 } = eg2, { locStart: Zx2, locEnd: eS2 } = Zc2, { printOptionalToken: tS2, printTypeAnnotation: nS2 } = _E2, { shouldHugFunctionParameters: rS2 } = PA2, { shouldHugType: iS2 } = ev2, { printHardlineAfterHeritage: uS2 } = nx2;
      var oS2 = { printObject: function(e3, t3, n3) {
        const r3 = t3.semi ? ";" : "", i3 = e3.getValue();
        let u3;
        u3 = i3.type === "TSTypeLiteral" ? "members" : i3.type === "TSInterfaceBody" ? "body" : "properties";
        const o3 = i3.type === "ObjectTypeAnnotation", s3 = [u3];
        o3 && s3.push("indexers", "callProperties", "internalSlots");
        const a3 = s3.map((e4) => i3[e4][0]).sort((e4, t4) => Zx2(e4) - Zx2(t4))[0], c3 = e3.getParentNode(0), l3 = o3 && c3 && (c3.type === "InterfaceDeclaration" || c3.type === "DeclareInterface" || c3.type === "DeclareClass") && e3.getName() === "body", p3 = i3.type === "TSInterfaceBody" || l3 || i3.type === "ObjectPattern" && c3.type !== "FunctionDeclaration" && c3.type !== "FunctionExpression" && c3.type !== "ArrowFunctionExpression" && c3.type !== "ObjectMethod" && c3.type !== "ClassMethod" && c3.type !== "ClassPrivateMethod" && c3.type !== "AssignmentPattern" && c3.type !== "CatchClause" && i3.properties.some((e4) => e4.value && (e4.value.type === "ObjectPattern" || e4.value.type === "ArrayPattern")) || i3.type !== "ObjectPattern" && a3 && zx2(t3.originalText, Zx2(i3), Zx2(a3)), f3 = l3 ? ";" : i3.type === "TSInterfaceBody" || i3.type === "TSTypeLiteral" ? Wx2(r3, ";") : ",", d3 = i3.type === "RecordExpression" ? "#{" : i3.exact ? "{|" : "{", h3 = i3.exact ? "|}" : "}", g3 = [];
        for (const t4 of s3)
          e3.each((e4) => {
            const t5 = e4.getValue();
            g3.push({ node: t5, printed: n3(), loc: Zx2(t5) });
          }, t4);
        s3.length > 1 && g3.sort((e4, t4) => e4.loc - t4.loc);
        let m3 = [];
        const y3 = g3.map((e4) => {
          const n4 = [...m3, $x2(e4.printed)];
          return m3 = [f3, Mx2], e4.node.type !== "TSPropertySignature" && e4.node.type !== "TSMethodSignature" && e4.node.type !== "TSConstructSignatureDeclaration" || !Xx2(e4.node, Kx2.PrettierIgnore) || m3.shift(), Qx2(e4.node, t3) && m3.push(qx2), n4;
        });
        if (i3.inexact) {
          let n4;
          if (Xx2(i3, Kx2.Dangling)) {
            const r4 = Xx2(i3, Kx2.Line);
            n4 = [_x2(e3, t3, true), r4 || Gx2(t3.originalText, eS2(Ux2(Yx2(i3)))) ? qx2 : Mx2, "..."];
          } else
            n4 = ["..."];
          y3.push([...m3, ...n4]);
        }
        const D3 = Ux2(i3[u3]), E3 = !(i3.inexact || D3 && D3.type === "RestElement" || D3 && (D3.type === "TSPropertySignature" || D3.type === "TSCallSignatureDeclaration" || D3.type === "TSMethodSignature" || D3.type === "TSConstructSignatureDeclaration") && Xx2(D3, Kx2.PrettierIgnore));
        let C3;
        if (y3.length === 0) {
          if (!Xx2(i3, Kx2.Dangling))
            return [d3, h3, nS2(e3, t3, n3)];
          C3 = $x2([d3, _x2(e3, t3), Rx2, h3, tS2(e3), nS2(e3, t3, n3)]);
        } else
          C3 = [l3 && Hx2(i3.properties) ? uS2(c3) : "", d3, Vx2([t3.bracketSpacing ? Mx2 : Rx2, ...y3]), Wx2(E3 && (f3 !== "," || Jx2(t3)) ? f3 : ""), t3.bracketSpacing ? Mx2 : Rx2, h3, tS2(e3), nS2(e3, t3, n3)];
        return e3.match((e4) => e4.type === "ObjectPattern" && !e4.decorators, (e4, t4, n4) => rS2(e4) && (t4 === "params" || t4 === "parameters" || t4 === "this" || t4 === "rest") && n4 === 0) || e3.match(iS2, (e4, t4) => t4 === "typeAnnotation", (e4, t4) => t4 === "typeAnnotation", (e4, t4, n4) => rS2(e4) && (t4 === "params" || t4 === "parameters" || t4 === "this" || t4 === "rest") && n4 === 0) || !p3 && e3.match((e4) => e4.type === "ObjectPattern", (e4) => e4.type === "AssignmentExpression" || e4.type === "VariableDeclarator") ? C3 : $x2(C3, { shouldBreak: p3 });
      } };
      const { printDanglingComments: sS2 } = Yf2, { printString: aS2, printNumber: cS2 } = Fi2, { builders: { hardline: lS2, softline: pS2, group: fS2, indent: dS2 } } = su2, { getParentExportDeclaration: hS2, isFunctionNotation: gS2, isGetterOrSetter: mS2, rawText: yS2, shouldPrintComma: DS2 } = eg2, { locStart: ES2, locEnd: CS2 } = Zc2, { printClass: bS2 } = nx2, { printOpaqueType: AS2, printTypeAlias: vS2, printIntersectionType: FS2, printUnionType: xS2, printFunctionType: SS2, printTupleType: wS2, printIndexedAccessType: TS2 } = ev2, { printInterface: BS2 } = hx2, { printTypeParameter: NS2, printTypeParameters: kS2 } = Ev2, { printExportDeclaration: PS2, printExportAllDeclaration: OS2 } = jx2, { printArrayItems: IS2 } = oC2, { printObject: LS2 } = oS2, { printPropertyKey: jS2 } = kv2, { printOptionalToken: _S2, printTypeAnnotation: MS2, printRestSpread: RS2 } = _E2;
      function $S2(e3, t3) {
        const n3 = hS2(e3);
        return n3 ? (Ff2.strictEqual(n3.type, "DeclareExportDeclaration"), t3) : ["declare ", t3];
      }
      var VS2 = { printFlow: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = t3.semi ? ";" : "", u3 = [];
        switch (r3.type) {
          case "DeclareClass":
            return $S2(e3, bS2(e3, t3, n3));
          case "DeclareFunction":
            return $S2(e3, ["function ", n3("id"), r3.predicate ? " " : "", n3("predicate"), i3]);
          case "DeclareModule":
            return $S2(e3, ["module ", n3("id"), " ", n3("body")]);
          case "DeclareModuleExports":
            return $S2(e3, ["module.exports", ": ", n3("typeAnnotation"), i3]);
          case "DeclareVariable":
            return $S2(e3, ["var ", n3("id"), i3]);
          case "DeclareOpaqueType":
            return $S2(e3, AS2(e3, t3, n3));
          case "DeclareInterface":
            return $S2(e3, BS2(e3, t3, n3));
          case "DeclareTypeAlias":
            return $S2(e3, vS2(e3, t3, n3));
          case "DeclareExportDeclaration":
            return $S2(e3, PS2(e3, t3, n3));
          case "DeclareExportAllDeclaration":
            return $S2(e3, OS2(e3, t3, n3));
          case "OpaqueType":
            return AS2(e3, t3, n3);
          case "TypeAlias":
            return vS2(e3, t3, n3);
          case "IntersectionTypeAnnotation":
            return FS2(e3, t3, n3);
          case "UnionTypeAnnotation":
            return xS2(e3, t3, n3);
          case "FunctionTypeAnnotation":
            return SS2(e3, t3, n3);
          case "TupleTypeAnnotation":
            return wS2(e3, t3, n3);
          case "GenericTypeAnnotation":
            return [n3("id"), kS2(e3, t3, n3, "typeParameters")];
          case "IndexedAccessType":
          case "OptionalIndexedAccessType":
            return TS2(e3, t3, n3);
          case "TypeAnnotation":
            return n3("typeAnnotation");
          case "TypeParameter":
            return NS2(e3, t3, n3);
          case "TypeofTypeAnnotation":
            return ["typeof ", n3("argument")];
          case "ExistsTypeAnnotation":
            return "*";
          case "EmptyTypeAnnotation":
            return "empty";
          case "MixedTypeAnnotation":
            return "mixed";
          case "ArrayTypeAnnotation":
            return [n3("elementType"), "[]"];
          case "BooleanLiteralTypeAnnotation":
            return String(r3.value);
          case "EnumDeclaration":
            return ["enum ", n3("id"), " ", n3("body")];
          case "EnumBooleanBody":
          case "EnumNumberBody":
          case "EnumStringBody":
          case "EnumSymbolBody":
            if (r3.type === "EnumSymbolBody" || r3.explicitType) {
              let e4 = null;
              switch (r3.type) {
                case "EnumBooleanBody":
                  e4 = "boolean";
                  break;
                case "EnumNumberBody":
                  e4 = "number";
                  break;
                case "EnumStringBody":
                  e4 = "string";
                  break;
                case "EnumSymbolBody":
                  e4 = "symbol";
              }
              u3.push("of ", e4, " ");
            }
            if (r3.members.length !== 0 || r3.hasUnknownMembers) {
              const i4 = r3.members.length > 0 ? [lS2, IS2(e3, t3, "members", n3), r3.hasUnknownMembers || DS2(t3) ? "," : ""] : [];
              u3.push(fS2(["{", dS2([...i4, ...r3.hasUnknownMembers ? [lS2, "..."] : []]), sS2(e3, t3, true), lS2, "}"]));
            } else
              u3.push(fS2(["{", sS2(e3, t3), pS2, "}"]));
            return u3;
          case "EnumBooleanMember":
          case "EnumNumberMember":
          case "EnumStringMember":
            return [n3("id"), " = ", typeof r3.init == "object" ? n3("init") : String(r3.init)];
          case "EnumDefaultedMember":
            return n3("id");
          case "FunctionTypeParam": {
            const t4 = r3.name ? n3("name") : e3.getParentNode().this === r3 ? "this" : "";
            return [t4, _S2(e3), t4 ? ": " : "", n3("typeAnnotation")];
          }
          case "InterfaceDeclaration":
          case "InterfaceTypeAnnotation":
            return BS2(e3, t3, n3);
          case "ClassImplements":
          case "InterfaceExtends":
            return [n3("id"), n3("typeParameters")];
          case "NullableTypeAnnotation":
            return ["?", n3("typeAnnotation")];
          case "Variance": {
            const { kind: e4 } = r3;
            return Ff2.ok(e4 === "plus" || e4 === "minus"), e4 === "plus" ? "+" : "-";
          }
          case "ObjectTypeCallProperty":
            return r3.static && u3.push("static "), u3.push(n3("value")), u3;
          case "ObjectTypeIndexer":
            return [r3.variance ? n3("variance") : "", "[", n3("id"), r3.id ? ": " : "", n3("key"), "]: ", n3("value")];
          case "ObjectTypeProperty": {
            let i4 = "";
            return r3.proto ? i4 = "proto " : r3.static && (i4 = "static "), [i4, mS2(r3) ? r3.kind + " " : "", r3.variance ? n3("variance") : "", jS2(e3, t3, n3), _S2(e3), gS2(r3) ? "" : ": ", n3("value")];
          }
          case "ObjectTypeAnnotation":
            return LS2(e3, t3, n3);
          case "ObjectTypeInternalSlot":
            return [r3.static ? "static " : "", "[[", n3("id"), "]]", _S2(e3), r3.method ? "" : ": ", n3("value")];
          case "ObjectTypeSpreadProperty":
            return RS2(e3, t3, n3);
          case "QualifiedTypeIdentifier":
            return [n3("qualification"), ".", n3("id")];
          case "StringLiteralTypeAnnotation":
            return aS2(yS2(r3), t3);
          case "NumberLiteralTypeAnnotation":
            Ff2.strictEqual(typeof r3.value, "number");
          case "BigIntLiteralTypeAnnotation":
            return r3.extra ? cS2(r3.extra.raw) : cS2(r3.raw);
          case "TypeCastExpression":
            return ["(", n3("expression"), MS2(e3, t3, n3), ")"];
          case "TypeParameterDeclaration":
          case "TypeParameterInstantiation": {
            const i4 = kS2(e3, t3, n3, "params");
            if (t3.parser === "flow") {
              const e4 = ES2(r3), n4 = CS2(r3), u4 = t3.originalText.lastIndexOf("/*", e4), o3 = t3.originalText.indexOf("*/", n4);
              if (u4 !== -1 && o3 !== -1) {
                const e5 = t3.originalText.slice(u4 + 2, o3).trim();
                if (e5.startsWith("::") && !e5.includes("/*") && !e5.includes("*/"))
                  return ["/*:: ", i4, " */"];
              }
            }
            return i4;
          }
          case "InferredPredicate":
            return "%checks";
          case "DeclaredPredicate":
            return ["%checks(", n3("value"), ")"];
          case "AnyTypeAnnotation":
            return "any";
          case "BooleanTypeAnnotation":
            return "boolean";
          case "BigIntTypeAnnotation":
            return "bigint";
          case "NullLiteralTypeAnnotation":
            return "null";
          case "NumberTypeAnnotation":
            return "number";
          case "SymbolTypeAnnotation":
            return "symbol";
          case "StringTypeAnnotation":
            return "string";
          case "VoidTypeAnnotation":
            return "void";
          case "ThisTypeAnnotation":
            return "this";
          case "Node":
          case "Printable":
          case "SourceLocation":
          case "Position":
          case "Statement":
          case "Function":
          case "Pattern":
          case "Expression":
          case "Declaration":
          case "Specifier":
          case "NamedSpecifier":
          case "Comment":
          case "MemberTypeAnnotation":
          case "Type":
            throw new Error("unprintable type: " + JSON.stringify(r3.type));
        }
      } };
      const { hasNewlineInRange: WS2 } = Fi2, { isJsxNode: qS2, isBlockComment: US2, getComments: zS2, isCallExpression: GS2, isMemberExpression: HS2 } = eg2, { locStart: JS2, locEnd: XS2 } = Zc2, { builders: { line: YS2, softline: KS2, group: QS2, indent: ZS2, align: ew2, ifBreak: tw2, dedent: nw2, breakParent: rw2 } } = su2;
      function iw2(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.type === "ConditionalExpression", u3 = i3 ? "alternate" : "falseType", o3 = e3.getParentNode(), s3 = i3 ? n3("test") : [n3("checkType"), " ", "extends", " ", n3("extendsType")];
        return o3.type === r3.type && o3[u3] === r3 ? ew2(2, s3) : s3;
      }
      const uw2 = new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
      var ow2 = { printTernary: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.type === "ConditionalExpression", u3 = i3 ? "consequent" : "trueType", o3 = i3 ? "alternate" : "falseType", s3 = i3 ? ["test"] : ["checkType", "extendsType"], a3 = r3[u3], c3 = r3[o3], l3 = [];
        let p3 = false;
        const f3 = e3.getParentNode(), d3 = f3.type === r3.type && s3.some((e4) => f3[e4] === r3);
        let h3, g3, m3 = f3.type === r3.type && !d3, y3 = 0;
        do {
          g3 = h3 || r3, h3 = e3.getParentNode(y3), y3++;
        } while (h3 && h3.type === r3.type && s3.every((e4) => h3[e4] !== g3));
        const D3 = h3 || f3, E3 = g3;
        if (i3 && (qS2(r3[s3[0]]) || qS2(a3) || qS2(c3) || function(e4) {
          const t4 = [e4];
          for (let e5 = 0; e5 < t4.length; e5++) {
            const n4 = t4[e5];
            for (const e6 of ["test", "consequent", "alternate"]) {
              const r4 = n4[e6];
              if (qS2(r4))
                return true;
              r4.type === "ConditionalExpression" && t4.push(r4);
            }
          }
          return false;
        }(E3))) {
          p3 = true, m3 = true;
          const e4 = (e5) => [tw2("("), ZS2([KS2, e5]), KS2, tw2(")")], t4 = (e5) => e5.type === "NullLiteral" || e5.type === "Literal" && e5.value === null || e5.type === "Identifier" && e5.name === "undefined";
          l3.push(" ? ", t4(a3) ? n3(u3) : e4(n3(u3)), " : ", c3.type === r3.type || t4(c3) ? n3(o3) : e4(n3(o3)));
        } else {
          const e4 = [YS2, "? ", a3.type === r3.type ? tw2("", "(") : "", ew2(2, n3(u3)), a3.type === r3.type ? tw2("", ")") : "", YS2, ": ", c3.type === r3.type ? n3(o3) : ew2(2, n3(o3))];
          l3.push(f3.type !== r3.type || f3[o3] === r3 || d3 ? e4 : t3.useTabs ? nw2(ZS2(e4)) : ew2(Math.max(0, t3.tabWidth - 2), e4));
        }
        const C3 = [...s3.map((e4) => zS2(r3[e4])), zS2(a3), zS2(c3)].flat().some((e4) => US2(e4) && WS2(t3.originalText, JS2(e4), XS2(e4))), b3 = !p3 && (HS2(f3) || f3.type === "NGPipeExpression" && f3.left === r3) && !f3.computed, A3 = function(e4) {
          const t4 = e4.getValue();
          if (t4.type !== "ConditionalExpression")
            return false;
          let n4, r4 = t4;
          for (let t5 = 0; !n4; t5++) {
            const i4 = e4.getParentNode(t5);
            GS2(i4) && i4.callee === r4 || HS2(i4) && i4.object === r4 || i4.type === "TSNonNullExpression" && i4.expression === r4 ? r4 = i4 : i4.type === "NewExpression" && i4.callee === r4 || i4.type === "TSAsExpression" && i4.expression === r4 ? (n4 = e4.getParentNode(t5 + 1), r4 = i4) : n4 = i4;
          }
          return r4 !== t4 && n4[uw2.get(n4.type)] === r4;
        }(e3), v3 = (F3 = [iw2(e3, 0, n3), m3 ? l3 : ZS2(l3), i3 && b3 && !A3 ? KS2 : ""], f3 === D3 ? QS2(F3, { shouldBreak: C3 }) : C3 ? [F3, rw2] : F3);
        var F3;
        return d3 || A3 ? QS2([ZS2([KS2, v3]), KS2]) : v3;
      } };
      const { builders: { hardline: sw2 } } = su2, { getLeftSidePathName: aw2, hasNakedLeftSide: cw2, isJsxNode: lw2, isTheOnlyJsxElementInMarkdown: pw2, hasComment: fw2, CommentCheckFlags: dw2, isNextLineEmpty: hw2 } = eg2, { shouldPrintParamsWithoutParens: gw2 } = DF2;
      function mw2(e3, t3, n3, r3) {
        const i3 = e3.getValue(), u3 = [], o3 = i3.type === "ClassBody", s3 = function(e4) {
          for (let t4 = e4.length - 1; t4 >= 0; t4--) {
            const n4 = e4[t4];
            if (n4.type !== "EmptyStatement")
              return n4;
          }
        }(i3[r3]);
        return e3.each((e4, r4, i4) => {
          const a3 = e4.getValue();
          if (a3.type === "EmptyStatement")
            return;
          const c3 = n3();
          t3.semi || o3 || pw2(t3, e4) || !function(e5, t4) {
            if (e5.getNode().type !== "ExpressionStatement")
              return false;
            return e5.call((e6) => yw2(e6, t4), "expression");
          }(e4, t3) ? u3.push(c3) : fw2(a3, dw2.Leading) ? u3.push(n3([], { needsSemi: true })) : u3.push(";", c3), !t3.semi && o3 && Dw2(a3) && function(e5, t4) {
            const n4 = e5.key && e5.key.name;
            if (!(n4 !== "static" && n4 !== "get" && n4 !== "set" || e5.value || e5.typeAnnotation))
              return true;
            if (!t4)
              return false;
            if (t4.static || t4.accessibility)
              return false;
            if (!t4.computed) {
              const e6 = t4.key && t4.key.name;
              if (e6 === "in" || e6 === "instanceof")
                return true;
            }
            if (Dw2(t4) && t4.variance && !t4.static && !t4.declare)
              return true;
            switch (t4.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractClassProperty":
                return t4.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((t4.value ? t4.value.async : t4.async) || t4.kind === "get" || t4.kind === "set")
                  return false;
                const e6 = t4.value ? t4.value.generator : t4.generator;
                return !(!t4.computed && !e6);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }(a3, i4[r4 + 1]) && u3.push(";"), a3 !== s3 && (u3.push(sw2), hw2(a3, t3) && u3.push(sw2));
        }, r3), u3;
      }
      function yw2(e3, t3) {
        const n3 = e3.getValue();
        switch (n3.type) {
          case "ParenthesizedExpression":
          case "TypeCastExpression":
          case "ArrayExpression":
          case "ArrayPattern":
          case "TemplateLiteral":
          case "TemplateElement":
          case "RegExpLiteral":
            return true;
          case "ArrowFunctionExpression":
            if (!gw2(e3, t3))
              return true;
            break;
          case "UnaryExpression": {
            const { prefix: e4, operator: t4 } = n3;
            if (e4 && (t4 === "+" || t4 === "-"))
              return true;
            break;
          }
          case "BindExpression":
            if (!n3.object)
              return true;
            break;
          case "Literal":
            if (n3.regex)
              return true;
            break;
          default:
            if (lw2(n3))
              return true;
        }
        return !!oD2(e3, t3) || !!cw2(n3) && e3.call((e4) => yw2(e4, t3), ...aw2(e3, n3));
      }
      const Dw2 = ({ type: e3 }) => e3 === "ClassProperty" || e3 === "PropertyDefinition" || e3 === "ClassPrivateProperty";
      var Ew2 = { printBody: function(e3, t3, n3) {
        return mw2(e3, t3, n3, "body");
      }, printSwitchCaseConsequent: function(e3, t3, n3) {
        return mw2(e3, t3, n3, "consequent");
      } };
      const { printDanglingComments: Cw2 } = Yf2, { isNonEmptyArray: bw2 } = Fi2, { builders: { hardline: Aw2, indent: vw2 } } = su2, { hasComment: Fw2, CommentCheckFlags: xw2, isNextLineEmpty: Sw2 } = eg2, { printHardlineAfterHeritage: ww2 } = nx2, { printBody: Tw2 } = Ew2;
      function Bw2(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = bw2(r3.directives), u3 = r3.body.some((e4) => e4.type !== "EmptyStatement"), o3 = Fw2(r3, xw2.Dangling);
        if (!i3 && !u3 && !o3)
          return "";
        const s3 = [];
        if (i3 && e3.each((e4, r4, i4) => {
          s3.push(n3()), (r4 < i4.length - 1 || u3 || o3) && (s3.push(Aw2), Sw2(e4.getValue(), t3) && s3.push(Aw2));
        }, "directives"), u3 && s3.push(Tw2(e3, t3, n3)), o3 && s3.push(Cw2(e3, t3, true)), r3.type === "Program") {
          const t4 = e3.getParentNode();
          t4 && t4.type === "ModuleExpression" || s3.push(Aw2);
        }
        return s3;
      }
      var Nw2 = { printBlock: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [];
        if (r3.type === "StaticBlock" && i3.push("static "), r3.type === "ClassBody" && bw2(r3.body)) {
          const t4 = e3.getParentNode();
          i3.push(ww2(t4));
        }
        i3.push("{");
        const u3 = Bw2(e3, t3, n3);
        if (u3)
          i3.push(vw2([Aw2, u3]), Aw2);
        else {
          const t4 = e3.getParentNode(), n4 = e3.getParentNode(1);
          t4.type === "ArrowFunctionExpression" || t4.type === "FunctionExpression" || t4.type === "FunctionDeclaration" || t4.type === "ObjectMethod" || t4.type === "ClassMethod" || t4.type === "ClassPrivateMethod" || t4.type === "ForStatement" || t4.type === "WhileStatement" || t4.type === "DoWhileStatement" || t4.type === "DoExpression" || t4.type === "CatchClause" && !n4.finalizer || t4.type === "TSModuleDeclaration" || t4.type === "TSDeclareFunction" || r3.type === "StaticBlock" || r3.type === "ClassBody" || i3.push(Aw2);
        }
        return i3.push("}"), i3;
      }, printBlockBody: Bw2 };
      const { printDanglingComments: kw2 } = Yf2, { hasNewlineInRange: Pw2 } = Fi2, { builders: { join: Ow2, line: Iw2, hardline: Lw2, softline: jw2, group: _w2, indent: Mw2, conditionalGroup: Rw2, ifBreak: $w2 } } = su2, { isLiteral: Vw2, getTypeScriptMappedTypeModifier: Ww2, shouldPrintComma: qw2, isCallExpression: Uw2, isMemberExpression: zw2 } = eg2, { locStart: Gw2, locEnd: Hw2 } = Zc2, { printOptionalToken: Jw2, printTypeScriptModifiers: Xw2 } = _E2, { printTernary: Yw2 } = ow2, { printFunctionParameters: Kw2, shouldGroupFunctionParameters: Qw2 } = PA2, { printTemplateLiteral: Zw2 } = Eg2, { printArrayItems: eT2 } = oC2, { printObject: tT2 } = oS2, { printClassProperty: nT2, printClassMethod: rT2 } = nx2, { printTypeParameter: iT2, printTypeParameters: uT2 } = Ev2, { printPropertyKey: oT2 } = kv2, { printFunction: sT2, printMethodInternal: aT2 } = DF2, { printInterface: cT2 } = hx2, { printBlock: lT2 } = Nw2, { printTypeAlias: pT2, printIntersectionType: fT2, printUnionType: dT2, printFunctionType: hT2, printTupleType: gT2, printIndexedAccessType: mT2 } = ev2;
      var yT2 = { printTypescript: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!r3.type.startsWith("TS"))
          return;
        if (r3.type.endsWith("Keyword"))
          return r3.type.slice(2, -7).toLowerCase();
        const i3 = t3.semi ? ";" : "", u3 = [];
        switch (r3.type) {
          case "TSThisType":
            return "this";
          case "TSTypeAssertion": {
            const e4 = !(r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression"), t4 = _w2(["<", Mw2([jw2, n3("typeAnnotation")]), jw2, ">"]), i4 = [$w2("("), Mw2([jw2, n3("expression")]), jw2, $w2(")")];
            return e4 ? Rw2([[t4, n3("expression")], [t4, _w2(i4, { shouldBreak: true })], [t4, n3("expression")]]) : _w2([t4, n3("expression")]);
          }
          case "TSDeclareFunction":
            return sT2(e3, n3, t3);
          case "TSExportAssignment":
            return ["export = ", n3("expression"), i3];
          case "TSModuleBlock":
            return lT2(e3, t3, n3);
          case "TSInterfaceBody":
          case "TSTypeLiteral":
            return tT2(e3, t3, n3);
          case "TSTypeAliasDeclaration":
            return pT2(e3, t3, n3);
          case "TSQualifiedName":
            return Ow2(".", [n3("left"), n3("right")]);
          case "TSAbstractMethodDefinition":
          case "TSDeclareMethod":
            return rT2(e3, t3, n3);
          case "TSAbstractClassProperty":
            return nT2(e3, t3, n3);
          case "TSInterfaceHeritage":
          case "TSExpressionWithTypeArguments":
            return u3.push(n3("expression")), r3.typeParameters && u3.push(n3("typeParameters")), u3;
          case "TSTemplateLiteralType":
            return Zw2(e3, n3, t3);
          case "TSNamedTupleMember":
            return [n3("label"), r3.optional ? "?" : "", ": ", n3("elementType")];
          case "TSRestType":
            return ["...", n3("typeAnnotation")];
          case "TSOptionalType":
            return [n3("typeAnnotation"), "?"];
          case "TSInterfaceDeclaration":
            return cT2(e3, t3, n3);
          case "TSClassImplements":
            return [n3("expression"), n3("typeParameters")];
          case "TSTypeParameterDeclaration":
          case "TSTypeParameterInstantiation":
            return uT2(e3, t3, n3, "params");
          case "TSTypeParameter":
            return iT2(e3, t3, n3);
          case "TSAsExpression": {
            u3.push(n3("expression"), " as ", n3("typeAnnotation"));
            const t4 = e3.getParentNode();
            return Uw2(t4) && t4.callee === r3 || zw2(t4) && t4.object === r3 ? _w2([Mw2([jw2, ...u3]), jw2]) : u3;
          }
          case "TSArrayType":
            return [n3("elementType"), "[]"];
          case "TSPropertySignature":
            return r3.readonly && u3.push("readonly "), u3.push(oT2(e3, t3, n3), Jw2(e3)), r3.typeAnnotation && u3.push(": ", n3("typeAnnotation")), r3.initializer && u3.push(" = ", n3("initializer")), u3;
          case "TSParameterProperty":
            return r3.accessibility && u3.push(r3.accessibility + " "), r3.export && u3.push("export "), r3.static && u3.push("static "), r3.override && u3.push("override "), r3.readonly && u3.push("readonly "), u3.push(n3("parameter")), u3;
          case "TSTypeQuery":
            return ["typeof ", n3("exprName")];
          case "TSIndexSignature": {
            const u4 = e3.getParentNode(), o3 = r3.parameters.length > 1 ? $w2(qw2(t3) ? "," : "") : "", s3 = _w2([Mw2([jw2, Ow2([", ", jw2], e3.map(n3, "parameters"))]), o3, jw2]);
            return [r3.export ? "export " : "", r3.accessibility ? [r3.accessibility, " "] : "", r3.static ? "static " : "", r3.readonly ? "readonly " : "", r3.declare ? "declare " : "", "[", r3.parameters ? s3 : "", r3.typeAnnotation ? "]: " : "]", r3.typeAnnotation ? n3("typeAnnotation") : "", u4.type === "ClassBody" ? i3 : ""];
          }
          case "TSTypePredicate":
            return [r3.asserts ? "asserts " : "", n3("parameterName"), r3.typeAnnotation ? [" is ", n3("typeAnnotation")] : ""];
          case "TSNonNullExpression":
            return [n3("expression"), "!"];
          case "TSImportType":
            return [r3.isTypeOf ? "typeof " : "", "import(", n3(r3.parameter ? "parameter" : "argument"), ")", r3.qualifier ? [".", n3("qualifier")] : "", uT2(e3, t3, n3, "typeParameters")];
          case "TSLiteralType":
            return n3("literal");
          case "TSIndexedAccessType":
            return mT2(e3, t3, n3);
          case "TSConstructSignatureDeclaration":
          case "TSCallSignatureDeclaration":
          case "TSConstructorType":
            if (r3.type === "TSConstructorType" && r3.abstract && u3.push("abstract "), r3.type !== "TSCallSignatureDeclaration" && u3.push("new "), u3.push(_w2(Kw2(e3, n3, t3, false, true))), r3.returnType || r3.typeAnnotation) {
              const e4 = r3.type === "TSConstructorType";
              u3.push(e4 ? " => " : ": ", n3("returnType"), n3("typeAnnotation"));
            }
            return u3;
          case "TSTypeOperator":
            return [r3.operator, " ", n3("typeAnnotation")];
          case "TSMappedType": {
            const u4 = Pw2(t3.originalText, Gw2(r3), Hw2(r3));
            return _w2(["{", Mw2([t3.bracketSpacing ? Iw2 : jw2, r3.readonly ? [Ww2(r3.readonly, "readonly"), " "] : "", Xw2(e3, t3, n3), n3("typeParameter"), r3.optional ? Ww2(r3.optional, "?") : "", r3.typeAnnotation ? ": " : "", n3("typeAnnotation"), $w2(i3)]), kw2(e3, t3, true), t3.bracketSpacing ? Iw2 : jw2, "}"], { shouldBreak: u4 });
          }
          case "TSMethodSignature": {
            const i4 = r3.kind && r3.kind !== "method" ? `${r3.kind} ` : "";
            u3.push(r3.accessibility ? [r3.accessibility, " "] : "", i4, r3.export ? "export " : "", r3.static ? "static " : "", r3.readonly ? "readonly " : "", r3.abstract ? "abstract " : "", r3.declare ? "declare " : "", r3.computed ? "[" : "", n3("key"), r3.computed ? "]" : "", Jw2(e3));
            const o3 = Kw2(e3, n3, t3, false, true), s3 = r3.returnType ? "returnType" : "typeAnnotation", a3 = r3[s3], c3 = a3 ? n3(s3) : "", l3 = Qw2(r3, c3);
            return u3.push(l3 ? _w2(o3) : o3), a3 && u3.push(": ", _w2(c3)), _w2(u3);
          }
          case "TSNamespaceExportDeclaration":
            return u3.push("export as namespace ", n3("id")), t3.semi && u3.push(";"), _w2(u3);
          case "TSEnumDeclaration":
            return r3.declare && u3.push("declare "), r3.modifiers && u3.push(Xw2(e3, t3, n3)), r3.const && u3.push("const "), u3.push("enum ", n3("id"), " "), r3.members.length === 0 ? u3.push(_w2(["{", kw2(e3, t3), jw2, "}"])) : u3.push(_w2(["{", Mw2([Lw2, eT2(e3, t3, "members", n3), qw2(t3, "es5") ? "," : ""]), kw2(e3, t3, true), Lw2, "}"])), u3;
          case "TSEnumMember":
            return u3.push(n3("id")), r3.initializer && u3.push(" = ", n3("initializer")), u3;
          case "TSImportEqualsDeclaration":
            return r3.isExport && u3.push("export "), u3.push("import "), r3.importKind && r3.importKind !== "value" && u3.push(r3.importKind, " "), u3.push(n3("id"), " = ", n3("moduleReference")), t3.semi && u3.push(";"), _w2(u3);
          case "TSExternalModuleReference":
            return ["require(", n3("expression"), ")"];
          case "TSModuleDeclaration": {
            const o3 = e3.getParentNode(), s3 = Vw2(r3.id), a3 = o3.type === "TSModuleDeclaration", c3 = r3.body && r3.body.type === "TSModuleDeclaration";
            if (a3)
              u3.push(".");
            else {
              r3.declare && u3.push("declare "), u3.push(Xw2(e3, t3, n3));
              const i4 = t3.originalText.slice(Gw2(r3), Gw2(r3.id));
              r3.id.type === "Identifier" && r3.id.name === "global" && !/namespace|module/.test(i4) || u3.push(s3 || /(?:^|\s)module(?:\s|$)/.test(i4) ? "module " : "namespace ");
            }
            return u3.push(n3("id")), c3 ? u3.push(n3("body")) : r3.body ? u3.push(" ", _w2(n3("body"))) : u3.push(i3), u3;
          }
          case "TSPrivateIdentifier":
            return r3.escapedText;
          case "TSConditionalType":
            return Yw2(e3, t3, n3);
          case "TSInferType":
            return ["infer", " ", n3("typeParameter")];
          case "TSIntersectionType":
            return fT2(e3, t3, n3);
          case "TSUnionType":
            return dT2(e3, t3, n3);
          case "TSFunctionType":
            return hT2(e3, t3, n3);
          case "TSTupleType":
            return gT2(e3, t3, n3);
          case "TSTypeReference":
            return [n3("typeName"), uT2(e3, t3, n3, "typeParameters")];
          case "TSTypeAnnotation":
            return n3("typeAnnotation");
          case "TSEmptyBodyFunctionExpression":
            return aT2(e3, t3, n3);
          case "TSJSDocAllType":
            return "*";
          case "TSJSDocUnknownType":
            return "?";
          case "TSJSDocNullableType":
            return ["?", n3("typeAnnotation")];
          case "TSJSDocNonNullableType":
            return ["!", n3("typeAnnotation")];
          default:
            throw new Error(`Unknown TypeScript node type: ${JSON.stringify(r3.type)}.`);
        }
      } };
      const { hasNewline: DT2 } = Fi2, { builders: { join: ET2, hardline: CT2 }, utils: { replaceTextEndOfLine: bT2 } } = su2, { isLineComment: AT2, isBlockComment: vT2 } = eg2, { locStart: FT2, locEnd: xT2 } = Zc2;
      var ST2 = { printComment: function(e3, t3) {
        const n3 = e3.getValue();
        if (AT2(n3))
          return t3.originalText.slice(FT2(n3), xT2(n3)).trimEnd();
        if (vT2(n3)) {
          if (function(e5) {
            const t4 = `*${e5.value}*`.split("\n");
            return t4.length > 1 && t4.every((e6) => e6.trim()[0] === "*");
          }(n3)) {
            const e5 = function(e6) {
              const t4 = e6.value.split("\n");
              return ["/*", ET2(CT2, t4.map((e7, n4) => n4 === 0 ? e7.trimEnd() : " " + (n4 < t4.length - 1 ? e7.trim() : e7.trimStart()))), "*/"];
            }(n3);
            return n3.trailing && !DT2(t3.originalText, FT2(n3), { backwards: true }) ? [CT2, e5] : e5;
          }
          const e4 = xT2(n3), r3 = t3.originalText.slice(e4 - 3, e4) === "*-/";
          return ["/*", bT2(n3.value), r3 ? "*-/" : "*/"];
        }
        throw new Error("Not a comment: " + JSON.stringify(n3));
      } };
      const { printString: wT2, printNumber: TT2 } = Fi2;
      function BT2(e3) {
        return e3.toLowerCase();
      }
      function NT2({ pattern: e3, flags: t3 }) {
        return `/${e3}/${t3 = [...t3].sort().join("")}`;
      }
      var kT2 = { printLiteral: function(e3, t3) {
        const n3 = e3.getNode();
        switch (n3.type) {
          case "RegExpLiteral":
            return NT2(n3);
          case "BigIntLiteral":
            return BT2(n3.bigint || n3.extra.raw);
          case "NumericLiteral":
            return TT2(n3.extra.raw);
          case "StringLiteral":
            return wT2(n3.extra.raw, t3);
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return String(n3.value);
          case "DecimalLiteral":
            return TT2(n3.value) + "m";
          case "Literal": {
            if (n3.regex)
              return NT2(n3.regex);
            if (n3.bigint)
              return BT2(n3.raw);
            if (n3.decimal)
              return TT2(n3.decimal) + "m";
            const { value: e4 } = n3;
            return typeof e4 == "number" ? TT2(n3.raw) : typeof e4 == "string" ? wT2(n3.raw, t3) : String(e4);
          }
        }
      } };
      const { printDanglingComments: PT2 } = Yf2, { hasNewline: OT2 } = Fi2, { builders: { join: IT2, line: LT2, hardline: jT2, softline: _T2, group: MT2, indent: RT2 }, utils: { replaceTextEndOfLine: $T2 } } = su2, { insertPragma: VT2 } = Rm2, { hasFlowShorthandAnnotationComment: WT2, hasComment: qT2, CommentCheckFlags: UT2, isTheOnlyJsxElementInMarkdown: zT2, isBlockComment: GT2, isLineComment: HT2, isNextLineEmpty: JT2, needsHardlineAfterDanglingComment: XT2, rawText: YT2, hasIgnoreComment: KT2, isCallExpression: QT2, isMemberExpression: ZT2 } = eg2, { locStart: eB2, locEnd: tB2 } = Zc2, { printHtmlBinding: nB2, isVueEventBindingExpression: rB2 } = dD2, { printAngular: iB2 } = JD2, { printJsx: uB2, hasJsxIgnoreComment: oB2 } = NE2, { printFlow: sB2 } = VS2, { printTypescript: aB2 } = yT2, { printOptionalToken: cB2, printBindExpressionCallee: lB2, printTypeAnnotation: pB2, adjustClause: fB2, printRestSpread: dB2 } = _E2, { printImportDeclaration: hB2, printExportDeclaration: gB2, printExportAllDeclaration: mB2, printModuleSpecifier: yB2 } = jx2, { printTernary: DB2 } = ow2, { printTemplateLiteral: EB2 } = Eg2, { printArray: CB2 } = oC2, { printObject: bB2 } = oS2, { printClass: AB2, printClassMethod: vB2, printClassProperty: FB2 } = nx2, { printProperty: xB2 } = kv2, { printFunction: SB2, printArrowFunction: wB2, printMethod: TB2, printReturnStatement: BB2, printThrowStatement: NB2 } = DF2, { printCallExpression: kB2 } = Pb2, { printVariableDeclarator: PB2, printAssignmentExpression: OB2 } = oA2, { printBinaryishExpression: IB2 } = RD2, { printSwitchCaseConsequent: LB2 } = Ew2, { printMemberExpression: jB2 } = zC2, { printBlock: _B2, printBlockBody: MB2 } = Nw2, { printComment: RB2 } = ST2, { printLiteral: $B2 } = kT2, { printDecorators: VB2 } = kF2;
      function WB2(e3, t3) {
        const n3 = YT2(e3), r3 = n3.slice(1, -1);
        if (r3.includes('"') || r3.includes("'"))
          return n3;
        const i3 = t3.singleQuote ? "'" : '"';
        return i3 + r3 + i3;
      }
      var qB2 = { preprocess: sD2, print: function(e3, t3, n3, r3) {
        const i3 = function(e4, t4, n4, r4) {
          const i4 = e4.getValue(), u4 = t4.semi ? ";" : "";
          if (!i4)
            return "";
          if (typeof i4 == "string")
            return i4;
          for (const r5 of [$B2, nB2, iB2, uB2, sB2, aB2]) {
            const i5 = r5(e4, t4, n4);
            if (i5 !== void 0)
              return i5;
          }
          let o4 = [];
          switch (i4.type) {
            case "JsExpressionRoot":
              return n4("node");
            case "JsonRoot":
              return [n4("node"), jT2];
            case "File":
              return i4.program && i4.program.interpreter && o4.push(n4(["program", "interpreter"])), o4.push(n4("program")), o4;
            case "Program":
              return MB2(e4, t4, n4);
            case "EmptyStatement":
              return "";
            case "ExpressionStatement":
              if (i4.directive)
                return [WB2(i4.expression, t4), u4];
              if (t4.parser === "__vue_event_binding") {
                const t5 = e4.getParentNode();
                if (t5.type === "Program" && t5.body.length === 1 && t5.body[0] === i4)
                  return [n4("expression"), rB2(i4.expression) ? ";" : ""];
              }
              return [n4("expression"), zT2(t4, e4) ? "" : u4];
            case "ParenthesizedExpression":
              return !qT2(i4.expression) && (i4.expression.type === "ObjectExpression" || i4.expression.type === "ArrayExpression") ? ["(", n4("expression"), ")"] : MT2(["(", RT2([_T2, n4("expression")]), _T2, ")"]);
            case "AssignmentExpression":
              return OB2(e4, t4, n4);
            case "VariableDeclarator":
              return PB2(e4, t4, n4);
            case "BinaryExpression":
            case "LogicalExpression":
              return IB2(e4, t4, n4);
            case "AssignmentPattern":
              return [n4("left"), " = ", n4("right")];
            case "OptionalMemberExpression":
            case "MemberExpression":
              return jB2(e4, t4, n4);
            case "MetaProperty":
              return [n4("meta"), ".", n4("property")];
            case "BindExpression":
              return i4.object && o4.push(n4("object")), o4.push(MT2(RT2([_T2, lB2(e4, t4, n4)]))), o4;
            case "Identifier":
              return [i4.name, cB2(e4), pB2(e4, t4, n4)];
            case "V8IntrinsicIdentifier":
              return ["%", i4.name];
            case "SpreadElement":
            case "SpreadElementPattern":
            case "SpreadProperty":
            case "SpreadPropertyPattern":
            case "RestElement":
              return dB2(e4, t4, n4);
            case "FunctionDeclaration":
            case "FunctionExpression":
              return SB2(e4, n4, t4, r4);
            case "ArrowFunctionExpression":
              return wB2(e4, t4, n4, r4);
            case "YieldExpression":
              return o4.push("yield"), i4.delegate && o4.push("*"), i4.argument && o4.push(" ", n4("argument")), o4;
            case "AwaitExpression":
              if (o4.push("await"), i4.argument) {
                o4.push(" ", n4("argument"));
                const t5 = e4.getParentNode();
                if (QT2(t5) && t5.callee === i4 || ZT2(t5) && t5.object === i4) {
                  o4 = [RT2([_T2, ...o4]), _T2];
                  const t6 = e4.findAncestor((e5) => e5.type === "AwaitExpression" || e5.type === "BlockStatement");
                  if (!t6 || t6.type !== "AwaitExpression")
                    return MT2(o4);
                }
              }
              return o4;
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              return gB2(e4, t4, n4);
            case "ExportAllDeclaration":
              return mB2(e4, t4, n4);
            case "ImportDeclaration":
              return hB2(e4, t4, n4);
            case "ImportSpecifier":
            case "ExportSpecifier":
            case "ImportNamespaceSpecifier":
            case "ExportNamespaceSpecifier":
            case "ImportDefaultSpecifier":
            case "ExportDefaultSpecifier":
              return yB2(e4, t4, n4);
            case "ImportAttribute":
              return [n4("key"), ": ", n4("value")];
            case "Import":
              return "import";
            case "BlockStatement":
            case "StaticBlock":
            case "ClassBody":
              return _B2(e4, t4, n4);
            case "ThrowStatement":
              return NB2(e4, t4, n4);
            case "ReturnStatement":
              return BB2(e4, t4, n4);
            case "NewExpression":
            case "ImportExpression":
            case "OptionalCallExpression":
            case "CallExpression":
              return kB2(e4, t4, n4);
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              return bB2(e4, t4, n4);
            case "ObjectProperty":
            case "Property":
              return i4.method || i4.kind === "get" || i4.kind === "set" ? TB2(e4, t4, n4) : xB2(e4, t4, n4);
            case "ObjectMethod":
              return TB2(e4, t4, n4);
            case "Decorator":
              return ["@", n4("expression")];
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              return CB2(e4, t4, n4);
            case "SequenceExpression": {
              const t5 = e4.getParentNode(0);
              if (t5.type === "ExpressionStatement" || t5.type === "ForStatement") {
                const t6 = [];
                return e4.each((e5, r5) => {
                  r5 === 0 ? t6.push(n4()) : t6.push(",", RT2([LT2, n4()]));
                }, "expressions"), MT2(t6);
              }
              return MT2(IT2([",", LT2], e4.map(n4, "expressions")));
            }
            case "ThisExpression":
              return "this";
            case "Super":
              return "super";
            case "Directive":
              return [n4("value"), u4];
            case "DirectiveLiteral":
              return WB2(i4, t4);
            case "UnaryExpression":
              return o4.push(i4.operator), /[a-z]$/.test(i4.operator) && o4.push(" "), qT2(i4.argument) ? o4.push(MT2(["(", RT2([_T2, n4("argument")]), _T2, ")"])) : o4.push(n4("argument")), o4;
            case "UpdateExpression":
              return o4.push(n4("argument"), i4.operator), i4.prefix && o4.reverse(), o4;
            case "ConditionalExpression":
              return DB2(e4, t4, n4);
            case "VariableDeclaration": {
              const t5 = e4.map(n4, "declarations"), r5 = e4.getParentNode(), s4 = r5.type === "ForStatement" || r5.type === "ForInStatement" || r5.type === "ForOfStatement", a4 = i4.declarations.some((e5) => e5.init);
              let c3;
              return t5.length !== 1 || qT2(i4.declarations[0]) ? t5.length > 0 && (c3 = RT2(t5[0])) : c3 = t5[0], o4 = [i4.declare ? "declare " : "", i4.kind, c3 ? [" ", c3] : "", RT2(t5.slice(1).map((e5) => [",", a4 && !s4 ? jT2 : LT2, e5]))], s4 && r5.body !== i4 || o4.push(u4), MT2(o4);
            }
            case "WithStatement":
              return MT2(["with (", n4("object"), ")", fB2(i4.body, n4("body"))]);
            case "IfStatement": {
              const r5 = fB2(i4.consequent, n4("consequent")), u5 = MT2(["if (", MT2([RT2([_T2, n4("test")]), _T2]), ")", r5]);
              if (o4.push(u5), i4.alternate) {
                const r6 = qT2(i4.consequent, UT2.Trailing | UT2.Line) || XT2(i4), u6 = i4.consequent.type === "BlockStatement" && !r6;
                o4.push(u6 ? " " : jT2), qT2(i4, UT2.Dangling) && o4.push(PT2(e4, t4, true), r6 ? jT2 : " "), o4.push("else", MT2(fB2(i4.alternate, n4("alternate"), i4.alternate.type === "IfStatement")));
              }
              return o4;
            }
            case "ForStatement": {
              const r5 = fB2(i4.body, n4("body")), u5 = PT2(e4, t4, true), o5 = u5 ? [u5, _T2] : "";
              return i4.init || i4.test || i4.update ? [o5, MT2(["for (", MT2([RT2([_T2, n4("init"), ";", LT2, n4("test"), ";", LT2, n4("update")]), _T2]), ")", r5])] : [o5, MT2(["for (;;)", r5])];
            }
            case "WhileStatement":
              return MT2(["while (", MT2([RT2([_T2, n4("test")]), _T2]), ")", fB2(i4.body, n4("body"))]);
            case "ForInStatement":
              return MT2(["for (", n4("left"), " in ", n4("right"), ")", fB2(i4.body, n4("body"))]);
            case "ForOfStatement":
              return MT2(["for", i4.await ? " await" : "", " (", n4("left"), " of ", n4("right"), ")", fB2(i4.body, n4("body"))]);
            case "DoWhileStatement": {
              const e5 = fB2(i4.body, n4("body"));
              return o4 = [MT2(["do", e5])], i4.body.type === "BlockStatement" ? o4.push(" ") : o4.push(jT2), o4.push("while (", MT2([RT2([_T2, n4("test")]), _T2]), ")", u4), o4;
            }
            case "DoExpression":
              return [i4.async ? "async " : "", "do ", n4("body")];
            case "BreakStatement":
              return o4.push("break"), i4.label && o4.push(" ", n4("label")), o4.push(u4), o4;
            case "ContinueStatement":
              return o4.push("continue"), i4.label && o4.push(" ", n4("label")), o4.push(u4), o4;
            case "LabeledStatement":
              return i4.body.type === "EmptyStatement" ? [n4("label"), ":;"] : [n4("label"), ": ", n4("body")];
            case "TryStatement":
              return ["try ", n4("block"), i4.handler ? [" ", n4("handler")] : "", i4.finalizer ? [" finally ", n4("finalizer")] : ""];
            case "CatchClause":
              if (i4.param) {
                const e5 = qT2(i4.param, (e6) => !GT2(e6) || e6.leading && OT2(t4.originalText, tB2(e6)) || e6.trailing && OT2(t4.originalText, eB2(e6), { backwards: true })), r5 = n4("param");
                return ["catch ", e5 ? ["(", RT2([_T2, r5]), _T2, ") "] : ["(", r5, ") "], n4("body")];
              }
              return ["catch ", n4("body")];
            case "SwitchStatement":
              return [MT2(["switch (", RT2([_T2, n4("discriminant")]), _T2, ")"]), " {", i4.cases.length > 0 ? RT2([jT2, IT2(jT2, e4.map((e5, r5, i5) => {
                const u5 = e5.getValue();
                return [n4(), r5 !== i5.length - 1 && JT2(u5, t4) ? jT2 : ""];
              }, "cases"))]) : "", jT2, "}"];
            case "SwitchCase": {
              i4.test ? o4.push("case ", n4("test"), ":") : o4.push("default:");
              const r5 = i4.consequent.filter((e5) => e5.type !== "EmptyStatement");
              if (r5.length > 0) {
                const i5 = LB2(e4, t4, n4);
                o4.push(r5.length === 1 && r5[0].type === "BlockStatement" ? [" ", i5] : RT2([jT2, i5]));
              }
              return o4;
            }
            case "DebuggerStatement":
              return ["debugger", u4];
            case "ClassDeclaration":
            case "ClassExpression":
              return AB2(e4, t4, n4);
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "MethodDefinition":
              return vB2(e4, t4, n4);
            case "ClassProperty":
            case "PropertyDefinition":
            case "ClassPrivateProperty":
              return FB2(e4, t4, n4);
            case "TemplateElement":
              return $T2(i4.value.raw);
            case "TemplateLiteral":
              return EB2(e4, n4, t4);
            case "TaggedTemplateExpression":
              return [n4("tag"), n4("typeParameters"), n4("quasi")];
            case "PrivateIdentifier":
              return ["#", n4("name")];
            case "PrivateName":
              return ["#", n4("id")];
            case "InterpreterDirective":
              return o4.push("#!", i4.value, jT2), JT2(i4, t4) && o4.push(jT2), o4;
            case "TopicReference":
              return "%";
            case "ArgumentPlaceholder":
              return "?";
            case "ModuleExpression": {
              o4.push("module {");
              const e5 = n4("body");
              return e5 && o4.push(RT2([jT2, e5]), jT2), o4.push("}"), o4;
            }
            default:
              throw new Error("unknown type: " + JSON.stringify(i4.type));
          }
        }(e3, t3, n3, r3);
        if (!i3)
          return "";
        const u3 = e3.getValue(), { type: o3 } = u3;
        if (o3 === "ClassMethod" || o3 === "ClassPrivateMethod" || o3 === "ClassProperty" || o3 === "PropertyDefinition" || o3 === "TSAbstractClassProperty" || o3 === "ClassPrivateProperty" || o3 === "MethodDefinition" || o3 === "TSAbstractMethodDefinition" || o3 === "TSDeclareMethod")
          return i3;
        const s3 = VB2(e3, t3, n3);
        if (s3)
          return MT2([...s3, i3]);
        if (!oD2(e3, t3))
          return r3 && r3.needsSemi ? [";", i3] : i3;
        const a3 = [r3 && r3.needsSemi ? ";(" : "(", i3];
        if (WT2(u3)) {
          const [e4] = u3.trailingComments;
          a3.push(" /*", e4.value.trimStart(), "*/"), e4.printed = true;
        }
        return a3.push(")"), a3;
      }, embed: um2, insertPragma: VT2, massageAstNode: lm2, hasPrettierIgnore: (e3) => KT2(e3) || oB2(e3), willPrintOwnComments: Uy2.willPrintOwnComments, canAttachComment: function(e3) {
        return e3.type && !GT2(e3) && !HT2(e3) && e3.type !== "EmptyStatement" && e3.type !== "TemplateElement" && e3.type !== "Import" && e3.type !== "TSEmptyBodyFunctionExpression";
      }, printComment: RB2, isBlockComment: GT2, handleComments: { avoidAstMutation: true, ownLine: Uy2.handleOwnLineComment, endOfLine: Uy2.handleEndOfLineComment, remaining: Uy2.handleRemainingComment }, getCommentChildNodes: Uy2.getCommentChildNodes };
      const { builders: { hardline: UB2, indent: zB2, join: GB2 } } = su2;
      const HB2 = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
      function JB2(e3, t3) {
        const { type: n3 } = e3;
        if (n3 !== "ObjectProperty" || e3.key.type !== "Identifier") {
          if (n3 === "UnaryExpression" && e3.operator === "+")
            return t3.argument;
          if (n3 !== "ArrayExpression")
            return n3 === "TemplateLiteral" ? { type: "StringLiteral", value: e3.quasis[0].value.cooked } : void 0;
          for (const [n4, r3] of e3.elements.entries())
            r3 === null && t3.elements.splice(n4, 0, { type: "NullLiteral" });
        } else
          t3.key = { type: "StringLiteral", value: e3.key.name };
      }
      JB2.ignoredProperties = HB2;
      var XB2 = { preprocess: sD2, print: function(e3, t3, n3) {
        const r3 = e3.getValue();
        switch (r3.type) {
          case "JsonRoot":
            return [n3("node"), UB2];
          case "ArrayExpression": {
            if (r3.elements.length === 0)
              return "[]";
            const t4 = e3.map(() => e3.getValue() === null ? "null" : n3(), "elements");
            return ["[", zB2([UB2, GB2([",", UB2], t4)]), UB2, "]"];
          }
          case "ObjectExpression":
            return r3.properties.length === 0 ? "{}" : ["{", zB2([UB2, GB2([",", UB2], e3.map(n3, "properties"))]), UB2, "}"];
          case "ObjectProperty":
            return [n3("key"), ": ", n3("value")];
          case "UnaryExpression":
            return [r3.operator === "+" ? "" : r3.operator, n3("argument")];
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return r3.value ? "true" : "false";
          case "StringLiteral":
          case "NumericLiteral":
            return JSON.stringify(r3.value);
          case "Identifier": {
            const t4 = e3.getParentNode();
            return t4 && t4.type === "ObjectProperty" && t4.key === r3 ? JSON.stringify(r3.name) : r3.name;
          }
          case "TemplateLiteral":
            return n3(["quasis", 0]);
          case "TemplateElement":
            return JSON.stringify(r3.value.cooked);
          default:
            throw new Error("unknown type: " + JSON.stringify(r3.type));
        }
      }, massageAstNode: JB2 };
      const YB2 = "Common";
      var KB2 = { bracketSpacing: { since: "0.0.0", category: YB2, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: YB2, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: YB2, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: YB2, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." } };
      const QB2 = "JavaScript";
      var ZB2 = { arrowParens: { since: "1.9.0", category: QB2, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: KB2.bracketSameLine, bracketSpacing: KB2.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: QB2, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: QB2, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: KB2.singleQuote, jsxSingleQuote: { since: "1.15.0", category: QB2, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: QB2, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: QB2, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] } }, eN2 = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 }, tN2 = { name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 }, nN2 = { name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 }, rN2 = { name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 }, iN2 = { name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 }, uN2 = { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
      var oN2 = { languages: [rh2(eN2, (e3) => ({ since: "0.0.0", parsers: ["babel", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e3.interpreters, "zx"], extensions: [...e3.extensions.filter((e4) => e4 !== ".jsx"), ".wxs"] })), rh2(eN2, () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), rh2(eN2, () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), rh2(tN2, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), rh2(nN2, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), rh2(rN2, () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] })), rh2(rN2, (e3) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e3.extensions.filter((e4) => e4 !== ".jsonl") })), rh2(iN2, (e3) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e3.filenames, ".eslintrc"] })), rh2(uN2, () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], options: ZB2, printers: { estree: qB2, "estree-json": XB2 }, parsers: void 0 };
      const { isFrontMatterNode: sN2 } = Fi2, aN2 = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
      function cN2(e3, t3, n3) {
        if (sN2(e3) && e3.lang === "yaml" && delete t3.value, e3.type === "css-comment" && n3.type === "css-root" && n3.nodes.length > 0) {
          if ((n3.nodes[0] === e3 || sN2(n3.nodes[0]) && n3.nodes[1] === e3) && (delete t3.text, /^\*\s*@(?:format|prettier)\s*$/.test(e3.text)))
            return null;
          if (n3.type === "css-root" && _n2(n3.nodes) === e3)
            return null;
        }
        if (e3.type === "value-root" && delete t3.text, e3.type !== "media-query" && e3.type !== "media-query-list" && e3.type !== "media-feature-expression" || delete t3.value, e3.type === "css-rule" && delete t3.params, e3.type === "selector-combinator" && (t3.value = t3.value.replace(/\s+/g, " ")), e3.type === "media-feature" && (t3.value = t3.value.replace(/ /g, "")), (e3.type === "value-word" && (e3.isColor && e3.isHex || ["initial", "inherit", "unset", "revert"].includes(t3.value.replace().toLowerCase())) || e3.type === "media-feature" || e3.type === "selector-root-invalid" || e3.type === "selector-pseudo") && (t3.value = t3.value.toLowerCase()), e3.type === "css-decl" && (t3.prop = t3.prop.toLowerCase()), e3.type !== "css-atrule" && e3.type !== "css-import" || (t3.name = t3.name.toLowerCase()), e3.type === "value-number" && (t3.unit = t3.unit.toLowerCase()), e3.type !== "media-feature" && e3.type !== "media-keyword" && e3.type !== "media-type" && e3.type !== "media-unknown" && e3.type !== "media-url" && e3.type !== "media-value" && e3.type !== "selector-attribute" && e3.type !== "selector-string" && e3.type !== "selector-class" && e3.type !== "selector-combinator" && e3.type !== "value-string" || !t3.value || (t3.value = t3.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e3.type === "selector-attribute" && (t3.attribute = t3.attribute.trim(), t3.namespace && typeof t3.namespace == "string" && (t3.namespace = t3.namespace.trim(), t3.namespace.length === 0 && (t3.namespace = true)), t3.value && (t3.value = t3.value.trim().replace(/^["']|["']$/g, ""), delete t3.quoted)), e3.type !== "media-value" && e3.type !== "media-type" && e3.type !== "value-number" && e3.type !== "selector-root-invalid" && e3.type !== "selector-class" && e3.type !== "selector-combinator" && e3.type !== "selector-tag" || !t3.value || (t3.value = t3.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e4, t4, n4) => {
          const r3 = Number(t4);
          return Number.isNaN(r3) ? e4 : r3 + n4.toLowerCase();
        })), e3.type === "selector-tag") {
          const n4 = e3.value.toLowerCase();
          ["from", "to"].includes(n4) && (t3.value = n4);
        }
        e3.type === "css-atrule" && e3.name.toLowerCase() === "supports" && delete t3.value, e3.type === "selector-unknown" && delete t3.value;
      }
      cN2.ignoredProperties = aN2;
      var lN2 = cN2;
      const { builders: { hardline: pN2, markAsRoot: fN2 } } = su2;
      var dN2 = function(e3, t3) {
        if (e3.lang === "yaml") {
          const n3 = e3.value.trim(), r3 = n3 ? t3(n3, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
          return fN2([e3.startDelimiter, pN2, r3, r3 ? pN2 : "", e3.endDelimiter]);
        }
      };
      const { builders: { hardline: hN2 } } = su2;
      var gN2 = function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (r3.type === "front-matter") {
          const e4 = dN2(r3, n3);
          return e4 ? [e4, hN2] : "";
        }
      };
      const mN2 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
      var yN2 = function(e3) {
        const t3 = e3.match(mN2);
        if (!t3)
          return { content: e3 };
        const { startDelimiter: n3, language: r3, value: i3 = "", endDelimiter: u3 } = t3.groups;
        let o3 = r3.trim() || "yaml";
        if (n3 === "+++" && (o3 = "toml"), o3 !== "yaml" && n3 !== u3)
          return { content: e3 };
        const [s3] = t3;
        return { frontMatter: { type: "front-matter", lang: o3, value: i3, startDelimiter: n3, endDelimiter: u3, raw: s3.replace(/\n$/, "") }, content: s3.replace(/[^\n]/g, " ") + e3.slice(s3.length) };
      };
      var DN2 = { hasPragma: function(e3) {
        return Rm2.hasPragma(yN2(e3).content);
      }, insertPragma: function(e3) {
        const { frontMatter: t3, content: n3 } = yN2(e3);
        return (t3 ? t3.raw + "\n\n" : "") + Rm2.insertPragma(n3);
      } };
      const { isNonEmptyArray: EN2 } = Fi2, CN2 = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), bN2 = new Set(["import", "use", "forward"]);
      function AN2(e3, t3) {
        const n3 = Array.isArray(t3) ? t3 : [t3];
        let r3, i3 = -1;
        for (; r3 = e3.getParentNode(++i3); )
          if (n3.includes(r3.type))
            return i3;
        return -1;
      }
      function vN2(e3, t3) {
        const n3 = AN2(e3, t3);
        return n3 === -1 ? null : e3.getParentNode(n3);
      }
      function FN2(e3) {
        return e3.type === "value-operator" && e3.value === "*";
      }
      function xN2(e3) {
        return e3.type === "value-operator" && e3.value === "/";
      }
      function SN2(e3) {
        return e3.type === "value-operator" && e3.value === "+";
      }
      function wN2(e3) {
        return e3.type === "value-operator" && e3.value === "-";
      }
      function TN2(e3) {
        return e3.type === "value-operator" && e3.value === "%";
      }
      function BN2(e3) {
        return e3.type === "value-comma_group" && e3.groups && e3.groups[1] && e3.groups[1].type === "value-colon";
      }
      function NN2(e3) {
        return e3.type === "value-paren_group" && e3.groups && e3.groups[0] && BN2(e3.groups[0]);
      }
      function kN2(e3) {
        return e3 && e3.type === "value-colon";
      }
      var PN2 = { getAncestorCounter: AN2, getAncestorNode: vN2, getPropOfDeclNode: function(e3) {
        const t3 = vN2(e3, "css-decl");
        return t3 && t3.prop && t3.prop.toLowerCase();
      }, hasSCSSInterpolation: function(e3) {
        if (EN2(e3)) {
          for (let t3 = e3.length - 1; t3 > 0; t3--)
            if (e3[t3].type === "word" && e3[t3].value === "{" && e3[t3 - 1].type === "word" && e3[t3 - 1].value.endsWith("#"))
              return true;
        }
        return false;
      }, hasStringOrFunction: function(e3) {
        if (EN2(e3)) {
          for (let t3 = 0; t3 < e3.length; t3++)
            if (e3[t3].type === "string" || e3[t3].type === "func")
              return true;
        }
        return false;
      }, maybeToLowerCase: function(e3) {
        return e3.includes("$") || e3.includes("@") || e3.includes("#") || e3.startsWith("%") || e3.startsWith("--") || e3.startsWith(":--") || e3.includes("(") && e3.includes(")") ? e3 : e3.toLowerCase();
      }, insideValueFunctionNode: function(e3, t3) {
        const n3 = vN2(e3, "value-func");
        return n3 && n3.value && n3.value.toLowerCase() === t3;
      }, insideICSSRuleNode: function(e3) {
        const t3 = vN2(e3, "css-rule");
        return t3 && t3.raws && t3.raws.selector && (t3.raws.selector.startsWith(":import") || t3.raws.selector.startsWith(":export"));
      }, insideAtRuleNode: function(e3, t3) {
        const n3 = Array.isArray(t3) ? t3 : [t3], r3 = vN2(e3, "css-atrule");
        return r3 && n3.includes(r3.name.toLowerCase());
      }, insideURLFunctionInImportAtRuleNode: function(e3) {
        const t3 = e3.getValue(), n3 = vN2(e3, "css-atrule");
        return n3 && n3.name === "import" && t3.groups[0].value === "url" && t3.groups.length === 2;
      }, isKeyframeAtRuleKeywords: function(e3, t3) {
        const n3 = vN2(e3, "css-atrule");
        return n3 && n3.name && n3.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t3.toLowerCase());
      }, isWideKeywords: function(e3) {
        return ["initial", "inherit", "unset", "revert"].includes(e3.toLowerCase());
      }, isSCSS: function(e3, t3) {
        return e3 === "less" || e3 === "scss" ? e3 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t3);
      }, isSCSSVariable: function(e3) {
        return Boolean(e3 && e3.type === "word" && e3.value.startsWith("$"));
      }, isLastNode: function(e3, t3) {
        const n3 = e3.getParentNode();
        if (!n3)
          return false;
        const { nodes: r3 } = n3;
        return r3 && r3.indexOf(t3) === r3.length - 1;
      }, isLessParser: function(e3) {
        return e3.parser === "css" || e3.parser === "less";
      }, isSCSSControlDirectiveNode: function(e3) {
        return e3.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e3.name);
      }, isDetachedRulesetDeclarationNode: function(e3) {
        return !!e3.selector && (typeof e3.selector == "string" && /^@.+:.*$/.test(e3.selector) || e3.selector.value && /^@.+:.*$/.test(e3.selector.value));
      }, isRelationalOperatorNode: function(e3) {
        return e3.type === "value-word" && ["<", ">", "<=", ">="].includes(e3.value);
      }, isEqualityOperatorNode: function(e3) {
        return e3.type === "value-word" && ["==", "!="].includes(e3.value);
      }, isMultiplicationNode: FN2, isDivisionNode: xN2, isAdditionNode: SN2, isSubtractionNode: wN2, isModuloNode: TN2, isMathOperatorNode: function(e3) {
        return FN2(e3) || xN2(e3) || SN2(e3) || wN2(e3) || TN2(e3);
      }, isEachKeywordNode: function(e3) {
        return e3.type === "value-word" && e3.value === "in";
      }, isForKeywordNode: function(e3) {
        return e3.type === "value-word" && ["from", "through", "end"].includes(e3.value);
      }, isURLFunctionNode: function(e3) {
        return e3.type === "value-func" && e3.value.toLowerCase() === "url";
      }, isIfElseKeywordNode: function(e3) {
        return e3.type === "value-word" && ["and", "or", "not"].includes(e3.value);
      }, hasComposesNode: function(e3) {
        return e3.value && e3.value.type === "value-root" && e3.value.group && e3.value.group.type === "value-value" && e3.prop.toLowerCase() === "composes";
      }, hasParensAroundNode: function(e3) {
        return e3.value && e3.value.group && e3.value.group.group && e3.value.group.group.type === "value-paren_group" && e3.value.group.group.open !== null && e3.value.group.group.close !== null;
      }, hasEmptyRawBefore: function(e3) {
        return e3.raws && e3.raws.before === "";
      }, isSCSSNestedPropertyNode: function(e3) {
        return !!e3.selector && e3.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
      }, isDetachedRulesetCallNode: function(e3) {
        return e3.raws && e3.raws.params && /^\(\s*\)$/.test(e3.raws.params);
      }, isTemplatePlaceholderNode: function(e3) {
        return e3.name.startsWith("prettier-placeholder");
      }, isTemplatePropNode: function(e3) {
        return e3.prop.startsWith("@prettier-placeholder");
      }, isPostcssSimpleVarNode: function(e3, t3) {
        return e3.value === "$$" && e3.type === "value-func" && t3 && t3.type === "value-word" && !t3.raws.before;
      }, isKeyValuePairNode: BN2, isKeyValuePairInParenGroupNode: NN2, isKeyInValuePairNode: function(e3, t3) {
        if (!BN2(t3))
          return false;
        const { groups: n3 } = t3, r3 = n3.indexOf(e3);
        return r3 !== -1 && kN2(n3[r3 + 1]);
      }, isSCSSMapItemNode: function(e3) {
        const t3 = e3.getValue();
        if (t3.groups.length === 0)
          return false;
        const n3 = e3.getParentNode(1);
        if (!(NN2(t3) || n3 && NN2(n3)))
          return false;
        const r3 = vN2(e3, "css-decl");
        return !!(r3 && r3.prop && r3.prop.startsWith("$")) || (!!NN2(n3) || n3.type === "value-func");
      }, isInlineValueCommentNode: function(e3) {
        return e3.type === "value-comment" && e3.inline;
      }, isHashNode: function(e3) {
        return e3.type === "value-word" && e3.value === "#";
      }, isLeftCurlyBraceNode: function(e3) {
        return e3.type === "value-word" && e3.value === "{";
      }, isRightCurlyBraceNode: function(e3) {
        return e3.type === "value-word" && e3.value === "}";
      }, isWordNode: function(e3) {
        return ["value-word", "value-atword"].includes(e3.type);
      }, isColonNode: kN2, isMediaAndSupportsKeywords: function(e3) {
        return e3.value && ["not", "and", "or"].includes(e3.value.toLowerCase());
      }, isColorAdjusterFuncNode: function(e3) {
        return e3.type === "value-func" && CN2.has(e3.value.toLowerCase());
      }, lastLineHasInlineComment: function(e3) {
        return /\/\//.test(e3.split(/[\n\r]/).pop());
      }, stringifyNode: function e3(t3) {
        if (t3.groups) {
          return (t3.open && t3.open.value ? t3.open.value : "") + t3.groups.reduce((n4, r4, i3) => n4 + e3(r4) + (t3.groups[0].type === "comma_group" && i3 !== t3.groups.length - 1 ? "," : ""), "") + (t3.close && t3.close.value ? t3.close.value : "");
        }
        const n3 = t3.raws && t3.raws.before ? t3.raws.before : "", r3 = t3.raws && t3.raws.quote ? t3.raws.quote : "";
        return n3 + r3 + (t3.type === "atword" ? "@" : "") + (t3.value ? t3.value : "") + r3 + (t3.unit ? t3.unit : "") + (t3.group ? e3(t3.group) : "") + (t3.raws && t3.raws.after ? t3.raws.after : "");
      }, isAtWordPlaceholderNode: function(e3) {
        return e3 && e3.type === "value-atword" && e3.value.startsWith("prettier-placeholder-");
      }, isModuleRuleName: function(e3) {
        return bN2.has(e3);
      } }, ON2 = function(e3, t3) {
        let n3 = 0;
        for (let r3 = 0; r3 < e3.line - 1; ++r3)
          n3 = t3.indexOf("\n", n3) + 1;
        return n3 + e3.column;
      };
      const { getLast: IN2, skipEverythingButNewLine: LN2 } = Fi2;
      function jN2(e3, t3) {
        return typeof e3.sourceIndex == "number" ? e3.sourceIndex : e3.source ? ON2(e3.source.start, t3) - 1 : null;
      }
      function _N2(e3, t3) {
        if (e3.type === "css-comment" && e3.inline)
          return LN2(t3, e3.source.startOffset);
        const n3 = e3.nodes && IN2(e3.nodes);
        return n3 && e3.source && !e3.source.end && (e3 = n3), e3.source && e3.source.end ? ON2(e3.source.end, t3) : null;
      }
      function MN2(e3, t3, n3) {
        e3.source && (e3.source.startOffset = jN2(e3, n3) + t3, e3.source.endOffset = _N2(e3, n3) + t3);
        for (const r3 in e3) {
          const i3 = e3[r3];
          r3 !== "source" && i3 && typeof i3 == "object" && MN2(i3, t3, n3);
        }
      }
      function RN2(e3) {
        let t3 = e3.source.startOffset;
        return typeof e3.prop == "string" && (t3 += e3.prop.length), e3.type === "css-atrule" && typeof e3.name == "string" && (t3 += 1 + e3.name.length + e3.raws.afterName.match(/^\s*:?\s*/)[0].length), e3.type !== "css-atrule" && e3.raws && typeof e3.raws.between == "string" && (t3 += e3.raws.between.length), t3;
      }
      var $N2 = { locStart: function(e3) {
        return e3.source.startOffset;
      }, locEnd: function(e3) {
        return e3.source.endOffset;
      }, calculateLoc: function e3(t3, n3) {
        t3.source && (t3.source.startOffset = jN2(t3, n3), t3.source.endOffset = _N2(t3, n3));
        for (const r3 in t3) {
          const i3 = t3[r3];
          r3 !== "source" && i3 && typeof i3 == "object" && (i3.type === "value-root" || i3.type === "value-unknown" ? MN2(i3, RN2(t3), i3.text || i3.value) : e3(i3, n3));
        }
      }, replaceQuotesInInlineComments: function(e3) {
        let t3, n3 = "initial", r3 = "initial", i3 = false;
        const u3 = [];
        for (let o3 = 0; o3 < e3.length; o3++) {
          const s3 = e3[o3];
          switch (n3) {
            case "initial":
              if (s3 === "'") {
                n3 = "single-quotes";
                continue;
              }
              if (s3 === '"') {
                n3 = "double-quotes";
                continue;
              }
              if ((s3 === "u" || s3 === "U") && e3.slice(o3, o3 + 4).toLowerCase() === "url(") {
                n3 = "url", o3 += 3;
                continue;
              }
              if (s3 === "*" && e3[o3 - 1] === "/") {
                n3 = "comment-block";
                continue;
              }
              if (s3 === "/" && e3[o3 - 1] === "/") {
                n3 = "comment-inline", t3 = o3 - 1;
                continue;
              }
              continue;
            case "single-quotes":
              if (s3 === "'" && e3[o3 - 1] !== "\\" && (n3 = r3, r3 = "initial"), s3 === "\n" || s3 === "\r")
                return e3;
              continue;
            case "double-quotes":
              if (s3 === '"' && e3[o3 - 1] !== "\\" && (n3 = r3, r3 = "initial"), s3 === "\n" || s3 === "\r")
                return e3;
              continue;
            case "url":
              if (s3 === ")" && (n3 = "initial"), s3 === "\n" || s3 === "\r")
                return e3;
              if (s3 === "'") {
                n3 = "single-quotes", r3 = "url";
                continue;
              }
              if (s3 === '"') {
                n3 = "double-quotes", r3 = "url";
                continue;
              }
              continue;
            case "comment-block":
              s3 === "/" && e3[o3 - 1] === "*" && (n3 = "initial");
              continue;
            case "comment-inline":
              s3 !== '"' && s3 !== "'" && s3 !== "*" || (i3 = true), s3 !== "\n" && s3 !== "\r" || (i3 && u3.push([t3, o3]), n3 = "initial", i3 = false);
              continue;
          }
        }
        for (const [t4, n4] of u3)
          e3 = e3.slice(0, t4) + e3.slice(t4, n4).replace(/["'*]/g, " ") + e3.slice(n4);
        return e3;
      } };
      const { printNumber: VN2, printString: WN2, hasNewline: qN2, isFrontMatterNode: UN2, isNextLineEmpty: zN2, isNonEmptyArray: GN2 } = Fi2, { builders: { join: HN2, line: JN2, hardline: XN2, softline: YN2, group: KN2, fill: QN2, indent: ZN2, dedent: ek2, ifBreak: tk2, breakParent: nk2 }, utils: { removeLines: rk2, getDocParts: ik2 } } = su2, { insertPragma: uk2 } = DN2, { getAncestorNode: ok2, getPropOfDeclNode: sk2, maybeToLowerCase: ak2, insideValueFunctionNode: ck2, insideICSSRuleNode: lk2, insideAtRuleNode: pk2, insideURLFunctionInImportAtRuleNode: fk2, isKeyframeAtRuleKeywords: dk2, isWideKeywords: hk2, isSCSS: gk2, isLastNode: mk2, isLessParser: yk2, isSCSSControlDirectiveNode: Dk2, isDetachedRulesetDeclarationNode: Ek2, isRelationalOperatorNode: Ck2, isEqualityOperatorNode: bk2, isMultiplicationNode: Ak2, isDivisionNode: vk2, isAdditionNode: Fk2, isSubtractionNode: xk2, isMathOperatorNode: Sk2, isEachKeywordNode: wk2, isForKeywordNode: Tk2, isURLFunctionNode: Bk2, isIfElseKeywordNode: Nk2, hasComposesNode: kk2, hasParensAroundNode: Pk2, hasEmptyRawBefore: Ok2, isKeyValuePairNode: Ik2, isKeyInValuePairNode: Lk2, isDetachedRulesetCallNode: jk2, isTemplatePlaceholderNode: _k2, isTemplatePropNode: Mk2, isPostcssSimpleVarNode: Rk2, isSCSSMapItemNode: $k2, isInlineValueCommentNode: Vk2, isHashNode: Wk2, isLeftCurlyBraceNode: qk2, isRightCurlyBraceNode: Uk2, isWordNode: zk2, isColonNode: Gk2, isMediaAndSupportsKeywords: Hk2, isColorAdjusterFuncNode: Jk2, lastLineHasInlineComment: Xk2, isAtWordPlaceholderNode: Yk2 } = PN2, { locStart: Kk2, locEnd: Qk2 } = $N2;
      function Zk2(e3) {
        return e3.trailingComma === "es5" || e3.trailingComma === "all";
      }
      function eP2(e3, t3, n3) {
        const r3 = [];
        return e3.each((e4, i3, u3) => {
          const o3 = u3[i3 - 1];
          if (o3 && o3.type === "css-comment" && o3.text.trim() === "prettier-ignore") {
            const n4 = e4.getValue();
            r3.push(t3.originalText.slice(Kk2(n4), Qk2(n4)));
          } else
            r3.push(n3());
          i3 !== u3.length - 1 && (u3[i3 + 1].type === "css-comment" && !qN2(t3.originalText, Kk2(u3[i3 + 1]), { backwards: true }) && !UN2(u3[i3]) || u3[i3 + 1].type === "css-atrule" && u3[i3 + 1].name === "else" && u3[i3].type !== "css-comment" ? r3.push(" ") : (r3.push(t3.__isHTMLStyleAttribute ? JN2 : XN2), zN2(t3.originalText, e4.getValue(), Qk2) && !UN2(u3[i3]) && r3.push(XN2)));
        }, "nodes"), r3;
      }
      const tP2 = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, nP2 = new RegExp(tP2.source + `|(${/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source})?(${/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source})(${/[A-Za-z]+/g.source})?`, "g");
      function rP2(e3, t3) {
        return e3.replace(tP2, (e4) => WN2(e4, t3));
      }
      function iP2(e3, t3) {
        const n3 = t3.singleQuote ? "'" : '"';
        return e3.includes('"') || e3.includes("'") ? e3 : n3 + e3 + n3;
      }
      function uP2(e3) {
        return e3.replace(nP2, (e4, t3, n3, r3, i3) => !n3 && r3 ? oP2(r3) + ak2(i3 || "") : e4);
      }
      function oP2(e3) {
        return VN2(e3).replace(/\.0(?=$|e)/, "");
      }
      var sP2 = { print: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!r3)
          return "";
        if (typeof r3 == "string")
          return r3;
        switch (r3.type) {
          case "front-matter":
            return [r3.raw, XN2];
          case "css-root": {
            const i3 = eP2(e3, t3, n3), u3 = r3.raws.after.trim();
            return [i3, u3 ? ` ${u3}` : "", ik2(i3).length > 0 ? XN2 : ""];
          }
          case "css-comment": {
            const e4 = r3.inline || r3.raws.inline, n4 = t3.originalText.slice(Kk2(r3), Qk2(r3));
            return e4 ? n4.trimEnd() : n4;
          }
          case "css-rule":
            return [n3("selector"), r3.important ? " !important" : "", r3.nodes ? [r3.selector && r3.selector.type === "selector-unknown" && Xk2(r3.selector.value) ? JN2 : " ", "{", r3.nodes.length > 0 ? ZN2([XN2, eP2(e3, t3, n3)]) : "", XN2, "}", Ek2(r3) ? ";" : ""] : ";"];
          case "css-decl": {
            const i3 = e3.getParentNode(), { between: u3 } = r3.raws, o3 = u3.trim(), s3 = o3 === ":";
            let a3 = kk2(r3) ? rk2(n3("value")) : n3("value");
            return !s3 && Xk2(o3) && (a3 = ZN2([XN2, ek2(a3)])), [r3.raws.before.replace(/[\s;]/g, ""), lk2(e3) ? r3.prop : ak2(r3.prop), o3.startsWith("//") ? " " : "", o3, r3.extend ? "" : " ", yk2(t3) && r3.extend && r3.selector ? ["extend(", n3("selector"), ")"] : "", a3, r3.raws.important ? r3.raws.important.replace(/\s*!\s*important/i, " !important") : r3.important ? " !important" : "", r3.raws.scssDefault ? r3.raws.scssDefault.replace(/\s*!default/i, " !default") : r3.scssDefault ? " !default" : "", r3.raws.scssGlobal ? r3.raws.scssGlobal.replace(/\s*!global/i, " !global") : r3.scssGlobal ? " !global" : "", r3.nodes ? [" {", ZN2([YN2, eP2(e3, t3, n3)]), YN2, "}"] : Mk2(r3) && !i3.raws.semicolon && t3.originalText[Qk2(r3) - 1] !== ";" ? "" : t3.__isHTMLStyleAttribute && mk2(e3, r3) ? tk2(";") : ";"];
          }
          case "css-atrule": {
            const i3 = e3.getParentNode(), u3 = _k2(r3) && !i3.raws.semicolon && t3.originalText[Qk2(r3) - 1] !== ";";
            if (yk2(t3)) {
              if (r3.mixin)
                return [n3("selector"), r3.important ? " !important" : "", u3 ? "" : ";"];
              if (r3.function)
                return [r3.name, n3("params"), u3 ? "" : ";"];
              if (r3.variable)
                return ["@", r3.name, ": ", r3.value ? n3("value") : "", r3.raws.between.trim() ? r3.raws.between.trim() + " " : "", r3.nodes ? ["{", ZN2([r3.nodes.length > 0 ? YN2 : "", eP2(e3, t3, n3)]), YN2, "}"] : "", u3 ? "" : ";"];
            }
            return ["@", jk2(r3) || r3.name.endsWith(":") ? r3.name : ak2(r3.name), r3.params ? [jk2(r3) ? "" : _k2(r3) ? r3.raws.afterName === "" ? "" : r3.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r3.raws.afterName) ? [XN2, XN2] : /^\s*\n/.test(r3.raws.afterName) ? XN2 : " " : " ", n3("params")] : "", r3.selector ? ZN2([" ", n3("selector")]) : "", r3.value ? KN2([" ", n3("value"), Dk2(r3) ? Pk2(r3) ? " " : JN2 : ""]) : r3.name === "else" ? " " : "", r3.nodes ? [Dk2(r3) ? "" : r3.selector && !r3.selector.nodes && typeof r3.selector.value == "string" && Xk2(r3.selector.value) || !r3.selector && typeof r3.params == "string" && Xk2(r3.params) ? JN2 : " ", "{", ZN2([r3.nodes.length > 0 ? YN2 : "", eP2(e3, t3, n3)]), YN2, "}"] : u3 ? "" : ";"];
          }
          case "media-query-list": {
            const t4 = [];
            return e3.each((e4) => {
              const r4 = e4.getValue();
              r4.type === "media-query" && r4.value === "" || t4.push(n3());
            }, "nodes"), KN2(ZN2(HN2(JN2, t4)));
          }
          case "media-query":
            return [HN2(" ", e3.map(n3, "nodes")), mk2(e3, r3) ? "" : ","];
          case "media-type":
            return uP2(rP2(r3.value, t3));
          case "media-feature-expression":
            return r3.nodes ? ["(", ...e3.map(n3, "nodes"), ")"] : r3.value;
          case "media-feature":
            return ak2(rP2(r3.value.replace(/ +/g, " "), t3));
          case "media-colon":
            return [r3.value, " "];
          case "media-value":
            return uP2(rP2(r3.value, t3));
          case "media-keyword":
            return rP2(r3.value, t3);
          case "media-url":
            return rP2(r3.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t3);
          case "media-unknown":
            return r3.value;
          case "selector-root":
            return KN2([pk2(e3, "custom-selector") ? [ok2(e3, "css-atrule").customSelector, JN2] : "", HN2([",", pk2(e3, ["extend", "custom-selector", "nest"]) ? JN2 : XN2], e3.map(n3, "nodes"))]);
          case "selector-selector":
            return KN2(ZN2(e3.map(n3, "nodes")));
          case "selector-comment":
            return r3.value;
          case "selector-string":
            return rP2(r3.value, t3);
          case "selector-tag": {
            const t4 = e3.getParentNode(), n4 = t4 && t4.nodes.indexOf(r3), i3 = n4 && t4.nodes[n4 - 1];
            return [r3.namespace ? [r3.namespace === true ? "" : r3.namespace.trim(), "|"] : "", i3.type === "selector-nesting" ? r3.value : uP2(dk2(e3, r3.value) ? r3.value.toLowerCase() : r3.value)];
          }
          case "selector-id":
            return ["#", r3.value];
          case "selector-class":
            return [".", uP2(rP2(r3.value, t3))];
          case "selector-attribute":
            return ["[", r3.namespace ? [r3.namespace === true ? "" : r3.namespace.trim(), "|"] : "", r3.attribute.trim(), r3.operator ? r3.operator : "", r3.value ? iP2(rP2(r3.value.trim(), t3), t3) : "", r3.insensitive ? " i" : "", "]"];
          case "selector-combinator":
            if (r3.value === "+" || r3.value === ">" || r3.value === "~" || r3.value === ">>>") {
              const t4 = e3.getParentNode();
              return [t4.type === "selector-selector" && t4.nodes[0] === r3 ? "" : JN2, r3.value, mk2(e3, r3) ? "" : " "];
            }
            return [r3.value.trim().startsWith("(") ? JN2 : "", uP2(rP2(r3.value.trim(), t3)) || JN2];
          case "selector-universal":
            return [r3.namespace ? [r3.namespace === true ? "" : r3.namespace.trim(), "|"] : "", r3.value];
          case "selector-pseudo":
            return [ak2(r3.value), GN2(r3.nodes) ? ["(", HN2(", ", e3.map(n3, "nodes")), ")"] : ""];
          case "selector-nesting":
            return r3.value;
          case "selector-unknown": {
            const n4 = ok2(e3, "css-rule");
            if (n4 && n4.isSCSSNesterProperty)
              return uP2(rP2(ak2(r3.value), t3));
            const i3 = e3.getParentNode();
            if (i3.raws && i3.raws.selector) {
              const e4 = Kk2(i3), n5 = e4 + i3.raws.selector.length;
              return t3.originalText.slice(e4, n5).trim();
            }
            const u3 = e3.getParentNode(1);
            if (i3.type === "value-paren_group" && u3 && u3.type === "value-func" && u3.value === "selector") {
              const e4 = Kk2(i3.open) + 1, n5 = Qk2(i3.close) - 1, r4 = t3.originalText.slice(e4, n5).trim();
              return Xk2(r4) ? [nk2, r4] : r4;
            }
            return r3.value;
          }
          case "value-value":
          case "value-root":
            return n3("group");
          case "value-comment":
            return t3.originalText.slice(Kk2(r3), Qk2(r3));
          case "value-comma_group": {
            const t4 = e3.getParentNode(), i3 = e3.getParentNode(1), u3 = sk2(e3), o3 = u3 && t4.type === "value-value" && (u3 === "grid" || u3.startsWith("grid-template")), s3 = ok2(e3, "css-atrule"), a3 = s3 && Dk2(s3), c3 = r3.groups.some((e4) => Vk2(e4)), l3 = e3.map(n3, "groups"), p3 = [], f3 = ck2(e3, "url");
            let d3 = false, h3 = false;
            for (let n4 = 0; n4 < r3.groups.length; ++n4) {
              p3.push(l3[n4]);
              const u4 = r3.groups[n4 - 1], c4 = r3.groups[n4], g3 = r3.groups[n4 + 1], m3 = r3.groups[n4 + 2];
              if (f3) {
                (g3 && Fk2(g3) || Fk2(c4)) && p3.push(" ");
                continue;
              }
              if (pk2(e3, "forward") && c4.type === "value-word" && c4.value && u4.type === "value-word" && u4.value === "as" && g3.type === "value-operator" && g3.value === "*")
                continue;
              if (!g3)
                continue;
              if (c4.type === "value-word" && c4.value.endsWith("-") && Yk2(g3))
                continue;
              const y3 = c4.type === "value-string" && c4.value.startsWith("#{"), D3 = d3 && g3.type === "value-string" && g3.value.endsWith("}");
              if (y3 || D3) {
                d3 = !d3;
                continue;
              }
              if (d3)
                continue;
              if (Gk2(c4) || Gk2(g3))
                continue;
              if (c4.type === "value-atword" && c4.value === "")
                continue;
              if (c4.value === "~")
                continue;
              if (c4.value && c4.value.includes("\\") && g3 && g3.type !== "value-comment")
                continue;
              if (u4 && u4.value && u4.value.indexOf("\\") === u4.value.length - 1 && c4.type === "value-operator" && c4.value === "/")
                continue;
              if (c4.value === "\\")
                continue;
              if (Rk2(c4, g3))
                continue;
              if (Wk2(c4) || qk2(c4) || Uk2(g3) || qk2(g3) && Ok2(g3) || Uk2(c4) && Ok2(g3))
                continue;
              if (c4.value === "--" && Wk2(g3))
                continue;
              const E3 = Sk2(c4), C3 = Sk2(g3);
              if ((E3 && Wk2(g3) || C3 && Uk2(c4)) && Ok2(g3))
                continue;
              if (!u4 && vk2(c4))
                continue;
              if (ck2(e3, "calc") && (Fk2(c4) || Fk2(g3) || xk2(c4) || xk2(g3)) && Ok2(g3))
                continue;
              const b3 = (Fk2(c4) || xk2(c4)) && n4 === 0 && (g3.type === "value-number" || g3.isHex) && i3 && Jk2(i3) && !Ok2(g3), A3 = m3 && m3.type === "value-func" || m3 && zk2(m3) || c4.type === "value-func" || zk2(c4), v3 = g3.type === "value-func" || zk2(g3) || u4 && u4.type === "value-func" || u4 && zk2(u4);
              if (Ak2(g3) || Ak2(c4) || ck2(e3, "calc") || b3 || !(vk2(g3) && !A3 || vk2(c4) && !v3 || Fk2(g3) && !A3 || Fk2(c4) && !v3 || xk2(g3) || xk2(c4)) || !(Ok2(g3) || E3 && (!u4 || u4 && Sk2(u4))))
                if (Vk2(c4)) {
                  if (t4.type === "value-paren_group") {
                    p3.push(ek2(XN2));
                    continue;
                  }
                  p3.push(XN2);
                } else
                  a3 && (bk2(g3) || Ck2(g3) || Nk2(g3) || wk2(c4) || Tk2(c4)) || s3 && s3.name.toLowerCase() === "namespace" ? p3.push(" ") : o3 ? c4.source && g3.source && c4.source.start.line !== g3.source.start.line ? (p3.push(XN2), h3 = true) : p3.push(" ") : C3 ? p3.push(" ") : g3 && g3.value === "..." || Yk2(c4) && Yk2(g3) && Qk2(c4) === Kk2(g3) || p3.push(JN2);
            }
            return c3 && p3.push(nk2), h3 && p3.unshift(XN2), a3 ? KN2(ZN2(p3)) : fk2(e3) ? KN2(QN2(p3)) : KN2(ZN2(QN2(p3)));
          }
          case "value-paren_group": {
            const i3 = e3.getParentNode();
            if (i3 && Bk2(i3) && (r3.groups.length === 1 || r3.groups.length > 0 && r3.groups[0].type === "value-comma_group" && r3.groups[0].groups.length > 0 && r3.groups[0].groups[0].type === "value-word" && r3.groups[0].groups[0].value.startsWith("data:")))
              return [r3.open ? n3("open") : "", HN2(",", e3.map(n3, "groups")), r3.close ? n3("close") : ""];
            if (!r3.open) {
              const t4 = e3.map(n3, "groups"), r4 = [];
              for (let e4 = 0; e4 < t4.length; e4++)
                e4 !== 0 && r4.push([",", JN2]), r4.push(t4[e4]);
              return KN2(ZN2(QN2(r4)));
            }
            const u3 = $k2(e3), o3 = _n2(r3.groups), s3 = o3 && o3.type === "value-comment", a3 = Lk2(r3, i3), c3 = KN2([r3.open ? n3("open") : "", ZN2([YN2, HN2([",", JN2], e3.map((e4) => {
              const t4 = e4.getValue(), r4 = n3();
              if (Ik2(t4) && t4.type === "value-comma_group" && t4.groups && t4.groups[0].type !== "value-paren_group" && t4.groups[2] && t4.groups[2].type === "value-paren_group") {
                const e5 = ik2(r4.contents.contents);
                return e5[1] = KN2(e5[1]), KN2(ek2(r4));
              }
              return r4;
            }, "groups"))]), tk2(!s3 && gk2(t3.parser, t3.originalText) && u3 && Zk2(t3) ? "," : ""), YN2, r3.close ? n3("close") : ""], { shouldBreak: u3 && !a3 });
            return a3 ? ek2(c3) : c3;
          }
          case "value-func":
            return [r3.value, pk2(e3, "supports") && Hk2(r3) ? " " : "", n3("group")];
          case "value-paren":
            return r3.value;
          case "value-number":
            return [oP2(r3.value), ak2(r3.unit)];
          case "value-operator":
            return r3.value;
          case "value-word":
            return r3.isColor && r3.isHex || hk2(r3.value) ? r3.value.toLowerCase() : r3.value;
          case "value-colon": {
            const t4 = e3.getParentNode(), n4 = t4 && t4.groups.indexOf(r3), i3 = n4 && t4.groups[n4 - 1];
            return [r3.value, i3 && typeof i3.value == "string" && _n2(i3.value) === "\\" || ck2(e3, "url") ? "" : JN2];
          }
          case "value-comma":
            return [r3.value, " "];
          case "value-string":
            return WN2(r3.raws.quote + r3.value + r3.raws.quote, t3);
          case "value-atword":
            return ["@", r3.value];
          case "value-unicode-range":
          case "value-unknown":
            return r3.value;
          default:
            throw new Error(`Unknown postcss type ${JSON.stringify(r3.type)}`);
        }
      }, embed: gN2, insertPragma: uk2, massageAstNode: lN2 }, aP2 = { singleQuote: KB2.singleQuote }, cP2 = { name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 }, lP2 = { name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 }, pP2 = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
      var fP2 = { languages: [rh2({ name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 }, (e3) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e3.extensions, ".wxss"] })), rh2(cP2, () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), rh2(lP2, () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), rh2(pP2, () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], options: aP2, printers: { postcss: sP2 }, parsers: void 0 };
      var dP2 = { locStart: function(e3) {
        return e3.loc.start.offset;
      }, locEnd: function(e3) {
        return e3.loc.end.offset;
      } };
      function hP2(e3, t3) {
        if (e3.type === "TextNode") {
          const n3 = e3.chars.trim();
          if (!n3)
            return null;
          t3.chars = n3.replace(/[\t\n\f\r ]+/g, " ");
        }
        e3.type === "AttrNode" && e3.name.toLowerCase() === "class" && delete t3.value;
      }
      hP2.ignoredProperties = new Set(["loc", "selfClosing"]);
      var gP2 = hP2;
      const mP2 = new Set(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
      function yP2(e3) {
        return DP2(e3, ["TextNode"]) && !/\S/.test(e3.chars);
      }
      function DP2(e3, t3) {
        return e3 && t3.includes(e3.type);
      }
      function EP2(e3, t3) {
        return DP2(e3.getParentNode(0), t3);
      }
      function CP2(e3, t3) {
        const n3 = e3.getValue(), r3 = e3.getParentNode(0) || {}, i3 = r3.children || r3.body || r3.parts || [], u3 = i3.indexOf(n3);
        return u3 !== -1 && i3[u3 + t3];
      }
      function bP2(e3, t3 = 1) {
        return CP2(e3, -t3);
      }
      function AP2(e3) {
        return CP2(e3, 1);
      }
      function vP2(e3) {
        return DP2(e3, ["MustacheCommentStatement"]) && typeof e3.value == "string" && e3.value.trim() === "prettier-ignore";
      }
      var FP2 = { getNextNode: AP2, getPreviousNode: bP2, hasPrettierIgnore: function(e3) {
        const t3 = e3.getValue(), n3 = bP2(e3, 2);
        return vP2(t3) || vP2(n3);
      }, isLastNodeOfSiblings: function(e3) {
        const t3 = e3.getValue(), n3 = e3.getParentNode(0);
        return !(!EP2(e3, ["ElementNode"]) || _n2(n3.children) !== t3) || !(!EP2(e3, ["Block"]) || _n2(n3.body) !== t3);
      }, isNextNodeOfSomeType: function(e3, t3) {
        return DP2(AP2(e3), t3);
      }, isNodeOfSomeType: DP2, isParentOfSomeType: EP2, isPreviousNodeOfSomeType: function(e3, t3) {
        return DP2(bP2(e3), t3);
      }, isVoid: function(e3) {
        return function(e4) {
          return DP2(e4, ["ElementNode"]) && typeof e4.tag == "string" && (function(e5) {
            return e5.toUpperCase() === e5;
          }(e4.tag[0]) || e4.tag.includes("."));
        }(e3) && e3.children.every((e4) => yP2(e4)) || mP2.has(e3.tag);
      }, isWhitespaceNode: yP2 };
      const { builders: { dedent: xP2, fill: SP2, group: wP2, hardline: TP2, ifBreak: BP2, indent: NP2, join: kP2, line: PP2, softline: OP2 }, utils: { getDocParts: IP2, replaceTextEndOfLine: LP2 } } = su2, { isNonEmptyArray: jP2 } = Fi2, { locStart: _P2, locEnd: MP2 } = dP2, { getNextNode: RP2, getPreviousNode: $P2, hasPrettierIgnore: VP2, isLastNodeOfSiblings: WP2, isNextNodeOfSomeType: qP2, isNodeOfSomeType: UP2, isParentOfSomeType: zP2, isPreviousNodeOfSomeType: GP2, isVoid: HP2, isWhitespaceNode: JP2 } = FP2;
      function XP2(e3, t3) {
        return _P2(e3) - _P2(t3);
      }
      function YP2(e3, t3, n3) {
        const r3 = e3.getValue().children.every((e4) => JP2(e4));
        return t3.htmlWhitespaceSensitivity === "ignore" && r3 ? "" : e3.map((e4, r4) => {
          const i3 = n3();
          return r4 === 0 && t3.htmlWhitespaceSensitivity === "ignore" ? [OP2, i3] : i3;
        }, "children");
      }
      function KP2(e3) {
        return HP2(e3) ? BP2([OP2, "/>"], [" />", OP2]) : BP2([OP2, ">"], ">");
      }
      function QP2(e3) {
        return [e3.escaped === false ? "{{{" : "{{", e3.strip && e3.strip.open ? "~" : ""];
      }
      function ZP2(e3) {
        const t3 = e3.escaped === false ? "}}}" : "}}";
        return [e3.strip && e3.strip.close ? "~" : "", t3];
      }
      function eO2(e3) {
        return [QP2(e3), e3.closeStrip.open ? "~" : "", "/"];
      }
      function tO2(e3) {
        const t3 = ZP2(e3);
        return [e3.closeStrip.close ? "~" : "", t3];
      }
      function nO2(e3) {
        return [QP2(e3), e3.inverseStrip.open ? "~" : ""];
      }
      function rO2(e3) {
        const t3 = ZP2(e3);
        return [e3.inverseStrip.close ? "~" : "", t3];
      }
      function iO2(e3, t3) {
        const n3 = e3.getValue(), r3 = function(e4) {
          return [QP2(e4), e4.openStrip.open ? "~" : "", "#"];
        }(n3), i3 = function(e4) {
          const t4 = ZP2(e4);
          return [e4.openStrip.close ? "~" : "", t4];
        }(n3), u3 = [DO2(e3, t3)], o3 = EO2(e3, t3);
        if (o3 && u3.push(PP2, o3), jP2(n3.program.blockParams)) {
          const e4 = CO2(n3.program);
          u3.push(PP2, e4);
        }
        return wP2([r3, NP2(u3), OP2, i3]);
      }
      function uO2(e3, t3) {
        return [t3.htmlWhitespaceSensitivity === "ignore" ? TP2 : "", nO2(e3), "else", rO2(e3)];
      }
      function oO2(e3, t3) {
        const n3 = e3.getParentNode(1);
        return [nO2(n3), "else if ", EO2(e3, t3), rO2(n3)];
      }
      function sO2(e3, t3, n3) {
        const r3 = e3.getValue();
        if (n3.htmlWhitespaceSensitivity === "ignore") {
          return [aO2(r3) ? OP2 : TP2, eO2(r3), t3("path"), tO2(r3)];
        }
        return [eO2(r3), t3("path"), tO2(r3)];
      }
      function aO2(e3) {
        return UP2(e3, ["BlockStatement"]) && e3.program.body.every((e4) => JP2(e4));
      }
      function cO2(e3) {
        return UP2(e3, ["BlockStatement"]) && e3.inverse;
      }
      function lO2(e3, t3, n3) {
        if (aO2(e3.getValue()))
          return "";
        const r3 = t3("program");
        return n3.htmlWhitespaceSensitivity === "ignore" ? NP2([TP2, r3]) : NP2(r3);
      }
      function pO2(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = t3("inverse"), u3 = n3.htmlWhitespaceSensitivity === "ignore" ? [TP2, i3] : i3;
        return function(e4) {
          return cO2(e4) && e4.inverse.body.length === 1 && UP2(e4.inverse.body[0], ["BlockStatement"]) && e4.inverse.body[0].path.parts[0] === "if";
        }(r3) ? u3 : cO2(r3) ? [uO2(r3, n3), NP2(u3)] : "";
      }
      function fO2(e3) {
        return IP2(kP2(PP2, function(e4) {
          return e4.split(/[\t\n\f\r ]+/);
        }(e3)));
      }
      function dO2(e3) {
        return (e3 = typeof e3 == "string" ? e3 : "").split("\n").length - 1;
      }
      function hO2(e3 = 0) {
        return new Array(Math.min(e3, 2)).fill(TP2);
      }
      function gO2(e3, t3) {
        const n3 = { quote: '"', regex: /"/g }, r3 = { quote: "'", regex: /'/g }, i3 = e3.singleQuote ? r3 : n3, u3 = i3 === r3 ? n3 : r3;
        let o3 = false;
        if (t3.includes(i3.quote) || t3.includes(u3.quote)) {
          o3 = (t3.match(i3.regex) || []).length > (t3.match(u3.regex) || []).length;
        }
        return o3 ? u3 : i3;
      }
      function mO2(e3, t3) {
        const n3 = DO2(e3, t3), r3 = EO2(e3, t3);
        return r3 ? NP2([n3, PP2, wP2(r3)]) : n3;
      }
      function yO2(e3, t3) {
        const n3 = DO2(e3, t3), r3 = EO2(e3, t3);
        return r3 ? [NP2([n3, PP2, r3]), OP2] : n3;
      }
      function DO2(e3, t3) {
        return t3("path");
      }
      function EO2(e3, t3) {
        const n3 = e3.getValue(), r3 = [];
        if (n3.params.length > 0) {
          const n4 = e3.map(t3, "params");
          r3.push(...n4);
        }
        if (n3.hash && n3.hash.pairs.length > 0) {
          const e4 = t3("hash");
          r3.push(e4);
        }
        return r3.length === 0 ? "" : kP2(PP2, r3);
      }
      function CO2(e3) {
        return ["as |", e3.blockParams.join(" "), "|"];
      }
      var bO2 = { print: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!r3)
          return "";
        if (VP2(e3))
          return t3.originalText.slice(_P2(r3), MP2(r3));
        switch (r3.type) {
          case "Block":
          case "Program":
          case "Template":
            return wP2(e3.map(n3, "body"));
          case "ElementNode": {
            const i3 = wP2(function(e4, t4) {
              const n4 = e4.getValue(), r4 = ["attributes", "modifiers", "comments"].filter((e5) => jP2(n4[e5])), i4 = r4.flatMap((e5) => n4[e5]).sort(XP2);
              for (const n5 of r4)
                e4.each((e5) => {
                  const n6 = i4.indexOf(e5.getValue());
                  i4.splice(n6, 1, [PP2, t4()]);
                }, n5);
              jP2(n4.blockParams) && i4.push(PP2, CO2(n4));
              return ["<", n4.tag, NP2(i4), KP2(n4)];
            }(e3, n3)), u3 = t3.htmlWhitespaceSensitivity === "ignore" && qP2(e3, ["ElementNode"]) ? OP2 : "";
            if (HP2(r3))
              return [i3, u3];
            const o3 = ["</", r3.tag, ">"];
            return r3.children.length === 0 ? [i3, NP2(o3), u3] : t3.htmlWhitespaceSensitivity === "ignore" ? [i3, NP2(YP2(e3, t3, n3)), TP2, NP2(o3), u3] : [i3, NP2(wP2(YP2(e3, t3, n3))), NP2(o3), u3];
          }
          case "BlockStatement": {
            const i3 = e3.getParentNode(1);
            return i3 && i3.inverse && i3.inverse.body.length === 1 && i3.inverse.body[0] === r3 && i3.inverse.body[0].path.parts[0] === "if" ? [oO2(e3, n3), lO2(e3, n3, t3), pO2(e3, n3, t3)] : [iO2(e3, n3), wP2([lO2(e3, n3, t3), pO2(e3, n3, t3), sO2(e3, n3, t3)])];
          }
          case "ElementModifierStatement":
            return wP2(["{{", yO2(e3, n3), "}}"]);
          case "MustacheStatement":
            return wP2([QP2(r3), yO2(e3, n3), ZP2(r3)]);
          case "SubExpression":
            return wP2(["(", mO2(e3, n3), OP2, ")"]);
          case "AttrNode": {
            const e4 = r3.value.type === "TextNode";
            if (e4 && r3.value.chars === "" && _P2(r3.value) === MP2(r3.value))
              return r3.name;
            const i3 = e4 ? gO2(t3, r3.value.chars).quote : r3.value.type === "ConcatStatement" ? gO2(t3, r3.value.parts.filter((e5) => e5.type === "TextNode").map((e5) => e5.chars).join("")).quote : "", u3 = n3("value");
            return [r3.name, "=", i3, r3.name === "class" && i3 ? wP2(NP2(u3)) : u3, i3];
          }
          case "ConcatStatement":
            return e3.map(n3, "parts");
          case "Hash":
            return kP2(PP2, e3.map(n3, "pairs"));
          case "HashPair":
            return [r3.key, "=", n3("value")];
          case "TextNode": {
            let n4 = r3.chars.replace(/{{/g, "\\{{");
            const i3 = function(e4) {
              for (let t4 = 0; t4 < 2; t4++) {
                const n5 = e4.getParentNode(t4);
                if (n5 && n5.type === "AttrNode")
                  return n5.name.toLowerCase();
              }
            }(e3);
            if (i3) {
              if (i3 === "class") {
                const t4 = n4.trim().split(/\s+/).join(" ");
                let r4 = false, i4 = false;
                return zP2(e3, ["ConcatStatement"]) && (GP2(e3, ["MustacheStatement"]) && /^\s/.test(n4) && (r4 = true), qP2(e3, ["MustacheStatement"]) && /\s$/.test(n4) && t4 !== "" && (i4 = true)), [r4 ? PP2 : "", t4, i4 ? PP2 : ""];
              }
              return LP2(n4);
            }
            const u3 = /^[\t\n\f\r ]*$/.test(n4), o3 = !$P2(e3), s3 = !RP2(e3);
            if (t3.htmlWhitespaceSensitivity !== "ignore") {
              const t4 = /^[\t\n\f\r ]*/, r4 = /[\t\n\f\r ]*$/, i4 = s3 && zP2(e3, ["Template"]), a4 = o3 && zP2(e3, ["Template"]);
              if (u3) {
                if (a4 || i4)
                  return "";
                let t5 = [PP2];
                const r5 = dO2(n4);
                return r5 && (t5 = hO2(r5)), WP2(e3) && (t5 = t5.map((e4) => xP2(e4))), t5;
              }
              const [c4] = n4.match(t4), [l4] = n4.match(r4);
              let p4 = [];
              if (c4) {
                p4 = [PP2];
                const e4 = dO2(c4);
                e4 && (p4 = hO2(e4)), n4 = n4.replace(t4, "");
              }
              let f4 = [];
              if (l4) {
                if (!i4) {
                  f4 = [PP2];
                  const t5 = dO2(l4);
                  t5 && (f4 = hO2(t5)), WP2(e3) && (f4 = f4.map((e4) => xP2(e4)));
                }
                n4 = n4.replace(r4, "");
              }
              return [...p4, SP2(fO2(n4)), ...f4];
            }
            const a3 = dO2(n4);
            let c3 = function(e4) {
              return dO2(((e4 = typeof e4 == "string" ? e4 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
            }(n4), l3 = function(e4) {
              return dO2(((e4 = typeof e4 == "string" ? e4 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
            }(n4);
            if ((o3 || s3) && u3 && zP2(e3, ["Block", "ElementNode", "Template"]))
              return "";
            u3 && a3 ? (c3 = Math.min(a3, 2), l3 = 0) : (qP2(e3, ["BlockStatement", "ElementNode"]) && (l3 = Math.max(l3, 1)), GP2(e3, ["BlockStatement", "ElementNode"]) && (c3 = Math.max(c3, 1)));
            let p3 = "", f3 = "";
            return l3 === 0 && qP2(e3, ["MustacheStatement"]) && (f3 = " "), c3 === 0 && GP2(e3, ["MustacheStatement"]) && (p3 = " "), o3 && (c3 = 0, p3 = ""), s3 && (l3 = 0, f3 = ""), n4 = n4.replace(/^[\t\n\f\r ]+/g, p3).replace(/[\t\n\f\r ]+$/, f3), [...hO2(c3), SP2(fO2(n4)), ...hO2(l3)];
          }
          case "MustacheCommentStatement": {
            const e4 = _P2(r3), n4 = MP2(r3), i3 = t3.originalText.charAt(e4 + 2) === "~", u3 = t3.originalText.charAt(n4 - 3) === "~", o3 = r3.value.includes("}}") ? "--" : "";
            return ["{{", i3 ? "~" : "", "!", o3, r3.value, o3, u3 ? "~" : "", "}}"];
          }
          case "PathExpression":
            return r3.original;
          case "BooleanLiteral":
            return String(r3.value);
          case "CommentStatement":
            return ["<!--", r3.value, "-->"];
          case "StringLiteral":
            return function(e4, t4) {
              const { quote: n4, regex: r4 } = gO2(t4, e4);
              return [n4, e4.replace(r4, `\\${n4}`), n4];
            }(r3.value, t3);
          case "NumberLiteral":
            return String(r3.value);
          case "UndefinedLiteral":
            return "undefined";
          case "NullLiteral":
            return "null";
          default:
            throw new Error("unknown glimmer type: " + JSON.stringify(r3.type));
        }
      }, massageAstNode: gP2 };
      var AO2 = { languages: [rh2({ name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 }, () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], printers: { glimmer: bO2 }, parsers: void 0 };
      var vO2 = { hasPragma: function(e3) {
        return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e3);
      }, insertPragma: function(e3) {
        return "# @format\n\n" + e3;
      } };
      var FO2 = { locStart: function(e3) {
        return typeof e3.start == "number" ? e3.start : e3.loc && e3.loc.start;
      }, locEnd: function(e3) {
        return typeof e3.end == "number" ? e3.end : e3.loc && e3.loc.end;
      } };
      const { builders: { join: xO2, hardline: SO2, line: wO2, softline: TO2, group: BO2, indent: NO2, ifBreak: kO2 } } = su2, { isNextLineEmpty: PO2, isNonEmptyArray: OO2 } = Fi2, { insertPragma: IO2 } = vO2, { locStart: LO2, locEnd: jO2 } = FO2;
      function _O2(e3, t3, n3) {
        if (n3.directives.length === 0)
          return "";
        const r3 = xO2(wO2, e3.map(t3, "directives"));
        return n3.kind === "FragmentDefinition" || n3.kind === "OperationDefinition" ? BO2([wO2, r3]) : [" ", BO2(NO2([TO2, r3]))];
      }
      function MO2(e3, t3, n3) {
        const r3 = e3.getValue().length;
        return e3.map((e4, i3) => {
          const u3 = n3();
          return PO2(t3.originalText, e4.getValue(), jO2) && i3 < r3 - 1 ? [u3, SO2] : u3;
        });
      }
      function RO2(e3, t3, n3) {
        const r3 = e3.getNode(), i3 = [], { interfaces: u3 } = r3, o3 = e3.map((e4) => n3(e4), "interfaces");
        for (let e4 = 0; e4 < u3.length; e4++) {
          const n4 = u3[e4];
          i3.push(o3[e4]);
          const r4 = u3[e4 + 1];
          if (r4) {
            const e5 = t3.originalText.slice(n4.loc.end, r4.loc.start), u4 = e5.includes("#"), o4 = e5.replace(/#.*/g, "").trim();
            i3.push(o4 === "," ? "," : " &", u4 ? wO2 : " ");
          }
        }
        return i3;
      }
      function $O2() {
      }
      $O2.ignoredProperties = new Set(["loc", "comments"]);
      var VO2 = { print: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!r3)
          return "";
        if (typeof r3 == "string")
          return r3;
        switch (r3.kind) {
          case "Document": {
            const r4 = [];
            return e3.each((e4, i3, u3) => {
              r4.push(n3()), i3 !== u3.length - 1 && (r4.push(SO2), PO2(t3.originalText, e4.getValue(), jO2) && r4.push(SO2));
            }, "definitions"), [...r4, SO2];
          }
          case "OperationDefinition": {
            const i3 = t3.originalText[LO2(r3)] !== "{", u3 = Boolean(r3.name);
            return [i3 ? r3.operation : "", i3 && u3 ? [" ", n3("name")] : "", i3 && !u3 && OO2(r3.variableDefinitions) ? " " : "", OO2(r3.variableDefinitions) ? BO2(["(", NO2([TO2, xO2([kO2("", ", "), TO2], e3.map(n3, "variableDefinitions"))]), TO2, ")"]) : "", _O2(e3, n3, r3), r3.selectionSet && (i3 || u3) ? " " : "", n3("selectionSet")];
          }
          case "FragmentDefinition":
            return ["fragment ", n3("name"), OO2(r3.variableDefinitions) ? BO2(["(", NO2([TO2, xO2([kO2("", ", "), TO2], e3.map(n3, "variableDefinitions"))]), TO2, ")"]) : "", " on ", n3("typeCondition"), _O2(e3, n3, r3), " ", n3("selectionSet")];
          case "SelectionSet":
            return ["{", NO2([SO2, xO2(SO2, e3.call((e4) => MO2(e4, t3, n3), "selections"))]), SO2, "}"];
          case "Field":
            return BO2([r3.alias ? [n3("alias"), ": "] : "", n3("name"), r3.arguments.length > 0 ? BO2(["(", NO2([TO2, xO2([kO2("", ", "), TO2], e3.call((e4) => MO2(e4, t3, n3), "arguments"))]), TO2, ")"]) : "", _O2(e3, n3, r3), r3.selectionSet ? " " : "", n3("selectionSet")]);
          case "Name":
            return r3.value;
          case "StringValue":
            return r3.block ? ['"""', SO2, xO2(SO2, r3.value.replace(/"""/g, "\\$&").split("\n")), SO2, '"""'] : ['"', r3.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
          case "IntValue":
          case "FloatValue":
          case "EnumValue":
            return r3.value;
          case "BooleanValue":
            return r3.value ? "true" : "false";
          case "NullValue":
            return "null";
          case "Variable":
            return ["$", n3("name")];
          case "ListValue":
            return BO2(["[", NO2([TO2, xO2([kO2("", ", "), TO2], e3.map(n3, "values"))]), TO2, "]"]);
          case "ObjectValue":
            return BO2(["{", t3.bracketSpacing && r3.fields.length > 0 ? " " : "", NO2([TO2, xO2([kO2("", ", "), TO2], e3.map(n3, "fields"))]), TO2, kO2("", t3.bracketSpacing && r3.fields.length > 0 ? " " : ""), "}"]);
          case "ObjectField":
          case "Argument":
            return [n3("name"), ": ", n3("value")];
          case "Directive":
            return ["@", n3("name"), r3.arguments.length > 0 ? BO2(["(", NO2([TO2, xO2([kO2("", ", "), TO2], e3.call((e4) => MO2(e4, t3, n3), "arguments"))]), TO2, ")"]) : ""];
          case "NamedType":
            return n3("name");
          case "VariableDefinition":
            return [n3("variable"), ": ", n3("type"), r3.defaultValue ? [" = ", n3("defaultValue")] : "", _O2(e3, n3, r3)];
          case "ObjectTypeExtension":
          case "ObjectTypeDefinition":
            return [n3("description"), r3.description ? SO2 : "", r3.kind === "ObjectTypeExtension" ? "extend " : "", "type ", n3("name"), r3.interfaces.length > 0 ? [" implements ", ...RO2(e3, t3, n3)] : "", _O2(e3, n3, r3), r3.fields.length > 0 ? [" {", NO2([SO2, xO2(SO2, e3.call((e4) => MO2(e4, t3, n3), "fields"))]), SO2, "}"] : ""];
          case "FieldDefinition":
            return [n3("description"), r3.description ? SO2 : "", n3("name"), r3.arguments.length > 0 ? BO2(["(", NO2([TO2, xO2([kO2("", ", "), TO2], e3.call((e4) => MO2(e4, t3, n3), "arguments"))]), TO2, ")"]) : "", ": ", n3("type"), _O2(e3, n3, r3)];
          case "DirectiveDefinition":
            return [n3("description"), r3.description ? SO2 : "", "directive ", "@", n3("name"), r3.arguments.length > 0 ? BO2(["(", NO2([TO2, xO2([kO2("", ", "), TO2], e3.call((e4) => MO2(e4, t3, n3), "arguments"))]), TO2, ")"]) : "", r3.repeatable ? " repeatable" : "", " on ", xO2(" | ", e3.map(n3, "locations"))];
          case "EnumTypeExtension":
          case "EnumTypeDefinition":
            return [n3("description"), r3.description ? SO2 : "", r3.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n3("name"), _O2(e3, n3, r3), r3.values.length > 0 ? [" {", NO2([SO2, xO2(SO2, e3.call((e4) => MO2(e4, t3, n3), "values"))]), SO2, "}"] : ""];
          case "EnumValueDefinition":
            return [n3("description"), r3.description ? SO2 : "", n3("name"), _O2(e3, n3, r3)];
          case "InputValueDefinition":
            return [n3("description"), r3.description ? r3.description.block ? SO2 : wO2 : "", n3("name"), ": ", n3("type"), r3.defaultValue ? [" = ", n3("defaultValue")] : "", _O2(e3, n3, r3)];
          case "InputObjectTypeExtension":
          case "InputObjectTypeDefinition":
            return [n3("description"), r3.description ? SO2 : "", r3.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", n3("name"), _O2(e3, n3, r3), r3.fields.length > 0 ? [" {", NO2([SO2, xO2(SO2, e3.call((e4) => MO2(e4, t3, n3), "fields"))]), SO2, "}"] : ""];
          case "SchemaDefinition":
            return ["schema", _O2(e3, n3, r3), " {", r3.operationTypes.length > 0 ? NO2([SO2, xO2(SO2, e3.call((e4) => MO2(e4, t3, n3), "operationTypes"))]) : "", SO2, "}"];
          case "OperationTypeDefinition":
            return [n3("operation"), ": ", n3("type")];
          case "InterfaceTypeExtension":
          case "InterfaceTypeDefinition":
            return [n3("description"), r3.description ? SO2 : "", r3.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", n3("name"), r3.interfaces.length > 0 ? [" implements ", ...RO2(e3, t3, n3)] : "", _O2(e3, n3, r3), r3.fields.length > 0 ? [" {", NO2([SO2, xO2(SO2, e3.call((e4) => MO2(e4, t3, n3), "fields"))]), SO2, "}"] : ""];
          case "FragmentSpread":
            return ["...", n3("name"), _O2(e3, n3, r3)];
          case "InlineFragment":
            return ["...", r3.typeCondition ? [" on ", n3("typeCondition")] : "", _O2(e3, n3, r3), " ", n3("selectionSet")];
          case "UnionTypeExtension":
          case "UnionTypeDefinition":
            return BO2([n3("description"), r3.description ? SO2 : "", BO2([r3.kind === "UnionTypeExtension" ? "extend " : "", "union ", n3("name"), _O2(e3, n3, r3), r3.types.length > 0 ? [" =", kO2("", " "), NO2([kO2([wO2, "  "]), xO2([wO2, "| "], e3.map(n3, "types"))])] : ""])]);
          case "ScalarTypeExtension":
          case "ScalarTypeDefinition":
            return [n3("description"), r3.description ? SO2 : "", r3.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n3("name"), _O2(e3, n3, r3)];
          case "NonNullType":
            return [n3("type"), "!"];
          case "ListType":
            return ["[", n3("type"), "]"];
          default:
            throw new Error("unknown graphql type: " + JSON.stringify(r3.kind));
        }
      }, massageAstNode: $O2, hasPrettierIgnore: function(e3) {
        const t3 = e3.getValue();
        return t3 && Array.isArray(t3.comments) && t3.comments.some((e4) => e4.value.trim() === "prettier-ignore");
      }, insertPragma: IO2, printComment: function(e3) {
        const t3 = e3.getValue();
        if (t3.kind === "Comment")
          return "#" + t3.value.trimEnd();
        throw new Error("Not a comment: " + JSON.stringify(t3));
      }, canAttachComment: function(e3) {
        return e3.kind && e3.kind !== "Comment";
      } }, WO2 = { bracketSpacing: KB2.bracketSpacing };
      var qO2 = { languages: [rh2({ name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 }, () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], options: WO2, printers: { graphql: VO2 }, parsers: void 0 };
      var UO2 = { locStart: function(e3) {
        return e3.position.start.offset;
      }, locEnd: function(e3) {
        return e3.position.end.offset;
      } };
      const { getLast: zO2 } = Fi2, { locStart: GO2, locEnd: HO2 } = UO2, { cjkPattern: JO2, kPattern: XO2, punctuationPattern: YO2 } = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" }, KO2 = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], QO2 = [...KO2, "tableCell", "paragraph", "heading"], ZO2 = new RegExp(XO2), eI2 = new RegExp(YO2);
      function tI2(e3, t3) {
        const [, n3, r3, i3] = t3.slice(e3.position.start.offset, e3.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
        return { numberText: n3, marker: r3, leadingSpaces: i3 };
      }
      var nI2 = { mapAst: function(e3, t3) {
        return function e4(n3, r3, i3) {
          const u3 = Object.assign({}, t3(n3, r3, i3));
          return u3.children && (u3.children = u3.children.map((t4, n4) => e4(t4, n4, [u3, ...i3]))), u3;
        }(e3, null, []);
      }, splitText: function(e3, t3) {
        const n3 = "non-cjk", r3 = "cj-letter", i3 = "cjk-punctuation", u3 = [], o3 = (t3.proseWrap === "preserve" ? e3 : e3.replace(new RegExp(`(${JO2})
(${JO2})`, "g"), "$1$2")).split(/([\t\n ]+)/);
        for (const [e4, t4] of o3.entries()) {
          if (e4 % 2 == 1) {
            u3.push({ type: "whitespace", value: /\n/.test(t4) ? "\n" : " " });
            continue;
          }
          if ((e4 === 0 || e4 === o3.length - 1) && t4 === "")
            continue;
          const a3 = t4.split(new RegExp(`(${JO2})`));
          for (const [e5, t5] of a3.entries())
            (e5 !== 0 && e5 !== a3.length - 1 || t5 !== "") && (e5 % 2 != 0 ? s3(eI2.test(t5) ? { type: "word", value: t5, kind: i3, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: t5, kind: ZO2.test(t5) ? "k-letter" : r3, hasLeadingPunctuation: false, hasTrailingPunctuation: false }) : t5 !== "" && s3({ type: "word", value: t5, kind: n3, hasLeadingPunctuation: eI2.test(t5[0]), hasTrailingPunctuation: eI2.test(zO2(t5)) }));
        }
        return u3;
        function s3(e4) {
          const t4 = zO2(u3);
          var o4, s4;
          t4 && t4.type === "word" && (t4.kind === n3 && e4.kind === r3 && !t4.hasTrailingPunctuation || t4.kind === r3 && e4.kind === n3 && !e4.hasLeadingPunctuation ? u3.push({ type: "whitespace", value: " " }) : (o4 = n3, s4 = i3, t4.kind === o4 && e4.kind === s4 || t4.kind === s4 && e4.kind === o4 || [t4.value, e4.value].some((e5) => /\u3000/.test(e5)) || u3.push({ type: "whitespace", value: "" }))), u3.push(e4);
        }
      }, punctuationPattern: YO2, getFencedCodeBlockValue: function(e3, t3) {
        const { value: n3 } = e3;
        return e3.position.end.offset === t3.length && n3.endsWith("\n") && t3.endsWith("\n") ? n3.slice(0, -1) : n3;
      }, getOrderedListItemInfo: tI2, hasGitDiffFriendlyOrderedList: function(e3, t3) {
        if (!e3.ordered)
          return false;
        if (e3.children.length < 2)
          return false;
        const n3 = Number(tI2(e3.children[0], t3.originalText).numberText), r3 = Number(tI2(e3.children[1], t3.originalText).numberText);
        if (n3 === 0 && e3.children.length > 2) {
          const n4 = Number(tI2(e3.children[2], t3.originalText).numberText);
          return r3 === 1 && n4 === 1;
        }
        return r3 === 1;
      }, INLINE_NODE_TYPES: KO2, INLINE_NODE_WRAPPER_TYPES: QO2, isAutolink: function(e3) {
        if (!e3 || e3.type !== "link" || e3.children.length !== 1)
          return false;
        const t3 = e3.children[0];
        return t3 && GO2(e3) === GO2(t3) && HO2(e3) === HO2(t3);
      } };
      const { inferParserByLanguage: rI2, getMaxContinuousCount: iI2 } = Fi2, { builders: { hardline: uI2, markAsRoot: oI2 }, utils: { replaceEndOfLine: sI2 } } = su2, { getFencedCodeBlockValue: aI2 } = nI2;
      var cI2 = function(e3, t3, n3, r3) {
        const i3 = e3.getValue();
        if (i3.type === "code" && i3.lang !== null) {
          const e4 = rI2(i3.lang, r3);
          if (e4) {
            const t4 = r3.__inJsTemplate ? "~" : "`", u3 = t4.repeat(Math.max(3, iI2(i3.value, t4) + 1)), o3 = n3(aI2(i3, r3.originalText), { parser: e4 }, { stripTrailingHardline: true });
            return oI2([u3, i3.lang, i3.meta ? " " + i3.meta : "", uI2, sI2(o3), uI2, u3]);
          }
        }
        switch (i3.type) {
          case "front-matter":
            return dN2(i3, n3);
          case "importExport":
            return [n3(i3.value, { parser: "babel" }, { stripTrailingHardline: true }), uI2];
          case "jsx":
            return n3(`<$>${i3.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
        }
        return null;
      };
      const lI2 = ["format", "prettier"];
      function pI2(e3) {
        const t3 = `@(${lI2.join("|")})`, n3 = new RegExp([`<!--\\s*${t3}\\s*-->`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${t3}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), r3 = e3.match(n3);
        return r3 && r3.index === 0;
      }
      var fI2 = { startWithPragma: pI2, hasPragma: (e3) => pI2(yN2(e3).content.trimStart()), insertPragma: (e3) => {
        const t3 = yN2(e3), n3 = `<!-- @${lI2[0]} -->`;
        return t3.frontMatter ? `${t3.frontMatter.raw}

${n3}

${t3.content}` : `${n3}

${t3.content}`;
      } };
      const { getOrderedListItemInfo: dI2, mapAst: hI2, splitText: gI2 } = nI2, mI2 = /^.$/us;
      function yI2(e3, t3, n3) {
        return hI2(e3, (e4) => {
          if (!e4.children)
            return e4;
          const r3 = e4.children.reduce((e5, r4) => {
            const i3 = _n2(e5);
            return i3 && t3(i3, r4) ? e5.splice(-1, 1, n3(i3, r4)) : e5.push(r4), e5;
          }, []);
          return Object.assign(Object.assign({}, e4), {}, { children: r3 });
        });
      }
      var DI2 = function(e3, t3) {
        return e3 = function(e4) {
          return yI2(e4, (e5, t4) => e5.type === "importExport" && t4.type === "importExport", (e5, t4) => ({ type: "importExport", value: e5.value + "\n\n" + t4.value, position: { start: e5.position.start, end: t4.position.end } }));
        }(e3 = function(e4) {
          return hI2(e4, (e5) => e5.type !== "import" && e5.type !== "export" ? e5 : Object.assign(Object.assign({}, e5), {}, { type: "importExport" }));
        }(e3 = function(e4, t4) {
          return hI2(e4, (e5, n3, [r3]) => {
            if (e5.type !== "text")
              return e5;
            let { value: i3 } = e5;
            return r3.type === "paragraph" && (n3 === 0 && (i3 = i3.trimStart()), n3 === r3.children.length - 1 && (i3 = i3.trimEnd())), { type: "sentence", position: e5.position, children: gI2(i3, t4) };
          });
        }(e3 = function(e4, t4) {
          return hI2(e4, (e5, t5, n4) => {
            if (e5.type === "list" && e5.children.length > 0) {
              for (let t6 = 0; t6 < n4.length; t6++) {
                const r4 = n4[t6];
                if (r4.type === "list" && !r4.isAligned)
                  return e5.isAligned = false, e5;
              }
              e5.isAligned = r3(e5);
            }
            return e5;
          });
          function n3(e5) {
            return e5.children.length === 0 ? -1 : e5.children[0].position.start.column - 1;
          }
          function r3(e5) {
            if (!e5.ordered)
              return true;
            const [r4, i3] = e5.children;
            if (dI2(r4, t4.originalText).leadingSpaces.length > 1)
              return true;
            const u3 = n3(r4);
            if (u3 === -1)
              return false;
            if (e5.children.length === 1)
              return u3 % t4.tabWidth == 0;
            if (u3 !== n3(i3))
              return false;
            if (u3 % t4.tabWidth == 0)
              return true;
            return dI2(i3, t4.originalText).leadingSpaces.length > 1;
          }
        }(e3 = function(e4, t4) {
          return hI2(e4, (e5, n3, r3) => {
            if (e5.type === "code") {
              const n4 = /^\n?(?: {4,}|\t)/.test(t4.originalText.slice(e5.position.start.offset, e5.position.end.offset));
              if (e5.isIndented = n4, n4)
                for (let e6 = 0; e6 < r3.length; e6++) {
                  const t5 = r3[e6];
                  if (t5.hasIndentedCodeblock)
                    break;
                  t5.type === "list" && (t5.hasIndentedCodeblock = true);
                }
            }
            return e5;
          });
        }(e3 = function(e4) {
          return hI2(e4, (e5) => e5.type !== "inlineCode" ? e5 : Object.assign(Object.assign({}, e5), {}, { value: e5.value.replace(/\s+/g, " ") }));
        }(e3 = function(e4) {
          return yI2(e4, (e5, t4) => e5.type === "text" && t4.type === "text", (e5, t4) => ({ type: "text", value: e5.value + t4.value, position: { start: e5.position.start, end: t4.position.end } }));
        }(e3 = function(e4, t4) {
          return hI2(e4, (e5) => e5.type === "text" && e5.value !== "*" && e5.value !== "_" && mI2.test(e5.value) && e5.position.end.offset - e5.position.start.offset !== e5.value.length ? Object.assign(Object.assign({}, e5), {}, { value: t4.originalText.slice(e5.position.start.offset, e5.position.end.offset) }) : e5);
        }(e3, t3))), t3), t3), t3)));
      };
      const { isFrontMatterNode: EI2 } = Fi2, { startWithPragma: CI2 } = fI2, bI2 = new Set(["position", "raw"]);
      function AI2(e3, t3, n3) {
        return e3.type !== "front-matter" && e3.type !== "code" && e3.type !== "yaml" && e3.type !== "import" && e3.type !== "export" && e3.type !== "jsx" || delete t3.value, e3.type === "list" && delete t3.isAligned, e3.type !== "list" && e3.type !== "listItem" || (delete t3.spread, delete t3.loose), e3.type === "text" ? null : (e3.type === "inlineCode" && (t3.value = e3.value.replace(/[\t\n ]+/g, " ")), e3.type === "wikiLink" && (t3.value = e3.value.trim().replace(/[\t\n]+/g, " ")), e3.type !== "definition" && e3.type !== "linkReference" || (t3.label = e3.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e3.type !== "definition" && e3.type !== "link" && e3.type !== "image" || !e3.title || (t3.title = e3.title.replace(/\\(["')])/g, "$1")), n3 && n3.type === "root" && n3.children.length > 0 && (n3.children[0] === e3 || EI2(n3.children[0]) && n3.children[1] === e3) && e3.type === "html" && CI2(e3.value) ? null : void 0);
      }
      AI2.ignoredProperties = bI2;
      var vI2 = AI2;
      const { getLast: FI2, getMinNotPresentContinuousCount: xI2, getMaxContinuousCount: SI2, getStringWidth: wI2, isNonEmptyArray: TI2 } = Fi2, { builders: { breakParent: BI2, join: NI2, line: kI2, literalline: PI2, markAsRoot: OI2, hardline: II2, softline: LI2, ifBreak: jI2, fill: _I2, align: MI2, indent: RI2, group: $I2, hardlineWithoutBreakParent: VI2 }, utils: { normalizeDoc: WI2, replaceTextEndOfLine: qI2 }, printer: { printDocToString: UI2 } } = su2, { insertPragma: zI2 } = fI2, { locStart: GI2, locEnd: HI2 } = UO2, { getFencedCodeBlockValue: JI2, hasGitDiffFriendlyOrderedList: XI2, splitText: YI2, punctuationPattern: KI2, INLINE_NODE_TYPES: QI2, INLINE_NODE_WRAPPER_TYPES: ZI2, isAutolink: eL2 } = nI2, tL2 = new Set(["importExport"]), nL2 = ["heading", "tableCell", "link", "wikiLink"], rL2 = new Set(["listItem", "definition", "footnoteDefinition"]);
      function iL2(e3, t3, n3, r3) {
        const i3 = e3.getValue(), u3 = i3.checked === null ? "" : i3.checked ? "[x] " : "[ ] ";
        return [u3, lL2(e3, t3, n3, { processor: (e4, i4) => {
          if (i4 === 0 && e4.getValue().type !== "list")
            return MI2(" ".repeat(u3.length), n3());
          const o3 = " ".repeat(function(e5, t4, n4) {
            return e5 < t4 ? t4 : e5 > n4 ? n4 : e5;
          }(t3.tabWidth - r3.length, 0, 3));
          return [o3, MI2(o3, n3())];
        } })];
      }
      function uL2(e3, t3) {
        return function(e4, t4, n3) {
          let r3 = -1;
          for (const i3 of t4.children)
            if (i3.type === e4.type && n3(i3) ? r3++ : r3 = -1, i3 === e4)
              return r3;
        }(e3, t3, (t4) => t4.ordered === e3.ordered);
      }
      function oL2(e3, t3) {
        const n3 = Array.isArray(t3) ? t3 : [t3];
        let r3, i3 = -1;
        for (; r3 = e3.getParentNode(++i3); )
          if (n3.includes(r3.type))
            return i3;
        return -1;
      }
      function sL2(e3, t3) {
        const n3 = oL2(e3, t3);
        return n3 === -1 ? null : e3.getParentNode(n3);
      }
      function aL2(e3, t3, n3) {
        if (n3.proseWrap === "preserve" && t3 === "\n")
          return II2;
        const r3 = n3.proseWrap === "always" && !sL2(e3, nL2);
        return t3 !== "" ? r3 ? kI2 : " " : r3 ? LI2 : "";
      }
      function cL2(e3, t3, n3) {
        const r3 = [];
        let i3 = null;
        const { children: u3 } = e3.getValue();
        for (const [e4, t4] of u3.entries())
          switch (fL2(t4)) {
            case "start":
              i3 === null && (i3 = { index: e4, offset: t4.position.end.offset });
              break;
            case "end":
              i3 !== null && (r3.push({ start: i3, end: { index: e4, offset: t4.position.start.offset } }), i3 = null);
          }
        return lL2(e3, t3, n3, { processor: (e4, i4) => {
          if (r3.length > 0) {
            const e5 = r3[0];
            if (i4 === e5.start.index)
              return [u3[e5.start.index].value, t3.originalText.slice(e5.start.offset, e5.end.offset), u3[e5.end.index].value];
            if (e5.start.index < i4 && i4 < e5.end.index)
              return false;
            if (i4 === e5.end.index)
              return r3.shift(), false;
          }
          return n3();
        } });
      }
      function lL2(e3, t3, n3, r3 = {}) {
        const { postprocessor: i3 } = r3, u3 = r3.processor || (() => n3()), o3 = e3.getValue(), s3 = [];
        let a3;
        return e3.each((e4, n4) => {
          const r4 = e4.getValue(), i4 = u3(e4, n4);
          if (i4 !== false) {
            const e5 = { parts: s3, prevNode: a3, parentNode: o3, options: t3 };
            (function(e6, t4) {
              const n5 = t4.parts.length === 0, r5 = QI2.includes(e6.type), i5 = e6.type === "html" && ZI2.includes(t4.parentNode.type);
              return !n5 && !r5 && !i5;
            })(r4, e5) && (s3.push(II2), a3 && tL2.has(a3.type) || (function(e6, t4) {
              const n5 = (t4.prevNode && t4.prevNode.type) === e6.type && rL2.has(e6.type), r5 = t4.parentNode.type === "listItem" && !t4.parentNode.loose, i5 = t4.prevNode && t4.prevNode.type === "listItem" && t4.prevNode.loose, u4 = fL2(t4.prevNode) === "next", o4 = e6.type === "html" && t4.prevNode && t4.prevNode.type === "html" && t4.prevNode.position.end.line + 1 === e6.position.start.line, s4 = e6.type === "html" && t4.parentNode.type === "listItem" && t4.prevNode && t4.prevNode.type === "paragraph" && t4.prevNode.position.end.line + 1 === e6.position.start.line;
              return i5 || !(n5 || r5 || u4 || o4 || s4);
            }(r4, e5) || dL2(r4, e5)) && s3.push(II2), dL2(r4, e5) && s3.push(II2)), s3.push(i4), a3 = r4;
          }
        }, "children"), i3 ? i3(s3) : s3;
      }
      function pL2(e3) {
        let t3 = e3;
        for (; TI2(t3.children); )
          t3 = FI2(t3.children);
        return t3;
      }
      function fL2(e3) {
        if (e3.type !== "html")
          return false;
        const t3 = e3.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
        return t3 !== null && (t3[1] ? t3[1] : "next");
      }
      function dL2(e3, t3) {
        const n3 = t3.prevNode && t3.prevNode.type === "list", r3 = e3.type === "code" && e3.isIndented;
        return n3 && r3;
      }
      function hL2(e3, t3 = []) {
        const n3 = [" ", ...Array.isArray(t3) ? t3 : [t3]];
        return new RegExp(n3.map((e4) => `\\${e4}`).join("|")).test(e3) ? `<${e3}>` : e3;
      }
      function gL2(e3, t3, n3 = true) {
        if (!e3)
          return "";
        if (n3)
          return " " + gL2(e3, t3, false);
        if ((e3 = e3.replace(/\\(["')])/g, "$1")).includes('"') && e3.includes("'") && !e3.includes(")"))
          return `(${e3})`;
        const r3 = e3.split("'").length - 1, i3 = e3.split('"').length - 1, u3 = r3 > i3 ? '"' : i3 > r3 || t3.singleQuote ? "'" : '"';
        return `${u3}${e3 = (e3 = e3.replace(/\\/, "\\\\")).replace(new RegExp(`(${u3})`, "g"), "\\$1")}${u3}`;
      }
      var mL2 = { preprocess: DI2, print: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (function(e4) {
          const t4 = sL2(e4, ["linkReference", "imageReference"]);
          return t4 && (t4.type !== "linkReference" || t4.referenceType !== "full");
        }(e3))
          return YI2(t3.originalText.slice(r3.position.start.offset, r3.position.end.offset), t3).map((n4) => n4.type === "word" ? n4.value : n4.value === "" ? "" : aL2(e3, n4.value, t3));
        switch (r3.type) {
          case "front-matter":
            return t3.originalText.slice(r3.position.start.offset, r3.position.end.offset);
          case "root":
            return r3.children.length === 0 ? "" : [WI2(cL2(e3, t3, n3)), tL2.has(pL2(r3).type) ? "" : II2];
          case "paragraph":
            return lL2(e3, t3, n3, { postprocessor: _I2 });
          case "sentence":
            return lL2(e3, t3, n3);
          case "word": {
            let t4 = r3.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${KI2})(_+)`, `(_+)(${KI2}|$)`].join("|"), "g"), (e4, t5, n5, r4, i4) => (n5 ? `${t5}${n5}` : `${r4}${i4}`).replace(/_/g, "\\_"));
            const n4 = (e4, t5, n5) => e4.type === "sentence" && n5 === 0, i3 = (e4, t5, n5) => eL2(e4.children[n5 - 1]);
            return t4 !== r3.value && (e3.match(void 0, n4, i3) || e3.match(void 0, n4, (e4, t5, n5) => e4.type === "emphasis" && n5 === 0, i3)) && (t4 = t4.replace(/^(\\?[*_])+/, (e4) => e4.replace(/\\/g, ""))), t4;
          }
          case "whitespace": {
            const n4 = e3.getParentNode(), i3 = n4.children.indexOf(r3), u3 = n4.children[i3 + 1], o3 = u3 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(u3.value) ? "never" : t3.proseWrap;
            return aL2(e3, r3.value, { proseWrap: o3 });
          }
          case "emphasis": {
            let i3;
            if (eL2(r3.children[0]))
              i3 = t3.originalText[r3.position.start.offset];
            else {
              const t4 = e3.getParentNode(), n4 = t4.children.indexOf(r3), u3 = t4.children[n4 - 1], o3 = t4.children[n4 + 1];
              i3 = u3 && u3.type === "sentence" && u3.children.length > 0 && FI2(u3.children).type === "word" && !FI2(u3.children).hasTrailingPunctuation || o3 && o3.type === "sentence" && o3.children.length > 0 && o3.children[0].type === "word" && !o3.children[0].hasLeadingPunctuation || sL2(e3, "emphasis") ? "*" : "_";
            }
            return [i3, lL2(e3, t3, n3), i3];
          }
          case "strong":
            return ["**", lL2(e3, t3, n3), "**"];
          case "delete":
            return ["~~", lL2(e3, t3, n3), "~~"];
          case "inlineCode": {
            const e4 = xI2(r3.value, "`"), t4 = "`".repeat(e4 || 1), n4 = e4 && !/^\s/.test(r3.value) ? " " : "";
            return [t4, n4, r3.value, n4, t4];
          }
          case "wikiLink": {
            let e4 = "";
            return e4 = t3.proseWrap === "preserve" ? r3.value : r3.value.replace(/[\t\n]+/g, " "), ["[[", e4, "]]"];
          }
          case "link":
            switch (t3.originalText[r3.position.start.offset]) {
              case "<": {
                const e4 = "mailto:";
                return ["<", r3.url.startsWith(e4) && t3.originalText.slice(r3.position.start.offset + 1, r3.position.start.offset + 1 + e4.length) !== e4 ? r3.url.slice(e4.length) : r3.url, ">"];
              }
              case "[":
                return ["[", lL2(e3, t3, n3), "](", hL2(r3.url, ")"), gL2(r3.title, t3), ")"];
              default:
                return t3.originalText.slice(r3.position.start.offset, r3.position.end.offset);
            }
          case "image":
            return ["![", r3.alt || "", "](", hL2(r3.url, ")"), gL2(r3.title, t3), ")"];
          case "blockquote":
            return ["> ", MI2("> ", lL2(e3, t3, n3))];
          case "heading":
            return ["#".repeat(r3.depth) + " ", lL2(e3, t3, n3)];
          case "code": {
            if (r3.isIndented) {
              const e5 = " ".repeat(4);
              return MI2(e5, [e5, ...qI2(r3.value, II2)]);
            }
            const e4 = t3.__inJsTemplate ? "~" : "`", n4 = e4.repeat(Math.max(3, SI2(r3.value, e4) + 1));
            return [n4, r3.lang || "", r3.meta ? " " + r3.meta : "", II2, ...qI2(JI2(r3, t3.originalText), II2), II2, n4];
          }
          case "html": {
            const t4 = e3.getParentNode(), n4 = t4.type === "root" && FI2(t4.children) === r3 ? r3.value.trimEnd() : r3.value, i3 = /^<!--.*-->$/s.test(n4);
            return qI2(n4, i3 ? II2 : OI2(PI2));
          }
          case "list": {
            const i3 = uL2(r3, e3.getParentNode()), u3 = XI2(r3, t3);
            return lL2(e3, t3, n3, { processor: (e4, o3) => {
              const s3 = function() {
                const e5 = r3.ordered ? (o3 === 0 ? r3.start : u3 ? 1 : r3.start + o3) + (i3 % 2 == 0 ? ". " : ") ") : i3 % 2 == 0 ? "- " : "* ";
                return r3.isAligned || r3.hasIndentedCodeblock ? function(e6, t4) {
                  const n4 = r4();
                  return e6 + " ".repeat(n4 >= 4 ? 0 : n4);
                  function r4() {
                    const n5 = e6.length % t4.tabWidth;
                    return n5 === 0 ? 0 : t4.tabWidth - n5;
                  }
                }(e5, t3) : e5;
              }(), a3 = e4.getValue();
              return a3.children.length === 2 && a3.children[1].type === "html" && a3.children[0].position.start.column !== a3.children[1].position.start.column ? [s3, iL2(e4, t3, n3, s3)] : [s3, MI2(" ".repeat(s3.length), iL2(e4, t3, n3, s3))];
            } });
          }
          case "thematicBreak": {
            const t4 = oL2(e3, "list");
            if (t4 === -1)
              return "---";
            return uL2(e3.getParentNode(t4), e3.getParentNode(t4 + 1)) % 2 == 0 ? "***" : "---";
          }
          case "linkReference":
            return ["[", lL2(e3, t3, n3), "]", r3.referenceType === "full" ? ["[", r3.identifier, "]"] : r3.referenceType === "collapsed" ? "[]" : ""];
          case "imageReference":
            switch (r3.referenceType) {
              case "full":
                return ["![", r3.alt || "", "][", r3.identifier, "]"];
              default:
                return ["![", r3.alt, "]", r3.referenceType === "collapsed" ? "[]" : ""];
            }
          case "definition": {
            const e4 = t3.proseWrap === "always" ? kI2 : " ";
            return $I2(["[", r3.identifier, "]:", RI2([e4, hL2(r3.url), r3.title === null ? "" : [e4, gL2(r3.title, t3, false)]])]);
          }
          case "footnote":
            return ["[^", lL2(e3, t3, n3), "]"];
          case "footnoteReference":
            return ["[^", r3.identifier, "]"];
          case "footnoteDefinition": {
            const i3 = e3.getParentNode().children[e3.getName() + 1], u3 = r3.children.length === 1 && r3.children[0].type === "paragraph" && (t3.proseWrap === "never" || t3.proseWrap === "preserve" && r3.children[0].position.start.line === r3.children[0].position.end.line);
            return ["[^", r3.identifier, "]: ", u3 ? lL2(e3, t3, n3) : $I2([MI2(" ".repeat(4), lL2(e3, t3, n3, { processor: (e4, t4) => t4 === 0 ? $I2([LI2, n3()]) : n3() })), i3 && i3.type === "footnoteDefinition" ? LI2 : ""])];
          }
          case "table":
            return function(e4, t4, n4) {
              const r4 = e4.getValue(), i3 = [], u3 = e4.map((e5) => e5.map((e6, r5) => {
                const u4 = UI2(n4(), t4).formatted, o4 = wI2(u4);
                return i3[r5] = Math.max(i3[r5] || 3, o4), { text: u4, width: o4 };
              }, "children"), "children"), o3 = a3(false);
              if (t4.proseWrap !== "never")
                return [BI2, o3];
              const s3 = a3(true);
              return [BI2, $I2(jI2(s3, o3))];
              function a3(e5) {
                const t5 = [l3(u3[0], e5), c3(e5)];
                return u3.length > 1 && t5.push(NI2(VI2, u3.slice(1).map((t6) => l3(t6, e5)))), NI2(VI2, t5);
              }
              function c3(e5) {
                return `| ${i3.map((t5, n5) => {
                  const i4 = r4.align[n5], u4 = i4 === "center" || i4 === "right" ? ":" : "-";
                  return `${i4 === "center" || i4 === "left" ? ":" : "-"}${e5 ? "-" : "-".repeat(t5 - 2)}${u4}`;
                }).join(" | ")} |`;
              }
              function l3(e5, t5) {
                return `| ${e5.map(({ text: e6, width: n5 }, u4) => {
                  if (t5)
                    return e6;
                  const o4 = i3[u4] - n5, s4 = r4.align[u4];
                  let a4 = 0;
                  s4 === "right" ? a4 = o4 : s4 === "center" && (a4 = Math.floor(o4 / 2));
                  const c4 = o4 - a4;
                  return `${" ".repeat(a4)}${e6}${" ".repeat(c4)}`;
                }).join(" | ")} |`;
              }
            }(e3, t3, n3);
          case "tableCell":
            return lL2(e3, t3, n3);
          case "break":
            return /\s/.test(t3.originalText[r3.position.start.offset]) ? ["  ", OI2(PI2)] : ["\\", II2];
          case "liquidNode":
            return qI2(r3.value, II2);
          case "importExport":
            return [r3.value, II2];
          case "jsx":
            return r3.value;
          case "math":
            return ["$$", II2, r3.value ? [...qI2(r3.value, II2), II2] : "", "$$"];
          case "inlineMath":
            return t3.originalText.slice(GI2(r3), HI2(r3));
          case "tableRow":
          case "listItem":
          default:
            throw new Error(`Unknown markdown type ${JSON.stringify(r3.type)}`);
        }
      }, embed: cI2, massageAstNode: vI2, hasPrettierIgnore: function(e3) {
        const t3 = Number(e3.getName());
        return t3 !== 0 && fL2(e3.getParentNode().children[t3 - 1]) === "next";
      }, insertPragma: zI2 }, yL2 = { proseWrap: KB2.proseWrap, singleQuote: KB2.singleQuote }, DL2 = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
      var EL2 = { languages: [rh2(DL2, (e3) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e3.filenames, "README"], extensions: e3.extensions.filter((e4) => e4 !== ".mdx") })), rh2(DL2, () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], options: yL2, printers: { mdast: mL2 }, parsers: void 0 };
      const { isFrontMatterNode: CL2 } = Fi2, bL2 = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
      function AL2(e3, t3) {
        return e3.type === "text" || e3.type === "comment" || CL2(e3) || e3.type === "yaml" || e3.type === "toml" ? null : (e3.type === "attribute" && delete t3.value, void (e3.type === "docType" && delete t3.value));
      }
      AL2.ignoredProperties = bL2;
      var vL2 = AL2, FL2 = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] };
      const { inferParserByLanguage: xL2, isFrontMatterNode: SL2 } = Fi2, { builders: { line: wL2, hardline: TL2, join: BL2 }, utils: { getDocParts: NL2, replaceTextEndOfLine: kL2 } } = su2, { CSS_DISPLAY_TAGS: PL2, CSS_DISPLAY_DEFAULT: OL2, CSS_WHITE_SPACE_TAGS: IL2, CSS_WHITE_SPACE_DEFAULT: LL2 } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, jL2 = WL2(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), _L2 = function(e3, t3) {
        const n3 = Object.create(null);
        for (const [r3, i3] of Object.entries(e3))
          n3[r3] = t3(i3, r3);
        return n3;
      }(FL2, WL2), ML2 = new Set(["	", "\n", "\f", "\r", " "]), RL2 = (e3) => e3.replace(/[\t\n\f\r ]+$/, ""), $L2 = (e3) => ((e4) => e4.replace(/^[\t\f\r ]*?\n/g, ""))(RL2(e3)), VL2 = (e3) => e3.match(/^[\t\n\f\r ]*/)[0];
      function WL2(e3) {
        const t3 = Object.create(null);
        for (const n3 of e3)
          t3[n3] = true;
        return t3;
      }
      function qL2(e3) {
        return e3.type === "element" && (e3.fullName === "script" || e3.fullName === "style" || e3.fullName === "svg:style" || ej2(e3) && (e3.name === "script" || e3.name === "style"));
      }
      function UL2(e3) {
        return tj2(e3).startsWith("pre");
      }
      function zL2(e3) {
        return e3.type === "element" && e3.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e3.name) || e3.cssDisplay.startsWith("table") && e3.cssDisplay !== "table-cell");
      }
      function GL2(e3) {
        return YL2(e3) || e3.type === "element" && e3.fullName === "br" || HL2(e3);
      }
      function HL2(e3) {
        return JL2(e3) && XL2(e3);
      }
      function JL2(e3) {
        return e3.hasLeadingSpaces && (e3.prev ? e3.prev.sourceSpan.end.line < e3.sourceSpan.start.line : e3.parent.type === "root" || e3.parent.startSourceSpan.end.line < e3.sourceSpan.start.line);
      }
      function XL2(e3) {
        return e3.hasTrailingSpaces && (e3.next ? e3.next.sourceSpan.start.line > e3.sourceSpan.end.line : e3.parent.type === "root" || e3.parent.endSourceSpan && e3.parent.endSourceSpan.start.line > e3.sourceSpan.end.line);
      }
      function YL2(e3) {
        switch (e3.type) {
          case "ieConditionalComment":
          case "comment":
          case "directive":
            return true;
          case "element":
            return ["script", "select"].includes(e3.name);
        }
        return false;
      }
      function KL2(e3) {
        const { type: t3, lang: n3 } = e3.attrMap;
        return t3 === "module" || t3 === "text/javascript" || t3 === "text/babel" || t3 === "application/javascript" || n3 === "jsx" ? "babel" : t3 === "application/x-typescript" || n3 === "ts" || n3 === "tsx" ? "typescript" : t3 === "text/markdown" ? "markdown" : t3 === "text/html" ? "html" : t3 && (t3.endsWith("json") || t3.endsWith("importmap")) ? "json" : t3 === "text/x-handlebars-template" ? "glimmer" : void 0;
      }
      function QL2(e3) {
        return e3 === "block" || e3 === "list-item" || e3.startsWith("table");
      }
      function ZL2(e3) {
        return tj2(e3).startsWith("pre");
      }
      function ej2(e3) {
        return e3.type === "element" && !e3.hasExplicitNamespace && !["html", "svg"].includes(e3.namespace);
      }
      function tj2(e3) {
        return e3.type === "element" && (!e3.namespace || ej2(e3)) && IL2[e3.name] || LL2;
      }
      function nj2(e3, t3 = function(e4) {
        let t4 = Number.POSITIVE_INFINITY;
        for (const n3 of e4.split("\n")) {
          if (n3.length === 0)
            continue;
          if (!ML2.has(n3[0]))
            return 0;
          const e5 = VL2(n3).length;
          n3.length !== e5 && e5 < t4 && (t4 = e5);
        }
        return t4 === Number.POSITIVE_INFINITY ? 0 : t4;
      }(e3)) {
        return t3 === 0 ? e3 : e3.split("\n").map((e4) => e4.slice(t3)).join("\n");
      }
      const rj2 = new Set(["template", "style", "script"]);
      function ij2(e3, t3) {
        return uj2(e3, t3) && !rj2.has(e3.fullName);
      }
      function uj2(e3, t3) {
        return t3.parser === "vue" && e3.type === "element" && e3.parent.type === "root" && e3.fullName.toLowerCase() !== "html";
      }
      function oj2(e3, t3) {
        return uj2(e3, t3) && (ij2(e3, t3) || e3.attrMap.lang && e3.attrMap.lang !== "html");
      }
      var sj2 = { HTML_ELEMENT_ATTRIBUTES: _L2, HTML_TAGS: jL2, htmlTrim: (e3) => ((e4) => e4.replace(/^[\t\n\f\r ]+/, ""))(RL2(e3)), htmlTrimPreserveIndentation: $L2, hasHtmlWhitespace: (e3) => /[\t\n\f\r ]/.test(e3), getLeadingAndTrailingHtmlWhitespace: (e3) => {
        const [, t3, n3, r3] = e3.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
        return { leadingWhitespace: t3, trailingWhitespace: r3, text: n3 };
      }, canHaveInterpolation: function(e3) {
        return e3.children && !qL2(e3);
      }, countChars: function(e3, t3) {
        let n3 = 0;
        for (let r3 = 0; r3 < e3.length; r3++)
          e3[r3] === t3 && n3++;
        return n3;
      }, countParents: function(e3, t3) {
        let n3 = 0;
        for (let r3 = e3.stack.length - 1; r3 >= 0; r3--) {
          const i3 = e3.stack[r3];
          i3 && typeof i3 == "object" && !Array.isArray(i3) && t3(i3) && n3++;
        }
        return n3;
      }, dedentString: nj2, forceBreakChildren: zL2, forceBreakContent: function(e3) {
        return zL2(e3) || e3.type === "element" && e3.children.length > 0 && (["body", "script", "style"].includes(e3.name) || e3.children.some((e4) => function(e5) {
          return e5.children && e5.children.some((e6) => e6.type !== "text");
        }(e4))) || e3.firstChild && e3.firstChild === e3.lastChild && e3.firstChild.type !== "text" && JL2(e3.firstChild) && (!e3.lastChild.isTrailingSpaceSensitive || XL2(e3.lastChild));
      }, forceNextEmptyLine: function(e3) {
        return SL2(e3) || e3.next && e3.sourceSpan.end && e3.sourceSpan.end.line + 1 < e3.next.sourceSpan.start.line;
      }, getLastDescendant: function e3(t3) {
        return t3.lastChild ? e3(t3.lastChild) : t3;
      }, getNodeCssStyleDisplay: function(e3, t3) {
        if (e3.prev && e3.prev.type === "comment") {
          const t4 = e3.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
          if (t4)
            return t4[1];
        }
        let n3 = false;
        if (e3.type === "element" && e3.namespace === "svg") {
          if (!function(e4, t4) {
            let n4 = e4;
            for (; n4; ) {
              if (t4(n4))
                return true;
              n4 = n4.parent;
            }
            return false;
          }(e3, (e4) => e4.fullName === "svg:foreignObject"))
            return e3.name === "svg" ? "inline-block" : "block";
          n3 = true;
        }
        switch (t3.htmlWhitespaceSensitivity) {
          case "strict":
            return "inline";
          case "ignore":
            return "block";
          default:
            return t3.parser === "vue" && e3.parent && e3.parent.type === "root" ? "block" : e3.type === "element" && (!e3.namespace || n3 || ej2(e3)) && PL2[e3.name] || OL2;
        }
      }, getNodeCssStyleWhiteSpace: tj2, hasPrettierIgnore: function(e3) {
        return e3.type !== "attribute" && (!!e3.parent && (typeof e3.index == "number" && e3.index !== 0 && function(e4) {
          return e4.type === "comment" && e4.value.trim() === "prettier-ignore";
        }(e3.parent.children[e3.index - 1])));
      }, inferScriptParser: function(e3, t3) {
        return e3.name !== "script" || e3.attrMap.src ? e3.name === "style" ? function(e4) {
          const { lang: t4 } = e4.attrMap;
          return t4 && t4 !== "postcss" && t4 !== "css" ? t4 === "scss" ? "scss" : t4 === "less" ? "less" : void 0 : "css";
        }(e3) : t3 && oj2(e3, t3) ? KL2(e3) || !("src" in e3.attrMap) && xL2(e3.attrMap.lang, t3) : void 0 : e3.attrMap.lang || e3.attrMap.type ? KL2(e3) : "babel";
      }, isVueCustomBlock: ij2, isVueNonHtmlBlock: oj2, isVueSlotAttribute: function(e3) {
        const t3 = e3.fullName;
        return t3.charAt(0) === "#" || t3 === "slot-scope" || t3 === "v-slot" || t3.startsWith("v-slot:");
      }, isVueSfcBindingsAttribute: function(e3, t3) {
        const n3 = e3.parent;
        if (!uj2(n3, t3))
          return false;
        const r3 = n3.fullName, i3 = e3.fullName;
        return r3 === "script" && i3 === "setup" || r3 === "style" && i3 === "vars";
      }, isDanglingSpaceSensitiveNode: function(e3) {
        return !(t3 = e3.cssDisplay, QL2(t3) || t3 === "inline-block" || qL2(e3));
        var t3;
      }, isIndentationSensitiveNode: UL2, isLeadingSpaceSensitiveNode: function(e3, t3) {
        const n3 = function() {
          if (SL2(e3))
            return false;
          if ((e3.type === "text" || e3.type === "interpolation") && e3.prev && (e3.prev.type === "text" || e3.prev.type === "interpolation"))
            return true;
          if (!e3.parent || e3.parent.cssDisplay === "none")
            return false;
          if (ZL2(e3.parent))
            return true;
          if (!e3.prev && (e3.parent.type === "root" || ZL2(e3) && e3.parent || qL2(e3.parent) || ij2(e3.parent, t3) || (n4 = e3.parent.cssDisplay, QL2(n4) || n4 === "inline-block")))
            return false;
          var n4;
          if (e3.prev && !function(e4) {
            return !QL2(e4);
          }(e3.prev.cssDisplay))
            return false;
          return true;
        }();
        return n3 && !e3.prev && e3.parent && e3.parent.tagDefinition && e3.parent.tagDefinition.ignoreFirstLf ? e3.type === "interpolation" : n3;
      }, isPreLikeNode: ZL2, isScriptLikeTag: qL2, isTextLikeNode: function(e3) {
        return e3.type === "text" || e3.type === "comment";
      }, isTrailingSpaceSensitiveNode: function(e3, t3) {
        return !SL2(e3) && (!(e3.type !== "text" && e3.type !== "interpolation" || !e3.next || e3.next.type !== "text" && e3.next.type !== "interpolation") || !(!e3.parent || e3.parent.cssDisplay === "none") && (!!ZL2(e3.parent) || !(!e3.next && (e3.parent.type === "root" || ZL2(e3) && e3.parent || qL2(e3.parent) || ij2(e3.parent, t3) || (n3 = e3.parent.cssDisplay, QL2(n3) || n3 === "inline-block"))) && !(e3.next && !function(e4) {
          return !QL2(e4);
        }(e3.next.cssDisplay))));
        var n3;
      }, isWhitespaceSensitiveNode: function(e3) {
        return qL2(e3) || e3.type === "interpolation" || UL2(e3);
      }, isUnknownNamespace: ej2, preferHardlineAsLeadingSpaces: function(e3) {
        return YL2(e3) || e3.prev && GL2(e3.prev) || HL2(e3);
      }, preferHardlineAsTrailingSpaces: GL2, shouldPreserveContent: function(e3, t3) {
        return !(e3.type !== "ieConditionalComment" || !e3.lastChild || e3.lastChild.isSelfClosing || e3.lastChild.endSourceSpan) || (e3.type === "ieConditionalComment" && !e3.complete || (!(!ZL2(e3) || !e3.children.some((e4) => e4.type !== "text" && e4.type !== "interpolation")) || !(!oj2(e3, t3) || qL2(e3) || e3.type === "interpolation")));
      }, unescapeQuoteEntities: function(e3) {
        return e3.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
      }, getTextValueParts: function(e3, t3 = e3.value) {
        return e3.parent.isWhitespaceSensitive ? e3.parent.isIndentationSensitive ? kL2(t3) : kL2(nj2($L2(t3)), TL2) : NL2(BL2(wL2, ((e4) => e4.split(/[\t\n\f\r ]+/))(t3)));
      } }, aj2 = r2(function(e3, t3) {
        function n3(e4) {
          return t3.$0 <= e4 && e4 <= t3.$9;
        }
        /**
        	   * @license
        	   * Copyright Google Inc. All Rights Reserved.
        	   *
        	   * Use of this source code is governed by an MIT-style license that can be
        	   * found in the LICENSE file at https://angular.io/license
        	   */
        Object.defineProperty(t3, "__esModule", { value: true }), t3.$EOF = 0, t3.$BSPACE = 8, t3.$TAB = 9, t3.$LF = 10, t3.$VTAB = 11, t3.$FF = 12, t3.$CR = 13, t3.$SPACE = 32, t3.$BANG = 33, t3.$DQ = 34, t3.$HASH = 35, t3.$$ = 36, t3.$PERCENT = 37, t3.$AMPERSAND = 38, t3.$SQ = 39, t3.$LPAREN = 40, t3.$RPAREN = 41, t3.$STAR = 42, t3.$PLUS = 43, t3.$COMMA = 44, t3.$MINUS = 45, t3.$PERIOD = 46, t3.$SLASH = 47, t3.$COLON = 58, t3.$SEMICOLON = 59, t3.$LT = 60, t3.$EQ = 61, t3.$GT = 62, t3.$QUESTION = 63, t3.$0 = 48, t3.$7 = 55, t3.$9 = 57, t3.$A = 65, t3.$E = 69, t3.$F = 70, t3.$X = 88, t3.$Z = 90, t3.$LBRACKET = 91, t3.$BACKSLASH = 92, t3.$RBRACKET = 93, t3.$CARET = 94, t3.$_ = 95, t3.$a = 97, t3.$b = 98, t3.$e = 101, t3.$f = 102, t3.$n = 110, t3.$r = 114, t3.$t = 116, t3.$u = 117, t3.$v = 118, t3.$x = 120, t3.$z = 122, t3.$LBRACE = 123, t3.$BAR = 124, t3.$RBRACE = 125, t3.$NBSP = 160, t3.$PIPE = 124, t3.$TILDA = 126, t3.$AT = 64, t3.$BT = 96, t3.isWhitespace = function(e4) {
          return e4 >= t3.$TAB && e4 <= t3.$SPACE || e4 == t3.$NBSP;
        }, t3.isDigit = n3, t3.isAsciiLetter = function(e4) {
          return e4 >= t3.$a && e4 <= t3.$z || e4 >= t3.$A && e4 <= t3.$Z;
        }, t3.isAsciiHexDigit = function(e4) {
          return e4 >= t3.$a && e4 <= t3.$f || e4 >= t3.$A && e4 <= t3.$F || n3(e4);
        }, t3.isNewLine = function(e4) {
          return e4 === t3.$LF || e4 === t3.$CR;
        }, t3.isOctalDigit = function(e4) {
          return t3.$0 <= e4 && e4 <= t3.$7;
        };
      });
      /**
      	 * @license
      	 * Copyright Google Inc. All Rights Reserved.
      	 *
      	 * Use of this source code is governed by an MIT-style license that can be
      	 * found in the LICENSE file at https://angular.io/license
      	 */
      class cj2 {
        constructor(e3, t3, n3) {
          this.filePath = e3, this.name = t3, this.members = n3;
        }
        assertNoMembers() {
          if (this.members.length)
            throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
        }
      }
      var lj2 = cj2;
      var pj2 = class {
        constructor() {
          this.cache = new Map();
        }
        get(e3, t3, n3) {
          const r3 = `"${e3}".${t3}${(n3 = n3 || []).length ? `.${n3.join(".")}` : ""}`;
          let i3 = this.cache.get(r3);
          return i3 || (i3 = new cj2(e3, t3, n3), this.cache.set(r3, i3)), i3;
        }
      }, fj2 = Object.defineProperty({ StaticSymbol: lj2, StaticSymbolCache: pj2 }, "__esModule", { value: true });
      /**
      	 * @license
      	 * Copyright Google Inc. All Rights Reserved.
      	 *
      	 * Use of this source code is governed by an MIT-style license that can be
      	 * found in the LICENSE file at https://angular.io/license
      	 */
      const dj2 = /-+([a-z0-9])/g;
      var hj2 = function(e3) {
        return e3.replace(dj2, (...e4) => e4[1].toUpperCase());
      };
      var gj2 = function(e3, t3) {
        return yj2(e3, ":", t3);
      };
      var mj2 = function(e3, t3) {
        return yj2(e3, ".", t3);
      };
      function yj2(e3, t3, n3) {
        const r3 = e3.indexOf(t3);
        return r3 == -1 ? n3 : [e3.slice(0, r3).trim(), e3.slice(r3 + 1).trim()];
      }
      function Dj2(e3, t3, n3) {
        return Array.isArray(e3) ? t3.visitArray(e3, n3) : function(e4) {
          return typeof e4 == "object" && e4 !== null && Object.getPrototypeOf(e4) === kj2;
        }(e3) ? t3.visitStringMap(e3, n3) : e3 == null || typeof e3 == "string" || typeof e3 == "number" || typeof e3 == "boolean" ? t3.visitPrimitive(e3, n3) : t3.visitOther(e3, n3);
      }
      var Ej2 = Dj2;
      var Cj2 = function(e3) {
        return e3 != null;
      };
      var bj2 = function(e3) {
        return e3 === void 0 ? null : e3;
      };
      var Aj2 = class {
        visitArray(e3, t3) {
          return e3.map((e4) => Dj2(e4, this, t3));
        }
        visitStringMap(e3, t3) {
          const n3 = {};
          return Object.keys(e3).forEach((r3) => {
            n3[r3] = Dj2(e3[r3], this, t3);
          }), n3;
        }
        visitPrimitive(e3, t3) {
          return e3;
        }
        visitOther(e3, t3) {
          return e3;
        }
      }, vj2 = { assertSync: (e3) => {
        if (Lj2(e3))
          throw new Error("Illegal state: value cannot be a promise");
        return e3;
      }, then: (e3, t3) => Lj2(e3) ? e3.then(t3) : t3(e3), all: (e3) => e3.some(Lj2) ? Promise.all(e3) : e3 };
      var Fj2 = function(e3) {
        throw new Error(`Internal Error: ${e3}`);
      };
      var xj2 = function(e3, t3) {
        const n3 = Error(e3);
        return n3[Sj2] = true, t3 && (n3[wj2] = t3), n3;
      };
      const Sj2 = "ngSyntaxError", wj2 = "ngParseErrors";
      var Tj2 = function(e3) {
        return e3[Sj2];
      };
      var Bj2 = function(e3) {
        return e3[wj2] || [];
      };
      var Nj2 = function(e3) {
        return e3.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      };
      const kj2 = Object.getPrototypeOf({});
      var Pj2 = function(e3) {
        let t3 = "";
        for (let n3 = 0; n3 < e3.length; n3++) {
          let r3 = e3.charCodeAt(n3);
          if (r3 >= 55296 && r3 <= 56319 && e3.length > n3 + 1) {
            const t4 = e3.charCodeAt(n3 + 1);
            t4 >= 56320 && t4 <= 57343 && (n3++, r3 = (r3 - 55296 << 10) + t4 - 56320 + 65536);
          }
          r3 <= 127 ? t3 += String.fromCharCode(r3) : r3 <= 2047 ? t3 += String.fromCharCode(r3 >> 6 & 31 | 192, 63 & r3 | 128) : r3 <= 65535 ? t3 += String.fromCharCode(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128) : r3 <= 2097151 && (t3 += String.fromCharCode(r3 >> 18 & 7 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128));
        }
        return t3;
      };
      var Oj2 = function e3(t3) {
        if (typeof t3 == "string")
          return t3;
        if (t3 instanceof Array)
          return "[" + t3.map(e3).join(", ") + "]";
        if (t3 == null)
          return "" + t3;
        if (t3.overriddenName)
          return `${t3.overriddenName}`;
        if (t3.name)
          return `${t3.name}`;
        if (!t3.toString)
          return "object";
        const n3 = t3.toString();
        if (n3 == null)
          return "" + n3;
        const r3 = n3.indexOf("\n");
        return r3 === -1 ? n3 : n3.substring(0, r3);
      };
      var Ij2 = function(e3) {
        return typeof e3 == "function" && e3.hasOwnProperty("__forward_ref__") ? e3() : e3;
      };
      function Lj2(e3) {
        return !!e3 && typeof e3.then == "function";
      }
      var jj2 = Lj2;
      var _j2 = class {
        constructor(e3) {
          this.full = e3;
          const t3 = e3.split(".");
          this.major = t3[0], this.minor = t3[1], this.patch = t3.slice(2).join(".");
        }
      };
      const Mj2 = typeof window != "undefined" && window, Rj2 = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
      var $j2 = t2 !== void 0 && t2 || Mj2 || Rj2, Vj2 = Object.defineProperty({ dashCaseToCamelCase: hj2, splitAtColon: gj2, splitAtPeriod: mj2, visitValue: Ej2, isDefined: Cj2, noUndefined: bj2, ValueTransformer: Aj2, SyncAsync: vj2, error: Fj2, syntaxError: xj2, isSyntaxError: Tj2, getParseErrors: Bj2, escapeRegExp: Nj2, utf8Encode: Pj2, stringify: Oj2, resolveForwardRef: Ij2, isPromise: jj2, Version: _j2, global: $j2 }, "__esModule", { value: true }), Wj2 = r2(function(e3, t3) {
        /**
        	   * @license
        	   * Copyright Google Inc. All Rights Reserved.
        	   *
        	   * Use of this source code is governed by an MIT-style license that can be
        	   * found in the LICENSE file at https://angular.io/license
        	   */
        Object.defineProperty(t3, "__esModule", { value: true });
        const n3 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
        function r3(e4) {
          return e4.replace(/\W/g, "_");
        }
        t3.sanitizeIdentifier = r3;
        let i3 = 0;
        function u3(e4) {
          if (!e4 || !e4.reference)
            return null;
          const t4 = e4.reference;
          if (t4 instanceof fj2.StaticSymbol)
            return t4.name;
          if (t4.__anonymousType)
            return t4.__anonymousType;
          let n4 = Vj2.stringify(t4);
          return n4.indexOf("(") >= 0 ? (n4 = "anonymous_" + i3++, t4.__anonymousType = n4) : n4 = r3(n4), n4;
        }
        var o3;
        t3.identifierName = u3, t3.identifierModuleUrl = function(e4) {
          const t4 = e4.reference;
          return t4 instanceof fj2.StaticSymbol ? t4.filePath : `./${Vj2.stringify(t4)}`;
        }, t3.viewClassName = function(e4, t4) {
          return `View_${u3({ reference: e4 })}_${t4}`;
        }, t3.rendererTypeName = function(e4) {
          return `RenderType_${u3({ reference: e4 })}`;
        }, t3.hostViewClassName = function(e4) {
          return `HostView_${u3({ reference: e4 })}`;
        }, t3.componentFactoryName = function(e4) {
          return `${u3({ reference: e4 })}NgFactory`;
        }, function(e4) {
          e4[e4.Pipe = 0] = "Pipe", e4[e4.Directive = 1] = "Directive", e4[e4.NgModule = 2] = "NgModule", e4[e4.Injectable = 3] = "Injectable";
        }(o3 = t3.CompileSummaryKind || (t3.CompileSummaryKind = {})), t3.tokenName = function(e4) {
          return e4.value != null ? r3(e4.value) : u3(e4.identifier);
        }, t3.tokenReference = function(e4) {
          return e4.identifier != null ? e4.identifier.reference : e4.value;
        };
        t3.CompileStylesheetMetadata = class {
          constructor({ moduleUrl: e4, styles: t4, styleUrls: n4 } = {}) {
            this.moduleUrl = e4 || null, this.styles = a3(t4), this.styleUrls = a3(n4);
          }
        };
        t3.CompileTemplateMetadata = class {
          constructor({ encapsulation: e4, template: t4, templateUrl: n4, htmlAst: r4, styles: i4, styleUrls: u4, externalStylesheets: o4, animations: s4, ngContentSelectors: l4, interpolation: p3, isInline: f3, preserveWhitespaces: d3 }) {
            if (this.encapsulation = e4, this.template = t4, this.templateUrl = n4, this.htmlAst = r4, this.styles = a3(i4), this.styleUrls = a3(u4), this.externalStylesheets = a3(o4), this.animations = s4 ? c3(s4) : [], this.ngContentSelectors = l4 || [], p3 && p3.length != 2)
              throw new Error("'interpolation' should have a start and an end symbol.");
            this.interpolation = p3, this.isInline = f3, this.preserveWhitespaces = d3;
          }
          toSummary() {
            return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
          }
        };
        class s3 {
          static create({ isHost: e4, type: t4, isComponent: r4, selector: i4, exportAs: u4, changeDetection: o4, inputs: a4, outputs: c4, host: l4, providers: p3, viewProviders: f3, queries: d3, guards: h3, viewQueries: g3, entryComponents: m3, template: y3, componentViewType: D3, rendererType: E3, componentFactory: C3 }) {
            const b3 = {}, A3 = {}, v3 = {};
            l4 != null && Object.keys(l4).forEach((e5) => {
              const t5 = l4[e5], r5 = e5.match(n3);
              r5 === null ? v3[e5] = t5 : r5[1] != null ? A3[r5[1]] = t5 : r5[2] != null && (b3[r5[2]] = t5);
            });
            const F3 = {};
            a4 != null && a4.forEach((e5) => {
              const t5 = Vj2.splitAtColon(e5, [e5, e5]);
              F3[t5[0]] = t5[1];
            });
            const x3 = {};
            return c4 != null && c4.forEach((e5) => {
              const t5 = Vj2.splitAtColon(e5, [e5, e5]);
              x3[t5[0]] = t5[1];
            }), new s3({ isHost: e4, type: t4, isComponent: !!r4, selector: i4, exportAs: u4, changeDetection: o4, inputs: F3, outputs: x3, hostListeners: b3, hostProperties: A3, hostAttributes: v3, providers: p3, viewProviders: f3, queries: d3, guards: h3, viewQueries: g3, entryComponents: m3, template: y3, componentViewType: D3, rendererType: E3, componentFactory: C3 });
          }
          constructor({ isHost: e4, type: t4, isComponent: n4, selector: r4, exportAs: i4, changeDetection: u4, inputs: o4, outputs: s4, hostListeners: c4, hostProperties: l4, hostAttributes: p3, providers: f3, viewProviders: d3, queries: h3, guards: g3, viewQueries: m3, entryComponents: y3, template: D3, componentViewType: E3, rendererType: C3, componentFactory: b3 }) {
            this.isHost = !!e4, this.type = t4, this.isComponent = n4, this.selector = r4, this.exportAs = i4, this.changeDetection = u4, this.inputs = o4, this.outputs = s4, this.hostListeners = c4, this.hostProperties = l4, this.hostAttributes = p3, this.providers = a3(f3), this.viewProviders = a3(d3), this.queries = a3(h3), this.guards = g3, this.viewQueries = a3(m3), this.entryComponents = a3(y3), this.template = D3, this.componentViewType = E3, this.rendererType = C3, this.componentFactory = b3;
          }
          toSummary() {
            return { summaryKind: o3.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
          }
        }
        t3.CompileDirectiveMetadata = s3;
        t3.CompilePipeMetadata = class {
          constructor({ type: e4, name: t4, pure: n4 }) {
            this.type = e4, this.name = t4, this.pure = !!n4;
          }
          toSummary() {
            return { summaryKind: o3.Pipe, type: this.type, name: this.name, pure: this.pure };
          }
        };
        t3.CompileShallowModuleMetadata = class {
        };
        t3.CompileNgModuleMetadata = class {
          constructor({ type: e4, providers: t4, declaredDirectives: n4, exportedDirectives: r4, declaredPipes: i4, exportedPipes: u4, entryComponents: o4, bootstrapComponents: s4, importedModules: c4, exportedModules: l4, schemas: p3, transitiveModule: f3, id: d3 }) {
            this.type = e4 || null, this.declaredDirectives = a3(n4), this.exportedDirectives = a3(r4), this.declaredPipes = a3(i4), this.exportedPipes = a3(u4), this.providers = a3(t4), this.entryComponents = a3(o4), this.bootstrapComponents = a3(s4), this.importedModules = a3(c4), this.exportedModules = a3(l4), this.schemas = a3(p3), this.id = d3 || null, this.transitiveModule = f3 || null;
          }
          toSummary() {
            const e4 = this.transitiveModule;
            return { summaryKind: o3.NgModule, type: this.type, entryComponents: e4.entryComponents, providers: e4.providers, modules: e4.modules, exportedDirectives: e4.exportedDirectives, exportedPipes: e4.exportedPipes };
          }
        };
        function a3(e4) {
          return e4 || [];
        }
        t3.TransitiveCompileNgModuleMetadata = class {
          constructor() {
            this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
          }
          addProvider(e4, t4) {
            this.providers.push({ provider: e4, module: t4 });
          }
          addDirective(e4) {
            this.directivesSet.has(e4.reference) || (this.directivesSet.add(e4.reference), this.directives.push(e4));
          }
          addExportedDirective(e4) {
            this.exportedDirectivesSet.has(e4.reference) || (this.exportedDirectivesSet.add(e4.reference), this.exportedDirectives.push(e4));
          }
          addPipe(e4) {
            this.pipesSet.has(e4.reference) || (this.pipesSet.add(e4.reference), this.pipes.push(e4));
          }
          addExportedPipe(e4) {
            this.exportedPipesSet.has(e4.reference) || (this.exportedPipesSet.add(e4.reference), this.exportedPipes.push(e4));
          }
          addModule(e4) {
            this.modulesSet.has(e4.reference) || (this.modulesSet.add(e4.reference), this.modules.push(e4));
          }
          addEntryComponent(e4) {
            this.entryComponentsSet.has(e4.componentType) || (this.entryComponentsSet.add(e4.componentType), this.entryComponents.push(e4));
          }
        };
        function c3(e4) {
          return e4.reduce((e5, t4) => {
            const n4 = Array.isArray(t4) ? c3(t4) : t4;
            return e5.concat(n4);
          }, []);
        }
        function l3(e4) {
          return e4.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
        }
        t3.ProviderMeta = class {
          constructor(e4, { useClass: t4, useValue: n4, useExisting: r4, useFactory: i4, deps: u4, multi: o4 }) {
            this.token = e4, this.useClass = t4 || null, this.useValue = n4, this.useExisting = r4, this.useFactory = i4 || null, this.dependencies = u4 || null, this.multi = !!o4;
          }
        }, t3.flatten = c3, t3.templateSourceUrl = function(e4, t4, n4) {
          let r4;
          return r4 = n4.isInline ? t4.type.reference instanceof fj2.StaticSymbol ? `${t4.type.reference.filePath}.${t4.type.reference.name}.html` : `${u3(e4)}/${u3(t4.type)}.html` : n4.templateUrl, t4.type.reference instanceof fj2.StaticSymbol ? r4 : l3(r4);
        }, t3.sharedStylesheetJitUrl = function(e4, t4) {
          const n4 = e4.moduleUrl.split(/\/\\/g);
          return l3(`css/${t4}${n4[n4.length - 1]}.ngstyle.js`);
        }, t3.ngModuleJitUrl = function(e4) {
          return l3(`${u3(e4.type)}/module.ngfactory.js`);
        }, t3.templateJitUrl = function(e4, t4) {
          return l3(`${u3(e4)}/${u3(t4.type)}.ngfactory.js`);
        };
      }), qj2 = r2(function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true });
        /**
        	   * @license
        	   * Copyright Google Inc. All Rights Reserved.
        	   *
        	   * Use of this source code is governed by an MIT-style license that can be
        	   * found in the LICENSE file at https://angular.io/license
        	   */
        class n3 {
          constructor(e4, t4, n4, r4) {
            this.file = e4, this.offset = t4, this.line = n4, this.col = r4;
          }
          toString() {
            return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
          }
          moveBy(e4) {
            const t4 = this.file.content, r4 = t4.length;
            let i4 = this.offset, u4 = this.line, o3 = this.col;
            for (; i4 > 0 && e4 < 0; ) {
              i4--, e4++;
              if (t4.charCodeAt(i4) == aj2.$LF) {
                u4--;
                const e5 = t4.substr(0, i4 - 1).lastIndexOf(String.fromCharCode(aj2.$LF));
                o3 = e5 > 0 ? i4 - e5 : i4;
              } else
                o3--;
            }
            for (; i4 < r4 && e4 > 0; ) {
              const n4 = t4.charCodeAt(i4);
              i4++, e4--, n4 == aj2.$LF ? (u4++, o3 = 0) : o3++;
            }
            return new n3(this.file, i4, u4, o3);
          }
          getContext(e4, t4) {
            const n4 = this.file.content;
            let r4 = this.offset;
            if (r4 != null) {
              r4 > n4.length - 1 && (r4 = n4.length - 1);
              let i4 = r4, u4 = 0, o3 = 0;
              for (; u4 < e4 && r4 > 0 && (r4--, u4++, n4[r4] != "\n" || ++o3 != t4); )
                ;
              for (u4 = 0, o3 = 0; u4 < e4 && i4 < n4.length - 1 && (i4++, u4++, n4[i4] != "\n" || ++o3 != t4); )
                ;
              return { before: n4.substring(r4, this.offset), after: n4.substring(this.offset, i4 + 1) };
            }
            return null;
          }
        }
        t3.ParseLocation = n3;
        class r3 {
          constructor(e4, t4) {
            this.content = e4, this.url = t4;
          }
        }
        t3.ParseSourceFile = r3;
        class i3 {
          constructor(e4, t4, n4 = null) {
            this.start = e4, this.end = t4, this.details = n4;
          }
          toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
          }
        }
        var u3;
        t3.ParseSourceSpan = i3, t3.EMPTY_PARSE_LOCATION = new n3(new r3("", ""), 0, 0, 0), t3.EMPTY_SOURCE_SPAN = new i3(t3.EMPTY_PARSE_LOCATION, t3.EMPTY_PARSE_LOCATION), function(e4) {
          e4[e4.WARNING = 0] = "WARNING", e4[e4.ERROR = 1] = "ERROR";
        }(u3 = t3.ParseErrorLevel || (t3.ParseErrorLevel = {}));
        t3.ParseError = class {
          constructor(e4, t4, n4 = u3.ERROR) {
            this.span = e4, this.msg = t4, this.level = n4;
          }
          contextualMessage() {
            const e4 = this.span.start.getContext(100, 3);
            return e4 ? `${this.msg} ("${e4.before}[${u3[this.level]} ->]${e4.after}")` : this.msg;
          }
          toString() {
            const e4 = this.span.details ? `, ${this.span.details}` : "";
            return `${this.contextualMessage()}: ${this.span.start}${e4}`;
          }
        }, t3.typeSourceSpan = function(e4, t4) {
          const u4 = Wj2.identifierModuleUrl(t4), o3 = u4 != null ? `in ${e4} ${Wj2.identifierName(t4)} in ${u4}` : `in ${e4} ${Wj2.identifierName(t4)}`, s3 = new r3("", o3);
          return new i3(new n3(s3, -1, -1, -1), new n3(s3, -1, -1, -1));
        }, t3.r3JitTypeSourceSpan = function(e4, t4, u4) {
          const o3 = new r3("", `in ${e4} ${t4} in ${u4}`);
          return new i3(new n3(o3, -1, -1, -1), new n3(o3, -1, -1, -1));
        };
      });
      const { ParseSourceSpan: Uj2 } = qj2, { htmlTrim: zj2, getLeadingAndTrailingHtmlWhitespace: Gj2, hasHtmlWhitespace: Hj2, canHaveInterpolation: Jj2, getNodeCssStyleDisplay: Xj2, isDanglingSpaceSensitiveNode: Yj2, isIndentationSensitiveNode: Kj2, isLeadingSpaceSensitiveNode: Qj2, isTrailingSpaceSensitiveNode: Zj2, isWhitespaceSensitiveNode: e_2 } = sj2, t_2 = [function(e3) {
        e3.walk((e4) => {
          if (e4.type === "element" && e4.tagDefinition.ignoreFirstLf && e4.children.length > 0 && e4.children[0].type === "text" && e4.children[0].value[0] === "\n") {
            const [t3, ...n3] = e4.children;
            e4.setChildren(t3.value.length === 1 ? n3 : [t3.clone({ value: t3.value.slice(1) }), ...n3]);
          }
        });
      }, function(e3) {
        const t3 = (e4) => e4.type === "element" && e4.prev && e4.prev.type === "ieConditionalStartComment" && e4.prev.sourceSpan.end.offset === e4.startSourceSpan.start.offset && e4.firstChild && e4.firstChild.type === "ieConditionalEndComment" && e4.firstChild.sourceSpan.start.offset === e4.startSourceSpan.end.offset;
        e3.walk((e4) => {
          if (e4.children) {
            const n3 = e4.children.map(t3);
            if (n3.some(Boolean)) {
              const t4 = [];
              for (let r3 = 0; r3 < e4.children.length; r3++) {
                const i3 = e4.children[r3];
                if (!n3[r3 + 1])
                  if (n3[r3]) {
                    const e5 = i3.prev, n4 = i3.firstChild, r4 = new Uj2(e5.sourceSpan.start, n4.sourceSpan.end), u3 = new Uj2(r4.start, i3.sourceSpan.end);
                    t4.push(i3.clone({ condition: e5.condition, sourceSpan: u3, startSourceSpan: r4, children: i3.children.slice(1) }));
                  } else
                    t4.push(i3);
              }
              e4.setChildren(t4);
            }
          }
        });
      }, function(e3) {
        return function(e4, t3, n3) {
          e4.walk((e5) => {
            if (e5.children) {
              const r3 = e5.children.map(t3);
              if (r3.some(Boolean)) {
                const t4 = [];
                for (let i3 = 0; i3 < e5.children.length; i3++) {
                  const u3 = e5.children[i3];
                  if (u3.type !== "text" && !r3[i3]) {
                    t4.push(u3);
                    continue;
                  }
                  const o3 = u3.type === "text" ? u3 : u3.clone({ type: "text", value: n3(u3) });
                  if (t4.length === 0 || _n2(t4).type !== "text") {
                    t4.push(o3);
                    continue;
                  }
                  const s3 = t4.pop();
                  t4.push(s3.clone({ value: s3.value + o3.value, sourceSpan: new Uj2(s3.sourceSpan.start, o3.sourceSpan.end) }));
                }
                e5.setChildren(t4);
              }
            }
          });
        }(e3, (e4) => e4.type === "cdata", (e4) => `<![CDATA[${e4.value}]]>`);
      }, function(e3, t3) {
        if (t3.parser === "html")
          return;
        const n3 = /{{(.+?)}}/s;
        e3.walk((e4) => {
          if (!Jj2(e4))
            return;
          const t4 = [];
          for (const r3 of e4.children) {
            if (r3.type !== "text") {
              t4.push(r3);
              continue;
            }
            let e5 = r3.sourceSpan.start, i3 = null;
            const u3 = r3.value.split(n3);
            for (let n4 = 0; n4 < u3.length; n4++, e5 = i3) {
              const r4 = u3[n4];
              n4 % 2 != 0 ? (i3 = e5.moveBy(r4.length + 4), t4.push({ type: "interpolation", sourceSpan: new Uj2(e5, i3), children: r4.length === 0 ? [] : [{ type: "text", value: r4, sourceSpan: new Uj2(e5.moveBy(2), i3.moveBy(-2)) }] })) : (i3 = e5.moveBy(r4.length), r4.length > 0 && t4.push({ type: "text", value: r4, sourceSpan: new Uj2(e5, i3) }));
            }
          }
          e4.setChildren(t4);
        });
      }, function(e3) {
        e3.walk((e4) => {
          if (!e4.children)
            return;
          if (e4.children.length === 0 || e4.children.length === 1 && e4.children[0].type === "text" && zj2(e4.children[0].value).length === 0)
            return e4.hasDanglingSpaces = e4.children.length > 0, void (e4.children = []);
          const t3 = e_2(e4), n3 = Kj2(e4);
          e4.setChildren(e4.children.flatMap((e5) => {
            if (e5.type !== "text" || t3)
              return e5;
            const n4 = [], { leadingWhitespace: r3, text: i3, trailingWhitespace: u3 } = Gj2(e5.value);
            return r3 && n4.push(n_2), i3 && n4.push({ type: "text", value: i3, sourceSpan: new Uj2(e5.sourceSpan.start.moveBy(r3.length), e5.sourceSpan.end.moveBy(-u3.length)) }), u3 && n4.push(n_2), n4;
          }).map((e5, t4, n4) => {
            if (e5 !== n_2)
              return Object.assign(Object.assign({}, e5), {}, { hasLeadingSpaces: n4[t4 - 1] === n_2, hasTrailingSpaces: n4[t4 + 1] === n_2 });
          }).filter(Boolean)), e4.isWhitespaceSensitive = t3, e4.isIndentationSensitive = n3;
        });
      }, function(e3, t3) {
        e3.walk((e4) => Object.assign(e4, { cssDisplay: Xj2(e4, t3) }));
      }, function(e3) {
        e3.walk((e4) => Object.assign(e4, { isSelfClosing: !e4.children || e4.type === "element" && (e4.tagDefinition.isVoid || e4.startSourceSpan === e4.endSourceSpan) }));
      }, function(e3, t3) {
        e3.walk((e4) => e4.type !== "element" ? e4 : Object.assign(e4, { hasHtmComponentClosingTag: e4.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t3.originalText.slice(e4.endSourceSpan.start.offset, e4.endSourceSpan.end.offset)) }));
      }, function(e3, t3) {
        e3.walk((e4) => {
          e4.children && (e4.children.length !== 0 ? e4.setChildren(e4.children.map((e5) => Object.assign(Object.assign({}, e5), {}, { isLeadingSpaceSensitive: Qj2(e5, t3), isTrailingSpaceSensitive: Zj2(e5, t3) })).map((e5, t4, n3) => Object.assign(Object.assign({}, e5), {}, { isLeadingSpaceSensitive: (t4 === 0 || n3[t4 - 1].isTrailingSpaceSensitive) && e5.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t4 === n3.length - 1 || n3[t4 + 1].isLeadingSpaceSensitive) && e5.isTrailingSpaceSensitive }))) : e4.isDanglingSpaceSensitive = Yj2(e4));
        });
      }, function(e3) {
        const t3 = (e4) => e4.type === "element" && e4.attrs.length === 0 && e4.children.length === 1 && e4.firstChild.type === "text" && !Hj2(e4.children[0].value) && !e4.firstChild.hasLeadingSpaces && !e4.firstChild.hasTrailingSpaces && e4.isLeadingSpaceSensitive && !e4.hasLeadingSpaces && e4.isTrailingSpaceSensitive && !e4.hasTrailingSpaces && e4.prev && e4.prev.type === "text" && e4.next && e4.next.type === "text";
        e3.walk((e4) => {
          if (e4.children) {
            const n3 = e4.children.map(t3);
            if (n3.some(Boolean)) {
              const t4 = [];
              for (let r3 = 0; r3 < e4.children.length; r3++) {
                const i3 = e4.children[r3];
                if (n3[r3]) {
                  const n4 = t4.pop(), u3 = e4.children[++r3], { isTrailingSpaceSensitive: o3, hasTrailingSpaces: s3 } = u3;
                  t4.push(n4.clone({ value: n4.value + `<${i3.rawName}>` + i3.firstChild.value + `</${i3.rawName}>` + u3.value, sourceSpan: new Uj2(n4.sourceSpan.start, u3.sourceSpan.end), isTrailingSpaceSensitive: o3, hasTrailingSpaces: s3 }));
                } else
                  t4.push(i3);
              }
              e4.setChildren(t4);
            }
          }
        });
      }];
      const n_2 = { type: "whitespace" };
      var r_2 = function(e3, t3) {
        const n3 = e3.map((e4) => e4);
        for (const e4 of t_2)
          e4(n3, t3);
        return n3;
      };
      var i_2 = { hasPragma: function(e3) {
        return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e3);
      }, insertPragma: function(e3) {
        return "<!-- @format -->\n\n" + e3.replace(/^\s*\n/, "");
      } };
      var u_2 = { locStart: function(e3) {
        return e3.sourceSpan.start.offset;
      }, locEnd: function(e3) {
        return e3.sourceSpan.end.offset;
      } };
      const { isNonEmptyArray: o_2 } = Fi2, { builders: { indent: s_2, join: a_2, line: c_2, softline: l_2 }, utils: { replaceTextEndOfLine: p_2 } } = su2, { locStart: f_2, locEnd: d_2 } = u_2, { isTextLikeNode: h_2, getLastDescendant: g_2, isPreLikeNode: m_2, hasPrettierIgnore: y_2, shouldPreserveContent: D_2 } = sj2;
      function E_2(e3, t3) {
        return e3.lastChild && T_2(e3.lastChild) ? "" : [b_2(e3, t3), v_2(e3, t3)];
      }
      function C_2(e3, t3) {
        return (e3.next ? S_2(e3.next) : w_2(e3.parent)) ? "" : [F_2(e3, t3), A_2(e3, t3)];
      }
      function b_2(e3, t3) {
        return w_2(e3) ? F_2(e3.lastChild, t3) : "";
      }
      function A_2(e3, t3) {
        return T_2(e3) ? v_2(e3.parent, t3) : B_2(e3) ? L_2(e3.next) : "";
      }
      function v_2(e3, t3) {
        if (Ff2(!e3.isSelfClosing), x_2(e3, t3))
          return "";
        switch (e3.type) {
          case "ieConditionalComment":
            return "<!";
          case "element":
            if (e3.hasHtmComponentClosingTag)
              return "<//";
          default:
            return `</${e3.rawName}`;
        }
      }
      function F_2(e3, t3) {
        if (x_2(e3, t3))
          return "";
        switch (e3.type) {
          case "ieConditionalComment":
          case "ieConditionalEndComment":
            return "[endif]-->";
          case "ieConditionalStartComment":
            return "]><!-->";
          case "interpolation":
            return "}}";
          case "element":
            if (e3.isSelfClosing)
              return "/>";
          default:
            return ">";
        }
      }
      function x_2(e3, t3) {
        return !e3.isSelfClosing && !e3.endSourceSpan && (y_2(e3) || D_2(e3.parent, t3));
      }
      function S_2(e3) {
        return e3.prev && e3.prev.type !== "docType" && !h_2(e3.prev) && e3.isLeadingSpaceSensitive && !e3.hasLeadingSpaces;
      }
      function w_2(e3) {
        return e3.lastChild && e3.lastChild.isTrailingSpaceSensitive && !e3.lastChild.hasTrailingSpaces && !h_2(g_2(e3.lastChild)) && !m_2(e3);
      }
      function T_2(e3) {
        return !e3.next && !e3.hasTrailingSpaces && e3.isTrailingSpaceSensitive && h_2(g_2(e3));
      }
      function B_2(e3) {
        return e3.next && !h_2(e3.next) && h_2(e3) && e3.isTrailingSpaceSensitive && !e3.hasTrailingSpaces;
      }
      function N_2(e3) {
        return !e3.prev && e3.isLeadingSpaceSensitive && !e3.hasLeadingSpaces;
      }
      function k_2(e3, t3, n3) {
        const r3 = e3.getValue();
        if (!o_2(r3.attrs))
          return r3.isSelfClosing ? " " : "";
        const i3 = r3.prev && r3.prev.type === "comment" && function(e4) {
          const t4 = e4.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
          return !!t4 && (!t4[1] || t4[1].split(/\s+/));
        }(r3.prev.value), u3 = typeof i3 == "boolean" ? () => i3 : Array.isArray(i3) ? (e4) => i3.includes(e4.rawName) : () => false, o3 = e3.map((e4) => {
          const r4 = e4.getValue();
          return u3(r4) ? p_2(t3.originalText.slice(f_2(r4), d_2(r4))) : n3();
        }, "attrs"), s3 = r3.type === "element" && r3.fullName === "script" && r3.attrs.length === 1 && r3.attrs[0].fullName === "src" && r3.children.length === 0, a3 = [s_2([s3 ? " " : c_2, a_2(c_2, o3)])];
        return r3.firstChild && N_2(r3.firstChild) || r3.isSelfClosing && w_2(r3.parent) || s3 ? a3.push(r3.isSelfClosing ? " " : "") : a3.push(t3.bracketSameLine ? r3.isSelfClosing ? " " : "" : r3.isSelfClosing ? c_2 : l_2), a3;
      }
      function P_2(e3) {
        return e3.firstChild && N_2(e3.firstChild) ? "" : j_2(e3);
      }
      function O_2(e3, t3) {
        return e3.prev && B_2(e3.prev) ? "" : [I_2(e3, t3), L_2(e3)];
      }
      function I_2(e3, t3) {
        return N_2(e3) ? j_2(e3.parent) : S_2(e3) ? F_2(e3.prev, t3) : "";
      }
      function L_2(e3) {
        switch (e3.type) {
          case "ieConditionalComment":
          case "ieConditionalStartComment":
            return `<!--[if ${e3.condition}`;
          case "ieConditionalEndComment":
            return "<!--<!";
          case "interpolation":
            return "{{";
          case "docType":
            return "<!DOCTYPE";
          case "element":
            if (e3.condition)
              return `<!--[if ${e3.condition}]><!--><${e3.rawName}`;
          default:
            return `<${e3.rawName}`;
        }
      }
      function j_2(e3) {
        switch (Ff2(!e3.isSelfClosing), e3.type) {
          case "ieConditionalComment":
            return "]>";
          case "element":
            if (e3.condition)
              return "><!--<![endif]-->";
          default:
            return ">";
        }
      }
      var __2 = { printClosingTag: function(e3, t3) {
        return [e3.isSelfClosing ? "" : E_2(e3, t3), C_2(e3, t3)];
      }, printClosingTagStart: E_2, printClosingTagStartMarker: v_2, printClosingTagEndMarker: F_2, printClosingTagSuffix: A_2, printClosingTagEnd: C_2, needsToBorrowLastChildClosingTagEndMarker: w_2, needsToBorrowParentClosingTagStartMarker: T_2, needsToBorrowPrevClosingTagEndMarker: S_2, printOpeningTag: function(e3, t3, n3) {
        const r3 = e3.getValue();
        return [O_2(r3, t3), k_2(e3, t3, n3), r3.isSelfClosing ? "" : P_2(r3)];
      }, printOpeningTagStart: O_2, printOpeningTagPrefix: I_2, printOpeningTagStartMarker: L_2, printOpeningTagEndMarker: j_2, needsToBorrowNextOpeningTagStartMarker: B_2, needsToBorrowParentOpeningTagEndMarker: N_2 }, M_2 = r2(function(e3) {
        var n3, r3;
        n3 = t2, r3 = function() {
          return function(e4, t3) {
            var n4 = t3 && t3.logger || console;
            function r4(e5) {
              return e5 === " " || e5 === "	" || e5 === "\n" || e5 === "\f" || e5 === "\r";
            }
            function i3(t4) {
              var n5, r5 = t4.exec(e4.substring(y3));
              if (r5)
                return n5 = r5[0], y3 += n5.length, n5;
            }
            for (var u3, o3, s3, a3, c3, l3 = e4.length, p3 = /^[ \t\n\r\u000c]+/, f3 = /^[, \t\n\r\u000c]+/, d3 = /^[^ \t\n\r\u000c]+/, h3 = /[,]+$/, g3 = /^\d+$/, m3 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y3 = 0, D3 = []; ; ) {
              if (i3(f3), y3 >= l3)
                return D3;
              u3 = i3(d3), o3 = [], u3.slice(-1) === "," ? (u3 = u3.replace(h3, ""), C3()) : E3();
            }
            function E3() {
              for (i3(p3), s3 = "", a3 = "in descriptor"; ; ) {
                if (c3 = e4.charAt(y3), a3 === "in descriptor")
                  if (r4(c3))
                    s3 && (o3.push(s3), s3 = "", a3 = "after descriptor");
                  else {
                    if (c3 === ",")
                      return y3 += 1, s3 && o3.push(s3), void C3();
                    if (c3 === "(")
                      s3 += c3, a3 = "in parens";
                    else {
                      if (c3 === "")
                        return s3 && o3.push(s3), void C3();
                      s3 += c3;
                    }
                  }
                else if (a3 === "in parens")
                  if (c3 === ")")
                    s3 += c3, a3 = "in descriptor";
                  else {
                    if (c3 === "")
                      return o3.push(s3), void C3();
                    s3 += c3;
                  }
                else if (a3 === "after descriptor")
                  if (r4(c3))
                    ;
                  else {
                    if (c3 === "")
                      return void C3();
                    a3 = "in descriptor", y3 -= 1;
                  }
                y3 += 1;
              }
            }
            function C3() {
              var t4, r5, i4, s4, a4, c4, l4, p4, f4, d4 = false, h4 = {};
              for (s4 = 0; s4 < o3.length; s4++)
                c4 = (a4 = o3[s4])[a4.length - 1], l4 = a4.substring(0, a4.length - 1), p4 = parseInt(l4, 10), f4 = parseFloat(l4), g3.test(l4) && c4 === "w" ? ((t4 || r5) && (d4 = true), p4 === 0 ? d4 = true : t4 = p4) : m3.test(l4) && c4 === "x" ? ((t4 || r5 || i4) && (d4 = true), f4 < 0 ? d4 = true : r5 = f4) : g3.test(l4) && c4 === "h" ? ((i4 || r5) && (d4 = true), p4 === 0 ? d4 = true : i4 = p4) : d4 = true;
              d4 ? n4 && n4.error && n4.error("Invalid srcset descriptor found in '" + e4 + "' at '" + a4 + "'.") : (h4.url = u3, t4 && (h4.w = t4), r5 && (h4.d = r5), i4 && (h4.h = i4), D3.push(h4));
            }
          };
        }, e3.exports ? e3.exports = r3() : n3.parseSrcset = r3();
      });
      const { builders: { group: R_2, ifBreak: $_2, indent: V_2, join: W_2, line: q_2, softline: U_2 } } = su2;
      const z_2 = [":", "__", "--", "_", "-"];
      function G_2(e3) {
        const t3 = e3.search(/[^_-]/);
        if (t3 !== -1)
          for (const n3 of z_2) {
            const r3 = e3.indexOf(n3, t3);
            if (r3 !== -1)
              return e3.slice(0, r3);
          }
        return e3;
      }
      var H_2 = { printImgSrcset: function(e3) {
        const t3 = M_2(e3, { logger: { error(e4) {
          throw new Error(e4);
        } } }), n3 = t3.some(({ w: e4 }) => e4), r3 = t3.some(({ h: e4 }) => e4);
        if (n3 + r3 + t3.some(({ d: e4 }) => e4) > 1)
          throw new Error("Mixed descriptor in srcset is not supported");
        const i3 = n3 ? "w" : r3 ? "h" : "d", u3 = n3 ? "w" : r3 ? "h" : "x", o3 = (e4) => Math.max(...e4), s3 = t3.map((e4) => e4.url), a3 = o3(s3.map((e4) => e4.length)), c3 = t3.map((e4) => e4[i3]).map((e4) => e4 ? e4.toString() : ""), l3 = c3.map((e4) => {
          const t4 = e4.indexOf(".");
          return t4 === -1 ? e4.length : t4;
        }), p3 = o3(l3);
        return W_2([",", q_2], s3.map((e4, t4) => {
          const n4 = [e4], r4 = c3[t4];
          if (r4) {
            const i4 = a3 - e4.length + 1, o4 = p3 - l3[t4], s4 = " ".repeat(i4 + o4);
            n4.push($_2(s4, " "), r4 + u3);
          }
          return n4;
        }));
      }, printClassNames: function(e3) {
        const t3 = e3.trim().split(/\s+/), n3 = [];
        let r3;
        for (let e4 = 0; e4 < t3.length; e4++) {
          const i3 = G_2(t3[e4]);
          i3 !== r3 && i3 !== t3[e4 - 1] && n3.push([]), _n2(n3).push(t3[e4]), r3 = i3;
        }
        return [V_2([U_2, W_2(q_2, n3.map((e4) => R_2(W_2(q_2, e4))))]), U_2];
      } };
      const { builders: { group: J_2 } } = su2;
      var X_2 = { isVueEventBindingExpression: function(e3) {
        const t3 = e3.trim();
        return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t3) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t3);
      }, printVueFor: function(e3, t3) {
        const { left: n3, operator: r3, right: i3 } = function(e4) {
          const t4 = /(.*?)\s+(in|of)\s+(.*)/s, n4 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r4 = /^\(|\)$/g, i4 = e4.match(t4);
          if (!i4)
            return;
          const u3 = {};
          u3.for = i4[3].trim();
          const o3 = i4[1].trim().replace(r4, ""), s3 = o3.match(n4);
          s3 ? (u3.alias = o3.replace(n4, ""), u3.iterator1 = s3[1].trim(), s3[2] && (u3.iterator2 = s3[2].trim())) : u3.alias = o3;
          return { left: `${[u3.alias, u3.iterator1, u3.iterator2].filter(Boolean).join(",")}`, operator: i4[2], right: u3.for };
        }(e3);
        return [J_2(t3(`function _(${n3}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", r3, " ", t3(i3, { parser: "__js_expression" }, { stripTrailingHardline: true })];
      }, printVueBindings: function(e3, t3) {
        return t3(`function _(${e3}) {}`, { parser: "babel", __isVueBindings: true });
      } };
      const { needsToBorrowParentClosingTagStartMarker: Y_2, printClosingTagStartMarker: K_2, needsToBorrowLastChildClosingTagEndMarker: Q_2, printClosingTagEndMarker: Z_2, needsToBorrowParentOpeningTagEndMarker: eM2, printOpeningTagEndMarker: tM2 } = __2;
      var nM2 = function(e3, t3) {
        let n3 = e3.startSourceSpan.end.offset;
        e3.firstChild && eM2(e3.firstChild) && (n3 -= tM2(e3).length);
        let r3 = e3.endSourceSpan.start.offset;
        return e3.lastChild && Y_2(e3.lastChild) ? r3 += K_2(e3, t3).length : Q_2(e3) && (r3 -= Z_2(e3.lastChild, t3).length), t3.originalText.slice(n3, r3);
      };
      const { builders: { breakParent: rM2, group: iM2, hardline: uM2, indent: oM2, line: sM2, fill: aM2, softline: cM2 }, utils: { mapDoc: lM2, replaceTextEndOfLine: pM2 } } = su2, { printClosingTag: fM2, printClosingTagSuffix: dM2, needsToBorrowPrevClosingTagEndMarker: hM2, printOpeningTagPrefix: gM2, printOpeningTag: mM2 } = __2, { printImgSrcset: yM2, printClassNames: DM2 } = H_2, { printVueFor: EM2, printVueBindings: CM2, isVueEventBindingExpression: bM2 } = X_2, { isScriptLikeTag: AM2, isVueNonHtmlBlock: vM2, inferScriptParser: FM2, htmlTrimPreserveIndentation: xM2, dedentString: SM2, unescapeQuoteEntities: wM2, isVueSlotAttribute: TM2, isVueSfcBindingsAttribute: BM2, getTextValueParts: NM2 } = sj2;
      function kM2(e3, t3, n3) {
        const r3 = (t4) => new RegExp(t4.join("|")).test(e3.fullName), i3 = () => wM2(e3.value);
        let u3 = false;
        const o3 = (e4, t4) => {
          const n4 = e4.type === "NGRoot" ? e4.node.type === "NGMicrosyntax" && e4.node.body.length === 1 && e4.node.body[0].type === "NGMicrosyntaxExpression" ? e4.node.body[0].expression : e4.node : e4.type === "JsExpressionRoot" ? e4.node : e4;
          !n4 || n4.type !== "ObjectExpression" && n4.type !== "ArrayExpression" && (t4.parser !== "__vue_expression" || n4.type !== "TemplateLiteral" && n4.type !== "StringLiteral") || (u3 = true);
        }, s3 = (e4, t4 = true) => iM2([oM2([cM2, e4]), t4 ? cM2 : ""]), a3 = (e4) => u3 ? ((e5) => iM2(e5))(e4) : s3(e4), c3 = (e4, n4) => t3(e4, Object.assign({ __onHtmlBindingRoot: o3, __embeddedInHtml: true }, n4), { stripTrailingHardline: true });
        if (e3.fullName === "srcset" && (e3.parent.fullName === "img" || e3.parent.fullName === "source"))
          return s3(yM2(i3()));
        if (e3.fullName === "class" && !n3.parentParser) {
          const e4 = i3();
          if (!e4.includes("{{"))
            return DM2(e4);
        }
        if (e3.fullName === "style" && !n3.parentParser) {
          const e4 = i3();
          if (!e4.includes("{{"))
            return s3(c3(e4, { parser: "css", __isHTMLStyleAttribute: true }));
        }
        if (n3.parser === "vue") {
          if (e3.fullName === "v-for")
            return EM2(i3(), c3);
          if (TM2(e3) || BM2(e3, n3))
            return CM2(i3(), c3);
          const t4 = ["^:", "^v-bind:"], u4 = ["^v-"];
          if (r3(["^@", "^v-on:"])) {
            const e4 = i3();
            return a3(c3(e4, { parser: bM2(e4) ? "__js_expression" : "__vue_event_binding" }));
          }
          if (r3(t4))
            return a3(c3(i3(), { parser: "__vue_expression" }));
          if (r3(u4))
            return a3(c3(i3(), { parser: "__js_expression" }));
        }
        if (n3.parser === "angular") {
          const t4 = (e4, t5) => c3(e4, Object.assign(Object.assign({}, t5), {}, { trailingComma: "none" })), n4 = ["^\\*"], u4 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], o4 = ["^i18n(-.+)?$"];
          if (r3(["^\\(.+\\)$", "^on-"]))
            return a3(t4(i3(), { parser: "__ng_action" }));
          if (r3(u4))
            return a3(t4(i3(), { parser: "__ng_binding" }));
          if (r3(o4)) {
            const t5 = i3().trim();
            return s3(aM2(NM2(e3, t5)), !t5.includes("@@"));
          }
          if (r3(n4))
            return a3(t4(i3(), { parser: "__ng_directive" }));
          const l3 = /{{(.+?)}}/s, p3 = i3();
          if (l3.test(p3)) {
            const e4 = [];
            for (const [n5, r4] of p3.split(l3).entries())
              if (n5 % 2 == 0)
                e4.push(pM2(r4));
              else
                try {
                  e4.push(iM2(["{{", oM2([sM2, t4(r4, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), sM2, "}}"]));
                } catch (e5) {
                  e4.push("{{", pM2(r4), "}}");
                }
            return iM2(e4);
          }
        }
        return null;
      }
      var PM2 = function(e3, t3, n3, r3) {
        const i3 = e3.getValue();
        switch (i3.type) {
          case "element":
            if (AM2(i3) || i3.type === "interpolation")
              return;
            if (!i3.isSelfClosing && vM2(i3, r3)) {
              const u3 = FM2(i3, r3);
              if (!u3)
                return;
              const o3 = nM2(i3, r3);
              let s3 = /^\s*$/.test(o3), a3 = "";
              return s3 || (a3 = n3(xM2(o3), { parser: u3, __embeddedInHtml: true }, { stripTrailingHardline: true }), s3 = a3 === ""), [gM2(i3, r3), iM2(mM2(e3, r3, t3)), s3 ? "" : uM2, a3, s3 ? "" : uM2, fM2(i3, r3), dM2(i3, r3)];
            }
            break;
          case "text":
            if (AM2(i3.parent)) {
              const e4 = FM2(i3.parent);
              if (e4) {
                const t4 = e4 === "markdown" ? SM2(i3.value.replace(/^[^\S\n]*?\n/, "")) : i3.value, u3 = { parser: e4, __embeddedInHtml: true };
                if (r3.parser === "html" && e4 === "babel") {
                  let e5 = "script";
                  const { attrMap: t5 } = i3.parent;
                  t5 && (t5.type === "module" || t5.type === "text/babel" && t5["data-type"] === "module") && (e5 = "module"), u3.__babelSourceType = e5;
                }
                return [rM2, gM2(i3, r3), n3(t4, u3, { stripTrailingHardline: true }), dM2(i3, r3)];
              }
            } else if (i3.parent.type === "interpolation") {
              const e4 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
              return r3.parser === "angular" ? (e4.parser = "__ng_interpolation", e4.trailingComma = "none") : r3.parser === "vue" ? e4.parser = "__vue_expression" : e4.parser = "__js_expression", [oM2([sM2, n3(i3.value, e4, { stripTrailingHardline: true })]), i3.parent.next && hM2(i3.parent.next) ? " " : sM2];
            }
            break;
          case "attribute": {
            if (!i3.value)
              break;
            if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r3.originalText.slice(i3.valueSpan.start.offset, i3.valueSpan.end.offset)))
              return [i3.rawName, "=", i3.value];
            if (r3.parser === "lwc") {
              if (/^{.*}$/s.test(r3.originalText.slice(i3.valueSpan.start.offset, i3.valueSpan.end.offset)))
                return [i3.rawName, "=", i3.value];
            }
            const e4 = kM2(i3, (e5, t4) => n3(e5, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, t4), { stripTrailingHardline: true }), r3);
            if (e4)
              return [i3.rawName, '="', iM2(lM2(e4, (e5) => typeof e5 == "string" ? e5.replace(/"/g, "&quot;") : e5)), '"'];
            break;
          }
          case "front-matter":
            return dN2(i3, n3);
        }
      };
      const { builders: { breakParent: OM2, group: IM2, ifBreak: LM2, line: jM2, softline: _M2, hardline: MM2 }, utils: { replaceTextEndOfLine: RM2 } } = su2, { locStart: $M2, locEnd: VM2 } = u_2, { forceBreakChildren: WM2, forceNextEmptyLine: qM2, isTextLikeNode: UM2, hasPrettierIgnore: zM2, preferHardlineAsLeadingSpaces: GM2 } = sj2, { printOpeningTagPrefix: HM2, needsToBorrowNextOpeningTagStartMarker: JM2, printOpeningTagStartMarker: XM2, needsToBorrowPrevClosingTagEndMarker: YM2, printClosingTagEndMarker: KM2, printClosingTagSuffix: QM2, needsToBorrowParentClosingTagStartMarker: ZM2 } = __2;
      function eR2(e3, t3, n3) {
        const r3 = e3.getValue();
        return zM2(r3) ? [HM2(r3, t3), ...RM2(t3.originalText.slice($M2(r3) + (r3.prev && JM2(r3.prev) ? XM2(r3).length : 0), VM2(r3) - (r3.next && YM2(r3.next) ? KM2(r3, t3).length : 0))), QM2(r3, t3)] : n3();
      }
      function tR2(e3, t3) {
        return UM2(e3) && UM2(t3) ? e3.isTrailingSpaceSensitive ? e3.hasTrailingSpaces ? GM2(t3) ? MM2 : jM2 : "" : GM2(t3) ? MM2 : _M2 : JM2(e3) && (zM2(t3) || t3.firstChild || t3.isSelfClosing || t3.type === "element" && t3.attrs.length > 0) || e3.type === "element" && e3.isSelfClosing && YM2(t3) ? "" : !t3.isLeadingSpaceSensitive || GM2(t3) || YM2(t3) && e3.lastChild && ZM2(e3.lastChild) && e3.lastChild.lastChild && ZM2(e3.lastChild.lastChild) ? MM2 : t3.hasLeadingSpaces ? jM2 : _M2;
      }
      var nR2 = { printChildren: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (WM2(r3))
          return [OM2, ...e3.map((e4) => {
            const r4 = e4.getValue(), i4 = r4.prev ? tR2(r4.prev, r4) : "";
            return [i4 ? [i4, qM2(r4.prev) ? MM2 : ""] : "", eR2(e4, t3, n3)];
          }, "children")];
        const i3 = r3.children.map(() => Symbol(""));
        return e3.map((e4, r4) => {
          const u3 = e4.getValue();
          if (UM2(u3)) {
            if (u3.prev && UM2(u3.prev)) {
              const r5 = tR2(u3.prev, u3);
              if (r5)
                return qM2(u3.prev) ? [MM2, MM2, eR2(e4, t3, n3)] : [r5, eR2(e4, t3, n3)];
            }
            return eR2(e4, t3, n3);
          }
          const o3 = [], s3 = [], a3 = [], c3 = [], l3 = u3.prev ? tR2(u3.prev, u3) : "", p3 = u3.next ? tR2(u3, u3.next) : "";
          return l3 && (qM2(u3.prev) ? o3.push(MM2, MM2) : l3 === MM2 ? o3.push(MM2) : UM2(u3.prev) ? s3.push(l3) : s3.push(LM2("", _M2, { groupId: i3[r4 - 1] }))), p3 && (qM2(u3) ? UM2(u3.next) && c3.push(MM2, MM2) : p3 === MM2 ? UM2(u3.next) && c3.push(MM2) : a3.push(p3)), [...o3, IM2([...s3, IM2([eR2(e4, t3, n3), ...a3], { id: i3[r4] })]), ...c3];
        }, "children");
      } };
      const { builders: { breakParent: rR2, dedentToRoot: iR2, group: uR2, ifBreak: oR2, indentIfBreak: sR2, indent: aR2, line: cR2, softline: lR2 }, utils: { replaceTextEndOfLine: pR2 } } = su2, { shouldPreserveContent: fR2, isScriptLikeTag: dR2, isVueCustomBlock: hR2, countParents: gR2, forceBreakContent: mR2 } = sj2, { printOpeningTagPrefix: yR2, printOpeningTag: DR2, printClosingTagSuffix: ER2, printClosingTag: CR2, needsToBorrowPrevClosingTagEndMarker: bR2, needsToBorrowLastChildClosingTagEndMarker: AR2 } = __2, { printChildren: vR2 } = nR2;
      var FR2 = { printElement: function(e3, t3, n3) {
        const r3 = e3.getValue();
        if (fR2(r3, t3))
          return [yR2(r3, t3), uR2(DR2(e3, t3, n3)), ...pR2(nM2(r3, t3)), ...CR2(r3, t3), ER2(r3, t3)];
        const i3 = r3.children.length === 1 && r3.firstChild.type === "interpolation" && r3.firstChild.isLeadingSpaceSensitive && !r3.firstChild.hasLeadingSpaces && r3.lastChild.isTrailingSpaceSensitive && !r3.lastChild.hasTrailingSpaces, u3 = Symbol("element-attr-group-id"), o3 = (i4) => uR2([uR2(DR2(e3, t3, n3), { id: u3 }), i4, CR2(r3, t3)]);
        return r3.children.length === 0 ? o3(r3.hasDanglingSpaces && r3.isDanglingSpaceSensitive ? cR2 : "") : o3([mR2(r3) ? rR2 : "", (s3 = [i3 ? oR2(lR2, "", { groupId: u3 }) : r3.firstChild.hasLeadingSpaces && r3.firstChild.isLeadingSpaceSensitive ? cR2 : r3.firstChild.type === "text" && r3.isWhitespaceSensitive && r3.isIndentationSensitive ? iR2(lR2) : lR2, vR2(e3, t3, n3)], i3 ? sR2(s3, { groupId: u3 }) : !dR2(r3) && !hR2(r3, t3) || r3.parent.type !== "root" || t3.parser !== "vue" || t3.vueIndentScriptAndStyle ? aR2(s3) : s3), (r3.next ? bR2(r3.next) : AR2(r3.parent)) ? r3.lastChild.hasTrailingSpaces && r3.lastChild.isTrailingSpaceSensitive ? " " : "" : i3 ? oR2(lR2, "", { groupId: u3 }) : r3.lastChild.hasTrailingSpaces && r3.lastChild.isTrailingSpaceSensitive ? cR2 : (r3.lastChild.type === "comment" || r3.lastChild.type === "text" && r3.isWhitespaceSensitive && r3.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t3.tabWidth * gR2(e3, (e4) => e4.parent && e4.parent.type !== "root")}}$`).test(r3.lastChild.value) ? "" : lR2]);
        var s3;
      } };
      const { builders: { fill: xR2, group: SR2, hardline: wR2, literalline: TR2 }, utils: { cleanDoc: BR2, getDocParts: NR2, isConcat: kR2, replaceTextEndOfLine: PR2 } } = su2, { countChars: OR2, unescapeQuoteEntities: IR2, getTextValueParts: LR2 } = sj2, { insertPragma: jR2 } = i_2, { locStart: _R2, locEnd: MR2 } = u_2, { printClosingTagSuffix: RR2, printClosingTagEnd: $R2, printOpeningTagPrefix: VR2, printOpeningTagStart: WR2 } = __2, { printElement: qR2 } = FR2, { printChildren: UR2 } = nR2;
      var zR2 = { preprocess: r_2, print: function(e3, t3, n3) {
        const r3 = e3.getValue();
        switch (r3.type) {
          case "front-matter":
            return PR2(r3.raw);
          case "root":
            return t3.__onHtmlRoot && t3.__onHtmlRoot(r3), [SR2(UR2(e3, t3, n3)), wR2];
          case "element":
          case "ieConditionalComment":
            return qR2(e3, t3, n3);
          case "ieConditionalStartComment":
          case "ieConditionalEndComment":
            return [WR2(r3), $R2(r3)];
          case "interpolation":
            return [WR2(r3, t3), ...e3.map(n3, "children"), $R2(r3, t3)];
          case "text": {
            if (r3.parent.type === "interpolation") {
              const e5 = /\n[^\S\n]*?$/, t4 = e5.test(r3.value), n4 = t4 ? r3.value.replace(e5, "") : r3.value;
              return [...PR2(n4), t4 ? wR2 : ""];
            }
            const e4 = BR2([VR2(r3, t3), ...LR2(r3), RR2(r3, t3)]);
            return kR2(e4) || e4.type === "fill" ? xR2(NR2(e4)) : e4;
          }
          case "docType":
            return [SR2([WR2(r3, t3), " ", r3.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), $R2(r3, t3)];
          case "comment":
            return [VR2(r3, t3), ...PR2(t3.originalText.slice(_R2(r3), MR2(r3)), TR2), RR2(r3, t3)];
          case "attribute": {
            if (r3.value === null)
              return r3.rawName;
            const e4 = IR2(r3.value), t4 = OR2(e4, "'") < OR2(e4, '"') ? "'" : '"';
            return [r3.rawName, "=", t4, ...PR2(t4 === '"' ? e4.replace(/"/g, "&quot;") : e4.replace(/'/g, "&apos;")), t4];
          }
          default:
            throw new Error(`Unexpected node type ${r3.type}`);
        }
      }, insertPragma: jR2, massageAstNode: vL2, embed: PM2 };
      const GR2 = "HTML";
      var HR2 = { bracketSameLine: KB2.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: GR2, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, vueIndentScriptAndStyle: { since: "1.19.0", category: GR2, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } }, JR2 = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 }, XR2 = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
      var YR2 = { languages: [rh2(JR2, () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), rh2(JR2, (e3) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e3.extensions, ".mjml"] })), rh2(JR2, () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), rh2(XR2, () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], printers: { html: zR2 }, options: HR2, parsers: void 0 };
      var KR2 = { isPragma: function(e3) {
        return /^\s*@(?:prettier|format)\s*$/.test(e3);
      }, hasPragma: function(e3) {
        return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e3);
      }, insertPragma: function(e3) {
        return `# @format

${e3}`;
      } };
      var QR2 = { locStart: function(e3) {
        return e3.position.start.offset;
      }, locEnd: function(e3) {
        return e3.position.end.offset;
      } };
      var ZR2 = function(e3, t3, n3, r3) {
        if (e3.getValue().type === "root" && r3.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r3.filepath))
          return n3(r3.originalText, Object.assign(Object.assign({}, r3), {}, { parser: "json" }));
      };
      const { getLast: e$4, isNonEmptyArray: t$4 } = Fi2;
      function n$4(e3, t3) {
        return e3 && typeof e3.type == "string" && (!t3 || t3.includes(e3.type));
      }
      function r$4(e3) {
        return e3.value.trim() === "prettier-ignore";
      }
      function i$5(e3) {
        return e3 && t$4(e3.leadingComments);
      }
      function u$4(e3) {
        return e3 && t$4(e3.middleComments);
      }
      function o$4(e3) {
        return e3 && e3.indicatorComment;
      }
      function s$4(e3) {
        return e3 && e3.trailingComment;
      }
      function a$4(e3) {
        return e3 && t$4(e3.endComments);
      }
      function c$4(e3) {
        const t3 = [];
        let n3;
        for (const r3 of e3.split(/( +)/))
          r3 !== " " ? n3 === " " ? t3.push(r3) : t3.push((t3.pop() || "") + r3) : n3 === void 0 && t3.unshift(""), n3 = r3;
        return n3 === " " && t3.push((t3.pop() || "") + " "), t3[0] === "" && (t3.shift(), t3.unshift(" " + (t3.shift() || ""))), t3;
      }
      var l$4 = { getLast: e$4, getAncestorCount: function(e3, t3) {
        let n3 = 0;
        const r3 = e3.stack.length - 1;
        for (let i3 = 0; i3 < r3; i3++) {
          const r4 = e3.stack[i3];
          n$4(r4) && t3(r4) && n3++;
        }
        return n3;
      }, isNode: n$4, isEmptyNode: function(e3) {
        return !t$4(e3.children) && !function(e4) {
          return i$5(e4) || u$4(e4) || o$4(e4) || s$4(e4) || a$4(e4);
        }(e3);
      }, isInlineNode: function(e3) {
        if (!e3)
          return true;
        switch (e3.type) {
          case "plain":
          case "quoteDouble":
          case "quoteSingle":
          case "alias":
          case "flowMapping":
          case "flowSequence":
            return true;
          default:
            return false;
        }
      }, mapNode: function e3(t3, n3, r3) {
        return n3("children" in t3 ? Object.assign(Object.assign({}, t3), {}, { children: t3.children.map((r4) => e3(r4, n3, t3)) }) : t3, r3);
      }, defineShortcut: function(e3, t3, n3) {
        Object.defineProperty(e3, t3, { get: n3, enumerable: false });
      }, isNextLineEmpty: function(e3, t3) {
        let n3 = 0;
        const r3 = t3.length;
        for (let i3 = e3.position.end.offset - 1; i3 < r3; i3++) {
          const e4 = t3[i3];
          if (e4 === "\n" && n3++, n3 === 1 && /\S/.test(e4))
            return false;
          if (n3 === 2)
            return true;
        }
        return false;
      }, isLastDescendantNode: function(e3) {
        switch (e3.getValue().type) {
          case "tag":
          case "anchor":
          case "comment":
            return false;
        }
        const t3 = e3.stack.length;
        for (let n3 = 1; n3 < t3; n3++) {
          const t4 = e3.stack[n3], r3 = e3.stack[n3 - 1];
          if (Array.isArray(r3) && typeof t4 == "number" && t4 !== r3.length - 1)
            return false;
        }
        return true;
      }, getBlockValueLineContents: function(e3, { parentIndent: t3, isLastDescendant: n3, options: r3 }) {
        const i3 = e3.position.start.line === e3.position.end.line ? "" : r3.originalText.slice(e3.position.start.offset, e3.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u3 = e3.indent === null ? ((e4) => e4 ? e4[1].length : Number.POSITIVE_INFINITY)(i3.match(/^( *)\S/m)) : e3.indent - 1 + t3, o3 = i3.split("\n").map((e4) => e4.slice(u3));
        return r3.proseWrap === "preserve" || e3.type === "blockLiteral" ? s3(o3.map((e4) => e4.length === 0 ? [] : [e4])) : s3(o3.map((e4) => e4.length === 0 ? [] : c$4(e4)).reduce((e4, t4, n4) => n4 !== 0 && o3[n4 - 1].length > 0 && t4.length > 0 && !/^\s/.test(t4[0]) && !/^\s|\s$/.test(e$4(e4)) ? [...e4.slice(0, -1), [...e$4(e4), ...t4]] : [...e4, t4], []).map((e4) => e4.reduce((e5, t4) => e5.length > 0 && /\s$/.test(e$4(e5)) ? [...e5.slice(0, -1), e$4(e5) + " " + t4] : [...e5, t4], [])).map((e4) => r3.proseWrap === "never" ? [e4.join(" ")] : e4));
        function s3(t4) {
          if (e3.chomping === "keep")
            return e$4(t4).length === 0 ? t4.slice(0, -1) : t4;
          let r4 = 0;
          for (let e4 = t4.length - 1; e4 >= 0 && t4[e4].length === 0; e4--)
            r4++;
          return r4 === 0 ? t4 : r4 >= 2 && !n3 ? t4.slice(0, -(r4 - 1)) : t4.slice(0, -r4);
        }
      }, getFlowScalarLineContents: function(e3, t3, n3) {
        const r3 = t3.split("\n").map((e4, t4, n4) => t4 === 0 && t4 === n4.length - 1 ? e4 : t4 !== 0 && t4 !== n4.length - 1 ? e4.trim() : t4 === 0 ? e4.trimEnd() : e4.trimStart());
        return n3.proseWrap === "preserve" ? r3.map((e4) => e4.length === 0 ? [] : [e4]) : r3.map((e4) => e4.length === 0 ? [] : c$4(e4)).reduce((t4, n4, i3) => i3 !== 0 && r3[i3 - 1].length > 0 && n4.length > 0 && (e3 !== "quoteDouble" || !e$4(e$4(t4)).endsWith("\\")) ? [...t4.slice(0, -1), [...e$4(t4), ...n4]] : [...t4, n4], []).map((e4) => n3.proseWrap === "never" ? [e4.join(" ")] : e4);
      }, getLastDescendantNode: function e3(t3) {
        return t$4(t3.children) ? e3(e$4(t3.children)) : t3;
      }, hasPrettierIgnore: function(e3) {
        const t3 = e3.getValue();
        if (t3.type === "documentBody") {
          const t4 = e3.getParentNode();
          return a$4(t4.head) && r$4(e$4(t4.head.endComments));
        }
        return i$5(t3) && r$4(e$4(t3.leadingComments));
      }, hasLeadingComments: i$5, hasMiddleComments: u$4, hasIndicatorComment: o$4, hasTrailingComment: s$4, hasEndComments: a$4 };
      const { defineShortcut: p$4, mapNode: f$4 } = l$4;
      function d$5(e3) {
        switch (e3.type) {
          case "document":
            p$4(e3, "head", () => e3.children[0]), p$4(e3, "body", () => e3.children[1]);
            break;
          case "documentBody":
          case "sequenceItem":
          case "flowSequenceItem":
          case "mappingKey":
          case "mappingValue":
            p$4(e3, "content", () => e3.children[0]);
            break;
          case "mappingItem":
          case "flowMappingItem":
            p$4(e3, "key", () => e3.children[0]), p$4(e3, "value", () => e3.children[1]);
        }
        return e3;
      }
      var h$4 = function(e3) {
        return f$4(e3, d$5);
      };
      const { builders: { softline: g$4, align: m$4 } } = su2, { hasEndComments: y$4, isNextLineEmpty: D$4, isNode: E$4 } = l$4, C$4 = new WeakMap();
      function b$4(e3) {
        return y$4(e3) && !E$4(e3, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
      }
      var A$4 = { alignWithSpaces: function(e3, t3) {
        return m$4(" ".repeat(e3), t3);
      }, shouldPrintEndComments: b$4, printNextEmptyLine: function(e3, t3) {
        const n3 = e3.getValue(), r3 = e3.stack[0];
        let i3;
        return C$4.has(r3) ? i3 = C$4.get(r3) : (i3 = new Set(), C$4.set(r3, i3)), i3.has(n3.position.end.line) || (i3.add(n3.position.end.line), !D$4(n3, t3) || b$4(e3.getParentNode())) ? "" : g$4;
      } };
      const { builders: { ifBreak: v$4, line: F$4, softline: x$4, hardline: S$4, join: w$4 } } = su2, { isEmptyNode: T$4, getLast: B$4, hasEndComments: N$4 } = l$4, { printNextEmptyLine: k$4, alignWithSpaces: P$4 } = A$4;
      function O$4(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = r3.type === "flowMapping", u3 = i3 ? "{" : "[", o3 = i3 ? "}" : "]";
        let s3 = x$4;
        i3 && r3.children.length > 0 && n3.bracketSpacing && (s3 = F$4);
        const a3 = B$4(r3.children), c3 = a3 && a3.type === "flowMappingItem" && T$4(a3.key) && T$4(a3.value);
        return [u3, P$4(n3.tabWidth, [s3, I$4(e3, t3, n3), n3.trailingComma === "none" ? "" : v$4(","), N$4(r3) ? [S$4, w$4(S$4, e3.map(t3, "endComments"))] : ""]), c3 ? "" : s3, o3];
      }
      function I$4(e3, t3, n3) {
        const r3 = e3.getValue();
        return e3.map((e4, i3) => [t3(), i3 === r3.children.length - 1 ? "" : [",", F$4, r3.children[i3].position.start.line !== r3.children[i3 + 1].position.start.line ? k$4(e4, n3.originalText) : ""]], "children");
      }
      var L$4 = { printFlowMapping: O$4, printFlowSequence: O$4 };
      const { builders: { conditionalGroup: j$5, group: _$4, hardline: M$4, ifBreak: R$4, join: $$4, line: V$4 } } = su2, { hasLeadingComments: W$4, hasMiddleComments: q$4, hasTrailingComment: U$4, hasEndComments: z$4, isNode: G$4, isEmptyNode: H$4, isInlineNode: J$4 } = l$4, { alignWithSpaces: X$4 } = A$4;
      function Y$4(e3, t3) {
        if (!e3)
          return true;
        switch (e3.type) {
          case "plain":
          case "quoteSingle":
          case "quoteDouble":
            break;
          case "alias":
            return true;
          default:
            return false;
        }
        if (t3.proseWrap === "preserve")
          return e3.position.start.line === e3.position.end.line;
        if (/\\$/m.test(t3.originalText.slice(e3.position.start.offset, e3.position.end.offset)))
          return false;
        switch (t3.proseWrap) {
          case "never":
            return !e3.value.includes("\n");
          case "always":
            return !/[\n ]/.test(e3.value);
          default:
            return false;
        }
      }
      var K$4 = function(e3, t3, n3, r3, i3) {
        const { key: u3, value: o3 } = e3, s3 = H$4(u3), a3 = H$4(o3);
        if (s3 && a3)
          return ": ";
        const c3 = r3("key"), l3 = function(e4) {
          return e4.key.content && e4.key.content.type === "alias";
        }(e3) ? " " : "";
        if (a3)
          return e3.type === "flowMappingItem" && t3.type === "flowMapping" ? c3 : e3.type !== "mappingItem" || !Y$4(u3.content, i3) || U$4(u3.content) || t3.tag && t3.tag.value === "tag:yaml.org,2002:set" ? ["? ", X$4(2, c3)] : [c3, l3, ":"];
        const p3 = r3("value");
        if (s3)
          return [": ", X$4(2, p3)];
        if (W$4(o3) || !J$4(u3.content))
          return ["? ", X$4(2, c3), M$4, $$4("", n3.map(r3, "value", "leadingComments").map((e4) => [e4, M$4])), ": ", X$4(2, p3)];
        if (function(e4) {
          if (!e4)
            return true;
          switch (e4.type) {
            case "plain":
            case "quoteDouble":
            case "quoteSingle":
              return e4.position.start.line === e4.position.end.line;
            case "alias":
              return true;
            default:
              return false;
          }
        }(u3.content) && !W$4(u3.content) && !q$4(u3.content) && !U$4(u3.content) && !z$4(u3) && !W$4(o3.content) && !q$4(o3.content) && !z$4(o3) && Y$4(o3.content, i3))
          return [c3, l3, ": ", p3];
        const f3 = Symbol("mappingKey"), d3 = _$4([R$4("? "), _$4(X$4(2, c3), { id: f3 })]), h3 = [M$4, ": ", X$4(2, p3)], g3 = [l3, ":"];
        W$4(o3.content) || z$4(o3) && o3.content && !G$4(o3.content, ["mapping", "sequence"]) || t3.type === "mapping" && U$4(u3.content) && J$4(o3.content) || G$4(o3.content, ["mapping", "sequence"]) && o3.content.tag === null && o3.content.anchor === null ? g3.push(M$4) : o3.content && g3.push(V$4), g3.push(p3);
        const m3 = X$4(i3.tabWidth, g3);
        return !Y$4(u3.content, i3) || W$4(u3.content) || q$4(u3.content) || z$4(u3) ? j$5([[d3, R$4(h3, m3, { groupId: f3 })]]) : j$5([[c3, m3]]);
      };
      const { builders: { dedent: Q$4, dedentToRoot: Z$4, fill: eV2, hardline: tV2, join: nV2, line: rV2, literalline: iV2, markAsRoot: uV2 }, utils: { getDocParts: oV2 } } = su2, { getAncestorCount: sV2, getBlockValueLineContents: aV2, hasIndicatorComment: cV2, isLastDescendantNode: lV2, isNode: pV2 } = l$4, { alignWithSpaces: fV2 } = A$4;
      var dV2 = function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = sV2(e3, (e4) => pV2(e4, ["sequence", "mapping"])), u3 = lV2(e3), o3 = [r3.type === "blockFolded" ? ">" : "|"];
        r3.indent !== null && o3.push(r3.indent.toString()), r3.chomping !== "clip" && o3.push(r3.chomping === "keep" ? "+" : "-"), cV2(r3) && o3.push(" ", t3("indicatorComment"));
        const s3 = aV2(r3, { parentIndent: i3, isLastDescendant: u3, options: n3 }), a3 = [];
        for (const [e4, t4] of s3.entries())
          e4 === 0 && a3.push(tV2), a3.push(eV2(oV2(nV2(rV2, t4)))), e4 !== s3.length - 1 ? a3.push(t4.length === 0 ? tV2 : uV2(iV2)) : r3.chomping === "keep" && u3 && a3.push(Z$4(t4.length === 0 ? tV2 : iV2));
        return r3.indent === null ? o3.push(Q$4(fV2(n3.tabWidth, a3))) : o3.push(Z$4(fV2(r3.indent - 1 + i3, a3))), o3;
      };
      const { builders: { breakParent: hV2, fill: gV2, group: mV2, hardline: yV2, join: DV2, line: EV2, lineSuffix: CV2, literalline: bV2 }, utils: { getDocParts: AV2, replaceTextEndOfLine: vV2 } } = su2, { isPreviousLineEmpty: FV2 } = Fi2, { insertPragma: xV2, isPragma: SV2 } = KR2, { locStart: wV2 } = QR2, { getFlowScalarLineContents: TV2, getLastDescendantNode: BV2, hasLeadingComments: NV2, hasMiddleComments: kV2, hasTrailingComment: PV2, hasEndComments: OV2, hasPrettierIgnore: IV2, isLastDescendantNode: LV2, isNode: jV2, isInlineNode: _V2 } = l$4, { alignWithSpaces: MV2, printNextEmptyLine: RV2, shouldPrintEndComments: $V2 } = A$4, { printFlowMapping: VV2, printFlowSequence: WV } = L$4;
      function qV(e3, t3) {
        return PV2(e3) || t3 && (t3.head.children.length > 0 || OV2(t3.head));
      }
      function UV(e3, t3, n3) {
        const r3 = TV2(e3, t3, n3);
        return DV2(yV2, r3.map((e4) => gV2(AV2(DV2(EV2, e4)))));
      }
      var zV = { preprocess: h$4, embed: ZR2, print: function(e3, t3, n3) {
        const r3 = e3.getValue(), i3 = [];
        r3.type !== "mappingValue" && NV2(r3) && i3.push([DV2(yV2, e3.map(n3, "leadingComments")), yV2]);
        const { tag: u3, anchor: o3 } = r3;
        u3 && i3.push(n3("tag")), u3 && o3 && i3.push(" "), o3 && i3.push(n3("anchor"));
        let s3 = "";
        jV2(r3, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !LV2(e3) && (s3 = RV2(e3, t3.originalText)), (u3 || o3) && (jV2(r3, ["sequence", "mapping"]) && !kV2(r3) ? i3.push(yV2) : i3.push(" ")), kV2(r3) && i3.push([r3.middleComments.length === 1 ? "" : yV2, DV2(yV2, e3.map(n3, "middleComments")), yV2]);
        const a3 = e3.getParentNode();
        return IV2(e3) ? i3.push(vV2(t3.originalText.slice(r3.position.start.offset, r3.position.end.offset).trimEnd(), bV2)) : i3.push(mV2(function(e4, t4, n4, r4, i4) {
          switch (e4.type) {
            case "root": {
              const { children: t5 } = e4, r5 = [];
              n4.each((e5, n5) => {
                const u5 = t5[n5], o4 = t5[n5 + 1];
                n5 !== 0 && r5.push(yV2), r5.push(i4()), qV(u5, o4) ? (r5.push(yV2, "..."), PV2(u5) && r5.push(" ", i4("trailingComment"))) : o4 && !PV2(o4.head) && r5.push(yV2, "---");
              }, "children");
              const u4 = BV2(e4);
              return jV2(u4, ["blockLiteral", "blockFolded"]) && u4.chomping === "keep" || r5.push(yV2), r5;
            }
            case "document": {
              const u4 = [];
              return function(e5, t5, n5, r5) {
                if (n5.children[0] === e5 && /---(?:\s|$)/.test(r5.originalText.slice(wV2(e5), wV2(e5) + 4)) || e5.head.children.length > 0 || OV2(e5.head) || PV2(e5.head))
                  return "head";
                if (qV(e5, t5))
                  return false;
                return !!t5 && "root";
              }(e4, t4.children[n4.getName() + 1], t4, r4) === "head" && ((e4.head.children.length > 0 || e4.head.endComments.length > 0) && u4.push(i4("head")), PV2(e4.head) ? u4.push(["---", " ", i4(["head", "trailingComment"])]) : u4.push("---")), function(e5) {
                return e5.body.children.length > 0 || OV2(e5.body);
              }(e4) && u4.push(i4("body")), DV2(yV2, u4);
            }
            case "documentHead":
              return DV2(yV2, [...n4.map(i4, "children"), ...n4.map(i4, "endComments")]);
            case "documentBody": {
              const { children: t5, endComments: r5 } = e4;
              let u4 = "";
              if (t5.length > 0 && r5.length > 0) {
                const t6 = BV2(e4);
                jV2(t6, ["blockFolded", "blockLiteral"]) ? t6.chomping !== "keep" && (u4 = [yV2, yV2]) : u4 = yV2;
              }
              return [DV2(yV2, n4.map(i4, "children")), u4, DV2(yV2, n4.map(i4, "endComments"))];
            }
            case "directive":
              return ["%", DV2(" ", [e4.name, ...e4.parameters])];
            case "comment":
              return ["#", e4.value];
            case "alias":
              return ["*", e4.value];
            case "tag":
              return r4.originalText.slice(e4.position.start.offset, e4.position.end.offset);
            case "anchor":
              return ["&", e4.value];
            case "plain":
              return UV(e4.type, r4.originalText.slice(e4.position.start.offset, e4.position.end.offset), r4);
            case "quoteDouble":
            case "quoteSingle": {
              const t5 = "'", n5 = '"', i5 = r4.originalText.slice(e4.position.start.offset + 1, e4.position.end.offset - 1);
              if (e4.type === "quoteSingle" && i5.includes("\\") || e4.type === "quoteDouble" && /\\[^"]/.test(i5)) {
                const u5 = e4.type === "quoteDouble" ? n5 : t5;
                return [u5, UV(e4.type, i5, r4), u5];
              }
              if (i5.includes(n5))
                return [t5, UV(e4.type, e4.type === "quoteDouble" ? i5.replace(/\\"/g, n5).replace(/'/g, t5.repeat(2)) : i5, r4), t5];
              if (i5.includes(t5))
                return [n5, UV(e4.type, e4.type === "quoteSingle" ? i5.replace(/''/g, t5) : i5, r4), n5];
              const u4 = r4.singleQuote ? t5 : n5;
              return [u4, UV(e4.type, i5, r4), u4];
            }
            case "blockFolded":
            case "blockLiteral":
              return dV2(n4, i4, r4);
            case "mapping":
            case "sequence":
              return DV2(yV2, n4.map(i4, "children"));
            case "sequenceItem":
              return ["- ", MV2(2, e4.content ? i4("content") : "")];
            case "mappingKey":
            case "mappingValue":
              return e4.content ? i4("content") : "";
            case "mappingItem":
            case "flowMappingItem":
              return K$4(e4, t4, n4, i4, r4);
            case "flowMapping":
              return VV2(n4, i4, r4);
            case "flowSequence":
              return WV(n4, i4, r4);
            case "flowSequenceItem":
              return i4("content");
            default:
              throw new Error(`Unexpected node type ${e4.type}`);
          }
        }(r3, a3, e3, t3, n3))), PV2(r3) && !jV2(r3, ["document", "documentHead"]) && i3.push(CV2([r3.type !== "mappingValue" || r3.content ? " " : "", a3.type === "mappingKey" && e3.getParentNode(2).type === "mapping" && _V2(r3) ? "" : hV2, n3("trailingComment")])), $V2(r3) && i3.push(MV2(r3.type === "sequenceItem" ? 2 : 0, [yV2, DV2(yV2, e3.map((e4) => [FV2(t3.originalText, e4.getValue(), wV2) ? yV2 : "", n3()], "endComments"))])), i3.push(s3), i3;
      }, massageAstNode: function(e3, t3) {
        if (jV2(t3))
          switch (delete t3.position, t3.type) {
            case "comment":
              if (SV2(t3.value))
                return null;
              break;
            case "quoteDouble":
            case "quoteSingle":
              t3.type = "quote";
          }
      }, insertPragma: xV2 }, GV = { bracketSpacing: KB2.bracketSpacing, singleQuote: KB2.singleQuote, proseWrap: KB2.proseWrap };
      var HV = [oN2, fP2, AO2, qO2, EL2, YR2, { languages: [rh2({ name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 }, (e3) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e3.filenames.filter((e4) => e4 !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))], printers: { yaml: zV }, options: GV, parsers: void 0 }];
      const { version: JV } = e2, { getSupportInfo: XV } = ui2;
      function YV(e3, t3 = 1) {
        return (...n3) => {
          const r3 = n3[t3] || {}, i3 = r3.plugins || [];
          return n3[t3] = Object.assign(Object.assign({}, r3), {}, { plugins: [...HV, ...Array.isArray(i3) ? i3 : Object.values(i3)] }), e3(...n3);
        };
      }
      const KV = YV(kd2.formatWithCursor);
      return { formatWithCursor: KV, format: (e3, t3) => KV(e3, t3).formatted, check(e3, t3) {
        const { formatted: n3 } = KV(e3, t3);
        return n3 === e3;
      }, doc: su2, getSupportInfo: YV(XV, 0), version: JV, util: th2, __debug: { parse: YV(kd2.parse), formatAST: YV(kd2.formatAST), formatDoc: YV(kd2.formatDoc), printToDoc: YV(kd2.printToDoc), printDocToString: YV(kd2.printDocToString) } };
    });
  })(standalone);
  (function(module, exports) {
    !function(t2, e2) {
      e2(exports, standalone.exports);
    }(commonjsGlobal, function(t2, e2) {
      function i2(t3) {
        return t3 && typeof t3 == "object" && "default" in t3 ? t3 : { default: t3 };
      }
      var n2 = i2(e2), s2 = { matchST_ATTRIBUTE: function() {
        var t3 = 0, e3 = this.input();
        if (this.is_WHITESPACE()) {
          do {
            e3 = this.input();
          } while (this.is_WHITESPACE());
          return this.unput(1), null;
        }
        switch (e3) {
          case "]":
            return t3 === 0 ? this.popState() : t3--, "]";
          case "(":
          case ")":
          case ":":
          case "=":
            return this.consume_TOKEN();
          case "[":
            return t3++, "[";
          case ",":
            return ",";
          case '"':
            return this.ST_DOUBLE_QUOTES();
          case "'":
            return this.T_CONSTANT_ENCAPSED_STRING();
          case "/":
            if (this._input[this.offset] === "/")
              return this.T_COMMENT();
            if (this._input[this.offset] === "*")
              return this.input(), this.T_DOC_COMMENT();
        }
        if (this.is_LABEL_START() || e3 === "\\") {
          for (; this.offset < this.size; ) {
            var i3 = this.input();
            if (!this.is_LABEL() && i3 !== "\\") {
              i3 && this.unput(1);
              break;
            }
          }
          return this.tok.T_STRING;
        }
        if (this.is_NUM())
          return this.consume_NUM();
        throw new Error('Bad terminal sequence "'.concat(e3, '" at line ').concat(this.yylineno, " (offset ").concat(this.offset, ")"));
      } };
      s2.matchST_ATTRIBUTE;
      var r2 = { T_COMMENT: function() {
        for (; this.offset < this.size; ) {
          var t3 = this.input();
          if (t3 === "\n" || t3 === "\r")
            return this.tok.T_COMMENT;
          if (t3 === "?" && !this.aspTagMode && this._input[this.offset] === ">")
            return this.unput(1), this.tok.T_COMMENT;
          if (t3 === "%" && this.aspTagMode && this._input[this.offset] === ">")
            return this.unput(1), this.tok.T_COMMENT;
        }
        return this.tok.T_COMMENT;
      }, T_DOC_COMMENT: function() {
        var t3 = this.input(), e3 = this.tok.T_COMMENT;
        if (t3 === "*") {
          if (t3 = this.input(), this.is_WHITESPACE() && (e3 = this.tok.T_DOC_COMMENT), t3 === "/")
            return e3;
          this.unput(1);
        }
        for (; this.offset < this.size; )
          if ((t3 = this.input()) === "*" && this._input[this.offset] === "/") {
            this.input();
            break;
          }
        return e3;
      } };
      r2.T_COMMENT, r2.T_DOC_COMMENT;
      var o2 = { nextINITIAL: function() {
        return this.conditionStack.length > 1 && this.conditionStack[this.conditionStack.length - 1] === "INITIAL" ? this.popState() : this.begin("ST_IN_SCRIPTING"), this;
      }, matchINITIAL: function() {
        for (; this.offset < this.size; ) {
          var t3 = this.input();
          if (t3 == "<") {
            if ((t3 = this.ahead(1)) == "?") {
              if (this.tryMatch("?=")) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
                break;
              }
              if (this.tryMatchCaseless("?php") && ((t3 = this._input[this.offset + 4]) === " " || t3 === "	" || t3 === "\n" || t3 === "\r")) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();
                break;
              }
              if (this.short_tags) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
                break;
              }
            } else if (this.asp_tags && t3 == "%") {
              if (this.tryMatch("%=")) {
                this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
                break;
              }
              this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
              break;
            }
          }
        }
        return this.yytext.length > 0 && this.tok.T_INLINE_HTML;
      } };
      o2.nextINITIAL, o2.matchINITIAL;
      var a2 = { consume_NUM: function() {
        var t3 = this.yytext[0], e3 = t3 === ".";
        if (t3 === "0")
          if ((t3 = this.input()) === "x" || t3 === "X") {
            if ((t3 = this.input()) !== "_" && this.is_HEX())
              return this.consume_HNUM();
            this.unput(t3 ? 2 : 1);
          } else if (t3 === "b" || t3 === "B") {
            if ((t3 = this.input()) !== "_" && t3 === "0" || t3 === "1")
              return this.consume_BNUM();
            this.unput(t3 ? 2 : 1);
          } else
            this.is_NUM() || t3 && this.unput(1);
        for (; this.offset < this.size; ) {
          var i3 = t3;
          if ((t3 = this.input()) === "_") {
            if (i3 === "_") {
              this.unput(2);
              break;
            }
            if (i3 === ".") {
              this.unput(1);
              break;
            }
            if (i3 === "e" || i3 === "E") {
              this.unput(2);
              break;
            }
          } else {
            if (t3 === ".") {
              if (e3) {
                this.unput(1);
                break;
              }
              if (i3 === "_") {
                this.unput(2);
                break;
              }
              e3 = true;
              continue;
            }
            if (t3 === "e" || t3 === "E") {
              if (i3 === "_") {
                this.unput(1);
                break;
              }
              var n3 = 2;
              if ((t3 = this.input()) !== "+" && t3 !== "-" || (n3 = 3, t3 = this.input()), this.is_NUM_START())
                return this.consume_LNUM(), this.tok.T_DNUMBER;
              this.unput(t3 ? n3 : n3 - 1);
              break;
            }
          }
          if (!this.is_NUM()) {
            t3 && this.unput(1);
            break;
          }
        }
        return e3 ? this.tok.T_DNUMBER : this.yytext.length < 9 || this.yytext.length < 10 || this.yytext.length == 10 && this.yytext < "2147483648" ? this.tok.T_LNUMBER : this.tok.T_DNUMBER;
      }, consume_HNUM: function() {
        for (; this.offset < this.size; ) {
          var t3 = this.input();
          if (!this.is_HEX()) {
            t3 && this.unput(1);
            break;
          }
        }
        return this.tok.T_LNUMBER;
      }, consume_LNUM: function() {
        for (; this.offset < this.size; ) {
          var t3 = this.input();
          if (!this.is_NUM()) {
            t3 && this.unput(1);
            break;
          }
        }
        return this.tok.T_LNUMBER;
      }, consume_BNUM: function() {
        for (var t3; this.offset < this.size; )
          if ((t3 = this.input()) !== "0" && t3 !== "1" && t3 !== "_") {
            t3 && this.unput(1);
            break;
          }
        return this.tok.T_LNUMBER;
      } };
      a2.consume_NUM, a2.consume_HNUM, a2.consume_LNUM, a2.consume_BNUM;
      var h2 = { matchST_LOOKING_FOR_PROPERTY: function() {
        var t3 = this.input();
        if (t3 === "-") {
          if ((t3 = this.input()) === ">")
            return this.tok.T_OBJECT_OPERATOR;
          t3 && this.unput(1);
        } else {
          if (this.is_WHITESPACE())
            return this.tok.T_WHITESPACE;
          if (this.is_LABEL_START())
            return this.consume_LABEL(), this.popState(), this.tok.T_STRING;
        }
        return this.popState(), t3 && this.unput(1), false;
      }, matchST_LOOKING_FOR_VARNAME: function() {
        var t3 = this.input();
        if (this.popState(), this.begin("ST_IN_SCRIPTING"), this.is_LABEL_START()) {
          if (this.consume_LABEL(), (t3 = this.input()) === "[" || t3 === "}")
            return this.unput(1), this.tok.T_STRING_VARNAME;
          this.unput(this.yytext.length);
        } else
          t3 && this.unput(1);
        return false;
      }, matchST_VAR_OFFSET: function() {
        var t3 = this.input();
        if (this.is_NUM_START())
          return this.consume_NUM(), this.tok.T_NUM_STRING;
        if (t3 === "]")
          return this.popState(), "]";
        if (t3 === "$") {
          if (this.input(), this.is_LABEL_START())
            return this.consume_LABEL(), this.tok.T_VARIABLE;
          throw new Error("Unexpected terminal");
        }
        if (this.is_LABEL_START())
          return this.consume_LABEL(), this.tok.T_STRING;
        if (this.is_WHITESPACE() || t3 === "\\" || t3 === "'" || t3 === "#")
          return this.tok.T_ENCAPSED_AND_WHITESPACE;
        if (t3 === "[" || t3 === "{" || t3 === "}" || t3 === '"' || t3 === "`" || this.is_TOKEN())
          return t3;
        throw new Error("Unexpected terminal");
      } };
      h2.matchST_LOOKING_FOR_PROPERTY, h2.matchST_LOOKING_FOR_VARNAME, h2.matchST_VAR_OFFSET;
      var l2 = { matchST_IN_SCRIPTING: function() {
        var t3 = this.input();
        switch (t3) {
          case " ":
          case "	":
          case "\n":
          case "\r":
          case "\r\n":
            return this.T_WHITESPACE();
          case "#":
            return this._input[this.offset] === "[" ? (this.input(), this.begin("ST_ATTRIBUTE"), this.tok.T_ATTRIBUTE) : this.T_COMMENT();
          case "/":
            return this._input[this.offset] === "/" ? this.T_COMMENT() : this._input[this.offset] === "*" ? (this.input(), this.T_DOC_COMMENT()) : this.consume_TOKEN();
          case "'":
            return this.T_CONSTANT_ENCAPSED_STRING();
          case '"':
            return this.ST_DOUBLE_QUOTES();
          case "`":
            return this.begin("ST_BACKQUOTE"), "`";
          case "?":
            if (!this.aspTagMode && this.tryMatch(">")) {
              this.input();
              var e3 = this._input[this.offset];
              return e3 !== "\n" && e3 !== "\r" || this.input(), this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG;
            }
            return this.consume_TOKEN();
          case "%":
            return this.aspTagMode && this._input[this.offset] === ">" ? (this.input(), (t3 = this._input[this.offset]) !== "\n" && t3 !== "\r" || this.input(), this.aspTagMode = false, this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG) : this.consume_TOKEN();
          case "{":
            return this.begin("ST_IN_SCRIPTING"), "{";
          case "}":
            return this.conditionStack.length > 2 && this.popState(), "}";
          default:
            if (t3 === ".") {
              if (t3 = this.input(), this.is_NUM_START())
                return this.consume_NUM();
              t3 && this.unput(1);
            }
            if (this.is_NUM_START())
              return this.consume_NUM();
            if (this.is_LABEL_START())
              return this.consume_LABEL().T_STRING();
            if (this.is_TOKEN())
              return this.consume_TOKEN();
        }
        throw new Error('Bad terminal sequence "' + t3 + '" at line ' + this.yylineno + " (offset " + this.offset + ")");
      }, T_WHITESPACE: function() {
        for (; this.offset < this.size; ) {
          var t3 = this.input();
          if (t3 !== " " && t3 !== "	" && t3 !== "\n" && t3 !== "\r") {
            t3 && this.unput(1);
            break;
          }
        }
        return this.tok.T_WHITESPACE;
      } };
      l2.matchST_IN_SCRIPTING, l2.T_WHITESPACE;
      var c2 = ["\n", "\r"], u2 = ["\n", "\r", ";"], _2 = u2.concat(["	", " ", ",", "]", ")", "/", "=", "!"]), d2 = { T_CONSTANT_ENCAPSED_STRING: function() {
        for (var t3; this.offset < this.size; )
          if ((t3 = this.input()) == "\\")
            this.input();
          else if (t3 == "'")
            break;
        return this.tok.T_CONSTANT_ENCAPSED_STRING;
      }, is_HEREDOC: function() {
        var t3 = this.offset;
        if (this._input[this.offset - 1] === "<" && this._input[this.offset] === "<" && this._input[this.offset + 1] === "<") {
          if (this.offset += 3, this.is_TABSPACE())
            for (; this.offset < this.size && (this.offset++, this.is_TABSPACE()); )
              ;
          var e3 = this._input[this.offset - 1];
          if (e3 === "'" || e3 === '"' ? this.offset++ : e3 = null, this.is_LABEL_START()) {
            for (var i3 = this.offset - 1; this.offset < this.size && (this.offset++, this.is_LABEL()); )
              ;
            var n3 = this._input.substring(i3, this.offset - 1);
            if ((!e3 || e3 === this._input[this.offset - 1]) && (e3 && this.offset++, c2.includes(this._input[this.offset - 1])))
              return this.heredoc_label.label = n3, this.heredoc_label.length = n3.length, this.heredoc_label.finished = false, i3 = this.offset - t3, this.offset = t3, this.consume(i3), e3 === "'" ? this.begin("ST_NOWDOC") : this.begin("ST_HEREDOC"), this.prematch_ENDOFDOC(), this.tok.T_START_HEREDOC;
          }
        }
        return this.offset = t3, false;
      }, ST_DOUBLE_QUOTES: function() {
        for (var t3; this.offset < this.size; )
          if ((t3 = this.input()) == "\\")
            this.input();
          else {
            if (t3 == '"')
              break;
            if (t3 == "$") {
              if ((t3 = this.input()) == "{" || this.is_LABEL_START()) {
                this.unput(2);
                break;
              }
              t3 && this.unput(1);
            } else if (t3 == "{") {
              if ((t3 = this.input()) == "$") {
                this.unput(2);
                break;
              }
              t3 && this.unput(1);
            }
          }
        if (t3 == '"')
          return this.tok.T_CONSTANT_ENCAPSED_STRING;
        var e3 = 1;
        return this.yytext[0] !== "b" && this.yytext[0] !== "B" || (e3 = 2), this.yytext.length > 2 && this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE, this.yytext.length - e3), this.unput(this.yytext.length - e3), this.begin("ST_DOUBLE_QUOTES"), this.yytext;
      }, isDOC_MATCH: function(t3, e3) {
        var i3 = this._input[t3 - 2];
        if (!c2.includes(i3))
          return false;
        var n3 = false, s3 = false, r3 = 0, o3 = this._input[t3 - 1];
        if (this.version >= 703) {
          for (; o3 === "	" || o3 === " "; )
            o3 === " " ? n3 = true : o3 === "	" && (s3 = true), o3 = this._input[t3 + r3], r3++;
          if (t3 += r3, c2.includes(this._input[t3 - 1]))
            return false;
        }
        if (this._input.substring(t3 - 1, t3 - 1 + this.heredoc_label.length) === this.heredoc_label.label) {
          var a3 = this._input[t3 - 1 + this.heredoc_label.length];
          if ((this.version >= 703 ? _2 : u2).includes(a3)) {
            if (e3) {
              if (this.consume(r3), n3 && s3)
                throw new Error("Parse error:  mixing spaces and tabs in ending marker at line " + this.yylineno + " (offset " + this.offset + ")");
            } else
              this.heredoc_label.indentation = r3, this.heredoc_label.indentation_uses_spaces = n3, this.heredoc_label.first_encaps_node = true;
            return true;
          }
        }
        return false;
      }, prematch_ENDOFDOC: function() {
        this.heredoc_label.indentation_uses_spaces = false, this.heredoc_label.indentation = 0, this.heredoc_label.first_encaps_node = true;
        for (var t3 = this.offset + 1; t3 < this._input.length; ) {
          if (this.isDOC_MATCH(t3, false))
            return;
          if (!c2.includes(this._input[t3 - 1]))
            for (; !c2.includes(this._input[t3++]) && t3 < this._input.length; )
              ;
          t3++;
        }
      }, matchST_NOWDOC: function() {
        if (this.isDOC_MATCH(this.offset, true))
          return this.consume(this.heredoc_label.length), this.popState(), this.tok.T_END_HEREDOC;
        for (var t3 = this._input[this.offset - 1]; this.offset < this.size; )
          if (c2.includes(t3)) {
            if (t3 = this.input(), this.isDOC_MATCH(this.offset, true))
              return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
          } else
            t3 = this.input();
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      }, matchST_HEREDOC: function() {
        var t3 = this.input();
        if (this.isDOC_MATCH(this.offset, true))
          return this.consume(this.heredoc_label.length - 1), this.popState(), this.tok.T_END_HEREDOC;
        for (; this.offset < this.size; )
          if (t3 === "\\" && (t3 = this.input(), c2.includes(t3) || (t3 = this.input())), c2.includes(t3)) {
            if (t3 = this.input(), this.isDOC_MATCH(this.offset, true))
              return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
          } else if (t3 === "$") {
            if ((t3 = this.input()) === "{")
              return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
            if (this.is_LABEL_START()) {
              var e3 = this.offset, i3 = this.consume_VARIABLE();
              return this.yytext.length > this.offset - e3 + 2 ? (this.appendToken(i3, this.offset - e3 + 2), this.unput(this.offset - e3 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i3;
            }
          } else if (t3 === "{") {
            if ((t3 = this.input()) === "$")
              return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
          } else
            t3 = this.input();
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      }, consume_VARIABLE: function() {
        this.consume_LABEL();
        var t3 = this.input();
        if (t3 == "[")
          return this.unput(1), this.begin("ST_VAR_OFFSET"), this.tok.T_VARIABLE;
        if (t3 === "-") {
          if (this.input() === ">")
            return this.input(), this.is_LABEL_START() && this.begin("ST_LOOKING_FOR_PROPERTY"), this.unput(3), this.tok.T_VARIABLE;
          this.unput(2);
        } else
          t3 && this.unput(1);
        return this.tok.T_VARIABLE;
      }, matchST_BACKQUOTE: function() {
        var t3 = this.input();
        if (t3 === "$") {
          if ((t3 = this.input()) === "{")
            return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          if (this.is_LABEL_START())
            return this.consume_VARIABLE();
        } else if (t3 === "{") {
          if (this._input[this.offset] === "$")
            return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
        } else if (t3 === "`")
          return this.popState(), "`";
        for (; this.offset < this.size; ) {
          if (t3 === "\\")
            this.input();
          else {
            if (t3 === "`") {
              this.unput(1), this.popState(), this.appendToken("`", 1);
              break;
            }
            if (t3 === "$") {
              if ((t3 = this.input()) === "{")
                return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
              if (this.is_LABEL_START()) {
                var e3 = this.offset, i3 = this.consume_VARIABLE();
                return this.yytext.length > this.offset - e3 + 2 ? (this.appendToken(i3, this.offset - e3 + 2), this.unput(this.offset - e3 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i3;
              }
              continue;
            }
            if (t3 === "{") {
              if ((t3 = this.input()) === "$")
                return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
              continue;
            }
          }
          t3 = this.input();
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      }, matchST_DOUBLE_QUOTES: function() {
        var t3 = this.input();
        if (t3 === "$") {
          if ((t3 = this.input()) === "{")
            return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          if (this.is_LABEL_START())
            return this.consume_VARIABLE();
        } else if (t3 === "{") {
          if (this._input[this.offset] === "$")
            return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
        } else if (t3 === '"')
          return this.popState(), '"';
        for (; this.offset < this.size; ) {
          if (t3 === "\\")
            this.input();
          else {
            if (t3 === '"') {
              this.unput(1), this.popState(), this.appendToken('"', 1);
              break;
            }
            if (t3 === "$") {
              if ((t3 = this.input()) === "{")
                return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
              if (this.is_LABEL_START()) {
                var e3 = this.offset, i3 = this.consume_VARIABLE();
                return this.yytext.length > this.offset - e3 + 2 ? (this.appendToken(i3, this.offset - e3 + 2), this.unput(this.offset - e3 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i3;
              }
              t3 && this.unput(1);
            } else if (t3 === "{") {
              if ((t3 = this.input()) === "$")
                return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
              t3 && this.unput(1);
            }
          }
          t3 = this.input();
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      } };
      d2.T_CONSTANT_ENCAPSED_STRING, d2.is_HEREDOC, d2.ST_DOUBLE_QUOTES, d2.isDOC_MATCH, d2.prematch_ENDOFDOC, d2.matchST_NOWDOC, d2.matchST_HEREDOC, d2.consume_VARIABLE, d2.matchST_BACKQUOTE, d2.matchST_DOUBLE_QUOTES;
      var p2 = { T_STRING: function() {
        var t3 = this.yytext.toLowerCase(), e3 = this.keywords[t3];
        if (typeof e3 != "number") {
          if (t3 === "yield")
            this.version >= 700 && this.tryMatch(" from") ? (this.consume(5), e3 = this.tok.T_YIELD_FROM) : e3 = this.tok.T_YIELD;
          else if (e3 = this.tok.T_STRING, t3 === "b" || t3 === "B") {
            var i3 = this.input(1);
            if (i3 === '"')
              return this.ST_DOUBLE_QUOTES();
            if (i3 === "'")
              return this.T_CONSTANT_ENCAPSED_STRING();
            i3 && this.unput(1);
          }
        }
        return e3;
      }, consume_TOKEN: function() {
        var t3 = this._input[this.offset - 1], e3 = this.tokenTerminals[t3];
        return e3 ? e3.apply(this, []) : this.yytext;
      }, tokenTerminals: { $: function() {
        return this.offset++, this.is_LABEL_START() ? (this.offset--, this.consume_LABEL(), this.tok.T_VARIABLE) : (this.offset--, "$");
      }, "-": function() {
        var t3 = this._input[this.offset];
        return t3 === ">" ? (this.begin("ST_LOOKING_FOR_PROPERTY").input(), this.tok.T_OBJECT_OPERATOR) : t3 === "-" ? (this.input(), this.tok.T_DEC) : t3 === "=" ? (this.input(), this.tok.T_MINUS_EQUAL) : "-";
      }, "\\": function() {
        return this.tok.T_NS_SEPARATOR;
      }, "/": function() {
        return this._input[this.offset] === "=" ? (this.input(), this.tok.T_DIV_EQUAL) : "/";
      }, ":": function() {
        return this._input[this.offset] === ":" ? (this.input(), this.tok.T_DOUBLE_COLON) : ":";
      }, "(": function() {
        var t3 = this.offset;
        if (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), this.is_LABEL_START()) {
          var e3 = this.yytext.length;
          this.consume_LABEL();
          var i3 = this.yytext.substring(e3 - 1).toLowerCase(), n3 = this.castKeywords[i3];
          if (typeof n3 == "number" && (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), this._input[this.offset - 1] === ")"))
            return n3;
        }
        return this.unput(this.offset - t3), "(";
      }, "=": function() {
        var t3 = this._input[this.offset];
        return t3 === ">" ? (this.input(), this.tok.T_DOUBLE_ARROW) : t3 === "=" ? this._input[this.offset + 1] === "=" ? (this.consume(2), this.tok.T_IS_IDENTICAL) : (this.input(), this.tok.T_IS_EQUAL) : "=";
      }, "+": function() {
        var t3 = this._input[this.offset];
        return t3 === "+" ? (this.input(), this.tok.T_INC) : t3 === "=" ? (this.input(), this.tok.T_PLUS_EQUAL) : "+";
      }, "!": function() {
        return this._input[this.offset] === "=" ? this._input[this.offset + 1] === "=" ? (this.consume(2), this.tok.T_IS_NOT_IDENTICAL) : (this.input(), this.tok.T_IS_NOT_EQUAL) : "!";
      }, "?": function() {
        return this.version >= 700 && this._input[this.offset] === "?" ? this.version >= 704 && this._input[this.offset + 1] === "=" ? (this.consume(2), this.tok.T_COALESCE_EQUAL) : (this.input(), this.tok.T_COALESCE) : this.version >= 800 && this._input[this.offset] === "-" && this._input[this.offset + 1] === ">" ? (this.consume(2), this.tok.T_NULLSAFE_OBJECT_OPERATOR) : "?";
      }, "<": function() {
        var t3 = this._input[this.offset];
        return t3 === "<" ? (t3 = this._input[this.offset + 1]) === "=" ? (this.consume(2), this.tok.T_SL_EQUAL) : t3 === "<" && this.is_HEREDOC() ? this.tok.T_START_HEREDOC : (this.input(), this.tok.T_SL) : t3 === "=" ? (this.input(), this.version >= 700 && this._input[this.offset] === ">" ? (this.input(), this.tok.T_SPACESHIP) : this.tok.T_IS_SMALLER_OR_EQUAL) : t3 === ">" ? (this.input(), this.tok.T_IS_NOT_EQUAL) : "<";
      }, ">": function() {
        var t3 = this._input[this.offset];
        return t3 === "=" ? (this.input(), this.tok.T_IS_GREATER_OR_EQUAL) : t3 === ">" ? (t3 = this._input[this.offset + 1]) === "=" ? (this.consume(2), this.tok.T_SR_EQUAL) : (this.input(), this.tok.T_SR) : ">";
      }, "*": function() {
        var t3 = this._input[this.offset];
        return t3 === "=" ? (this.input(), this.tok.T_MUL_EQUAL) : t3 === "*" ? (this.input(), this._input[this.offset] === "=" ? (this.input(), this.tok.T_POW_EQUAL) : this.tok.T_POW) : "*";
      }, ".": function() {
        var t3 = this._input[this.offset];
        return t3 === "=" ? (this.input(), this.tok.T_CONCAT_EQUAL) : t3 === "." && this._input[this.offset + 1] === "." ? (this.consume(2), this.tok.T_ELLIPSIS) : ".";
      }, "%": function() {
        return this._input[this.offset] === "=" ? (this.input(), this.tok.T_MOD_EQUAL) : "%";
      }, "&": function() {
        var t3 = this._input[this.offset];
        return t3 === "=" ? (this.input(), this.tok.T_AND_EQUAL) : t3 === "&" ? (this.input(), this.tok.T_BOOLEAN_AND) : "&";
      }, "|": function() {
        var t3 = this._input[this.offset];
        return t3 === "=" ? (this.input(), this.tok.T_OR_EQUAL) : t3 === "|" ? (this.input(), this.tok.T_BOOLEAN_OR) : "|";
      }, "^": function() {
        return this._input[this.offset] === "=" ? (this.input(), this.tok.T_XOR_EQUAL) : "^";
      } } };
      p2.T_STRING, p2.consume_TOKEN, p2.tokenTerminals;
      var f2 = { is_NUM: function() {
        var t3 = this._input.charCodeAt(this.offset - 1);
        return t3 > 47 && t3 < 58 || t3 === 95;
      }, is_NUM_START: function() {
        var t3 = this._input.charCodeAt(this.offset - 1);
        return t3 > 47 && t3 < 58;
      }, is_LABEL: function() {
        var t3 = this._input.charCodeAt(this.offset - 1);
        return t3 > 96 && t3 < 123 || t3 > 64 && t3 < 91 || t3 === 95 || t3 > 47 && t3 < 58 || t3 > 126;
      }, is_LABEL_START: function() {
        var t3 = this._input.charCodeAt(this.offset - 1);
        return t3 > 64 && t3 < 91 || (t3 > 96 && t3 < 123 || (t3 === 95 || t3 > 126));
      }, consume_LABEL: function() {
        for (; this.offset < this.size; ) {
          var t3 = this.input();
          if (!this.is_LABEL()) {
            t3 && this.unput(1);
            break;
          }
        }
        return this;
      }, is_TOKEN: function() {
        var t3 = this._input[this.offset - 1];
        return ";:,.\\[]()|^&+-/*=%!~$<>?@".indexOf(t3) !== -1;
      }, is_WHITESPACE: function() {
        var t3 = this._input[this.offset - 1];
        return t3 === " " || t3 === "	" || t3 === "\n" || t3 === "\r";
      }, is_TABSPACE: function() {
        var t3 = this._input[this.offset - 1];
        return t3 === " " || t3 === "	";
      }, consume_TABSPACE: function() {
        for (; this.offset < this.size; ) {
          var t3 = this.input();
          if (!this.is_TABSPACE()) {
            t3 && this.unput(1);
            break;
          }
        }
        return this;
      }, is_HEX: function() {
        var t3 = this._input.charCodeAt(this.offset - 1);
        return t3 > 47 && t3 < 58 || (t3 > 64 && t3 < 71 || (t3 > 96 && t3 < 103 || t3 === 95));
      } };
      f2.is_NUM, f2.is_NUM_START, f2.is_LABEL, f2.is_LABEL_START, f2.consume_LABEL, f2.is_TOKEN, f2.is_WHITESPACE, f2.is_TABSPACE, f2.consume_TABSPACE, f2.is_HEX;
      var T2 = function(t3) {
        this.engine = t3, this.tok = this.engine.tokens.names, this.EOF = 1, this.debug = false, this.all_tokens = true, this.comment_tokens = false, this.mode_eval = false, this.asp_tags = false, this.short_tags = false, this.version = 800, this.yyprevcol = 0, this.keywords = { __class__: this.tok.T_CLASS_C, __trait__: this.tok.T_TRAIT_C, __function__: this.tok.T_FUNC_C, __method__: this.tok.T_METHOD_C, __line__: this.tok.T_LINE, __file__: this.tok.T_FILE, __dir__: this.tok.T_DIR, __namespace__: this.tok.T_NS_C, exit: this.tok.T_EXIT, die: this.tok.T_EXIT, function: this.tok.T_FUNCTION, const: this.tok.T_CONST, return: this.tok.T_RETURN, try: this.tok.T_TRY, catch: this.tok.T_CATCH, finally: this.tok.T_FINALLY, throw: this.tok.T_THROW, if: this.tok.T_IF, elseif: this.tok.T_ELSEIF, endif: this.tok.T_ENDIF, else: this.tok.T_ELSE, while: this.tok.T_WHILE, endwhile: this.tok.T_ENDWHILE, do: this.tok.T_DO, for: this.tok.T_FOR, endfor: this.tok.T_ENDFOR, foreach: this.tok.T_FOREACH, endforeach: this.tok.T_ENDFOREACH, declare: this.tok.T_DECLARE, enddeclare: this.tok.T_ENDDECLARE, instanceof: this.tok.T_INSTANCEOF, as: this.tok.T_AS, switch: this.tok.T_SWITCH, endswitch: this.tok.T_ENDSWITCH, case: this.tok.T_CASE, default: this.tok.T_DEFAULT, break: this.tok.T_BREAK, continue: this.tok.T_CONTINUE, goto: this.tok.T_GOTO, echo: this.tok.T_ECHO, print: this.tok.T_PRINT, class: this.tok.T_CLASS, interface: this.tok.T_INTERFACE, trait: this.tok.T_TRAIT, extends: this.tok.T_EXTENDS, implements: this.tok.T_IMPLEMENTS, new: this.tok.T_NEW, clone: this.tok.T_CLONE, var: this.tok.T_VAR, eval: this.tok.T_EVAL, include: this.tok.T_INCLUDE, include_once: this.tok.T_INCLUDE_ONCE, require: this.tok.T_REQUIRE, require_once: this.tok.T_REQUIRE_ONCE, namespace: this.tok.T_NAMESPACE, use: this.tok.T_USE, insteadof: this.tok.T_INSTEADOF, global: this.tok.T_GLOBAL, isset: this.tok.T_ISSET, empty: this.tok.T_EMPTY, __halt_compiler: this.tok.T_HALT_COMPILER, static: this.tok.T_STATIC, abstract: this.tok.T_ABSTRACT, final: this.tok.T_FINAL, private: this.tok.T_PRIVATE, protected: this.tok.T_PROTECTED, public: this.tok.T_PUBLIC, unset: this.tok.T_UNSET, list: this.tok.T_LIST, array: this.tok.T_ARRAY, callable: this.tok.T_CALLABLE, or: this.tok.T_LOGICAL_OR, and: this.tok.T_LOGICAL_AND, xor: this.tok.T_LOGICAL_XOR, match: this.tok.T_MATCH }, this.castKeywords = { int: this.tok.T_INT_CAST, integer: this.tok.T_INT_CAST, real: this.tok.T_DOUBLE_CAST, double: this.tok.T_DOUBLE_CAST, float: this.tok.T_DOUBLE_CAST, string: this.tok.T_STRING_CAST, binary: this.tok.T_STRING_CAST, array: this.tok.T_ARRAY_CAST, object: this.tok.T_OBJECT_CAST, bool: this.tok.T_BOOL_CAST, boolean: this.tok.T_BOOL_CAST, unset: this.tok.T_UNSET_CAST };
      };
      T2.prototype.setInput = function(t3) {
        return this._input = t3, this.size = t3.length, this.yylineno = 1, this.offset = 0, this.yyprevcol = 0, this.yytext = "", this.yylloc = { first_offset: 0, first_line: 1, first_column: 0, prev_offset: 0, prev_line: 1, prev_column: 0, last_line: 1, last_column: 0 }, this.tokens = [], this.version > 703 ? this.keywords.fn = this.tok.T_FN : delete this.keywords.fn, this.done = this.offset >= this.size, !this.all_tokens && this.mode_eval ? (this.conditionStack = ["INITIAL"], this.begin("ST_IN_SCRIPTING")) : (this.conditionStack = [], this.begin("INITIAL")), this.heredoc_label = { label: "", length: 0, indentation: 0, indentation_uses_spaces: false, finished: false, first_encaps_node: false, toString: function() {
          this.label;
        } }, this;
      }, T2.prototype.input = function() {
        var t3 = this._input[this.offset];
        return t3 ? (this.yytext += t3, this.offset++, t3 === "\r" && this._input[this.offset] === "\n" && (this.yytext += "\n", this.offset++), t3 === "\n" || t3 === "\r" ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++, t3) : "";
      }, T2.prototype.unput = function(t3) {
        if (t3 === 1)
          this.offset--, this._input[this.offset] === "\n" && this._input[this.offset - 1] === "\r" && (this.offset--, t3++), this._input[this.offset] === "\r" || this._input[this.offset] === "\n" ? (this.yylloc.last_line--, this.yylineno--, this.yylloc.last_column = this.yyprevcol) : this.yylloc.last_column--, this.yytext = this.yytext.substring(0, this.yytext.length - t3);
        else if (t3 > 0)
          if (this.offset -= t3, t3 < this.yytext.length) {
            this.yytext = this.yytext.substring(0, this.yytext.length - t3), this.yylloc.last_line = this.yylloc.first_line, this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;
            for (var e3 = 0; e3 < this.yytext.length; e3++) {
              var i3 = this.yytext[e3];
              i3 === "\r" ? (i3 = this.yytext[++e3], this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0, i3 !== "\n" && (i3 === "\r" ? this.yylloc.last_line++ : this.yylloc.last_column++)) : i3 === "\n" ? (this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0) : this.yylloc.last_column++;
            }
            this.yylineno = this.yylloc.last_line;
          } else
            this.yytext = "", this.yylloc.last_line = this.yylineno = this.yylloc.first_line, this.yylloc.last_column = this.yylloc.first_column;
        return this;
      }, T2.prototype.tryMatch = function(t3) {
        return t3 === this.ahead(t3.length);
      }, T2.prototype.tryMatchCaseless = function(t3) {
        return t3 === this.ahead(t3.length).toLowerCase();
      }, T2.prototype.ahead = function(t3) {
        var e3 = this._input.substring(this.offset, this.offset + t3);
        return e3[e3.length - 1] === "\r" && this._input[this.offset + t3 + 1] === "\n" && (e3 += "\n"), e3;
      }, T2.prototype.consume = function(t3) {
        for (var e3 = 0; e3 < t3; e3++) {
          var i3 = this._input[this.offset];
          if (!i3)
            break;
          this.yytext += i3, this.offset++, i3 === "\r" && this._input[this.offset] === "\n" && (this.yytext += "\n", this.offset++, e3++), i3 === "\n" || i3 === "\r" ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++;
        }
        return this;
      }, T2.prototype.getState = function() {
        return { yytext: this.yytext, offset: this.offset, yylineno: this.yylineno, yyprevcol: this.yyprevcol, yylloc: { first_offset: this.yylloc.first_offset, first_line: this.yylloc.first_line, first_column: this.yylloc.first_column, last_line: this.yylloc.last_line, last_column: this.yylloc.last_column }, heredoc_label: this.heredoc_label };
      }, T2.prototype.setState = function(t3) {
        return this.yytext = t3.yytext, this.offset = t3.offset, this.yylineno = t3.yylineno, this.yyprevcol = t3.yyprevcol, this.yylloc = t3.yylloc, t3.heredoc_label && (this.heredoc_label = t3.heredoc_label), this;
      }, T2.prototype.appendToken = function(t3, e3) {
        return this.tokens.push([t3, e3]), this;
      }, T2.prototype.lex = function() {
        this.yylloc.prev_offset = this.offset, this.yylloc.prev_line = this.yylloc.last_line, this.yylloc.prev_column = this.yylloc.last_column;
        var t3 = this.next() || this.lex();
        if (!this.all_tokens) {
          for (; t3 === this.tok.T_WHITESPACE || !this.comment_tokens && (t3 === this.tok.T_COMMENT || t3 === this.tok.T_DOC_COMMENT) || t3 === this.tok.T_OPEN_TAG; )
            t3 = this.next() || this.lex();
          if (t3 == this.tok.T_OPEN_TAG_WITH_ECHO)
            return this.tok.T_ECHO;
          if (t3 === this.tok.T_CLOSE_TAG)
            return ";";
        }
        return this.yylloc.prev_offset || (this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column), t3;
      }, T2.prototype.begin = function(t3) {
        if (this.conditionStack.push(t3), this.curCondition = t3, this.stateCb = this["match" + t3], typeof this.stateCb != "function")
          throw new Error('Undefined condition state "' + t3 + '"');
        return this;
      }, T2.prototype.popState = function() {
        var t3 = this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
        if (this.curCondition = this.conditionStack[this.conditionStack.length - 1], this.stateCb = this["match" + this.curCondition], typeof this.stateCb != "function")
          throw new Error('Undefined condition state "' + this.curCondition + '"');
        return t3;
      }, T2.prototype.next = function() {
        var t3;
        if (this._input || (this.done = true), this.yylloc.first_offset = this.offset, this.yylloc.first_line = this.yylloc.last_line, this.yylloc.first_column = this.yylloc.last_column, this.yytext = "", this.done)
          return this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column, this.EOF;
        if (this.tokens.length > 0 ? (typeof (t3 = this.tokens.shift())[1] == "object" ? this.setState(t3[1]) : this.consume(t3[1]), t3 = t3[0]) : t3 = this.stateCb.apply(this, []), this.offset >= this.size && this.tokens.length === 0 && (this.done = true), this.debug) {
          var e3 = t3;
          e3 = typeof e3 == "number" ? this.engine.tokens.values[e3] : '"' + e3 + '"';
          var i3 = new Error(e3 + "	from " + this.yylloc.first_line + "," + this.yylloc.first_column + "	 - to " + this.yylloc.last_line + "," + this.yylloc.last_column + '	"' + this.yytext + '"');
          console.error(i3.stack);
        }
        return t3;
      }, [s2, r2, o2, a2, h2, l2, d2, p2, f2].forEach(function(t3) {
        for (var e3 in t3)
          T2.prototype[e3] = t3[e3];
      });
      var k2 = T2, m2 = function(t3, e3, i3) {
        this.line = t3, this.column = e3, this.offset = i3;
      }, E2 = { read_array: function() {
        var t3 = null, e3 = false, i3 = this.node("array");
        this.token === this.tok.T_ARRAY ? (this.next().expect("("), t3 = ")") : (e3 = true, t3 = "]");
        var n3 = [];
        return this.next().token !== t3 && (n3 = this.read_array_pair_list(e3)), this.expect(t3), this.next(), i3(e3, n3);
      }, read_array_pair_list: function(t3) {
        var e3 = this;
        return this.read_list(function() {
          return e3.read_array_pair(t3);
        }, ",", true);
      }, read_array_pair: function(t3) {
        if (!(!t3 && this.token === ")" || t3 && this.token === "]")) {
          if (this.token === ",")
            return this.node("noop")();
          var e3 = this.node("entry"), i3 = null, n3 = null, s3 = false, r3 = false;
          if (this.token === "&")
            this.next(), s3 = true, n3 = this.read_variable(true, false);
          else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704)
            this.next(), this.token === "&" && this.error(), r3 = true, n3 = this.read_expr();
          else {
            var o3 = this.read_expr();
            this.token === this.tok.T_DOUBLE_ARROW ? (this.next(), i3 = o3, this.token === "&" ? (this.next(), s3 = true, n3 = this.read_variable(true, false)) : n3 = this.read_expr()) : n3 = o3;
          }
          return e3(i3, n3, s3, r3);
        }
      } };
      function x2(t3, e3, i3) {
        return e3 in t3 ? Object.defineProperty(t3, e3, { value: i3, enumerable: true, configurable: true, writable: true }) : t3[e3] = i3, t3;
      }
      function y2(t3, e3) {
        var i3 = Object.keys(t3);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(t3);
          e3 && (n3 = n3.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
          })), i3.push.apply(i3, n3);
        }
        return i3;
      }
      function v2(t3) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var i3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? y2(Object(i3), true).forEach(function(e4) {
            x2(t3, e4, i3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(i3)) : y2(Object(i3)).forEach(function(e4) {
            Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(i3, e4));
          });
        }
        return t3;
      }
      function A2(t3, e3) {
        return function(t4) {
          if (Array.isArray(t4))
            return t4;
        }(t3) || function(t4, e4) {
          if (typeof Symbol == "undefined" || !(Symbol.iterator in Object(t4)))
            return;
          var i3 = [], n3 = true, s3 = false, r3 = void 0;
          try {
            for (var o3, a3 = t4[Symbol.iterator](); !(n3 = (o3 = a3.next()).done) && (i3.push(o3.value), !e4 || i3.length !== e4); n3 = true)
              ;
          } catch (t5) {
            s3 = true, r3 = t5;
          } finally {
            try {
              n3 || a3.return == null || a3.return();
            } finally {
              if (s3)
                throw r3;
            }
          }
          return i3;
        }(t3, e3) || N2(t3, e3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function g2(t3) {
        return function(t4) {
          if (Array.isArray(t4))
            return C2(t4);
        }(t3) || function(t4) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(t4))
            return Array.from(t4);
        }(t3) || N2(t3) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function N2(t3, e3) {
        if (t3) {
          if (typeof t3 == "string")
            return C2(t3, e3);
          var i3 = Object.prototype.toString.call(t3).slice(8, -1);
          return i3 === "Object" && t3.constructor && (i3 = t3.constructor.name), i3 === "Map" || i3 === "Set" ? Array.from(i3) : i3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? C2(t3, e3) : void 0;
        }
      }
      function C2(t3, e3) {
        (e3 == null || e3 > t3.length) && (e3 = t3.length);
        for (var i3 = 0, n3 = new Array(e3); i3 < e3; i3++)
          n3[i3] = t3[i3];
        return n3;
      }
      function S2(t3) {
        if (typeof Symbol == "undefined" || t3[Symbol.iterator] == null) {
          if (Array.isArray(t3) || (t3 = N2(t3))) {
            var e3 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return e3 >= t3.length ? { done: true } : { done: false, value: t3[e3++] };
            }, e: function(t4) {
              throw t4;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var n3, s3, r3 = true, o3 = false;
        return { s: function() {
          n3 = t3[Symbol.iterator]();
        }, n: function() {
          var t4 = n3.next();
          return r3 = t4.done, t4;
        }, e: function(t4) {
          o3 = true, s3 = t4;
        }, f: function() {
          try {
            r3 || n3.return == null || n3.return();
          } finally {
            if (o3)
              throw s3;
          }
        } };
      }
      E2.read_array, E2.read_array_pair_list, E2.read_array_pair;
      var b2 = { read_class_declaration_statement: function(t3) {
        var e3 = this.node("class"), i3 = this.read_class_modifiers();
        if (this.token !== this.tok.T_CLASS)
          return this.error(this.tok.T_CLASS), this.next(), null;
        this.next().expect(this.tok.T_STRING);
        var n3 = this.node("identifier"), s3 = this.text();
        this.next(), n3 = n3(s3);
        var r3 = this.read_extends_from(), o3 = this.read_implements_list();
        this.expect("{");
        var a3 = e3(n3, r3, o3, this.next().read_class_body(), i3);
        return t3 && (a3.attrGroups = t3), a3;
      }, read_class_modifiers: function() {
        return [0, 0, this.read_class_modifier()];
      }, read_class_modifier: function() {
        return this.token === this.tok.T_ABSTRACT ? (this.next(), 1) : this.token === this.tok.T_FINAL ? (this.next(), 2) : 0;
      }, read_class_body: function() {
        for (var t3 = [], e3 = []; this.token !== this.EOF && this.token !== "}"; )
          if (this.token !== this.tok.T_COMMENT)
            if (this.token !== this.tok.T_DOC_COMMENT)
              if (this.token !== this.tok.T_USE) {
                this.token === this.tok.T_ATTRIBUTE && (e3 = this.read_attr_list());
                var i3 = this.position(), n3 = this.read_member_flags(false);
                if (this.token !== this.tok.T_CONST)
                  if (this.token === this.tok.T_VAR && (this.next().expect(this.tok.T_VARIABLE), n3[0] = null, n3[1] = 0), this.token === this.tok.T_FUNCTION)
                    t3.push(this.read_function(false, n3, e3, i3)), e3 = [];
                  else if (this.token === this.tok.T_VARIABLE || this.version >= 704 && (this.token === "?" || this.token === this.tok.T_CALLABLE || this.token === this.tok.T_ARRAY || this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE)) {
                    var s3 = this.read_variable_list(n3, e3);
                    e3 = [], this.expect(";"), this.next(), t3 = t3.concat(s3);
                  } else
                    this.error([this.tok.T_CONST, this.tok.T_VARIABLE, this.tok.T_FUNCTION]), this.next();
                else {
                  var r3 = this.read_constant_list(n3, e3);
                  this.expect(";") && this.next(), t3 = t3.concat(r3);
                }
              } else
                t3 = t3.concat(this.read_trait_use_statement());
            else
              t3.push(this.read_doc_comment());
          else
            t3.push(this.read_comment());
        return this.expect("}"), this.next(), t3;
      }, read_variable_list: function(t3, e3) {
        var i3 = this.node("propertystatement"), n3 = this.read_list(function() {
          var t4 = this.node("property"), i4 = A2(this.read_optional_type(), 2), n4 = i4[0], s3 = i4[1];
          this.expect(this.tok.T_VARIABLE);
          var r3 = this.node("identifier"), o3 = this.text().substring(1);
          return this.next(), r3 = r3(o3), this.token === ";" || this.token === "," ? t4(r3, null, n4, s3, e3 || []) : this.token === "=" ? t4(r3, this.next().read_expr(), n4, s3, e3 || []) : (this.expect([",", ";", "="]), t4(r3, null, n4, s3, e3 || []));
        }, ",");
        return i3(null, n3, t3);
      }, read_constant_list: function(t3, e3) {
        this.expect(this.tok.T_CONST) && this.next();
        var i3 = this.node("classconstant"), n3 = this.read_list(function() {
          var t4 = this.node("constant"), e4 = null, i4 = null;
          if (this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            e4 = this.node("identifier");
            var n4 = this.text();
            this.next(), e4 = e4(n4);
          } else
            this.expect("IDENTIFIER");
          return this.expect("=") && (i4 = this.next().read_expr()), t4(e4, i4);
        }, ",");
        return i3(null, n3, t3, e3 || []);
      }, read_member_flags: function(t3) {
        var e3 = [-1, -1, -1];
        if (this.is("T_MEMBER_FLAGS")) {
          var i3 = 0, n3 = 0;
          do {
            switch (this.token) {
              case this.tok.T_PUBLIC:
                i3 = 0, n3 = 0;
                break;
              case this.tok.T_PROTECTED:
                i3 = 0, n3 = 1;
                break;
              case this.tok.T_PRIVATE:
                i3 = 0, n3 = 2;
                break;
              case this.tok.T_STATIC:
                i3 = 1, n3 = 1;
                break;
              case this.tok.T_ABSTRACT:
                i3 = 2, n3 = 1;
                break;
              case this.tok.T_FINAL:
                i3 = 2, n3 = 2;
            }
            t3 && (i3 == 0 && n3 == 2 ? (this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]), n3 = -1) : i3 == 2 && n3 == 1 && (this.error(), n3 = -1)), e3[i3] !== -1 ? this.error() : n3 !== -1 && (e3[i3] = n3);
          } while (this.next().is("T_MEMBER_FLAGS"));
        }
        return e3[1] == -1 && (e3[1] = 0), e3[2] == -1 && (e3[2] = 0), e3;
      }, read_optional_type: function() {
        var t3 = false;
        this.token === "?" && (t3 = true, this.next());
        var e3 = this.read_types();
        if (t3 && !e3 && this.raiseError("Expecting a type definition combined with nullable operator"), !t3 && !e3)
          return [false, null];
        if (this.token === "|") {
          e3 = [e3];
          do {
            this.next();
            var i3 = this.read_type();
            if (!i3) {
              this.raiseError("Expecting a type definition");
              break;
            }
            e3.push(i3);
          } while (this.token === "|");
        }
        return [t3, e3];
      }, read_interface_declaration_statement: function(t3) {
        var e3 = this.node("interface");
        if (this.token !== this.tok.T_INTERFACE)
          return this.error(this.tok.T_INTERFACE), this.next(), null;
        this.next().expect(this.tok.T_STRING);
        var i3 = this.node("identifier"), n3 = this.text();
        this.next(), i3 = i3(n3);
        var s3 = this.read_interface_extends_list();
        return this.expect("{"), e3(i3, s3, this.next().read_interface_body(), t3 || []);
      }, read_interface_body: function() {
        for (var t3 = [], e3 = []; this.token !== this.EOF && this.token !== "}"; )
          if (this.token !== this.tok.T_COMMENT)
            if (this.token !== this.tok.T_DOC_COMMENT) {
              var i3 = this.position();
              e3 = this.read_attr_list();
              var n3 = this.read_member_flags(true);
              if (this.token == this.tok.T_CONST) {
                var s3 = this.read_constant_list(n3, e3);
                this.expect(";") && this.next(), t3 = t3.concat(s3), e3 = [];
              } else if (this.token === this.tok.T_FUNCTION) {
                var r3 = this.read_function_declaration(2, n3, e3, i3);
                r3.parseFlags(n3), t3.push(r3), this.expect(";") && this.next(), e3 = [];
              } else
                this.error([this.tok.T_CONST, this.tok.T_FUNCTION]), this.next();
            } else
              t3.push(this.read_doc_comment());
          else
            t3.push(this.read_comment());
        return this.expect("}") && this.next(), t3;
      }, read_trait_declaration_statement: function() {
        var t3 = this.node("trait");
        if (this.token !== this.tok.T_TRAIT)
          return this.error(this.tok.T_TRAIT), this.next(), null;
        this.next().expect(this.tok.T_STRING);
        var e3 = this.node("identifier"), i3 = this.text();
        return this.next(), e3 = e3(i3), this.expect("{"), t3(e3, this.next().read_class_body());
      }, read_trait_use_statement: function() {
        var t3 = this.node("traituse");
        this.expect(this.tok.T_USE) && this.next();
        for (var e3 = [this.read_namespace_name()], i3 = null; this.token === ","; )
          e3.push(this.next().read_namespace_name());
        if (this.token === "{") {
          for (i3 = []; this.next().token !== this.EOF && this.token !== "}"; )
            i3.push(this.read_trait_use_alias()), this.expect(";");
          this.expect("}") && this.next();
        } else
          this.expect(";") && this.next();
        return t3(e3, i3);
      }, read_trait_use_alias: function() {
        var t3, e3 = this.node(), i3 = null;
        if (this.is("IDENTIFIER")) {
          t3 = this.node("identifier");
          var n3 = this.text();
          this.next(), t3 = t3(n3);
        } else if (t3 = this.read_namespace_name(), this.token === this.tok.T_DOUBLE_COLON)
          if (this.next(), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            i3 = t3, t3 = this.node("identifier");
            var s3 = this.text();
            this.next(), t3 = t3(s3);
          } else
            this.expect(this.tok.T_STRING);
        else
          t3 = t3.name;
        if (this.token === this.tok.T_INSTEADOF)
          return e3("traitprecedence", i3, t3, this.next().read_name_list());
        if (this.token === this.tok.T_AS) {
          var r3 = null, o3 = null;
          if (this.next().is("T_MEMBER_FLAGS") && (r3 = this.read_member_flags()), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            o3 = this.node("identifier");
            var a3 = this.text();
            this.next(), o3 = o3(a3);
          } else
            r3 === false && this.expect(this.tok.T_STRING);
          return e3("traitalias", i3, t3, o3, r3);
        }
        return this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]), e3("traitalias", i3, t3, null, null);
      } };
      b2.read_class_declaration_statement, b2.read_class_modifiers, b2.read_class_modifier, b2.read_class_body, b2.read_variable_list, b2.read_constant_list, b2.read_member_flags, b2.read_optional_type, b2.read_interface_declaration_statement, b2.read_interface_body, b2.read_trait_declaration_statement, b2.read_trait_use_statement, b2.read_trait_use_alias;
      var L2 = { read_comment: function() {
        var t3 = this.text(), e3 = this.ast.prepare(t3.substring(0, 2) === "/*" ? "commentblock" : "commentline", null, this), i3 = this.lexer.yylloc.first_offset, n3 = this.prev;
        return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (e3 = e3(t3)).offset = i3, this.prev = n3, e3;
      }, read_doc_comment: function() {
        var t3 = this.ast.prepare("commentblock", null, this), e3 = this.lexer.yylloc.first_offset, i3 = this.text(), n3 = this.prev;
        return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (t3 = t3(i3)).offset = e3, this.prev = n3, t3;
      } };
      L2.read_comment, L2.read_doc_comment;
      var O2 = { read_expr: function(t3) {
        var e3 = this.node();
        if (this.token === "@")
          return t3 || (t3 = this.next().read_expr()), e3("silent", t3);
        if (t3 || (t3 = this.read_expr_item()), this.token === "|")
          return e3("bin", "|", t3, this.next().read_expr());
        if (this.token === "&")
          return e3("bin", "&", t3, this.next().read_expr());
        if (this.token === "^")
          return e3("bin", "^", t3, this.next().read_expr());
        if (this.token === ".")
          return e3("bin", ".", t3, this.next().read_expr());
        if (this.token === "+")
          return e3("bin", "+", t3, this.next().read_expr());
        if (this.token === "-")
          return e3("bin", "-", t3, this.next().read_expr());
        if (this.token === "*")
          return e3("bin", "*", t3, this.next().read_expr());
        if (this.token === "/")
          return e3("bin", "/", t3, this.next().read_expr());
        if (this.token === "%")
          return e3("bin", "%", t3, this.next().read_expr());
        if (this.token === this.tok.T_POW)
          return e3("bin", "**", t3, this.next().read_expr());
        if (this.token === this.tok.T_SL)
          return e3("bin", "<<", t3, this.next().read_expr());
        if (this.token === this.tok.T_SR)
          return e3("bin", ">>", t3, this.next().read_expr());
        if (this.token === this.tok.T_BOOLEAN_OR)
          return e3("bin", "||", t3, this.next().read_expr());
        if (this.token === this.tok.T_LOGICAL_OR)
          return e3("bin", "or", t3, this.next().read_expr());
        if (this.token === this.tok.T_BOOLEAN_AND)
          return e3("bin", "&&", t3, this.next().read_expr());
        if (this.token === this.tok.T_LOGICAL_AND)
          return e3("bin", "and", t3, this.next().read_expr());
        if (this.token === this.tok.T_LOGICAL_XOR)
          return e3("bin", "xor", t3, this.next().read_expr());
        if (this.token === this.tok.T_IS_IDENTICAL)
          return e3("bin", "===", t3, this.next().read_expr());
        if (this.token === this.tok.T_IS_NOT_IDENTICAL)
          return e3("bin", "!==", t3, this.next().read_expr());
        if (this.token === this.tok.T_IS_EQUAL)
          return e3("bin", "==", t3, this.next().read_expr());
        if (this.token === this.tok.T_IS_NOT_EQUAL)
          return e3("bin", "!=", t3, this.next().read_expr());
        if (this.token === "<")
          return e3("bin", "<", t3, this.next().read_expr());
        if (this.token === ">")
          return e3("bin", ">", t3, this.next().read_expr());
        if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL)
          return e3("bin", "<=", t3, this.next().read_expr());
        if (this.token === this.tok.T_IS_GREATER_OR_EQUAL)
          return e3("bin", ">=", t3, this.next().read_expr());
        if (this.token === this.tok.T_SPACESHIP)
          return e3("bin", "<=>", t3, this.next().read_expr());
        if (this.token === this.tok.T_INSTANCEOF && (t3 = e3("bin", "instanceof", t3, this.next().read_class_name_reference()), this.token !== ";" && this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF && (t3 = this.read_expr(t3))), this.token === this.tok.T_COALESCE)
          return e3("bin", "??", t3, this.next().read_expr());
        if (this.token === "?") {
          var i3 = null;
          return this.next().token !== ":" && (i3 = this.read_expr()), this.expect(":") && this.next(), e3("retif", t3, i3, this.read_expr());
        }
        return e3.destroy(t3), t3;
      }, read_expr_cast: function(t3) {
        return this.node("cast")(t3, this.text(), this.next().read_expr());
      }, read_isset_variable: function() {
        return this.read_expr();
      }, read_isset_variables: function() {
        return this.read_function_list(this.read_isset_variable, ",");
      }, read_internal_functions_in_yacc: function() {
        var t3 = null;
        switch (this.token) {
          case this.tok.T_ISSET:
            t3 = this.node("isset"), this.next().expect("(") && this.next();
            var e3 = this.read_isset_variables();
            this.expect(")") && this.next(), t3 = t3(e3);
            break;
          case this.tok.T_EMPTY:
            t3 = this.node("empty"), this.next().expect("(") && this.next();
            var i3 = this.read_expr();
            this.expect(")") && this.next(), t3 = t3(i3);
            break;
          case this.tok.T_INCLUDE:
            t3 = this.node("include")(false, false, this.next().read_expr());
            break;
          case this.tok.T_INCLUDE_ONCE:
            t3 = this.node("include")(true, false, this.next().read_expr());
            break;
          case this.tok.T_EVAL:
            t3 = this.node("eval"), this.next().expect("(") && this.next();
            var n3 = this.read_expr();
            this.expect(")") && this.next(), t3 = t3(n3);
            break;
          case this.tok.T_REQUIRE:
            t3 = this.node("include")(false, true, this.next().read_expr());
            break;
          case this.tok.T_REQUIRE_ONCE:
            t3 = this.node("include")(true, true, this.next().read_expr());
        }
        return t3;
      }, read_optional_expr: function(t3) {
        return this.token !== t3 ? this.read_expr() : null;
      }, read_exit_expr: function() {
        var t3 = null;
        return this.token === "(" && (this.next(), t3 = this.read_optional_expr(")"), this.expect(")") && this.next()), t3;
      }, read_expr_item: function() {
        var t3, e3, i3 = [];
        if (this.token === "+")
          return this.node("unary")("+", this.next().read_expr());
        if (this.token === "-")
          return this.node("unary")("-", this.next().read_expr());
        if (this.token === "!")
          return this.node("unary")("!", this.next().read_expr());
        if (this.token === "~")
          return this.node("unary")("~", this.next().read_expr());
        if (this.token === "(")
          return (e3 = this.next().read_expr()).parenthesizedExpression = true, this.expect(")") && this.next(), this.handleDereferencable(e3);
        if (this.token === "`")
          return this.read_encapsed_string("`");
        if (this.token === this.tok.T_LIST) {
          var n3 = null, s3 = this.innerList;
          t3 = this.node("list"), s3 || (n3 = this.node("assign")), this.next().expect("(") && this.next(), this.innerList || (this.innerList = true);
          var r3 = this.read_array_pair_list(false);
          this.expect(")") && this.next();
          for (var o3 = false, a3 = 0; a3 < r3.length; a3++)
            if (r3[a3] !== null && r3[a3].kind !== "noop") {
              o3 = true;
              break;
            }
          return o3 || this.raiseError("Fatal Error :  Cannot use empty list on line " + this.lexer.yylloc.first_line), s3 ? t3(r3, false) : (this.innerList = false, this.expect("=") ? n3(t3(r3, false), this.next().read_expr(), "=") : t3(r3, false));
        }
        if (this.token === this.tok.T_ATTRIBUTE && (i3 = this.read_attr_list()), this.token === this.tok.T_CLONE)
          return this.node("clone")(this.next().read_expr());
        switch (this.token) {
          case this.tok.T_INC:
            return this.node("pre")("+", this.next().read_variable(false, false));
          case this.tok.T_DEC:
            return this.node("pre")("-", this.next().read_variable(false, false));
          case this.tok.T_NEW:
            return this.read_new_expr();
          case this.tok.T_ISSET:
          case this.tok.T_EMPTY:
          case this.tok.T_INCLUDE:
          case this.tok.T_INCLUDE_ONCE:
          case this.tok.T_EVAL:
          case this.tok.T_REQUIRE:
          case this.tok.T_REQUIRE_ONCE:
            return this.read_internal_functions_in_yacc();
          case this.tok.T_MATCH:
            return this.read_match_expression();
          case this.tok.T_INT_CAST:
            return this.read_expr_cast("int");
          case this.tok.T_DOUBLE_CAST:
            return this.read_expr_cast("float");
          case this.tok.T_STRING_CAST:
            return this.read_expr_cast(this.text().indexOf("binary") !== -1 ? "binary" : "string");
          case this.tok.T_ARRAY_CAST:
            return this.read_expr_cast("array");
          case this.tok.T_OBJECT_CAST:
            return this.read_expr_cast("object");
          case this.tok.T_BOOL_CAST:
            return this.read_expr_cast("bool");
          case this.tok.T_UNSET_CAST:
            return this.read_expr_cast("unset");
          case this.tok.T_THROW:
            return this.version < 800 && this.raiseError("PHP 8+ is required to use throw as an expression"), this.node("throw")(this.next().read_expr());
          case this.tok.T_EXIT:
            var h3 = this.lexer.yytext.toLowerCase() === "die";
            return t3 = this.node("exit"), this.next(), t3(this.read_exit_expr(), h3);
          case this.tok.T_PRINT:
            return this.node("print")(this.next().read_expr());
          case this.tok.T_YIELD:
            var l3 = null, c3 = null;
            return t3 = this.node("yield"), this.next().is("EXPR") && (l3 = this.read_expr(), this.token === this.tok.T_DOUBLE_ARROW && (c3 = l3, l3 = this.next().read_expr())), t3(l3, c3);
          case this.tok.T_YIELD_FROM:
            return (t3 = this.node("yieldfrom"))(e3 = this.next().read_expr());
          case this.tok.T_FN:
          case this.tok.T_FUNCTION:
            return this.read_inline_function(void 0, i3);
          case this.tok.T_STATIC:
            var u3 = [this.token, this.lexer.getState()];
            if (this.next(), this.token === this.tok.T_FUNCTION || this.version >= 704 && this.token === this.tok.T_FN)
              return this.read_inline_function([0, 1, 0], i3);
            this.lexer.tokens.push(u3), this.next();
        }
        if (this.is("VARIABLE")) {
          t3 = this.node();
          var _3 = (e3 = this.read_variable(false, false)).kind === "identifier" || e3.kind === "staticlookup" && e3.offset.kind === "identifier";
          switch (this.token) {
            case "=":
              return _3 && this.error("VARIABLE"), this.next().token == "&" ? this.read_assignref(t3, e3) : t3("assign", e3, this.read_expr(), "=");
            case this.tok.T_PLUS_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "+=");
            case this.tok.T_MINUS_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "-=");
            case this.tok.T_MUL_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "*=");
            case this.tok.T_POW_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "**=");
            case this.tok.T_DIV_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "/=");
            case this.tok.T_CONCAT_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), ".=");
            case this.tok.T_MOD_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "%=");
            case this.tok.T_AND_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "&=");
            case this.tok.T_OR_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "|=");
            case this.tok.T_XOR_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "^=");
            case this.tok.T_SL_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "<<=");
            case this.tok.T_SR_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), ">>=");
            case this.tok.T_COALESCE_EQUAL:
              return _3 && this.error("VARIABLE"), t3("assign", e3, this.next().read_expr(), "??=");
            case this.tok.T_INC:
              return _3 && this.error("VARIABLE"), this.next(), t3("post", "+", e3);
            case this.tok.T_DEC:
              return _3 && this.error("VARIABLE"), this.next(), t3("post", "-", e3);
            default:
              t3.destroy(e3);
          }
        } else {
          if (this.is("SCALAR")) {
            if (t3 = this.node(), (e3 = this.read_scalar()).kind === "array" && e3.shortForm && this.token === "=") {
              var d3 = this.convertToList(e3);
              return e3.loc && (d3.loc = e3.loc), t3("assign", d3, this.next().read_expr(), "=");
            }
            return t3.destroy(e3), this.handleDereferencable(e3);
          }
          this.error("EXPR"), this.next();
        }
        return e3;
      }, convertToList: function(t3) {
        var e3 = this, i3 = t3.items.map(function(t4) {
          return t4.value && t4.value.kind === "array" && t4.value.shortForm && (t4.value = e3.convertToList(t4.value)), t4;
        }), n3 = this.node("list")(i3, true);
        return t3.loc && (n3.loc = t3.loc), t3.leadingComments && (n3.leadingComments = t3.leadingComments), t3.trailingComments && (n3.trailingComments = t3.trailingComments), n3;
      }, read_assignref: function(t3, e3) {
        var i3;
        return this.next(), this.token === this.tok.T_NEW ? (this.version >= 700 && this.error(), i3 = this.read_new_expr()) : i3 = this.read_variable(false, false), t3("assignref", e3, i3);
      }, read_inline_function: function(t3, e3) {
        if (this.token === this.tok.T_FUNCTION) {
          var i3 = this.read_function(true, t3, e3);
          return i3.attrGroups = e3, i3;
        }
        !this.version >= 704 && this.raiseError("Arrow Functions are not allowed");
        var n3 = this.node("arrowfunc");
        this.expect(this.tok.T_FN) && this.next();
        var s3 = this.is_reference();
        this.expect("(") && this.next();
        var r3 = this.read_parameter_list();
        this.expect(")") && this.next();
        var o3 = false, a3 = null;
        this.token === ":" && (this.next().token === "?" && (o3 = true, this.next()), a3 = this.read_types()), this.expect(this.tok.T_DOUBLE_ARROW) && this.next();
        var h3 = n3(r3, s3, this.read_expr(), a3, o3, !!t3);
        return h3.attrGroups = e3, h3;
      }, read_match_expression: function() {
        var t3 = this.node("match");
        this.expect(this.tok.T_MATCH) && this.next(), this.version < 800 && this.raiseError("Match statements are not allowed before PHP 8");
        var e3, i3;
        return this.expect("(") && this.next(), e3 = this.read_expr(), this.expect(")") && this.next(), this.expect("{") && this.next(), i3 = this.read_match_arms(), this.expect("}") && this.next(), t3(e3, i3);
      }, read_match_arms: function() {
        var t3 = this;
        return this.read_list(function() {
          return t3.read_match_arm();
        }, ",", true);
      }, read_match_arm: function() {
        if (this.token !== "}")
          return this.node("matcharm")(this.read_match_arm_conds(), this.read_expr());
      }, read_match_arm_conds: function() {
        var t3 = [];
        if (this.token === this.tok.T_DEFAULT)
          t3 = null, this.next();
        else
          for (t3.push(this.read_expr()); this.token === ","; ) {
            if (this.next(), this.token === this.tok.T_DOUBLE_ARROW)
              return this.next(), t3;
            t3.push(this.read_expr());
          }
        return this.expect(this.tok.T_DOUBLE_ARROW) && this.next(), t3;
      }, read_attribute() {
        var t3 = this.text(), e3 = [];
        return this.next(), this.token === "(" && (e3 = this.read_argument_list()), this.node("attribute")(t3, e3);
      }, read_attr_list() {
        var t3 = [];
        if (this.token === this.tok.T_ATTRIBUTE)
          do {
            var e3 = this.node("attrgroup")([]);
            for (this.next(), e3.attrs.push(this.read_attribute()); this.token === ","; )
              this.next(), this.token !== "]" && e3.attrs.push(this.read_attribute());
            t3.push(e3), this.expect("]"), this.next();
          } while (this.token === this.tok.T_ATTRIBUTE);
        return t3;
      }, read_new_expr: function() {
        var t3 = this.node("new");
        this.expect(this.tok.T_NEW) && this.next();
        var e3 = [], i3 = this.read_attr_list();
        if (this.token === this.tok.T_CLASS) {
          var n3 = this.node("class");
          this.next().token === "(" && (e3 = this.read_argument_list());
          var s3 = this.read_extends_from(), r3 = this.read_implements_list(), o3 = null;
          this.expect("{") && (o3 = this.next().read_class_body());
          var a3 = n3(null, s3, r3, o3, [0, 0, 0]);
          return a3.attrGroups = i3, t3(a3, e3);
        }
        var h3 = this.read_new_class_name();
        return this.token === "(" && (e3 = this.read_argument_list()), t3(h3, e3);
      }, read_new_class_name: function() {
        if (this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE) {
          var t3 = this.read_namespace_name(true);
          return this.token === this.tok.T_DOUBLE_COLON && (t3 = this.read_static_getter(t3)), t3;
        }
        if (this.is("VARIABLE"))
          return this.read_variable(true, false);
        this.expect([this.tok.T_STRING, "VARIABLE"]);
      }, handleDereferencable: function(t3) {
        for (; this.token !== this.EOF; )
          if (this.token === this.tok.T_OBJECT_OPERATOR || this.token === this.tok.T_DOUBLE_COLON)
            t3 = this.recursive_variable_chain_scan(t3, false, false, true);
          else if (this.token === this.tok.T_CURLY_OPEN || this.token === "[")
            t3 = this.read_dereferencable(t3);
          else {
            if (this.token !== "(")
              return t3;
            t3 = this.node("call")(t3, this.read_argument_list());
          }
        return t3;
      } };
      O2.read_expr, O2.read_expr_cast, O2.read_isset_variable, O2.read_isset_variables, O2.read_internal_functions_in_yacc, O2.read_optional_expr, O2.read_exit_expr, O2.read_expr_item, O2.convertToList, O2.read_assignref, O2.read_inline_function, O2.read_match_expression, O2.read_match_arms, O2.read_match_arm, O2.read_match_arm_conds, O2.read_attribute, O2.read_attr_list, O2.read_new_expr, O2.read_new_class_name, O2.handleDereferencable;
      var I2 = { is_reference: function() {
        return this.token == "&" && (this.next(), true);
      }, is_variadic: function() {
        return this.token === this.tok.T_ELLIPSIS && (this.next(), true);
      }, read_function: function(t3, e3, i3, n3) {
        var s3 = this.read_function_declaration(t3 ? 1 : e3 ? 2 : 0, e3 && e3[1] === 1, i3 || [], n3);
        return e3 && e3[2] == 1 ? (s3.parseFlags(e3), this.expect(";") && this.next()) : (this.expect("{") && (s3.body = this.read_code_block(false), s3.loc && s3.body.loc && (s3.loc.end = s3.body.loc.end)), !t3 && e3 && s3.parseFlags(e3)), s3;
      }, read_function_declaration: function(t3, e3, i3, n3) {
        var s3 = this, r3 = "function";
        t3 === 1 ? r3 = "closure" : t3 === 2 && (r3 = "method");
        var o3 = this.node(r3);
        this.expect(this.tok.T_FUNCTION) && this.next();
        var a3 = this.is_reference(), h3 = false, l3 = [], c3 = null, u3 = false;
        if (t3 !== 1) {
          var _3 = this.node("identifier");
          t3 === 2 ? this.version >= 700 ? this.token === this.tok.T_STRING || this.is("IDENTIFIER") ? (h3 = this.text(), this.next()) : this.version < 704 && this.error("IDENTIFIER") : this.token === this.tok.T_STRING ? (h3 = this.text(), this.next()) : this.error("IDENTIFIER") : this.version >= 700 ? this.token === this.tok.T_STRING ? (h3 = this.text(), this.next()) : this.version >= 704 ? this.expect("(") || this.next() : (this.error(this.tok.T_STRING), this.next()) : (this.expect(this.tok.T_STRING) && (h3 = this.text()), this.next()), h3 = _3(h3);
        }
        this.expect("(") && this.next();
        var d3 = this.read_parameter_list();
        this.expect(")") && this.next(), t3 === 1 && (l3 = this.read_lexical_vars()), this.token === ":" && (this.next().token === "?" && (u3 = true, this.next()), c3 = this.read_types());
        var p3 = function(t4) {
          return t4.attrGroups = i3 || [], n3 && t4.loc && (t4.loc.start = n3, t4.loc.source && (t4.loc.source = s3.lexer._input.substr(t4.loc.start.offset, t4.loc.end.offset - t4.loc.start.offset))), t4;
        };
        return p3(t3 === 1 ? o3(d3, a3, l3, c3, u3, e3) : o3(h3, d3, a3, c3, u3));
      }, read_lexical_vars: function() {
        var t3 = [];
        return this.token === this.tok.T_USE && (this.next(), this.expect("(") && this.next(), t3 = this.read_lexical_var_list(), this.expect(")") && this.next()), t3;
      }, read_list_with_dangling_comma: function(t3) {
        for (var e3 = []; this.token != this.EOF; ) {
          if (e3.push(t3()), this.token != ",") {
            if (this.token == ")")
              break;
            this.error([",", ")"]);
            break;
          }
          if (this.next(), this.version >= 800 && this.token === ")")
            return e3;
        }
        return e3;
      }, read_lexical_var_list: function() {
        return this.read_list_with_dangling_comma(this.read_lexical_var.bind(this));
      }, read_lexical_var: function() {
        if (this.token === "&")
          return this.read_byref(this.read_lexical_var.bind(this));
        var t3 = this.node("variable");
        this.expect(this.tok.T_VARIABLE);
        var e3 = this.text().substring(1);
        return this.next(), t3(e3, false);
      }, read_parameter_list: function() {
        return this.token != ")" ? this.read_list_with_dangling_comma(this.read_parameter.bind(this)) : [];
      }, read_parameter: function() {
        var t3, e3 = this.node("parameter"), i3 = null, n3 = null, s3 = false, r3 = [];
        this.token === this.tok.T_ATTRIBUTE && (r3 = this.read_attr_list());
        var o3 = this.read_promoted();
        this.token === "?" && (this.next(), s3 = true), t3 = this.read_types(), s3 && !t3 && this.raiseError("Expecting a type definition combined with nullable operator");
        var a3 = this.is_reference(), h3 = this.is_variadic();
        if (this.expect(this.tok.T_VARIABLE)) {
          i3 = this.node("identifier");
          var l3 = this.text().substring(1);
          this.next(), i3 = i3(l3);
        }
        this.token == "=" && (n3 = this.next().read_expr());
        var c3 = e3(i3, t3, n3, a3, h3, s3, o3);
        return r3 && (c3.attrGroups = r3), c3;
      }, read_types() {
        var t3 = [], e3 = this.node("uniontype"), i3 = this.read_type();
        if (!i3)
          return null;
        for (t3.push(i3); this.token === "|"; )
          this.next(), i3 = this.read_type(), t3.push(i3);
        return t3.length === 1 ? t3[0] : e3(t3);
      }, read_promoted() {
        return this.token === this.tok.T_PUBLIC ? (this.next(), 1) : this.token === this.tok.T_PROTECTED ? (this.next(), 2) : this.token === this.tok.T_PRIVATE ? (this.next(), 4) : 0;
      }, read_argument_list: function() {
        var t3 = [];
        return this.expect("(") && this.next(), this.token !== ")" && (t3 = this.read_non_empty_argument_list()), this.expect(")") && this.next(), t3;
      }, read_non_empty_argument_list: function() {
        var t3 = false;
        return this.read_function_list(function() {
          var e3 = this.read_argument();
          return e3 && (t3 && this.raiseError("Unexpected argument after a variadic argument"), e3.kind === "variadic" && (t3 = true)), e3;
        }.bind(this), ",");
      }, read_argument: function() {
        if (this.token === this.tok.T_ELLIPSIS)
          return this.node("variadic")(this.next().read_expr());
        if (this.token === this.tok.T_STRING || Object.values(this.lexer.keywords).includes(this.token)) {
          var t3 = this.lexer.getState(), e3 = this.lexer.lex();
          if (this.lexer.setState(t3), e3 === ":")
            return this.version < 800 && this.raiseError("PHP 8+ is required to use named arguments"), this.node("namedargument")(this.text(), this.next().next().read_expr());
        }
        return this.read_expr();
      }, read_type: function() {
        var t3 = this.node();
        if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {
          var e3 = this.text();
          return this.next(), t3("typereference", e3.toLowerCase(), e3);
        }
        if (this.token === this.tok.T_STRING || this.token === this.tok.T_STATIC) {
          var i3 = this.text(), n3 = [this.token, this.lexer.getState()];
          return this.next(), this.token !== this.tok.T_NS_SEPARATOR && this.ast.typereference.types.indexOf(i3.toLowerCase()) > -1 ? t3("typereference", i3.toLowerCase(), i3) : (this.lexer.tokens.push(n3), this.next(), t3.destroy(), this.read_namespace_name());
        }
        return this.token === this.tok.T_NAMESPACE || this.token === this.tok.T_NS_SEPARATOR ? (t3.destroy(), this.read_namespace_name()) : (t3.destroy(), null);
      } };
      I2.is_reference, I2.is_variadic, I2.read_function, I2.read_function_declaration, I2.read_lexical_vars, I2.read_list_with_dangling_comma, I2.read_lexical_var_list, I2.read_lexical_var, I2.read_parameter_list, I2.read_parameter, I2.read_types, I2.read_promoted, I2.read_argument_list, I2.read_non_empty_argument_list, I2.read_argument, I2.read_type;
      var R2 = { read_if: function() {
        var t3 = this.node("if"), e3 = this.next().read_if_expr(), i3 = null, n3 = null, s3 = false;
        if (this.token === ":") {
          s3 = true, this.next(), i3 = this.node("block");
          for (var r3 = []; this.token !== this.EOF && this.token !== this.tok.T_ENDIF; ) {
            if (this.token === this.tok.T_ELSEIF) {
              n3 = this.read_elseif_short();
              break;
            }
            if (this.token === this.tok.T_ELSE) {
              n3 = this.read_else_short();
              break;
            }
            r3.push(this.read_inner_statement());
          }
          i3 = i3(null, r3), this.expect(this.tok.T_ENDIF) && this.next(), this.expectEndOfStatement();
        } else
          i3 = this.read_statement(), this.token === this.tok.T_ELSEIF ? n3 = this.read_if() : this.token === this.tok.T_ELSE && (n3 = this.next().read_statement());
        return t3(e3, i3, n3, s3);
      }, read_if_expr: function() {
        this.expect("(") && this.next();
        var t3 = this.read_expr();
        return this.expect(")") && this.next(), t3;
      }, read_elseif_short: function() {
        var t3 = null, e3 = this.node("if"), i3 = this.next().read_if_expr();
        this.expect(":") && this.next();
        for (var n3 = this.node("block"), s3 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; ) {
          if (this.token === this.tok.T_ELSEIF) {
            t3 = this.read_elseif_short();
            break;
          }
          if (this.token === this.tok.T_ELSE) {
            t3 = this.read_else_short();
            break;
          }
          s3.push(this.read_inner_statement());
        }
        return e3(i3, n3(null, s3), t3, true);
      }, read_else_short: function() {
        this.next().expect(":") && this.next();
        for (var t3 = this.node("block"), e3 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; )
          e3.push(this.read_inner_statement());
        return t3(null, e3);
      } };
      R2.read_if, R2.read_if_expr, R2.read_elseif_short, R2.read_else_short;
      var w2 = { read_while: function() {
        var t3 = this.node("while");
        this.expect(this.tok.T_WHILE) && this.next();
        var e3, i3 = null, n3 = false;
        return this.expect("(") && this.next(), e3 = this.read_expr(), this.expect(")") && this.next(), this.token === ":" ? (n3 = true, i3 = this.read_short_form(this.tok.T_ENDWHILE)) : i3 = this.read_statement(), t3(e3, i3, n3);
      }, read_do: function() {
        var t3 = this.node("do");
        this.expect(this.tok.T_DO) && this.next();
        var e3, i3 = null;
        return e3 = this.read_statement(), this.expect(this.tok.T_WHILE) && (this.next().expect("(") && this.next(), i3 = this.read_expr(), this.expect(")") && this.next(), this.expect(";") && this.next()), t3(i3, e3);
      }, read_for: function() {
        var t3 = this.node("for");
        this.expect(this.tok.T_FOR) && this.next();
        var e3 = [], i3 = [], n3 = [], s3 = null, r3 = false;
        return this.expect("(") && this.next(), this.token !== ";" ? (e3 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), this.token !== ";" ? (i3 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), this.token !== ")" ? (n3 = this.read_list(this.read_expr, ","), this.expect(")") && this.next()) : this.next(), this.token === ":" ? (r3 = true, s3 = this.read_short_form(this.tok.T_ENDFOR)) : s3 = this.read_statement(), t3(e3, i3, n3, s3, r3);
      }, read_foreach: function() {
        var t3 = this.node("foreach");
        this.expect(this.tok.T_FOREACH) && this.next();
        var e3, i3 = null, n3 = null, s3 = null, r3 = false;
        return this.expect("(") && this.next(), e3 = this.read_expr(), this.expect(this.tok.T_AS) && (this.next(), n3 = this.read_foreach_variable(), this.token === this.tok.T_DOUBLE_ARROW && (i3 = n3, n3 = this.next().read_foreach_variable())), i3 && i3.kind === "list" && this.raiseError("Fatal Error : Cannot use list as key element"), this.expect(")") && this.next(), this.token === ":" ? (r3 = true, s3 = this.read_short_form(this.tok.T_ENDFOREACH)) : s3 = this.read_statement(), t3(e3, i3, n3, s3, r3);
      }, read_foreach_variable: function() {
        if (this.token === this.tok.T_LIST || this.token === "[") {
          var t3 = this.token === "[", e3 = this.node("list");
          this.next(), !t3 && this.expect("(") && this.next();
          var i3 = this.read_array_pair_list(t3);
          return this.expect(t3 ? "]" : ")") && this.next(), e3(i3, t3);
        }
        return this.read_variable(false, false);
      } };
      w2.read_while, w2.read_do, w2.read_for, w2.read_foreach, w2.read_foreach_variable;
      var D2 = { read_start: function() {
        return this.token == this.tok.T_NAMESPACE ? this.read_namespace() : this.read_top_statement();
      } };
      D2.read_start;
      var P2 = { read_namespace: function() {
        var t3, e3, i3 = this.node("namespace");
        return this.expect(this.tok.T_NAMESPACE) && this.next(), e3 = this.token == "{" ? { name: [""] } : this.read_namespace_name(), this.currentNamespace = e3, this.token == ";" ? (this.currentNamespace = e3, t3 = this.next().read_top_statements(), this.expect(this.EOF), i3(e3.name, t3, false)) : this.token == "{" ? (this.currentNamespace = e3, t3 = this.next().read_top_statements(), this.expect("}") && this.next(), t3.length === 0 && this.extractDoc && this._docs.length > this._docIndex && t3.push(this.node("noop")()), i3(e3.name, t3, true)) : this.token === "(" ? (e3.resolution = this.ast.reference.RELATIVE_NAME, e3.name = e3.name.substring(1), i3.destroy(), this.node("call")(e3, this.read_argument_list())) : (this.error(["{", ";"]), this.currentNamespace = e3, t3 = this.read_top_statements(), this.expect(this.EOF), i3(e3, t3, false));
      }, read_namespace_name: function(t3) {
        var e3 = this.node(), i3 = false;
        this.token === this.tok.T_NAMESPACE && (this.next().expect(this.tok.T_NS_SEPARATOR) && this.next(), i3 = true);
        var n3 = this.read_list(this.tok.T_STRING, this.tok.T_NS_SEPARATOR, true);
        if (!i3 && n3.length === 1 && (t3 || this.token !== "(")) {
          if (n3[0].toLowerCase() === "parent")
            return e3("parentreference", n3[0]);
          if (n3[0].toLowerCase() === "self")
            return e3("selfreference", n3[0]);
        }
        return e3("name", n3, i3);
      }, read_use_statement: function() {
        var t3 = this.node("usegroup"), e3 = [], i3 = null;
        this.expect(this.tok.T_USE) && this.next();
        var n3 = this.read_use_type();
        return e3.push(this.read_use_declaration(false)), this.token === "," ? e3 = e3.concat(this.next().read_use_declarations(false)) : this.token === "{" && (i3 = e3[0].name, e3 = this.next().read_use_declarations(n3 === null), this.expect("}") && this.next()), t3 = t3(i3, n3, e3), this.expect(";") && this.next(), t3;
      }, read_class_name_reference: function() {
        return this.read_variable(true, false);
      }, read_use_declaration: function(t3) {
        var e3 = this.node("useitem"), i3 = null;
        t3 && (i3 = this.read_use_type());
        var n3 = this.read_namespace_name(), s3 = this.read_use_alias();
        return e3(n3.name, s3, i3);
      }, read_use_declarations: function(t3) {
        for (var e3 = [this.read_use_declaration(t3)]; this.token === ","; ) {
          if (this.next(), t3) {
            if (this.token !== this.tok.T_FUNCTION && this.token !== this.tok.T_CONST && this.token !== this.tok.T_STRING)
              break;
          } else if (this.token !== this.tok.T_STRING && this.token !== this.tok.T_NS_SEPARATOR)
            break;
          e3.push(this.read_use_declaration(t3));
        }
        return e3;
      }, read_use_alias: function() {
        var t3 = null;
        if (this.token === this.tok.T_AS && this.next().expect(this.tok.T_STRING)) {
          var e3 = this.node("identifier"), i3 = this.text();
          this.next(), t3 = e3(i3);
        }
        return t3;
      }, read_use_type: function() {
        return this.token === this.tok.T_FUNCTION ? (this.next(), this.ast.useitem.TYPE_FUNCTION) : this.token === this.tok.T_CONST ? (this.next(), this.ast.useitem.TYPE_CONST) : null;
      } };
      P2.read_namespace, P2.read_namespace_name, P2.read_use_statement, P2.read_class_name_reference, P2.read_use_declaration, P2.read_use_declarations, P2.read_use_alias, P2.read_use_type;
      var U2 = { "\\": "\\", $: "$", n: "\n", r: "\r", t: "	", f: String.fromCharCode(12), v: String.fromCharCode(11), e: String.fromCharCode(27) }, B2 = { resolve_special_chars: function(t3, e3) {
        return e3 ? t3.replace(/\\"/, '"').replace(/\\([\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g, function(t4, e4, i3) {
          return U2[e4] ? U2[e4] : e4[0] === "x" || e4[0] === "X" ? String.fromCodePoint(parseInt(e4.substr(1), 16)) : e4[0] === "u" ? String.fromCodePoint(parseInt(i3, 16)) : String.fromCodePoint(parseInt(e4, 8));
        }) : t3.replace(/\\\\/g, "\\").replace(/\\'/g, "'");
      }, remove_heredoc_leading_whitespace_chars: function(t3, e3, i3, n3) {
        if (e3 === 0)
          return t3;
        this.check_heredoc_indentation_level(t3, e3, i3, n3);
        var s3 = i3 ? " " : "	", r3 = new RegExp("\\n".concat(s3, "{").concat(e3, "}"), "g"), o3 = new RegExp("^".concat(s3, "{").concat(e3, "}"));
        return n3 && (t3 = t3.replace(o3, "")), t3.replace(r3, "\n");
      }, check_heredoc_indentation_level: function(t3, e3, i3, n3) {
        var s3 = t3.length, r3 = 0, o3 = 0, a3 = true, h3 = i3 ? " " : "	", l3 = false;
        if (!n3) {
          if ((r3 = t3.indexOf("\n")) === -1)
            return;
          r3++;
        }
        for (; r3 < s3; )
          a3 ? t3[r3] === h3 ? o3++ : l3 = true : a3 = false, t3[r3] !== "\n" && l3 && o3 < e3 ? this.raiseError("Invalid body indentation level (expecting an indentation at least ".concat(e3, ")")) : l3 = false, t3[r3] === "\n" && (a3 = true, o3 = 0), r3++;
      }, read_dereferencable_scalar: function() {
        var t3 = null;
        switch (this.token) {
          case this.tok.T_CONSTANT_ENCAPSED_STRING:
            var e3 = this.node("string"), i3 = this.text(), n3 = 0;
            i3[0] !== "b" && i3[0] !== "B" || (n3 = 1);
            var s3 = i3[n3] === '"';
            this.next(), e3 = e3(s3, this.resolve_special_chars(i3.substring(n3 + 1, i3.length - 1), s3), n3 === 1, i3), t3 = this.token === this.tok.T_DOUBLE_COLON ? this.read_static_getter(e3) : e3;
            break;
          case this.tok.T_ARRAY:
          case "[":
            t3 = this.read_array();
        }
        return t3;
      }, read_scalar: function() {
        if (this.is("T_MAGIC_CONST"))
          return this.get_magic_constant();
        var t3, e3;
        switch (this.token) {
          case this.tok.T_LNUMBER:
          case this.tok.T_DNUMBER:
            var i3 = this.node("number");
            return t3 = this.text(), this.next(), i3(t3, null);
          case this.tok.T_START_HEREDOC:
            if (this.lexer.curCondition === "ST_NOWDOC") {
              var n3 = this.lexer.yylloc.first_offset;
              e3 = this.node("nowdoc"), t3 = this.next().text(), this.lexer.heredoc_label.indentation > 0 && (t3 = t3.substring(0, t3.length - this.lexer.heredoc_label.indentation));
              var s3 = t3[t3.length - 1];
              s3 === "\n" ? t3 = t3[t3.length - 2] === "\r" ? t3.substring(0, t3.length - 2) : t3.substring(0, t3.length - 1) : s3 === "\r" && (t3 = t3.substring(0, t3.length - 1)), this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next(), this.expect(this.tok.T_END_HEREDOC) && this.next();
              var r3 = this.lexer._input.substring(n3, this.lexer.yylloc.first_offset);
              return e3 = e3(this.remove_heredoc_leading_whitespace_chars(t3, this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node), r3, this.lexer.heredoc_label.label);
            }
            return this.read_encapsed_string(this.tok.T_END_HEREDOC);
          case '"':
            return this.read_encapsed_string('"');
          case 'b"':
          case 'B"':
            return this.read_encapsed_string('"', true);
          case this.tok.T_CONSTANT_ENCAPSED_STRING:
          case this.tok.T_ARRAY:
          case "[":
            return this.read_dereferencable_scalar();
          default:
            var o3 = this.error("SCALAR");
            return this.next(), o3;
        }
      }, read_dereferencable: function(t3) {
        var e3, i3, n3 = this.node("offsetlookup");
        return this.token === "[" ? (i3 = this.next().read_expr(), this.expect("]") && this.next(), e3 = n3(t3, i3)) : this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES && (e3 = n3(t3, i3 = this.read_encapsed_string_item(false))), e3;
      }, read_encapsed_string_item: function(t3) {
        var e3, i3, n3, s3 = this.node("encapsedpart"), r3 = null, o3 = false, a3 = this.node();
        if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {
          var h3 = this.text();
          this.next(), a3 = a3("string", false, this.version >= 703 && !this.lexer.heredoc_label.finished ? this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(h3, t3), this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node) : h3, false, h3);
        } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {
          if (r3 = "simple", o3 = true, n3 = null, this.next().token === this.tok.T_STRING_VARNAME) {
            n3 = this.node("variable");
            var l3 = this.text();
            this.next(), this.token === "[" ? (n3 = n3(l3, false), i3 = this.node("offsetlookup"), e3 = this.next().read_expr(), this.expect("]") && this.next(), a3 = i3(n3, e3)) : a3 = n3(l3, false);
          } else
            a3 = a3("variable", this.read_expr(), false);
          this.expect("}") && this.next();
        } else if (this.token === this.tok.T_CURLY_OPEN)
          r3 = "complex", a3.destroy(), a3 = this.next().read_variable(false, false), this.expect("}") && this.next();
        else if (this.token === this.tok.T_VARIABLE) {
          if (r3 = "simple", a3.destroy(), a3 = this.read_simple_variable(), this.token === "[" && (i3 = this.node("offsetlookup"), e3 = this.next().read_encaps_var_offset(), this.expect("]") && this.next(), a3 = i3(a3, e3)), this.token === this.tok.T_OBJECT_OPERATOR) {
            i3 = this.node("propertylookup"), this.next().expect(this.tok.T_STRING);
            var c3 = this.node("identifier");
            n3 = this.text(), this.next(), a3 = i3(a3, c3(n3));
          }
        } else {
          this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);
          var u3 = this.text();
          this.next(), a3.destroy(), a3 = a3("string", false, u3, false, u3);
        }
        return this.lexer.heredoc_label.first_encaps_node = false, s3(a3, r3, o3);
      }, read_encapsed_string: function(t3) {
        var e3 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], i3 = this.lexer.yylloc.first_offset, n3 = this.node("encapsed");
        this.next();
        var s3 = this.lexer.yylloc.prev_offset - (e3 ? 1 : 0), r3 = [], o3 = null;
        for (o3 = t3 === "`" ? this.ast.encapsed.TYPE_SHELL : t3 === '"' ? this.ast.encapsed.TYPE_STRING : this.ast.encapsed.TYPE_HEREDOC; this.token !== t3 && this.token !== this.EOF; )
          r3.push(this.read_encapsed_string_item(true));
        if (r3.length > 0 && r3[r3.length - 1].kind === "encapsedpart" && r3[r3.length - 1].expression.kind === "string") {
          var a3 = r3[r3.length - 1].expression, h3 = a3.value[a3.value.length - 1];
          h3 === "\n" ? a3.value[a3.value.length - 2] === "\r" ? a3.value = a3.value.substring(0, a3.value.length - 2) : a3.value = a3.value.substring(0, a3.value.length - 1) : h3 === "\r" && (a3.value = a3.value.substring(0, a3.value.length - 1));
        }
        this.expect(t3) && this.next();
        var l3 = this.lexer._input.substring(o3 === "heredoc" ? i3 : s3 - 1, this.lexer.yylloc.first_offset);
        return n3 = n3(r3, l3, o3), t3 === this.tok.T_END_HEREDOC && (n3.label = this.lexer.heredoc_label.label, this.lexer.heredoc_label.finished = true), n3;
      }, get_magic_constant: function() {
        var t3 = this.node("magic"), e3 = this.text();
        return this.next(), t3(e3.toUpperCase(), e3);
      } };
      B2.resolve_special_chars, B2.remove_heredoc_leading_whitespace_chars, B2.check_heredoc_indentation_level, B2.read_dereferencable_scalar, B2.read_scalar, B2.read_dereferencable, B2.read_encapsed_string_item, B2.read_encapsed_string, B2.get_magic_constant;
      var M2 = { read_top_statements: function() {
        for (var t3 = []; this.token !== this.EOF && this.token !== "}"; ) {
          var e3 = this.read_top_statement();
          e3 && (Array.isArray(e3) ? t3 = t3.concat(e3) : t3.push(e3));
        }
        return t3;
      }, read_top_statement: function() {
        var t3 = [];
        switch (this.token === this.tok.T_ATTRIBUTE && (t3 = this.read_attr_list()), this.token) {
          case this.tok.T_FUNCTION:
            return this.read_function(false, false, t3);
          case this.tok.T_ABSTRACT:
          case this.tok.T_FINAL:
          case this.tok.T_CLASS:
            return this.read_class_declaration_statement(t3);
          case this.tok.T_INTERFACE:
            return this.read_interface_declaration_statement(t3);
          case this.tok.T_TRAIT:
            return this.read_trait_declaration_statement();
          case this.tok.T_USE:
            return this.read_use_statement();
          case this.tok.T_CONST:
            var e3 = this.node("constantstatement"), i3 = this.next().read_const_list();
            return this.expectEndOfStatement(), e3(null, i3);
          case this.tok.T_NAMESPACE:
            return this.read_namespace();
          case this.tok.T_HALT_COMPILER:
            var n3 = this.node("halt");
            return this.next().expect("(") && this.next(), this.expect(")") && this.next(), this.expect(";"), this.lexer.done = true, n3(this.lexer._input.substring(this.lexer.offset));
          default:
            return this.read_statement();
        }
      }, read_inner_statements: function() {
        for (var t3 = []; this.token != this.EOF && this.token !== "}"; ) {
          var e3 = this.read_inner_statement();
          e3 && (Array.isArray(e3) ? t3 = t3.concat(e3) : t3.push(e3));
        }
        return t3;
      }, read_const_list: function() {
        return this.read_list(function() {
          this.expect(this.tok.T_STRING);
          var t3 = this.node("constant"), e3 = this.node("identifier"), i3 = this.text();
          return this.next(), e3 = e3(i3), this.expect("=") ? t3(e3, this.next().read_expr()) : t3(e3, null);
        }, ",", false);
      }, read_declare_list: function() {
        for (var t3 = []; this.token != this.EOF && this.token !== ")"; ) {
          this.expect(this.tok.T_STRING);
          var e3 = this.node("declaredirective"), i3 = this.node("identifier"), n3 = this.text();
          this.next(), i3 = i3(n3);
          var s3 = null;
          if (this.expect("=") && (s3 = this.next().read_expr()), t3.push(e3(i3, s3)), this.token !== ",")
            break;
          this.next();
        }
        return t3;
      }, read_inner_statement: function() {
        var t3 = [];
        switch (this.token === this.tok.T_ATTRIBUTE && (t3 = this.read_attr_list()), this.token) {
          case this.tok.T_FUNCTION:
            var e3 = this.read_function(false, false);
            return e3.attrGroups = t3, e3;
          case this.tok.T_ABSTRACT:
          case this.tok.T_FINAL:
          case this.tok.T_CLASS:
            return this.read_class_declaration_statement();
          case this.tok.T_INTERFACE:
            return this.read_interface_declaration_statement();
          case this.tok.T_TRAIT:
            return this.read_trait_declaration_statement();
          case this.tok.T_HALT_COMPILER:
            this.raiseError("__HALT_COMPILER() can only be used from the outermost scope");
            var i3 = this.node("halt");
            return this.next().expect("(") && this.next(), this.expect(")") && this.next(), i3 = i3(this.lexer._input.substring(this.lexer.offset)), this.expect(";") && this.next(), i3;
          default:
            return this.read_statement();
        }
      }, read_statement: function() {
        switch (this.token) {
          case "{":
            return this.read_code_block(false);
          case this.tok.T_IF:
            return this.read_if();
          case this.tok.T_SWITCH:
            return this.read_switch();
          case this.tok.T_FOR:
            return this.read_for();
          case this.tok.T_FOREACH:
            return this.read_foreach();
          case this.tok.T_WHILE:
            return this.read_while();
          case this.tok.T_DO:
            return this.read_do();
          case this.tok.T_COMMENT:
            return this.read_comment();
          case this.tok.T_DOC_COMMENT:
            return this.read_doc_comment();
          case this.tok.T_RETURN:
            var t3 = this.node("return");
            this.next();
            var e3 = this.read_optional_expr(";");
            return this.expectEndOfStatement(), t3(e3);
          case this.tok.T_BREAK:
          case this.tok.T_CONTINUE:
            var i3 = this.node(this.token === this.tok.T_CONTINUE ? "continue" : "break");
            this.next();
            var n3 = this.read_optional_expr(";");
            return this.expectEndOfStatement(), i3(n3);
          case this.tok.T_GLOBAL:
            var s3 = this.node("global"), r3 = this.next().read_list(this.read_simple_variable, ",");
            return this.expectEndOfStatement(), s3(r3);
          case this.tok.T_STATIC:
            var o3 = [this.token, this.lexer.getState()], a3 = this.node();
            if (this.next().token === this.tok.T_DOUBLE_COLON) {
              this.lexer.tokens.push(o3);
              var h3 = this.next().read_expr();
              return this.expectEndOfStatement(h3), a3("expressionstatement", h3);
            }
            if (this.token === this.tok.T_FUNCTION)
              return this.read_function(true, [0, 1, 0]);
            var l3 = this.read_variable_declarations();
            return this.expectEndOfStatement(), a3("static", l3);
          case this.tok.T_ECHO:
            var c3 = this.node("echo"), u3 = this.text(), _3 = u3 === "<?=" || u3 === "<%=", d3 = this.next().read_function_list(this.read_expr, ",");
            return this.expectEndOfStatement(), c3(d3, _3);
          case this.tok.T_INLINE_HTML:
            var p3 = this.text(), f3 = this.lexer.yylloc.first_offset > 0 ? this.lexer._input[this.lexer.yylloc.first_offset - 1] : null, T3 = f3 === "\r" || f3 === "\n";
            T3 && f3 === "\n" && this.lexer.yylloc.first_offset > 1 && this.lexer._input[this.lexer.yylloc.first_offset - 2] === "\r" && (f3 = "\r\n");
            var k3 = this.node("inline");
            return this.next(), k3(p3, T3 ? f3 + p3 : p3);
          case this.tok.T_UNSET:
            var m3 = this.node("unset");
            this.next().expect("(") && this.next();
            var E3 = this.read_function_list(this.read_variable, ",");
            return this.expect(")") && this.next(), this.expect(";") && this.next(), m3(E3);
          case this.tok.T_DECLARE:
            var x3, y3 = this.node("declare"), v3 = [];
            this.next().expect("(") && this.next();
            var A3 = this.read_declare_list();
            if (this.expect(")") && this.next(), this.token === ":") {
              for (this.next(); this.token != this.EOF && this.token !== this.tok.T_ENDDECLARE; )
                v3.push(this.read_top_statement());
              v3.length === 0 && this.extractDoc && this._docs.length > this._docIndex && v3.push(this.node("noop")()), this.expect(this.tok.T_ENDDECLARE) && this.next(), this.expectEndOfStatement(), x3 = this.ast.declare.MODE_SHORT;
            } else if (this.token === "{") {
              for (this.next(); this.token != this.EOF && this.token !== "}"; )
                v3.push(this.read_top_statement());
              v3.length === 0 && this.extractDoc && this._docs.length > this._docIndex && v3.push(this.node("noop")()), this.expect("}") && this.next(), x3 = this.ast.declare.MODE_BLOCK;
            } else
              this.expect(";") && this.next(), x3 = this.ast.declare.MODE_NONE;
            return y3(A3, v3, x3);
          case this.tok.T_TRY:
            return this.read_try();
          case this.tok.T_THROW:
            var g3 = this.node("throw"), N3 = this.next().read_expr();
            return this.expectEndOfStatement(), g3(N3);
          case ";":
            return this.next(), null;
          case this.tok.T_STRING:
            var C3 = this.node(), S3 = [this.token, this.lexer.getState()], b3 = this.text(), L3 = this.node("identifier");
            if (this.next().token === ":")
              return L3 = L3(b3), this.next(), C3("label", L3);
            L3.destroy(), C3.destroy(), this.lexer.tokens.push(S3);
            var O3 = this.node("expressionstatement"), I3 = this.next().read_expr();
            return this.expectEndOfStatement(I3), O3(I3);
          case this.tok.T_GOTO:
            var R3 = this.node("goto"), w3 = null;
            if (this.next().expect(this.tok.T_STRING)) {
              w3 = this.node("identifier");
              var D3 = this.text();
              this.next(), w3 = w3(D3), this.expectEndOfStatement();
            }
            return R3(w3);
          default:
            var P3 = this.node("expressionstatement"), U3 = this.read_expr();
            return this.expectEndOfStatement(U3), P3(U3);
        }
      }, read_code_block: function(t3) {
        var e3 = this.node("block");
        this.expect("{") && this.next();
        var i3 = t3 ? this.read_top_statements() : this.read_inner_statements();
        return i3.length === 0 && this.extractDoc && this._docs.length > this._docIndex && i3.push(this.node("noop")()), this.expect("}") && this.next(), e3(null, i3);
      } };
      M2.read_top_statements, M2.read_top_statement, M2.read_inner_statements, M2.read_const_list, M2.read_declare_list, M2.read_inner_statement, M2.read_statement, M2.read_code_block;
      var F2 = { read_switch: function() {
        var t3 = this.node("switch");
        this.expect(this.tok.T_SWITCH) && this.next(), this.expect("(") && this.next();
        var e3 = this.read_expr();
        this.expect(")") && this.next();
        var i3 = this.token === ":";
        return t3(e3, this.read_switch_case_list(), i3);
      }, read_switch_case_list: function() {
        var t3 = null, e3 = this.node("block"), i3 = [];
        for (this.token === "{" ? t3 = "}" : this.token === ":" ? t3 = this.tok.T_ENDSWITCH : this.expect(["{", ":"]), this.next(), this.token === ";" && this.next(); this.token !== this.EOF && this.token !== t3; )
          i3.push(this.read_case_list(t3));
        return i3.length === 0 && this.extractDoc && this._docs.length > this._docIndex && i3.push(this.node("noop")()), this.expect(t3) && this.next(), t3 === this.tok.T_ENDSWITCH && this.expectEndOfStatement(), e3(null, i3);
      }, read_case_list: function(t3) {
        var e3 = this.node("case"), i3 = null;
        this.token === this.tok.T_CASE ? i3 = this.next().read_expr() : this.token === this.tok.T_DEFAULT ? this.next() : this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]), this.expect([":", ";"]) && this.next();
        for (var n3 = this.node("block"), s3 = []; this.token !== this.EOF && this.token !== t3 && this.token !== this.tok.T_CASE && this.token !== this.tok.T_DEFAULT; )
          s3.push(this.read_inner_statement());
        return e3(i3, n3(null, s3));
      } };
      F2.read_switch, F2.read_switch_case_list, F2.read_case_list;
      var H2 = { read_try: function() {
        this.expect(this.tok.T_TRY);
        for (var t3 = this.node("try"), e3 = null, i3 = [], n3 = this.next().read_statement(); this.token === this.tok.T_CATCH; ) {
          var s3 = this.node("catch");
          this.next().expect("(") && this.next();
          var r3 = this.read_list(this.read_namespace_name, "|", false), o3 = null;
          this.token === this.tok.T_VARIABLE && (o3 = this.read_variable(true, false)), this.expect(")"), i3.push(s3(this.next().read_statement(), r3, o3));
        }
        return this.token === this.tok.T_FINALLY && (e3 = this.next().read_statement()), t3(n3, i3, e3);
      } };
      H2.read_try;
      var G2 = { read_short_form: function(t3) {
        var e3 = this.node("block"), i3 = [];
        for (this.expect(":") && this.next(); this.token != this.EOF && this.token !== t3; )
          i3.push(this.read_inner_statement());
        return i3.length === 0 && this.extractDoc && this._docs.length > this._docIndex && i3.push(this.node("noop")()), this.expect(t3) && this.next(), this.expectEndOfStatement(), e3(null, i3);
      }, read_function_list: function(t3, e3) {
        var i3 = [];
        do {
          if (this.token == e3 && this.version >= 703 && i3.length > 0) {
            i3.push(this.node("noop")());
            break;
          }
          if (i3.push(t3.apply(this, [])), this.token != e3)
            break;
          if (this.next().token == ")" && this.version >= 703)
            break;
        } while (this.token != this.EOF);
        return i3;
      }, read_list: function(t3, e3, i3) {
        var n3 = [];
        if (this.token == e3 && (i3 && n3.push(typeof t3 == "function" ? this.node("noop")() : null), this.next()), typeof t3 == "function")
          do {
            var s3 = t3.apply(this, []);
            if (s3 && n3.push(s3), this.token != e3)
              break;
          } while (this.next().token != this.EOF);
        else {
          if (!this.expect(t3))
            return [];
          for (n3.push(this.text()); this.next().token != this.EOF && this.token == e3 && this.next().token == t3; )
            n3.push(this.text());
        }
        return n3;
      }, read_name_list: function() {
        return this.read_list(this.read_namespace_name, ",", false);
      }, read_byref: function(t3) {
        var e3 = this.node("byref");
        this.next(), e3 = e3(null);
        var i3 = t3();
        return i3 && (this.ast.swapLocations(i3, e3, i3, this), i3.byref = true), i3;
      }, read_variable_declarations: function() {
        return this.read_list(function() {
          var t3 = this.node("staticvariable"), e3 = this.node("variable");
          if (this.expect(this.tok.T_VARIABLE)) {
            var i3 = this.text().substring(1);
            this.next(), e3 = e3(i3, false);
          } else
            e3 = e3("#ERR", false);
          return this.token === "=" ? t3(e3, this.next().read_expr()) : e3;
        }, ",");
      }, read_extends_from: function() {
        return this.token === this.tok.T_EXTENDS ? this.next().read_namespace_name() : null;
      }, read_interface_extends_list: function() {
        return this.token === this.tok.T_EXTENDS ? this.next().read_name_list() : null;
      }, read_implements_list: function() {
        return this.token === this.tok.T_IMPLEMENTS ? this.next().read_name_list() : null;
      } };
      G2.read_short_form, G2.read_function_list, G2.read_list, G2.read_name_list, G2.read_byref, G2.read_variable_declarations, G2.read_extends_from, G2.read_interface_extends_list, G2.read_implements_list;
      var V2 = { read_variable: function(t3, e3) {
        var i3;
        if (this.token === "&")
          return this.read_byref(this.read_variable.bind(this, t3, e3));
        if (this.is([this.tok.T_VARIABLE, "$"]))
          i3 = this.read_reference_variable(e3);
        else if (this.is([this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE])) {
          i3 = this.node();
          var n3 = this.read_namespace_name();
          if (this.token != this.tok.T_DOUBLE_COLON && this.token != "(" && ["parentreference", "selfreference"].indexOf(n3.kind) === -1) {
            var s3 = n3.name.toLowerCase();
            s3 === "true" ? i3 = n3.destroy(i3("boolean", true, n3.name)) : s3 === "false" ? i3 = n3.destroy(i3("boolean", false, n3.name)) : s3 === "null" ? i3 = n3.destroy(i3("nullkeyword", n3.name)) : (i3.destroy(n3), i3 = n3);
          } else
            i3.destroy(n3), i3 = n3;
        } else if (this.token === this.tok.T_STATIC) {
          i3 = this.node("staticreference");
          var r3 = this.text();
          this.next(), i3 = i3(r3);
        } else
          this.expect("VARIABLE");
        return this.token === this.tok.T_DOUBLE_COLON && (i3 = this.read_static_getter(i3, e3)), this.recursive_variable_chain_scan(i3, t3, e3);
      }, read_static_getter: function(t3, e3) {
        var i3, n3, s3 = this.node("staticlookup");
        return this.next().is([this.tok.T_VARIABLE, "$"]) ? i3 = this.read_reference_variable(e3) : this.token === this.tok.T_STRING || this.token === this.tok.T_CLASS || this.version >= 700 && this.is("IDENTIFIER") ? (i3 = this.node("identifier"), n3 = this.text(), this.next(), i3 = i3(n3)) : this.token === "{" ? (i3 = this.node("literal"), n3 = this.next().read_expr(), this.expect("}") && this.next(), i3 = i3("literal", n3, null), this.expect("(")) : (this.error([this.tok.T_VARIABLE, this.tok.T_STRING]), i3 = this.node("identifier"), n3 = this.text(), this.next(), i3 = i3(n3)), s3(t3, i3);
      }, read_what: function() {
        var t3 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], e3 = null, i3 = null;
        switch (this.next().token) {
          case this.tok.T_STRING:
            e3 = this.node("identifier"), i3 = this.text(), this.next(), e3 = e3(i3), t3 && this.token === this.tok.T_OBJECT_OPERATOR && this.error();
            break;
          case this.tok.T_VARIABLE:
            e3 = this.node("variable"), i3 = this.text().substring(1), this.next(), e3 = e3(i3, false);
            break;
          case "$":
            e3 = this.node(), this.next().expect(["$", "{", this.tok.T_VARIABLE]), this.token === "{" ? (i3 = this.next().read_expr(), this.expect("}") && this.next(), e3 = e3("variable", i3, true)) : e3 = e3("variable", i3 = this.read_expr(), false);
            break;
          case "{":
            e3 = this.node("encapsedpart"), i3 = this.next().read_expr(), this.expect("}") && this.next(), e3 = e3(i3, "complex", false);
            break;
          default:
            this.error([this.tok.T_STRING, this.tok.T_VARIABLE, "$", "{"]), e3 = this.node("identifier"), i3 = this.text(), this.next(), e3 = e3(i3);
        }
        return e3;
      }, recursive_variable_chain_scan: function(t3, e3, i3) {
        var n3, s3;
        t:
          for (; this.token != this.EOF; )
            switch (this.token) {
              case "(":
                if (e3)
                  return t3;
                t3 = this.node("call")(t3, this.read_argument_list());
                break;
              case "[":
              case "{":
                var r3 = this.token === "[";
                if (n3 = this.node("offsetlookup"), this.next(), s3 = false, i3)
                  s3 = this.read_encaps_var_offset(), this.expect(r3 ? "]" : "}") && this.next();
                else
                  (r3 ? this.token !== "]" : this.token !== "}") ? (s3 = this.read_expr(), this.expect(r3 ? "]" : "}") && this.next()) : this.next();
                t3 = n3(t3, s3);
                break;
              case this.tok.T_DOUBLE_COLON:
                t3.kind === "staticlookup" && t3.offset.kind === "identifier" && this.error(), t3 = (n3 = this.node("staticlookup"))(t3, this.read_what(true));
                break;
              case this.tok.T_OBJECT_OPERATOR:
                t3 = (n3 = this.node("propertylookup"))(t3, this.read_what());
                break;
              case this.tok.T_NULLSAFE_OBJECT_OPERATOR:
                t3 = (n3 = this.node("nullsafepropertylookup"))(t3, this.read_what());
                break;
              default:
                break t;
            }
        return t3;
      }, read_encaps_var_offset: function() {
        var t3 = this.node();
        if (this.token === this.tok.T_STRING) {
          var e3 = this.text();
          this.next(), t3 = t3("identifier", e3);
        } else if (this.token === this.tok.T_NUM_STRING) {
          var i3 = this.text();
          this.next(), t3 = t3("number", i3, null);
        } else if (this.token === "-") {
          this.next();
          var n3 = -1 * this.text();
          this.expect(this.tok.T_NUM_STRING) && this.next(), t3 = t3("number", n3, null);
        } else if (this.token === this.tok.T_VARIABLE) {
          var s3 = this.text().substring(1);
          this.next(), t3 = t3("variable", s3, false);
        } else {
          this.expect([this.tok.T_STRING, this.tok.T_NUM_STRING, "-", this.tok.T_VARIABLE]);
          var r3 = this.text();
          this.next(), t3 = t3("identifier", r3);
        }
        return t3;
      }, read_reference_variable: function(t3) {
        for (var e3, i3 = this.read_simple_variable(); this.token != this.EOF; ) {
          var n3 = this.node();
          if (this.token != "{" || t3) {
            n3.destroy();
            break;
          }
          e3 = this.next().read_expr(), this.expect("}") && this.next(), i3 = n3("offsetlookup", i3, e3);
        }
        return i3;
      }, read_simple_variable: function() {
        var t3, e3 = this.node("variable");
        if (this.expect([this.tok.T_VARIABLE, "$"]) && this.token === this.tok.T_VARIABLE)
          t3 = this.text().substring(1), this.next(), e3 = e3(t3, false);
        else
          switch (this.token === "$" && this.next(), this.token) {
            case "{":
              var i3 = this.next().read_expr();
              this.expect("}") && this.next(), e3 = e3(i3, true);
              break;
            case "$":
              e3 = e3(this.read_simple_variable(), false);
              break;
            case this.tok.T_VARIABLE:
              t3 = this.text().substring(1);
              var n3 = this.node("variable");
              this.next(), e3 = e3(n3(t3, false), false);
              break;
            default:
              this.error(["{", "$", this.tok.T_VARIABLE]), t3 = this.text(), this.next(), e3 = e3(t3, false);
          }
        return e3;
      } };
      function W2(t3) {
        return t3 != "." && t3 != "," && !isNaN(parseFloat(t3)) && isFinite(t3);
      }
      V2.read_variable, V2.read_static_getter, V2.read_what, V2.recursive_variable_chain_scan, V2.read_encaps_var_offset, V2.read_reference_variable, V2.read_simple_variable;
      var Q2 = function(t3, e3) {
        this.lexer = t3, this.ast = e3, this.tok = t3.tok, this.EOF = t3.EOF, this.token = null, this.prev = null, this.debug = false, this.version = 800, this.extractDoc = false, this.extractTokens = false, this.suppressErrors = false;
        var i3 = function(t4) {
          return [t4, null];
        };
        this.entries = { IDENTIFIER: new Map([this.tok.T_ABSTRACT, this.tok.T_ARRAY, this.tok.T_AS, this.tok.T_BREAK, this.tok.T_CALLABLE, this.tok.T_CASE, this.tok.T_CATCH, this.tok.T_CLASS, this.tok.T_CLASS_C, this.tok.T_CLONE, this.tok.T_CONST, this.tok.T_CONTINUE, this.tok.T_DECLARE, this.tok.T_DEFAULT, this.tok.T_DIR, this.tok.T_DO, this.tok.T_ECHO, this.tok.T_ELSE, this.tok.T_ELSEIF, this.tok.T_EMPTY, this.tok.T_ENDDECLARE, this.tok.T_ENDFOR, this.tok.T_ENDFOREACH, this.tok.T_ENDIF, this.tok.T_ENDSWITCH, this.tok.T_ENDWHILE, this.tok.T_EVAL, this.tok.T_EXIT, this.tok.T_EXTENDS, this.tok.T_FILE, this.tok.T_FINAL, this.tok.T_FINALLY, this.tok.T_FN, this.tok.T_FOR, this.tok.T_FOREACH, this.tok.T_FUNC_C, this.tok.T_FUNCTION, this.tok.T_GLOBAL, this.tok.T_GOTO, this.tok.T_IF, this.tok.T_IMPLEMENTS, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_INSTANCEOF, this.tok.T_INSTEADOF, this.tok.T_INTERFACE, this.tok.T_ISSET, this.tok.T_LINE, this.tok.T_LIST, this.tok.T_LOGICAL_AND, this.tok.T_LOGICAL_OR, this.tok.T_LOGICAL_XOR, this.tok.T_MATCH, this.tok.T_METHOD_C, this.tok.T_NAMESPACE, this.tok.T_NEW, this.tok.T_NS_C, this.tok.T_PRINT, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_PUBLIC, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_RETURN, this.tok.T_STATIC, this.tok.T_SWITCH, this.tok.T_THROW, this.tok.T_TRAIT, this.tok.T_TRY, this.tok.T_UNSET, this.tok.T_USE, this.tok.T_VAR, this.tok.T_WHILE, this.tok.T_YIELD].map(i3)), VARIABLE: new Map([this.tok.T_VARIABLE, "$", "&", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE, this.tok.T_STATIC].map(i3)), SCALAR: new Map([this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i3)), T_MAGIC_CONST: new Map([this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C].map(i3)), T_MEMBER_FLAGS: new Map([this.tok.T_PUBLIC, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_STATIC, this.tok.T_ABSTRACT, this.tok.T_FINAL].map(i3)), EOS: new Map([";", this.EOF, this.tok.T_INLINE_HTML].map(i3)), EXPR: new Map(["@", "-", "+", "!", "~", "(", "`", this.tok.T_LIST, this.tok.T_CLONE, this.tok.T_INC, this.tok.T_DEC, this.tok.T_NEW, this.tok.T_ISSET, this.tok.T_EMPTY, this.tok.T_MATCH, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_EVAL, this.tok.T_INT_CAST, this.tok.T_DOUBLE_CAST, this.tok.T_STRING_CAST, this.tok.T_ARRAY_CAST, this.tok.T_OBJECT_CAST, this.tok.T_BOOL_CAST, this.tok.T_UNSET_CAST, this.tok.T_EXIT, this.tok.T_PRINT, this.tok.T_YIELD, this.tok.T_STATIC, this.tok.T_FUNCTION, this.tok.T_FN, this.tok.T_VARIABLE, "$", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_STRING, this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i3)) };
      };
      Q2.prototype.getTokenName = function(t3) {
        return W2(t3) ? t3 == this.EOF ? "the end of file (EOF)" : this.lexer.engine.tokens.values[t3] : "'" + t3 + "'";
      }, Q2.prototype.parse = function(t3, e3) {
        this._errors = [], this.filename = e3 || "eval", this.currentNamespace = [""], this.extractDoc ? this._docs = [] : this._docs = null, this.extractTokens ? this._tokens = [] : this._tokens = null, this._docIndex = 0, this._lastNode = null, this.lexer.setInput(t3), this.lexer.all_tokens = this.extractTokens, this.lexer.comment_tokens = this.extractDoc, this.length = this.lexer._input.length, this.innerList = false, this.innerListForm = false;
        var i3 = this.node("program"), n3 = [];
        for (this.next(); this.token != this.EOF; )
          n3.push(this.read_start());
        n3.length === 0 && this.extractDoc && this._docs.length > this._docIndex && n3.push(this.node("noop")()), this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];
        var s3 = i3(n3, this._errors, this._docs, this._tokens);
        if (this.debug) {
          var r3 = this.ast.checkNodes();
          if (r3.length > 0)
            throw r3.forEach(function(t4) {
              t4.position && console.log("Node at line " + t4.position.line + ", column " + t4.position.column), console.log(t4.stack.join("\n"));
            }), new Error("Some nodes are not closed");
        }
        return s3;
      }, Q2.prototype.raiseError = function(t3, e3, i3, n3) {
        if (t3 += " on line " + this.lexer.yylloc.first_line, !this.suppressErrors) {
          var s3 = new SyntaxError(t3, this.filename, this.lexer.yylloc.first_line);
          throw s3.lineNumber = this.lexer.yylloc.first_line, s3.fileName = this.filename, s3.columnNumber = this.lexer.yylloc.first_column, s3;
        }
        var r3 = this.ast.prepare("error", null, this)(t3, n3, this.lexer.yylloc.first_line, i3);
        return this._errors.push(r3), r3;
      }, Q2.prototype.error = function(t3) {
        var e3 = "Parse Error : syntax error", i3 = this.getTokenName(this.token), n3 = "";
        if (this.token !== this.EOF) {
          if (W2(this.token)) {
            var s3 = this.text();
            s3.length > 10 && (s3 = s3.substring(0, 7) + "..."), i3 = "'" + s3 + "' (" + i3 + ")";
          }
          e3 += ", unexpected " + i3;
        }
        return t3 && !Array.isArray(t3) && ((W2(t3) || t3.length === 1) && (n3 = ", expecting " + this.getTokenName(t3)), e3 += n3), this.raiseError(e3, n3, t3, i3);
      }, Q2.prototype.position = function() {
        return new m2(this.lexer.yylloc.first_line, this.lexer.yylloc.first_column, this.lexer.yylloc.first_offset);
      }, Q2.prototype.node = function(t3) {
        if (this.extractDoc) {
          var e3 = null;
          this._docIndex < this._docs.length && (e3 = this._docs.slice(this._docIndex), this._docIndex = this._docs.length, this.debug && (console.log(new Error("Append docs on " + t3)), console.log(e3)));
          var i3 = this.ast.prepare(t3, e3, this);
          return i3.postBuild = function(t4) {
            if (this._docIndex < this._docs.length)
              if (this._lastNode) {
                for (var e4 = this.prev[2], i4 = this._docIndex; i4 < this._docs.length && !(this._docs[i4].offset > e4); i4++)
                  ;
                i4 > this._docIndex && (this._lastNode.setTrailingComments(this._docs.slice(this._docIndex, i4)), this._docIndex = i4);
              } else
                this.token === this.EOF && (t4.setTrailingComments(this._docs.slice(this._docIndex)), this._docIndex = this._docs.length);
            this._lastNode = t4;
          }.bind(this), i3;
        }
        return this.ast.prepare(t3, null, this);
      }, Q2.prototype.expectEndOfStatement = function(t3) {
        if (this.token === ";")
          t3 && this.lexer.yytext === ";" && t3.includeToken(this);
        else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF)
          return this.error(";"), false;
        return this.next(), true;
      };
      var Y2 = ["parser.next", "parser.node", "parser.showlog"];
      Q2.prototype.showlog = function() {
        for (var t3, e3 = new Error().stack.split("\n"), i3 = 2; i3 < e3.length; i3++) {
          t3 = e3[i3].trim();
          for (var n3 = false, s3 = 0; s3 < Y2.length; s3++)
            if (t3.substring(3, 3 + Y2[s3].length) === Y2[s3]) {
              n3 = true;
              break;
            }
          if (!n3)
            break;
        }
        return console.log("Line " + this.lexer.yylloc.first_line + " : " + this.getTokenName(this.token) + ">" + this.lexer.yytext + "< @-->" + t3), this;
      }, Q2.prototype.expect = function(t3) {
        if (Array.isArray(t3)) {
          if (t3.indexOf(this.token) === -1)
            return this.error(t3), false;
        } else if (this.token != t3)
          return this.error(t3), false;
        return true;
      }, Q2.prototype.text = function() {
        return this.lexer.yytext;
      }, Q2.prototype.next = function() {
        if (this.token === ";" && this.lexer.yytext !== ";" || (this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset]), this.lex(), this.debug && this.showlog(), this.extractDoc)
          for (; this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT; )
            this.token === this.tok.T_COMMENT ? this._docs.push(this.read_comment()) : this._docs.push(this.read_doc_comment());
        return this;
      }, Q2.prototype.lex = function() {
        if (this.extractTokens)
          do {
            if (this.token = this.lexer.lex() || this.EOF, this.token === this.EOF)
              return this;
            var t3 = this.lexer.yytext;
            if (t3 = this.lexer.engine.tokens.values.hasOwnProperty(this.token) ? [this.lexer.engine.tokens.values[this.token], t3, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset] : [null, t3, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset], this._tokens.push(t3), this.token === this.tok.T_CLOSE_TAG)
              return this.token = ";", this;
            if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO)
              return this.token = this.tok.T_ECHO, this;
          } while (this.token === this.tok.T_WHITESPACE || !this.extractDoc && (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) || this.token === this.tok.T_OPEN_TAG);
        else
          this.token = this.lexer.lex() || this.EOF;
        return this;
      }, Q2.prototype.is = function(t3) {
        return Array.isArray(t3) ? t3.indexOf(this.token) !== -1 : this.entries[t3].has(this.token);
      }, [E2, b2, L2, O2, I2, R2, w2, D2, P2, B2, M2, F2, H2, G2, V2].forEach(function(t3) {
        for (var e3 in t3) {
          if (Q2.prototype.hasOwnProperty(e3))
            throw new Error("Function " + e3 + " is already defined - collision");
          Q2.prototype[e3] = t3[e3];
        }
      });
      var j2 = Q2, $2 = { values: { 101: "T_HALT_COMPILER", 102: "T_USE", 103: "T_ENCAPSED_AND_WHITESPACE", 104: "T_OBJECT_OPERATOR", 105: "T_STRING", 106: "T_DOLLAR_OPEN_CURLY_BRACES", 107: "T_STRING_VARNAME", 108: "T_CURLY_OPEN", 109: "T_NUM_STRING", 110: "T_ISSET", 111: "T_EMPTY", 112: "T_INCLUDE", 113: "T_INCLUDE_ONCE", 114: "T_EVAL", 115: "T_REQUIRE", 116: "T_REQUIRE_ONCE", 117: "T_NAMESPACE", 118: "T_NS_SEPARATOR", 119: "T_AS", 120: "T_IF", 121: "T_ENDIF", 122: "T_WHILE", 123: "T_DO", 124: "T_FOR", 125: "T_SWITCH", 126: "T_BREAK", 127: "T_CONTINUE", 128: "T_RETURN", 129: "T_GLOBAL", 130: "T_STATIC", 131: "T_ECHO", 132: "T_INLINE_HTML", 133: "T_UNSET", 134: "T_FOREACH", 135: "T_DECLARE", 136: "T_TRY", 137: "T_THROW", 138: "T_GOTO", 139: "T_FINALLY", 140: "T_CATCH", 141: "T_ENDDECLARE", 142: "T_LIST", 143: "T_CLONE", 144: "T_PLUS_EQUAL", 145: "T_MINUS_EQUAL", 146: "T_MUL_EQUAL", 147: "T_DIV_EQUAL", 148: "T_CONCAT_EQUAL", 149: "T_MOD_EQUAL", 150: "T_AND_EQUAL", 151: "T_OR_EQUAL", 152: "T_XOR_EQUAL", 153: "T_SL_EQUAL", 154: "T_SR_EQUAL", 155: "T_INC", 156: "T_DEC", 157: "T_BOOLEAN_OR", 158: "T_BOOLEAN_AND", 159: "T_LOGICAL_OR", 160: "T_LOGICAL_AND", 161: "T_LOGICAL_XOR", 162: "T_SL", 163: "T_SR", 164: "T_IS_IDENTICAL", 165: "T_IS_NOT_IDENTICAL", 166: "T_IS_EQUAL", 167: "T_IS_NOT_EQUAL", 168: "T_IS_SMALLER_OR_EQUAL", 169: "T_IS_GREATER_OR_EQUAL", 170: "T_INSTANCEOF", 171: "T_INT_CAST", 172: "T_DOUBLE_CAST", 173: "T_STRING_CAST", 174: "T_ARRAY_CAST", 175: "T_OBJECT_CAST", 176: "T_BOOL_CAST", 177: "T_UNSET_CAST", 178: "T_EXIT", 179: "T_PRINT", 180: "T_YIELD", 181: "T_YIELD_FROM", 182: "T_FUNCTION", 183: "T_DOUBLE_ARROW", 184: "T_DOUBLE_COLON", 185: "T_ARRAY", 186: "T_CALLABLE", 187: "T_CLASS", 188: "T_ABSTRACT", 189: "T_TRAIT", 190: "T_FINAL", 191: "T_EXTENDS", 192: "T_INTERFACE", 193: "T_IMPLEMENTS", 194: "T_VAR", 195: "T_PUBLIC", 196: "T_PROTECTED", 197: "T_PRIVATE", 198: "T_CONST", 199: "T_NEW", 200: "T_INSTEADOF", 201: "T_ELSEIF", 202: "T_ELSE", 203: "T_ENDSWITCH", 204: "T_CASE", 205: "T_DEFAULT", 206: "T_ENDFOR", 207: "T_ENDFOREACH", 208: "T_ENDWHILE", 209: "T_CONSTANT_ENCAPSED_STRING", 210: "T_LNUMBER", 211: "T_DNUMBER", 212: "T_LINE", 213: "T_FILE", 214: "T_DIR", 215: "T_TRAIT_C", 216: "T_METHOD_C", 217: "T_FUNC_C", 218: "T_NS_C", 219: "T_START_HEREDOC", 220: "T_END_HEREDOC", 221: "T_CLASS_C", 222: "T_VARIABLE", 223: "T_OPEN_TAG", 224: "T_OPEN_TAG_WITH_ECHO", 225: "T_CLOSE_TAG", 226: "T_WHITESPACE", 227: "T_COMMENT", 228: "T_DOC_COMMENT", 229: "T_ELLIPSIS", 230: "T_COALESCE", 231: "T_POW", 232: "T_POW_EQUAL", 233: "T_SPACESHIP", 234: "T_COALESCE_EQUAL", 235: "T_FN", 236: "T_NULLSAFE_OBJECT_OPERATOR", 237: "T_MATCH", 238: "T_ATTRIBUTE" }, names: { T_HALT_COMPILER: 101, T_USE: 102, T_ENCAPSED_AND_WHITESPACE: 103, T_OBJECT_OPERATOR: 104, T_STRING: 105, T_DOLLAR_OPEN_CURLY_BRACES: 106, T_STRING_VARNAME: 107, T_CURLY_OPEN: 108, T_NUM_STRING: 109, T_ISSET: 110, T_EMPTY: 111, T_INCLUDE: 112, T_INCLUDE_ONCE: 113, T_EVAL: 114, T_REQUIRE: 115, T_REQUIRE_ONCE: 116, T_NAMESPACE: 117, T_NS_SEPARATOR: 118, T_AS: 119, T_IF: 120, T_ENDIF: 121, T_WHILE: 122, T_DO: 123, T_FOR: 124, T_SWITCH: 125, T_BREAK: 126, T_CONTINUE: 127, T_RETURN: 128, T_GLOBAL: 129, T_STATIC: 130, T_ECHO: 131, T_INLINE_HTML: 132, T_UNSET: 133, T_FOREACH: 134, T_DECLARE: 135, T_TRY: 136, T_THROW: 137, T_GOTO: 138, T_FINALLY: 139, T_CATCH: 140, T_ENDDECLARE: 141, T_LIST: 142, T_CLONE: 143, T_PLUS_EQUAL: 144, T_MINUS_EQUAL: 145, T_MUL_EQUAL: 146, T_DIV_EQUAL: 147, T_CONCAT_EQUAL: 148, T_MOD_EQUAL: 149, T_AND_EQUAL: 150, T_OR_EQUAL: 151, T_XOR_EQUAL: 152, T_SL_EQUAL: 153, T_SR_EQUAL: 154, T_INC: 155, T_DEC: 156, T_BOOLEAN_OR: 157, T_BOOLEAN_AND: 158, T_LOGICAL_OR: 159, T_LOGICAL_AND: 160, T_LOGICAL_XOR: 161, T_SL: 162, T_SR: 163, T_IS_IDENTICAL: 164, T_IS_NOT_IDENTICAL: 165, T_IS_EQUAL: 166, T_IS_NOT_EQUAL: 167, T_IS_SMALLER_OR_EQUAL: 168, T_IS_GREATER_OR_EQUAL: 169, T_INSTANCEOF: 170, T_INT_CAST: 171, T_DOUBLE_CAST: 172, T_STRING_CAST: 173, T_ARRAY_CAST: 174, T_OBJECT_CAST: 175, T_BOOL_CAST: 176, T_UNSET_CAST: 177, T_EXIT: 178, T_PRINT: 179, T_YIELD: 180, T_YIELD_FROM: 181, T_FUNCTION: 182, T_DOUBLE_ARROW: 183, T_DOUBLE_COLON: 184, T_ARRAY: 185, T_CALLABLE: 186, T_CLASS: 187, T_ABSTRACT: 188, T_TRAIT: 189, T_FINAL: 190, T_EXTENDS: 191, T_INTERFACE: 192, T_IMPLEMENTS: 193, T_VAR: 194, T_PUBLIC: 195, T_PROTECTED: 196, T_PRIVATE: 197, T_CONST: 198, T_NEW: 199, T_INSTEADOF: 200, T_ELSEIF: 201, T_ELSE: 202, T_ENDSWITCH: 203, T_CASE: 204, T_DEFAULT: 205, T_ENDFOR: 206, T_ENDFOREACH: 207, T_ENDWHILE: 208, T_CONSTANT_ENCAPSED_STRING: 209, T_LNUMBER: 210, T_DNUMBER: 211, T_LINE: 212, T_FILE: 213, T_DIR: 214, T_TRAIT_C: 215, T_METHOD_C: 216, T_FUNC_C: 217, T_NS_C: 218, T_START_HEREDOC: 219, T_END_HEREDOC: 220, T_CLASS_C: 221, T_VARIABLE: 222, T_OPEN_TAG: 223, T_OPEN_TAG_WITH_ECHO: 224, T_CLOSE_TAG: 225, T_WHITESPACE: 226, T_COMMENT: 227, T_DOC_COMMENT: 228, T_ELLIPSIS: 229, T_COALESCE: 230, T_POW: 231, T_POW_EQUAL: 232, T_SPACESHIP: 233, T_COALESCE_EQUAL: 234, T_FN: 235, T_NULLSAFE_OBJECT_OPERATOR: 236, T_MATCH: 237, T_ATTRIBUTE: 238 } }, z2 = function(t3, e3, i3) {
        this.source = t3, this.start = e3, this.end = i3;
      }, K2 = function(t3, e3, i3) {
        this.kind = t3, e3 && (this.leadingComments = e3), i3 && (this.loc = i3);
      };
      K2.prototype.setTrailingComments = function(t3) {
        this.trailingComments = t3;
      }, K2.prototype.destroy = function(t3) {
        if (!t3)
          throw new Error("Node already initialized, you must swap with another node");
        return this.leadingComments && (t3.leadingComments ? t3.leadingComments = Array.concat(this.leadingComments, t3.leadingComments) : t3.leadingComments = this.leadingComments), this.trailingComments && (t3.trailingComments ? t3.trailingComments = Array.concat(this.trailingComments, t3.trailingComments) : t3.trailingComments = this.trailingComments), t3;
      }, K2.prototype.includeToken = function(t3) {
        return this.loc && (this.loc.end && (this.loc.end.line = t3.lexer.yylloc.last_line, this.loc.end.column = t3.lexer.yylloc.last_column, this.loc.end.offset = t3.lexer.offset), t3.ast.withSource && (this.loc.source = t3.lexer._input.substring(this.loc.start.offset, t3.lexer.offset))), this;
      }, K2.extends = function(t3, e3) {
        return e3.prototype = Object.create(this.prototype), e3.extends = this.extends, e3.prototype.constructor = e3, e3.kind = t3, e3;
      };
      var X2 = K2, J2 = "expression", q2 = X2.extends(J2, function(t3, e3, i3) {
        X2.apply(this, [t3 || J2, e3, i3]);
      }), Z2 = "array", tt2 = q2.extends(Z2, function(t3, e3, i3, n3) {
        q2.apply(this, [Z2, i3, n3]), this.items = e3, this.shortForm = t3;
      }), et2 = "arrowfunc", it2 = q2.extends(et2, function(t3, e3, i3, n3, s3, r3, o3, a3) {
        q2.apply(this, [et2, o3, a3]), this.arguments = t3, this.byref = e3, this.body = i3, this.type = n3, this.nullable = s3, this.isStatic = r3 || false;
      }), nt2 = "assign", st2 = q2.extends(nt2, function(t3, e3, i3, n3, s3) {
        q2.apply(this, [nt2, n3, s3]), this.left = t3, this.right = e3, this.operator = i3;
      }), rt2 = "assignref", ot2 = q2.extends(rt2, function(t3, e3, i3, n3) {
        q2.apply(this, [rt2, i3, n3]), this.left = t3, this.right = e3;
      }), at2 = "attribute", ht2 = X2.extends(at2, function(t3, e3, i3, n3) {
        X2.apply(this, [at2, i3, n3]), this.name = t3, this.args = e3;
      }), lt2 = "attrgroup", ct2 = X2.extends(lt2, function(t3, e3, i3) {
        X2.apply(this, [lt2, e3, i3]), this.attrs = t3 || [];
      }), ut2 = "operation", _t2 = q2.extends(ut2, function(t3, e3, i3) {
        q2.apply(this, [t3 || ut2, e3, i3]);
      }), dt2 = _t2.extends("bin", function(t3, e3, i3, n3, s3) {
        _t2.apply(this, ["bin", n3, s3]), this.type = t3, this.left = e3, this.right = i3;
      }), pt2 = "statement", ft2 = X2.extends(pt2, function(t3, e3, i3) {
        X2.apply(this, [t3 || pt2, e3, i3]);
      }), Tt2 = "block", kt2 = ft2.extends(Tt2, function(t3, e3, i3, n3) {
        ft2.apply(this, [t3 || Tt2, i3, n3]), this.children = e3.filter(Boolean);
      }), mt2 = "literal", Et2 = q2.extends(mt2, function(t3, e3, i3, n3, s3) {
        q2.apply(this, [t3 || mt2, n3, s3]), this.value = e3, i3 && (this.raw = i3);
      }), xt2 = "boolean", yt2 = Et2.extends(xt2, function(t3, e3, i3, n3) {
        Et2.apply(this, [xt2, t3, e3, i3, n3]);
      }), vt2 = "break", At2 = ft2.extends(vt2, function(t3, e3, i3) {
        ft2.apply(this, [vt2, e3, i3]), this.level = t3;
      }), gt2 = "byref", Nt2 = q2.extends(gt2, function(t3, e3, i3) {
        q2.apply(this, [gt2, e3, i3]), this.what = t3;
      }), Ct2 = "call", St2 = q2.extends(Ct2, function(t3, e3, i3, n3) {
        q2.apply(this, [Ct2, i3, n3]), this.what = t3, this.arguments = e3;
      }), bt2 = "case", Lt2 = ft2.extends(bt2, function(t3, e3, i3, n3) {
        ft2.apply(this, [bt2, i3, n3]), this.test = t3, this.body = e3;
      }), Ot2 = "cast", It2 = _t2.extends(Ot2, function(t3, e3, i3, n3, s3) {
        _t2.apply(this, [Ot2, n3, s3]), this.type = t3, this.raw = e3, this.expr = i3;
      }), Rt2 = "catch", wt2 = ft2.extends(Rt2, function(t3, e3, i3, n3, s3) {
        ft2.apply(this, [Rt2, n3, s3]), this.body = t3, this.what = e3, this.variable = i3;
      }), Dt2 = "declaration", Pt2 = ft2.extends(Dt2, function(t3, e3, i3, n3) {
        ft2.apply(this, [t3 || Dt2, i3, n3]), this.name = e3;
      });
      Pt2.prototype.parseFlags = function(t3) {
        this.isAbstract = t3[2] === 1, this.isFinal = t3[2] === 2, this.kind !== "class" && (t3[0] === -1 ? this.visibility = "" : t3[0] === null ? this.visibility = null : t3[0] === 0 ? this.visibility = "public" : t3[0] === 1 ? this.visibility = "protected" : t3[0] === 2 && (this.visibility = "private"), this.isStatic = t3[1] === 1);
      };
      var Ut2 = Pt2, Bt2 = "class", Mt2 = Ut2.extends(Bt2, function(t3, e3, i3, n3, s3, r3, o3) {
        Ut2.apply(this, [Bt2, t3, r3, o3]), this.isAnonymous = !t3, this.extends = e3, this.implements = i3, this.body = n3, this.attrGroups = [], this.parseFlags(s3);
      }), Ft2 = "constantstatement", Ht2 = ft2.extends(Ft2, function(t3, e3, i3, n3) {
        ft2.apply(this, [t3 || Ft2, i3, n3]), this.constants = e3;
      }), Gt2 = "classconstant", Vt2 = Ht2.extends(Gt2, function(t3, e3, i3, n3, s3, r3) {
        Ht2.apply(this, [t3 || Gt2, e3, s3, r3]), this.parseFlags(i3), this.attrGroups = n3;
      });
      Vt2.prototype.parseFlags = function(t3) {
        t3[0] === -1 ? this.visibility = "" : t3[0] === null ? this.visibility = null : t3[0] === 0 ? this.visibility = "public" : t3[0] === 1 ? this.visibility = "protected" : t3[0] === 2 && (this.visibility = "private");
      };
      var Wt2 = Vt2, Qt2 = "clone", Yt2 = q2.extends(Qt2, function(t3, e3, i3) {
        q2.apply(this, [Qt2, e3, i3]), this.what = t3;
      }), jt2 = "closure", $t2 = q2.extends(jt2, function(t3, e3, i3, n3, s3, r3, o3, a3) {
        q2.apply(this, [jt2, o3, a3]), this.uses = i3, this.arguments = t3, this.byref = e3, this.type = n3, this.nullable = s3, this.isStatic = r3 || false, this.body = null, this.attrGroups = [];
      }), zt2 = X2.extends("comment", function(t3, e3, i3, n3) {
        X2.apply(this, [t3, i3, n3]), this.value = e3;
      }), Kt2 = "commentblock", Xt2 = zt2.extends(Kt2, function(t3, e3, i3) {
        zt2.apply(this, [Kt2, t3, e3, i3]);
      }), Jt2 = "commentline", qt2 = zt2.extends(Jt2, function(t3, e3, i3) {
        zt2.apply(this, [Jt2, t3, e3, i3]);
      }), Zt2 = "constant", te2 = X2.extends(Zt2, function(t3, e3, i3, n3) {
        X2.apply(this, [Zt2, i3, n3]), this.name = t3, this.value = e3;
      }), ee2 = "continue", ie2 = ft2.extends(ee2, function(t3, e3, i3) {
        ft2.apply(this, [ee2, e3, i3]), this.level = t3;
      }), ne2 = "declare", se2 = kt2.extends(ne2, function(t3, e3, i3, n3, s3) {
        kt2.apply(this, [ne2, e3, n3, s3]), this.directives = t3, this.mode = i3;
      });
      se2.MODE_SHORT = "short", se2.MODE_BLOCK = "block", se2.MODE_NONE = "none";
      var re2 = se2, oe2 = "declaredirective", ae2 = X2.extends(oe2, function(t3, e3, i3, n3) {
        X2.apply(this, [oe2, i3, n3]), this.key = t3, this.value = e3;
      }), he2 = ft2.extends("do", function(t3, e3, i3, n3) {
        ft2.apply(this, ["do", i3, n3]), this.test = t3, this.body = e3;
      }), le2 = "echo", ce2 = ft2.extends(le2, function(t3, e3, i3, n3) {
        ft2.apply(this, [le2, i3, n3]), this.shortForm = e3, this.expressions = t3;
      }), ue2 = "empty", _e2 = q2.extends(ue2, function(t3, e3, i3) {
        q2.apply(this, [ue2, e3, i3]), this.expression = t3;
      }), de2 = "encapsed", pe2 = Et2.extends(de2, function(t3, e3, i3, n3, s3) {
        Et2.apply(this, [de2, t3, e3, n3, s3]), this.type = i3;
      });
      pe2.TYPE_STRING = "string", pe2.TYPE_SHELL = "shell", pe2.TYPE_HEREDOC = "heredoc", pe2.TYPE_OFFSET = "offset";
      var fe2 = pe2, Te2 = "encapsedpart", ke2 = q2.extends(Te2, function(t3, e3, i3, n3, s3) {
        q2.apply(this, [Te2, n3, s3]), this.expression = t3, this.syntax = e3, this.curly = i3;
      }), me2 = "entry", Ee2 = q2.extends(me2, function(t3, e3, i3, n3, s3, r3) {
        q2.apply(this, [me2, s3, r3]), this.key = t3, this.value = e3, this.byRef = i3, this.unpack = n3;
      }), xe2 = "error", ye2 = X2.extends(xe2, function(t3, e3, i3, n3, s3, r3) {
        X2.apply(this, [xe2, s3, r3]), this.message = t3, this.token = e3, this.line = i3, this.expected = n3;
      }), ve2 = "eval", Ae2 = q2.extends(ve2, function(t3, e3, i3) {
        q2.apply(this, [ve2, e3, i3]), this.source = t3;
      }), ge2 = "exit", Ne2 = q2.extends(ge2, function(t3, e3, i3, n3) {
        q2.apply(this, [ge2, i3, n3]), this.expression = t3, this.useDie = e3;
      }), Ce2 = "expressionstatement", Se2 = ft2.extends(Ce2, function(t3, e3, i3) {
        ft2.apply(this, [Ce2, e3, i3]), this.expression = t3;
      }), be2 = ft2.extends("for", function(t3, e3, i3, n3, s3, r3, o3) {
        ft2.apply(this, ["for", r3, o3]), this.init = t3, this.test = e3, this.increment = i3, this.shortForm = s3, this.body = n3;
      }), Le2 = "foreach", Oe2 = ft2.extends(Le2, function(t3, e3, i3, n3, s3, r3, o3) {
        ft2.apply(this, [Le2, r3, o3]), this.source = t3, this.key = e3, this.value = i3, this.shortForm = s3, this.body = n3;
      }), Ie2 = "function", Re2 = Ut2.extends(Ie2, function(t3, e3, i3, n3, s3, r3, o3) {
        Ut2.apply(this, [Ie2, t3, r3, o3]), this.arguments = e3, this.byref = i3, this.type = n3, this.nullable = s3, this.body = null, this.attrGroups = [];
      }), we2 = "global", De2 = ft2.extends(we2, function(t3, e3, i3) {
        ft2.apply(this, [we2, e3, i3]), this.items = t3;
      }), Pe2 = "goto", Ue2 = ft2.extends(Pe2, function(t3, e3, i3) {
        ft2.apply(this, [Pe2, e3, i3]), this.label = t3;
      }), Be2 = "halt", Me2 = ft2.extends(Be2, function(t3, e3, i3) {
        ft2.apply(this, [Be2, e3, i3]), this.after = t3;
      }), Fe2 = "identifier", He2 = X2.extends(Fe2, function(t3, e3, i3) {
        X2.apply(this, [Fe2, e3, i3]), this.name = t3;
      }), Ge2 = ft2.extends("if", function(t3, e3, i3, n3, s3, r3) {
        ft2.apply(this, ["if", s3, r3]), this.test = t3, this.body = e3, this.alternate = i3, this.shortForm = n3;
      }), Ve2 = "include", We2 = q2.extends(Ve2, function(t3, e3, i3, n3, s3) {
        q2.apply(this, [Ve2, n3, s3]), this.once = t3, this.require = e3, this.target = i3;
      }), Qe2 = "inline", Ye2 = Et2.extends(Qe2, function(t3, e3, i3, n3) {
        Et2.apply(this, [Qe2, t3, e3, i3, n3]);
      }), je2 = "interface", $e2 = Ut2.extends(je2, function(t3, e3, i3, n3, s3, r3) {
        Ut2.apply(this, [je2, t3, s3, r3]), this.extends = e3, this.body = i3, this.attrGroups = n3;
      }), ze2 = "isset", Ke2 = q2.extends(ze2, function(t3, e3, i3) {
        q2.apply(this, [ze2, e3, i3]), this.variables = t3;
      }), Xe2 = "label", Je2 = ft2.extends(Xe2, function(t3, e3, i3) {
        ft2.apply(this, [Xe2, e3, i3]), this.name = t3;
      }), qe2 = "list", Ze2 = q2.extends(qe2, function(t3, e3, i3, n3) {
        q2.apply(this, [qe2, i3, n3]), this.items = t3, this.shortForm = e3;
      }), ti2 = "lookup", ei2 = q2.extends(ti2, function(t3, e3, i3, n3, s3) {
        q2.apply(this, [t3 || ti2, n3, s3]), this.what = e3, this.offset = i3;
      }), ii2 = "magic", ni2 = Et2.extends(ii2, function(t3, e3, i3, n3) {
        Et2.apply(this, [ii2, t3, e3, i3, n3]);
      }), si2 = "match", ri2 = q2.extends(si2, function(t3, e3, i3, n3) {
        q2.apply(this, [si2, i3, n3]), this.cond = t3, this.arms = e3;
      }), oi2 = "matcharm", ai2 = q2.extends(oi2, function(t3, e3, i3, n3) {
        q2.apply(this, [oi2, i3, n3]), this.conds = t3, this.body = e3;
      }), hi2 = "method", li2 = Re2.extends(hi2, function() {
        Re2.apply(this, arguments), this.kind = hi2;
      }), ci2 = "reference", ui2 = X2.extends(ci2, function(t3, e3, i3) {
        X2.apply(this, [t3 || ci2, e3, i3]);
      }), _i2 = "name", di2 = ui2.extends(_i2, function t3(e3, i3, n3, s3) {
        ui2.apply(this, [_i2, n3, s3]), i3 ? this.resolution = t3.RELATIVE_NAME : e3.length === 1 ? this.resolution = t3.UNQUALIFIED_NAME : e3[0] ? this.resolution = t3.QUALIFIED_NAME : this.resolution = t3.FULL_QUALIFIED_NAME, this.name = e3.join("\\");
      });
      di2.UNQUALIFIED_NAME = "uqn", di2.QUALIFIED_NAME = "qn", di2.FULL_QUALIFIED_NAME = "fqn", di2.RELATIVE_NAME = "rn";
      var pi2 = di2, fi2 = "namespace", Ti2 = kt2.extends(fi2, function(t3, e3, i3, n3, s3) {
        kt2.apply(this, [fi2, e3, n3, s3]), this.name = t3, this.withBrackets = i3 || false;
      }), ki2 = "namedargument", mi2 = q2.extends(ki2, function(t3, e3, i3, n3) {
        q2.apply(this, [ki2, i3, n3]), this.name = t3, this.value = e3;
      }), Ei2 = q2.extends("new", function(t3, e3, i3, n3) {
        q2.apply(this, ["new", i3, n3]), this.what = t3, this.arguments = e3;
      }), xi2 = "noop", yi2 = X2.extends(xi2, function(t3, e3) {
        X2.apply(this, [xi2, t3, e3]);
      }), vi2 = "nowdoc", Ai2 = Et2.extends(vi2, function(t3, e3, i3, n3, s3) {
        Et2.apply(this, [vi2, t3, e3, n3, s3]), this.label = i3;
      }), gi2 = "nullkeyword", Ni2 = X2.extends(gi2, function(t3, e3, i3) {
        X2.apply(this, [gi2, e3, i3]), this.raw = t3;
      }), Ci2 = "nullsafepropertylookup", Si2 = ei2.extends(Ci2, function(t3, e3, i3, n3) {
        ei2.apply(this, [Ci2, t3, e3, i3, n3]);
      }), bi2 = "number", Li2 = Et2.extends(bi2, function(t3, e3, i3, n3) {
        Et2.apply(this, [bi2, t3, e3, i3, n3]);
      }), Oi2 = "offsetlookup", Ii2 = ei2.extends(Oi2, function(t3, e3, i3, n3) {
        ei2.apply(this, [Oi2, t3, e3, i3, n3]);
      }), Ri2 = "parameter", wi2 = Ut2.extends(Ri2, function(t3, e3, i3, n3, s3, r3, o3, a3, h3) {
        Ut2.apply(this, [Ri2, t3, a3, h3]), this.value = i3, this.type = e3, this.byref = n3, this.variadic = s3, this.nullable = r3, this.flags = o3 || 0, this.attrGroups = [];
      }), Di2 = "parentreference", Pi2 = ui2.extends(Di2, function(t3, e3, i3) {
        ui2.apply(this, [Di2, e3, i3]), this.raw = t3;
      }), Ui2 = "post", Bi2 = _t2.extends(Ui2, function(t3, e3, i3, n3) {
        _t2.apply(this, [Ui2, i3, n3]), this.type = t3, this.what = e3;
      }), Mi2 = _t2.extends("pre", function(t3, e3, i3, n3) {
        _t2.apply(this, ["pre", i3, n3]), this.type = t3, this.what = e3;
      }), Fi2 = "print", Hi2 = q2.extends(Fi2, function(t3, e3, i3) {
        q2.apply(this, [Fi2, e3, i3]), this.expression = t3;
      }), Gi2 = "program", Vi2 = kt2.extends(Gi2, function(t3, e3, i3, n3, s3, r3) {
        kt2.apply(this, [Gi2, t3, s3, r3]), this.errors = e3, i3 && (this.comments = i3), n3 && (this.tokens = n3);
      }), Wi2 = "property", Qi2 = ft2.extends(Wi2, function(t3, e3, i3, n3, s3, r3, o3) {
        ft2.apply(this, [Wi2, r3, o3]), this.name = t3, this.value = e3, this.nullable = i3, this.type = n3, this.attrGroups = s3;
      }), Yi2 = "propertylookup", ji2 = ei2.extends(Yi2, function(t3, e3, i3, n3) {
        ei2.apply(this, [Yi2, t3, e3, i3, n3]);
      }), $i2 = "propertystatement", zi2 = ft2.extends($i2, function(t3, e3, i3, n3, s3) {
        ft2.apply(this, [$i2, n3, s3]), this.properties = e3, this.parseFlags(i3);
      });
      zi2.prototype.parseFlags = function(t3) {
        t3[0] === -1 ? this.visibility = "" : t3[0] === null ? this.visibility = null : t3[0] === 0 ? this.visibility = "public" : t3[0] === 1 ? this.visibility = "protected" : t3[0] === 2 && (this.visibility = "private"), this.isStatic = t3[1] === 1;
      };
      var Ki2 = zi2, Xi2 = "retif", Ji2 = q2.extends(Xi2, function(t3, e3, i3, n3, s3) {
        q2.apply(this, [Xi2, n3, s3]), this.test = t3, this.trueExpr = e3, this.falseExpr = i3;
      }), qi2 = "return", Zi2 = ft2.extends(qi2, function(t3, e3, i3) {
        ft2.apply(this, [qi2, e3, i3]), this.expr = t3;
      }), tn2 = "selfreference", en2 = ui2.extends(tn2, function(t3, e3, i3) {
        ui2.apply(this, [tn2, e3, i3]), this.raw = t3;
      }), nn2 = "silent", sn2 = q2.extends(nn2, function(t3, e3, i3) {
        q2.apply(this, [nn2, e3, i3]), this.expr = t3;
      }), rn2 = "static", on2 = ft2.extends(rn2, function(t3, e3, i3) {
        ft2.apply(this, [rn2, e3, i3]), this.variables = t3;
      }), an2 = "staticvariable", hn2 = X2.extends(an2, function(t3, e3, i3, n3) {
        X2.apply(this, [an2, i3, n3]), this.variable = t3, this.defaultValue = e3;
      }), ln2 = "staticlookup", cn2 = ei2.extends(ln2, function(t3, e3, i3, n3) {
        ei2.apply(this, [ln2, t3, e3, i3, n3]);
      }), un2 = "staticreference", _n2 = ui2.extends(un2, function(t3, e3, i3) {
        ui2.apply(this, [un2, e3, i3]), this.raw = t3;
      }), dn2 = "string", pn2 = Et2.extends(dn2, function(t3, e3, i3, n3, s3, r3) {
        Et2.apply(this, [dn2, e3, n3, s3, r3]), this.unicode = i3, this.isDoubleQuote = t3;
      }), fn2 = "switch", Tn2 = ft2.extends(fn2, function(t3, e3, i3, n3, s3) {
        ft2.apply(this, [fn2, n3, s3]), this.test = t3, this.body = e3, this.shortForm = i3;
      }), kn2 = "throw", mn2 = ft2.extends(kn2, function(t3, e3, i3) {
        ft2.apply(this, [kn2, e3, i3]), this.what = t3;
      }), En2 = "trait", xn2 = Ut2.extends(En2, function(t3, e3, i3, n3) {
        Ut2.apply(this, [En2, t3, i3, n3]), this.body = e3;
      }), yn2 = "traitalias", vn2 = X2.extends(yn2, function(t3, e3, i3, n3, s3, r3) {
        X2.apply(this, [yn2, s3, r3]), this.trait = t3, this.method = e3, this.as = i3, this.visibility = "", n3 && (n3[0] === 0 ? this.visibility = "public" : n3[0] === 1 ? this.visibility = "protected" : n3[0] === 2 && (this.visibility = "private"));
      }), An2 = "traitprecedence", gn2 = X2.extends(An2, function(t3, e3, i3, n3, s3) {
        X2.apply(this, [An2, n3, s3]), this.trait = t3, this.method = e3, this.instead = i3;
      }), Nn2 = "traituse", Cn2 = X2.extends(Nn2, function(t3, e3, i3, n3) {
        X2.apply(this, [Nn2, i3, n3]), this.traits = t3, this.adaptations = e3;
      }), Sn2 = ft2.extends("try", function(t3, e3, i3, n3, s3) {
        ft2.apply(this, ["try", n3, s3]), this.body = t3, this.catches = e3, this.always = i3;
      }), bn2 = "typereference", Ln2 = ui2.extends(bn2, function(t3, e3, i3, n3) {
        ui2.apply(this, [bn2, i3, n3]), this.name = t3, this.raw = e3;
      });
      Ln2.types = ["int", "float", "string", "bool", "object", "array", "callable", "iterable", "void", "static"];
      var On2 = Ln2, In2 = "unary", Rn2 = _t2.extends(In2, function(t3, e3, i3, n3) {
        _t2.apply(this, [In2, i3, n3]), this.type = t3, this.what = e3;
      }), wn2 = "uniontype", Dn2 = Ut2.extends(wn2, function(t3, e3, i3) {
        Ut2.apply(this, [wn2, null, e3, i3]), this.types = t3;
      }), Pn2 = "unset", Un2 = ft2.extends(Pn2, function(t3, e3, i3) {
        ft2.apply(this, [Pn2, e3, i3]), this.variables = t3;
      }), Bn2 = "usegroup", Mn2 = ft2.extends(Bn2, function(t3, e3, i3, n3, s3) {
        ft2.apply(this, [Bn2, n3, s3]), this.name = t3, this.type = e3, this.items = i3;
      }), Fn2 = "useitem", Hn2 = ft2.extends(Fn2, function(t3, e3, i3, n3, s3) {
        ft2.apply(this, [Fn2, n3, s3]), this.name = t3, this.alias = e3, this.type = i3;
      });
      Hn2.TYPE_CONST = "const", Hn2.TYPE_FUNCTION = "function";
      var Gn2 = Hn2, Vn2 = "variable", Wn2 = q2.extends(Vn2, function(t3, e3, i3, n3) {
        q2.apply(this, [Vn2, i3, n3]), this.name = t3, this.curly = e3 || false;
      }), Qn2 = "variadic", Yn2 = q2.extends(Qn2, function(t3, e3, i3) {
        q2.apply(this, [Qn2, e3, i3]), this.what = t3;
      }), jn2 = "while", $n2 = ft2.extends(jn2, function(t3, e3, i3, n3, s3) {
        ft2.apply(this, [jn2, n3, s3]), this.test = t3, this.body = e3, this.shortForm = i3;
      }), zn2 = "yield", Kn2 = q2.extends(zn2, function(t3, e3, i3, n3) {
        q2.apply(this, [zn2, i3, n3]), this.value = t3, this.key = e3;
      }), Xn2 = "yieldfrom", Jn2 = q2.extends(Xn2, function(t3, e3, i3) {
        q2.apply(this, [Xn2, e3, i3]), this.value = t3;
      }), qn2 = function(t3, e3) {
        this.withPositions = t3, this.withSource = e3;
      };
      qn2.precedence = {}, [["or"], ["xor"], ["and"], ["="], ["?"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "!=", "===", "!==", "<=>"], ["<", "<=", ">", ">="], ["<<", ">>"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["cast", "silent"], ["**"]].forEach(function(t3, e3) {
        t3.forEach(function(t4) {
          qn2.precedence[t4] = e3 + 1;
        });
      }), qn2.prototype.isRightAssociative = function(t3) {
        return t3 === "**" || t3 === "??";
      }, qn2.prototype.swapLocations = function(t3, e3, i3, n3) {
        this.withPositions && (t3.loc.start = e3.loc.start, t3.loc.end = i3.loc.end, this.withSource && (t3.loc.source = n3.lexer._input.substring(t3.loc.start.offset, t3.loc.end.offset)));
      }, qn2.prototype.resolveLocations = function(t3, e3, i3, n3) {
        this.withPositions && (t3.loc.start.offset > e3.loc.start.offset && (t3.loc.start = e3.loc.start), t3.loc.end.offset < i3.loc.end.offset && (t3.loc.end = i3.loc.end), this.withSource && (t3.loc.source = n3.lexer._input.substring(t3.loc.start.offset, t3.loc.end.offset)));
      }, qn2.prototype.resolvePrecedence = function(t3, e3) {
        var i3, n3, s3;
        return t3.kind === "call" ? this.resolveLocations(t3, t3.what, t3, e3) : t3.kind === "propertylookup" || t3.kind === "staticlookup" || t3.kind === "offsetlookup" && t3.offset ? this.resolveLocations(t3, t3.what, t3.offset, e3) : t3.kind === "bin" ? t3.right && !t3.right.parenthesizedExpression && (t3.right.kind === "bin" ? (n3 = qn2.precedence[t3.type], s3 = qn2.precedence[t3.right.type], n3 && s3 && s3 <= n3 && (t3.type !== t3.right.type || !this.isRightAssociative(t3.type)) && (i3 = t3.right, t3.right = t3.right.left, this.swapLocations(t3, t3.left, t3.right, e3), i3.left = this.resolvePrecedence(t3, e3), this.swapLocations(i3, i3.left, i3.right, e3), t3 = i3)) : t3.right.kind === "retif" && (n3 = qn2.precedence[t3.type], s3 = qn2.precedence["?"], n3 && s3 && s3 <= n3 && (i3 = t3.right, t3.right = t3.right.test, this.swapLocations(t3, t3.left, t3.right, e3), i3.test = this.resolvePrecedence(t3, e3), this.swapLocations(i3, i3.test, i3.falseExpr, e3), t3 = i3))) : t3.kind !== "silent" && t3.kind !== "cast" || !t3.expr || t3.expr.parenthesizedExpression ? t3.kind === "unary" ? t3.what && !t3.what.parenthesizedExpression && (t3.what.kind === "bin" ? (i3 = t3.what, t3.what = t3.what.left, this.swapLocations(t3, t3, t3.what, e3), i3.left = this.resolvePrecedence(t3, e3), this.swapLocations(i3, i3.left, i3.right, e3), t3 = i3) : t3.what.kind === "retif" && (i3 = t3.what, t3.what = t3.what.test, this.swapLocations(t3, t3, t3.what, e3), i3.test = this.resolvePrecedence(t3, e3), this.swapLocations(i3, i3.test, i3.falseExpr, e3), t3 = i3)) : t3.kind === "retif" ? t3.falseExpr && t3.falseExpr.kind === "retif" && !t3.falseExpr.parenthesizedExpression && (i3 = t3.falseExpr, t3.falseExpr = i3.test, this.swapLocations(t3, t3.test, t3.falseExpr, e3), i3.test = this.resolvePrecedence(t3, e3), this.swapLocations(i3, i3.test, i3.falseExpr, e3), t3 = i3) : t3.kind === "assign" ? t3.right && t3.right.kind === "bin" && !t3.right.parenthesizedExpression && (n3 = qn2.precedence["="], s3 = qn2.precedence[t3.right.type], n3 && s3 && s3 < n3 && (i3 = t3.right, t3.right = t3.right.left, i3.left = t3, this.swapLocations(i3, i3.left, t3.right, e3), t3 = i3)) : t3.kind === "expressionstatement" && this.swapLocations(t3, t3.expression, t3, e3) : t3.expr.kind === "bin" ? (i3 = t3.expr, t3.expr = t3.expr.left, this.swapLocations(t3, t3, t3.expr, e3), i3.left = this.resolvePrecedence(t3, e3), this.swapLocations(i3, i3.left, i3.right, e3), t3 = i3) : t3.expr.kind === "retif" && (i3 = t3.expr, t3.expr = t3.expr.test, this.swapLocations(t3, t3, t3.expr, e3), i3.test = this.resolvePrecedence(t3, e3), this.swapLocations(i3, i3.test, i3.falseExpr, e3), t3 = i3), t3;
      }, qn2.prototype.prepare = function(t3, e3, i3) {
        var n3 = null;
        (this.withPositions || this.withSource) && (n3 = i3.position());
        var s3 = this, r3 = function r4() {
          var o3 = null, a3 = Array.prototype.slice.call(arguments);
          if (a3.push(e3), s3.withPositions || s3.withSource) {
            var h3 = null;
            s3.withSource && (h3 = i3.lexer._input.substring(n3.offset, i3.prev[2])), o3 = new z2(h3, n3, new m2(i3.prev[0], i3.prev[1], i3.prev[2])), a3.push(o3);
          }
          t3 || (t3 = a3.shift());
          var l3 = s3[t3];
          if (typeof l3 != "function")
            throw new Error('Undefined node "' + t3 + '"');
          var c3 = Object.create(l3.prototype);
          return l3.apply(c3, a3), r4.instance = c3, r4.trailingComments && (c3.trailingComments = r4.trailingComments), typeof r4.postBuild == "function" && r4.postBuild(c3), i3.debug && delete qn2.stack[r4.stackUid], s3.resolvePrecedence(c3, i3);
        };
        return i3.debug && (qn2.stack || (qn2.stack = {}, qn2.stackUid = 1), qn2.stack[++qn2.stackUid] = { position: n3, stack: new Error().stack.split("\n").slice(3, 5) }, r3.stackUid = qn2.stackUid), r3.setTrailingComments = function(t4) {
          r3.instance ? r3.instance.setTrailingComments(t4) : r3.trailingComments = t4;
        }, r3.destroy = function(t4) {
          e3 && (t4 ? t4.leadingComments ? t4.leadingComments = e3.concat(t4.leadingComments) : t4.leadingComments = e3 : i3._docIndex = i3._docs.length - e3.length), i3.debug && delete qn2.stack[r3.stackUid];
        }, r3;
      }, qn2.prototype.checkNodes = function() {
        var t3 = [];
        for (var e3 in qn2.stack)
          qn2.stack.hasOwnProperty(e3) && t3.push(qn2.stack[e3]);
        return qn2.stack = {}, t3;
      }, [tt2, it2, st2, ot2, ht2, ct2, dt2, kt2, yt2, At2, Nt2, St2, Lt2, It2, wt2, Mt2, Wt2, Yt2, $t2, zt2, Xt2, qt2, te2, Ht2, ie2, Ut2, re2, ae2, he2, ce2, _e2, fe2, ke2, Ee2, ye2, Ae2, Ne2, q2, Se2, be2, Oe2, Re2, De2, Ue2, Me2, He2, Ge2, We2, Ye2, $e2, Ke2, Je2, Ze2, Et2, ei2, ni2, ri2, ai2, li2, pi2, Ti2, mi2, Ei2, X2, yi2, Ai2, Ni2, Si2, Li2, Ii2, _t2, wi2, Pi2, Bi2, Mi2, Hi2, Vi2, Qi2, ji2, Ki2, ui2, Ji2, Zi2, en2, sn2, ft2, on2, hn2, cn2, _n2, pn2, Tn2, mn2, xn2, vn2, gn2, Cn2, Sn2, On2, Rn2, Dn2, Un2, Mn2, Gn2, Wn2, Yn2, $n2, Kn2, Jn2].forEach(function(t3) {
        qn2.prototype[t3.kind] = t3;
      });
      var Zn2 = qn2;
      function ts2(t3, e3) {
        for (var i3 = Object.keys(t3), n3 = i3.length; n3--; ) {
          var s3 = i3[n3], r3 = t3[s3];
          r3 === null ? delete e3[s3] : typeof r3 == "function" ? e3[s3] = r3.bind(e3) : Array.isArray(r3) ? e3[s3] = Array.isArray(e3[s3]) ? e3[s3].concat(r3) : r3 : e3[s3] = typeof r3 == "object" && typeof e3[s3] == "object" ? ts2(r3, e3[s3]) : r3;
        }
        return e3;
      }
      var es2 = function(t3) {
        if (typeof this == "function")
          return new this(t3);
        if (this.tokens = $2, this.lexer = new k2(this), this.ast = new Zn2(), this.parser = new j2(this.lexer, this.ast), t3 && typeof t3 == "object") {
          if (t3.parser && (t3.lexer || (t3.lexer = {}), t3.parser.version)) {
            if (typeof t3.parser.version == "string") {
              var e3 = t3.parser.version.split(".");
              if (e3 = 100 * parseInt(e3[0]) + parseInt(e3[1]), isNaN(e3))
                throw new Error("Bad version number : " + t3.parser.version);
              t3.parser.version = e3;
            } else if (typeof t3.parser.version != "number")
              throw new Error("Expecting a number for version");
            if (t3.parser.version < 500 || t3.parser.version > 900)
              throw new Error("Can only handle versions between 5.x to 8.x");
          }
          ts2(t3, this), this.lexer.version = this.parser.version;
        }
      }, is2 = function(t3) {
        return typeof t3.write == "function" ? t3.toString() : t3;
      };
      es2.create = function(t3) {
        return new es2(t3);
      }, es2.parseEval = function(t3, e3) {
        return new es2(e3).parseEval(t3);
      }, es2.prototype.parseEval = function(t3) {
        return this.lexer.mode_eval = true, this.lexer.all_tokens = false, t3 = is2(t3), this.parser.parse(t3, "eval");
      }, es2.parseCode = function(t3, e3, i3) {
        return typeof e3 != "object" || i3 || (i3 = e3, e3 = "unknown"), new es2(i3).parseCode(t3, e3);
      }, es2.prototype.parseCode = function(t3, e3) {
        return this.lexer.mode_eval = false, this.lexer.all_tokens = false, t3 = is2(t3), this.parser.parse(t3, e3);
      }, es2.tokenGetAll = function(t3, e3) {
        return new es2(e3).tokenGetAll(t3);
      }, es2.prototype.tokenGetAll = function(t3) {
        this.lexer.mode_eval = false, this.lexer.all_tokens = true, t3 = is2(t3);
        var e3 = this.lexer.EOF, i3 = this.tokens.values;
        this.lexer.setInput(t3);
        for (var n3 = this.lexer.lex() || e3, s3 = []; n3 != e3; ) {
          var r3 = this.lexer.yytext;
          i3.hasOwnProperty(n3) && (r3 = [i3[n3], r3, this.lexer.yylloc.first_line]), s3.push(r3), n3 = this.lexer.lex() || e3;
        }
        return s3;
      };
      var ns2 = es2, ss2 = $2, rs2 = k2, os2 = Zn2, as2 = j2, hs2 = ts2, ls2 = es2;
      ns2.tokens = ss2, ns2.lexer = rs2, ns2.AST = os2, ns2.parser = as2, ns2.combine = hs2, ns2.default = ls2;
      var cs2 = function(t3, e3, i3) {
        var n3 = i3 && i3.parentParser === "markdown";
        if (!t3 && n3)
          return "";
        t3 = t3.replace(/\?>\r?\n<\?/g, "?>\n___PSEUDO_INLINE_PLACEHOLDER___<?");
        var s3, r3 = new ns2({ parser: { extractDoc: true }, ast: { withPositions: true, withSource: true } }), o3 = t3.indexOf("<?php") !== -1, a3 = n3 && !o3;
        try {
          s3 = a3 ? r3.parseEval(t3) : r3.parseCode(t3);
        } catch (t4) {
          throw t4 instanceof SyntaxError && "lineNumber" in t4 && (t4.loc = { start: { line: t4.lineNumber, column: t4.columnNumber } }, delete t4.lineNumber, delete t4.columnNumber), t4;
        }
        return s3.extra = { parseAsEval: a3 }, s3.comments.forEach(function(t4) {
          t4.value[t4.value.length - 1] === "\r" && (t4.value = t4.value.slice(0, -1), t4.loc.end.offset = t4.loc.end.offset - 1), t4.value[t4.value.length - 1] === "\n" && (t4.value = t4.value.slice(0, -1), t4.loc.end.offset = t4.loc.end.offset - 1);
        }), s3;
      }, us2 = n2.default.util, _s2 = us2.hasNewline, ds2 = us2.skipEverythingButNewLine, ps2 = us2.skipNewline, fs2 = us2.isNextLineEmpty, Ts2 = us2.isPreviousLineEmpty, ks2 = us2.getNextNonSpaceNonCommentCharacterIndex, ms2 = n2.default.version;
      function Es2(t3, e3) {
        return parseInt(ms2[0]) > 1 ? t3[e3] : t3;
      }
      var xs2 = {};
      function ys2(t3) {
        return xs2[t3];
      }
      [["or"], ["xor"], ["and"], ["=", "+=", "-=", "*=", "**=", "/=", ".=", "%=", "&=", "|=", "^=", "<<=", ">>="], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!==", "<>", "<=>"], ["<", ">", "<=", ">="], [">>", "<<"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["++", "--", "~"], ["**"]].forEach(function(t3, e3) {
        t3.forEach(function(t4) {
          xs2[t4] = e3;
        });
      });
      var vs2 = ["==", "!=", "===", "!==", "<>", "<=>"], As2 = ["*", "/", "%"], gs2 = [">>", "<<"];
      function Ns2(t3) {
        return ["block", "program", "namespace", "class", "interface", "trait", "traituse", "declare"].includes(t3.kind);
      }
      function Cs2(t3) {
        var e3 = t3.body;
        return e3 ? (e3.kind === "block" && (e3 = e3.children), e3[0]) : null;
      }
      function Ss2(t3) {
        var e3 = t3.children || t3.body || t3.adaptations;
        return Array.isArray(e3) ? e3 : null;
      }
      function bs2(t3) {
        var e3 = t3.getParentNode();
        return e3 ? Ss2(e3) : null;
      }
      function Ls2(t3) {
        return t3.length > 0 ? t3[t3.length - 1] : null;
      }
      function Os2(t3) {
        var e3 = t3.getValue();
        if (e3.kind === "program") {
          var i3 = Ss2(e3);
          return !(!i3 || i3.length === 0) && i3[0].kind === "inline";
        }
        if (e3.kind === "switch") {
          if (!e3.body)
            return false;
          var n3 = Ss2(e3.body);
          if (n3.length === 0)
            return false;
          var s3 = A2(n3, 1)[0];
          if (!s3.body)
            return false;
          var r3 = Ss2(s3.body);
          return r3.length !== 0 && r3[0].kind === "inline";
        }
        var o3 = Cs2(e3);
        return !!o3 && o3.kind === "inline";
      }
      var Is2 = ["__construct", "__destruct", "__call", "__callStatic", "__get", "__set", "__isset", "__unset", "__sleep", "__wakeup", "__toString", "__invoke", "__set_state", "__clone", "__debugInfo"].reduce(function(t3, e3) {
        return t3[e3.toLowerCase()] = e3, t3;
      }, {});
      var Rs2 = { printNumber: function(t3) {
        return t3.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e)/, "");
      }, getPrecedence: ys2, isBitwiseOperator: function(t3) {
        return !!gs2[t3] || t3 === "|" || t3 === "^" || t3 === "&";
      }, shouldFlatten: function(t3, e3) {
        return ys2(e3) === ys2(t3) && (t3 !== "**" && ((!vs2.includes(t3) || !vs2.includes(e3)) && (!(e3 === "%" && As2.includes(t3) || t3 === "%" && As2.includes(e3)) && ((e3 === t3 || !As2.includes(e3) || !As2.includes(t3)) && (!gs2.includes(t3) || !gs2.includes(e3))))));
      }, nodeHasStatement: Ns2, getNodeListProperty: Ss2, getParentNodeListProperty: bs2, getLast: Ls2, getPenultimate: function(t3) {
        return t3.length > 1 ? t3[t3.length - 2] : null;
      }, isLastStatement: function(t3) {
        var e3 = bs2(t3);
        if (!e3)
          return true;
        var i3 = t3.getValue();
        return e3[e3.length - 1] === i3;
      }, getBodyFirstChild: Cs2, lineShouldEndWithSemicolon: function(t3) {
        var e3 = t3.getValue(), i3 = t3.getParentNode();
        if (!i3)
          return false;
        if (["for", "foreach", "while", "do", "if", "switch"].includes(i3.kind) && e3.kind !== "block" && e3.kind !== "if" && (i3.body === e3 || i3.alternate === e3))
          return true;
        if (!Ns2(i3))
          return false;
        if (e3.kind === "echo" && e3.shortForm)
          return false;
        if (e3.kind === "traituse")
          return !e3.adaptations;
        if (e3.kind === "method" && e3.isAbstract)
          return true;
        if (e3.kind === "method") {
          var n3 = t3.getParentNode();
          if (n3 && n3.kind === "interface")
            return true;
        }
        return ["expressionstatement", "do", "usegroup", "classconstant", "propertystatement", "traitprecedence", "traitalias", "goto", "constantstatement", "global", "static", "echo", "unset", "return", "break", "continue", "throw"].includes(e3.kind);
      }, fileShouldEndWithHardline: function(t3) {
        var e3 = t3.getValue(), i3 = e3.kind === "program", n3 = e3.children && Ls2(e3.children);
        if (!i3)
          return false;
        if (n3 && ["halt", "inline"].includes(n3.kind))
          return false;
        if (n3 && (n3.kind === "declare" || n3.kind === "namespace")) {
          var s3 = n3.children.length > 0 && Ls2(n3.children);
          if (s3 && ["halt", "inline"].includes(s3.kind))
            return false;
        }
        return true;
      }, maybeStripLeadingSlashFromUse: function(t3) {
        var e3 = t3.replace(/^\\/, "");
        return e3.indexOf("\\") !== -1 ? e3 : t3;
      }, hasDanglingComments: function(t3) {
        return t3.comments && t3.comments.some(function(t4) {
          return !t4.leading && !t4.trailing;
        });
      }, hasLeadingComment: function(t3) {
        return t3.comments && t3.comments.some(function(t4) {
          return t4.leading;
        });
      }, hasTrailingComment: function(t3) {
        return t3.comments && t3.comments.some(function(t4) {
          return t4.trailing;
        });
      }, docShouldHaveTrailingNewline: function t3(e3) {
        var i3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n3 = e3.getNode(i3), s3 = e3.getNode(i3 + 1), r3 = e3.getNode(i3 + 2);
        if (!s3)
          return false;
        if (r3 && ["call", "new", "echo"].includes(r3.kind) && !["call", "array"].includes(s3.kind) || s3.kind === "parameter") {
          var o3 = r3.arguments.length - 1, a3 = r3.arguments.indexOf(s3);
          return a3 !== o3;
        }
        if (r3 && r3.kind === "for") {
          var h3 = r3.init.indexOf(s3);
          if (h3 !== -1)
            return h3 !== r3.init.length - 1;
          var l3 = r3.test.indexOf(s3);
          if (l3 !== -1)
            return l3 !== r3.test.length - 1;
          var c3 = r3.increment.indexOf(s3);
          if (c3 !== -1)
            return c3 !== r3.increment.length - 1;
        }
        if (s3.kind === "bin")
          return s3.left === n3 || t3(e3, i3 + 1);
        if (s3.kind === "case" && s3.test === n3)
          return true;
        if (s3.kind === "staticvariable") {
          var u3 = r3.variables.length - 1, _3 = r3.variables.indexOf(s3);
          return _3 !== u3;
        }
        if (s3.kind === "entry") {
          if (s3.key === n3)
            return true;
          var d3 = r3.items.length - 1, p3 = r3.items.indexOf(s3);
          return p3 !== d3;
        }
        if (["call", "new"].includes(s3.kind)) {
          var f3 = s3.arguments.length - 1, T3 = s3.arguments.indexOf(n3);
          return T3 !== f3;
        }
        if (s3.kind === "echo") {
          var k3 = s3.expressions.length - 1, m3 = s3.expressions.indexOf(n3);
          return m3 !== k3;
        }
        if (s3.kind === "array") {
          var E3 = s3.items.length - 1, x3 = s3.items.indexOf(n3);
          return x3 !== E3;
        }
        return s3.kind === "retif" && t3(e3, i3 + 1);
      }, isLookupNode: function(t3) {
        return t3.kind === "propertylookup" || t3.kind === "staticlookup" || t3.kind === "offsetlookup";
      }, isFirstChildrenInlineNode: Os2, shouldPrintHardLineAfterStartInControlStructure: function(t3) {
        var e3 = t3.getValue();
        return !["try", "catch"].includes(e3.kind) && Os2(t3);
      }, shouldPrintHardLineBeforeEndInControlStructure: function(t3) {
        var e3 = t3.getValue();
        if (["try", "catch"].includes(e3.kind))
          return true;
        if (e3.kind === "switch") {
          var i3 = Ss2(e3.body);
          if (i3.length === 0)
            return true;
          var n3 = Ls2(i3);
          if (!n3.body)
            return true;
          var s3 = Ss2(n3.body);
          return s3.length === 0 || s3[0].kind !== "inline";
        }
        return !Os2(t3);
      }, getAlignment: function(t3) {
        var e3 = t3.split("\n").pop();
        return e3.length - e3.trimLeft().length + 1;
      }, isProgramLikeNode: function(t3) {
        return ["program", "declare", "namespace"].includes(t3.kind);
      }, isReferenceLikeNode: function(t3) {
        return ["name", "parentreference", "selfreference", "staticreference"].includes(t3.kind);
      }, getNodeKindIncludingLogical: function(t3) {
        return t3.kind === "bin" && ["||", "&&"].includes(t3.type) ? "logical" : t3.kind;
      }, useDoubleQuote: function(t3, e3) {
        if (t3.isDoubleQuote === e3.singleQuote) {
          var i3 = t3.raw.slice(t3.raw[0] === "b" ? 2 : 1, -1).match(/\\([$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})|\r?\n|'|"|\$/);
          return t3.isDoubleQuote ? i3 : !i3;
        }
        return t3.isDoubleQuote;
      }, hasEmptyBody: function(t3) {
        var e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "body", i3 = t3.getValue();
        return i3[e3] && i3[e3].children && i3[e3].children.length === 0 && (!i3[e3].comments || i3[e3].comments.length === 0);
      }, isNextLineEmptyAfterNamespace: function(t3, e3, i3) {
        var n3 = i3(e3);
        return n3 = ds2(t3, n3), n3 = ps2(t3, n3), _s2(t3, n3);
      }, shouldPrintHardlineBeforeTrailingComma: function(t3) {
        return t3.kind === "nowdoc" || t3.kind === "encapsed" && t3.type === "heredoc" || t3.kind === "entry" && (t3.value.kind === "nowdoc" || t3.value.kind === "encapsed" && t3.value.type === "heredoc");
      }, isDocNode: function(t3) {
        return t3.kind === "nowdoc" || t3.kind === "encapsed" && t3.type === "heredoc";
      }, getAncestorNode: function(t3, e3) {
        var i3 = function(t4, e4) {
          for (var i4, n3 = [].concat(e4), s3 = -1; i4 = t4.getParentNode(++s3); )
            if (n3.indexOf(i4.kind) !== -1)
              return s3;
          return -1;
        }(t3, e3);
        return i3 === -1 ? null : t3.getParentNode(i3);
      }, getNextNode: function(t3, e3) {
        var i3 = t3.getParentNode(), n3 = Ss2(i3);
        if (!n3)
          return null;
        var s3 = n3.indexOf(e3);
        return s3 === -1 ? null : i3.children[s3 + 1];
      }, normalizeMagicMethodName: function(t3) {
        var e3 = t3.toLowerCase();
        return Is2[e3] ? Is2[e3] : t3;
      }, isPreviousLineEmpty: function(t3, e3, i3) {
        return Ts2(t3, e3, Es2(i3, "locStart"));
      }, isNextLineEmpty: function(t3, e3, i3) {
        return fs2(t3, e3, Es2(i3, "locEnd"));
      }, getNextNonSpaceNonCommentCharacterIndex: function(t3, e3, i3) {
        return ks2(t3, e3, Es2(i3, "locEnd"));
      } }, ws2 = n2.default.util, Ds2 = ws2.addLeadingComment, Ps2 = ws2.addDanglingComment, Us2 = ws2.addTrailingComment, Bs2 = ws2.skipNewline, Ms2 = ws2.hasNewline, Fs2 = ws2.hasNewlineInRange, Hs2 = n2.default.doc.builders, Gs2 = Hs2.concat, Vs2 = Hs2.join, Ws2 = Hs2.indent, Qs2 = Hs2.hardline, Ys2 = Hs2.cursor, js2 = Hs2.lineSuffix, $s2 = Hs2.breakParent, zs2 = Rs2.getNextNonSpaceNonCommentCharacterIndex, Ks2 = Rs2.isNextLineEmpty, Xs2 = Rs2.isPreviousLineEmpty, Js2 = Rs2.isLookupNode;
      function qs2(t3, e3) {
        var i3 = t3.children;
        i3.length === 0 ? Ps2(t3, e3) : Ds2(i3[0], e3);
      }
      function Zs2(t3, e3) {
        t3.kind === "block" ? qs2(t3, e3) : Ds2(t3, e3);
      }
      function tr2(t3, e3, i3, n3, s3, r3) {
        var o3 = zs2(t3, s3, r3), a3 = t3.charAt(o3);
        return e3 && e3.kind === "identifier" && i3 && (i3.kind === "function" || i3.kind === "method") && a3 === ")" ? (Us2(i3, s3), true) : !(!i3 || i3.kind !== "function" && i3.kind !== "method" || !n3 || n3.kind !== "block") && (qs2(n3, s3), true);
      }
      function er2(t3, e3, i3, n3, s3, r3) {
        if (!i3 || i3.kind !== "if" || !n3)
          return false;
        var o3 = zs2(t3, s3, r3);
        return t3.charAt(o3) === ")" ? (Us2(e3, s3), true) : e3 === i3.body && n3 === i3.alternate ? (Ps2(i3, s3), true) : n3.kind === "if" ? (Zs2(n3.body, s3), true) : i3.body === n3 && (Ds2(n3, s3), true);
      }
      function ir2(t3, e3, i3) {
        if (t3 && ["class", "interface", "trait"].includes(t3.kind)) {
          if (e3 && t3.extends) {
            if (Array.isArray(t3.extends)) {
              if (t3.extends.some(function(t4) {
                if (e3 && e3 === t4)
                  return Ps2(e3, i3), true;
              }))
                return true;
            } else if (e3 === t3.extends)
              return Ps2(e3, i3), true;
          }
          if (e3 && t3.implements && t3.implements.some(function(t4) {
            if (e3 && e3 === t4)
              return Ps2(e3, i3), true;
          }))
            return true;
          if (!(t3.body && t3.body.length > 0))
            return Ps2(t3, i3), true;
        }
        return !!(e3 && e3.kind === "class" && e3.isAnonymous && e3.leadingComments && i3.kind === "commentblock");
      }
      function nr2(t3, e3, i3, n3, s3) {
        if (e3 && (e3.kind === "function" || e3.kind === "method")) {
          for (var r3 = 0, o3 = 0; o3 < e3.arguments.length; o3++)
            r3 = s3.locEnd(e3.arguments[o3]) > r3 ? s3.locEnd(e3.arguments[o3]) : r3;
          var a3 = e3.body && s3.locStart(n3) > r3 && s3.locEnd(n3) < s3.locStart(e3.body), h3 = zs2(t3, n3, s3);
          if (e3.type && a3 && t3.charAt(h3) !== ")")
            return s3.locEnd(n3) < s3.locStart(e3.type) ? (Ps2(e3.type, n3), true) : (Us2(e3.type, n3), true);
        }
        return false;
      }
      function sr2(t3, e3, i3, n3, s3) {
        return !(!i3 || !["function", "method", "parameter"].includes(i3.kind)) && (e3.kind === "typereference" && n3.kind === "identifier" && (Us2(e3, s3), true));
      }
      function rr2(t3, e3) {
        return !(!t3 || !["label", "goto"].includes(t3.kind)) && (Us2(t3, e3), true);
      }
      function or2(t3, e3, i3, n3) {
        return i3 && i3.kind === "inline" ? (i3.leadingComments || (i3.leadingComments = []), i3.leadingComments.includes(n3) || i3.leadingComments.push(n3), true) : !(t3 || i3 || !e3 || e3.kind !== "inline") && (Ps2(e3, n3), true);
      }
      function ar2(t3, e3, i3) {
        return !(!t3 || t3.kind !== "try" || !e3) && (e3.kind === "block" ? (qs2(e3, i3), true) : e3.kind === "try" ? (Zs2(e3.always, i3), true) : e3.kind === "catch" && (Zs2(e3.body, i3), true));
      }
      function hr2(t3, e3, i3, n3) {
        return i3 || e3 || !t3 || t3.kind !== "namespace" || t3.withBrackets ? !(e3 || !t3 || t3.kind !== "namespace" || t3.withBrackets) && (Ps2(t3, n3), true) : (Us2(t3, n3), true);
      }
      function lr2(t3, e3, i3, n3) {
        return !(!t3 || t3.kind !== "declare") && ((!e3 || e3.kind !== "noop") && (i3 && t3.directives[0] !== i3 ? !(!i3 || !e3) && (Ds2(i3, n3), true) : (t3.mode === "none" ? Us2(t3, n3) : Ps2(t3, n3), true)));
      }
      function cr2(t3, e3, i3, n3, s3, r3) {
        if (!i3 || i3.kind !== "while" || !n3)
          return false;
        var o3 = zs2(t3, s3, r3);
        return t3.charAt(o3) === ")" ? (Us2(e3, s3), true) : n3.kind === "block" && (qs2(n3, s3), true);
      }
      function ur2(t3, e3) {
        return t3.getValue().printed = true, e3.printer.printComment(t3, e3);
      }
      function _r2(t3, e3, i3) {
        return t3.getNode() === e3.cursorNode && t3.getValue() ? Gs2([Ys2, i3, Ys2]) : i3;
      }
      var dr2 = { handleOwnLineComment: function(t3, e3, i3) {
        var n3 = t3.precedingNode, s3 = t3.enclosingNode, r3 = t3.followingNode;
        return tr2(e3, n3, s3, r3, t3, i3) || function(t4, e4, i4) {
          if (t4 && Js2(t4) && e4 && ["identifier", "variable", "encapsed"].includes(e4.kind))
            return Ds2(t4, i4), true;
          return false;
        }(s3, r3, t3) || er2(e3, n3, s3, r3, t3, i3) || cr2(e3, n3, s3, r3, t3, i3) || ar2(s3, r3, t3) || ir2(s3, r3, t3) || sr2(e3, n3, s3, r3, t3) || nr2(e3, s3, r3, t3, i3) || function(t4, e4, i4, n4) {
          if (!i4 && t4 && (t4.kind === "for" || t4.kind === "foreach"))
            return t4.body && t4.body.kind !== "block" ? Ds2(i4, n4) : Ds2(t4, n4), true;
          return false;
        }(s3, 0, r3, t3) || or2(s3, n3, r3, t3) || lr2(s3, n3, r3, t3);
      }, handleEndOfLineComment: function(t3, e3, i3) {
        var n3 = t3.precedingNode, s3 = t3.enclosingNode, r3 = t3.followingNode;
        return function(t4, e4, i4, n4, s4) {
          if (!e4 && !n4 && i4 && i4.kind === "array")
            return Us2(i4, s4), true;
          return false;
        }(0, n3, s3, r3, t3) || function(t4, e4, i4, n4, s4) {
          if (i4 && i4.kind === "return" && !i4.expr)
            return Us2(i4, s4), true;
          return false;
        }(0, 0, s3, 0, t3) || tr2(e3, n3, s3, r3, t3, i3) || function(t4, e4, i4, n4, s4, r4) {
          var o3 = e4 && !Fs2(s4, r4.locEnd(e4), r4.locStart(n4));
          if ((!e4 || !o3) && t4 && t4.kind === "retif" && i4)
            return Ds2(i4, n4), true;
          return false;
        }(s3, n3, r3, t3, e3, i3) || er2(e3, n3, s3, r3, t3, i3) || cr2(e3, n3, s3, r3, t3, i3) || ar2(s3, r3, t3) || ir2(s3, r3, t3) || sr2(e3, n3, s3, r3, t3) || nr2(e3, s3, r3, t3, i3) || function(t4, e4) {
          if (t4 && t4.kind === "entry")
            return Ds2(t4, e4), true;
          return false;
        }(s3, t3) || function(t4, e4, i4) {
          if (e4 && e4.kind === "call" && t4 && e4.what === t4 && e4.arguments.length > 0)
            return Ds2(e4.arguments[0], i4), true;
          return false;
        }(n3, s3, t3) || function(t4, e4, i4) {
          if (t4 && t4.kind === "assign" && e4) {
            var n4 = t4.loc.start.offset + t4.loc.source.indexOf("=");
            if (i4.loc.start.offset > n4)
              return Ds2(e4, i4), true;
          }
          return false;
        }(s3, r3, t3) || or2(s3, n3, r3, t3) || hr2(s3, n3, r3, t3) || lr2(s3, n3, r3, t3) || rr2(s3, t3);
      }, handleRemainingComment: function(t3, e3, i3) {
        var n3 = t3.precedingNode, s3 = t3.enclosingNode, r3 = t3.followingNode;
        return er2(e3, n3, s3, r3, t3, i3) || cr2(e3, n3, s3, r3, t3, i3) || function(t4, e4, i4, n4) {
          var s4 = zs2(t4, i4, n4);
          if (t4.charAt(s4) !== ")")
            return false;
          if (e4 && (e4.kind === "function" || e4.kind === "closure" || e4.kind === "method" || e4.kind === "call" || e4.kind === "new") && e4.arguments.length === 0)
            return Ps2(e4, i4), true;
          return false;
        }(e3, s3, t3, i3) || ir2(s3, r3, t3) || function(t4, e4, i4) {
          if (t4 && t4.kind === "traituse" && t4.adaptations && !t4.adaptations.length)
            return Ps2(t4, i4), true;
          return false;
        }(s3, 0, t3) || sr2(e3, n3, s3, r3, t3) || nr2(e3, s3, r3, t3, i3) || rr2(s3, t3) || function(t4, e4, i4, n4) {
          if (e4 && e4.kind === "halt")
            return Ps2(e4, n4), true;
          if (t4 && t4.kind === "halt")
            return Ps2(t4, n4), true;
          return false;
        }(n3, s3, 0, t3) || function(t4, e4) {
          if (t4 && (t4.kind === "continue" || t4.kind === "break") && !t4.label)
            return Us2(t4, e4), true;
          return false;
        }(s3, t3) || or2(s3, n3, r3, t3) || hr2(s3, n3, r3, t3);
      }, getCommentChildNodes: function(t3) {
        return typeof t3 != "object" ? [] : function(t4) {
          return Object.keys(t4).filter(function(t5) {
            return t5 !== "kind" && t5 !== "loc" && t5 !== "errors" && t5 !== "extra" && t5 !== "comments" && t5 !== "leadingComments" && t5 !== "enclosingNode" && t5 !== "precedingNode" && t5 !== "followingNode";
          }).map(function(e3) {
            return t4[e3];
          });
        }(t3);
      }, canAttachComment: function(t3) {
        return t3.kind && t3.kind !== "commentblock" && t3.kind !== "commentline";
      }, isBlockComment: function(t3) {
        return t3.kind === "commentblock";
      }, printDanglingComments: function(t3, e3, i3, n3) {
        var s3 = [], r3 = t3.getValue();
        return r3 && r3.comments ? (t3.each(function(t4) {
          var i4 = t4.getValue();
          !i4 || i4.leading || i4.trailing || n3 && !n3(i4) || s3.push(ur2(t4, e3));
        }, "comments"), s3.length === 0 ? "" : i3 ? Vs2(Qs2, s3) : Ws2(Gs2([Qs2, Vs2(Qs2, s3)]))) : "";
      }, hasLeadingComment: function(t3) {
        return t3.comments && t3.comments.some(function(t4) {
          return t4.leading;
        });
      }, hasTrailingComment: function(t3) {
        return t3.comments && t3.comments.some(function(t4) {
          return t4.trailing;
        });
      }, hasLeadingOwnLineComment: function(t3, e3, i3) {
        return e3.comments && e3.comments.some(function(e4) {
          return e4.leading && Ms2(t3, i3.locEnd(e4));
        });
      }, printComments: function(t3, e3) {
        var i3 = [];
        return t3.forEach(function(t4, n3, s3) {
          t4.printed = true;
          var r3 = s3.length === n3 + 1;
          i3.push(t4.value), r3 || i3.push(Qs2), Ks2(e3.originalText, t4, e3) && !r3 && i3.push(Qs2);
        }), Gs2(i3);
      }, printAllComments: function(t3, e3, i3, n3) {
        var s3 = t3.getValue(), r3 = e3(t3), o3 = s3 && s3.comments;
        if (!o3 || o3.length === 0)
          return _r2(t3, i3, r3);
        var a3 = [], h3 = [n3 ? ";" : "", r3];
        return t3.each(function(t4) {
          var e4 = t4.getValue(), n4 = e4.leading, s4 = e4.trailing;
          if (n4) {
            var r4 = function(t5, e5, i4) {
              var n5 = t5.getValue(), s5 = ur2(t5, i4);
              if (!s5)
                return "";
              var r5 = i4.printer.isBlockComment && i4.printer.isBlockComment(n5);
              return Gs2(r5 ? [s5, Ms2(i4.originalText, i4.locEnd(n5)) ? Qs2 : " "] : [s5, Qs2]);
            }(t4, 0, i3);
            if (!r4)
              return;
            a3.push(r4);
            var o4 = i3.originalText;
            Ms2(o4, Bs2(o4, i3.locEnd(e4))) && a3.push(Qs2);
          } else
            s4 && h3.push(function(t5, e5, i4) {
              var n5 = t5.getValue(), s5 = ur2(t5, i4);
              if (!s5)
                return "";
              var r5 = i4.printer.isBlockComment && i4.printer.isBlockComment(n5);
              if (Ms2(i4.originalText, i4.locStart(n5), { backwards: true })) {
                var o5 = Xs2(i4.originalText, n5, i4);
                return js2(Gs2([Qs2, o5 ? Qs2 : "", s5]));
              }
              return Gs2(r5 ? [" ", s5] : [js2(Gs2([" ", s5])), r5 ? "" : $s2]);
            }(t4, 0, i3));
        }, "comments"), _r2(t3, i3, Gs2(a3.concat(h3)));
      } };
      function pr2() {
      }
      pr2.strictEqual = function() {
      };
      var fr2 = pr2, Tr2 = Rs2.getPrecedence, kr2 = Rs2.shouldFlatten, mr2 = Rs2.isBitwiseOperator;
      var Er2 = function(t3) {
        var e3 = t3.getParentNode();
        if (!e3)
          return false;
        var i3 = t3.getName(), n3 = t3.getNode();
        if (["program", "expressionstatement", "namespace", "declare", "block", "include", "print", "return", "echo"].includes(e3.kind))
          return false;
        switch (n3.kind) {
          case "pre":
          case "post":
            if (e3.kind === "unary")
              return n3.kind === "pre" && (n3.type === "+" && e3.type === "+" || n3.type === "-" && e3.type === "-");
          case "unary":
            switch (e3.kind) {
              case "unary":
                return n3.type === e3.type && (n3.type === "+" || n3.type === "-");
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return i3 === "what" && e3.what === n3;
              case "bin":
                return e3.type === "**" && i3 === "left";
              default:
                return false;
            }
          case "bin":
            switch (e3.kind) {
              case "assign":
              case "retif":
                return ["and", "xor", "or"].includes(n3.type);
              case "silent":
              case "cast":
                return n3.parenthesizedExpression;
              case "pre":
              case "post":
              case "unary":
                return true;
              case "call":
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
                return i3 === "what" && e3.what === n3;
              case "bin":
                var s3 = e3.type, r3 = Tr2(s3), o3 = n3.type, a3 = Tr2(o3);
                return r3 > a3 || (s3 === "||" && o3 === "&&" || (r3 === a3 && i3 === "right" ? (fr2.strictEqual(e3.right, n3), true) : r3 === a3 && !kr2(s3, o3) || (r3 < a3 && o3 === "%" ? s3 === "+" || s3 === "-" : !!mr2(s3))));
              default:
                return false;
            }
          case "propertylookup":
          case "staticlookup":
            switch (e3.kind) {
              case "call":
                return i3 === "what" && e3.what === n3 && n3.parenthesizedExpression;
              default:
                return false;
            }
          case "clone":
          case "new":
            switch (e3.kind) {
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return i3 === "what" && e3.what === n3;
              default:
                return false;
            }
          case "yield":
            switch (e3.kind) {
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return i3 === "what" && e3.what === n3;
              case "retif":
                return e3.test === n3;
              default:
                return !(!n3.key && !n3.value);
            }
          case "assign":
            return (e3.kind !== "for" || !e3.init.includes(n3) && !e3.increment.includes(n3)) && (e3.kind !== "assign" && (e3.kind !== "static" && (!["if", "do", "while", "foreach", "switch"].includes(e3.kind) && (e3.kind !== "silent" && e3.kind !== "call"))));
          case "retif":
            switch (e3.kind) {
              case "cast":
                return true;
              case "unary":
              case "bin":
              case "retif":
                return !(i3 === "test" && !e3.trueExpr);
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return i3 === "what" && e3.what === n3;
              default:
                return false;
            }
          case "closure":
            switch (e3.kind) {
              case "call":
                return i3 === "what" && e3.what === n3;
              case "propertylookup":
                return true;
              default:
                return false;
            }
          case "silence":
          case "cast":
            return n3.parenthesizedExpression;
          case "string":
          case "array":
            switch (e3.kind) {
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return (!["string", "array"].includes(n3.kind) || e3.kind !== "offsetlookup") && (i3 === "what" && e3.what === n3);
              default:
                return false;
            }
          case "print":
          case "include":
            return e3.kind === "bin";
        }
        return false;
      }, xr2 = n2.default.doc.builders, yr2 = xr2.breakParent, vr2 = xr2.concat, Ar2 = xr2.join, gr2 = xr2.line, Nr2 = xr2.lineSuffix, Cr2 = xr2.group, Sr2 = xr2.conditionalGroup, br2 = xr2.indent, Lr2 = xr2.dedent, Or2 = xr2.ifBreak, Ir2 = xr2.hardline, Rr2 = xr2.softline, wr2 = xr2.literalline, Dr2 = xr2.align, Pr2 = xr2.dedentToRoot, Ur2 = n2.default.doc.utils.willBreak, Br2 = n2.default.util, Mr2 = Br2.isNextLineEmptyAfterIndex, Fr2 = Br2.hasNewline, Hr2 = Br2.hasNewlineInRange, Gr2 = Rs2.getLast, Vr2 = Rs2.getPenultimate, Wr2 = Rs2.isLastStatement, Qr2 = Rs2.lineShouldEndWithSemicolon, Yr2 = Rs2.printNumber, jr2 = Rs2.shouldFlatten, $r2 = Rs2.maybeStripLeadingSlashFromUse, zr2 = Rs2.fileShouldEndWithHardline, Kr2 = Rs2.hasDanglingComments, Xr2 = Rs2.hasLeadingComment, Jr2 = Rs2.hasTrailingComment, qr2 = Rs2.docShouldHaveTrailingNewline, Zr2 = Rs2.isLookupNode, to2 = Rs2.isFirstChildrenInlineNode, eo2 = Rs2.shouldPrintHardLineAfterStartInControlStructure, io2 = Rs2.shouldPrintHardLineBeforeEndInControlStructure, no2 = Rs2.getAlignment, so2 = Rs2.isProgramLikeNode, ro2 = Rs2.getNodeKindIncludingLogical, oo2 = Rs2.useDoubleQuote, ao2 = Rs2.hasEmptyBody, ho2 = Rs2.isNextLineEmptyAfterNamespace, lo2 = Rs2.shouldPrintHardlineBeforeTrailingComma, co2 = Rs2.isDocNode, uo2 = Rs2.getAncestorNode, _o2 = Rs2.isReferenceLikeNode, po2 = Rs2.getNextNode, fo2 = Rs2.normalizeMagicMethodName, To2 = Rs2.getNextNonSpaceNonCommentCharacterIndex, ko2 = Rs2.isNextLineEmpty;
      function mo2(t3, e3) {
        return parseFloat(t3) >= parseFloat(e3);
      }
      function Eo2(t3, e3) {
        return !!t3.trailingCommaPHP && mo2(t3.phpVersion, e3);
      }
      function xo2(t3) {
        switch (t3.braceStyle) {
          case "1tbs":
            return false;
          case "psr-2":
          default:
            return true;
        }
      }
      function yo2(t3, e3, i3) {
        var n3 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
        return vr2([n3 ? "?" : "", "->", t3.call(i3, "offset")]);
      }
      function vo2(t3, e3, i3) {
        return yo2(t3, e3, i3, true);
      }
      function Ao2(t3, e3, i3) {
        var n3 = t3.getValue(), s3 = !["variable", "identifier"].includes(n3.offset.kind);
        return vr2(["::", s3 ? "{" : "", t3.call(i3, "offset"), s3 ? "}" : ""]);
      }
      function go2(t3, e3, i3) {
        var n3 = t3.getValue(), s3 = n3.offset && n3.offset.kind === "number" || uo2(t3, "encapsed");
        return vr2(["[", n3.offset ? Cr2(vr2([br2(vr2([s3 ? "" : Rr2, t3.call(i3, "offset")])), s3 ? "" : Rr2])) : "", "]"]);
      }
      function No2(t3) {
        return t3.kind === "array" && (t3.items.length > 0 || t3.comments) || t3.kind === "function" || t3.kind === "method" || t3.kind === "closure";
      }
      function Co2(t3) {
        var e3 = Gr2(t3), i3 = Vr2(t3);
        return !Xr2(e3) && !Jr2(e3) && No2(e3) && (!i3 || i3.kind !== e3.kind);
      }
      function So2(t3) {
        if (t3.length !== 2)
          return false;
        var e3 = A2(t3, 2), i3 = e3[0], n3 = e3[1];
        return !(i3.comments && i3.comments.length || i3.kind !== "function" && i3.kind !== "method" && i3.kind !== "closure" || n3.kind === "retif" || No2(n3));
      }
      function bo2(t3, e3, i3) {
        var n3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "arguments", s3 = t3.getValue()[n3];
        if (s3.length === 0)
          return vr2(["(", dr2.printDanglingComments(t3, e3, true), ")"]);
        var r3 = false, o3 = false, a3 = s3.length - 1, h3 = t3.map(function(t4, n4) {
          var s4 = t4.getNode(), h4 = [i3(t4)];
          return n4 === a3 || (ko2(e3.originalText, s4, e3) ? (n4 === 0 && (o3 = true), r3 = true, h4.push(",", Ir2, Ir2)) : h4.push(",", gr2)), vr2(h4);
        }, n3), l3 = t3.getValue(), c3 = Gr2(s3), u3 = Eo2(e3, "7.3") && ["call", "new", "unset", "isset"].includes(l3.kind) || Eo2(e3, "8.0") && ["function", "closure", "method", "arrowfunc"].includes(l3.kind) ? br2(vr2([c3 && lo2(c3) ? Ir2 : "", ","])) : "";
        function _3() {
          return Cr2(vr2(["(", br2(vr2([gr2, vr2(h3)])), u3, gr2, ")"]), { shouldBreak: true });
        }
        var d3 = So2(s3), p3 = Co2(s3);
        if (d3 || p3) {
          var f3, T3 = (d3 ? h3.slice(1).some(Ur2) : h3.slice(0, -1).some(Ur2)) || r3, k3 = 0;
          t3.each(function(t4) {
            d3 && k3 === 0 && (f3 = [vr2([t4.call(function(t5) {
              return i3(t5, { expandFirstArg: true });
            }), h3.length > 1 ? "," : "", o3 ? Ir2 : gr2, o3 ? Ir2 : ""])].concat(h3.slice(1))), p3 && k3 === s3.length - 1 && (f3 = h3.slice(0, -1).concat(t4.call(function(t5) {
              return i3(t5, { expandLastArg: true });
            }))), k3++;
          }, n3);
          var m3 = h3.some(Ur2), E3 = vr2(["(", vr2(f3), ")"]);
          return vr2([m3 ? yr2 : "", Sr2([m3 ? Or2(_3(), E3) : E3, vr2(d3 ? ["(", Cr2(f3[0], { shouldBreak: true }), vr2(f3.slice(1)), ")"] : ["(", vr2(h3.slice(0, -1)), Cr2(Gr2(f3), { shouldBreak: true }), ")"]), Cr2(vr2(["(", br2(vr2([gr2, vr2(h3)])), Or2(u3), gr2, ")"]), { shouldBreak: true })], { shouldBreak: T3 })]);
        }
        return Cr2(vr2(["(", br2(vr2([Rr2, vr2(h3)])), Or2(u3), Rr2, ")"]), { shouldBreak: h3.some(Ur2) || r3 });
      }
      function Lo2(t3) {
        return t3.kind === "array" && t3.items.length !== 0;
      }
      function Oo2(t3) {
        return t3.right.kind === "array" && t3.right.items.length !== 0;
      }
      function Io2(t3, e3, i3) {
        var n3 = t3.getValue();
        switch (n3.kind) {
          case "propertylookup":
            return yo2(t3, e3, i3);
          case "nullsafepropertylookup":
            return vo2(t3, e3, i3);
          case "staticlookup":
            return Ao2(t3, 0, i3);
          case "offsetlookup":
            return go2(t3, 0, i3);
          default:
            return "Have not implemented lookup kind ".concat(n3.kind, " yet.");
        }
      }
      function Ro2(t3) {
        var e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i3 = e3.opening, n3 = i3 === void 0 || i3;
        if (t3.type === "heredoc")
          return n3 ? "<<<".concat(t3.label) : t3.label;
        var s3 = { string: '"', shell: "`" };
        return s3[t3.type] ? s3[t3.type] : "Unimplemented encapsed type ".concat(t3.type);
      }
      function wo2(t3, e3, i3) {
        var n3 = [], s3 = [];
        return t3.each(function(t4) {
          n3.push(vr2(s3)), n3.push(Cr2(i3(t4))), s3 = [",", gr2], t4.getValue() && ko2(e3.originalText, t4.getValue(), e3) && s3.push(Rr2);
        }, "items"), vr2(n3);
      }
      function Do2(t3, e3) {
        if (e3.length === 0)
          return t3;
        var i3 = 0;
        return e3.reduce(function(e4, n3) {
          var s3 = n3.start, r3 = n3.end, o3 = n3.alignment, a3 = n3.before, h3 = n3.after, l3 = vr2([a3 || "", vr2(t3.slice(s3, r3)), h3 || ""]), c3 = e4.concat(t3.slice(i3, s3), o3 ? Pr2(Cr2(vr2([Dr2(new Array(o3).join(" "), l3)]))) : Cr2(l3), r3 === t3.length - 1 ? t3.slice(r3) : "");
          return i3 = r3, c3;
        }, []);
      }
      function Po2(t3, e3, i3) {
        var n3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "children", s3 = t3.getValue(), r3 = t3.getParentNode(), o3 = -1, a3 = [], h3 = [];
        t3.map(function(l4, c4) {
          var u4 = l4.getValue(), _4 = u4.kind === "inline", d4 = i3(l4), p4 = s3[n3], f4 = p4[c4 + 1], T4 = !Wr2(l4) && !_4 && (f4 && f4.kind === "case" ? !to2(t3) : f4 && f4.kind !== "inline"), k4 = vr2([d4, T4 ? Ir2 : "", T4 && ko2(e3.originalText, u4, e3) ? Ir2 : ""]), m4 = c4 === 0, E4 = p4.length - 1 === c4, x3 = s3.kind === "block" && r3 && ["function", "closure", "method", "try", "catch"].includes(r3.kind), y3 = x3 && m4 ? "" : " ";
          if (_4 || !_4 && E4 && o3 >= 0) {
            var v3 = o3;
            if (_4 && (o3 = c4), _4 && !m4 || !_4 && E4) {
              var A3 = (_4 ? v3 : o3) + 1, g3 = E4 && !_4 ? c4 + 1 : c4, N3 = p4[_4 ? v3 : o3], C3 = N3 ? no2(N3.raw) : "", S3 = g3 - A3 > 1, b3 = S3 ? x3 && !N3 || so2(s3) && A3 === 0 ? "" : Ir2 : "", L3 = S3 && u4.kind !== "halt" ? x3 && E4 ? "" : Ir2 : "";
              S3 && (y3 = ""), h3.push({ start: A3, end: g3, alignment: C3, before: b3, after: L3 });
            }
          }
          if (_4) {
            var O3 = f4 && f4.kind === "echo" && f4.shortForm ? "<?=" : "<?php", I3 = u4.leadingComments && u4.leadingComments.length ? vr2([m4 && s3.kind !== "namespace" && !x3 ? "<?php" : "", s3.kind !== "namespace" && x3 ? "" : Ir2, dr2.printComments(u4.leadingComments, e3), Ir2, "?>"]) : so2(s3) && m4 && s3.kind !== "namespace" ? "" : vr2([y3, "?>"]), R3 = t3.getNode(c4 + 1), w3 = R3 && R3.children && R3.children.length, D3 = u4.comments && u4.comments.length ? vr2([O3, Ir2, w3 ? dr2.printComments(u4.comments, e3) : "", Ir2, w3 ? "?>" : ""]) : so2(s3) && E4 ? "" : vr2([O3, " "]);
            k4 = vr2([I3, k4, D3]);
          }
          a3.push(k4);
        }, n3);
        var l3 = Do2(a3, h3);
        if (s3.kind === "program" && !s3.extra.parseAsEval) {
          var c3 = [], u3 = A2(s3.children, 1), _3 = u3[0], d3 = !_3 || _3.kind !== "inline";
          if (d3) {
            var p3 = e3.originalText.trim().match(/^<\?(php|=)(\s+)?\S/), f3 = vr2([p3 && p3[2] && p3[2].includes("\n") ? vr2([Ir2, p3[2].split("\n").length > 2 ? Ir2 : ""]) : " ", s3.comments ? dr2.printComments(s3.comments, e3) : ""]), T3 = _3 && _3.kind === "echo" && _3.shortForm;
            c3.push(vr2([T3 ? "<?=" : "<?php", f3]));
          }
          c3.push(vr2(l3));
          var k3 = e3.originalText.trim().endsWith("?>");
          if (k3) {
            var m3 = Gr2(s3.children), E3 = m3 ? vr2([Hr2(e3.originalText.trimEnd(), e3.locEnd(m3), e3.locEnd(s3)) ? Ir2 : " ", ko2(e3.originalText, m3, e3) ? Ir2 : ""]) : s3.comments ? Ir2 : "";
            c3.push(Nr2(vr2([E3, "?>"])));
          }
          return vr2(c3);
        }
        return vr2(l3);
      }
      function Uo2(t3, e3, i3, n3) {
        return vr2(t3.map(function(t4) {
          var n4 = [];
          return n4.push(i3(t4)), Wr2(t4) || (n4.push(Ir2), ko2(e3.originalText, t4.getValue(), e3) && n4.push(Ir2)), vr2(n4);
        }, n3));
      }
      function Bo2(t3, e3, i3) {
        var n3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "extends", s3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : " ", r3 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : " ", o3 = t3.getValue(), a3 = Kr2(o3[n3]) ? vr2([Ir2, t3.call(function(t4) {
          return dr2.printDanglingComments(t4, e3, true);
        }, n3), Ir2]) : s3, h3 = Array.isArray(o3[n3]) ? Cr2(vr2([Ar2(",", t3.map(function(t4) {
          var n4 = i3(t4);
          return Kr2(t4.getValue()) ? vr2([Ir2, dr2.printDanglingComments(t4, e3, true), Ir2, n4]) : vr2([r3, n4]);
        }, n3))])) : vr2([r3, t3.call(i3, n3)]);
        return br2(vr2([a3, n3, Ur2(a3) ? br2(h3) : h3]));
      }
      function Mo2(t3, e3, i3) {
        var n3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, s3 = n3.inline, r3 = s3 !== void 0 && s3, o3 = [];
        return t3.getValue().attrGroups ? (t3.each(function(t4) {
          var n4 = ["#["];
          o3.length > 0 && o3.push(r3 ? " " : Ir2), n4.push(Or2(Rr2)), t4.each(function(t5) {
            var s4 = t5.getValue();
            n4.length > 2 && n4.push(",", Or2(Rr2, " "));
            var r4 = [s4.name];
            s4.args.length > 0 && r4.push(bo2(t5, e3, i3, "args")), n4.push(Cr2(vr2(r4)));
          }, "attrs"), o3.push(Cr2(vr2([br2(vr2(n4)), Or2(Rr2), "]", Rr2, r3 ? " " : ""])));
        }, "attrGroups"), o3.length === 0 ? [] : [vr2([].concat(o3, [r3 ? "" : Ir2]))]) : [];
      }
      function Fo2(t3, e3, i3) {
        var n3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "body", s3 = t3.getValue();
        if (!s3[n3])
          return ";";
        var r3 = t3.call(i3, n3);
        return vr2([s3.shortForm ? ":" : " {", br2(vr2([s3[n3].kind !== "block" || s3[n3].children && s3[n3].children.length > 0 || s3[n3].comments && s3[n3].comments.length > 0 ? vr2([eo2(t3) ? s3.kind === "switch" ? " " : "" : Ir2, r3]) : ""])), s3.kind === "if" && n3 === "body" ? "" : vr2([io2(t3) ? Ir2 : "", s3.shortForm ? vr2(["end", s3.kind, ";"]) : "}"])]);
      }
      function Ho2(t3, e3, i3, n3, s3, r3, o3) {
        if (!n3)
          return e3;
        var a3 = Go2(t3, n3, s3, r3, o3);
        return Cr2(vr2([e3, i3, a3]));
      }
      function Go2(t3, e3, i3, n3, s3) {
        var r3 = n3 ? "&" : "";
        if (dr2.hasLeadingOwnLineComment(s3.originalText, e3, s3))
          return br2(vr2([Ir2, r3, i3]));
        var o3 = e3.kind === "cast" ? e3.expr : e3;
        return o3.kind === "bin" && !Oo2(o3) || o3.kind === "retif" && (!o3.trueExpr && !Lo2(o3.falseExpr) || o3.test.kind === "bin" && !Oo2(o3.test)) || (t3.kind === "variable" || t3.kind === "string" || Zr2(t3)) && (o3.kind === "string" && !Vo2(o3) || function t4(e4) {
          return !!Zr2(e4) && (!(e4.what.kind !== "variable" && !_o2(e4.what)) || t4(e4.what));
        }(o3)) ? Cr2(br2(vr2([gr2, r3, i3]))) : vr2([" ", r3, i3]);
      }
      function Vo2(t3) {
        return t3.raw.includes("\n");
      }
      function Wo2(t3, e3, i3) {
        return (t3.kind === "string" || t3.kind === "encapsed" && (t3.type === "string" || t3.type === "shell")) && Vo2(t3) && !Fr2(e3, i3.locStart(t3), { backwards: true });
      }
      var Qo2 = function(t3, e3, i3) {
        var n3 = t3.getValue();
        if (!n3)
          return "";
        if (typeof n3 == "string")
          return n3;
        var s3 = function(t4, e4, i4) {
          var n4 = t4.getValue();
          switch (n4.kind) {
            case "program":
              return Cr2(vr2([Po2(t4, e4, i4), dr2.printDanglingComments(t4, e4, true, function(t5) {
                return !t5.printed;
              })]));
            case "expressionstatement":
              return t4.call(i4, "expression");
            case "block":
              return vr2([Po2(t4, e4, i4), dr2.printDanglingComments(t4, e4, true)]);
            case "declare":
              var s4 = function(t5) {
                return Ar2(", ", t5.map(function(t6) {
                  return vr2([i4(t6)]);
                }, "directives"));
              };
              if (["block", "short"].includes(n4.mode))
                return vr2(["declare(", s4(t4), ")", n4.mode === "block" ? " {" : ":", n4.children.length > 0 ? br2(vr2([Ir2, Po2(t4, e4, i4)])) : "", dr2.printDanglingComments(t4, e4), Ir2, n4.mode === "block" ? "}" : "enddeclare;"]);
              var r4 = po2(t4, n4);
              return vr2(["declare(", s4(t4), ")", r4 && r4.kind === "inline" ? "" : ";"]);
            case "declaredirective":
              return vr2([t4.call(i4, "key"), "=", t4.call(i4, "value")]);
            case "namespace":
              return vr2(["namespace ", n4.name && typeof n4.name == "string" ? vr2([n4.name, n4.withBrackets ? " " : ""]) : "", n4.withBrackets ? "{" : ";", Kr2(n4) ? vr2([" ", dr2.printDanglingComments(t4, e4, true)]) : "", n4.children.length > 0 ? n4.withBrackets ? br2(vr2([Ir2, Po2(t4, e4, i4)])) : vr2([n4.children[0].kind === "inline" ? "" : vr2([Ir2, ho2(e4.originalText, n4, e4.locStart) ? Ir2 : ""]), Po2(t4, e4, i4)]) : "", n4.withBrackets ? vr2([Ir2, "}"]) : ""]);
            case "usegroup":
              return Cr2(vr2(["use ", n4.type ? vr2([n4.type, " "]) : "", br2(vr2([n4.name ? vr2([$r2(n4.name), "\\{", Rr2]) : "", Ar2(vr2([",", gr2]), t4.map(function(t5) {
                return vr2([i4(t5)]);
              }, "items"))])), n4.name ? vr2([Or2(Eo2(e4, "7.2") ? "," : ""), Rr2, "}"]) : ""]));
            case "useitem":
              return vr2([n4.type ? vr2([n4.type, " "]) : "", $r2(n4.name), Kr2(n4) ? vr2([" ", dr2.printDanglingComments(t4, e4, true)]) : "", n4.alias ? vr2([" as ", t4.call(i4, "alias")]) : ""]);
            case "class":
            case "interface":
            case "trait":
              return function(t5, e5, i5) {
                var n5 = t5.getValue(), s5 = n5.kind === "class" && n5.isAnonymous, r5 = Mo2(t5, e5, i5, { inline: s5 }), o5 = s5 ? [] : g2(r5);
                n5.isFinal && o5.push("final ");
                n5.isAbstract && o5.push("abstract ");
                o5.push(s5 ? "" : n5.kind), n5.name && o5.push(" ", t5.call(i5, "name"));
                n5.extends && n5.implements ? o5.push(Sr2([vr2([Bo2(t5, e5, i5, "extends"), Bo2(t5, e5, i5, "implements")]), vr2([Bo2(t5, e5, i5, "extends"), Bo2(t5, e5, i5, "implements", " ", Ir2)]), vr2([Bo2(t5, e5, i5, "extends", Ir2, " "), Bo2(t5, e5, i5, "implements", Ir2, n5.implements.length > 1 ? Ir2 : " ")])], { shouldBreak: Kr2(n5.extends) })) : (n5.extends && o5.push(Sr2([Bo2(t5, e5, i5, "extends"), Bo2(t5, e5, i5, "extends", " ", Ir2), Bo2(t5, e5, i5, "extends", Ir2, n5.extends.length > 1 ? Ir2 : " ")])), n5.implements && o5.push(Sr2([Bo2(t5, e5, i5, "implements"), Bo2(t5, e5, i5, "implements", " ", Ir2), Bo2(t5, e5, i5, "implements", Ir2, n5.implements.length > 1 ? Ir2 : " ")])));
                var a4 = Cr2(vr2([Cr2(vr2(o5)), xo2(e5) ? s5 ? gr2 : Ir2 : " "])), h4 = n5.body && n5.body.length === 0 && !Kr2(n5), l4 = vr2(["{", br2(vr2([h4 ? "" : Ir2, Uo2(t5, e5, i5, "body")])), dr2.printDanglingComments(t5, e5, true), s5 && h4 ? Rr2 : Ir2, "}"]);
                return vr2([a4, l4]);
              }(t4, e4, i4);
            case "traitprecedence":
              return vr2([t4.call(i4, "trait"), "::", t4.call(i4, "method"), " insteadof ", Ar2(", ", t4.map(i4, "instead"))]);
            case "traitalias":
              return vr2([n4.trait ? vr2([t4.call(i4, "trait"), "::"]) : "", n4.method ? t4.call(i4, "method") : "", " as ", Ar2(" ", [].concat(g2(n4.visibility ? [n4.visibility] : []), g2(n4.as ? [t4.call(i4, "as")] : [])))]);
            case "traituse":
              return Cr2(vr2(["use ", br2(Cr2(Ar2(vr2([",", gr2]), t4.map(i4, "traits")))), n4.adaptations ? vr2([" {", n4.adaptations.length > 0 ? vr2([br2(vr2([Ir2, Uo2(t4, e4, i4, "adaptations")])), Ir2]) : Kr2(n4) ? vr2([gr2, dr2.printDanglingComments(t4, e4, true), gr2]) : "", "}"]) : ""]));
            case "function":
            case "closure":
            case "method":
              return function(t5, e5, i5) {
                var n5 = t5.getValue(), s5 = g2(Mo2(t5, e5, i5, { inline: n5.kind === "closure" }));
                n5.isFinal && s5.push("final ");
                n5.isAbstract && s5.push("abstract ");
                n5.visibility && s5.push(n5.visibility, " ");
                n5.isStatic && s5.push("static ");
                s5.push("function "), n5.byref && s5.push("&");
                n5.name && s5.push(t5.call(i5, "name"));
                s5.push(bo2(t5, e5, i5)), n5.uses && n5.uses.length > 0 && s5.push(Cr2(vr2([" use ", bo2(t5, e5, i5, "uses")])));
                n5.type && s5.push(vr2([": ", Kr2(n5.type) ? vr2([t5.call(function(t6) {
                  return dr2.printDanglingComments(t6, e5, true);
                }, "type"), " "]) : "", n5.nullable ? "?" : "", t5.call(i5, "type")]));
                var r5 = vr2(s5);
                if (!n5.body)
                  return r5;
                var o5 = n5.kind === "closure", a4 = vr2(["{", br2(vr2([ao2(t5) ? "" : Ir2, t5.call(i5, "body")])), o5 && ao2(t5) ? "" : Ir2, "}"]);
                if (o5)
                  return vr2([r5, " ", a4]);
                if (n5.arguments.length === 0)
                  return vr2([r5, xo2(e5) ? Ir2 : " ", a4]);
                if (s5.some(Ur2))
                  return vr2([r5, " ", a4]);
                return Sr2([vr2([r5, xo2(e5) ? Ir2 : " ", a4]), vr2([r5, " ", a4])]);
              }(t4, e4, i4);
            case "arrowfunc":
              return vr2([].concat(g2(Mo2(t4, e4, i4, { inline: true })), [n4.isStatic ? "static " : "", "fn", bo2(t4, e4, i4), n4.type ? vr2([": ", n4.nullable ? "?" : "", t4.call(i4, "type")]) : "", " => ", t4.call(i4, "body")]));
            case "parameter":
              var o4 = "";
              n4.flags === 1 ? o4 = "public " : n4.flags === 2 ? o4 = "protected " : n4.flags === 4 && (o4 = "private ");
              var a3 = vr2([].concat(g2(Mo2(t4, e4, i4, { inline: true })), [o4, n4.nullable ? "?" : "", n4.type ? vr2([t4.call(i4, "type"), " "]) : "", n4.byref ? "&" : "", n4.variadic ? "..." : "", "$", t4.call(i4, "name")]));
              return n4.value ? Cr2(vr2([a3, Kr2(n4) ? " " : "", dr2.printDanglingComments(t4, e4, true), vr2([" =", Go2(n4.name, n4.value, t4.call(i4, "value"), false, e4)])])) : a3;
            case "variadic":
              return vr2(["...", t4.call(i4, "what")]);
            case "property":
              return Cr2(vr2([n4.type ? vr2([n4.nullable ? "?" : "", t4.call(i4, "type"), " "]) : "", "$", t4.call(i4, "name"), n4.value ? vr2([" =", Go2(n4.name, n4.value, t4.call(i4, "value"), false, e4)]) : ""]));
            case "propertystatement":
              var h3 = [];
              t4.map(function(t5) {
                return h3.push.apply(h3, g2(Mo2(t5, e4, i4)));
              }, "properties");
              var l3, c3 = t4.map(function(t5) {
                return i4(t5);
              }, "properties"), u3 = n4.properties.some(function(t5) {
                return t5.value;
              });
              if (c3.length !== 1 || n4.properties[0].comments)
                c3.length > 0 && (l3 = br2(c3[0]));
              else
                l3 = A2(c3, 1)[0];
              var _3 = n4.visibility || n4.visibility === null;
              return Cr2(vr2([].concat(h3, [_3 ? vr2([n4.visibility === null ? "var" : n4.visibility, ""]) : "", n4.isStatic ? vr2([_3 ? " " : "", "static"]) : "", l3 ? vr2([" ", l3]) : "", br2(vr2(c3.slice(1).map(function(t5) {
                return vr2([",", u3 ? Ir2 : gr2, t5]);
              })))])));
            case "if":
              var d3 = [], p3 = Fo2(t4, e4, i4, "body"), f3 = Cr2(vr2(["if (", Cr2(vr2([br2(vr2([Rr2, t4.call(i4, "test")])), Rr2])), ")", p3]));
              if (d3.push(f3, to2(t4) || !n4.body ? "" : Ir2), n4.alternate) {
                d3.push(n4.shortForm ? "" : "} ");
                var T3 = Jr2(n4.body) && n4.body.comments.some(function(t5) {
                  return t5.trailing && !dr2.isBlockComment(t5);
                }) || function(t5) {
                  if (!t5.comments)
                    return false;
                  var e5 = Gr2(t5.comments.filter(function(t6) {
                    return !t6.leading && !t6.trailing;
                  }));
                  return e5 && !dr2.isBlockComment(e5);
                }(n4), k3 = !T3;
                d3.push(k3 ? "" : Ir2), Kr2(n4) && d3.push(ko2(e4.originalText, n4.body, e4) ? Ir2 : "", dr2.printDanglingComments(t4, e4, true), T3 ? Ir2 : " "), d3.push("else", Cr2(n4.alternate.kind === "if" ? t4.call(i4, "alternate") : Fo2(t4, e4, i4, "alternate")));
              } else
                d3.push(n4.body ? n4.shortForm ? "endif;" : "}" : "");
              return vr2(d3);
            case "do":
              return vr2(["do", Fo2(t4, e4, i4, "body"), " while (", Cr2(vr2([br2(vr2([Rr2, t4.call(i4, "test")])), Rr2])), ")"]);
            case "while":
            case "switch":
              return Cr2(vr2([n4.kind, " (", Cr2(vr2([br2(vr2([Rr2, t4.call(i4, "test")])), Rr2])), ")", Fo2(t4, e4, i4, "body")]));
            case "for":
              var m3 = Fo2(t4, e4, i4, "body"), E3 = dr2.printDanglingComments(t4, e4, true), x3 = E3 ? vr2([E3, Rr2]) : "";
              return n4.init.length || n4.test.length || n4.increment.length ? vr2([x3, Cr2(vr2(["for (", Cr2(vr2([br2(vr2([Rr2, Cr2(vr2([Ar2(vr2([",", gr2]), t4.map(i4, "init"))])), ";", gr2, Cr2(vr2([Ar2(vr2([",", gr2]), t4.map(i4, "test"))])), ";", gr2, Cr2(Ar2(vr2([",", gr2]), t4.map(i4, "increment")))])), Rr2])), ")", m3]))]) : vr2([x3, Cr2(vr2(["for (;;)", m3]))]);
            case "foreach":
              var y3 = Fo2(t4, e4, i4, "body"), v3 = dr2.printDanglingComments(t4, e4, true), N3 = v3 ? vr2([v3, Rr2]) : "";
              return vr2([N3, Cr2(vr2(["foreach (", Cr2(vr2([br2(vr2([Rr2, t4.call(i4, "source"), gr2, "as ", Cr2(n4.key ? br2(Ar2(vr2([" =>", gr2]), [t4.call(i4, "key"), t4.call(i4, "value")])) : t4.call(i4, "value"))])), Rr2])), ")", y3]))]);
            case "try":
              var C3 = [];
              return C3.push("try", Fo2(t4, e4, i4, "body")), n4.catches && C3.push(vr2(t4.map(i4, "catches"))), n4.always && C3.push(" finally", Fo2(t4, e4, i4, "always")), vr2(C3);
            case "catch":
              return vr2([" catch", n4.what ? vr2([" (", Ar2(" | ", t4.map(i4, "what")), n4.variable ? vr2([" ", t4.call(i4, "variable")]) : "", ")"]) : "", Fo2(t4, e4, i4, "body")]);
            case "case":
              return vr2([n4.test ? vr2(["case ", n4.test.comments ? br2(t4.call(i4, "test")) : t4.call(i4, "test"), ":"]) : "default:", n4.body && n4.body.children && n4.body.children.length ? br2(vr2([to2(t4) ? "" : Ir2, t4.call(i4, "body")])) : ""]);
            case "break":
            case "continue":
              return n4.level && (n4.level.kind === "number" && n4.level.value !== "1") ? vr2(["".concat(n4.kind, " "), t4.call(i4, "level")]) : n4.kind;
            case "call":
              return n4.arguments.length === 1 && Wo2(n4.arguments[0], e4.originalText, e4) ? vr2([t4.call(i4, "what"), vr2(["(", Ar2(", ", t4.map(i4, "arguments")), ")"])]) : Zr2(n4.what) ? function(t5, e5, i5) {
                var n5 = [];
                function s5(t6) {
                  var i6 = e5.originalText, n6 = To2(i6, t6, e5);
                  return i6.charAt(n6) === ")" ? Mr2(i6, n6 + 1, e5) : ko2(i6, t6, e5);
                }
                function r5(t6) {
                  var o6 = t6.getValue();
                  if (o6.kind !== "call" || !Zr2(o6.what) && o6.what.kind !== "call")
                    if (Zr2(o6)) {
                      var a5 = null;
                      a5 = o6.kind === "propertylookup" ? yo2(t6, e5, i5) : o6.kind === "nullsafepropertylookup" ? vo2(t6, e5, i5) : o6.kind === "staticlookup" ? Ao2(t6, e5, i5) : go2(t6, e5, i5), n5.unshift({ node: o6, needsParens: Er2(t6), printed: dr2.printAllComments(t6, function() {
                        return a5;
                      }, e5) }), t6.call(function(t7) {
                        return r5(t7);
                      }, "what");
                    } else
                      n5.unshift({ node: o6, printed: t6.call(i5) });
                  else
                    n5.unshift({ node: o6, printed: vr2([dr2.printAllComments(t6, function() {
                      return vr2([bo2(t6, e5, i5)]);
                    }, e5), s5(o6) ? Ir2 : ""]) }), t6.call(function(t7) {
                      return r5(t7);
                    }, "what");
                }
                var o5 = t5.getValue();
                n5.unshift({ node: o5, printed: bo2(t5, e5, i5) }), t5.call(function(t6) {
                  return r5(t6);
                }, "what");
                for (var a4 = 0; a4 < n5.length; ++a4)
                  n5[a4].node.kind === "call" && n5[a4 - 1] && ["propertylookup", "staticlookup"].includes(n5[a4 - 1].node.kind) && n5[a4 - 1].needsParens && (n5[0].printed = vr2(["(", n5[0].printed]), n5[a4 - 1].printed = vr2([n5[a4 - 1].printed, ")"]));
                for (var h4 = [], l4 = [n5[0]], c4 = 1; c4 < n5.length && (n5[c4].node.kind === "call" || Zr2(n5[c4].node) && n5[c4].node.offset && n5[c4].node.offset.kind === "number"); ++c4)
                  l4.push(n5[c4]);
                if (n5[0].node.kind !== "call")
                  for (; c4 + 1 < n5.length && (Zr2(n5[c4].node) && Zr2(n5[c4 + 1].node)); ++c4)
                    l4.push(n5[c4]);
                h4.push(l4), l4 = [];
                for (var u4 = false; c4 < n5.length; ++c4) {
                  if (u4 && Zr2(n5[c4].node)) {
                    if (n5[c4].node.kind === "offsetlookup" && n5[c4].node.offset && n5[c4].node.offset.kind === "number") {
                      l4.push(n5[c4]);
                      continue;
                    }
                    h4.push(l4), l4 = [], u4 = false;
                  }
                  n5[c4].node.kind === "call" && (u4 = true), l4.push(n5[c4]), n5[c4].node.comments && dr2.hasTrailingComment(n5[c4].node) && (h4.push(l4), l4 = [], u4 = false);
                }
                l4.length > 0 && h4.push(l4);
                function _4(t6) {
                  var i6 = t6[1].length && t6[1][0].node.kind === "offsetlookup";
                  if (t6[0].length === 1) {
                    var n6 = t6[0][0].node;
                    return n6.kind === "variable" && (n6.name === "this" || d4 && s6(n6.name)) || _o2(n6);
                  }
                  function s6(t7) {
                    return t7.length < e5.tabWidth;
                  }
                  var r6 = Gr2(t6[0]).node;
                  return Zr2(r6) && (r6.offset.kind === "identifier" || r6.offset.kind === "variable") && i6;
                }
                var d4 = t5.getParentNode().kind === "expressionstatement", p4 = h4.length >= 2 && !h4[1][0].node.comments && _4(h4);
                function f4(t6) {
                  for (var e6 = [], i6 = 0; i6 < t6.length; i6++)
                    t6[i6 + 1] && t6[i6 + 1].needsParens ? (e6.push("(", t6[i6].printed, t6[i6 + 1].printed, ")"), i6++) : e6.push(t6[i6].printed);
                  return vr2(e6);
                }
                function T4(t6) {
                  return t6.length === 0 ? "" : br2(Cr2(vr2([Ir2, Ar2(Ir2, t6.map(f4))])));
                }
                var k4 = h4.map(f4), m4 = vr2(k4), E4 = p4 ? 3 : 2, x4 = h4.slice(0, E4).reduce(function(t6, e6) {
                  return t6.concat(e6);
                }, []), y4 = x4.slice(1, -1).some(function(t6) {
                  return dr2.hasLeadingComment(t6.node);
                }) || x4.slice(0, -1).some(function(t6) {
                  return dr2.hasTrailingComment(t6.node);
                }) || h4[E4] && dr2.hasLeadingComment(h4[E4][0].node), v5 = uo2(t5, "encapsed");
                if (h4.length <= E4 && !y4 || v5)
                  return Cr2(m4);
                var A3 = Gr2(p4 ? h4.slice(1, 2)[0] : h4[0]).node, g3 = A3.kind !== "call" && s5(A3), N4 = vr2([f4(h4[0]), p4 ? vr2(h4.slice(1, 2).map(f4)) : "", g3 ? Ir2 : "", T4(h4.slice(p4 ? 2 : 1))]), C4 = n5.filter(function(t6) {
                  return t6.node.kind === "call";
                }).length;
                if (y4 || C4 >= 3 || k4.slice(0, -1).some(Ur2))
                  return Cr2(N4);
                return vr2([Ur2(m4) || g3 ? yr2 : "", Sr2([m4, N4])]);
              }(t4, e4, i4) : vr2([t4.call(i4, "what"), bo2(t4, e4, i4)]);
            case "new":
              var S3 = n4.what && n4.what.kind === "class" && n4.what.isAnonymous;
              if (!S3 && n4.arguments.length === 1 && Wo2(n4.arguments[0], e4.originalText, e4))
                return vr2(["new "].concat(g2(t4.call(Mo2, "what")), [t4.call(i4, "what"), "(", Ar2(", ", t4.map(i4, "arguments")), ")"]));
              var b3 = [];
              if (b3.push("new "), S3)
                b3.push.apply(b3, [n4.what.leadingComments && n4.what.leadingComments[0].kind === "commentblock" ? vr2([dr2.printComments(n4.what.leadingComments, e4), " "]) : ""].concat(g2(t4.call(function(t5, e5, i5) {
                  return Mo2(t5, e5, i5, { inline: true });
                }, "what")), ["class", n4.arguments.length > 0 ? vr2([" ", bo2(t4, e4, i4)]) : "", Cr2(t4.call(i4, "what"))]));
              else {
                var L3 = vr2([t4.call(i4, "what"), bo2(t4, e4, i4)]);
                b3.push(Xr2(n4.what) ? br2(L3) : L3);
              }
              return vr2(b3);
            case "clone":
              return vr2(["clone ", n4.what.comments ? br2(t4.call(i4, "what")) : t4.call(i4, "what")]);
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
              var O3, I3 = t4.getParentNode(), R3 = 0;
              do {
                O3 = t4.getParentNode(R3), R3++;
              } while (O3 && Zr2(O3));
              var w3 = uo2(t4, "encapsed") || O3 && (O3.kind === "new" || O3.kind === "assign" && O3.left.kind !== "variable") || n4.kind === "offsetlookup" || (_o2(n4.what) || n4.what.kind === "variable") && ["identifier", "variable", "encapsedpart"].includes(n4.offset.kind) && I3 && !Zr2(I3);
              return vr2([t4.call(i4, "what"), w3 ? Io2(t4, e4, i4) : Cr2(br2(vr2([Rr2, Io2(t4, e4, i4)])))]);
            case "exit":
              return Cr2(vr2([n4.useDie ? "die" : "exit", "(", n4.expression ? Wo2(n4.expression, e4.originalText, e4) ? t4.call(i4, "expression") : vr2([br2(vr2([Rr2, t4.call(i4, "expression")])), Rr2]) : dr2.printDanglingComments(t4, e4), ")"]));
            case "global":
              return Cr2(vr2(["global ", br2(vr2([Ar2(vr2([",", gr2]), t4.map(i4, "items"))]))]));
            case "include":
              return vr2([n4.require ? "require" : "include", n4.once ? "_once" : "", " ", n4.target.comments ? br2(t4.call(i4, "target")) : t4.call(i4, "target")]);
            case "label":
              return vr2([t4.call(i4, "name"), ":"]);
            case "goto":
              return vr2(["goto ", t4.call(i4, "label")]);
            case "throw":
              return vr2(["throw ", n4.what.comments ? br2(t4.call(i4, "what")) : t4.call(i4, "what")]);
            case "silent":
              return vr2(["@", t4.call(i4, "expr")]);
            case "halt":
              return vr2([Kr2(n4) ? vr2([dr2.printDanglingComments(t4, e4, true), Ir2]) : "", "__halt_compiler();", n4.after]);
            case "eval":
              return Cr2(vr2(["eval(", Wo2(n4.source, e4.originalText, e4) ? t4.call(i4, "source") : vr2([br2(vr2([Rr2, t4.call(i4, "source")])), Rr2]), ")"]));
            case "echo":
              var D3, P3 = t4.map(function(t5) {
                return i4(t5);
              }, "expressions");
              if (P3.length !== 1 || n4.expressions[0].comments)
                P3.length > 0 && (D3 = co2(n4.expressions[0]) || n4.expressions[0].comments ? br2(P3[0]) : Lr2(P3[0]));
              else
                D3 = A2(P3, 1)[0];
              return Cr2(vr2([n4.shortForm ? "" : "echo ", D3 || "", br2(vr2(P3.slice(1).map(function(t5) {
                return vr2([",", gr2, t5]);
              })))]));
            case "print":
              return vr2(["print ", n4.expression.comments ? br2(t4.call(i4, "expression")) : t4.call(i4, "expression")]);
            case "return":
              var U3 = [];
              if (U3.push("return"), n4.expr) {
                var B3 = t4.call(i4, "expr");
                U3.push(" ", n4.expr.comments ? br2(B3) : B3);
              }
              return Kr2(n4) && U3.push(" ", dr2.printDanglingComments(t4, e4, true)), vr2(U3);
            case "isset":
            case "unset":
              return Cr2(vr2([n4.kind, bo2(t4, e4, i4, "variables")]));
            case "empty":
              return Cr2(vr2(["empty(", br2(vr2([Rr2, t4.call(i4, "expression")])), Rr2, ")"]));
            case "variable":
              var M3 = t4.getParentNode(), F3 = t4.getParentNode(1), H3 = M3.kind === "assign" ? "" : n4.byref ? "&" : "", G3 = M3.kind === "encapsedpart" && M3.syntax === "simple" && M3.curly || F3 && M3.kind === "offsetlookup" && F3.kind === "encapsedpart" && F3.syntax === "simple" && F3.curly ? "" : "$", V3 = n4.curly ? "{" : "", W3 = n4.curly ? "}" : "";
              return vr2([H3, G3, V3, t4.call(i4, "name"), W3]);
            case "constantstatement":
            case "classconstant":
              var Q3, Y3 = Mo2(t4, e4, i4), j3 = t4.map(function(t5) {
                return i4(t5);
              }, "constants");
              if (j3.length !== 1 || n4.constants[0].comments)
                j3.length > 0 && (Q3 = br2(j3[0]));
              else
                Q3 = A2(j3, 1)[0];
              return Cr2(vr2([].concat(g2(Y3), [n4.visibility ? vr2([n4.visibility, " "]) : "", "const", Q3 ? vr2([" ", Q3]) : "", br2(vr2(j3.slice(1).map(function(t5) {
                return vr2([",", Ir2, t5]);
              })))])));
            case "constant":
              return Ho2(n4.name, t4.call(i4, "name"), " =", n4.value, t4.call(i4, "value"), false, e4);
            case "static":
              var $3, z3 = t4.map(function(t5) {
                return i4(t5);
              }, "variables"), K3 = n4.variables.some(function(t5) {
                return t5.defaultValue;
              });
              if (z3.length !== 1 || n4.variables[0].comments)
                z3.length > 0 && ($3 = br2(z3[0]));
              else
                $3 = A2(z3, 1)[0];
              return Cr2(vr2(["static", $3 ? vr2([" ", $3]) : "", br2(vr2(z3.slice(1).map(function(t5) {
                return vr2([",", K3 ? Ir2 : gr2, t5]);
              })))]));
            case "staticvariable":
              return Ho2(n4.variable, t4.call(i4, "variable"), " =", n4.defaultValue, t4.call(i4, "defaultValue"), false, e4);
            case "list":
            case "array":
              var X3 = n4.kind === "array" && mo2(e4.phpVersion, "5.4") || n4.kind === "list" && (n4.shortForm || mo2(e4.phpVersion, "7.1")), J3 = X3 ? "[" : vr2([n4.kind, "("]), q3 = X3 ? "]" : ")";
              if (n4.items.length === 0)
                return Kr2(n4) ? Cr2(vr2([J3, dr2.printDanglingComments(t4, e4), Rr2, q3])) : vr2([J3, q3]);
              var Z3 = Gr2(n4.items), tt3 = Z3 && Z3.kind === "noop", et3 = A2(n4.items.filter(function(t5) {
                return t5.kind !== "noop";
              }).sort(function(t5, i5) {
                return e4.locStart(t5) - e4.locStart(i5);
              }), 1)[0], it3 = !(!et3 || !et3.key) && et3 && Hr2(e4.originalText, e4.locStart(n4), e4.locStart(et3));
              return Cr2(vr2([J3, br2(vr2([Rr2, wo2(t4, e4, i4)])), tt3 ? "," : "", Or2(!tt3 && Eo2(e4, "5.0") ? vr2([Z3 && lo2(Z3) ? Ir2 : "", ","]) : ""), dr2.printDanglingComments(t4, e4, true), Rr2, q3]), { shouldBreak: it3 });
            case "entry":
              var nt3 = n4.byRef ? "&" : "", st3 = n4.unpack ? "..." : "";
              return n4.key ? Ho2(n4.key, t4.call(i4, "key"), " =>", n4.value, t4.call(i4, "value"), nt3, e4) : vr2([nt3, st3, t4.call(i4, "value")]);
            case "yield":
              var rt3 = vr2([n4.key ? vr2([t4.call(i4, "key"), " => "]) : "", t4.call(i4, "value")]);
              return vr2(["yield", n4.key || n4.value ? " " : "", n4.value && n4.value.comments ? br2(rt3) : rt3]);
            case "yieldfrom":
              return vr2(["yield from ", n4.value.comments ? br2(t4.call(i4, "value")) : t4.call(i4, "value")]);
            case "unary":
              return vr2([n4.type, t4.call(i4, "what")]);
            case "pre":
              return vr2([n4.type + n4.type, t4.call(i4, "what")]);
            case "post":
              return vr2([t4.call(i4, "what"), n4.type + n4.type]);
            case "cast":
              return vr2(["(", n4.type, ") ", n4.expr.comments ? br2(t4.call(i4, "expr")) : t4.call(i4, "expr")]);
            case "assignref":
            case "assign":
              var ot3 = n4.kind === "assignref";
              return Ho2(n4.left, t4.call(i4, "left"), vr2([" ", ot3 ? "=" : n4.operator]), n4.right, t4.call(i4, "right"), ot3, e4);
            case "bin":
              var at3 = t4.getParentNode(), ht3 = t4.getParentNode(1), lt3 = n4 !== at3.body && (at3.kind === "if" || at3.kind === "while" || at3.kind === "switch" || at3.kind === "do"), ct3 = function t5(e5, i5, n5, s5, r5) {
                var o5 = [], a4 = e5.getValue();
                if (a4.kind === "bin") {
                  jr2(a4.type, a4.left.type) ? o5 = o5.concat(e5.call(function(e6) {
                    return t5(e6, i5, n5, true, r5);
                  }, "left")) : o5.push(e5.call(i5, "left"));
                  var h4 = Oo2(a4), l4 = vr2(h4 ? [a4.type, " ", e5.call(i5, "right")] : [a4.type, gr2, e5.call(i5, "right")]), c4 = e5.getParentNode(), u4 = !(r5 && ["||", "&&"].includes(a4.type)) && ro2(c4) !== ro2(a4) && ro2(a4.left) !== ro2(a4) && ro2(a4.right) !== ro2(a4), _4 = co2(a4.left) || a4.left.kind === "bin" && co2(a4.left.right);
                  o5.push(_4 ? "" : " ", u4 ? Cr2(l4) : l4), s5 && a4.comments && (o5 = dr2.printAllComments(e5, function() {
                    return vr2(o5);
                  }, n5));
                } else
                  o5.push(e5.call(i5));
                return o5;
              }(t4, i4, e4, false, lt3);
              if (lt3)
                return vr2(ct3);
              if (at3.kind === "unary" || Zr2(at3) && at3.kind !== "offsetlookup")
                return Cr2(vr2([br2(vr2([Rr2, vr2(ct3)])), Rr2]));
              var ut3 = n4 !== at3.body && at3.kind === "for" || at3.kind === "retif" && ht3 && ht3.kind !== "return", _t3 = ["assign", "property", "constant", "staticvariable", "entry"].includes(at3.kind), dt3 = n4.left.kind === "bin" && jr2(n4.type, n4.left.type);
              if (ut3 || Oo2(n4) && !dt3 || !Oo2(n4) && _t3)
                return Cr2(vr2(ct3));
              var pt3 = vr2(ct3.slice(1));
              return Cr2(vr2([ct3.length > 0 ? ct3[0] : "", br2(pt3)]));
            case "retif":
              var ft3, Tt3 = [], kt3 = t4.getParentNode(), mt3 = 0;
              do {
                ft3 = t4.getParentNode(mt3), mt3++;
              } while (ft3 && ft3.kind === "retif");
              var Et3 = ft3 || kt3, xt3 = n4.falseExpr.kind === "bin" ? br2(t4.call(i4, "falseExpr")) : t4.call(i4, "falseExpr"), yt3 = vr2([n4.trueExpr ? gr2 : " ", "?", n4.trueExpr ? vr2([" ", n4.trueExpr.kind === "bin" ? br2(t4.call(i4, "trueExpr")) : t4.call(i4, "trueExpr"), gr2]) : "", ":", n4.trueExpr ? vr2([" ", xt3]) : vr2([Lo2(n4.falseExpr) ? " " : gr2, xt3])]);
              Tt3.push(yt3);
              var vt3 = function(t5) {
                return kt3 === Et3 ? Cr2(t5) : t5;
              }, At3 = t4.getParentNode(1), gt3 = kt3.kind === "cast" && At3 ? At3 : kt3, Nt3 = ["propertylookup", "staticlookup"].includes(gt3.kind), Ct3 = t4.call(i4, "test");
              if (!n4.trueExpr) {
                var St3 = vr2([Ct3, gt3.kind === "bin" || ["print", "echo", "return", "include"].includes(Et3.kind) ? br2(vr2(Tt3)) : vr2(Tt3)]);
                return gt3.kind === "call" && gt3.what === n4 || gt3.kind === "unary" || Zr2(gt3) && gt3.kind !== "offsetlookup" ? Cr2(vr2([br2(vr2([Rr2, St3])), Rr2])) : vt3(St3);
              }
              return vt3(vr2([n4.test.kind === "retif" ? br2(Ct3) : Ct3, br2(vr2(Tt3)), Nt3 ? Rr2 : ""]));
            case "boolean":
              return n4.value ? "true" : "false";
            case "number":
              return Yr2(n4.value);
            case "string":
              if (t4.getParentNode().kind === "encapsedpart") {
                var bt3 = t4.getParentNode(1), Lt3 = 0, Ot3 = mo2(e4.phpVersion, "7.3"), It3 = wr2;
                if (bt3.type === "heredoc") {
                  It3 = Ot3 ? Ir2 : wr2;
                  var Rt3 = bt3.raw.split(/\r?\n/g);
                  (Lt3 = Rt3[Rt3.length - 1].search(/\S/)) === -1 && (Lt3 = Rt3[Rt3.length - 2].search(/\S/));
                }
                return Ar2(It3, n4.raw.split(/\r?\n/g).map(function(t5, e5) {
                  return e5 > 0 || n4.loc.start.column === 0 ? t5.substring(Lt3) : t5;
                }));
              }
              var wt3 = oo2(n4, e4) ? '"' : "'", Dt3 = n4.raw;
              return n4.raw[0] === "b" && (Dt3 = Dt3.slice(1)), ['"', "'"].includes(Dt3[0]) && (Dt3 = Dt3.substr(1)), ['"', "'"].includes(Dt3[Dt3.length - 1]) && (Dt3 = Dt3.substr(0, Dt3.length - 1)), vr2([n4.raw[0] === "b" ? "b" : "", wt3, Ar2(wr2, Dt3.split(/\r?\n/g)), wt3]);
            case "uniontype":
              return Cr2(vr2(t4.map(function(e5, n5) {
                return vr2(n5 === 0 ? [t4.call(i4)] : ["|", t4.call(i4)]);
              }, "types")));
            case "encapsedpart":
              var Pt3 = n4.syntax === "simple" && n4.curly || n4.syntax === "complex" ? vr2([n4.curly ? "$" : "", "{"]) : "", Ut3 = n4.syntax === "simple" && n4.curly || n4.syntax === "complex" ? "}" : "";
              return vr2([Pt3, t4.call(i4, "expression"), Ut3]);
            case "encapsed":
              switch (n4.type) {
                case "string":
                case "shell":
                case "heredoc":
                  var Bt3 = mo2(e4.phpVersion, "7.3") ? Ir2 : wr2;
                  return vr2([Ro2(n4), n4.type === "heredoc" ? Bt3 : "", vr2(t4.map(i4, "value")), Ro2(n4, { opening: false }), n4.type === "heredoc" && qr2(t4) ? Ir2 : ""]);
                default:
                  return "Have not implemented kind ".concat(n4.type, " yet.");
              }
            case "inline":
              return Ar2(wr2, n4.raw.replace("___PSEUDO_INLINE_PLACEHOLDER___", "").split(/\r?\n/g));
            case "magic":
              return n4.value;
            case "nowdoc":
              var Mt3 = mo2(e4.phpVersion, "7.3") ? Ir2 : wr2;
              return vr2(["<<<'", n4.label, "'", Mt3, Ar2(Mt3, n4.value.split(/\r?\n/g)), Mt3, n4.label, qr2(t4) ? Ir2 : ""]);
            case "name":
              return vr2([n4.resolution === "rn" ? "namespace\\" : "", n4.name]);
            case "literal":
              return t4.call(i4, "value");
            case "parentreference":
              return "parent";
            case "selfreference":
              return "self";
            case "staticreference":
              return "static";
            case "typereference":
              return n4.name;
            case "nullkeyword":
              return "null";
            case "identifier":
              return t4.getParentNode().kind === "method" && (n4.name = fo2(n4.name)), t4.call(i4, "name");
            case "match":
              var Ft3 = t4.map(function(t5, e5) {
                var n5 = t5.getValue().conds === null ? "default" : vr2(t5.map(function(t6, e6) {
                  return Cr2(vr2(e6 > 0 ? [",", gr2, i4(t6)] : [i4(t6)]));
                }, "conds")), s5 = t5.call(i4, "body");
                return vr2(e5 > 0 ? [", ", gr2, n5, " => ", s5] : [gr2, n5, " => ", s5]);
              }, "arms");
              return Cr2(vr2(["match (", Cr2(vr2([Rr2, br2(vr2([t4.call(i4, "cond")])), Rr2])), ") {", br2(vr2(Ft3)), " ", Rr2, "}"]));
            case "noop":
              return n4.comments ? dr2.printComments(t4.getValue().comments, e4) : "";
            case "namedargument":
              return vr2([n4.name, ": ", t4.call(i4, "value")]);
            case "error":
            default:
              return "Have not implemented kind ".concat(n4.kind, " yet.");
          }
        }(t3, e3, i3), r3 = [], o3 = Er2(t3);
        return o3 && r3.unshift("("), r3.push(s3), o3 && r3.push(")"), Qr2(t3) && r3.push(";"), zr2(t3) && r3.push(Ir2), vr2(r3);
      };
      var Yo2 = function(t3, e3) {
        if (["loc", "range", "raw", "comments", "leadingComments", "trailingComments", "parenthesizedExpression", "parent", "prev", "start", "end", "tokens", "errors", "extra"].forEach(function(t4) {
          delete e3[t4];
        }), t3.kind === "string" && delete e3.isDoubleQuote, ["array", "list"].includes(t3.kind) && delete e3.shortForm, t3.kind === "inline") {
          if (t3.value.includes("___PSEUDO_INLINE_PLACEHOLDER___"))
            return null;
          e3.value = e3.value.replace(/\r\n?|\n/g, "");
        }
        if ((t3.kind === "continue" || t3.kind === "break") && t3.level) {
          var i3 = e3.level;
          i3.kind === "number" && (e3.level = i3.value === "1" ? null : i3);
        }
        if (t3.kind === "block" && t3.children.length === 1 && t3.children[0].kind === "block")
          for (; e3.children[0].kind === "block"; )
            e3.children = e3.children[0].children;
        if (t3.kind === "number" && (e3.value = Rs2.printNumber(t3.value)), ["foreach", "for", "if", "while", "do"].includes(t3.kind) && (t3.body && t3.body.kind !== "block" ? e3.body = { kind: "block", children: [e3.body] } : e3.body = e3.body ? e3.body : null, t3.alternate && t3.alternate.kind !== "block" ? e3.alternate = { kind: "block", children: [e3.alternate] } : e3.alternate = e3.alternate ? e3.alternate : null), t3.kind === "usegroup" && typeof t3.name == "string" && (e3.name = e3.name.replace(/^\\/, "")), t3.kind === "useitem" && (e3.name = e3.name.replace(/^\\/, "")), t3.kind === "method" && t3.name.kind === "identifier" && (e3.name.name = Rs2.normalizeMagicMethodName(e3.name.name)), t3.kind === "noop")
          return null;
      }, jo2 = "PHP", $o2 = { phpVersion: { since: "0.13.0", category: jo2, type: "choice", default: "7.0", description: "Minimum target PHP version.", choices: [{ value: "5.0" }, { value: "5.1" }, { value: "5.2" }, { value: "5.3" }, { value: "5.4" }, { value: "5.5" }, { value: "5.6" }, { value: "7.0" }, { value: "7.1" }, { value: "7.2" }, { value: "7.3" }, { value: "7.4" }, { value: "8.0" }] }, trailingCommaPHP: { since: "0.0.0", category: jo2, type: "boolean", default: true, description: "Print trailing commas wherever possible when multi-line." }, braceStyle: { since: "0.10.0", category: jo2, type: "choice", default: "psr-2", description: "Print one space or newline for code blocks (classes and functions).", choices: [{ value: "psr-2", description: "Use PSR-2 brace style." }, { value: "1tbs", description: "Use 1tbs brace style." }] } }, zo2 = function(t3, e3, i3, n3) {
        if (i3 !== "length" && i3 !== "prototype" && i3 !== "arguments" && i3 !== "caller") {
          var s3 = Object.getOwnPropertyDescriptor(t3, i3), r3 = Object.getOwnPropertyDescriptor(e3, i3);
          !Ko2(s3, r3) && n3 || Object.defineProperty(t3, i3, r3);
        }
      }, Ko2 = function(t3, e3) {
        return t3 === void 0 || t3.configurable || t3.writable === e3.writable && t3.enumerable === e3.enumerable && t3.configurable === e3.configurable && (t3.writable || t3.value === e3.value);
      }, Xo2 = function(t3, e3) {
        var i3 = Object.getPrototypeOf(e3);
        i3 !== Object.getPrototypeOf(t3) && Object.setPrototypeOf(t3, i3);
      }, Jo2 = function(t3, e3) {
        return "/* Wrapped ".concat(t3, "*/\n").concat(e3);
      }, qo2 = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), Zo2 = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), ta2 = function(t3, e3, i3) {
        var n3 = i3 === "" ? "" : "with ".concat(i3.trim(), "() "), s3 = Jo2.bind(null, n3, e3.toString());
        Object.defineProperty(s3, "name", Zo2), Object.defineProperty(t3, "toString", v2(v2({}, qo2), {}, { value: s3 }));
      }, ea2 = function(t3, e3) {
        var i3, n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s3 = n3.ignoreNonConfigurable, r3 = s3 !== void 0 && s3, o3 = t3.name, a3 = S2(Reflect.ownKeys(e3));
        try {
          for (a3.s(); !(i3 = a3.n()).done; ) {
            var h3 = i3.value;
            zo2(t3, e3, h3, r3);
          }
        } catch (t4) {
          a3.e(t4);
        } finally {
          a3.f();
        }
        return Xo2(t3, e3), ta2(t3, e3, o3), t3;
      }, ia2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
      function na2(t3) {
        return t3 && t3.default || t3;
      }
      var sa2, ra2 = function() {
        var t3 = {};
        return t3.promise = new Promise(function(e3, i3) {
          t3.resolve = e3, t3.reject = i3;
        }), t3;
      }, oa2 = function(t3, e3) {
        return t3(e3 = { exports: {} }, e3.exports), e3.exports;
      }(function(t3, e3) {
        var i3 = ia2 && ia2.__awaiter || function(t4, e4, i4, n4) {
          return new (i4 || (i4 = Promise))(function(s4, r4) {
            function o3(t5) {
              try {
                h3(n4.next(t5));
              } catch (t6) {
                r4(t6);
              }
            }
            function a3(t5) {
              try {
                h3(n4.throw(t5));
              } catch (t6) {
                r4(t6);
              }
            }
            function h3(t5) {
              t5.done ? s4(t5.value) : new i4(function(e5) {
                e5(t5.value);
              }).then(o3, a3);
            }
            h3((n4 = n4.apply(t4, e4 || [])).next());
          });
        }, n3 = ia2 && ia2.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(e3, "__esModule", { value: true });
        var s3 = n3(ra2);
        function r3(t4) {
          var e4, n4, r4, o3 = this, a3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "maxAge", h3 = function() {
            return i3(o3, void 0, void 0, regeneratorRuntime.mark(function o4() {
              var h4, l4, c4, u3, _3 = this;
              return regeneratorRuntime.wrap(function(o5) {
                for (; ; )
                  switch (o5.prev = o5.next) {
                    case 0:
                      if (e4 === void 0) {
                        o5.next = 2;
                        break;
                      }
                      return o5.abrupt("return");
                    case 2:
                      h4 = function(o6) {
                        return i3(_3, void 0, void 0, regeneratorRuntime.mark(function i4() {
                          var h5;
                          return regeneratorRuntime.wrap(function(i5) {
                            for (; ; )
                              switch (i5.prev = i5.next) {
                                case 0:
                                  if (r4 = s3.default(), !((h5 = o6[1][a3] - Date.now()) <= 0)) {
                                    i5.next = 6;
                                    break;
                                  }
                                  return t4.delete(o6[0]), r4.resolve(), i5.abrupt("return");
                                case 6:
                                  return e4 = o6[0], typeof (n4 = setTimeout(function() {
                                    t4.delete(o6[0]), r4 && r4.resolve();
                                  }, h5)).unref == "function" && n4.unref(), i5.abrupt("return", r4.promise);
                                case 10:
                                case "end":
                                  return i5.stop();
                              }
                          }, i4);
                        }));
                      }, o5.prev = 3, l4 = S2(t4), o5.prev = 5, l4.s();
                    case 7:
                      if ((c4 = l4.n()).done) {
                        o5.next = 13;
                        break;
                      }
                      return u3 = c4.value, o5.next = 11, h4(u3);
                    case 11:
                      o5.next = 7;
                      break;
                    case 13:
                      o5.next = 18;
                      break;
                    case 15:
                      o5.prev = 15, o5.t0 = o5.catch(5), l4.e(o5.t0);
                    case 18:
                      return o5.prev = 18, l4.f(), o5.finish(18);
                    case 21:
                      o5.next = 25;
                      break;
                    case 23:
                      o5.prev = 23, o5.t1 = o5.catch(3);
                    case 25:
                      e4 = void 0;
                    case 26:
                    case "end":
                      return o5.stop();
                  }
              }, o4, null, [[3, 23], [5, 15, 18, 21]]);
            }));
          }, l3 = function() {
            e4 = void 0, n4 !== void 0 && (clearTimeout(n4), n4 = void 0), r4 !== void 0 && (r4.reject(void 0), r4 = void 0);
          }, c3 = t4.set.bind(t4);
          return t4.set = function(i4, n5) {
            t4.has(i4) && t4.delete(i4);
            var s4 = c3(i4, n5);
            return e4 && e4 === i4 && l3(), h3(), s4;
          }, h3(), t4;
        }
        e3.default = r3, t3.exports = r3, t3.exports.default = r3;
      });
      (sa2 = oa2) && sa2.__esModule && Object.prototype.hasOwnProperty.call(sa2, "default") && sa2.default;
      var aa2 = oa2, ha2 = new WeakMap(), la2 = new WeakMap(), ca2 = function(t3) {
        var e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i3 = e3.cacheKey, n3 = e3.cache, s3 = n3 === void 0 ? new Map() : n3, r3 = e3.maxAge;
        typeof r3 == "number" && aa2(s3);
        var o3 = function() {
          for (var e4 = arguments.length, n4 = new Array(e4), o4 = 0; o4 < e4; o4++)
            n4[o4] = arguments[o4];
          var a3 = i3 ? i3(n4) : n4[0], h3 = s3.get(a3);
          if (h3)
            return h3.data;
          var l3 = t3.apply(this, n4);
          return s3.set(a3, { data: l3, maxAge: r3 ? Date.now() + r3 : Number.POSITIVE_INFINITY }), l3;
        };
        return ea2(o3, t3, { ignoreNonConfigurable: true }), la2.set(o3, s3), o3;
      };
      ca2.decorator = function() {
        var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return function(e3, i3, n3) {
          var s3 = e3[i3];
          if (typeof s3 != "function")
            throw new TypeError("The decorated value must be a function");
          delete n3.value, delete n3.writable, n3.get = function() {
            if (!ha2.has(this)) {
              var e4 = ca2(s3, t3);
              return ha2.set(this, e4), e4;
            }
            return ha2.get(this);
          };
        };
      }, ca2.clear = function(t3) {
        var e3 = la2.get(t3);
        if (!e3)
          throw new TypeError("Can't clear a function that was not memoized!");
        if (typeof e3.clear != "function")
          throw new TypeError("The cache Map can't be cleared!");
        e3.clear();
      };
      var ua2 = /@prettier|@format/, _a2 = ca2(function(t3) {
        var e3 = cs2(t3), i3 = A2(e3.children, 1)[0], n3 = A2(e3.comments.filter(function(t4) {
          return t4.kind === "commentblock";
        }), 1)[0];
        if (i3 && n3 && n3.loc.start.line < i3.loc.start.line)
          return n3;
      });
      var da2 = function(t3) {
        if (!ua2.test(t3))
          return false;
        var e3 = _a2(t3);
        if (e3) {
          var i3 = e3.value;
          return ua2.test(i3);
        }
        return false;
      }, pa2 = function(t3) {
        var e3 = _a2(t3);
        if (e3) {
          var i3 = e3.loc, n3 = i3.start.offset, s3 = i3.end.offset, r3 = t3.substring(0, n3), o3 = t3.substring(s3);
          return "".concat(r3).concat(function(t4, e4) {
            var i4 = t4.split(/\r?\n/g);
            if (i4.length === 1) {
              var n4 = A2(/\/*\*\*(.*)\*\//.exec(i4[0]), 2)[1];
              i4 = ["/**", " * ".concat(n4.trim()), " */"];
            }
            var s4 = i4.findIndex(function(t5) {
              return /@\S/.test(t5);
            }) || 1;
            return i4.splice(s4, 0, " * @format"), i4.join(function(t5) {
              var e5 = t5.indexOf("\n");
              return e5 >= 0 && t5.charAt(e5 - 1) === "\r" ? "\r\n" : "\n";
            }(e4));
          }(e3.value, t3)).concat(o3);
        }
        var a3 = "<?php";
        if (!t3.startsWith(a3))
          return t3;
        var h3 = a3.length, l3 = t3.substring(0, h3), c3 = t3.substring(h3);
        return "".concat(l3, "\n/** \n * @format \n */\n").concat(c3);
      }, fa2 = "programming", Ta2 = "text.html.php", ka2 = "application/x-httpd-php", ma2 = "#4F5D95", Ea2 = [".php", ".aw", ".ctp", ".fcgi", ".inc", ".php3", ".php4", ".php5", ".phps", ".phpt"], xa2 = [".php", ".php_cs", ".php_cs.dist", "Phakefile"], ya2 = ["php"], va2 = ["inc"], Aa2 = { name: "PHP", type: fa2, tmScope: Ta2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: ka2, color: ma2, extensions: Ea2, filenames: xa2, interpreters: ya2, aliases: va2, languageId: 272 }, ga2 = Object.freeze({ __proto__: null, name: "PHP", type: fa2, tmScope: Ta2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: ka2, color: ma2, extensions: Ea2, filenames: xa2, interpreters: ya2, aliases: va2, languageId: 272, default: Aa2 }), Na2 = "HTML+PHP", Ca2 = "markup", Sa2 = "text.html.php", ba2 = "HTML", La2 = [".phtml"], Oa2 = "application/x-httpd-php", Ia2 = { name: Na2, type: Ca2, tmScope: Sa2, group: ba2, extensions: La2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: Oa2, languageId: 151 }, Ra2 = Object.freeze({ __proto__: null, name: Na2, type: Ca2, tmScope: Sa2, group: ba2, extensions: La2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: Oa2, languageId: 151, default: Ia2 }), wa2 = na2(ga2), Da2 = na2(Ra2), Pa2 = n2.default.doc.builders, Ua2 = Pa2.join, Ba2 = Pa2.hardline, Ma2 = da2, Fa2 = pa2;
      function Ha2(t3, e3) {
        var i3 = e3.extend, n3 = e3.override, s3 = {};
        for (var r3 in t3) {
          s3[r3 === "languageId" ? "linguistLanguageId" : r3] = t3[r3];
        }
        if (i3)
          for (var o3 in i3)
            s3[o3] = (s3[o3] || []).concat(i3[o3]);
        for (var a3 in n3)
          s3[a3] = n3[a3];
        return s3;
      }
      var Ga2 = [Ha2(wa2, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } }), Ha2(Da2, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } })], Va2 = function(t3) {
        return function(e3) {
          return e3.loc && e3.loc[t3] && e3.loc[t3].offset;
        };
      }, Wa2 = { php: { parse: cs2, astFormat: "php", locStart: Va2("start"), locEnd: Va2("end"), hasPragma: Ma2 } }, Qa2 = { languages: Ga2, printers: { php: { print: Qo2, insertPragma: Fa2, massageAstNode: Yo2, getCommentChildNodes: dr2.getCommentChildNodes, canAttachComment: dr2.canAttachComment, isBlockComment: dr2.isBlockComment, handleComments: { ownLine: dr2.handleOwnLineComment, endOfLine: dr2.handleEndOfLineComment, remaining: dr2.handleRemainingComment }, willPrintOwnComments(t3) {
        var e3 = t3.getValue();
        return e3 && e3.kind === "noop";
      }, printComment(t3) {
        var e3 = t3.getValue();
        switch (e3.kind) {
          case "commentblock":
            if (!e3.value.includes("\n"))
              return e3.value;
            var i3 = e3.value.split(/\r?\n/g);
            return i3.slice(1, i3.length - 1).every(function(t4) {
              return t4.trim()[0] === "*";
            }) ? Ua2(Ba2, i3.map(function(t4, e4) {
              return (e4 > 0 ? " " : "") + (e4 < i3.length - 1 ? t4.trim() : t4.trimLeft());
            })) : e3.value;
          case "commentline":
            return e3.value.trimRight();
          default:
            throw new Error("Not a comment: ".concat(JSON.stringify(e3)));
        }
      }, hasPrettierIgnore(t3) {
        var e3 = function(t4) {
          return t4.value.includes("prettier-ignore") && !t4.value.includes("prettier-ignore-start") && !t4.value.includes("prettier-ignore-end");
        }, i3 = t3.getParentNode(), n3 = t3.getNode();
        return n3 && n3.kind !== "classconstant" && n3.comments && n3.comments.length > 0 && n3.comments.some(e3) || n3 && n3.kind === "constant" && i3 && i3.kind === "classconstant" && i3.comments && i3.comments.length > 0 && i3.comments.some(e3);
      } } }, parsers: Wa2, options: $o2, defaultOptions: { tabWidth: 4 } }, Ya2 = Qa2.languages, ja2 = Qa2.printers, $a2 = Qa2.parsers, za2 = Qa2.options, Ka2 = Qa2.defaultOptions;
      t2.default = Qa2, t2.defaultOptions = Ka2, t2.languages = Ya2, t2.options = za2, t2.parsers = $a2, t2.printers = ja2, Object.defineProperty(t2, "__esModule", { value: true });
    });
  })(standalone$1, standalone$1.exports);
  var __prettierPhp = /* @__PURE__ */ getDefaultExportFromCjs(standalone$1.exports);
  var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  define();
  class SCodeExample extends SLitComponent {
    constructor() {
      var _a2;
      super(__deepMerge$1({
        componentUtils: {
          interface: SCodeExampleComponentInterface
        }
      }));
      this._$copy = void 0;
      this._items = [];
      this._activeTabId = void 0;
      const languages = Object.assign({ html: xml, javascript, js: javascript, php, bash, shell: bash, css }, (_a2 = this.props.languages) !== null && _a2 !== void 0 ? _a2 : {});
      Object.keys(languages).forEach((lang) => {
        core.registerLanguage(lang, languages[lang]);
      });
    }
    static get properties() {
      return SLitComponent.properties({}, SCodeExampleComponentInterface);
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(__css)}
        `;
    }
    firstUpdated() {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function* () {
        this.$templates.forEach(($template) => {
          var _a3, _b3, _c2, _d2, _e2, _f2, _g2;
          if (!$template.getAttribute)
            return;
          let parser = "babel";
          switch ((_b3 = (_a3 = $template.getAttribute("id")) !== null && _a3 !== void 0 ? _a3 : $template.getAttribute("language")) !== null && _b3 !== void 0 ? _b3 : $template.getAttribute("lang")) {
            case "html":
            case "xml":
              parser = "html";
              break;
            case "css":
            case "scss":
            case "postcss":
              parser = "css";
              break;
          }
          let rawCode = decodeHtmlEntities($template.tagName.toLowerCase() === "textarea" && $template.value ? $template.value : $template.innerHTML);
          let formatedCode = rawCode;
          try {
            formatedCode = VV.format(rawCode, {
              parser,
              plugins: [
                Ot,
                Bo,
                Uu,
                __prettierPhp
              ]
            });
          } catch (e2) {
          }
          this._items = [
            ...this._items,
            {
              id: (_e2 = (_d2 = (_c2 = $template.getAttribute("id")) !== null && _c2 !== void 0 ? _c2 : $template.getAttribute("language")) !== null && _d2 !== void 0 ? _d2 : $template.getAttribute("lang")) !== null && _e2 !== void 0 ? _e2 : "html",
              lang: (_g2 = (_f2 = $template.getAttribute("language")) !== null && _f2 !== void 0 ? _f2 : $template.getAttribute("lang")) !== null && _g2 !== void 0 ? _g2 : "html",
              code: formatedCode,
              lines: formatedCode.trim().split("\n").length
            }
          ];
          $template.remove();
        });
        if (this.active) {
          this.setActiveTab(this.active);
        } else {
          if (this._items[0]) {
            this.setActiveTab(this._items[0].id);
          }
        }
        this._$pre = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".s-code-example__code");
        this._$root = (_b2 = this.shadowRoot) === null || _b2 === void 0 ? void 0 : _b2.querySelector(".s-code-example");
        return true;
      });
    }
    setActiveTabByTab(e2) {
      this.setActiveTab(e2.target.id);
    }
    get currentItem() {
      if (!this._activeTabId)
        return {};
      return this._items.find((i2) => i2.id === this._activeTabId);
    }
    setActiveTab(id2) {
      return __awaiter(this, void 0, void 0, function* () {
        yield wait();
        this._activeTabId = id2;
        this.initPrismOnTab(id2);
      });
    }
    setMoreClass() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._more) {
          this._$root.classList.add("s-code-example--more");
        } else {
          this._$root.classList.remove("s-code-example--more");
        }
        this.requestUpdate();
      });
    }
    toggleMore() {
      var _a2;
      this._more = !this._more;
      this.setMoreClass();
      scrollTo(this, Object.assign({}, (_a2 = this.props.scrollToSettings) !== null && _a2 !== void 0 ? _a2 : {}));
    }
    initPrismOnTab(id2) {
      var _a2, _b2;
      const $content = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`pre#${id2} code`);
      const item = this._items.find((i2) => i2.id === id2);
      if ($content.hasAttribute("inited")) {
        this.setMoreClass();
        return;
      }
      $content.setAttribute("inited", "true");
      let code;
      try {
        code = core.highlight($content.innerHTML.replace(/<!--\?lit.*-->/, ""), {
          language: $content.getAttribute("lang")
        });
      } catch (e2) {
      }
      item.highlightedCode = decodeHtmlEntities((_b2 = code === null || code === void 0 ? void 0 : code.value) !== null && _b2 !== void 0 ? _b2 : "");
      this.setMoreClass();
    }
    copy() {
      const id2 = this._activeTabId;
      const item = this._items.filter((i2) => i2.id === id2)[0];
      this.$copy.copy(item.code);
    }
    render() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      const currentItem = this.currentItem;
      return html`
            <div
                class="${this.componentUtils.className()} ${this.props.more ? this.componentUtils.className("more") : ""}"
                ?lines="${this.lines}"
                ?mounted="${this.mounted}"
                ?bare="${this.bare}"
                toolbar-position="${this.toolbarPosition}"
            >
                <div class="templates">
                    <slot></slot>
                </div>

                <header class="${this.componentUtils.className("__nav")}">
                    <ol
                        class="${this.componentUtils.className("__tabs", "s-tabs")}"
                    >
                        ${((_a2 = this._items) !== null && _a2 !== void 0 ? _a2 : []).map((item) => html`
                                <li
                                    class="${this.componentUtils.className("__tab")}"
                                    id="${item.id}"
                                    ?active="${this._activeTabId === item.id}"
                                    @click="${this.setActiveTabByTab}"
                                >
                                    ${item.lang}
                                </li>
                            `)}
                    </ol>
                    ${this.toolbarPosition === "nav" ? html`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                </header>
                <div
                    class="${this.componentUtils.className("__content")}"
                    style="--max-lines: ${(_b2 = this.props.lines) !== null && _b2 !== void 0 ? _b2 : 99999999};"
                >
                    ${this.toolbarPosition !== "nav" ? html`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                    ${((_c2 = this._items) !== null && _c2 !== void 0 ? _c2 : []).map((item) => {
        var _a3, _b3, _c3;
        return html`
                            <pre
                                class="${this.componentUtils.className("__code")}"
                                style="line-height:0;"
                                id="${(_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : item.lang}"
                                ?active="${this._activeTabId === ((_b3 = item.id) !== null && _b3 !== void 0 ? _b3 : item.lang)}"
                            >
                            <code lang="${(_c3 = item.lang) !== null && _c3 !== void 0 ? _c3 : item.id}" class="language-${item.lang} ${item.lang} ${this.props.bare ? "" : "hljs"}">${item.highlightedCode ? unsafeHTML(item.highlightedCode) : item.code.trim()}</code>
                        </pre>
                        `;
      })}
                    ${this.props.lines && currentItem.lines > this.lines ? html`
                        <div class="${this.componentUtils.className("__more-bar")}">
                            ${this.moreAction === "toggle" ? html`
                                          <a
                                              class="${this.componentUtils.className("__more-button", "s-btn")}"
                                              @click="${() => this.toggleMore()}"
                                          >
                                              ${this._more ? html`
                                                            ${(_d2 = this.props.lessLabel) !== null && _d2 !== void 0 ? _d2 : "Show less"}
                                                        ` : html`
                                                            ${(_e2 = this.props.moreLabel) !== null && _e2 !== void 0 ? _e2 : "Show more"}
                                                        `}
                                          </a>
                                      ` : html`
                                          <a
                                              class="${this.componentUtils.className("__more-button", "s-btn s-color--accent")}"
                                              href="${this.moreAction}"
                                          >
                                              ${this._more ? html`
                                                            ${(_f2 = this.props.lessLabel) !== null && _f2 !== void 0 ? _f2 : "Show less"}
                                                        ` : html`
                                                            ${(_g2 = this.props.moreLabel) !== null && _g2 !== void 0 ? _g2 : "Show more"}
                                                        `}
                                          </a>
                                      `}                        
                            </a>
                        </div>
                    ` : ""}
                </div>
            </div>
        `;
    }
  }
  __decorate([
    property()
  ], SCodeExample.prototype, "_items", void 0);
  __decorate([
    property()
  ], SCodeExample.prototype, "_activeTabId", void 0);
  __decorate([
    property({
      type: String
    })
  ], SCodeExample.prototype, "active", void 0);
  __decorate([
    property()
  ], SCodeExample.prototype, "props", void 0);
  __decorate([
    query("s-clipboard-copy")
  ], SCodeExample.prototype, "$copy", void 0);
  __decorate([
    query(".templates")
  ], SCodeExample.prototype, "$templatesContainer", void 0);
  __decorate([
    queryAssignedNodes()
  ], SCodeExample.prototype, "$templates", void 0);
  if (!window.env)
    window.env = { SUGAR: {} };
  window.env.SUGAR = JSON.parse(`{"platform":"browser","env":"dev","config":{"contact":{"discord":{"url":"https://discord.gg/ERsX54UE","shield":"https://img.shields.io/badge/Join%20us%20on%20discord-Join-blueviolet?style=for-the-badge&logo=discord"},"email":{"url":"mailto:olivier.bossel@gmail.com","shield":"https://img.shields.io/badge/Email%20us-Go-green?style=for-the-badge&logo=Mail.Ru"}},"datetime":{"dateFormat":"YYYY-MM-DD","timeFormat":"h:mm:ss","i18n":{"previousMonth":"Previous Month","nextMonth":"Next Month","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]}},"log":{"types":["info","warning","error"]},"serve":{"img":{"url":"http://127.0.0.1:3000/img"},"js":{"url":"http://127.0.0.1:3000/js"},"css":{"url":"http://127.0.0.1:3000/css"},"icons":{"url":"http://127.0.0.1:3000/icons"},"fonts":{"url":"http://127.0.0.1:3000/fonts"}},"env":{"env":"development"},"theme":{"theme":"default","variant":"light","cssVariables":["*"],"themes":{"coffeekraken-dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#776D91","...":"[extends.colorSchemas]"},"ui":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#7a738c","...":"[extends.colorSchemas]"},"accent":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffbb00","...":"[extends.colorSchemas]"},"complementary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":15},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#5100ff","...":"[extends.colorSchemas]"},"success":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#91ff00","...":"[extends.colorSchemas]"},"warning":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffd500","...":"[extends.colorSchemas]"},"error":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ff003b","...":"[extends.colorSchemas]"},"info":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#00ffff","...":"[extends.colorSchemas]"},"current":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"primary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"secondary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{"rhythmVertical":{"margin-bottom":60}}},"ui":{"filtrableInput":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":100,"outline":true,"rhythmVertical":{"margin-bottom":60}},"default":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":60}},"form":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"defaultColor":"accent","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":"10px","transition":"all .2s ease-out"},"scrollbar":{"size":"2px","defaultColor":"main"},"button":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"depth":50,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"avatar":{"borderRadius":"10px","borderWidth":"2px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"colorPicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","defaultStyle":"solid","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"datePicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":["theme.ui.form.defaultColor"],"defaultStyle":"solid","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"input":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"radio":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.5em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"outline":true,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":40}},"checkbox":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.2em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"range":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"label":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"inline","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":40}},"select":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"switch":{"borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"dropdown":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true},"list":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"dl","depth":50,"bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"fsTree":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"tabs":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"outline":true,"rhythmVertical":{"margin-bottom":60}},"terminal":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":50,"rhythmVertical":{"margin-bottom":60}},"tooltip":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"arrowSize":"20px"},"code":{"paddingInline":"3rem","paddingBlock":"3rem","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":50,"rhythmVertical":{"margin-bottom":60}},"blockquote":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":60}},"table":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"badge":{"paddingInline":".65em","paddingBlock":".35em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","depth":50,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"default-light":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"accent":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#ffbb00","...":"[extends.colorSchemas]"},"complementary":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#5100ff","...":"[extends.colorSchemas]"},"success":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50,"darken":20},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#91ff00","...":"[extends.colorSchemas]"},"warning":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#ffd500","...":"[extends.colorSchemas]"},"error":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#ff003b","...":"[extends.colorSchemas]"},"info":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#00ffff","...":"[extends.colorSchemas]"},"current":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"primary":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"secondary":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{"rhythmVertical":{"margin-bottom":60}}},"ui":{"filtrableInput":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":100,"outline":true,"rhythmVertical":{"margin-bottom":60}},"default":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":60}},"form":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"defaultColor":"accent","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":"10px","transition":"all .2s ease-out"},"scrollbar":{"size":"2px","defaultColor":"main"},"button":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"depth":50,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"avatar":{"borderRadius":"10px","borderWidth":"2px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"colorPicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","defaultStyle":"solid","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"datePicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":["theme.ui.form.defaultColor"],"defaultStyle":"solid","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"input":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"radio":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.5em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"outline":true,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":40}},"checkbox":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.2em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"range":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"label":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"inline","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":40}},"select":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"switch":{"borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"dropdown":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true},"list":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"dl","depth":50,"bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"fsTree":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"tabs":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"outline":true,"rhythmVertical":{"margin-bottom":60}},"terminal":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":50,"rhythmVertical":{"margin-bottom":60}},"tooltip":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"arrowSize":"20px"},"code":{"paddingInline":"3rem","paddingBlock":"3rem","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":50,"rhythmVertical":{"margin-bottom":60}},"blockquote":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":60}},"table":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"badge":{"paddingInline":".65em","paddingBlock":".35em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","depth":50,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"defaultColor":"main"},"default-dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"accent":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffbb00","...":"[extends.colorSchemas]"},"complementary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":15},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#5100ff","...":"[extends.colorSchemas]"},"success":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#91ff00","...":"[extends.colorSchemas]"},"warning":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffd500","...":"[extends.colorSchemas]"},"error":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ff003b","...":"[extends.colorSchemas]"},"info":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#00ffff","...":"[extends.colorSchemas]"},"current":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"primary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"secondary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{"rhythmVertical":{"margin-bottom":60}}},"ui":{"filtrableInput":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":100,"outline":true,"rhythmVertical":{"margin-bottom":60}},"default":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":60}},"form":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"defaultColor":"accent","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":"10px","transition":"all .2s ease-out"},"scrollbar":{"size":"2px","defaultColor":"main"},"button":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"depth":50,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"avatar":{"borderRadius":"10px","borderWidth":"2px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"colorPicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","defaultStyle":"solid","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"datePicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":["theme.ui.form.defaultColor"],"defaultStyle":"solid","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"input":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"radio":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.5em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"outline":true,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":40}},"checkbox":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.2em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"range":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true,"rhythmVertical":{"margin-bottom":40}},"label":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"inline","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":40}},"select":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"switch":{"borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":50,"defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"dropdown":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"outline":true},"list":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"dl","depth":50,"bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"fsTree":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"tabs":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"outline":true,"rhythmVertical":{"margin-bottom":60}},"terminal":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":50,"rhythmVertical":{"margin-bottom":60}},"tooltip":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"arrowSize":"20px"},"code":{"paddingInline":"3rem","paddingBlock":"3rem","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":50,"rhythmVertical":{"margin-bottom":60}},"blockquote":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":50,"rhythmVertical":{"margin-bottom":60}},"table":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"badge":{"paddingInline":".65em","paddingBlock":".35em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","depth":50,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"defaultColor":"main"}}}}}`);
  var os = new Proxy({}, {
    get() {
      throw new Error('Module "os" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  class Defaults {
    constructor() {
      __publicField(this, "appspace", "app.");
      __publicField(this, "socketRoot", "/tmp/");
      __publicField(this, "id", os.hostname());
      __publicField(this, "encoding", "utf8");
      __publicField(this, "rawBuffer", false);
      __publicField(this, "sync", false);
      __publicField(this, "unlink", true);
      __publicField(this, "delimiter", "\f");
      __publicField(this, "silent", false);
      __publicField(this, "logDepth", 5);
      __publicField(this, "logInColor", true);
      __publicField(this, "logger", console.log.bind(console));
      __publicField(this, "maxConnections", 100);
      __publicField(this, "retry", 500);
      __publicField(this, "maxRetries", Infinity);
      __publicField(this, "stopRetrying", false);
      __publicField(this, "IPType", getIPType());
      __publicField(this, "tls", false);
      __publicField(this, "networkHost", this.IPType == "IPv6" ? "::1" : "127.0.0.1");
      __publicField(this, "networkPort", 8e3);
      __publicField(this, "readableAll", false);
      __publicField(this, "writableAll", false);
      __publicField(this, "interface", {
        localAddress: false,
        localPort: false,
        family: false,
        hints: false,
        lookup: false
      });
    }
  }
  function getIPType() {
    const networkInterfaces = os.networkInterfaces();
    let IPType = "";
    if (networkInterfaces && Array.isArray(networkInterfaces) && networkInterfaces.length > 0) {
      IPType = networkInterfaces[Object.keys(networkInterfaces)[0]][0].family;
    }
    return IPType;
  }
  var net = new Proxy({}, {
    get() {
      throw new Error('Module "net" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var tls = new Proxy({}, {
    get() {
      throw new Error('Module "tls" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  class Parser {
    constructor(config) {
      if (!config) {
        config = new Defaults();
      }
      this.delimiter = config.delimiter;
    }
    format(message) {
      if (!message.data && message.data !== false && message.data !== 0) {
        message.data = {};
      }
      if (message.data["_maxListeners"]) {
        message.data = {};
      }
      message = message.JSON + this.delimiter;
      return message;
    }
    parse(data) {
      let events = data.split(this.delimiter);
      events.pop();
      return events;
    }
  }
  function Message() {
    Object.defineProperties(this, {
      data: {
        enumerable: true,
        get: getData,
        set: setData
      },
      type: {
        enumerable: true,
        get: getType,
        set: setType
      },
      load: {
        enumerable: true,
        writable: false,
        value: parse2
      },
      JSON: {
        enumerable: true,
        get: getJSON
      }
    });
    var type = "";
    var data = {};
    function getType() {
      return type;
    }
    function getData() {
      return data;
    }
    function getJSON() {
      return JSON.stringify({
        type,
        data
      });
    }
    function setType(value) {
      type = value;
    }
    function setData(value) {
      data = value;
    }
    function parse2(message) {
      try {
        var message = JSON.parse(message);
        type = message.type;
        data = message.data;
      } catch (err) {
        var badMessage = message;
        type = "error", data = {
          message: "Invalid JSON response format",
          err,
          response: badMessage
        };
      }
    }
  }
  var Message_1 = Message;
  var fs = new Proxy({}, {
    get() {
      throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  function Queue(asStack) {
    Object.defineProperties(this, {
      add: {
        enumerable: true,
        writable: false,
        value: addToQueue
      },
      next: {
        enumerable: true,
        writable: false,
        value: run
      },
      clear: {
        enumerable: true,
        writable: false,
        value: clearQueue
      },
      contents: {
        enumerable: false,
        get: getQueue,
        set: setQueue
      },
      autoRun: {
        enumerable: true,
        writable: true,
        value: true
      },
      stop: {
        enumerable: true,
        writable: true,
        value: false
      }
    });
    var queue2 = [];
    var running = false;
    function clearQueue() {
      queue2 = [];
      return queue2;
    }
    function getQueue() {
      return queue2;
    }
    function setQueue(val) {
      queue2 = val;
      return queue2;
    }
    function addToQueue() {
      for (var i2 in arguments) {
        queue2.push(arguments[i2]);
      }
      if (!running && !this.stop && this.autoRun) {
        this.next();
      }
    }
    function run() {
      running = true;
      if (queue2.length < 1 || this.stop) {
        running = false;
        return;
      }
      queue2.shift().bind(this)();
    }
  }
  var queue = Queue;
  class Fake {
  }
  class FakeCore {
  }
  class Is {
    constructor(strict = true) {
      this.strict = strict;
    }
    throw(valueType, expectedType) {
      let err = new TypeError();
      err.message = `expected type of ${valueType} to be ${expectedType}`;
      if (!this.strict) {
        return false;
      }
      throw err;
    }
    typeCheck(value, type) {
      if (typeof value === type) {
        return true;
      }
      return this.throw(typeof value, type);
    }
    instanceCheck(value = new Fake(), constructor = FakeCore) {
      if (value instanceof constructor) {
        return true;
      }
      return this.throw(typeof value, constructor.name);
    }
    symbolStringCheck(value, type) {
      if (Object.prototype.toString.call(value) == `[object ${type}]`) {
        return true;
      }
      return this.throw(Object.prototype.toString.call(value), `[object ${type}]`);
    }
    compare(value, targetValue, typeName) {
      if (value == targetValue) {
        return true;
      }
      if (!this.strict) {
        return false;
      }
      throw new Error(`expected ${value} == ${targetValue} but it is not.`);
    }
    defined(value) {
      const weakIs = new Is(false);
      if (weakIs.undefined(value)) {
        return this.throw("undefined", "defined");
      }
      return true;
    }
    any(value) {
      return this.defined(value);
    }
    exists(value) {
      return this.defined(value);
    }
    union(value, typesString) {
      const types = typesString.split("|");
      const weakIs = new Is(false);
      let pass = false;
      let type = "undefined";
      for (type of types) {
        try {
          if (weakIs[type](value)) {
            pass = true;
            break;
          }
        } catch (err) {
          return this.throw(type, "a method available on strong-type");
        }
      }
      if (pass) {
        return this[type](value);
      }
      return this.throw(typeof value, types.join("|"));
    }
    finite(value) {
      if (isFinite(value)) {
        return true;
      }
      return this.throw(typeof value, "finite");
    }
    NaN(value) {
      if (!this.number(value)) {
        return this.number(value);
      }
      if (isNaN(value)) {
        return true;
      }
      return this.throw(typeof value, "NaN");
    }
    null(value) {
      return this.compare(value, null, "null");
    }
    array(value) {
      return this.instanceCheck(value, Array);
    }
    boolean(value) {
      return this.typeCheck(value, "boolean");
    }
    bigInt(value) {
      return this.typeCheck(value, "bigint");
    }
    date(value) {
      return this.instanceCheck(value, Date);
    }
    generator(value) {
      return this.symbolStringCheck(value, "Generator");
    }
    asyncGenerator(value) {
      return this.symbolStringCheck(value, "AsyncGenerator");
    }
    globalThis(value) {
      return this.compare(value, globalThis, "explicitly globalThis, not window, global nor self");
    }
    infinity(value) {
      return this.compare(value, Infinity, "Infinity");
    }
    map(value) {
      return this.instanceCheck(value, Map);
    }
    weakMap(value) {
      return this.instanceCheck(value, WeakMap);
    }
    number(value) {
      return this.typeCheck(value, "number");
    }
    object(value) {
      return this.typeCheck(value, "object");
    }
    promise(value) {
      return this.instanceCheck(value, Promise);
    }
    regExp(value) {
      return this.instanceCheck(value, RegExp);
    }
    undefined(value) {
      return this.typeCheck(value, "undefined");
    }
    set(value) {
      return this.instanceCheck(value, Set);
    }
    weakSet(value) {
      return this.instanceCheck(value, WeakSet);
    }
    string(value) {
      return this.typeCheck(value, "string");
    }
    symbol(value) {
      return this.typeCheck(value, "symbol");
    }
    function(value) {
      return this.typeCheck(value, "function");
    }
    asyncFunction(value) {
      return this.symbolStringCheck(value, "AsyncFunction");
    }
    generatorFunction(value) {
      return this.symbolStringCheck(value, "GeneratorFunction");
    }
    asyncGeneratorFunction(value) {
      return this.symbolStringCheck(value, "AsyncGeneratorFunction");
    }
    error(value) {
      return this.instanceCheck(value, Error);
    }
    evalError(value) {
      return this.instanceCheck(value, EvalError);
    }
    rangeError(value) {
      return this.instanceCheck(value, RangeError);
    }
    referenceError(value) {
      return this.instanceCheck(value, ReferenceError);
    }
    syntaxError(value) {
      return this.instanceCheck(value, SyntaxError);
    }
    typeError(value) {
      return this.instanceCheck(value, TypeError);
    }
    URIError(value) {
      return this.instanceCheck(value, URIError);
    }
    bigInt64Array(value) {
      return this.instanceCheck(value, BigInt64Array);
    }
    bigUint64Array(value) {
      return this.instanceCheck(value, BigUint64Array);
    }
    float32Array(value) {
      return this.instanceCheck(value, Float32Array);
    }
    float64Array(value) {
      return this.instanceCheck(value, Float64Array);
    }
    int8Array(value) {
      return this.instanceCheck(value, Int8Array);
    }
    int16Array(value) {
      return this.instanceCheck(value, Int16Array);
    }
    int32Array(value) {
      return this.instanceCheck(value, Int32Array);
    }
    uint8Array(value) {
      return this.instanceCheck(value, Uint8Array);
    }
    uint8ClampedArray(value) {
      return this.instanceCheck(value, Uint8ClampedArray);
    }
    uint16Array(value) {
      return this.instanceCheck(value, Uint16Array);
    }
    uint32Array(value) {
      return this.instanceCheck(value, Uint32Array);
    }
    arrayBuffer(value) {
      return this.instanceCheck(value, ArrayBuffer);
    }
    dataView(value) {
      return this.instanceCheck(value, DataView);
    }
    sharedArrayBuffer(value) {
      return this.instanceCheck(value, function() {
        try {
          return SharedArrayBuffer;
        } catch (e2) {
          return Fake;
        }
      }());
    }
    intlDateTimeFormat(value) {
      return this.instanceCheck(value, Intl.DateTimeFormat);
    }
    intlCollator(value) {
      return this.instanceCheck(value, Intl.Collator);
    }
    intlDisplayNames(value) {
      return this.instanceCheck(value, Intl.DisplayNames);
    }
    intlListFormat(value) {
      return this.instanceCheck(value, Intl.ListFormat);
    }
    intlLocale(value) {
      return this.instanceCheck(value, Intl.Locale);
    }
    intlNumberFormat(value) {
      return this.instanceCheck(value, Intl.NumberFormat);
    }
    intlPluralRules(value) {
      return this.instanceCheck(value, Intl.PluralRules);
    }
    intlRelativeTimeFormat(value) {
      return this.instanceCheck(value, Intl.RelativeTimeFormat);
    }
    intlRelativeTimeFormat(value) {
      return this.instanceCheck(value, Intl.RelativeTimeFormat);
    }
    finalizationRegistry(value) {
      return this.instanceCheck(value, FinalizationRegistry);
    }
    weakRef(value) {
      return this.instanceCheck(value, WeakRef);
    }
  }
  const is = new Is();
  class EventPubSub {
    constructor() {
      __privateAdd(this, _handleOnce, (type, handlers, ...args) => {
        is.string(type);
        is.array(handlers);
        const deleteOnceHandled = [];
        for (let handler of handlers) {
          handler(...args);
          if (handler[__privateGet(this, _once)]) {
            deleteOnceHandled.push(handler);
          }
        }
        for (let handler of deleteOnceHandled) {
          this.off(type, handler);
        }
      });
      __privateAdd(this, _all, Symbol.for("event-pubsub-all"));
      __privateAdd(this, _once, Symbol.for("event-pubsub-once"));
      __privateAdd(this, _events, {});
    }
    on(type, handler, once = false) {
      is.string(type);
      is.function(handler);
      is.boolean(once);
      if (type == "*") {
        type = __privateGet(this, _all);
      }
      if (!__privateGet(this, _events)[type]) {
        __privateGet(this, _events)[type] = [];
      }
      handler[__privateGet(this, _once)] = once;
      __privateGet(this, _events)[type].push(handler);
      return this;
    }
    once(type, handler) {
      return this.on(type, handler, true);
    }
    off(type = "*", handler = "*") {
      is.string(type);
      if (type == __privateGet(this, _all).toString() || type == "*") {
        type = __privateGet(this, _all);
      }
      if (!__privateGet(this, _events)[type]) {
        return this;
      }
      if (handler == "*") {
        delete __privateGet(this, _events)[type];
        return this;
      }
      is.function(handler);
      const handlers = __privateGet(this, _events)[type];
      while (handlers.includes(handler)) {
        handlers.splice(handlers.indexOf(handler), 1);
      }
      if (handlers.length < 1) {
        delete __privateGet(this, _events)[type];
      }
      return this;
    }
    emit(type, ...args) {
      is.string(type);
      const globalHandlers = __privateGet(this, _events)[__privateGet(this, _all)] || [];
      __privateGet(this, _handleOnce).call(this, __privateGet(this, _all).toString(), globalHandlers, type, ...args);
      if (!__privateGet(this, _events)[type]) {
        return this;
      }
      const handlers = __privateGet(this, _events)[type];
      __privateGet(this, _handleOnce).call(this, type, handlers, ...args);
      return this;
    }
    reset() {
      this.off(__privateGet(this, _all).toString());
      for (let type in __privateGet(this, _events)) {
        this.off(type);
      }
      return this;
    }
    get list() {
      return Object.assign({}, __privateGet(this, _events));
    }
  }
  _handleOnce = new WeakMap();
  _all = new WeakMap();
  _once = new WeakMap();
  _events = new WeakMap();
  let eventParser$1 = new Parser();
  class Client extends EventPubSub {
    constructor(config, log2) {
      super();
      __publicField(this, "Client", Client);
      __publicField(this, "queue", new queue());
      __publicField(this, "socket", false);
      __publicField(this, "connect", connect$1);
      __publicField(this, "emit", emit$1);
      __publicField(this, "retriesRemaining", 0);
      __publicField(this, "explicitlyDisconnected", false);
      this.config = config;
      this.log = log2;
      this.publish = super.emit;
      config.maxRetries ? this.retriesRemaining = config.maxRetries : 0;
      eventParser$1 = new Parser(this.config);
    }
  }
  function emit$1(type, data) {
    this.log("dispatching event to ", this.id, this.path, " : ", type, ",", data);
    let message = new Message_1();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
      message = Buffer.from(type, this.config.encoding);
    } else {
      message = eventParser$1.format(message);
    }
    if (!this.config.sync) {
      this.socket.write(message);
      return;
    }
    this.queue.add(syncEmit.bind(this, message));
  }
  function syncEmit(message) {
    this.log("dispatching event to ", this.id, this.path, " : ", message);
    this.socket.write(message);
  }
  function connect$1() {
    let client = this;
    client.log("requested connection to ", client.id, client.path);
    if (!this.path) {
      client.log("\n\n######\nerror: ", client.id, " client has not specified socket path it wishes to connect to.");
      return;
    }
    const options = {};
    if (!client.port) {
      client.log("Connecting client on Unix Socket :", client.path);
      options.path = client.path;
      if (process.platform === "win32" && !client.path.startsWith("\\\\.\\pipe\\")) {
        options.path = options.path.replace(/^\//, "");
        options.path = options.path.replace(/\//g, "-");
        options.path = `\\\\.\\pipe\\${options.path}`;
      }
      client.socket = net.connect(options);
    } else {
      options.host = client.path;
      options.port = client.port;
      if (client.config.interface.localAddress) {
        options.localAddress = client.config.interface.localAddress;
      }
      if (client.config.interface.localPort) {
        options.localPort = client.config.interface.localPort;
      }
      if (client.config.interface.family) {
        options.family = client.config.interface.family;
      }
      if (client.config.interface.hints) {
        options.hints = client.config.interface.hints;
      }
      if (client.config.interface.lookup) {
        options.lookup = client.config.interface.lookup;
      }
      if (!client.config.tls) {
        client.log("Connecting client via TCP to", options);
        client.socket = net.connect(options);
      } else {
        client.log("Connecting client via TLS to", client.path, client.port, client.config.tls);
        if (client.config.tls.private) {
          client.config.tls.key = fs.readFileSync(client.config.tls.private);
        }
        if (client.config.tls.public) {
          client.config.tls.cert = fs.readFileSync(client.config.tls.public);
        }
        if (client.config.tls.trustedConnections) {
          if (typeof client.config.tls.trustedConnections === "string") {
            client.config.tls.trustedConnections = [client.config.tls.trustedConnections];
          }
          client.config.tls.ca = [];
          for (let i2 = 0; i2 < client.config.tls.trustedConnections.length; i2++) {
            client.config.tls.ca.push(fs.readFileSync(client.config.tls.trustedConnections[i2]));
          }
        }
        Object.assign(client.config.tls, options);
        client.socket = tls.connect(client.config.tls);
      }
    }
    client.socket.setEncoding(this.config.encoding);
    client.socket.on("error", function(err) {
      client.log("\n\n######\nerror: ", err);
      client.publish("error", err);
    });
    client.socket.on("connect", function connectionMade() {
      client.publish("connect");
      client.retriesRemaining = client.config.maxRetries;
      client.log("retrying reset");
    });
    client.socket.on("close", function connectionClosed() {
      client.log("connection closed", client.id, client.path, client.retriesRemaining, "tries remaining of", client.config.maxRetries);
      if (client.config.stopRetrying || client.retriesRemaining < 1 || client.explicitlyDisconnected) {
        client.publish("disconnect");
        client.log(client.config.id, "exceeded connection rety amount of", " or stopRetrying flag set.");
        client.socket.destroy();
        client.publish("destroy");
        client = void 0;
        return;
      }
      setTimeout(function retryTimeout() {
        if (client.explicitlyDisconnected) {
          return;
        }
        client.retriesRemaining--;
        client.connect();
      }.bind(null, client), client.config.retry);
      client.publish("disconnect");
    });
    client.socket.on("data", function(data) {
      client.log("## received events ##");
      if (client.config.rawBuffer) {
        client.publish("data", Buffer.from(data, client.config.encoding));
        if (!client.config.sync) {
          return;
        }
        client.queue.next();
        return;
      }
      if (!this.ipcBuffer) {
        this.ipcBuffer = "";
      }
      data = this.ipcBuffer += data;
      if (data.slice(-1) != eventParser$1.delimiter || data.indexOf(eventParser$1.delimiter) == -1) {
        client.log("Messages are large, You may want to consider smaller messages.");
        return;
      }
      this.ipcBuffer = "";
      const events = eventParser$1.parse(data);
      const eCount = events.length;
      for (let i2 = 0; i2 < eCount; i2++) {
        let message = new Message_1();
        message.load(events[i2]);
        client.log("detected event", message.type, message.data);
        client.publish(message.type, message.data);
      }
      if (!client.config.sync) {
        return;
      }
      client.queue.next();
    });
  }
  var dgram = new Proxy({}, {
    get() {
      throw new Error('Module "dgram" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  let eventParser = new Parser();
  class Server extends EventPubSub {
    constructor(path2, config, log2, port) {
      super();
      __publicField(this, "udp4", false);
      __publicField(this, "udp6", false);
      __publicField(this, "server", false);
      __publicField(this, "sockets", []);
      __publicField(this, "emit", emit);
      __publicField(this, "broadcast", broadcast);
      this.config = config;
      this.path = path2;
      this.port = port;
      this.log = log2;
      this.publish = super.emit;
      eventParser = new Parser(this.config);
      this.on("close", serverClosed.bind(this));
    }
    onStart(socket) {
      this.publish("start", socket);
    }
    stop() {
      this.server.close();
    }
    start() {
      if (!this.path) {
        this.log("Socket Server Path not specified, refusing to start");
        return;
      }
      if (this.config.unlink) {
        fs.unlink(this.path, startServer.bind(this));
      } else {
        startServer.bind(this)();
      }
    }
  }
  function emit(socket, type, data) {
    this.log("dispatching event to socket", " : ", type, data);
    let message = new Message_1();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
      this.log(this.config.encoding);
      message = Buffer.from(type, this.config.encoding);
    } else {
      message = eventParser.format(message);
    }
    if (this.udp4 || this.udp6) {
      if (!socket.address || !socket.port) {
        this.log("Attempting to emit to a single UDP socket without supplying socket address or port. Redispatching event as broadcast to all connected sockets");
        this.broadcast(type, data);
        return;
      }
      this.server.write(message, socket);
      return;
    }
    socket.write(message);
  }
  function broadcast(type, data) {
    this.log("broadcasting event to all known sockets listening to ", this.path, " : ", this.port ? this.port : "", type, data);
    let message = new Message_1();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
      message = Buffer.from(type, this.config.encoding);
    } else {
      message = eventParser.format(message);
    }
    if (this.udp4 || this.udp6) {
      for (let i2 = 1, count = this.sockets.length; i2 < count; i2++) {
        this.server.write(message, this.sockets[i2]);
      }
    } else {
      for (let i2 = 0, count = this.sockets.length; i2 < count; i2++) {
        this.sockets[i2].write(message);
      }
    }
  }
  function serverClosed() {
    for (let i2 = 0, count = this.sockets.length; i2 < count; i2++) {
      let socket = this.sockets[i2];
      let destroyedSocketId = false;
      if (socket) {
        if (socket.readable) {
          continue;
        }
      }
      if (socket.id) {
        destroyedSocketId = socket.id;
      }
      this.log("socket disconnected", destroyedSocketId.toString());
      if (socket && socket.destroy) {
        socket.destroy();
      }
      this.sockets.splice(i2, 1);
      this.publish("socket.disconnected", socket, destroyedSocketId);
      return;
    }
  }
  function gotData(socket, data, UDPSocket) {
    let sock = this.udp4 || this.udp6 ? UDPSocket : socket;
    if (this.config.rawBuffer) {
      data = Buffer.from(data, this.config.encoding);
      this.publish("data", data, sock);
      return;
    }
    if (!sock.ipcBuffer) {
      sock.ipcBuffer = "";
    }
    data = sock.ipcBuffer += data;
    if (data.slice(-1) != eventParser.delimiter || data.indexOf(eventParser.delimiter) == -1) {
      this.log("Messages are large, You may want to consider smaller messages.");
      return;
    }
    sock.ipcBuffer = "";
    data = eventParser.parse(data);
    while (data.length > 0) {
      let message = new Message_1();
      message.load(data.shift());
      if (message.data && message.data.id) {
        sock.id = message.data.id;
      }
      this.log("received event of : ", message.type, message.data);
      this.publish(message.type, message.data, sock);
    }
  }
  function socketClosed(socket) {
    this.publish("close", socket);
  }
  function serverCreated(socket) {
    this.sockets.push(socket);
    if (socket.setEncoding) {
      socket.setEncoding(this.config.encoding);
    }
    this.log("## socket connection to server detected ##");
    socket.on("close", socketClosed.bind(this));
    socket.on("error", function(err) {
      this.log("server socket error", err);
      this.publish("error", err);
    }.bind(this));
    socket.on("data", gotData.bind(this, socket));
    socket.on("message", function(msg, rinfo) {
      if (!rinfo) {
        return;
      }
      this.log("Received UDP message from ", rinfo.address, rinfo.port);
      let data;
      if (this.config.rawSocket) {
        data = Buffer.from(msg, this.config.encoding);
      } else {
        data = msg.toString();
      }
      socket.emit("data", data, rinfo);
    }.bind(this));
    this.publish("connect", socket);
    if (this.config.rawBuffer) {
      return;
    }
  }
  function startServer() {
    this.log("starting server on ", this.path, this.port ? `:${this.port}` : "");
    if (!this.udp4 && !this.udp6) {
      this.log("starting TLS server", this.config.tls);
      if (!this.config.tls) {
        this.server = net.createServer(serverCreated.bind(this));
      } else {
        startTLSServer.bind(this)();
      }
    } else {
      this.server = dgram.createSocket(this.udp4 ? "udp4" : "udp6");
      this.server.write = UDPWrite.bind(this);
      this.server.on("listening", function UDPServerStarted() {
        serverCreated.bind(this)(this.server);
      }.bind(this));
    }
    this.server.on("error", function(err) {
      this.log("server error", err);
      this.publish("error", err);
    }.bind(this));
    this.server.maxConnections = this.config.maxConnections;
    if (!this.port) {
      this.log("starting server as", "Unix || Windows Socket");
      if (process.platform === "win32") {
        this.path = this.path.replace(/^\//, "");
        this.path = this.path.replace(/\//g, "-");
        this.path = `\\\\.\\pipe\\${this.path}`;
      }
      this.server.listen({
        path: this.path,
        readableAll: this.config.readableAll,
        writableAll: this.config.writableAll
      }, this.onStart.bind(this));
      return;
    }
    if (!this.udp4 && !this.udp6) {
      this.log("starting server as", this.config.tls ? "TLS" : "TCP");
      this.server.listen(this.port, this.path, this.onStart.bind(this));
      return;
    }
    this.log("starting server as", this.udp4 ? "udp4" : "udp6");
    this.server.bind(this.port, this.path);
    this.onStart({
      address: this.path,
      port: this.port
    });
  }
  function startTLSServer() {
    this.log("starting TLS server", this.config.tls);
    if (this.config.tls.private) {
      this.config.tls.key = fs.readFileSync(this.config.tls.private);
    } else {
      this.config.tls.key = fs.readFileSync(`${__dirname}/../local-node-ipc-certs/private/server.key`);
    }
    if (this.config.tls.public) {
      this.config.tls.cert = fs.readFileSync(this.config.tls.public);
    } else {
      this.config.tls.cert = fs.readFileSync(`${__dirname}/../local-node-ipc-certs/server.pub`);
    }
    if (this.config.tls.dhparam) {
      this.config.tls.dhparam = fs.readFileSync(this.config.tls.dhparam);
    }
    if (this.config.tls.trustedConnections) {
      if (typeof this.config.tls.trustedConnections === "string") {
        this.config.tls.trustedConnections = [this.config.tls.trustedConnections];
      }
      this.config.tls.ca = [];
      for (let i2 = 0; i2 < this.config.tls.trustedConnections.length; i2++) {
        this.config.tls.ca.push(fs.readFileSync(this.config.tls.trustedConnections[i2]));
      }
    }
    this.server = tls.createServer(this.config.tls, serverCreated.bind(this));
  }
  function UDPWrite(message, socket) {
    let data = Buffer.from(message, this.config.encoding);
    this.server.send(data, 0, data.length, socket.port, socket.address, function(err, bytes) {
      if (err) {
        this.log("error writing data to socket", err);
        this.publish("error", function(err2) {
          this.publish("error", err2);
        });
      }
    });
  }
  var util = new Proxy({}, {
    get() {
      throw new Error('Module "util" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  class IPC {
    constructor() {
      __publicField(this, "config", new Defaults());
      __publicField(this, "of", {});
      __publicField(this, "server", false);
    }
    get connectTo() {
      return connect;
    }
    get connectToNet() {
      return connectNet;
    }
    get disconnect() {
      return disconnect;
    }
    get serve() {
      return serve;
    }
    get serveNet() {
      return serveNet;
    }
    get log() {
      return log;
    }
    set connectTo(value) {
      return connect;
    }
    set connectToNet(value) {
      return connectNet;
    }
    set disconnect(value) {
      return disconnect;
    }
    set serve(value) {
      return serve;
    }
    set serveNet(value) {
      return serveNet;
    }
    set log(value) {
      return log;
    }
  }
  function log(...args) {
    if (this.config.silent) {
      return;
    }
    for (let i2 = 0, count = args.length; i2 < count; i2++) {
      if (typeof args[i2] != "object") {
        continue;
      }
      args[i2] = util.inspect(args[i2], {
        depth: this.config.logDepth,
        colors: this.config.logInColor
      });
    }
    this.config.logger(args.join(" "));
  }
  function disconnect(id2) {
    if (!this.of[id2]) {
      return;
    }
    this.of[id2].explicitlyDisconnected = true;
    this.of[id2].off("*", "*");
    if (this.of[id2].socket) {
      if (this.of[id2].socket.destroy) {
        this.of[id2].socket.destroy();
      }
    }
    delete this.of[id2];
  }
  function serve(path2, callback) {
    if (typeof path2 == "function") {
      callback = path2;
      path2 = false;
    }
    if (!path2) {
      this.log("Server path not specified, so defaulting to", "ipc.config.socketRoot + ipc.config.appspace + ipc.config.id", this.config.socketRoot + this.config.appspace + this.config.id);
      path2 = this.config.socketRoot + this.config.appspace + this.config.id;
    }
    if (!callback) {
      callback = emptyCallback;
    }
    this.server = new Server(path2, this.config, log);
    this.server.on("start", callback);
  }
  function emptyCallback() {
  }
  function serveNet(host, port, UDPType2, callback) {
    if (typeof host == "number") {
      callback = UDPType2;
      UDPType2 = port;
      port = host;
      host = false;
    }
    if (typeof host == "function") {
      callback = host;
      UDPType2 = false;
      host = false;
      port = false;
    }
    if (!host) {
      this.log("Server host not specified, so defaulting to", "ipc.config.networkHost", this.config.networkHost);
      host = this.config.networkHost;
    }
    if (host.toLowerCase() == "udp4" || host.toLowerCase() == "udp6") {
      callback = port;
      UDPType2 = host.toLowerCase();
      port = false;
      host = this.config.networkHost;
    }
    if (typeof port == "string") {
      callback = UDPType2;
      UDPType2 = port;
      port = false;
    }
    if (typeof port == "function") {
      callback = port;
      UDPType2 = false;
      port = false;
    }
    if (!port) {
      this.log("Server port not specified, so defaulting to", "ipc.config.networkPort", this.config.networkPort);
      port = this.config.networkPort;
    }
    if (typeof UDPType2 == "function") {
      callback = UDPType2;
      UDPType2 = false;
    }
    if (!callback) {
      callback = emptyCallback;
    }
    this.server = new Server(host, this.config, log, port);
    if (UDPType2) {
      this.server[UDPType2] = true;
      if (UDPType2 === "udp4" && host === "::1") {
        this.server.path = "127.0.0.1";
      }
    }
    this.server.on("start", callback);
  }
  function connect(id2, path2, callback) {
    if (typeof path2 == "function") {
      callback = path2;
      path2 = false;
    }
    if (!callback) {
      callback = emptyCallback;
    }
    if (!id2) {
      this.log("Service id required", "Requested service connection without specifying service id. Aborting connection attempt");
      return;
    }
    if (!path2) {
      this.log("Service path not specified, so defaulting to", "ipc.config.socketRoot + ipc.config.appspace + id", (this.config.socketRoot + this.config.appspace + id2).data);
      path2 = this.config.socketRoot + this.config.appspace + id2;
    }
    if (this.of[id2]) {
      if (!this.of[id2].socket.destroyed) {
        this.log("Already Connected to", id2, "- So executing success without connection");
        callback();
        return;
      }
      this.of[id2].socket.destroy();
    }
    this.of[id2] = new Client(this.config, this.log);
    this.of[id2].id = id2;
    this.of[id2].socket ? this.of[id2].socket.id = id2 : null;
    this.of[id2].path = path2;
    this.of[id2].connect();
    callback(this);
  }
  function connectNet(id2, host, port, callback) {
    if (!id2) {
      this.log("Service id required", "Requested service connection without specifying service id. Aborting connection attempt");
      return;
    }
    if (typeof host == "number") {
      callback = port;
      port = host;
      host = false;
    }
    if (typeof host == "function") {
      callback = host;
      host = false;
      port = false;
    }
    if (!host) {
      this.log("Server host not specified, so defaulting to", "ipc.config.networkHost", this.config.networkHost);
      host = this.config.networkHost;
    }
    if (typeof port == "function") {
      callback = port;
      port = false;
    }
    if (!port) {
      this.log("Server port not specified, so defaulting to", "ipc.config.networkPort", this.config.networkPort);
      port = this.config.networkPort;
    }
    if (typeof callback == "string") {
      UDPType = callback;
      callback = false;
    }
    if (!callback) {
      callback = emptyCallback;
    }
    if (this.of[id2]) {
      if (!this.of[id2].socket.destroyed) {
        this.log("Already Connected to", id2, "- So executing success without connection");
        callback();
        return;
      }
      this.of[id2].socket.destroy();
    }
    this.of[id2] = new Client(this.config, this.log);
    this.of[id2].id = id2;
    this.of[id2].socket ? this.of[id2].socket.id = id2 : null;
    this.of[id2].path = host;
    this.of[id2].port = port;
    this.of[id2].connect();
    callback(this);
  }
  class IPCModule extends IPC {
    constructor() {
      super();
      __publicField(this, "IPC", IPC);
    }
  }
  const singleton = new IPCModule();
  var nodeIpc = /* @__PURE__ */ Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", "default": singleton, IPCModule });
})();

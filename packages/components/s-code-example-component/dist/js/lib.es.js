import {define as define$1} from "@coffeekraken/s-clipboard-copy-component";
import __SLitComponent from "@coffeekraken/s-lit-component";
import {css as css$1, unsafeCSS, html} from "lit";
import __SInterface from "@coffeekraken/s-interface";
function plainObject(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge(...args) {
  function merge(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject(newObj[key]) && plainObject(secondObj[key])) {
        newObj[key] = merge(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge(currentObj, toMergeObj);
  }
  return currentObj;
}
function wait(timeout = 0) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, timeout);
  });
}
var deepFreezeEs6 = {exports: {}};
function deepFreeze(obj) {
  if (obj instanceof Map) {
    obj.clear = obj.delete = obj.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj instanceof Set) {
    obj.add = obj.clear = obj.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach(function(name) {
    var prop = obj[name];
    if (typeof prop == "object" && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj;
}
deepFreezeEs6.exports = deepFreeze;
deepFreezeEs6.exports.default = deepFreeze;
var deepFreeze$1 = deepFreezeEs6.exports;
class Response {
  constructor(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original, ...objects) {
  const result = Object.create(null);
  for (const key in original) {
    result[key] = original[key];
  }
  objects.forEach(function(obj) {
    for (const key in obj) {
      result[key] = obj[key];
    }
  });
  return result;
}
const SPAN_CLOSE = "</span>";
const emitsWrappingTags = (node) => {
  return !!node.kind;
};
const expandScopeName = (name, {prefix}) => {
  if (name.includes(".")) {
    const pieces = name.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
    ].join(" ");
  }
  return `${prefix}${name}`;
};
class HTMLRenderer {
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  addText(text) {
    this.buffer += escapeHTML(text);
  }
  openNode(node) {
    if (!emitsWrappingTags(node))
      return;
    let scope = node.kind;
    if (node.sublanguage) {
      scope = `language-${scope}`;
    } else {
      scope = expandScopeName(scope, {prefix: this.classPrefix});
    }
    this.span(scope);
  }
  closeNode(node) {
    if (!emitsWrappingTags(node))
      return;
    this.buffer += SPAN_CLOSE;
  }
  value() {
    return this.buffer;
  }
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}
class TokenTree {
  constructor() {
    this.rootNode = {children: []};
    this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(node) {
    this.top.children.push(node);
  }
  openNode(kind) {
    const node = {kind, children: []};
    this.add(node);
    this.stack.push(node);
  }
  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  }
  closeAllNodes() {
    while (this.closeNode())
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  }
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }
  static _collapse(node) {
    if (typeof node === "string")
      return;
    if (!node.children)
      return;
    if (node.children.every((el2) => typeof el2 === "string")) {
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}
class TokenTreeEmitter extends TokenTree {
  constructor(options) {
    super();
    this.options = options;
  }
  addKeyword(text, kind) {
    if (text === "") {
      return;
    }
    this.openNode(kind);
    this.addText(text);
    this.closeNode();
  }
  addText(text) {
    if (text === "") {
      return;
    }
    this.add(text);
  }
  addSublanguage(emitter, name) {
    const node = emitter.root;
    node.kind = name;
    node.sublanguage = true;
    this.add(node);
  }
  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }
  finalize() {
    return true;
  }
}
function source$4(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead$3(re2) {
  return concat$4("(?=", re2, ")");
}
function concat$4(...args) {
  const joined = args.map((x2) => source$4(x2)).join("");
  return joined;
}
function stripOptionsFromArgs$1(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either$1(...args) {
  const opts = stripOptionsFromArgs$1(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source$4(x2)).join("|") + ")";
  return joined;
}
function countMatchGroups(re2) {
  return new RegExp(re2.toString() + "|").exec("").length - 1;
}
function startsWith(re2, lexeme) {
  const match = re2 && re2.exec(lexeme);
  return match && match.index === 0;
}
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences(regexps, {joinWith}) {
  let numCaptures = 0;
  return regexps.map((regex) => {
    numCaptures += 1;
    const offset = numCaptures;
    let re2 = source$4(regex);
    let out = "";
    while (re2.length > 0) {
      const match = BACKREF_RE.exec(re2);
      if (!match) {
        out += re2;
        break;
      }
      out += re2.substring(0, match.index);
      re2 = re2.substring(match.index + match[0].length);
      if (match[0][0] === "\\" && match[1]) {
        out += "\\" + String(Number(match[1]) + offset);
      } else {
        out += match[0];
        if (match[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re2) => `(${re2})`).join(joinWith);
}
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE$1 = "[a-zA-Z]\\w*";
const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
const BINARY_NUMBER_RE = "\\b(0b[01]+)";
const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat$4(beginShebang, /.*\b/, opts.binary, /\b.*/);
  }
  return inherit$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    "on:begin": (m2, resp) => {
      if (m2.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
const BACKSLASH_ESCAPE = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
const APOS_STRING_MODE = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit$1({
    scope: "comment",
    begin,
    end,
    contains: []
  }, modeOptions);
  mode.contains.push({
    scope: "doctag",
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either$1("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
  mode.contains.push({
    begin: concat$4(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}")
  });
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT("//", "$");
const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
const HASH_COMMENT_MODE = COMMENT("#", "$");
const NUMBER_MODE = {
  scope: "number",
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  scope: "number",
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  scope: "number",
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const REGEXP_MODE = {
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  }]
};
const TITLE_MODE = {
  scope: "title",
  begin: IDENT_RE$1,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  scope: "title",
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
  relevance: 0
};
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(mode, {
    "on:begin": (m2, resp) => {
      resp.data._beginMatch = m2[1];
    },
    "on:end": (m2, resp) => {
      if (resp.data._beginMatch !== m2[1])
        resp.ignoreMatch();
    }
  });
};
var MODES$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE,
  IDENT_RE: IDENT_RE$1,
  UNDERSCORE_IDENT_RE,
  NUMBER_RE,
  C_NUMBER_RE,
  BINARY_NUMBER_RE,
  RE_STARTERS_RE,
  SHEBANG,
  BACKSLASH_ESCAPE,
  APOS_STRING_MODE,
  QUOTE_STRING_MODE,
  PHRASAL_WORDS_MODE,
  COMMENT,
  C_LINE_COMMENT_MODE,
  C_BLOCK_COMMENT_MODE,
  HASH_COMMENT_MODE,
  NUMBER_MODE,
  C_NUMBER_MODE,
  BINARY_NUMBER_MODE,
  REGEXP_MODE,
  TITLE_MODE,
  UNDERSCORE_TITLE_MODE,
  METHOD_GUARD,
  END_SAME_AS_BEGIN
});
function skipIfHasPrecedingDot(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either$1(...mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
const beforeMatchExt = (mode, parent) => {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key) => {
    delete mode[key];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat$4(originalMode.beforeMatch, lookahead$3(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [
      Object.assign(originalMode, {endsParent: true})
    ]
  };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
const COMMON_KEYWORDS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  "list",
  "value"
];
const DEFAULT_KEYWORD_SCOPE = "keyword";
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  const compiledKeywords = Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map((x2) => x2.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword) ? 0 : 1;
}
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}
const seenDeprecations = {};
const error = (message) => {
  console.error(message);
};
const warn = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};
const deprecated = (version2, message) => {
  if (seenDeprecations[`${version2}/${message}`])
    return;
  console.log(`Deprecated as of ${version2}. ${message}`);
  seenDeprecations[`${version2}/${message}`] = true;
};
const MultiClassError = new Error();
function remapScopeNames(mode, regexes, {key}) {
  let offset = 0;
  const scopeNames = mode[key];
  const emit = {};
  const positions = {};
  for (let i2 = 1; i2 <= regexes.length; i2++) {
    positions[i2 + offset] = scopeNames[i2];
    emit[i2 + offset] = true;
    offset += countMatchGroups(regexes[i2 - 1]);
  }
  mode[key] = positions;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, {key: "beginScope"});
  mode.begin = _rewriteBackreferences(mode.begin, {joinWith: ""});
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, {key: "endScope"});
  mode.end = _rewriteBackreferences(mode.end, {joinWith: ""});
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = {_wrap: mode.beginScope};
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = {_wrap: mode.endScope};
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language) {
  function langRe(value, global2) {
    return new RegExp(source$4(value), "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : ""));
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    addRule(re2, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re2]);
      this.matchAt += countMatchGroups(re2) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el2) => el2[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, {joinWith: "|"}), true);
      this.lastIndex = 0;
    }
    exec(s2) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s2);
      if (!match) {
        return null;
      }
      const i2 = match.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
      const matchData = this.matchIndexes[i2];
      match.splice(0, i2);
      return Object.assign(match, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    getMatcher(index) {
      if (this.multiRegexes[index])
        return this.multiRegexes[index];
      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re2, opts]) => matcher.addRule(re2, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(re2, opts) {
      this.rules.push([re2, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    exec(s2) {
      const m2 = this.getMatcher(this.regexIndex);
      m2.lastIndex = this.lastIndex;
      let result = m2.exec(s2);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          const m22 = this.getMatcher(0);
          m22.lastIndex = this.lastIndex + 1;
          result = m22.exec(s2);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    }
  }
  function buildModeRegex(mode) {
    const mm2 = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm2.addRule(term.begin, {rule: term, type: "begin"}));
    if (mode.terminatorEnd) {
      mm2.addRule(mode.terminatorEnd, {type: "end"});
    }
    if (mode.illegal) {
      mm2.addRule(mode.illegal, {type: "illegal"});
    }
    return mm2;
  }
  function compileMode(mode, parent) {
    const cmode = mode;
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach((ext) => ext(mode, parent));
    language.compilerExtensions.forEach((ext) => ext(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords,
      compileIllegal,
      compileRelevance
    ].forEach((ext) => ext(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(mode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(mode.end);
      cmode.terminatorEnd = source$4(mode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(mode.illegal);
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c2) {
      return expandOrCloneMode(c2 === "self" ? mode : c2);
    }));
    mode.contains.forEach(function(c2) {
      compileMode(c2, cmode);
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1(language.classNameAliases || {});
  return compileMode(language);
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, {variants: null}, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, {starts: mode.starts ? inherit$1(mode.starts) : null});
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
var version = "11.1.0";
const escape = escapeHTML;
const inherit = inherit$1;
const NO_MATCH = Symbol("nomatch");
const MAX_KEYWORD_HITS = 7;
const HLJS = function(hljs) {
  const languages = Object.create(null);
  const aliases = Object.create(null);
  const plugins = [];
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  const PLAINTEXT_LANGUAGE = {disableAutodetect: true, name: "Plain text", contains: []};
  let options = {
    ignoreUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    __emitter: TokenTreeEmitter
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    let classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    const match = options.languageDetectRe.exec(classes);
    if (match) {
      const language = getLanguage(match[1]);
      if (!language) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match[1] : "no-highlight";
    }
    return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    const context = {
      code,
      language: languageName
    };
    fire("before:highlight", context);
    const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result.code = context.code;
    fire("after:highlight", result);
    return result;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";
      while (match) {
        buf += modeBuffer.substring(lastIndex, match.index);
        const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
        const data = keywordData(top, word);
        if (data) {
          const [kind, keywordRelevance] = data;
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match[0];
          } else {
            const cssClass = language.classNameAliases[kind] || kind;
            emitter.addKeyword(match[0], cssClass);
          }
        } else {
          buf += match[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substr(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      let result2 = null;
      if (typeof top.subLanguage === "string") {
        if (!languages[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = result2._top;
      } else {
        result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }
      if (top.relevance > 0) {
        relevance += result2.relevance;
      }
      emitter.addSublanguage(result2._emitter, result2.language);
    }
    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitMultiClass(scope, match) {
      let i2 = 1;
      while (match[i2] !== void 0) {
        if (!scope._emit[i2]) {
          i2++;
          continue;
        }
        const klass = language.classNameAliases[scope[i2]] || scope[i2];
        const text = match[i2];
        if (klass) {
          emitter.addKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i2++;
      }
    }
    function startNewMode(mode, match) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match);
          modeBuffer = "";
        }
      }
      top = Object.create(mode, {parent: {value: top}});
      return top;
    }
    function endOfMode(mode, match, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response(mode);
          mode["on:end"](match, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match) {
      const lexeme = match[0];
      const newMode = match.rule;
      const resp = new Response(newMode);
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb2 of beforeCallbacks) {
        if (!cb2)
          continue;
        cb2(match, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match) {
      const lexeme = match[0];
      const matchPlusRemainder = codeToHighlight.substr(match.index);
      const endMode = endOfMode(top, match, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH;
      }
      const origin = top;
      if (top.endScope && top.endScope._wrap) {
        processBuffer();
        emitter.addKeyword(lexeme, top.endScope._wrap);
      } else if (top.endScope && top.endScope._multi) {
        processBuffer();
        emitMultiClass(top.endScope, match);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.scope && !top.isMultiClass) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      const list = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.scope) {
          list.unshift(current.scope);
        }
      }
      list.forEach((item) => emitter.openNode(item));
    }
    let lastMatch = {};
    function processLexeme(textBeforeMatch, match) {
      const lexeme = match && match[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
        if (!SAFE_MODE) {
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match;
      if (match.type === "begin") {
        return doBeginMatch(match);
      } else if (match.type === "illegal" && !ignoreIllegals) {
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
        err.mode = top;
        throw err;
      } else if (match.type === "end") {
        const processed = doEndMatch(match);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }
      if (match.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match.index * 3) {
        const err = new Error("potential infinite loop, way more iterations than matches");
        throw err;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    const language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    const md2 = compileLanguage(language);
    let result = "";
    let top = continuation || md2;
    const continuations = {};
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = "";
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;
    try {
      top.matcher.considerAll();
      for (; ; ) {
        iterations++;
        if (resumeScanAtSamePosition) {
          resumeScanAtSamePosition = false;
        } else {
          top.matcher.considerAll();
        }
        top.matcher.lastIndex = index;
        const match = top.matcher.exec(codeToHighlight);
        if (!match)
          break;
        const beforeMatch = codeToHighlight.substring(index, match.index);
        const processedCount = processLexeme(beforeMatch, match);
        index = match.index + processedCount;
      }
      processLexeme(codeToHighlight.substr(index));
      emitter.closeAllNodes();
      emitter.finalize();
      result = emitter.toHTML();
      return {
        language: languageName,
        value: result,
        relevance,
        illegal: false,
        _emitter: emitter,
        _top: top
      };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return {
          language: languageName,
          value: escape(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode,
            resultSoFar: result
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top
        };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code) {
    const result = {
      value: escape(code),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result._emitter.addText(code);
    return result;
  }
  function highlightAuto(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext = justTextHighlightResult(code);
    const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name) => _highlight(name, code, false));
    results.unshift(plaintext);
    const sorted = results.sort((a2, b2) => {
      if (a2.relevance !== b2.relevance)
        return b2.relevance - a2.relevance;
      if (a2.language && b2.language) {
        if (getLanguage(a2.language).supersetOf === b2.language) {
          return 1;
        } else if (getLanguage(b2.language).supersetOf === a2.language) {
          return -1;
        }
      }
      return 0;
    });
    const [best, secondBest] = sorted;
    const result = best;
    result.secondBest = secondBest;
    return result;
  }
  function updateClassName(element, currentLang, resultLang) {
    const language = currentLang && aliases[currentLang] || resultLang;
    element.classList.add("hljs");
    element.classList.add(`language-${language}`);
  }
  function highlightElement(element) {
    let node = null;
    const language = blockLanguage(element);
    if (shouldNotHighlight(language))
      return;
    fire("before:highlightElement", {el: element, language});
    if (!options.ignoreUnescapedHTML && element.children.length > 0) {
      console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
      console.warn("https://github.com/highlightjs/highlight.js/issues/2886");
      console.warn(element);
    }
    node = element;
    const text = node.textContent;
    const result = language ? highlight2(text, {language, ignoreIllegals: true}) : highlightAuto(text);
    element.innerHTML = result.value;
    updateClassName(element, language, result.language);
    element.result = {
      language: result.language,
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element.secondBest = {
        language: result.secondBest.language,
        relevance: result.secondBest.relevance
      };
    }
    fire("after:highlightElement", {el: element, result, text});
  }
  function configure(userOptions) {
    options = inherit(options, userOptions);
  }
  const initHighlighting = () => {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    const blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$1;
      } else {
        error(error$1);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, {languageName});
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages() {
    return Object.keys(languages);
  }
  function getLanguage(name) {
    name = (name || "").toLowerCase();
    return languages[name] || languages[aliases[name]];
  }
  function registerAliases(aliasList, {languageName}) {
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach((alias) => {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name) {
    const lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data) => {
        plugin["before:highlightBlock"](Object.assign({block: data.el}, data));
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data) => {
        plugin["after:highlightBlock"](Object.assign({block: data.el}, data));
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function fire(event, args) {
    const cb2 = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb2]) {
        plugin[cb2](args);
      }
    });
  }
  function deprecateHighlightBlock(el2) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");
    return highlightElement(el2);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto,
    highlightAll,
    highlightElement,
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version;
  for (const key in MODES$1) {
    if (typeof MODES$1[key] === "object") {
      deepFreeze$1(MODES$1[key]);
    }
  }
  Object.assign(hljs, MODES$1);
  return hljs;
};
var highlight = HLJS({});
var core = highlight;
function source$3(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function concat$3(...args) {
  const joined = args.map((x2) => source$3(x2)).join("");
  return joined;
}
function bash(hljs) {
  const VAR = {};
  const BRACED_VAR = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [VAR]
      }
    ]
  };
  Object.assign(VAR, {
    className: "variable",
    variants: [
      {begin: concat$3(/\$[\w\d#@][\w\d_]*/, `(?![\\w\\d])(?![$])`)},
      BRACED_VAR
    ]
  });
  const SUBST = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  const HERE_DOC = {
    begin: /<<-?\s*(?=\w+)/,
    starts: {
      contains: [
        hljs.END_SAME_AS_BEGIN({
          begin: /(\w+)/,
          end: /(\w+)/,
          className: "string"
        })
      ]
    }
  };
  const QUOTE_STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      hljs.BACKSLASH_ESCAPE,
      VAR,
      SUBST
    ]
  };
  SUBST.contains.push(QUOTE_STRING);
  const ESCAPED_QUOTE = {
    className: "",
    begin: /\\"/
  };
  const APOS_STRING = {
    className: "string",
    begin: /'/,
    end: /'/
  };
  const ARITHMETIC = {
    begin: /\$\(\(/,
    end: /\)\)/,
    contains: [
      {begin: /\d+#[0-9a-f]+/, className: "number"},
      hljs.NUMBER_MODE,
      VAR
    ]
  };
  const SH_LIKE_SHELLS = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ];
  const KNOWN_SHEBANG = hljs.SHEBANG({
    binary: `(${SH_LIKE_SHELLS.join("|")})`,
    relevance: 10
  });
  const FUNCTION = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: true,
    contains: [hljs.inherit(hljs.TITLE_MODE, {begin: /\w[\w\d_]*/})],
    relevance: 0
  };
  const KEYWORDS2 = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function"
  ];
  const LITERALS2 = [
    "true",
    "false"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z._-]+\b/,
      keyword: KEYWORDS2,
      literal: LITERALS2,
      built_in: "break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp"
    },
    contains: [
      KNOWN_SHEBANG,
      hljs.SHEBANG(),
      FUNCTION,
      ARITHMETIC,
      hljs.HASH_COMMENT_MODE,
      HERE_DOC,
      QUOTE_STRING,
      ESCAPED_QUOTE,
      APOS_STRING,
      VAR
    ]
  };
}
const MODES = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    HEXCOLOR: {
      scope: "number",
      begin: "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z][A-Za-z0-9_-]*/
    }
  };
};
const TAGS = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  "host",
  "host-context",
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  "nth-child",
  "nth-col",
  "nth-last-child",
  "nth-last-col",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
];
const PSEUDO_ELEMENTS = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES = [
  "align-content",
  "align-items",
  "align-self",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "auto",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "border",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "clear",
  "clip",
  "clip-path",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "content",
  "counter-increment",
  "counter-reset",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-variant-ligatures",
  "font-variation-settings",
  "font-weight",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inherit",
  "initial",
  "justify-content",
  "left",
  "letter-spacing",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-bottom",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "max-height",
  "max-width",
  "min-height",
  "min-width",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "right",
  "src",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-last",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-indent",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "white-space",
  "widows",
  "width",
  "word-break",
  "word-spacing",
  "word-wrap",
  "z-index"
].reverse();
function source$2(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead$2(re2) {
  return concat$2("(?=", re2, ")");
}
function concat$2(...args) {
  const joined = args.map((x2) => source$2(x2)).join("");
  return joined;
}
function css(hljs) {
  const modes = MODES(hljs);
  const FUNCTION_DISPATCH = {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  };
  const VENDOR_PREFIX = {
    begin: /-(webkit|moz|ms|o)-(?=[a-z])/
  };
  const AT_MODIFIERS = "and or not only";
  const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
  const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  const STRINGS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: true,
    illegal: /[=|'\$]/,
    keywords: {
      keyframePosition: "from to"
    },
    classNameAliases: {
      keyframePosition: "selector-tag"
    },
    contains: [
      hljs.C_BLOCK_COMMENT_MODE,
      VENDOR_PREFIX,
      modes.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + IDENT_RE2,
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          {
            begin: ":(" + PSEUDO_CLASSES.join("|") + ")"
          },
          {
            begin: "::(" + PSEUDO_ELEMENTS.join("|") + ")"
          }
        ]
      },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
      },
      {
        begin: ":",
        end: "[;}]",
        contains: [
          modes.HEXCOLOR,
          modes.IMPORTANT,
          modes.CSS_NUMBER_MODE,
          ...STRINGS,
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            keywords: {
              built_in: "url data-uri"
            },
            contains: [
              {
                className: "string",
                begin: /[^)]/,
                endsWithParent: true,
                excludeEnd: true
              }
            ]
          },
          FUNCTION_DISPATCH
        ]
      },
      {
        begin: lookahead$2(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        contains: [
          {
            className: "keyword",
            begin: AT_PROPERTY_RE
          },
          {
            begin: /\s/,
            endsWithParent: true,
            excludeEnd: true,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...STRINGS,
              modes.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS.join("|") + ")\\b"
      }
    ]
  };
}
const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS = [
  "as",
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
const TYPES = [
  "Intl",
  "DataView",
  "Number",
  "Math",
  "Date",
  "String",
  "RegExp",
  "Object",
  "Function",
  "Boolean",
  "Error",
  "Symbol",
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  "Proxy",
  "Reflect",
  "JSON",
  "Promise",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Float32Array",
  "Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "ArrayBuffer",
  "BigInt64Array",
  "BigUint64Array",
  "BigInt"
];
const ERROR_TYPES = [
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global"
];
const BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
function source$1(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead$1(re2) {
  return concat$1("(?=", re2, ")");
}
function concat$1(...args) {
  const joined = args.map((x2) => source$1(x2)).join("");
  return joined;
}
function javascript(hljs) {
  const hasClosingTag = (match, {after}) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$12 = IDENT_RE;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (nextChar === "<") {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, {after: afterMatchIndex})) {
          response.ignoreMatch();
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits = "[0-9](_?[0-9])*";
  const frac = `\\.(${decimalDigits})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      {begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b`},
      {begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b`},
      {begin: `\\b(0|[1-9](_?[0-9])*)n\\b`},
      {begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},
      {begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"},
      {begin: "\\b0[oO][0-7](_?[0-7])*n?\\b"},
      {begin: "\\b0[0-7]+n?\\b"}
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1,
    contains: []
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
    relevance: 0,
    contains: [
      {
        begin: "(?=@[A-Za-z]+)",
        relevance: 0,
        contains: [
          {
            className: "doctag",
            begin: "@[A-Za-z]+"
          },
          {
            className: "type",
            begin: "\\{",
            end: "\\}",
            excludeEnd: true,
            excludeBegin: true,
            relevance: 0
          },
          {
            className: "variable",
            begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
            endsParent: true,
            relevance: 0
          },
          {
            begin: /(?=[^\n])\s/,
            relevance: 0
          }
        ]
      }
    ]
  });
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    TEMPLATE_STRING,
    NUMBER,
    hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        match: [
          /extends/,
          /\s+/,
          concat$1(IDENT_RE$12, "(", concat$1(/\./, IDENT_RE$12), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class.inherited"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: /\b[A-Z][a-z]+([A-Z][a-z]+)*/,
    className: "title.class",
    keywords: {
      _: [
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$12,
          /(?=\s*\()/
        ]
      },
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return concat$1("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: concat$1(/\b/, noneOf([
      ...BUILT_IN_GLOBALS,
      "super"
    ]), IDENT_RE$12, lookahead$1(/\(/)),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: concat$1(/\./, lookahead$1(concat$1(IDENT_RE$12, /(?![0-9A-Za-z$_(])/))),
    end: IDENT_RE$12,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$12,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$12,
      /\s*/,
      /=\s*/,
      lookahead$1(FUNC_LEAD_IN_RE)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "Javascript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1,
    exports: {PARAMS_CONTAINS},
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$12 + lookahead$1(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            variants: [
              {begin: FRAGMENT.begin, end: FRAGMENT.end},
              {
                begin: XML_TAG.begin,
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        beginKeywords: "while if switch catch for"
      },
      {
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, {begin: IDENT_RE$12, className: "title.function"})
        ]
      },
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      {
        match: "\\$" + IDENT_RE$12,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: {1: "title.function"},
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
      }
    ]
  };
}
function php(hljs) {
  const VARIABLE = {
    className: "variable",
    begin: `\\$+[a-zA-Z_\x7F-\xFF][a-zA-Z0-9_\x7F-\xFF]*(?![A-Za-z0-9])(?![$])`
  };
  const PREPROCESSOR = {
    className: "meta",
    variants: [
      {begin: /<\?php/, relevance: 10},
      {begin: /<\?[=]?/},
      {begin: /\?>/}
    ]
  };
  const SUBST = {
    className: "subst",
    variants: [
      {begin: /\$\w+/},
      {begin: /\{\$/, end: /\}/}
    ]
  };
  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
    illegal: null
  });
  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    illegal: null,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const HEREDOC = hljs.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*(\w+)\n/,
    end: /[ \t]*(\w+)\b/,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const STRING = {
    className: "string",
    contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
    variants: [
      hljs.inherit(SINGLE_QUOTED, {
        begin: "b'",
        end: "'"
      }),
      hljs.inherit(DOUBLE_QUOTED, {
        begin: 'b"',
        end: '"'
      }),
      DOUBLE_QUOTED,
      SINGLE_QUOTED,
      HEREDOC
    ]
  };
  const NUMBER = {
    className: "number",
    variants: [
      {begin: `\\b0b[01]+(?:_[01]+)*\\b`},
      {begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b`},
      {begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b`},
      {begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?`}
    ],
    relevance: 0
  };
  const KEYWORDS2 = {
    keyword: "__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ die echo exit include include_once print require require_once array abstract and as binary bool boolean break callable case catch class clone const continue declare default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends final finally float for foreach from global goto if implements instanceof insteadof int integer interface isset iterable list match|0 mixed new object or private protected public real return string switch throw trait try unset use var void while xor yield",
    literal: "false null true",
    built_in: "Error|0 AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass"
  };
  return {
    case_insensitive: true,
    keywords: KEYWORDS2,
    contains: [
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT("//", "$", {contains: [PREPROCESSOR]}),
      hljs.COMMENT("/\\*", "\\*/", {
        contains: [
          {
            className: "doctag",
            begin: "@[A-Za-z]+"
          }
        ]
      }),
      hljs.COMMENT("__halt_compiler.+?;", false, {
        endsWithParent: true,
        keywords: "__halt_compiler"
      }),
      PREPROCESSOR,
      {
        className: "keyword",
        begin: /\$this\b/
      },
      VARIABLE,
      {
        begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
      },
      {
        className: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: true,
        illegal: "[$%\\[]",
        contains: [
          {
            beginKeywords: "use"
          },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            endsParent: true
          },
          {
            className: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS2,
            contains: [
              "self",
              VARIABLE,
              hljs.C_BLOCK_COMMENT_MODE,
              STRING,
              NUMBER
            ]
          }
        ]
      },
      {
        className: "class",
        variants: [
          {beginKeywords: "enum", illegal: /[($"]/},
          {beginKeywords: "class interface trait", illegal: /[:($"]/}
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: true,
        contains: [
          {beginKeywords: "extends implements"},
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      STRING,
      NUMBER
    ]
  };
}
function source(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead(re2) {
  return concat("(?=", re2, ")");
}
function optional(re2) {
  return concat("(?:", re2, ")?");
}
function concat(...args) {
  const joined = args.map((x2) => source(x2)).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either(...args) {
  const opts = stripOptionsFromArgs(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source(x2)).join("|") + ")";
  return joined;
}
function xml(hljs) {
  const TAG_NAME_RE = concat(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
  const XML_ENTITIES = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
    className: "string"
  });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    className: "string"
  });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /[^\s"'=<>`]+/
              }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(/<!--/, /-->/, {
        relevance: 10
      }),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      {
        className: "meta",
        begin: /<\?xml/,
        end: /\?>/,
        relevance: 10
      },
      {
        className: "tag",
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: {
          name: "style"
        },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: {
          name: "script"
        },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      {
        className: "tag",
        begin: concat(/</, lookahead(concat(TAG_NAME_RE, either(/\/>/, />/, /\s/)))),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      {
        className: "tag",
        begin: concat(/<\//, lookahead(concat(TAG_NAME_RE, />/))),
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
const standardProperty = (options, element) => {
  if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
    return {
      ...element,
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      originalKey: element.key,
      initializer() {
        if (typeof element.initializer === "function") {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  }
};
const legacyProperty = (options, proto, name) => {
  proto.constructor.createProperty(name, options);
};
function property(options) {
  return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
const decorateProperty = ({finisher, descriptor}) => (protoOrDescriptor, name) => {
  var _a2;
  if (name !== void 0) {
    const ctor = protoOrDescriptor.constructor;
    if (descriptor !== void 0) {
      Object.defineProperty(protoOrDescriptor, name, descriptor(name));
    }
    finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);
  } else {
    const key = (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
    const info = descriptor != void 0 ? {
      kind: "method",
      placement: "prototype",
      key,
      descriptor: descriptor(protoOrDescriptor.key)
    } : {...protoOrDescriptor, key};
    if (finisher != void 0) {
      info.finisher = function(ctor) {
        finisher(ctor, key);
      };
    }
    return info;
  }
};
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
function query(selector, cache) {
  return decorateProperty({
    descriptor: (name) => {
      const descriptor = {
        get() {
          var _a2;
          return (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector);
        },
        enumerable: true,
        configurable: true
      };
      if (cache) {
        const key = typeof name === "symbol" ? Symbol() : `__${name}`;
        descriptor.get = function() {
          var _a2;
          if (this[key] === void 0) {
            this[key] = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector);
          }
          return this[key];
        };
      }
      return descriptor;
    }
  });
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
const ElementProto = Element.prototype;
const legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
function queryAssignedNodes(slotName = "", flatten = false, selector = "") {
  return decorateProperty({
    descriptor: (_name) => ({
      get() {
        var _a2, _b2;
        const slotSelector = `slot${slotName ? `[name=${slotName}]` : ":not([name])"}`;
        const slot = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(slotSelector);
        let nodes = (_b2 = slot) === null || _b2 === void 0 ? void 0 : _b2.assignedNodes({flatten});
        if (nodes && selector) {
          nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && (node.matches ? node.matches(selector) : legacyMatches.call(node, selector)));
        }
        return nodes;
      },
      enumerable: true,
      configurable: true
    })
  });
}
function decodeHtmlEntities(string) {
  const txt = document.createElement("textarea");
  txt.innerHTML = string;
  return txt.value;
}
var __css = ".hljs {\n    display: block;\n    overflow: hidden;\n    padding: var(--s-theme-ui-code-paddingBlock, 3rem) var(--s-theme-ui-code-paddingInline, 3rem);\n    background-color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    line-height: 1.5 !important;\n}\n\n    .hljs,\n    .hljs.hljs-subst {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    }\n\n    .hljs .hljs-selector-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-selector-id {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n        font-weight: bold;\n    }\n\n    .hljs .hljs-selector-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-pseudo {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-addition {\n        background-color: rgba(163, 190, 140, 0.5);\n    }\n\n    .hljs .hljs-deletion {\n        background-color: rgba(191, 97, 106, 0.5);\n    }\n\n    .hljs .hljs-built_in,\n    .hljs .hljs-type {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-function {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-function > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-keyword,\n    .hljs .hljs-literal,\n    .hljs .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-number {\n        color: #B48EAD;\n    }\n\n    .hljs .hljs-regexp {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-params {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-bullet {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-code {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-emphasis {\n        font-style: italic;\n    }\n\n    .hljs .hljs-formula {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-strong {\n        font-weight: bold;\n    }\n\n    .hljs .hljs-link:hover {\n        text-decoration: underline;\n    }\n\n    .hljs .hljs-quote {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-comment {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-doctag {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-meta,\n    .hljs .hljs-meta-keyword {\n        color: #5E81AC;\n    }\n\n    .hljs .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-30-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-30-lightness-offset, 0)) * 1%),var(--s-theme-color-text-30-a, 1));\n    }\n\n    .hljs .hljs-builtin-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-section {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-tag {\n        color: #5E81AC;\n    }\n\n    .hljs.abnf .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.abnf .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.apache .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.apache .hljs-section {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs.arduino .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.aspectj .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.aspectj > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs.bnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.clojure .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.clojure .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.coq .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.cpp .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.css .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.css .hljs-keyword {\n        color: #D08770;\n    }\n\n    .hljs.diff .hljs-meta {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.ebnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.glsl .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.groovy .hljs-meta:not(:first-child) {\n        color: #D08770;\n    }\n\n    .hljs.haxe .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.java .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.ldif .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.lisp .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.lua .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.moonscript .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-section {\n        color: #5E81AC;\n    }\n\n    .hljs.pf .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.processing .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.scss .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs.stylus .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs.swift .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.vim .hljs-built_in {\n        color: #88C0D0;\n        font-style: italic;\n    }\n\n    .hljs.yaml .hljs-meta {\n        color: #D08770;\n    }\n\n:host {\n    display: block;\n}\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: block;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example__slot {\n    display: none;\n}\n\n.s-code-example__nav {\n    position: relative;\n}\n\n.s-code-example__tabs {\n    display: flex;\n    list-style: none;\n}\n.s-code-example__tab {\n}\n\n.s-code-example__content {\n    position: relative;\n    --paddingBlock: var(--s-theme-ui-code-paddingBlock, 3rem);\n    overflow: hidden;\n}\n\n.s-code-example[lines] .s-code-example__content {\n        max-height: calc(1.5em * var(--max-lines) + (var(--paddingBlock) * 2));\n    }\n\n.s-code-example--more .s-code-example__content {\n        max-height: 99999px !important;\n    }\n[default-style] .s-code-example__content {\n    transition: var(--s-theme-ui-code-transition, 0);\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);box-shadow: var(--s-theme-ui-code-depth, 0);\n}\n\n.s-code-example__more-bar {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 50%;\n    width: 100%;\n    opacity: 0;\n    pointer-events: none;\n    display: flex;\n    align-items: flex-end;\n}\n\n.s-code-example[lines] .s-code-example__more-bar {\n        opacity: 1;\n        pointer-events: all;\n    }\n[default-style] .s-code-example__more-bar {\n    text-align: center;\n    padding-inline: var(--s-theme-ui-default-paddingInline, 1.5em);\n    padding-block: var(--s-theme-ui-default-paddingBlock, 0.75em);\n    justify-content: center;\n}\n[default-style] .s-code-example__more-bar:before {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;background: linear-gradient(0deg, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1)) 0%, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-lightness-offset, 0)) * 1%),0) 100%);\n    }\n\n.s-code-example__code {\n    display: none;\n    line-height: 0;\n}\n\n.s-code-example__code[active] {\n        display: block;\n    }\n\n.s-code-example__code > code {\n        line-height: 1;\n    }\n\n.s-code-example__toolbar {\n    position: absolute;\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n    z-index: 10;\n}\n\n.s-code-example__toolbar > * {\n        font-size: 20px;\n        opacity: 0.5;\n    }\n\n.s-code-example__toolbar > *:hover {\n            opacity: 1;\n        }\n\n[toolbar-position='nav'] .s-code-example__toolbar {\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n    /* transform: translate(0, -50%); */\n}\n";
class SCodeExampleInterface extends __SInterface {
}
SCodeExampleInterface.definition = {
  theme: {
    type: "String",
    default: "https://gitcdn.link/repo/PrismJS/prism-themes/master/themes/prism-nord.css"
  },
  active: {
    type: "String"
  },
  toolbar: {
    type: "Array<String>",
    values: ["copy"],
    default: ["copy"]
  },
  toolbarPosition: {
    type: "String",
    values: ["content", "nav"],
    default: "nav"
  },
  languages: {
    type: "Object",
    default: {}
  },
  lines: {
    type: "Number"
  },
  moreLabel: {
    type: "String",
    default: "Show more"
  },
  lessLabel: {
    type: "String",
    default: "Show less"
  },
  moreAction: {
    type: "String",
    default: "toggle"
  },
  more: {
    type: "Boolean",
    default: false
  }
};
var e$3 = {version: "2.4.1"}, t$3 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function n$3(e20) {
  return e20 && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
}
function r$3(e20) {
  var t2 = {exports: {}};
  return e20(t2, t2.exports), t2.exports;
}
var i$3 = r$3(function(e20, t2) {
  function n2() {
  }
  function r2(e21, t3, n3, r3, i3) {
    for (var u2 = 0, o2 = t3.length, s2 = 0, a2 = 0; u2 < o2; u2++) {
      var c2 = t3[u2];
      if (c2.removed) {
        if (c2.value = e21.join(r3.slice(a2, a2 + c2.count)), a2 += c2.count, u2 && t3[u2 - 1].added) {
          var l2 = t3[u2 - 1];
          t3[u2 - 1] = t3[u2], t3[u2] = l2;
        }
      } else {
        if (!c2.added && i3) {
          var p2 = n3.slice(s2, s2 + c2.count);
          p2 = p2.map(function(e22, t4) {
            var n4 = r3[a2 + t4];
            return n4.length > e22.length ? n4 : e22;
          }), c2.value = e21.join(p2);
        } else
          c2.value = e21.join(n3.slice(s2, s2 + c2.count));
        s2 += c2.count, c2.added || (a2 += c2.count);
      }
    }
    var f2 = t3[o2 - 1];
    return o2 > 1 && typeof f2.value == "string" && (f2.added || f2.removed) && e21.equals("", f2.value) && (t3[o2 - 2].value += f2.value, t3.pop()), t3;
  }
  function i2(e21) {
    return {newPos: e21.newPos, components: e21.components.slice(0)};
  }
  Object.defineProperty(t2, "__esModule", {value: true}), t2.default = n2, n2.prototype = {diff: function(e21, t3) {
    var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u2 = n3.callback;
    typeof n3 == "function" && (u2 = n3, n3 = {}), this.options = n3;
    var o2 = this;
    function s2(e22) {
      return u2 ? (setTimeout(function() {
        u2(void 0, e22);
      }, 0), true) : e22;
    }
    e21 = this.castInput(e21), t3 = this.castInput(t3), e21 = this.removeEmpty(this.tokenize(e21));
    var a2 = (t3 = this.removeEmpty(this.tokenize(t3))).length, c2 = e21.length, l2 = 1, p2 = a2 + c2, f2 = [{newPos: -1, components: []}], d2 = this.extractCommon(f2[0], t3, e21, 0);
    if (f2[0].newPos + 1 >= a2 && d2 + 1 >= c2)
      return s2([{value: this.join(t3), count: t3.length}]);
    function h2() {
      for (var n4 = -1 * l2; n4 <= l2; n4 += 2) {
        var u3 = void 0, p3 = f2[n4 - 1], d3 = f2[n4 + 1], h3 = (d3 ? d3.newPos : 0) - n4;
        p3 && (f2[n4 - 1] = void 0);
        var g3 = p3 && p3.newPos + 1 < a2, m2 = d3 && 0 <= h3 && h3 < c2;
        if (g3 || m2) {
          if (!g3 || m2 && p3.newPos < d3.newPos ? (u3 = i2(d3), o2.pushComponent(u3.components, void 0, true)) : ((u3 = p3).newPos++, o2.pushComponent(u3.components, true, void 0)), h3 = o2.extractCommon(u3, t3, e21, n4), u3.newPos + 1 >= a2 && h3 + 1 >= c2)
            return s2(r2(o2, u3.components, t3, e21, o2.useLongestToken));
          f2[n4] = u3;
        } else
          f2[n4] = void 0;
      }
      l2++;
    }
    if (u2)
      !function e22() {
        setTimeout(function() {
          if (l2 > p2)
            return u2();
          h2() || e22();
        }, 0);
      }();
    else
      for (; l2 <= p2; ) {
        var g2 = h2();
        if (g2)
          return g2;
      }
  }, pushComponent: function(e21, t3, n3) {
    var r3 = e21[e21.length - 1];
    r3 && r3.added === t3 && r3.removed === n3 ? e21[e21.length - 1] = {count: r3.count + 1, added: t3, removed: n3} : e21.push({count: 1, added: t3, removed: n3});
  }, extractCommon: function(e21, t3, n3, r3) {
    for (var i3 = t3.length, u2 = n3.length, o2 = e21.newPos, s2 = o2 - r3, a2 = 0; o2 + 1 < i3 && s2 + 1 < u2 && this.equals(t3[o2 + 1], n3[s2 + 1]); )
      o2++, s2++, a2++;
    return a2 && e21.components.push({count: a2}), e21.newPos = o2, s2;
  }, equals: function(e21, t3) {
    return this.options.comparator ? this.options.comparator(e21, t3) : e21 === t3 || this.options.ignoreCase && e21.toLowerCase() === t3.toLowerCase();
  }, removeEmpty: function(e21) {
    for (var t3 = [], n3 = 0; n3 < e21.length; n3++)
      e21[n3] && t3.push(e21[n3]);
    return t3;
  }, castInput: function(e21) {
    return e21;
  }, tokenize: function(e21) {
    return e21.split("");
  }, join: function(e21) {
    return e21.join("");
  }};
}), u$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", {value: true}), t2.diffChars = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.characterDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
  t2.characterDiff = r2;
}), o$3 = function(e20, t2) {
  if (typeof e20 == "function")
    t2.callback = e20;
  else if (e20)
    for (var n2 in e20)
      e20.hasOwnProperty(n2) && (t2[n2] = e20[n2]);
  return t2;
};
var s$3, a$3, c$3 = Object.defineProperty({generateOptions: o$3}, "__esModule", {value: true}), l$3 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), t2.diffWords = function(e21, t3, n3) {
    return n3 = (0, c$3.generateOptions)(n3, {ignoreWhitespace: true}), s2.diff(e21, t3, n3);
  }, t2.diffWordsWithSpace = function(e21, t3, n3) {
    return s2.diff(e21, t3, n3);
  }, t2.wordDiff = void 0;
  var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : {default: n2};
  var u2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, o2 = /\S/, s2 = new r2.default();
  t2.wordDiff = s2, s2.equals = function(e21, t3) {
    return this.options.ignoreCase && (e21 = e21.toLowerCase(), t3 = t3.toLowerCase()), e21 === t3 || this.options.ignoreWhitespace && !o2.test(e21) && !o2.test(t3);
  }, s2.tokenize = function(e21) {
    for (var t3 = e21.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n3 = 0; n3 < t3.length - 1; n3++)
      !t3[n3 + 1] && t3[n3 + 2] && u2.test(t3[n3]) && u2.test(t3[n3 + 2]) && (t3[n3] += t3[n3 + 2], t3.splice(n3 + 1, 2), n3--);
    return t3;
  };
}), p$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", {value: true}), t2.diffLines = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.diffTrimmedLines = function(e21, t3, n3) {
    var i2 = (0, c$3.generateOptions)(n3, {ignoreWhitespace: true});
    return r2.diff(e21, t3, i2);
  }, t2.lineDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
  t2.lineDiff = r2, r2.tokenize = function(e21) {
    var t3 = [], n3 = e21.split(/(\n|\r\n)/);
    n3[n3.length - 1] || n3.pop();
    for (var r3 = 0; r3 < n3.length; r3++) {
      var i2 = n3[r3];
      r3 % 2 && !this.options.newlineIsToken ? t3[t3.length - 1] += i2 : (this.options.ignoreWhitespace && (i2 = i2.trim()), t3.push(i2));
    }
    return t3;
  };
}), f$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", {value: true}), t2.diffSentences = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.sentenceDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
  t2.sentenceDiff = r2, r2.tokenize = function(e21) {
    return e21.split(/(\S.+?[.!?])(?=\s+|$)/);
  };
}), d$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", {value: true}), t2.diffCss = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.cssDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
  t2.cssDiff = r2, r2.tokenize = function(e21) {
    return e21.split(/([{}:;,]|\s+)/);
  };
}), h$3 = function(e20) {
  return e20 && e20.Math == Math && e20;
}, g$3 = h$3(typeof globalThis == "object" && globalThis) || h$3(typeof window == "object" && window) || h$3(typeof self == "object" && self) || h$3(typeof t$3 == "object" && t$3) || function() {
  return this;
}() || Function("return this")(), m$3 = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, y$3 = !m$3(function() {
  return Object.defineProperty({}, 1, {get: function() {
    return 7;
  }})[1] != 7;
}), D$3 = {}.propertyIsEnumerable, E$3 = Object.getOwnPropertyDescriptor, C$3 = {f: E$3 && !D$3.call({1: 2}, 1) ? function(e20) {
  var t2 = E$3(this, e20);
  return !!t2 && t2.enumerable;
} : D$3}, b$3 = function(e20, t2) {
  return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
}, A$3 = {}.toString, v$3 = function(e20) {
  return A$3.call(e20).slice(8, -1);
}, F$3 = "".split, S$3 = m$3(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return v$3(e20) == "String" ? F$3.call(e20, "") : Object(e20);
} : Object, x$3 = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, w$3 = function(e20) {
  return S$3(x$3(e20));
}, T$3 = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, B$3 = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, N$3 = function(e20, t2) {
  return arguments.length < 2 ? B$3(g$3[e20]) : g$3[e20] && g$3[e20][t2];
}, k$3 = N$3("navigator", "userAgent") || "", P$3 = g$3.process, O$3 = g$3.Deno, I$3 = P$3 && P$3.versions || O$3 && O$3.version, L$3 = I$3 && I$3.v8;
L$3 ? a$3 = (s$3 = L$3.split("."))[0] < 4 ? 1 : s$3[0] + s$3[1] : k$3 && (!(s$3 = k$3.match(/Edge\/(\d+)/)) || s$3[1] >= 74) && (s$3 = k$3.match(/Chrome\/(\d+)/)) && (a$3 = s$3[1]);
var j$3 = a$3 && +a$3, _$3 = !!Object.getOwnPropertySymbols && !m$3(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && j$3 && j$3 < 41;
}), M$3 = _$3 && !Symbol.sham && typeof Symbol.iterator == "symbol", R$3 = M$3 ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = N$3("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, $$3 = function(e20, t2) {
  try {
    Object.defineProperty(g$3, e20, {value: t2, configurable: true, writable: true});
  } catch (n2) {
    g$3[e20] = t2;
  }
  return t2;
}, V$3 = g$3["__core-js_shared__"] || $$3("__core-js_shared__", {}), W$3 = r$3(function(e20) {
  (e20.exports = function(e21, t2) {
    return V$3[e21] || (V$3[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
}), q$3 = function(e20) {
  return Object(x$3(e20));
}, U$3 = {}.hasOwnProperty, z$3 = Object.hasOwn || function(e20, t2) {
  return U$3.call(q$3(e20), t2);
}, G$3 = 0, H$3 = Math.random(), J$3 = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++G$3 + H$3).toString(36);
}, X$3 = W$3("wks"), Y$3 = g$3.Symbol, K$3 = M$3 ? Y$3 : Y$3 && Y$3.withoutSetter || J$3, Q$3 = function(e20) {
  return z$3(X$3, e20) && (_$3 || typeof X$3[e20] == "string") || (_$3 && z$3(Y$3, e20) ? X$3[e20] = Y$3[e20] : X$3[e20] = K$3("Symbol." + e20)), X$3[e20];
}, Z$3 = Q$3("toPrimitive"), ee$3 = function(e20, t2) {
  if (!T$3(e20) || R$3(e20))
    return e20;
  var n2, r2 = e20[Z$3];
  if (r2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), n2 = r2.call(e20, t2), !T$3(n2) || R$3(n2))
      return n2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var n3, r3;
    if (t3 === "string" && typeof (n3 = e21.toString) == "function" && !T$3(r3 = n3.call(e21)))
      return r3;
    if (typeof (n3 = e21.valueOf) == "function" && !T$3(r3 = n3.call(e21)))
      return r3;
    if (t3 !== "string" && typeof (n3 = e21.toString) == "function" && !T$3(r3 = n3.call(e21)))
      return r3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, te$3 = function(e20) {
  var t2 = ee$3(e20, "string");
  return R$3(t2) ? t2 : String(t2);
}, ne$3 = g$3.document, re$3 = T$3(ne$3) && T$3(ne$3.createElement), ie$3 = !y$3 && !m$3(function() {
  return Object.defineProperty((e20 = "div", re$3 ? ne$3.createElement(e20) : {}), "a", {get: function() {
    return 7;
  }}).a != 7;
  var e20;
}), ue$3 = Object.getOwnPropertyDescriptor, oe$3 = {f: y$3 ? ue$3 : function(e20, t2) {
  if (e20 = w$3(e20), t2 = te$3(t2), ie$3)
    try {
      return ue$3(e20, t2);
    } catch (e21) {
    }
  if (z$3(e20, t2))
    return b$3(!C$3.f.call(e20, t2), e20[t2]);
}}, se$3 = function(e20) {
  if (!T$3(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, ae$3 = Object.defineProperty, ce$3 = {f: y$3 ? ae$3 : function(e20, t2, n2) {
  if (se$3(e20), t2 = te$3(t2), se$3(n2), ie$3)
    try {
      return ae$3(e20, t2, n2);
    } catch (e21) {
    }
  if ("get" in n2 || "set" in n2)
    throw TypeError("Accessors not supported");
  return "value" in n2 && (e20[t2] = n2.value), e20;
}}, le$3 = y$3 ? function(e20, t2, n2) {
  return ce$3.f(e20, t2, b$3(1, n2));
} : function(e20, t2, n2) {
  return e20[t2] = n2, e20;
}, pe$3 = Function.toString;
typeof V$3.inspectSource != "function" && (V$3.inspectSource = function(e20) {
  return pe$3.call(e20);
});
var fe$3, de$3, he$3, ge$3, me$3 = V$3.inspectSource, ye$3 = g$3.WeakMap, De$3 = typeof ye$3 == "function" && /native code/.test(me$3(ye$3)), Ee$3 = W$3("keys"), Ce$3 = {}, be$3 = g$3.WeakMap;
if (De$3 || V$3.state) {
  var Ae$3 = V$3.state || (V$3.state = new be$3()), ve$3 = Ae$3.get, Fe$3 = Ae$3.has, Se$3 = Ae$3.set;
  fe$3 = function(e20, t2) {
    if (Fe$3.call(Ae$3, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, Se$3.call(Ae$3, e20, t2), t2;
  }, de$3 = function(e20) {
    return ve$3.call(Ae$3, e20) || {};
  }, he$3 = function(e20) {
    return Fe$3.call(Ae$3, e20);
  };
} else {
  var xe$3 = Ee$3[ge$3 = "state"] || (Ee$3[ge$3] = J$3(ge$3));
  Ce$3[xe$3] = true, fe$3 = function(e20, t2) {
    if (z$3(e20, xe$3))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, le$3(e20, xe$3, t2), t2;
  }, de$3 = function(e20) {
    return z$3(e20, xe$3) ? e20[xe$3] : {};
  }, he$3 = function(e20) {
    return z$3(e20, xe$3);
  };
}
var we$3, Te$3, Be$3 = {set: fe$3, get: de$3, has: he$3, enforce: function(e20) {
  return he$3(e20) ? de$3(e20) : fe$3(e20, {});
}, getterFor: function(e20) {
  return function(t2) {
    var n2;
    if (!T$3(t2) || (n2 = de$3(t2)).type !== e20)
      throw TypeError("Incompatible receiver, " + e20 + " required");
    return n2;
  };
}}, Ne$3 = r$3(function(e20) {
  var t2 = Be$3.get, n2 = Be$3.enforce, r2 = String(String).split("String");
  (e20.exports = function(e21, t3, i2, u2) {
    var o2, s2 = !!u2 && !!u2.unsafe, a2 = !!u2 && !!u2.enumerable, c2 = !!u2 && !!u2.noTargetGet;
    typeof i2 == "function" && (typeof t3 != "string" || z$3(i2, "name") || le$3(i2, "name", t3), (o2 = n2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e21 !== g$3 ? (s2 ? !c2 && e21[t3] && (a2 = true) : delete e21[t3], a2 ? e21[t3] = i2 : le$3(e21, t3, i2)) : a2 ? e21[t3] = i2 : $$3(t3, i2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || me$3(this);
  });
}), ke$3 = Math.ceil, Pe$3 = Math.floor, Oe$3 = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? Pe$3 : ke$3)(e20);
}, Ie$3 = Math.min, Le$3 = function(e20) {
  return e20 > 0 ? Ie$3(Oe$3(e20), 9007199254740991) : 0;
}, je$3 = Math.max, _e$3 = Math.min, Me$3 = function(e20) {
  return function(t2, n2, r2) {
    var i2, u2 = w$3(t2), o2 = Le$3(u2.length), s2 = function(e21, t3) {
      var n3 = Oe$3(e21);
      return n3 < 0 ? je$3(n3 + t3, 0) : _e$3(n3, t3);
    }(r2, o2);
    if (e20 && n2 != n2) {
      for (; o2 > s2; )
        if ((i2 = u2[s2++]) != i2)
          return true;
    } else
      for (; o2 > s2; s2++)
        if ((e20 || s2 in u2) && u2[s2] === n2)
          return e20 || s2 || 0;
    return !e20 && -1;
  };
}, Re$3 = {includes: Me$3(true), indexOf: Me$3(false)}.indexOf, $e$3 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ve$3 = {f: Object.getOwnPropertyNames || function(e20) {
  return function(e21, t2) {
    var n2, r2 = w$3(e21), i2 = 0, u2 = [];
    for (n2 in r2)
      !z$3(Ce$3, n2) && z$3(r2, n2) && u2.push(n2);
    for (; t2.length > i2; )
      z$3(r2, n2 = t2[i2++]) && (~Re$3(u2, n2) || u2.push(n2));
    return u2;
  }(e20, $e$3);
}}, We$3 = {f: Object.getOwnPropertySymbols}, qe$3 = N$3("Reflect", "ownKeys") || function(e20) {
  var t2 = Ve$3.f(se$3(e20)), n2 = We$3.f;
  return n2 ? t2.concat(n2(e20)) : t2;
}, Ue$3 = function(e20, t2) {
  for (var n2 = qe$3(t2), r2 = ce$3.f, i2 = oe$3.f, u2 = 0; u2 < n2.length; u2++) {
    var o2 = n2[u2];
    z$3(e20, o2) || r2(e20, o2, i2(t2, o2));
  }
}, ze$3 = /#|\.prototype\./, Ge$3 = function(e20, t2) {
  var n2 = Je$3[He$3(e20)];
  return n2 == Ye$3 || n2 != Xe$3 && (typeof t2 == "function" ? m$3(t2) : !!t2);
}, He$3 = Ge$3.normalize = function(e20) {
  return String(e20).replace(ze$3, ".").toLowerCase();
}, Je$3 = Ge$3.data = {}, Xe$3 = Ge$3.NATIVE = "N", Ye$3 = Ge$3.POLYFILL = "P", Ke$3 = Ge$3, Qe$3 = oe$3.f, Ze$3 = function(e20, t2) {
  var n2, r2, i2, u2, o2, s2 = e20.target, a2 = e20.global, c2 = e20.stat;
  if (n2 = a2 ? g$3 : c2 ? g$3[s2] || $$3(s2, {}) : (g$3[s2] || {}).prototype)
    for (r2 in t2) {
      if (u2 = t2[r2], i2 = e20.noTargetGet ? (o2 = Qe$3(n2, r2)) && o2.value : n2[r2], !Ke$3(a2 ? r2 : s2 + (c2 ? "." : "#") + r2, e20.forced) && i2 !== void 0) {
        if (typeof u2 == typeof i2)
          continue;
        Ue$3(u2, i2);
      }
      (e20.sham || i2 && i2.sham) && le$3(u2, "sham", true), Ne$3(n2, r2, u2, e20);
    }
}, et$3 = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, tt$3 = function(e20) {
  if (R$3(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, nt$3 = Math.floor, rt$3 = function(e20, t2) {
  var n2 = e20.length, r2 = nt$3(n2 / 2);
  return n2 < 8 ? it$3(e20, t2) : ut$3(rt$3(e20.slice(0, r2), t2), rt$3(e20.slice(r2), t2), t2);
}, it$3 = function(e20, t2) {
  for (var n2, r2, i2 = e20.length, u2 = 1; u2 < i2; ) {
    for (r2 = u2, n2 = e20[u2]; r2 && t2(e20[r2 - 1], n2) > 0; )
      e20[r2] = e20[--r2];
    r2 !== u2++ && (e20[r2] = n2);
  }
  return e20;
}, ut$3 = function(e20, t2, n2) {
  for (var r2 = e20.length, i2 = t2.length, u2 = 0, o2 = 0, s2 = []; u2 < r2 || o2 < i2; )
    u2 < r2 && o2 < i2 ? s2.push(n2(e20[u2], t2[o2]) <= 0 ? e20[u2++] : t2[o2++]) : s2.push(u2 < r2 ? e20[u2++] : t2[o2++]);
  return s2;
}, ot$3 = rt$3, st$3 = k$3.match(/firefox\/(\d+)/i), at$3 = !!st$3 && +st$3[1], ct$3 = /MSIE|Trident/.test(k$3), lt$3 = k$3.match(/AppleWebKit\/(\d+)\./), pt$3 = !!lt$3 && +lt$3[1], ft$3 = [], dt$3 = ft$3.sort, ht$3 = m$3(function() {
  ft$3.sort(void 0);
}), gt$3 = m$3(function() {
  ft$3.sort(null);
}), mt$3 = !!(Te$3 = []["sort"]) && m$3(function() {
  Te$3.call(null, we$3 || function() {
    throw 1;
  }, 1);
}), yt$3 = !m$3(function() {
  if (j$3)
    return j$3 < 70;
  if (!(at$3 && at$3 > 3)) {
    if (ct$3)
      return true;
    if (pt$3)
      return pt$3 < 603;
    var e20, t2, n2, r2, i2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          n2 = 3;
          break;
        case 68:
        case 71:
          n2 = 4;
          break;
        default:
          n2 = 2;
      }
      for (r2 = 0; r2 < 47; r2++)
        ft$3.push({k: t2 + r2, v: n2});
    }
    for (ft$3.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), r2 = 0; r2 < ft$3.length; r2++)
      t2 = ft$3[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
    return i2 !== "DGBEFHACIJK";
  }
});
Ze$3({target: "Array", proto: true, forced: ht$3 || !gt$3 || !mt$3 || !yt$3}, {sort: function(e20) {
  e20 !== void 0 && et$3(e20);
  var t2 = q$3(this);
  if (yt$3)
    return e20 === void 0 ? dt$3.call(t2) : dt$3.call(t2, e20);
  var n2, r2, i2 = [], u2 = Le$3(t2.length);
  for (r2 = 0; r2 < u2; r2++)
    r2 in t2 && i2.push(t2[r2]);
  for (n2 = (i2 = ot$3(i2, function(e21) {
    return function(t3, n3) {
      return n3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, n3) || 0 : tt$3(t3) > tt$3(n3) ? 1 : -1;
    };
  }(e20))).length, r2 = 0; r2 < n2; )
    t2[r2] = i2[r2++];
  for (; r2 < u2; )
    delete t2[r2++];
  return t2;
}});
var Dt$3 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), t2.diffJson = function(e21, t3, n3) {
    return s2.diff(e21, t3, n3);
  }, t2.canonicalize = a2, t2.jsonDiff = void 0;
  var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : {default: n2};
  function u2(e21) {
    return (u2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e22) {
      return typeof e22;
    } : function(e22) {
      return e22 && typeof Symbol == "function" && e22.constructor === Symbol && e22 !== Symbol.prototype ? "symbol" : typeof e22;
    })(e21);
  }
  var o2 = Object.prototype.toString, s2 = new r2.default();
  function a2(e21, t3, n3, r3, i2) {
    var s3, c2;
    for (t3 = t3 || [], n3 = n3 || [], r3 && (e21 = r3(i2, e21)), s3 = 0; s3 < t3.length; s3 += 1)
      if (t3[s3] === e21)
        return n3[s3];
    if (o2.call(e21) === "[object Array]") {
      for (t3.push(e21), c2 = new Array(e21.length), n3.push(c2), s3 = 0; s3 < e21.length; s3 += 1)
        c2[s3] = a2(e21[s3], t3, n3, r3, i2);
      return t3.pop(), n3.pop(), c2;
    }
    if (e21 && e21.toJSON && (e21 = e21.toJSON()), u2(e21) === "object" && e21 !== null) {
      t3.push(e21), c2 = {}, n3.push(c2);
      var l2, p2 = [];
      for (l2 in e21)
        e21.hasOwnProperty(l2) && p2.push(l2);
      for (p2.sort(), s3 = 0; s3 < p2.length; s3 += 1)
        c2[l2 = p2[s3]] = a2(e21[l2], t3, n3, r3, l2);
      t3.pop(), n3.pop();
    } else
      c2 = e21;
    return c2;
  }
  t2.jsonDiff = s2, s2.useLongestToken = true, s2.tokenize = p$3.lineDiff.tokenize, s2.castInput = function(e21) {
    var t3 = this.options, n3 = t3.undefinedReplacement, r3 = t3.stringifyReplacer, i2 = r3 === void 0 ? function(e22, t4) {
      return t4 === void 0 ? n3 : t4;
    } : r3;
    return typeof e21 == "string" ? e21 : JSON.stringify(a2(e21, null, null, i2), i2, "  ");
  }, s2.equals = function(e21, t3) {
    return r2.default.prototype.equals.call(s2, e21.replace(/,([\r\n])/g, "$1"), t3.replace(/,([\r\n])/g, "$1"));
  };
}), Et$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", {value: true}), t2.diffArrays = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.arrayDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
  t2.arrayDiff = r2, r2.tokenize = function(e21) {
    return e21.slice();
  }, r2.join = r2.removeEmpty = function(e21) {
    return e21;
  };
}), Ct$3 = function(e20) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e20.split(/\r\n|[\n\v\f\r\x85]/), r2 = e20.match(/\r\n|[\n\v\f\r\x85]/g) || [], i2 = [], u2 = 0;
  function o2() {
    var e21 = {};
    for (i2.push(e21); u2 < n2.length; ) {
      var r3 = n2[u2];
      if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
        break;
      var o3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
      o3 && (e21.index = o3[1]), u2++;
    }
    for (s2(e21), s2(e21), e21.hunks = []; u2 < n2.length; ) {
      var c2 = n2[u2];
      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c2))
        break;
      if (/^@@/.test(c2))
        e21.hunks.push(a2());
      else {
        if (c2 && t2.strict)
          throw new Error("Unknown line " + (u2 + 1) + " " + JSON.stringify(c2));
        u2++;
      }
    }
  }
  function s2(e21) {
    var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[u2]);
    if (t3) {
      var r3 = t3[1] === "---" ? "old" : "new", i3 = t3[2].split("	", 2), o3 = i3[0].replace(/\\\\/g, "\\");
      /^".*"$/.test(o3) && (o3 = o3.substr(1, o3.length - 2)), e21[r3 + "FileName"] = o3, e21[r3 + "Header"] = (i3[1] || "").trim(), u2++;
    }
  }
  function a2() {
    var e21 = u2, i3 = n2[u2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), o3 = {oldStart: +i3[1], oldLines: i3[2] === void 0 ? 1 : +i3[2], newStart: +i3[3], newLines: i3[4] === void 0 ? 1 : +i3[4], lines: [], linedelimiters: []};
    o3.oldLines === 0 && (o3.oldStart += 1), o3.newLines === 0 && (o3.newStart += 1);
    for (var s3 = 0, a3 = 0; u2 < n2.length && !(n2[u2].indexOf("--- ") === 0 && u2 + 2 < n2.length && n2[u2 + 1].indexOf("+++ ") === 0 && n2[u2 + 2].indexOf("@@") === 0); u2++) {
      var c2 = n2[u2].length == 0 && u2 != n2.length - 1 ? " " : n2[u2][0];
      if (c2 !== "+" && c2 !== "-" && c2 !== " " && c2 !== "\\")
        break;
      o3.lines.push(n2[u2]), o3.linedelimiters.push(r2[u2] || "\n"), c2 === "+" ? s3++ : c2 === "-" ? a3++ : c2 === " " && (s3++, a3++);
    }
    if (s3 || o3.newLines !== 1 || (o3.newLines = 0), a3 || o3.oldLines !== 1 || (o3.oldLines = 0), t2.strict) {
      if (s3 !== o3.newLines)
        throw new Error("Added line count did not match for hunk at line " + (e21 + 1));
      if (a3 !== o3.oldLines)
        throw new Error("Removed line count did not match for hunk at line " + (e21 + 1));
    }
    return o3;
  }
  for (; u2 < n2.length; )
    o2();
  return i2;
};
var bt$3, At$3 = Object.defineProperty({parsePatch: Ct$3}, "__esModule", {value: true}), vt$3 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), t2.default = function(e21, t3, n2) {
    var r2 = true, i2 = false, u2 = false, o2 = 1;
    return function s2() {
      if (r2 && !u2) {
        if (i2 ? o2++ : r2 = false, e21 + o2 <= n2)
          return o2;
        u2 = true;
      }
      if (!i2)
        return u2 || (r2 = true), t3 <= e21 - o2 ? -o2++ : (i2 = true, s2());
    };
  };
}), Ft$3 = wt$3, St$2 = function(e20, t2) {
  typeof e20 == "string" && (e20 = (0, At$3.parsePatch)(e20));
  var n2 = 0;
  !function r2() {
    var i2 = e20[n2++];
    if (!i2)
      return t2.complete();
    t2.loadFile(i2, function(e21, n3) {
      if (e21)
        return t2.complete(e21);
      var u2 = wt$3(n3, i2, t2);
      t2.patched(i2, u2, function(e22) {
        if (e22)
          return t2.complete(e22);
        r2();
      });
    });
  }();
}, xt$3 = (bt$3 = vt$3) && bt$3.__esModule ? bt$3 : {default: bt$3};
function wt$3(e20, t2) {
  var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t2 == "string" && (t2 = (0, At$3.parsePatch)(t2)), Array.isArray(t2)) {
    if (t2.length > 1)
      throw new Error("applyPatch only works with a single input.");
    t2 = t2[0];
  }
  var r2, i2, u2 = e20.split(/\r\n|[\n\v\f\r\x85]/), o2 = e20.match(/\r\n|[\n\v\f\r\x85]/g) || [], s2 = t2.hunks, a2 = n2.compareLine || function(e21, t3, n3, r3) {
    return t3 === r3;
  }, c2 = 0, l2 = n2.fuzzFactor || 0, p2 = 0, f2 = 0;
  function d2(e21, t3) {
    for (var n3 = 0; n3 < e21.lines.length; n3++) {
      var r3 = e21.lines[n3], i3 = r3.length > 0 ? r3[0] : " ", o3 = r3.length > 0 ? r3.substr(1) : r3;
      if (i3 === " " || i3 === "-") {
        if (!a2(t3 + 1, u2[t3], i3, o3) && ++c2 > l2)
          return false;
        t3++;
      }
    }
    return true;
  }
  for (var h2 = 0; h2 < s2.length; h2++) {
    for (var g2 = s2[h2], m2 = u2.length - g2.oldLines, y2 = 0, D2 = f2 + g2.oldStart - 1, E2 = (0, xt$3.default)(D2, p2, m2); y2 !== void 0; y2 = E2())
      if (d2(g2, D2 + y2)) {
        g2.offset = f2 += y2;
        break;
      }
    if (y2 === void 0)
      return false;
    p2 = g2.offset + g2.oldStart + g2.oldLines;
  }
  for (var C2 = 0, b2 = 0; b2 < s2.length; b2++) {
    var A2 = s2[b2], v2 = A2.oldStart + A2.offset + C2 - 1;
    C2 += A2.newLines - A2.oldLines;
    for (var F2 = 0; F2 < A2.lines.length; F2++) {
      var S2 = A2.lines[F2], x2 = S2.length > 0 ? S2[0] : " ", w2 = S2.length > 0 ? S2.substr(1) : S2, T2 = A2.linedelimiters[F2];
      if (x2 === " ")
        v2++;
      else if (x2 === "-")
        u2.splice(v2, 1), o2.splice(v2, 1);
      else if (x2 === "+")
        u2.splice(v2, 0, w2), o2.splice(v2, 0, T2), v2++;
      else if (x2 === "\\") {
        var B2 = A2.lines[F2 - 1] ? A2.lines[F2 - 1][0] : null;
        B2 === "+" ? r2 = true : B2 === "-" && (i2 = true);
      }
    }
  }
  if (r2)
    for (; !u2[u2.length - 1]; )
      u2.pop(), o2.pop();
  else
    i2 && (u2.push(""), o2.push("\n"));
  for (var N2 = 0; N2 < u2.length - 1; N2++)
    u2[N2] = u2[N2] + o2[N2];
  return u2.join("");
}
var Tt$2 = Object.defineProperty({applyPatch: Ft$3, applyPatches: St$2}, "__esModule", {value: true}), Bt$2 = Lt$2, Nt$2 = jt$2, kt$3 = _t$2, Pt$2 = function(e20, t2, n2, r2, i2, u2) {
  return _t$2(e20, e20, t2, n2, r2, i2, u2);
};
function Ot$3(e20) {
  return function(e21) {
    if (Array.isArray(e21))
      return It$2(e21);
  }(e20) || function(e21) {
    if (typeof Symbol != "undefined" && Symbol.iterator in Object(e21))
      return Array.from(e21);
  }(e20) || function(e21, t2) {
    if (!e21)
      return;
    if (typeof e21 == "string")
      return It$2(e21, t2);
    var n2 = Object.prototype.toString.call(e21).slice(8, -1);
    n2 === "Object" && e21.constructor && (n2 = e21.constructor.name);
    if (n2 === "Map" || n2 === "Set")
      return Array.from(e21);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return It$2(e21, t2);
  }(e20) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function It$2(e20, t2) {
  (t2 == null || t2 > e20.length) && (t2 = e20.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
    r2[n2] = e20[n2];
  return r2;
}
function Lt$2(e20, t2, n2, r2, i2, u2, o2) {
  o2 || (o2 = {}), o2.context === void 0 && (o2.context = 4);
  var s2 = (0, p$3.diffLines)(n2, r2, o2);
  function a2(e21) {
    return e21.map(function(e22) {
      return " " + e22;
    });
  }
  s2.push({value: "", lines: []});
  for (var c2 = [], l2 = 0, f2 = 0, d2 = [], h2 = 1, g2 = 1, m2 = function(e21) {
    var t3 = s2[e21], i3 = t3.lines || t3.value.replace(/\n$/, "").split("\n");
    if (t3.lines = i3, t3.added || t3.removed) {
      var u3;
      if (!l2) {
        var p2 = s2[e21 - 1];
        l2 = h2, f2 = g2, p2 && (d2 = o2.context > 0 ? a2(p2.lines.slice(-o2.context)) : [], l2 -= d2.length, f2 -= d2.length);
      }
      (u3 = d2).push.apply(u3, Ot$3(i3.map(function(e22) {
        return (t3.added ? "+" : "-") + e22;
      }))), t3.added ? g2 += i3.length : h2 += i3.length;
    } else {
      if (l2)
        if (i3.length <= 2 * o2.context && e21 < s2.length - 2) {
          var m3;
          (m3 = d2).push.apply(m3, Ot$3(a2(i3)));
        } else {
          var y3, D2 = Math.min(i3.length, o2.context);
          (y3 = d2).push.apply(y3, Ot$3(a2(i3.slice(0, D2))));
          var E2 = {oldStart: l2, oldLines: h2 - l2 + D2, newStart: f2, newLines: g2 - f2 + D2, lines: d2};
          if (e21 >= s2.length - 2 && i3.length <= o2.context) {
            var C2 = /\n$/.test(n2), b2 = /\n$/.test(r2), A2 = i3.length == 0 && d2.length > E2.oldLines;
            !C2 && A2 && n2.length > 0 && d2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C2 || A2) && b2 || d2.push("\\ No newline at end of file");
          }
          c2.push(E2), l2 = 0, f2 = 0, d2 = [];
        }
      h2 += i3.length, g2 += i3.length;
    }
  }, y2 = 0; y2 < s2.length; y2++)
    m2(y2);
  return {oldFileName: e20, newFileName: t2, oldHeader: i2, newHeader: u2, hunks: c2};
}
function jt$2(e20) {
  var t2 = [];
  e20.oldFileName == e20.newFileName && t2.push("Index: " + e20.oldFileName), t2.push("==================================================================="), t2.push("--- " + e20.oldFileName + (e20.oldHeader === void 0 ? "" : "	" + e20.oldHeader)), t2.push("+++ " + e20.newFileName + (e20.newHeader === void 0 ? "" : "	" + e20.newHeader));
  for (var n2 = 0; n2 < e20.hunks.length; n2++) {
    var r2 = e20.hunks[n2];
    r2.oldLines === 0 && (r2.oldStart -= 1), r2.newLines === 0 && (r2.newStart -= 1), t2.push("@@ -" + r2.oldStart + "," + r2.oldLines + " +" + r2.newStart + "," + r2.newLines + " @@"), t2.push.apply(t2, r2.lines);
  }
  return t2.join("\n") + "\n";
}
function _t$2(e20, t2, n2, r2, i2, u2, o2) {
  return jt$2(Lt$2(e20, t2, n2, r2, i2, u2, o2));
}
var Mt$2 = Object.defineProperty({structuredPatch: Bt$2, formatPatch: Nt$2, createTwoFilesPatch: kt$3, createPatch: Pt$2}, "__esModule", {value: true}), Rt$2 = function(e20, t2) {
  if (e20.length !== t2.length)
    return false;
  return Vt$2(e20, t2);
}, $t$2 = Vt$2;
function Vt$2(e20, t2) {
  if (t2.length > e20.length)
    return false;
  for (var n2 = 0; n2 < t2.length; n2++)
    if (t2[n2] !== e20[n2])
      return false;
  return true;
}
var Wt$2 = Object.defineProperty({arrayEqual: Rt$2, arrayStartsWith: $t$2}, "__esModule", {value: true}), qt$2 = Ht$2, Ut$2 = function(e20, t2, n2) {
  e20 = Jt$2(e20, n2), t2 = Jt$2(t2, n2);
  var r2 = {};
  (e20.index || t2.index) && (r2.index = e20.index || t2.index);
  (e20.newFileName || t2.newFileName) && (Xt$2(e20) ? Xt$2(t2) ? (r2.oldFileName = Yt$2(r2, e20.oldFileName, t2.oldFileName), r2.newFileName = Yt$2(r2, e20.newFileName, t2.newFileName), r2.oldHeader = Yt$2(r2, e20.oldHeader, t2.oldHeader), r2.newHeader = Yt$2(r2, e20.newHeader, t2.newHeader)) : (r2.oldFileName = e20.oldFileName, r2.newFileName = e20.newFileName, r2.oldHeader = e20.oldHeader, r2.newHeader = e20.newHeader) : (r2.oldFileName = t2.oldFileName || e20.oldFileName, r2.newFileName = t2.newFileName || e20.newFileName, r2.oldHeader = t2.oldHeader || e20.oldHeader, r2.newHeader = t2.newHeader || e20.newHeader));
  r2.hunks = [];
  var i2 = 0, u2 = 0, o2 = 0, s2 = 0;
  for (; i2 < e20.hunks.length || u2 < t2.hunks.length; ) {
    var a2 = e20.hunks[i2] || {oldStart: 1 / 0}, c2 = t2.hunks[u2] || {oldStart: 1 / 0};
    if (Kt$2(a2, c2))
      r2.hunks.push(Qt$2(a2, o2)), i2++, s2 += a2.newLines - a2.oldLines;
    else if (Kt$2(c2, a2))
      r2.hunks.push(Qt$2(c2, s2)), u2++, o2 += c2.newLines - c2.oldLines;
    else {
      var l2 = {oldStart: Math.min(a2.oldStart, c2.oldStart), oldLines: 0, newStart: Math.min(a2.newStart + o2, c2.oldStart + s2), newLines: 0, lines: []};
      Zt$2(l2, a2.oldStart, a2.lines, c2.oldStart, c2.lines), u2++, i2++, r2.hunks.push(l2);
    }
  }
  return r2;
};
function zt$2(e20) {
  return function(e21) {
    if (Array.isArray(e21))
      return Gt$2(e21);
  }(e20) || function(e21) {
    if (typeof Symbol != "undefined" && Symbol.iterator in Object(e21))
      return Array.from(e21);
  }(e20) || function(e21, t2) {
    if (!e21)
      return;
    if (typeof e21 == "string")
      return Gt$2(e21, t2);
    var n2 = Object.prototype.toString.call(e21).slice(8, -1);
    n2 === "Object" && e21.constructor && (n2 = e21.constructor.name);
    if (n2 === "Map" || n2 === "Set")
      return Array.from(e21);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return Gt$2(e21, t2);
  }(e20) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function Gt$2(e20, t2) {
  (t2 == null || t2 > e20.length) && (t2 = e20.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
    r2[n2] = e20[n2];
  return r2;
}
function Ht$2(e20) {
  var t2 = cn$2(e20.lines), n2 = t2.oldLines, r2 = t2.newLines;
  n2 !== void 0 ? e20.oldLines = n2 : delete e20.oldLines, r2 !== void 0 ? e20.newLines = r2 : delete e20.newLines;
}
function Jt$2(e20, t2) {
  if (typeof e20 == "string") {
    if (/^@@/m.test(e20) || /^Index:/m.test(e20))
      return (0, At$3.parsePatch)(e20)[0];
    if (!t2)
      throw new Error("Must provide a base reference or pass in a patch");
    return (0, Mt$2.structuredPatch)(void 0, void 0, t2, e20);
  }
  return e20;
}
function Xt$2(e20) {
  return e20.newFileName && e20.newFileName !== e20.oldFileName;
}
function Yt$2(e20, t2, n2) {
  return t2 === n2 ? t2 : (e20.conflict = true, {mine: t2, theirs: n2});
}
function Kt$2(e20, t2) {
  return e20.oldStart < t2.oldStart && e20.oldStart + e20.oldLines < t2.oldStart;
}
function Qt$2(e20, t2) {
  return {oldStart: e20.oldStart, oldLines: e20.oldLines, newStart: e20.newStart + t2, newLines: e20.newLines, lines: e20.lines};
}
function Zt$2(e20, t2, n2, r2, i2) {
  var u2 = {offset: t2, lines: n2, index: 0}, o2 = {offset: r2, lines: i2, index: 0};
  for (rn$2(e20, u2, o2), rn$2(e20, o2, u2); u2.index < u2.lines.length && o2.index < o2.lines.length; ) {
    var s2 = u2.lines[u2.index], a2 = o2.lines[o2.index];
    if (s2[0] !== "-" && s2[0] !== "+" || a2[0] !== "-" && a2[0] !== "+")
      if (s2[0] === "+" && a2[0] === " ") {
        var c2;
        (c2 = e20.lines).push.apply(c2, zt$2(on$2(u2)));
      } else if (a2[0] === "+" && s2[0] === " ") {
        var l2;
        (l2 = e20.lines).push.apply(l2, zt$2(on$2(o2)));
      } else
        s2[0] === "-" && a2[0] === " " ? tn$2(e20, u2, o2) : a2[0] === "-" && s2[0] === " " ? tn$2(e20, o2, u2, true) : s2 === a2 ? (e20.lines.push(s2), u2.index++, o2.index++) : nn$2(e20, on$2(u2), on$2(o2));
    else
      en$2(e20, u2, o2);
  }
  un$2(e20, u2), un$2(e20, o2), Ht$2(e20);
}
function en$2(e20, t2, n2) {
  var r2 = on$2(t2), i2 = on$2(n2);
  if (sn$2(r2) && sn$2(i2)) {
    var u2, o2;
    if ((0, Wt$2.arrayStartsWith)(r2, i2) && an$2(n2, r2, r2.length - i2.length))
      return void (u2 = e20.lines).push.apply(u2, zt$2(r2));
    if ((0, Wt$2.arrayStartsWith)(i2, r2) && an$2(t2, i2, i2.length - r2.length))
      return void (o2 = e20.lines).push.apply(o2, zt$2(i2));
  } else if ((0, Wt$2.arrayEqual)(r2, i2)) {
    var s2;
    return void (s2 = e20.lines).push.apply(s2, zt$2(r2));
  }
  nn$2(e20, r2, i2);
}
function tn$2(e20, t2, n2, r2) {
  var i2, u2 = on$2(t2), o2 = function(e21, t3) {
    var n3 = [], r3 = [], i3 = 0, u3 = false, o3 = false;
    for (; i3 < t3.length && e21.index < e21.lines.length; ) {
      var s2 = e21.lines[e21.index], a2 = t3[i3];
      if (a2[0] === "+")
        break;
      if (u3 = u3 || s2[0] !== " ", r3.push(a2), i3++, s2[0] === "+")
        for (o3 = true; s2[0] === "+"; )
          n3.push(s2), s2 = e21.lines[++e21.index];
      a2.substr(1) === s2.substr(1) ? (n3.push(s2), e21.index++) : o3 = true;
    }
    (t3[i3] || "")[0] === "+" && u3 && (o3 = true);
    if (o3)
      return n3;
    for (; i3 < t3.length; )
      r3.push(t3[i3++]);
    return {merged: r3, changes: n3};
  }(n2, u2);
  o2.merged ? (i2 = e20.lines).push.apply(i2, zt$2(o2.merged)) : nn$2(e20, r2 ? o2 : u2, r2 ? u2 : o2);
}
function nn$2(e20, t2, n2) {
  e20.conflict = true, e20.lines.push({conflict: true, mine: t2, theirs: n2});
}
function rn$2(e20, t2, n2) {
  for (; t2.offset < n2.offset && t2.index < t2.lines.length; ) {
    var r2 = t2.lines[t2.index++];
    e20.lines.push(r2), t2.offset++;
  }
}
function un$2(e20, t2) {
  for (; t2.index < t2.lines.length; ) {
    var n2 = t2.lines[t2.index++];
    e20.lines.push(n2);
  }
}
function on$2(e20) {
  for (var t2 = [], n2 = e20.lines[e20.index][0]; e20.index < e20.lines.length; ) {
    var r2 = e20.lines[e20.index];
    if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
      break;
    t2.push(r2), e20.index++;
  }
  return t2;
}
function sn$2(e20) {
  return e20.reduce(function(e21, t2) {
    return e21 && t2[0] === "-";
  }, true);
}
function an$2(e20, t2, n2) {
  for (var r2 = 0; r2 < n2; r2++) {
    var i2 = t2[t2.length - n2 + r2].substr(1);
    if (e20.lines[e20.index + r2] !== " " + i2)
      return false;
  }
  return e20.index += n2, true;
}
function cn$2(e20) {
  var t2 = 0, n2 = 0;
  return e20.forEach(function(e21) {
    if (typeof e21 != "string") {
      var r2 = cn$2(e21.mine), i2 = cn$2(e21.theirs);
      t2 !== void 0 && (r2.oldLines === i2.oldLines ? t2 += r2.oldLines : t2 = void 0), n2 !== void 0 && (r2.newLines === i2.newLines ? n2 += r2.newLines : n2 = void 0);
    } else
      n2 === void 0 || e21[0] !== "+" && e21[0] !== " " || n2++, t2 === void 0 || e21[0] !== "-" && e21[0] !== " " || t2++;
  }), {oldLines: t2, newLines: n2};
}
var ln$2 = Object.defineProperty({calcLineCount: qt$2, merge: Ut$2}, "__esModule", {value: true}), pn$2 = function(e20) {
  for (var t2, n2, r2 = [], i2 = 0; i2 < e20.length; i2++)
    t2 = e20[i2], n2 = t2.added ? 1 : t2.removed ? -1 : 0, r2.push([n2, t2.value]);
  return r2;
};
var fn$2 = Object.defineProperty({convertChangesToDMP: pn$2}, "__esModule", {value: true}), dn$2 = function(e20) {
  for (var t2 = [], n2 = 0; n2 < e20.length; n2++) {
    var r2 = e20[n2];
    r2.added ? t2.push("<ins>") : r2.removed && t2.push("<del>"), t2.push(hn$2(r2.value)), r2.added ? t2.push("</ins>") : r2.removed && t2.push("</del>");
  }
  return t2.join("");
};
function hn$2(e20) {
  var t2 = e20;
  return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
}
var gn$2 = Object.defineProperty({convertChangesToXML: dn$2}, "__esModule", {value: true}), mn$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), Object.defineProperty(t2, "Diff", {enumerable: true, get: function() {
    return n2.default;
  }}), Object.defineProperty(t2, "diffChars", {enumerable: true, get: function() {
    return u$3.diffChars;
  }}), Object.defineProperty(t2, "diffWords", {enumerable: true, get: function() {
    return l$3.diffWords;
  }}), Object.defineProperty(t2, "diffWordsWithSpace", {enumerable: true, get: function() {
    return l$3.diffWordsWithSpace;
  }}), Object.defineProperty(t2, "diffLines", {enumerable: true, get: function() {
    return p$3.diffLines;
  }}), Object.defineProperty(t2, "diffTrimmedLines", {enumerable: true, get: function() {
    return p$3.diffTrimmedLines;
  }}), Object.defineProperty(t2, "diffSentences", {enumerable: true, get: function() {
    return f$3.diffSentences;
  }}), Object.defineProperty(t2, "diffCss", {enumerable: true, get: function() {
    return d$3.diffCss;
  }}), Object.defineProperty(t2, "diffJson", {enumerable: true, get: function() {
    return Dt$3.diffJson;
  }}), Object.defineProperty(t2, "canonicalize", {enumerable: true, get: function() {
    return Dt$3.canonicalize;
  }}), Object.defineProperty(t2, "diffArrays", {enumerable: true, get: function() {
    return Et$3.diffArrays;
  }}), Object.defineProperty(t2, "applyPatch", {enumerable: true, get: function() {
    return Tt$2.applyPatch;
  }}), Object.defineProperty(t2, "applyPatches", {enumerable: true, get: function() {
    return Tt$2.applyPatches;
  }}), Object.defineProperty(t2, "parsePatch", {enumerable: true, get: function() {
    return At$3.parsePatch;
  }}), Object.defineProperty(t2, "merge", {enumerable: true, get: function() {
    return ln$2.merge;
  }}), Object.defineProperty(t2, "structuredPatch", {enumerable: true, get: function() {
    return Mt$2.structuredPatch;
  }}), Object.defineProperty(t2, "createTwoFilesPatch", {enumerable: true, get: function() {
    return Mt$2.createTwoFilesPatch;
  }}), Object.defineProperty(t2, "createPatch", {enumerable: true, get: function() {
    return Mt$2.createPatch;
  }}), Object.defineProperty(t2, "convertChangesToDMP", {enumerable: true, get: function() {
    return fn$2.convertChangesToDMP;
  }}), Object.defineProperty(t2, "convertChangesToXML", {enumerable: true, get: function() {
    return gn$2.convertChangesToXML;
  }});
  var n2 = function(e21) {
    return e21 && e21.__esModule ? e21 : {default: e21};
  }(i$3);
});
function yn$2(e20) {
  return {type: "concat", parts: e20};
}
function Dn$2(e20) {
  return {type: "indent", contents: e20};
}
function En$2(e20, t2) {
  return {type: "align", contents: t2, n: e20};
}
function Cn$2(e20, t2 = {}) {
  return {type: "group", id: t2.id, contents: e20, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates};
}
const bn$2 = {type: "break-parent"}, An$2 = {type: "line", hard: true}, vn$2 = {type: "line", hard: true, literal: true}, Fn$2 = yn$2([An$2, bn$2]), Sn$2 = yn$2([vn$2, bn$2]);
var xn$2 = {concat: yn$2, join: function(e20, t2) {
  const n2 = [];
  for (let r2 = 0; r2 < t2.length; r2++)
    r2 !== 0 && n2.push(e20), n2.push(t2[r2]);
  return yn$2(n2);
}, line: {type: "line"}, softline: {type: "line", soft: true}, hardline: Fn$2, literalline: Sn$2, group: Cn$2, conditionalGroup: function(e20, t2) {
  return Cn$2(e20[0], Object.assign(Object.assign({}, t2), {}, {expandedStates: e20}));
}, fill: function(e20) {
  return {type: "fill", parts: e20};
}, lineSuffix: function(e20) {
  return {type: "line-suffix", contents: e20};
}, lineSuffixBoundary: {type: "line-suffix-boundary"}, cursor: {type: "cursor", placeholder: Symbol("cursor")}, breakParent: bn$2, ifBreak: function(e20, t2, n2 = {}) {
  return {type: "if-break", breakContents: e20, flatContents: t2, groupId: n2.groupId};
}, trim: {type: "trim"}, indent: Dn$2, indentIfBreak: function(e20, t2) {
  return {type: "indent-if-break", contents: e20, groupId: t2.groupId, negate: t2.negate};
}, align: En$2, addAlignmentToDoc: function(e20, t2, n2) {
  let r2 = e20;
  if (t2 > 0) {
    for (let e21 = 0; e21 < Math.floor(t2 / n2); ++e21)
      r2 = Dn$2(r2);
    r2 = En$2(t2 % n2, r2), r2 = En$2(Number.NEGATIVE_INFINITY, r2);
  }
  return r2;
}, markAsRoot: function(e20) {
  return En$2({type: "root"}, e20);
}, dedentToRoot: function(e20) {
  return En$2(Number.NEGATIVE_INFINITY, e20);
}, dedent: function(e20) {
  return En$2(-1, e20);
}, hardlineWithoutBreakParent: An$2, literallineWithoutBreakParent: vn$2, label: function(e20, t2) {
  return {type: "label", label: e20, contents: t2};
}}, wn$2 = (e20) => typeof e20 == "string" ? e20.replace((({onlyFirst: e21 = false} = {}) => {
  const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(t2, e21 ? void 0 : "g");
})(), "") : e20;
const Tn$2 = (e20) => !Number.isNaN(e20) && (e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141));
var Bn$2 = Tn$2, Nn$2 = Tn$2;
Bn$2.default = Nn$2;
const kn$2 = (e20) => {
  if (typeof e20 != "string" || e20.length === 0)
    return 0;
  if ((e20 = wn$2(e20)).length === 0)
    return 0;
  e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
  let t2 = 0;
  for (let n2 = 0; n2 < e20.length; n2++) {
    const r2 = e20.codePointAt(n2);
    r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t2 += Bn$2(r2) ? 2 : 1));
  }
  return t2;
};
var Pn$2 = kn$2, On$2 = kn$2;
Pn$2.default = On$2;
var In$2 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
var Ln$2 = (e20) => e20[e20.length - 1];
function jn$2(e20, t2) {
  if (e20 == null)
    return {};
  var n2, r2, i2 = function(e21, t3) {
    if (e21 == null)
      return {};
    var n3, r3, i3 = {}, u3 = Object.keys(e21);
    for (r3 = 0; r3 < u3.length; r3++)
      n3 = u3[r3], t3.indexOf(n3) >= 0 || (i3[n3] = e21[n3]);
    return i3;
  }(e20, t2);
  if (Object.getOwnPropertySymbols) {
    var u2 = Object.getOwnPropertySymbols(e20);
    for (r2 = 0; r2 < u2.length; r2++)
      n2 = u2[r2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, n2) && (i2[n2] = e20[n2]);
  }
  return i2;
}
var _n$2 = Array.isArray || function(e20) {
  return v$3(e20) == "Array";
}, Mn$2 = function(e20, t2, n2) {
  if (et$3(e20), t2 === void 0)
    return e20;
  switch (n2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(n3) {
        return e20.call(t2, n3);
      };
    case 2:
      return function(n3, r2) {
        return e20.call(t2, n3, r2);
      };
    case 3:
      return function(n3, r2, i2) {
        return e20.call(t2, n3, r2, i2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, Rn$2 = function(e20, t2, n2, r2, i2, u2, o2, s2) {
  for (var a2, c2 = i2, l2 = 0, p2 = !!o2 && Mn$2(o2, s2, 3); l2 < r2; ) {
    if (l2 in n2) {
      if (a2 = p2 ? p2(n2[l2], l2, t2) : n2[l2], u2 > 0 && _n$2(a2))
        c2 = Rn$2(e20, t2, a2, Le$3(a2.length), c2, u2 - 1) - 1;
      else {
        if (c2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[c2] = a2;
      }
      c2++;
    }
    l2++;
  }
  return c2;
}, $n$2 = Rn$2, Vn$2 = Q$3("species"), Wn$2 = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return _n$2(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !_n$2(t3.prototype) ? T$3(t3) && (t3 = t3[Vn$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
Ze$3({target: "Array", proto: true}, {flatMap: function(e20) {
  var t2, n2 = q$3(this), r2 = Le$3(n2.length);
  return et$3(e20), (t2 = Wn$2(n2, 0)).length = $n$2(t2, n2, n2, r2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
}});
var qn$2 = {}, Un$2 = Q$3("iterator"), zn$2 = Array.prototype, Gn$2 = {};
Gn$2[Q$3("toStringTag")] = "z";
var Hn$2 = String(Gn$2) === "[object z]", Jn$2 = Q$3("toStringTag"), Xn$2 = v$3(function() {
  return arguments;
}()) == "Arguments", Yn$2 = Hn$2 ? v$3 : function(e20) {
  var t2, n2, r2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (n2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), Jn$2)) == "string" ? n2 : Xn$2 ? v$3(t2) : (r2 = v$3(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
}, Kn$2 = Q$3("iterator"), Qn$2 = function(e20) {
  if (e20 != null)
    return e20[Kn$2] || e20["@@iterator"] || qn$2[Yn$2(e20)];
}, Zn$2 = function(e20, t2, n2) {
  var r2, i2;
  se$3(e20);
  try {
    if ((r2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw n2;
      return n2;
    }
    r2 = r2.call(e20);
  } catch (e21) {
    i2 = true, r2 = e21;
  }
  if (t2 === "throw")
    throw n2;
  if (i2)
    throw r2;
  return se$3(r2), n2;
}, er$2 = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, tr$2 = function(e20, t2, n2) {
  var r2, i2, u2, o2, s2, a2, c2, l2, p2 = n2 && n2.that, f2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), h2 = !(!n2 || !n2.INTERRUPTED), g2 = Mn$2(t2, p2, 1 + f2 + h2), m2 = function(e21) {
    return r2 && Zn$2(r2, "normal", e21), new er$2(true, e21);
  }, y2 = function(e21) {
    return f2 ? (se$3(e21), h2 ? g2(e21[0], e21[1], m2) : g2(e21[0], e21[1])) : h2 ? g2(e21, m2) : g2(e21);
  };
  if (d2)
    r2 = e20;
  else {
    if (typeof (i2 = Qn$2(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((l2 = i2) !== void 0 && (qn$2.Array === l2 || zn$2[Un$2] === l2)) {
      for (u2 = 0, o2 = Le$3(e20.length); o2 > u2; u2++)
        if ((s2 = y2(e20[u2])) && s2 instanceof er$2)
          return s2;
      return new er$2(false);
    }
    r2 = function(e21, t3) {
      var n3 = arguments.length < 2 ? Qn$2(e21) : t3;
      if (typeof n3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return se$3(n3.call(e21));
    }(e20, i2);
  }
  for (a2 = r2.next; !(c2 = a2.call(r2)).done; ) {
    try {
      s2 = y2(c2.value);
    } catch (e21) {
      Zn$2(r2, "throw", e21);
    }
    if (typeof s2 == "object" && s2 && s2 instanceof er$2)
      return s2;
  }
  return new er$2(false);
};
Ze$3({target: "Object", stat: true}, {fromEntries: function(e20) {
  var t2 = {};
  return tr$2(e20, function(e21, n2) {
    !function(e22, t3, n3) {
      var r2 = te$3(t3);
      r2 in e22 ? ce$3.f(e22, r2, b$3(0, n3)) : e22[r2] = n3;
    }(t2, e21, n2);
  }, {AS_ENTRIES: true}), t2;
}});
var nr$2 = nr$2 !== void 0 ? nr$2 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
function rr$2() {
  throw new Error("setTimeout has not been defined");
}
function ir$2() {
  throw new Error("clearTimeout has not been defined");
}
var ur$2 = rr$2, or$2 = ir$2;
function sr$2(e20) {
  if (ur$2 === setTimeout)
    return setTimeout(e20, 0);
  if ((ur$2 === rr$2 || !ur$2) && setTimeout)
    return ur$2 = setTimeout, setTimeout(e20, 0);
  try {
    return ur$2(e20, 0);
  } catch (t2) {
    try {
      return ur$2.call(null, e20, 0);
    } catch (t3) {
      return ur$2.call(this, e20, 0);
    }
  }
}
typeof nr$2.setTimeout == "function" && (ur$2 = setTimeout), typeof nr$2.clearTimeout == "function" && (or$2 = clearTimeout);
var ar$2, cr$2 = [], lr$2 = false, pr$2 = -1;
function fr$2() {
  lr$2 && ar$2 && (lr$2 = false, ar$2.length ? cr$2 = ar$2.concat(cr$2) : pr$2 = -1, cr$2.length && dr$2());
}
function dr$2() {
  if (!lr$2) {
    var e20 = sr$2(fr$2);
    lr$2 = true;
    for (var t2 = cr$2.length; t2; ) {
      for (ar$2 = cr$2, cr$2 = []; ++pr$2 < t2; )
        ar$2 && ar$2[pr$2].run();
      pr$2 = -1, t2 = cr$2.length;
    }
    ar$2 = null, lr$2 = false, function(e21) {
      if (or$2 === clearTimeout)
        return clearTimeout(e21);
      if ((or$2 === ir$2 || !or$2) && clearTimeout)
        return or$2 = clearTimeout, clearTimeout(e21);
      try {
        or$2(e21);
      } catch (t3) {
        try {
          return or$2.call(null, e21);
        } catch (t4) {
          return or$2.call(this, e21);
        }
      }
    }(e20);
  }
}
function hr$2(e20, t2) {
  this.fun = e20, this.array = t2;
}
hr$2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function gr$2() {
}
var mr$2 = gr$2, yr$2 = gr$2, Dr$2 = gr$2, Er$2 = gr$2, Cr$2 = gr$2, br$2 = gr$2, Ar$2 = gr$2;
var vr$2 = nr$2.performance || {}, Fr$2 = vr$2.now || vr$2.mozNow || vr$2.msNow || vr$2.oNow || vr$2.webkitNow || function() {
  return new Date().getTime();
};
var Sr$2 = new Date();
var xr$2 = {nextTick: function(e20) {
  var t2 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n2 = 1; n2 < arguments.length; n2++)
      t2[n2 - 1] = arguments[n2];
  cr$2.push(new hr$2(e20, t2)), cr$2.length !== 1 || lr$2 || sr$2(dr$2);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: mr$2, addListener: yr$2, once: Dr$2, off: Er$2, removeListener: Cr$2, removeAllListeners: br$2, emit: Ar$2, binding: function(e20) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e20) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e20) {
  var t2 = 1e-3 * Fr$2.call(vr$2), n2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
  return e20 && (n2 -= e20[0], (r2 -= e20[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (new Date() - Sr$2) / 1e3;
}};
var wr$2 = typeof xr$2 == "object" && xr$2.env && xr$2.env.NODE_DEBUG && /\bsemver\b/i.test(xr$2.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
};
var Tr$2 = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, Br$2 = r$3(function(e20, t2) {
  const {MAX_SAFE_COMPONENT_LENGTH: n2} = Tr$2, r2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], u2 = t2.t = {};
  let o2 = 0;
  const s2 = (e21, t3, n3) => {
    const s3 = o2++;
    wr$2(s3, t3), u2[e21] = s3, i2[s3] = t3, r2[s3] = new RegExp(t3, n3 ? "g" : void 0);
  };
  s2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s2("MAINVERSION", `(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})`), s2("MAINVERSIONLOOSE", `(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})`), s2("PRERELEASEIDENTIFIER", `(?:${i2[u2.NUMERICIDENTIFIER]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[u2.NUMERICIDENTIFIERLOOSE]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASE", `(?:-(${i2[u2.PRERELEASEIDENTIFIER]}(?:\\.${i2[u2.PRERELEASEIDENTIFIER]})*))`), s2("PRERELEASELOOSE", `(?:-?(${i2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), s2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s2("BUILD", `(?:\\+(${i2[u2.BUILDIDENTIFIER]}(?:\\.${i2[u2.BUILDIDENTIFIER]})*))`), s2("FULLPLAIN", `v?${i2[u2.MAINVERSION]}${i2[u2.PRERELEASE]}?${i2[u2.BUILD]}?`), s2("FULL", `^${i2[u2.FULLPLAIN]}$`), s2("LOOSEPLAIN", `[v=\\s]*${i2[u2.MAINVERSIONLOOSE]}${i2[u2.PRERELEASELOOSE]}?${i2[u2.BUILD]}?`), s2("LOOSE", `^${i2[u2.LOOSEPLAIN]}$`), s2("GTLT", "((?:<|>)?=?)"), s2("XRANGEIDENTIFIERLOOSE", `${i2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s2("XRANGEIDENTIFIER", `${i2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), s2("XRANGEPLAIN", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:${i2[u2.PRERELEASE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:${i2[u2.PRERELEASELOOSE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAIN]}$`), s2("XRANGELOOSE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), s2("COERCERTL", i2[u2.COERCE], true), s2("LONETILDE", "(?:~>?)"), s2("TILDETRIM", `(\\s*)${i2[u2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", s2("TILDE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAIN]}$`), s2("TILDELOOSE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("LONECARET", "(?:\\^)"), s2("CARETTRIM", `(\\s*)${i2[u2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", s2("CARET", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAIN]}$`), s2("CARETLOOSE", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COMPARATORLOOSE", `^${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]})$|^$`), s2("COMPARATOR", `^${i2[u2.GTLT]}\\s*(${i2[u2.FULLPLAIN]})$|^$`), s2("COMPARATORTRIM", `(\\s*)${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]}|${i2[u2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", s2("HYPHENRANGE", `^\\s*(${i2[u2.XRANGEPLAIN]})\\s+-\\s+(${i2[u2.XRANGEPLAIN]})\\s*$`), s2("HYPHENRANGELOOSE", `^\\s*(${i2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[u2.XRANGEPLAINLOOSE]})\\s*$`), s2("STAR", "(<|>)?=?\\s*\\*"), s2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), s2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const Nr$2 = ["includePrerelease", "loose", "rtl"];
var kr$2 = (e20) => e20 ? typeof e20 != "object" ? {loose: true} : Nr$2.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
const Pr$2 = /^[0-9]+$/, Or$2 = (e20, t2) => {
  const n2 = Pr$2.test(e20), r2 = Pr$2.test(t2);
  return n2 && r2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e20 < t2 ? -1 : 1;
};
var Ir$2 = {compareIdentifiers: Or$2, rcompareIdentifiers: (e20, t2) => Or$2(t2, e20)};
const {MAX_LENGTH: Lr$2, MAX_SAFE_INTEGER: jr$2} = Tr$2, {re: _r$2, t: Mr$2} = Br$2, {compareIdentifiers: Rr$2} = Ir$2;
class $r$2 {
  constructor(e20, t2) {
    if (t2 = kr$2(t2), e20 instanceof $r$2) {
      if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
        return e20;
      e20 = e20.version;
    } else if (typeof e20 != "string")
      throw new TypeError(`Invalid Version: ${e20}`);
    if (e20.length > Lr$2)
      throw new TypeError(`version is longer than ${Lr$2} characters`);
    wr$2("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
    const n2 = e20.trim().match(t2.loose ? _r$2[Mr$2.LOOSE] : _r$2[Mr$2.FULL]);
    if (!n2)
      throw new TypeError(`Invalid Version: ${e20}`);
    if (this.raw = e20, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > jr$2 || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > jr$2 || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > jr$2 || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n2[4] ? this.prerelease = n2[4].split(".").map((e21) => {
      if (/^[0-9]+$/.test(e21)) {
        const t3 = +e21;
        if (t3 >= 0 && t3 < jr$2)
          return t3;
      }
      return e21;
    }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e20) {
    if (wr$2("SemVer.compare", this.version, this.options, e20), !(e20 instanceof $r$2)) {
      if (typeof e20 == "string" && e20 === this.version)
        return 0;
      e20 = new $r$2(e20, this.options);
    }
    return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
  }
  compareMain(e20) {
    return e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options)), Rr$2(this.major, e20.major) || Rr$2(this.minor, e20.minor) || Rr$2(this.patch, e20.patch);
  }
  comparePre(e20) {
    if (e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
      return -1;
    if (!this.prerelease.length && e20.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e20.prerelease.length)
      return 0;
    let t2 = 0;
    do {
      const n2 = this.prerelease[t2], r2 = e20.prerelease[t2];
      if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (n2 === void 0)
        return -1;
      if (n2 !== r2)
        return Rr$2(n2, r2);
    } while (++t2);
  }
  compareBuild(e20) {
    e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options));
    let t2 = 0;
    do {
      const n2 = this.build[t2], r2 = e20.build[t2];
      if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (n2 === void 0)
        return -1;
      if (n2 !== r2)
        return Rr$2(n2, r2);
    } while (++t2);
  }
  inc(e20, t2) {
    switch (e20) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let e21 = this.prerelease.length;
          for (; --e21 >= 0; )
            typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
          e21 === -1 && this.prerelease.push(0);
        }
        t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e20}`);
    }
    return this.format(), this.raw = this.version, this;
  }
}
var Vr$2 = $r$2;
var Wr$2 = (e20, t2, n2) => new Vr$2(e20, n2).compare(new Vr$2(t2, n2));
var qr$2 = (e20, t2, n2) => Wr$2(e20, t2, n2) < 0;
var Ur$2 = (e20, t2, n2) => Wr$2(e20, t2, n2) >= 0, zr$2 = r$3(function(e20, t2) {
  function n2() {
    for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
      e21[t3] = arguments[t3];
  }
  function r2() {
    return typeof WeakMap != "undefined" ? new WeakMap() : {add: n2, delete: n2, get: n2, set: n2, has: function(e21) {
      return false;
    }};
  }
  Object.defineProperty(t2, "__esModule", {value: true}), t2.outdent = void 0;
  var i2 = Object.prototype.hasOwnProperty, u2 = function(e21, t3) {
    return i2.call(e21, t3);
  };
  function o2(e21, t3) {
    for (var n3 in t3)
      u2(t3, n3) && (e21[n3] = t3[n3]);
    return e21;
  }
  var s2 = /^[ \t]*(?:\r\n|\r|\n)/, a2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function f2(e21, t3, n3) {
    var r3 = 0, i3 = e21[0].match(l2);
    i3 && (r3 = i3[1].length);
    var u3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
    t3 && (e21 = e21.slice(1));
    var o3 = n3.newline, c3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, f3 = typeof o3 == "string", d3 = e21.length;
    return e21.map(function(e22, t4) {
      return e22 = e22.replace(u3, "$1"), t4 === 0 && c3 && (e22 = e22.replace(s2, "")), t4 === d3 - 1 && p3 && (e22 = e22.replace(a2, "")), f3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
        return o3;
      })), e22;
    });
  }
  function d2(e21, t3) {
    for (var n3 = "", r3 = 0, i3 = e21.length; r3 < i3; r3++)
      n3 += e21[r3], r3 < i3 - 1 && (n3 += t3[r3]);
    return n3;
  }
  function h2(e21) {
    return u2(e21, "raw") && u2(e21, "length");
  }
  var g2 = function e21(t3) {
    var n3 = r2(), i3 = r2();
    return o2(function r3(u3) {
      for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
        s3[a3 - 1] = arguments[a3];
      if (h2(u3)) {
        var l3 = u3, m2 = (s3[0] === r3 || s3[0] === g2) && p2.test(l3[0]) && c2.test(l3[1]), y2 = m2 ? i3 : n3, D2 = y2.get(l3);
        if (D2 || (D2 = f2(l3, m2, t3), y2.set(l3, D2)), s3.length === 0)
          return D2[0];
        var E2 = d2(D2, m2 ? s3.slice(1) : s3);
        return E2;
      }
      return e21(o2(o2({}, t3), u3 || {}));
    }, {string: function(e22) {
      return f2([e22], false, t3)[0];
    }});
  }({trimLeadingNewline: true, trimTrailingNewline: true});
  t2.outdent = g2, t2.default = g2;
  try {
    e20.exports = g2, Object.defineProperty(g2, "__esModule", {value: true}), g2.default = g2, g2.outdent = g2;
  } catch (e21) {
  }
});
const {outdent: Gr$2} = zr$2, Hr$2 = {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: Gr$2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: Gr$2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e20) => typeof e20 == "string" || typeof e20 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: Gr$2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Gr$2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Gr$2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: Gr$2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
const Jr$2 = ["cliName", "cliCategory", "cliDescription"], Xr$2 = {compare: Wr$2, lt: qr$2, gte: Ur$2}, Yr$2 = e$3.version, Kr$2 = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: Hr$2}.options;
var Qr$2 = {getSupportInfo: function({plugins: e20 = [], showUnreleased: t2 = false, showDeprecated: n2 = false, showInternal: r2 = false} = {}) {
  const i2 = Yr$2.split("-", 1)[0], u2 = e20.flatMap((e21) => e21.languages || []).filter(s2), o2 = ((e21, t3) => Object.entries(e21).map(([e22, n3]) => Object.assign({[t3]: e22}, n3)))(Object.assign({}, ...e20.map(({options: e21}) => e21), Kr$2), "name").filter((e21) => s2(e21) && a2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
    if (r2)
      return e21;
    return jn$2(e21, Jr$2);
  }).map((t3) => {
    t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(s2).sort((e21, t4) => Xr$2.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => s2(e21) && a2(e21)), t3.name === "parser" && function(e21, t4, n4) {
      const r3 = new Set(e21.choices.map((e22) => e22.value));
      for (const i3 of t4)
        if (i3.parsers) {
          for (const t5 of i3.parsers)
            if (!r3.has(t5)) {
              r3.add(t5);
              const u3 = n4.find((e22) => e22.parsers && e22.parsers[t5]);
              let o3 = i3.name;
              u3 && u3.name && (o3 += ` (plugin: ${u3.name})`), e21.choices.push({value: t5, description: o3});
            }
        }
    }(t3, u2, e20));
    const n3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
    return Object.assign(Object.assign({}, t3), {}, {pluginDefaults: n3});
  });
  return {languages: u2, options: o2};
  function s2(e21) {
    return t2 || !("since" in e21) || e21.since && Xr$2.gte(i2, e21.since);
  }
  function a2(e21) {
    return n2 || !("deprecated" in e21) || e21.deprecated && Xr$2.lt(i2, e21.deprecated);
  }
}};
const {getSupportInfo: Zr$2} = Qr$2, ei$2 = /[^\x20-\x7F]/;
function ti$2(e20) {
  return (t2, n2, r2) => {
    const i2 = r2 && r2.backwards;
    if (n2 === false)
      return false;
    const {length: u2} = t2;
    let o2 = n2;
    for (; o2 >= 0 && o2 < u2; ) {
      const n3 = t2.charAt(o2);
      if (e20 instanceof RegExp) {
        if (!e20.test(n3))
          return o2;
      } else if (!e20.includes(n3))
        return o2;
      i2 ? o2-- : o2++;
    }
    return (o2 === -1 || o2 === u2) && o2;
  };
}
const ni$2 = ti$2(/\s/), ri$2 = ti$2(" 	"), ii$2 = ti$2(",; 	"), ui$2 = ti$2(/[^\n\r]/);
function oi$2(e20, t2) {
  if (t2 === false)
    return false;
  if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
    for (let n2 = t2 + 2; n2 < e20.length; ++n2)
      if (e20.charAt(n2) === "*" && e20.charAt(n2 + 1) === "/")
        return n2 + 2;
  }
  return t2;
}
function si$2(e20, t2) {
  return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? ui$2(e20, t2) : t2);
}
function ai$2(e20, t2, n2) {
  const r2 = n2 && n2.backwards;
  if (t2 === false)
    return false;
  const i2 = e20.charAt(t2);
  if (r2) {
    if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
      return t2 - 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 - 1;
  } else {
    if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
      return t2 + 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
function ci$2(e20, t2, n2 = {}) {
  const r2 = ri$2(e20, n2.backwards ? t2 - 1 : t2, n2);
  return r2 !== ai$2(e20, r2, n2);
}
function li$2(e20, t2) {
  let n2 = null, r2 = t2;
  for (; r2 !== n2; )
    n2 = r2, r2 = ii$2(e20, r2), r2 = oi$2(e20, r2), r2 = ri$2(e20, r2);
  return r2 = si$2(e20, r2), r2 = ai$2(e20, r2), r2 !== false && ci$2(e20, r2);
}
function pi$2(e20, t2) {
  let n2 = null, r2 = t2;
  for (; r2 !== n2; )
    n2 = r2, r2 = ri$2(e20, r2), r2 = oi$2(e20, r2), r2 = si$2(e20, r2), r2 = ai$2(e20, r2);
  return r2;
}
function fi$2(e20, t2, n2) {
  return pi$2(e20, n2(t2));
}
function di$2(e20, t2, n2 = 0) {
  let r2 = 0;
  for (let i2 = n2; i2 < e20.length; ++i2)
    e20[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
  return r2;
}
function hi$2(e20, t2) {
  const n2 = e20.slice(1, -1), r2 = {quote: '"', regex: /"/g}, i2 = {quote: "'", regex: /'/g}, u2 = t2 === "'" ? i2 : r2, o2 = u2 === i2 ? r2 : i2;
  let s2 = u2.quote;
  if (n2.includes(u2.quote) || n2.includes(o2.quote)) {
    s2 = (n2.match(u2.regex) || []).length > (n2.match(o2.regex) || []).length ? o2.quote : u2.quote;
  }
  return s2;
}
function gi$2(e20, t2, n2) {
  const r2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, u2) => i3 === r2 ? i3 : u2 === t2 ? "\\" + u2 : u2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
  return t2 + i2 + t2;
}
function mi$2(e20, t2) {
  (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
    const t3 = e21.type || e21.kind || "(unknown type)";
    let n2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
    n2.length > 20 && (n2 = n2.slice(0, 19) + "\u2026");
    return t3 + (n2 ? " " + n2 : "");
  }(e20);
}
var yi$2 = {inferParserByLanguage: function(e20, t2) {
  const {languages: n2} = Zr$2({plugins: t2.plugins}), r2 = n2.find(({name: t3}) => t3.toLowerCase() === e20) || n2.find(({aliases: t3}) => Array.isArray(t3) && t3.includes(e20)) || n2.find(({extensions: t3}) => Array.isArray(t3) && t3.includes(`.${e20}`));
  return r2 && r2.parsers[0];
}, getStringWidth: function(e20) {
  return e20 ? ei$2.test(e20) ? Pn$2(e20) : e20.length : 0;
}, getMaxContinuousCount: function(e20, t2) {
  const n2 = e20.match(new RegExp(`(${In$2(t2)})+`, "g"));
  return n2 === null ? 0 : n2.reduce((e21, n3) => Math.max(e21, n3.length / t2.length), 0);
}, getMinNotPresentContinuousCount: function(e20, t2) {
  const n2 = e20.match(new RegExp(`(${In$2(t2)})+`, "g"));
  if (n2 === null)
    return 0;
  const r2 = new Map();
  let i2 = 0;
  for (const e21 of n2) {
    const n3 = e21.length / t2.length;
    r2.set(n3, true), n3 > i2 && (i2 = n3);
  }
  for (let e21 = 1; e21 < i2; e21++)
    if (!r2.get(e21))
      return e21;
  return i2 + 1;
}, getPenultimate: (e20) => e20[e20.length - 2], getLast: Ln$2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: pi$2, getNextNonSpaceNonCommentCharacterIndex: fi$2, getNextNonSpaceNonCommentCharacter: function(e20, t2, n2) {
  return e20.charAt(fi$2(e20, t2, n2));
}, skip: ti$2, skipWhitespace: ni$2, skipSpaces: ri$2, skipToLineEnd: ii$2, skipEverythingButNewLine: ui$2, skipInlineComment: oi$2, skipTrailingComment: si$2, skipNewline: ai$2, isNextLineEmptyAfterIndex: li$2, isNextLineEmpty: function(e20, t2, n2) {
  return li$2(e20, n2(t2));
}, isPreviousLineEmpty: function(e20, t2, n2) {
  let r2 = n2(t2) - 1;
  return r2 = ri$2(e20, r2, {backwards: true}), r2 = ai$2(e20, r2, {backwards: true}), r2 = ri$2(e20, r2, {backwards: true}), r2 !== ai$2(e20, r2, {backwards: true});
}, hasNewline: ci$2, hasNewlineInRange: function(e20, t2, n2) {
  for (let r2 = t2; r2 < n2; ++r2)
    if (e20.charAt(r2) === "\n")
      return true;
  return false;
}, hasSpaces: function(e20, t2, n2 = {}) {
  return ri$2(e20, n2.backwards ? t2 - 1 : t2, n2) !== t2;
}, getAlignmentSize: di$2, getIndentSize: function(e20, t2) {
  const n2 = e20.lastIndexOf("\n");
  return n2 === -1 ? 0 : di$2(e20.slice(n2 + 1).match(/^[\t ]*/)[0], t2);
}, getPreferredQuote: hi$2, printString: function(e20, t2) {
  return gi$2(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : hi$2(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
}, printNumber: function(e20) {
  return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}, makeString: gi$2, addLeadingComment: function(e20, t2) {
  t2.leading = true, t2.trailing = false, mi$2(e20, t2);
}, addDanglingComment: function(e20, t2, n2) {
  t2.leading = false, t2.trailing = false, n2 && (t2.marker = n2), mi$2(e20, t2);
}, addTrailingComment: function(e20, t2) {
  t2.leading = false, t2.trailing = true, mi$2(e20, t2);
}, isFrontMatterNode: function(e20) {
  return e20 && e20.type === "front-matter";
}, getShebang: function(e20) {
  if (!e20.startsWith("#!"))
    return "";
  const t2 = e20.indexOf("\n");
  return t2 === -1 ? e20 : e20.slice(0, t2);
}, isNonEmptyArray: function(e20) {
  return Array.isArray(e20) && e20.length > 0;
}, createGroupIdMapper: function(e20) {
  const t2 = new WeakMap();
  return function(n2) {
    return t2.has(n2) || t2.set(n2, Symbol(e20)), t2.get(n2);
  };
}};
var Di$2 = {guessEndOfLine: function(e20) {
  const t2 = e20.indexOf("\r");
  return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
}, convertEndOfLineToChars: function(e20) {
  switch (e20) {
    case "cr":
      return "\r";
    case "crlf":
      return "\r\n";
    default:
      return "\n";
  }
}, countEndOfLineChars: function(e20, t2) {
  let n2;
  if (t2 === "\n")
    n2 = /\n/g;
  else if (t2 === "\r")
    n2 = /\r/g;
  else {
    if (t2 !== "\r\n")
      throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
    n2 = /\r\n/g;
  }
  const r2 = e20.match(n2);
  return r2 ? r2.length : 0;
}, normalizeEndOfLine: function(e20) {
  return e20.replace(/\r\n?/g, "\n");
}};
const {literalline: Ei$2, join: Ci$2} = xn$2, bi$2 = (e20) => Array.isArray(e20) || e20 && e20.type === "concat", Ai$2 = (e20) => {
  if (Array.isArray(e20))
    return e20;
  if (e20.type !== "concat" && e20.type !== "fill")
    throw new Error("Expect doc type to be `concat` or `fill`.");
  return e20.parts;
}, vi$2 = {};
function Fi$2(e20, t2, n2, r2) {
  const i2 = [e20];
  for (; i2.length > 0; ) {
    const e21 = i2.pop();
    if (e21 !== vi$2) {
      if (n2 && i2.push(e21, vi$2), !t2 || t2(e21) !== false)
        if (bi$2(e21) || e21.type === "fill") {
          const t3 = Ai$2(e21);
          for (let e22 = t3.length - 1; e22 >= 0; --e22)
            i2.push(t3[e22]);
        } else if (e21.type === "if-break")
          e21.flatContents && i2.push(e21.flatContents), e21.breakContents && i2.push(e21.breakContents);
        else if (e21.type === "group" && e21.expandedStates)
          if (r2)
            for (let t3 = e21.expandedStates.length - 1; t3 >= 0; --t3)
              i2.push(e21.expandedStates[t3]);
          else
            i2.push(e21.contents);
        else
          e21.contents && i2.push(e21.contents);
    } else
      n2(i2.pop());
  }
}
function Si$2(e20, t2) {
  const n2 = new Map();
  return r2(e20);
  function r2(e21) {
    if (n2.has(e21))
      return n2.get(e21);
    const i2 = function(e22) {
      if (Array.isArray(e22))
        return t2(e22.map(r2));
      if (e22.type === "concat" || e22.type === "fill") {
        const n3 = e22.parts.map(r2);
        return t2(Object.assign(Object.assign({}, e22), {}, {parts: n3}));
      }
      if (e22.type === "if-break") {
        const n3 = e22.breakContents && r2(e22.breakContents), i3 = e22.flatContents && r2(e22.flatContents);
        return t2(Object.assign(Object.assign({}, e22), {}, {breakContents: n3, flatContents: i3}));
      }
      if (e22.type === "group" && e22.expandedStates) {
        const n3 = e22.expandedStates.map(r2), i3 = n3[0];
        return t2(Object.assign(Object.assign({}, e22), {}, {contents: i3, expandedStates: n3}));
      }
      if (e22.contents) {
        const n3 = r2(e22.contents);
        return t2(Object.assign(Object.assign({}, e22), {}, {contents: n3}));
      }
      return t2(e22);
    }(e21);
    return n2.set(e21, i2), i2;
  }
}
function xi$2(e20, t2, n2) {
  let r2 = n2, i2 = false;
  return Fi$2(e20, function(e21) {
    const n3 = t2(e21);
    if (n3 !== void 0 && (i2 = true, r2 = n3), i2)
      return false;
  }), r2;
}
function wi$2(e20) {
  return !(e20.type !== "group" || !e20.break) || (!(e20.type !== "line" || !e20.hard) || (e20.type === "break-parent" || void 0));
}
function Ti$2(e20) {
  if (e20.length > 0) {
    const t2 = Ln$2(e20);
    t2.expandedStates || t2.break || (t2.break = "propagated");
  }
  return null;
}
function Bi$2(e20) {
  return e20.type !== "line" || e20.hard ? e20.type === "if-break" ? e20.flatContents || "" : e20 : e20.soft ? "" : " ";
}
const Ni$2 = (e20, t2) => e20 && e20.type === "line" && e20.hard && t2 && t2.type === "break-parent";
function ki$2(e20) {
  if (!e20)
    return e20;
  if (bi$2(e20) || e20.type === "fill") {
    const t2 = Ai$2(e20);
    for (; t2.length > 1 && Ni$2(...t2.slice(-2)); )
      t2.length -= 2;
    if (t2.length > 0) {
      const e21 = ki$2(Ln$2(t2));
      t2[t2.length - 1] = e21;
    }
    return Array.isArray(e20) ? t2 : Object.assign(Object.assign({}, e20), {}, {parts: t2});
  }
  switch (e20.type) {
    case "align":
    case "indent":
    case "indent-if-break":
    case "group":
    case "line-suffix":
    case "label": {
      const t2 = ki$2(e20.contents);
      return Object.assign(Object.assign({}, e20), {}, {contents: t2});
    }
    case "if-break": {
      const t2 = ki$2(e20.breakContents), n2 = ki$2(e20.flatContents);
      return Object.assign(Object.assign({}, e20), {}, {breakContents: t2, flatContents: n2});
    }
  }
  return e20;
}
function Pi$2(e20) {
  return Si$2(e20, (e21) => function(e22) {
    switch (e22.type) {
      case "fill":
        if (e22.parts.length === 0 || e22.parts.every((e23) => e23 === ""))
          return "";
        break;
      case "group":
        if (!(e22.contents || e22.id || e22.break || e22.expandedStates))
          return "";
        if (e22.contents.type === "group" && e22.contents.id === e22.id && e22.contents.break === e22.break && e22.contents.expandedStates === e22.expandedStates)
          return e22.contents;
        break;
      case "align":
      case "indent":
      case "indent-if-break":
      case "line-suffix":
        if (!e22.contents)
          return "";
        break;
      case "if-break":
        if (!e22.flatContents && !e22.breakContents)
          return "";
    }
    if (!bi$2(e22))
      return e22;
    const t2 = [];
    for (const n2 of Ai$2(e22)) {
      if (!n2)
        continue;
      const [e23, ...r2] = bi$2(n2) ? Ai$2(n2) : [n2];
      typeof e23 == "string" && typeof Ln$2(t2) == "string" ? t2[t2.length - 1] += e23 : t2.push(e23), t2.push(...r2);
    }
    return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e22) ? t2 : Object.assign(Object.assign({}, e22), {}, {parts: t2});
  }(e21));
}
function Oi$2(e20) {
  const t2 = [], n2 = e20.filter(Boolean);
  for (; n2.length > 0; ) {
    const e21 = n2.shift();
    e21 && (bi$2(e21) ? n2.unshift(...Ai$2(e21)) : t2.length > 0 && typeof Ln$2(t2) == "string" && typeof e21 == "string" ? t2[t2.length - 1] += e21 : t2.push(e21));
  }
  return t2;
}
function Ii$2(e20, t2 = Ei$2) {
  return Ci$2(t2, e20.split("\n")).parts;
}
var Li$2 = {isConcat: bi$2, getDocParts: Ai$2, willBreak: function(e20) {
  return xi$2(e20, wi$2, false);
}, traverseDoc: Fi$2, findInDoc: xi$2, mapDoc: Si$2, propagateBreaks: function(e20) {
  const t2 = new Set(), n2 = [];
  Fi$2(e20, function(e21) {
    if (e21.type === "break-parent" && Ti$2(n2), e21.type === "group") {
      if (n2.push(e21), t2.has(e21))
        return false;
      t2.add(e21);
    }
  }, function(e21) {
    if (e21.type === "group") {
      n2.pop().break && Ti$2(n2);
    }
  }, true);
}, removeLines: function(e20) {
  return Si$2(e20, Bi$2);
}, stripTrailingHardline: function(e20) {
  return ki$2(Pi$2(e20));
}, normalizeParts: Oi$2, normalizeDoc: function(e20) {
  return Si$2(e20, (e21) => Array.isArray(e21) ? Oi$2(e21) : e21.parts ? Object.assign(Object.assign({}, e21), {}, {parts: Oi$2(e21.parts)}) : e21);
}, cleanDoc: Pi$2, replaceTextEndOfLine: Ii$2, replaceEndOfLine: function(e20) {
  return Si$2(e20, (e21) => typeof e21 == "string" && e21.includes("\n") ? Ii$2(e21) : e21);
}};
const {getStringWidth: ji$2, getLast: _i$2} = yi$2, {convertEndOfLineToChars: Mi$2} = Di$2, {fill: Ri$2, cursor: $i$2, indent: Vi$2} = xn$2, {isConcat: Wi$2, getDocParts: qi$2} = Li$2;
let Ui$2;
function zi$2(e20, t2) {
  return Hi$2(e20, {type: "indent"}, t2);
}
function Gi$2(e20, t2, n2) {
  if (t2 === Number.NEGATIVE_INFINITY)
    return e20.root || {value: "", length: 0, queue: []};
  if (t2 < 0)
    return Hi$2(e20, {type: "dedent"}, n2);
  if (!t2)
    return e20;
  if (t2.type === "root")
    return Object.assign(Object.assign({}, e20), {}, {root: e20});
  return Hi$2(e20, {type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2}, n2);
}
function Hi$2(e20, t2, n2) {
  const r2 = t2.type === "dedent" ? e20.queue.slice(0, -1) : [...e20.queue, t2];
  let i2 = "", u2 = 0, o2 = 0, s2 = 0;
  for (const e21 of r2)
    switch (e21.type) {
      case "indent":
        l2(), n2.useTabs ? a2(1) : c2(n2.tabWidth);
        break;
      case "stringAlign":
        l2(), i2 += e21.n, u2 += e21.n.length;
        break;
      case "numberAlign":
        o2 += 1, s2 += e21.n;
        break;
      default:
        throw new Error(`Unexpected type '${e21.type}'`);
    }
  return p2(), Object.assign(Object.assign({}, e20), {}, {value: i2, length: u2, queue: r2});
  function a2(e21) {
    i2 += "	".repeat(e21), u2 += n2.tabWidth * e21;
  }
  function c2(e21) {
    i2 += " ".repeat(e21), u2 += e21;
  }
  function l2() {
    n2.useTabs ? function() {
      o2 > 0 && a2(o2);
      f2();
    }() : p2();
  }
  function p2() {
    s2 > 0 && c2(s2), f2();
  }
  function f2() {
    o2 = 0, s2 = 0;
  }
}
function Ji$2(e20) {
  if (e20.length === 0)
    return 0;
  let t2 = 0;
  for (; e20.length > 0 && typeof _i$2(e20) == "string" && /^[\t ]*$/.test(_i$2(e20)); )
    t2 += e20.pop().length;
  if (e20.length > 0 && typeof _i$2(e20) == "string") {
    const n2 = _i$2(e20).replace(/[\t ]*$/, "");
    t2 += _i$2(e20).length - n2.length, e20[e20.length - 1] = n2;
  }
  return t2;
}
function Xi$2(e20, t2, n2, r2, i2, u2) {
  let o2 = t2.length;
  const s2 = [e20], a2 = [];
  for (; n2 >= 0; ) {
    if (s2.length === 0) {
      if (o2 === 0)
        return true;
      s2.push(t2[o2 - 1]), o2--;
      continue;
    }
    const [e21, c2, l2] = s2.pop();
    if (typeof l2 == "string")
      a2.push(l2), n2 -= ji$2(l2);
    else if (Wi$2(l2)) {
      const t3 = qi$2(l2);
      for (let n3 = t3.length - 1; n3 >= 0; n3--)
        s2.push([e21, c2, t3[n3]]);
    } else
      switch (l2.type) {
        case "indent":
          s2.push([zi$2(e21, r2), c2, l2.contents]);
          break;
        case "align":
          s2.push([Gi$2(e21, l2.n, r2), c2, l2.contents]);
          break;
        case "trim":
          n2 += Ji$2(a2);
          break;
        case "group": {
          if (u2 && l2.break)
            return false;
          const t3 = l2.break ? 1 : c2;
          s2.push([e21, t3, l2.expandedStates && t3 === 1 ? _i$2(l2.expandedStates) : l2.contents]), l2.id && (Ui$2[l2.id] = t3);
          break;
        }
        case "fill":
          for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
            s2.push([e21, c2, l2.parts[t3]]);
          break;
        case "if-break":
        case "indent-if-break": {
          const t3 = l2.groupId ? Ui$2[l2.groupId] : c2;
          if (t3 === 1) {
            const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
            t4 && s2.push([e21, c2, t4]);
          }
          if (t3 === 2) {
            const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
            t4 && s2.push([e21, c2, t4]);
          }
          break;
        }
        case "line":
          switch (c2) {
            case 2:
              if (!l2.hard) {
                l2.soft || (a2.push(" "), n2 -= 1);
                break;
              }
              return true;
            case 1:
              return true;
          }
          break;
        case "line-suffix":
          i2 = true;
          break;
        case "line-suffix-boundary":
          if (i2)
            return false;
          break;
        case "label":
          s2.push([e21, c2, l2.contents]);
      }
  }
  return false;
}
var Yi$2 = {printDocToString: function(e20, t2) {
  Ui$2 = {};
  const n2 = t2.printWidth, r2 = Mi$2(t2.endOfLine);
  let i2 = 0;
  const u2 = [[{value: "", length: 0, queue: []}, 1, e20]], o2 = [];
  let s2 = false, a2 = [];
  for (; u2.length > 0; ) {
    const [e21, c3, l2] = u2.pop();
    if (typeof l2 == "string") {
      const e22 = r2 !== "\n" ? l2.replace(/\n/g, r2) : l2;
      o2.push(e22), i2 += ji$2(e22);
    } else if (Wi$2(l2)) {
      const t3 = qi$2(l2);
      for (let n3 = t3.length - 1; n3 >= 0; n3--)
        u2.push([e21, c3, t3[n3]]);
    } else
      switch (l2.type) {
        case "cursor":
          o2.push($i$2.placeholder);
          break;
        case "indent":
          u2.push([zi$2(e21, t2), c3, l2.contents]);
          break;
        case "align":
          u2.push([Gi$2(e21, l2.n, t2), c3, l2.contents]);
          break;
        case "trim":
          i2 -= Ji$2(o2);
          break;
        case "group":
          switch (c3) {
            case 2:
              if (!s2) {
                u2.push([e21, l2.break ? 1 : 2, l2.contents]);
                break;
              }
            case 1: {
              s2 = false;
              const r3 = [e21, 2, l2.contents], o3 = n2 - i2, c4 = a2.length > 0;
              if (!l2.break && Xi$2(r3, u2, o3, t2, c4))
                u2.push(r3);
              else if (l2.expandedStates) {
                const n3 = _i$2(l2.expandedStates);
                if (l2.break) {
                  u2.push([e21, 1, n3]);
                  break;
                }
                for (let r4 = 1; r4 < l2.expandedStates.length + 1; r4++) {
                  if (r4 >= l2.expandedStates.length) {
                    u2.push([e21, 1, n3]);
                    break;
                  }
                  {
                    const n4 = [e21, 2, l2.expandedStates[r4]];
                    if (Xi$2(n4, u2, o3, t2, c4)) {
                      u2.push(n4);
                      break;
                    }
                  }
                }
              } else
                u2.push([e21, 1, l2.contents]);
              break;
            }
          }
          l2.id && (Ui$2[l2.id] = _i$2(u2)[1]);
          break;
        case "fill": {
          const r3 = n2 - i2, {parts: o3} = l2;
          if (o3.length === 0)
            break;
          const [s3, p2] = o3, f2 = [e21, 2, s3], d2 = [e21, 1, s3], h2 = Xi$2(f2, [], r3, t2, a2.length > 0, true);
          if (o3.length === 1) {
            h2 ? u2.push(f2) : u2.push(d2);
            break;
          }
          const g2 = [e21, 2, p2], m2 = [e21, 1, p2];
          if (o3.length === 2) {
            h2 ? u2.push(g2, f2) : u2.push(m2, d2);
            break;
          }
          o3.splice(0, 2);
          const y2 = [e21, c3, Ri$2(o3)];
          Xi$2([e21, 2, [s3, p2, o3[0]]], [], r3, t2, a2.length > 0, true) ? u2.push(y2, g2, f2) : h2 ? u2.push(y2, m2, f2) : u2.push(y2, m2, d2);
          break;
        }
        case "if-break":
        case "indent-if-break": {
          const t3 = l2.groupId ? Ui$2[l2.groupId] : c3;
          if (t3 === 1) {
            const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
            t4 && u2.push([e21, c3, t4]);
          }
          if (t3 === 2) {
            const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
            t4 && u2.push([e21, c3, t4]);
          }
          break;
        }
        case "line-suffix":
          a2.push([e21, c3, l2.contents]);
          break;
        case "line-suffix-boundary":
          a2.length > 0 && u2.push([e21, c3, {type: "line", hard: true}]);
          break;
        case "line":
          switch (c3) {
            case 2:
              if (!l2.hard) {
                l2.soft || (o2.push(" "), i2 += 1);
                break;
              }
              s2 = true;
            case 1:
              if (a2.length > 0) {
                u2.push([e21, c3, l2], ...a2.reverse()), a2 = [];
                break;
              }
              l2.literal ? e21.root ? (o2.push(r2, e21.root.value), i2 = e21.root.length) : (o2.push(r2), i2 = 0) : (i2 -= Ji$2(o2), o2.push(r2 + e21.value), i2 = e21.length);
          }
          break;
        case "label":
          u2.push([e21, c3, l2.contents]);
      }
    u2.length === 0 && a2.length > 0 && (u2.push(...a2.reverse()), a2 = []);
  }
  const c2 = o2.indexOf($i$2.placeholder);
  if (c2 !== -1) {
    const e21 = o2.indexOf($i$2.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), n3 = o2.slice(c2 + 1, e21).join("");
    return {formatted: t3 + n3 + o2.slice(e21 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: n3};
  }
  return {formatted: o2.join("")};
}};
const {isConcat: Ki$2, getDocParts: Qi$2} = Li$2;
function Zi$2(e20) {
  if (!e20)
    return "";
  if (Ki$2(e20)) {
    const t2 = [];
    for (const n2 of Qi$2(e20))
      if (Ki$2(n2))
        t2.push(...Zi$2(n2).parts);
      else {
        const e21 = Zi$2(n2);
        e21 !== "" && t2.push(e21);
      }
    return {type: "concat", parts: t2};
  }
  return e20.type === "if-break" ? Object.assign(Object.assign({}, e20), {}, {breakContents: Zi$2(e20.breakContents), flatContents: Zi$2(e20.flatContents)}) : e20.type === "group" ? Object.assign(Object.assign({}, e20), {}, {contents: Zi$2(e20.contents), expandedStates: e20.expandedStates && e20.expandedStates.map(Zi$2)}) : e20.type === "fill" ? {type: "fill", parts: e20.parts.map(Zi$2)} : e20.contents ? Object.assign(Object.assign({}, e20), {}, {contents: Zi$2(e20.contents)}) : e20;
}
var eu$1 = {builders: xn$2, printer: Yi$2, utils: Li$2, debug: {printDocToDebug: function(e20) {
  const t2 = Object.create(null), n2 = new Set();
  return function e21(t3, n3, i2) {
    if (typeof t3 == "string")
      return JSON.stringify(t3);
    if (Ki$2(t3)) {
      const n4 = Qi$2(t3).map(e21).filter(Boolean);
      return n4.length === 1 ? n4[0] : `[${n4.join(", ")}]`;
    }
    if (t3.type === "line") {
      const e22 = Array.isArray(i2) && i2[n3 + 1] && i2[n3 + 1].type === "break-parent";
      return t3.literal ? e22 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e22 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
    }
    if (t3.type === "break-parent") {
      return Array.isArray(i2) && i2[n3 - 1] && i2[n3 - 1].type === "line" && i2[n3 - 1].hard ? void 0 : "breakParent";
    }
    if (t3.type === "trim")
      return "trim";
    if (t3.type === "indent")
      return "indent(" + e21(t3.contents) + ")";
    if (t3.type === "align")
      return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e21(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e21(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e21(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e21(t3.contents) + ")";
    if (t3.type === "if-break")
      return "ifBreak(" + e21(t3.breakContents) + (t3.flatContents ? ", " + e21(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${r2(t3.groupId)} }` : "") + ")";
    if (t3.type === "indent-if-break") {
      const n4 = [];
      t3.negate && n4.push("negate: true"), t3.groupId && n4.push(`groupId: ${r2(t3.groupId)}`);
      const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
      return `indentIfBreak(${e21(t3.contents)}${i3})`;
    }
    if (t3.type === "group") {
      const n4 = [];
      t3.break && t3.break !== "propagated" && n4.push("shouldBreak: true"), t3.id && n4.push(`id: ${r2(t3.id)}`);
      const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
      return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e21(t4)).join(",")}]${i3})` : `group(${e21(t3.contents)}${i3})`;
    }
    if (t3.type === "fill")
      return `fill([${t3.parts.map((t4) => e21(t4)).join(", ")}])`;
    if (t3.type === "line-suffix")
      return "lineSuffix(" + e21(t3.contents) + ")";
    if (t3.type === "line-suffix-boundary")
      return "lineSuffixBoundary";
    if (t3.type === "label")
      return `label(${JSON.stringify(t3.label)}, ${e21(t3.contents)})`;
    throw new Error("Unknown doc type " + t3.type);
  }(Zi$2(e20));
  function r2(e21) {
    if (typeof e21 != "symbol")
      return JSON.stringify(String(e21));
    if (e21 in t2)
      return t2[e21];
    const r3 = String(e21).slice(7, -1) || "symbol";
    for (let i2 = 0; ; i2++) {
      const u2 = r3 + (i2 > 0 ? ` #${i2}` : "");
      if (!n2.has(u2))
        return n2.add(u2), t2[e21] = `Symbol.for(${JSON.stringify(u2)})`;
    }
  }
}}}, tu$1 = Object.freeze({__proto__: null, default: {}});
function nu$1(e20, t2) {
  for (var n2 = 0, r2 = e20.length - 1; r2 >= 0; r2--) {
    var i2 = e20[r2];
    i2 === "." ? e20.splice(r2, 1) : i2 === ".." ? (e20.splice(r2, 1), n2++) : n2 && (e20.splice(r2, 1), n2--);
  }
  if (t2)
    for (; n2--; n2)
      e20.unshift("..");
  return e20;
}
var ru$1 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, iu$1 = function(e20) {
  return ru$1.exec(e20).slice(1);
};
function uu$1() {
  for (var e20 = "", t2 = false, n2 = arguments.length - 1; n2 >= -1 && !t2; n2--) {
    var r2 = n2 >= 0 ? arguments[n2] : "/";
    if (typeof r2 != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    r2 && (e20 = r2 + "/" + e20, t2 = r2.charAt(0) === "/");
  }
  return (t2 ? "/" : "") + (e20 = nu$1(hu$1(e20.split("/"), function(e21) {
    return !!e21;
  }), !t2).join("/")) || ".";
}
function ou$1(e20) {
  var t2 = su$1(e20), n2 = gu$1(e20, -1) === "/";
  return (e20 = nu$1(hu$1(e20.split("/"), function(e21) {
    return !!e21;
  }), !t2).join("/")) || t2 || (e20 = "."), e20 && n2 && (e20 += "/"), (t2 ? "/" : "") + e20;
}
function su$1(e20) {
  return e20.charAt(0) === "/";
}
function au$1() {
  var e20 = Array.prototype.slice.call(arguments, 0);
  return ou$1(hu$1(e20, function(e21, t2) {
    if (typeof e21 != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e21;
  }).join("/"));
}
function cu$1(e20, t2) {
  function n2(e21) {
    for (var t3 = 0; t3 < e21.length && e21[t3] === ""; t3++)
      ;
    for (var n3 = e21.length - 1; n3 >= 0 && e21[n3] === ""; n3--)
      ;
    return t3 > n3 ? [] : e21.slice(t3, n3 - t3 + 1);
  }
  e20 = uu$1(e20).substr(1), t2 = uu$1(t2).substr(1);
  for (var r2 = n2(e20.split("/")), i2 = n2(t2.split("/")), u2 = Math.min(r2.length, i2.length), o2 = u2, s2 = 0; s2 < u2; s2++)
    if (r2[s2] !== i2[s2]) {
      o2 = s2;
      break;
    }
  var a2 = [];
  for (s2 = o2; s2 < r2.length; s2++)
    a2.push("..");
  return (a2 = a2.concat(i2.slice(o2))).join("/");
}
function lu$1(e20) {
  var t2 = iu$1(e20), n2 = t2[0], r2 = t2[1];
  return n2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), n2 + r2) : ".";
}
function pu$1(e20, t2) {
  var n2 = iu$1(e20)[2];
  return t2 && n2.substr(-1 * t2.length) === t2 && (n2 = n2.substr(0, n2.length - t2.length)), n2;
}
function fu$1(e20) {
  return iu$1(e20)[3];
}
var du$1 = {extname: fu$1, basename: pu$1, dirname: lu$1, sep: "/", delimiter: ":", relative: cu$1, join: au$1, isAbsolute: su$1, normalize: ou$1, resolve: uu$1};
function hu$1(e20, t2) {
  if (e20.filter)
    return e20.filter(t2);
  for (var n2 = [], r2 = 0; r2 < e20.length; r2++)
    t2(e20[r2], r2, e20) && n2.push(e20[r2]);
  return n2;
}
var gu$1 = "ab".substr(-1) === "b" ? function(e20, t2, n2) {
  return e20.substr(t2, n2);
} : function(e20, t2, n2) {
  return t2 < 0 && (t2 = e20.length + t2), e20.substr(t2, n2);
}, mu$1 = Object.freeze({__proto__: null, resolve: uu$1, normalize: ou$1, isAbsolute: su$1, join: au$1, relative: cu$1, sep: "/", delimiter: ":", dirname: lu$1, basename: pu$1, extname: fu$1, default: du$1}), yu$1 = [], Du$1 = [], Eu$1 = typeof Uint8Array != "undefined" ? Uint8Array : Array, Cu$1 = false;
function bu$1() {
  Cu$1 = true;
  for (var e20 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, n2 = e20.length; t2 < n2; ++t2)
    yu$1[t2] = e20[t2], Du$1[e20.charCodeAt(t2)] = t2;
  Du$1["-".charCodeAt(0)] = 62, Du$1["_".charCodeAt(0)] = 63;
}
function Au$1(e20, t2, n2) {
  for (var r2, i2, u2 = [], o2 = t2; o2 < n2; o2 += 3)
    r2 = (e20[o2] << 16) + (e20[o2 + 1] << 8) + e20[o2 + 2], u2.push(yu$1[(i2 = r2) >> 18 & 63] + yu$1[i2 >> 12 & 63] + yu$1[i2 >> 6 & 63] + yu$1[63 & i2]);
  return u2.join("");
}
function vu$1(e20) {
  var t2;
  Cu$1 || bu$1();
  for (var n2 = e20.length, r2 = n2 % 3, i2 = "", u2 = [], o2 = 16383, s2 = 0, a2 = n2 - r2; s2 < a2; s2 += o2)
    u2.push(Au$1(e20, s2, s2 + o2 > a2 ? a2 : s2 + o2));
  return r2 === 1 ? (t2 = e20[n2 - 1], i2 += yu$1[t2 >> 2], i2 += yu$1[t2 << 4 & 63], i2 += "==") : r2 === 2 && (t2 = (e20[n2 - 2] << 8) + e20[n2 - 1], i2 += yu$1[t2 >> 10], i2 += yu$1[t2 >> 4 & 63], i2 += yu$1[t2 << 2 & 63], i2 += "="), u2.push(i2), u2.join("");
}
function Fu$1(e20, t2, n2, r2, i2) {
  var u2, o2, s2 = 8 * i2 - r2 - 1, a2 = (1 << s2) - 1, c2 = a2 >> 1, l2 = -7, p2 = n2 ? i2 - 1 : 0, f2 = n2 ? -1 : 1, d2 = e20[t2 + p2];
  for (p2 += f2, u2 = d2 & (1 << -l2) - 1, d2 >>= -l2, l2 += s2; l2 > 0; u2 = 256 * u2 + e20[t2 + p2], p2 += f2, l2 -= 8)
    ;
  for (o2 = u2 & (1 << -l2) - 1, u2 >>= -l2, l2 += r2; l2 > 0; o2 = 256 * o2 + e20[t2 + p2], p2 += f2, l2 -= 8)
    ;
  if (u2 === 0)
    u2 = 1 - c2;
  else {
    if (u2 === a2)
      return o2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
    o2 += Math.pow(2, r2), u2 -= c2;
  }
  return (d2 ? -1 : 1) * o2 * Math.pow(2, u2 - r2);
}
function Su$1(e20, t2, n2, r2, i2, u2) {
  var o2, s2, a2, c2 = 8 * u2 - i2 - 1, l2 = (1 << c2) - 1, p2 = l2 >> 1, f2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : u2 - 1, h2 = r2 ? 1 : -1, g2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
  for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = l2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (a2 = Math.pow(2, -o2)) < 1 && (o2--, a2 *= 2), (t2 += o2 + p2 >= 1 ? f2 / a2 : f2 * Math.pow(2, 1 - p2)) * a2 >= 2 && (o2++, a2 /= 2), o2 + p2 >= l2 ? (s2 = 0, o2 = l2) : o2 + p2 >= 1 ? (s2 = (t2 * a2 - 1) * Math.pow(2, i2), o2 += p2) : (s2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; e20[n2 + d2] = 255 & s2, d2 += h2, s2 /= 256, i2 -= 8)
    ;
  for (o2 = o2 << i2 | s2, c2 += i2; c2 > 0; e20[n2 + d2] = 255 & o2, d2 += h2, o2 /= 256, c2 -= 8)
    ;
  e20[n2 + d2 - h2] |= 128 * g2;
}
var xu$1 = {}.toString, wu$1 = Array.isArray || function(e20) {
  return xu$1.call(e20) == "[object Array]";
};
function Tu$1() {
  return Nu$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Bu$1(e20, t2) {
  if (Tu$1() < t2)
    throw new RangeError("Invalid typed array length");
  return Nu$1.TYPED_ARRAY_SUPPORT ? (e20 = new Uint8Array(t2)).__proto__ = Nu$1.prototype : (e20 === null && (e20 = new Nu$1(t2)), e20.length = t2), e20;
}
function Nu$1(e20, t2, n2) {
  if (!(Nu$1.TYPED_ARRAY_SUPPORT || this instanceof Nu$1))
    return new Nu$1(e20, t2, n2);
  if (typeof e20 == "number") {
    if (typeof t2 == "string")
      throw new Error("If encoding is specified then the first argument must be a string");
    return Ou$1(this, e20);
  }
  return ku$1(this, e20, t2, n2);
}
function ku$1(e20, t2, n2, r2) {
  if (typeof t2 == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer != "undefined" && t2 instanceof ArrayBuffer ? function(e21, t3, n3, r3) {
    if (t3.byteLength, n3 < 0 || t3.byteLength < n3)
      throw new RangeError("'offset' is out of bounds");
    if (t3.byteLength < n3 + (r3 || 0))
      throw new RangeError("'length' is out of bounds");
    t3 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t3) : r3 === void 0 ? new Uint8Array(t3, n3) : new Uint8Array(t3, n3, r3);
    Nu$1.TYPED_ARRAY_SUPPORT ? (e21 = t3).__proto__ = Nu$1.prototype : e21 = Iu$1(e21, t3);
    return e21;
  }(e20, t2, n2, r2) : typeof t2 == "string" ? function(e21, t3, n3) {
    typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
    if (!Nu$1.isEncoding(n3))
      throw new TypeError('"encoding" must be a valid string encoding');
    var r3 = 0 | _u$1(t3, n3), i2 = (e21 = Bu$1(e21, r3)).write(t3, n3);
    i2 !== r3 && (e21 = e21.slice(0, i2));
    return e21;
  }(e20, t2, n2) : function(e21, t3) {
    if (ju$1(t3)) {
      var n3 = 0 | Lu$1(t3.length);
      return (e21 = Bu$1(e21, n3)).length === 0 || t3.copy(e21, 0, 0, n3), e21;
    }
    if (t3) {
      if (typeof ArrayBuffer != "undefined" && t3.buffer instanceof ArrayBuffer || "length" in t3)
        return typeof t3.length != "number" || (r3 = t3.length) != r3 ? Bu$1(e21, 0) : Iu$1(e21, t3);
      if (t3.type === "Buffer" && wu$1(t3.data))
        return Iu$1(e21, t3.data);
    }
    var r3;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(e20, t2);
}
function Pu$1(e20) {
  if (typeof e20 != "number")
    throw new TypeError('"size" argument must be a number');
  if (e20 < 0)
    throw new RangeError('"size" argument must not be negative');
}
function Ou$1(e20, t2) {
  if (Pu$1(t2), e20 = Bu$1(e20, t2 < 0 ? 0 : 0 | Lu$1(t2)), !Nu$1.TYPED_ARRAY_SUPPORT)
    for (var n2 = 0; n2 < t2; ++n2)
      e20[n2] = 0;
  return e20;
}
function Iu$1(e20, t2) {
  var n2 = t2.length < 0 ? 0 : 0 | Lu$1(t2.length);
  e20 = Bu$1(e20, n2);
  for (var r2 = 0; r2 < n2; r2 += 1)
    e20[r2] = 255 & t2[r2];
  return e20;
}
function Lu$1(e20) {
  if (e20 >= Tu$1())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Tu$1().toString(16) + " bytes");
  return 0 | e20;
}
function ju$1(e20) {
  return !(e20 == null || !e20._isBuffer);
}
function _u$1(e20, t2) {
  if (ju$1(e20))
    return e20.length;
  if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e20) || e20 instanceof ArrayBuffer))
    return e20.byteLength;
  typeof e20 != "string" && (e20 = "" + e20);
  var n2 = e20.length;
  if (n2 === 0)
    return 0;
  for (var r2 = false; ; )
    switch (t2) {
      case "ascii":
      case "latin1":
      case "binary":
        return n2;
      case "utf8":
      case "utf-8":
      case void 0:
        return co$2(e20).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * n2;
      case "hex":
        return n2 >>> 1;
      case "base64":
        return lo$2(e20).length;
      default:
        if (r2)
          return co$2(e20).length;
        t2 = ("" + t2).toLowerCase(), r2 = true;
    }
}
function Mu$1(e20, t2, n2) {
  var r2 = false;
  if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length)
    return "";
  if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
    return "";
  if ((n2 >>>= 0) <= (t2 >>>= 0))
    return "";
  for (e20 || (e20 = "utf8"); ; )
    switch (e20) {
      case "hex":
        return Qu(this, t2, n2);
      case "utf8":
      case "utf-8":
        return Xu(this, t2, n2);
      case "ascii":
        return Yu(this, t2, n2);
      case "latin1":
      case "binary":
        return Ku(this, t2, n2);
      case "base64":
        return Ju(this, t2, n2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Zu(this, t2, n2);
      default:
        if (r2)
          throw new TypeError("Unknown encoding: " + e20);
        e20 = (e20 + "").toLowerCase(), r2 = true;
    }
}
function Ru$1(e20, t2, n2) {
  var r2 = e20[t2];
  e20[t2] = e20[n2], e20[n2] = r2;
}
function $u(e20, t2, n2, r2, i2) {
  if (e20.length === 0)
    return -1;
  if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = i2 ? 0 : e20.length - 1), n2 < 0 && (n2 = e20.length + n2), n2 >= e20.length) {
    if (i2)
      return -1;
    n2 = e20.length - 1;
  } else if (n2 < 0) {
    if (!i2)
      return -1;
    n2 = 0;
  }
  if (typeof t2 == "string" && (t2 = Nu$1.from(t2, r2)), ju$1(t2))
    return t2.length === 0 ? -1 : Vu(e20, t2, n2, r2, i2);
  if (typeof t2 == "number")
    return t2 &= 255, Nu$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e20, t2, n2) : Uint8Array.prototype.lastIndexOf.call(e20, t2, n2) : Vu(e20, [t2], n2, r2, i2);
  throw new TypeError("val must be string, number or Buffer");
}
function Vu(e20, t2, n2, r2, i2) {
  var u2, o2 = 1, s2 = e20.length, a2 = t2.length;
  if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
    if (e20.length < 2 || t2.length < 2)
      return -1;
    o2 = 2, s2 /= 2, a2 /= 2, n2 /= 2;
  }
  function c2(e21, t3) {
    return o2 === 1 ? e21[t3] : e21.readUInt16BE(t3 * o2);
  }
  if (i2) {
    var l2 = -1;
    for (u2 = n2; u2 < s2; u2++)
      if (c2(e20, u2) === c2(t2, l2 === -1 ? 0 : u2 - l2)) {
        if (l2 === -1 && (l2 = u2), u2 - l2 + 1 === a2)
          return l2 * o2;
      } else
        l2 !== -1 && (u2 -= u2 - l2), l2 = -1;
  } else
    for (n2 + a2 > s2 && (n2 = s2 - a2), u2 = n2; u2 >= 0; u2--) {
      for (var p2 = true, f2 = 0; f2 < a2; f2++)
        if (c2(e20, u2 + f2) !== c2(t2, f2)) {
          p2 = false;
          break;
        }
      if (p2)
        return u2;
    }
  return -1;
}
function Wu(e20, t2, n2, r2) {
  n2 = Number(n2) || 0;
  var i2 = e20.length - n2;
  r2 ? (r2 = Number(r2)) > i2 && (r2 = i2) : r2 = i2;
  var u2 = t2.length;
  if (u2 % 2 != 0)
    throw new TypeError("Invalid hex string");
  r2 > u2 / 2 && (r2 = u2 / 2);
  for (var o2 = 0; o2 < r2; ++o2) {
    var s2 = parseInt(t2.substr(2 * o2, 2), 16);
    if (isNaN(s2))
      return o2;
    e20[n2 + o2] = s2;
  }
  return o2;
}
function qu(e20, t2, n2, r2) {
  return po$2(co$2(t2, e20.length - n2), e20, n2, r2);
}
function Uu$1(e20, t2, n2, r2) {
  return po$2(function(e21) {
    for (var t3 = [], n3 = 0; n3 < e21.length; ++n3)
      t3.push(255 & e21.charCodeAt(n3));
    return t3;
  }(t2), e20, n2, r2);
}
function zu(e20, t2, n2, r2) {
  return Uu$1(e20, t2, n2, r2);
}
function Gu(e20, t2, n2, r2) {
  return po$2(lo$2(t2), e20, n2, r2);
}
function Hu(e20, t2, n2, r2) {
  return po$2(function(e21, t3) {
    for (var n3, r3, i2, u2 = [], o2 = 0; o2 < e21.length && !((t3 -= 2) < 0); ++o2)
      r3 = (n3 = e21.charCodeAt(o2)) >> 8, i2 = n3 % 256, u2.push(i2), u2.push(r3);
    return u2;
  }(t2, e20.length - n2), e20, n2, r2);
}
function Ju(e20, t2, n2) {
  return t2 === 0 && n2 === e20.length ? vu$1(e20) : vu$1(e20.slice(t2, n2));
}
function Xu(e20, t2, n2) {
  n2 = Math.min(e20.length, n2);
  for (var r2 = [], i2 = t2; i2 < n2; ) {
    var u2, o2, s2, a2, c2 = e20[i2], l2 = null, p2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
    if (i2 + p2 <= n2)
      switch (p2) {
        case 1:
          c2 < 128 && (l2 = c2);
          break;
        case 2:
          (192 & (u2 = e20[i2 + 1])) == 128 && (a2 = (31 & c2) << 6 | 63 & u2) > 127 && (l2 = a2);
          break;
        case 3:
          u2 = e20[i2 + 1], o2 = e20[i2 + 2], (192 & u2) == 128 && (192 & o2) == 128 && (a2 = (15 & c2) << 12 | (63 & u2) << 6 | 63 & o2) > 2047 && (a2 < 55296 || a2 > 57343) && (l2 = a2);
          break;
        case 4:
          u2 = e20[i2 + 1], o2 = e20[i2 + 2], s2 = e20[i2 + 3], (192 & u2) == 128 && (192 & o2) == 128 && (192 & s2) == 128 && (a2 = (15 & c2) << 18 | (63 & u2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && a2 < 1114112 && (l2 = a2);
      }
    l2 === null ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, r2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), r2.push(l2), i2 += p2;
  }
  return function(e21) {
    var t3 = e21.length;
    if (t3 <= 4096)
      return String.fromCharCode.apply(String, e21);
    var n3 = "", r3 = 0;
    for (; r3 < t3; )
      n3 += String.fromCharCode.apply(String, e21.slice(r3, r3 += 4096));
    return n3;
  }(r2);
}
Nu$1.TYPED_ARRAY_SUPPORT = nr$2.TYPED_ARRAY_SUPPORT === void 0 || nr$2.TYPED_ARRAY_SUPPORT, Nu$1.poolSize = 8192, Nu$1._augment = function(e20) {
  return e20.__proto__ = Nu$1.prototype, e20;
}, Nu$1.from = function(e20, t2, n2) {
  return ku$1(null, e20, t2, n2);
}, Nu$1.TYPED_ARRAY_SUPPORT && (Nu$1.prototype.__proto__ = Uint8Array.prototype, Nu$1.__proto__ = Uint8Array), Nu$1.alloc = function(e20, t2, n2) {
  return function(e21, t3, n3, r2) {
    return Pu$1(t3), t3 <= 0 ? Bu$1(e21, t3) : n3 !== void 0 ? typeof r2 == "string" ? Bu$1(e21, t3).fill(n3, r2) : Bu$1(e21, t3).fill(n3) : Bu$1(e21, t3);
  }(null, e20, t2, n2);
}, Nu$1.allocUnsafe = function(e20) {
  return Ou$1(null, e20);
}, Nu$1.allocUnsafeSlow = function(e20) {
  return Ou$1(null, e20);
}, Nu$1.isBuffer = fo$2, Nu$1.compare = function(e20, t2) {
  if (!ju$1(e20) || !ju$1(t2))
    throw new TypeError("Arguments must be Buffers");
  if (e20 === t2)
    return 0;
  for (var n2 = e20.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
    if (e20[i2] !== t2[i2]) {
      n2 = e20[i2], r2 = t2[i2];
      break;
    }
  return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
}, Nu$1.isEncoding = function(e20) {
  switch (String(e20).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, Nu$1.concat = function(e20, t2) {
  if (!wu$1(e20))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e20.length === 0)
    return Nu$1.alloc(0);
  var n2;
  if (t2 === void 0)
    for (t2 = 0, n2 = 0; n2 < e20.length; ++n2)
      t2 += e20[n2].length;
  var r2 = Nu$1.allocUnsafe(t2), i2 = 0;
  for (n2 = 0; n2 < e20.length; ++n2) {
    var u2 = e20[n2];
    if (!ju$1(u2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    u2.copy(r2, i2), i2 += u2.length;
  }
  return r2;
}, Nu$1.byteLength = _u$1, Nu$1.prototype._isBuffer = true, Nu$1.prototype.swap16 = function() {
  var e20 = this.length;
  if (e20 % 2 != 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t2 = 0; t2 < e20; t2 += 2)
    Ru$1(this, t2, t2 + 1);
  return this;
}, Nu$1.prototype.swap32 = function() {
  var e20 = this.length;
  if (e20 % 4 != 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t2 = 0; t2 < e20; t2 += 4)
    Ru$1(this, t2, t2 + 3), Ru$1(this, t2 + 1, t2 + 2);
  return this;
}, Nu$1.prototype.swap64 = function() {
  var e20 = this.length;
  if (e20 % 8 != 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t2 = 0; t2 < e20; t2 += 8)
    Ru$1(this, t2, t2 + 7), Ru$1(this, t2 + 1, t2 + 6), Ru$1(this, t2 + 2, t2 + 5), Ru$1(this, t2 + 3, t2 + 4);
  return this;
}, Nu$1.prototype.toString = function() {
  var e20 = 0 | this.length;
  return e20 === 0 ? "" : arguments.length === 0 ? Xu(this, 0, e20) : Mu$1.apply(this, arguments);
}, Nu$1.prototype.equals = function(e20) {
  if (!ju$1(e20))
    throw new TypeError("Argument must be a Buffer");
  return this === e20 || Nu$1.compare(this, e20) === 0;
}, Nu$1.prototype.inspect = function() {
  var e20 = "";
  return this.length > 0 && (e20 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e20 += " ... ")), "<Buffer " + e20 + ">";
}, Nu$1.prototype.compare = function(e20, t2, n2, r2, i2) {
  if (!ju$1(e20))
    throw new TypeError("Argument must be a Buffer");
  if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e20 ? e20.length : 0), r2 === void 0 && (r2 = 0), i2 === void 0 && (i2 = this.length), t2 < 0 || n2 > e20.length || r2 < 0 || i2 > this.length)
    throw new RangeError("out of range index");
  if (r2 >= i2 && t2 >= n2)
    return 0;
  if (r2 >= i2)
    return -1;
  if (t2 >= n2)
    return 1;
  if (this === e20)
    return 0;
  for (var u2 = (i2 >>>= 0) - (r2 >>>= 0), o2 = (n2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(u2, o2), a2 = this.slice(r2, i2), c2 = e20.slice(t2, n2), l2 = 0; l2 < s2; ++l2)
    if (a2[l2] !== c2[l2]) {
      u2 = a2[l2], o2 = c2[l2];
      break;
    }
  return u2 < o2 ? -1 : o2 < u2 ? 1 : 0;
}, Nu$1.prototype.includes = function(e20, t2, n2) {
  return this.indexOf(e20, t2, n2) !== -1;
}, Nu$1.prototype.indexOf = function(e20, t2, n2) {
  return $u(this, e20, t2, n2, true);
}, Nu$1.prototype.lastIndexOf = function(e20, t2, n2) {
  return $u(this, e20, t2, n2, false);
}, Nu$1.prototype.write = function(e20, t2, n2, r2) {
  if (t2 === void 0)
    r2 = "utf8", n2 = this.length, t2 = 0;
  else if (n2 === void 0 && typeof t2 == "string")
    r2 = t2, n2 = this.length, t2 = 0;
  else {
    if (!isFinite(t2))
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t2 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
  }
  var i2 = this.length - t2;
  if ((n2 === void 0 || n2 > i2) && (n2 = i2), e20.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  r2 || (r2 = "utf8");
  for (var u2 = false; ; )
    switch (r2) {
      case "hex":
        return Wu(this, e20, t2, n2);
      case "utf8":
      case "utf-8":
        return qu(this, e20, t2, n2);
      case "ascii":
        return Uu$1(this, e20, t2, n2);
      case "latin1":
      case "binary":
        return zu(this, e20, t2, n2);
      case "base64":
        return Gu(this, e20, t2, n2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Hu(this, e20, t2, n2);
      default:
        if (u2)
          throw new TypeError("Unknown encoding: " + r2);
        r2 = ("" + r2).toLowerCase(), u2 = true;
    }
}, Nu$1.prototype.toJSON = function() {
  return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)};
};
function Yu(e20, t2, n2) {
  var r2 = "";
  n2 = Math.min(e20.length, n2);
  for (var i2 = t2; i2 < n2; ++i2)
    r2 += String.fromCharCode(127 & e20[i2]);
  return r2;
}
function Ku(e20, t2, n2) {
  var r2 = "";
  n2 = Math.min(e20.length, n2);
  for (var i2 = t2; i2 < n2; ++i2)
    r2 += String.fromCharCode(e20[i2]);
  return r2;
}
function Qu(e20, t2, n2) {
  var r2 = e20.length;
  (!t2 || t2 < 0) && (t2 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
  for (var i2 = "", u2 = t2; u2 < n2; ++u2)
    i2 += ao$2(e20[u2]);
  return i2;
}
function Zu(e20, t2, n2) {
  for (var r2 = e20.slice(t2, n2), i2 = "", u2 = 0; u2 < r2.length; u2 += 2)
    i2 += String.fromCharCode(r2[u2] + 256 * r2[u2 + 1]);
  return i2;
}
function eo$2(e20, t2, n2) {
  if (e20 % 1 != 0 || e20 < 0)
    throw new RangeError("offset is not uint");
  if (e20 + t2 > n2)
    throw new RangeError("Trying to access beyond buffer length");
}
function to$2(e20, t2, n2, r2, i2, u2) {
  if (!ju$1(e20))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t2 > i2 || t2 < u2)
    throw new RangeError('"value" argument is out of bounds');
  if (n2 + r2 > e20.length)
    throw new RangeError("Index out of range");
}
function no$2(e20, t2, n2, r2) {
  t2 < 0 && (t2 = 65535 + t2 + 1);
  for (var i2 = 0, u2 = Math.min(e20.length - n2, 2); i2 < u2; ++i2)
    e20[n2 + i2] = (t2 & 255 << 8 * (r2 ? i2 : 1 - i2)) >>> 8 * (r2 ? i2 : 1 - i2);
}
function ro$2(e20, t2, n2, r2) {
  t2 < 0 && (t2 = 4294967295 + t2 + 1);
  for (var i2 = 0, u2 = Math.min(e20.length - n2, 4); i2 < u2; ++i2)
    e20[n2 + i2] = t2 >>> 8 * (r2 ? i2 : 3 - i2) & 255;
}
function io$2(e20, t2, n2, r2, i2, u2) {
  if (n2 + r2 > e20.length)
    throw new RangeError("Index out of range");
  if (n2 < 0)
    throw new RangeError("Index out of range");
}
function uo$2(e20, t2, n2, r2, i2) {
  return i2 || io$2(e20, 0, n2, 4), Su$1(e20, t2, n2, r2, 23, 4), n2 + 4;
}
function oo$2(e20, t2, n2, r2, i2) {
  return i2 || io$2(e20, 0, n2, 8), Su$1(e20, t2, n2, r2, 52, 8), n2 + 8;
}
Nu$1.prototype.slice = function(e20, t2) {
  var n2, r2 = this.length;
  if ((e20 = ~~e20) < 0 ? (e20 += r2) < 0 && (e20 = 0) : e20 > r2 && (e20 = r2), (t2 = t2 === void 0 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e20 && (t2 = e20), Nu$1.TYPED_ARRAY_SUPPORT)
    (n2 = this.subarray(e20, t2)).__proto__ = Nu$1.prototype;
  else {
    var i2 = t2 - e20;
    n2 = new Nu$1(i2, void 0);
    for (var u2 = 0; u2 < i2; ++u2)
      n2[u2] = this[u2 + e20];
  }
  return n2;
}, Nu$1.prototype.readUIntLE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = this[e20], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
    r2 += this[e20 + u2] * i2;
  return r2;
}, Nu$1.prototype.readUIntBE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = this[e20 + --t2], i2 = 1; t2 > 0 && (i2 *= 256); )
    r2 += this[e20 + --t2] * i2;
  return r2;
}, Nu$1.prototype.readUInt8 = function(e20, t2) {
  return t2 || eo$2(e20, 1, this.length), this[e20];
}, Nu$1.prototype.readUInt16LE = function(e20, t2) {
  return t2 || eo$2(e20, 2, this.length), this[e20] | this[e20 + 1] << 8;
}, Nu$1.prototype.readUInt16BE = function(e20, t2) {
  return t2 || eo$2(e20, 2, this.length), this[e20] << 8 | this[e20 + 1];
}, Nu$1.prototype.readUInt32LE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), (this[e20] | this[e20 + 1] << 8 | this[e20 + 2] << 16) + 16777216 * this[e20 + 3];
}, Nu$1.prototype.readUInt32BE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), 16777216 * this[e20] + (this[e20 + 1] << 16 | this[e20 + 2] << 8 | this[e20 + 3]);
}, Nu$1.prototype.readIntLE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = this[e20], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
    r2 += this[e20 + u2] * i2;
  return r2 >= (i2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
}, Nu$1.prototype.readIntBE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = t2, i2 = 1, u2 = this[e20 + --r2]; r2 > 0 && (i2 *= 256); )
    u2 += this[e20 + --r2] * i2;
  return u2 >= (i2 *= 128) && (u2 -= Math.pow(2, 8 * t2)), u2;
}, Nu$1.prototype.readInt8 = function(e20, t2) {
  return t2 || eo$2(e20, 1, this.length), 128 & this[e20] ? -1 * (255 - this[e20] + 1) : this[e20];
}, Nu$1.prototype.readInt16LE = function(e20, t2) {
  t2 || eo$2(e20, 2, this.length);
  var n2 = this[e20] | this[e20 + 1] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, Nu$1.prototype.readInt16BE = function(e20, t2) {
  t2 || eo$2(e20, 2, this.length);
  var n2 = this[e20 + 1] | this[e20] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, Nu$1.prototype.readInt32LE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), this[e20] | this[e20 + 1] << 8 | this[e20 + 2] << 16 | this[e20 + 3] << 24;
}, Nu$1.prototype.readInt32BE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), this[e20] << 24 | this[e20 + 1] << 16 | this[e20 + 2] << 8 | this[e20 + 3];
}, Nu$1.prototype.readFloatLE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), Fu$1(this, e20, true, 23, 4);
}, Nu$1.prototype.readFloatBE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), Fu$1(this, e20, false, 23, 4);
}, Nu$1.prototype.readDoubleLE = function(e20, t2) {
  return t2 || eo$2(e20, 8, this.length), Fu$1(this, e20, true, 52, 8);
}, Nu$1.prototype.readDoubleBE = function(e20, t2) {
  return t2 || eo$2(e20, 8, this.length), Fu$1(this, e20, false, 52, 8);
}, Nu$1.prototype.writeUIntLE = function(e20, t2, n2, r2) {
  (e20 = +e20, t2 |= 0, n2 |= 0, r2) || to$2(this, e20, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
  var i2 = 1, u2 = 0;
  for (this[t2] = 255 & e20; ++u2 < n2 && (i2 *= 256); )
    this[t2 + u2] = e20 / i2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeUIntBE = function(e20, t2, n2, r2) {
  (e20 = +e20, t2 |= 0, n2 |= 0, r2) || to$2(this, e20, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
  var i2 = n2 - 1, u2 = 1;
  for (this[t2 + i2] = 255 & e20; --i2 >= 0 && (u2 *= 256); )
    this[t2 + i2] = e20 / u2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeUInt8 = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 1, 255, 0), Nu$1.TYPED_ARRAY_SUPPORT || (e20 = Math.floor(e20)), this[t2] = 255 & e20, t2 + 1;
}, Nu$1.prototype.writeUInt16LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8) : no$2(this, e20, t2, true), t2 + 2;
}, Nu$1.prototype.writeUInt16BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 8, this[t2 + 1] = 255 & e20) : no$2(this, e20, t2, false), t2 + 2;
}, Nu$1.prototype.writeUInt32LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e20 >>> 24, this[t2 + 2] = e20 >>> 16, this[t2 + 1] = e20 >>> 8, this[t2] = 255 & e20) : ro$2(this, e20, t2, true), t2 + 4;
}, Nu$1.prototype.writeUInt32BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 24, this[t2 + 1] = e20 >>> 16, this[t2 + 2] = e20 >>> 8, this[t2 + 3] = 255 & e20) : ro$2(this, e20, t2, false), t2 + 4;
}, Nu$1.prototype.writeIntLE = function(e20, t2, n2, r2) {
  if (e20 = +e20, t2 |= 0, !r2) {
    var i2 = Math.pow(2, 8 * n2 - 1);
    to$2(this, e20, t2, n2, i2 - 1, -i2);
  }
  var u2 = 0, o2 = 1, s2 = 0;
  for (this[t2] = 255 & e20; ++u2 < n2 && (o2 *= 256); )
    e20 < 0 && s2 === 0 && this[t2 + u2 - 1] !== 0 && (s2 = 1), this[t2 + u2] = (e20 / o2 >> 0) - s2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeIntBE = function(e20, t2, n2, r2) {
  if (e20 = +e20, t2 |= 0, !r2) {
    var i2 = Math.pow(2, 8 * n2 - 1);
    to$2(this, e20, t2, n2, i2 - 1, -i2);
  }
  var u2 = n2 - 1, o2 = 1, s2 = 0;
  for (this[t2 + u2] = 255 & e20; --u2 >= 0 && (o2 *= 256); )
    e20 < 0 && s2 === 0 && this[t2 + u2 + 1] !== 0 && (s2 = 1), this[t2 + u2] = (e20 / o2 >> 0) - s2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeInt8 = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 1, 127, -128), Nu$1.TYPED_ARRAY_SUPPORT || (e20 = Math.floor(e20)), e20 < 0 && (e20 = 255 + e20 + 1), this[t2] = 255 & e20, t2 + 1;
}, Nu$1.prototype.writeInt16LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8) : no$2(this, e20, t2, true), t2 + 2;
}, Nu$1.prototype.writeInt16BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 8, this[t2 + 1] = 255 & e20) : no$2(this, e20, t2, false), t2 + 2;
}, Nu$1.prototype.writeInt32LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 2147483647, -2147483648), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8, this[t2 + 2] = e20 >>> 16, this[t2 + 3] = e20 >>> 24) : ro$2(this, e20, t2, true), t2 + 4;
}, Nu$1.prototype.writeInt32BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 2147483647, -2147483648), e20 < 0 && (e20 = 4294967295 + e20 + 1), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 24, this[t2 + 1] = e20 >>> 16, this[t2 + 2] = e20 >>> 8, this[t2 + 3] = 255 & e20) : ro$2(this, e20, t2, false), t2 + 4;
}, Nu$1.prototype.writeFloatLE = function(e20, t2, n2) {
  return uo$2(this, e20, t2, true, n2);
}, Nu$1.prototype.writeFloatBE = function(e20, t2, n2) {
  return uo$2(this, e20, t2, false, n2);
}, Nu$1.prototype.writeDoubleLE = function(e20, t2, n2) {
  return oo$2(this, e20, t2, true, n2);
}, Nu$1.prototype.writeDoubleBE = function(e20, t2, n2) {
  return oo$2(this, e20, t2, false, n2);
}, Nu$1.prototype.copy = function(e20, t2, n2, r2) {
  if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t2 >= e20.length && (t2 = e20.length), t2 || (t2 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
    return 0;
  if (e20.length === 0 || this.length === 0)
    return 0;
  if (t2 < 0)
    throw new RangeError("targetStart out of bounds");
  if (n2 < 0 || n2 >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (r2 < 0)
    throw new RangeError("sourceEnd out of bounds");
  r2 > this.length && (r2 = this.length), e20.length - t2 < r2 - n2 && (r2 = e20.length - t2 + n2);
  var i2, u2 = r2 - n2;
  if (this === e20 && n2 < t2 && t2 < r2)
    for (i2 = u2 - 1; i2 >= 0; --i2)
      e20[i2 + t2] = this[i2 + n2];
  else if (u2 < 1e3 || !Nu$1.TYPED_ARRAY_SUPPORT)
    for (i2 = 0; i2 < u2; ++i2)
      e20[i2 + t2] = this[i2 + n2];
  else
    Uint8Array.prototype.set.call(e20, this.subarray(n2, n2 + u2), t2);
  return u2;
}, Nu$1.prototype.fill = function(e20, t2, n2, r2) {
  if (typeof e20 == "string") {
    if (typeof t2 == "string" ? (r2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e20.length === 1) {
      var i2 = e20.charCodeAt(0);
      i2 < 256 && (e20 = i2);
    }
    if (r2 !== void 0 && typeof r2 != "string")
      throw new TypeError("encoding must be a string");
    if (typeof r2 == "string" && !Nu$1.isEncoding(r2))
      throw new TypeError("Unknown encoding: " + r2);
  } else
    typeof e20 == "number" && (e20 &= 255);
  if (t2 < 0 || this.length < t2 || this.length < n2)
    throw new RangeError("Out of range index");
  if (n2 <= t2)
    return this;
  var u2;
  if (t2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e20 || (e20 = 0), typeof e20 == "number")
    for (u2 = t2; u2 < n2; ++u2)
      this[u2] = e20;
  else {
    var o2 = ju$1(e20) ? e20 : co$2(new Nu$1(e20, r2).toString()), s2 = o2.length;
    for (u2 = 0; u2 < n2 - t2; ++u2)
      this[u2 + t2] = o2[u2 % s2];
  }
  return this;
};
var so$2 = /[^+\/0-9A-Za-z-_]/g;
function ao$2(e20) {
  return e20 < 16 ? "0" + e20.toString(16) : e20.toString(16);
}
function co$2(e20, t2) {
  var n2;
  t2 = t2 || 1 / 0;
  for (var r2 = e20.length, i2 = null, u2 = [], o2 = 0; o2 < r2; ++o2) {
    if ((n2 = e20.charCodeAt(o2)) > 55295 && n2 < 57344) {
      if (!i2) {
        if (n2 > 56319) {
          (t2 -= 3) > -1 && u2.push(239, 191, 189);
          continue;
        }
        if (o2 + 1 === r2) {
          (t2 -= 3) > -1 && u2.push(239, 191, 189);
          continue;
        }
        i2 = n2;
        continue;
      }
      if (n2 < 56320) {
        (t2 -= 3) > -1 && u2.push(239, 191, 189), i2 = n2;
        continue;
      }
      n2 = 65536 + (i2 - 55296 << 10 | n2 - 56320);
    } else
      i2 && (t2 -= 3) > -1 && u2.push(239, 191, 189);
    if (i2 = null, n2 < 128) {
      if ((t2 -= 1) < 0)
        break;
      u2.push(n2);
    } else if (n2 < 2048) {
      if ((t2 -= 2) < 0)
        break;
      u2.push(n2 >> 6 | 192, 63 & n2 | 128);
    } else if (n2 < 65536) {
      if ((t2 -= 3) < 0)
        break;
      u2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    } else {
      if (!(n2 < 1114112))
        throw new Error("Invalid code point");
      if ((t2 -= 4) < 0)
        break;
      u2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    }
  }
  return u2;
}
function lo$2(e20) {
  return function(e21) {
    var t2, n2, r2, i2, u2, o2;
    Cu$1 || bu$1();
    var s2 = e21.length;
    if (s2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    u2 = e21[s2 - 2] === "=" ? 2 : e21[s2 - 1] === "=" ? 1 : 0, o2 = new Eu$1(3 * s2 / 4 - u2), r2 = u2 > 0 ? s2 - 4 : s2;
    var a2 = 0;
    for (t2 = 0, n2 = 0; t2 < r2; t2 += 4, n2 += 3)
      i2 = Du$1[e21.charCodeAt(t2)] << 18 | Du$1[e21.charCodeAt(t2 + 1)] << 12 | Du$1[e21.charCodeAt(t2 + 2)] << 6 | Du$1[e21.charCodeAt(t2 + 3)], o2[a2++] = i2 >> 16 & 255, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2;
    return u2 === 2 ? (i2 = Du$1[e21.charCodeAt(t2)] << 2 | Du$1[e21.charCodeAt(t2 + 1)] >> 4, o2[a2++] = 255 & i2) : u2 === 1 && (i2 = Du$1[e21.charCodeAt(t2)] << 10 | Du$1[e21.charCodeAt(t2 + 1)] << 4 | Du$1[e21.charCodeAt(t2 + 2)] >> 2, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2), o2;
  }(function(e21) {
    if ((e21 = function(e22) {
      return e22.trim ? e22.trim() : e22.replace(/^\s+|\s+$/g, "");
    }(e21).replace(so$2, "")).length < 2)
      return "";
    for (; e21.length % 4 != 0; )
      e21 += "=";
    return e21;
  }(e20));
}
function po$2(e20, t2, n2, r2) {
  for (var i2 = 0; i2 < r2 && !(i2 + n2 >= t2.length || i2 >= e20.length); ++i2)
    t2[i2 + n2] = e20[i2];
  return i2;
}
function fo$2(e20) {
  return e20 != null && (!!e20._isBuffer || ho$2(e20) || function(e21) {
    return typeof e21.readFloatLE == "function" && typeof e21.slice == "function" && ho$2(e21.slice(0, 0));
  }(e20));
}
function ho$2(e20) {
  return !!e20.constructor && typeof e20.constructor.isBuffer == "function" && e20.constructor.isBuffer(e20);
}
var go$2 = n$3(tu$1);
var mo$2 = class {
  constructor(e20, t2) {
    (t2 = t2 || {}).readChunk || (t2.readChunk = 1024), t2.newLineCharacter ? t2.newLineCharacter = t2.newLineCharacter.charCodeAt(0) : t2.newLineCharacter = 10, this.fd = typeof e20 == "number" ? e20 : go$2.openSync(e20, "r"), this.options = t2, this.newLineCharacter = t2.newLineCharacter, this.reset();
  }
  _searchInBuffer(e20, t2) {
    let n2 = -1;
    for (let r2 = 0; r2 <= e20.length; r2++) {
      if (e20[r2] === t2) {
        n2 = r2;
        break;
      }
    }
    return n2;
  }
  reset() {
    this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
  }
  close() {
    go$2.closeSync(this.fd), this.fd = null;
  }
  _extractLines(e20) {
    let t2;
    const n2 = [];
    let r2 = 0, i2 = 0;
    for (; ; ) {
      let u3 = e20[r2++];
      if (u3 === this.newLineCharacter)
        t2 = e20.slice(i2, r2), n2.push(t2), i2 = r2;
      else if (u3 === void 0)
        break;
    }
    let u2 = e20.slice(i2, r2);
    return u2.length && n2.push(u2), n2;
  }
  _readChunk(e20) {
    let t2, n2 = 0;
    const r2 = [];
    do {
      const e21 = new Nu$1(this.options.readChunk);
      t2 = go$2.readSync(this.fd, e21, 0, this.options.readChunk, this.fdPosition), n2 += t2, this.fdPosition = this.fdPosition + t2, r2.push(e21);
    } while (t2 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
    let i2 = Nu$1.concat(r2);
    return t2 < this.options.readChunk && (this.eofReached = true, i2 = i2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(i2), e20 && (this.linesCache[0] = Nu$1.concat([e20, this.linesCache[0]]))), n2;
  }
  next() {
    if (!this.fd)
      return false;
    let e20, t2 = false;
    if (this.eofReached && this.linesCache.length === 0)
      return t2;
    if (this.linesCache.length || (e20 = this._readChunk()), this.linesCache.length) {
      t2 = this.linesCache.shift();
      t2[t2.length - 1] !== this.newLineCharacter && (e20 = this._readChunk(t2), e20 && (t2 = this.linesCache.shift()));
    }
    return this.eofReached && this.linesCache.length === 0 && this.close(), t2 && t2[t2.length - 1] === this.newLineCharacter && (t2 = t2.slice(0, t2.length - 1)), t2;
  }
};
class yo$2 extends Error {
}
class Do$2 extends Error {
}
class Eo$2 extends Error {
}
class Co$2 extends Error {
}
var bo$2 = {ConfigError: yo$2, DebugError: Do$2, UndefinedParserError: Eo$2, ArgExpansionBailout: Co$2}, Ao$2 = function(e20, t2) {
  return (Ao$2 = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(e21, t3) {
    e21.__proto__ = t3;
  } || function(e21, t3) {
    for (var n2 in t3)
      t3.hasOwnProperty(n2) && (e21[n2] = t3[n2]);
  })(e20, t2);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var vo$2 = function() {
  return (vo$2 = Object.assign || function(e20) {
    for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var i2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, i2) && (e20[i2] = t2[i2]);
    return e20;
  }).apply(this, arguments);
};
function Fo$2(e20) {
  var t2 = typeof Symbol == "function" && Symbol.iterator, n2 = t2 && e20[t2], r2 = 0;
  if (n2)
    return n2.call(e20);
  if (e20 && typeof e20.length == "number")
    return {next: function() {
      return e20 && r2 >= e20.length && (e20 = void 0), {value: e20 && e20[r2++], done: !e20};
    }};
  throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function So$2(e20, t2) {
  var n2 = typeof Symbol == "function" && e20[Symbol.iterator];
  if (!n2)
    return e20;
  var r2, i2, u2 = n2.call(e20), o2 = [];
  try {
    for (; (t2 === void 0 || t2-- > 0) && !(r2 = u2.next()).done; )
      o2.push(r2.value);
  } catch (e21) {
    i2 = {error: e21};
  } finally {
    try {
      r2 && !r2.done && (n2 = u2.return) && n2.call(u2);
    } finally {
      if (i2)
        throw i2.error;
    }
  }
  return o2;
}
function xo$2(e20) {
  return this instanceof xo$2 ? (this.v = e20, this) : new xo$2(e20);
}
var wo$2 = Object.freeze({__proto__: null, __extends: function(e20, t2) {
  function n2() {
    this.constructor = e20;
  }
  Ao$2(e20, t2), e20.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
}, get __assign() {
  return vo$2;
}, __rest: function(e20, t2) {
  var n2 = {};
  for (var r2 in e20)
    Object.prototype.hasOwnProperty.call(e20, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e20[r2]);
  if (e20 != null && typeof Object.getOwnPropertySymbols == "function") {
    var i2 = 0;
    for (r2 = Object.getOwnPropertySymbols(e20); i2 < r2.length; i2++)
      t2.indexOf(r2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e20, r2[i2]) && (n2[r2[i2]] = e20[r2[i2]]);
  }
  return n2;
}, __decorate: function(e20, t2, n2, r2) {
  var i2, u2 = arguments.length, o2 = u2 < 3 ? t2 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o2 = Reflect.decorate(e20, t2, n2, r2);
  else
    for (var s2 = e20.length - 1; s2 >= 0; s2--)
      (i2 = e20[s2]) && (o2 = (u2 < 3 ? i2(o2) : u2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
  return u2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
}, __param: function(e20, t2) {
  return function(n2, r2) {
    t2(n2, r2, e20);
  };
}, __metadata: function(e20, t2) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e20, t2);
}, __awaiter: function(e20, t2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(i2, u2) {
    function o2(e21) {
      try {
        a2(r2.next(e21));
      } catch (e22) {
        u2(e22);
      }
    }
    function s2(e21) {
      try {
        a2(r2.throw(e21));
      } catch (e22) {
        u2(e22);
      }
    }
    function a2(e21) {
      var t3;
      e21.done ? i2(e21.value) : (t3 = e21.value, t3 instanceof n2 ? t3 : new n2(function(e22) {
        e22(t3);
      })).then(o2, s2);
    }
    a2((r2 = r2.apply(e20, t2 || [])).next());
  });
}, __generator: function(e20, t2) {
  var n2, r2, i2, u2, o2 = {label: 0, sent: function() {
    if (1 & i2[0])
      throw i2[1];
    return i2[1];
  }, trys: [], ops: []};
  return u2 = {next: s2(0), throw: s2(1), return: s2(2)}, typeof Symbol == "function" && (u2[Symbol.iterator] = function() {
    return this;
  }), u2;
  function s2(u3) {
    return function(s3) {
      return function(u4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; o2; )
          try {
            if (n2 = 1, r2 && (i2 = 2 & u4[0] ? r2.return : u4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, u4[1])).done)
              return i2;
            switch (r2 = 0, i2 && (u4 = [2 & u4[0], i2.value]), u4[0]) {
              case 0:
              case 1:
                i2 = u4;
                break;
              case 4:
                return o2.label++, {value: u4[1], done: false};
              case 5:
                o2.label++, r2 = u4[1], u4 = [0];
                continue;
              case 7:
                u4 = o2.ops.pop(), o2.trys.pop();
                continue;
              default:
                if (!(i2 = o2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || u4[0] !== 6 && u4[0] !== 2)) {
                  o2 = 0;
                  continue;
                }
                if (u4[0] === 3 && (!i2 || u4[1] > i2[0] && u4[1] < i2[3])) {
                  o2.label = u4[1];
                  break;
                }
                if (u4[0] === 6 && o2.label < i2[1]) {
                  o2.label = i2[1], i2 = u4;
                  break;
                }
                if (i2 && o2.label < i2[2]) {
                  o2.label = i2[2], o2.ops.push(u4);
                  break;
                }
                i2[2] && o2.ops.pop(), o2.trys.pop();
                continue;
            }
            u4 = t2.call(e20, o2);
          } catch (e21) {
            u4 = [6, e21], r2 = 0;
          } finally {
            n2 = i2 = 0;
          }
        if (5 & u4[0])
          throw u4[1];
        return {value: u4[0] ? u4[1] : void 0, done: true};
      }([u3, s3]);
    };
  }
}, __createBinding: function(e20, t2, n2, r2) {
  r2 === void 0 && (r2 = n2), e20[r2] = t2[n2];
}, __exportStar: function(e20, t2) {
  for (var n2 in e20)
    n2 === "default" || t2.hasOwnProperty(n2) || (t2[n2] = e20[n2]);
}, __values: Fo$2, __read: So$2, __spread: function() {
  for (var e20 = [], t2 = 0; t2 < arguments.length; t2++)
    e20 = e20.concat(So$2(arguments[t2]));
  return e20;
}, __spreadArrays: function() {
  for (var e20 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
    e20 += arguments[t2].length;
  var r2 = Array(e20), i2 = 0;
  for (t2 = 0; t2 < n2; t2++)
    for (var u2 = arguments[t2], o2 = 0, s2 = u2.length; o2 < s2; o2++, i2++)
      r2[i2] = u2[o2];
  return r2;
}, __await: xo$2, __asyncGenerator: function(e20, t2, n2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r2, i2 = n2.apply(e20, t2 || []), u2 = [];
  return r2 = {}, o2("next"), o2("throw"), o2("return"), r2[Symbol.asyncIterator] = function() {
    return this;
  }, r2;
  function o2(e21) {
    i2[e21] && (r2[e21] = function(t3) {
      return new Promise(function(n3, r3) {
        u2.push([e21, t3, n3, r3]) > 1 || s2(e21, t3);
      });
    });
  }
  function s2(e21, t3) {
    try {
      (n3 = i2[e21](t3)).value instanceof xo$2 ? Promise.resolve(n3.value.v).then(a2, c2) : l2(u2[0][2], n3);
    } catch (e22) {
      l2(u2[0][3], e22);
    }
    var n3;
  }
  function a2(e21) {
    s2("next", e21);
  }
  function c2(e21) {
    s2("throw", e21);
  }
  function l2(e21, t3) {
    e21(t3), u2.shift(), u2.length && s2(u2[0][0], u2[0][1]);
  }
}, __asyncDelegator: function(e20) {
  var t2, n2;
  return t2 = {}, r2("next"), r2("throw", function(e21) {
    throw e21;
  }), r2("return"), t2[Symbol.iterator] = function() {
    return this;
  }, t2;
  function r2(r3, i2) {
    t2[r3] = e20[r3] ? function(t3) {
      return (n2 = !n2) ? {value: xo$2(e20[r3](t3)), done: r3 === "return"} : i2 ? i2(t3) : t3;
    } : i2;
  }
}, __asyncValues: function(e20) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t2, n2 = e20[Symbol.asyncIterator];
  return n2 ? n2.call(e20) : (e20 = Fo$2(e20), t2 = {}, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
    return this;
  }, t2);
  function r2(n3) {
    t2[n3] = e20[n3] && function(t3) {
      return new Promise(function(r3, i2) {
        (function(e21, t4, n4, r4) {
          Promise.resolve(r4).then(function(t5) {
            e21({value: t5, done: n4});
          }, t4);
        })(r3, i2, (t3 = e20[n3](t3)).done, t3.value);
      });
    };
  }
}, __makeTemplateObject: function(e20, t2) {
  return Object.defineProperty ? Object.defineProperty(e20, "raw", {value: t2}) : e20.raw = t2, e20;
}, __importStar: function(e20) {
  if (e20 && e20.__esModule)
    return e20;
  var t2 = {};
  if (e20 != null)
    for (var n2 in e20)
      Object.hasOwnProperty.call(e20, n2) && (t2[n2] = e20[n2]);
  return t2.default = e20, t2;
}, __importDefault: function(e20) {
  return e20 && e20.__esModule ? e20 : {default: e20};
}, __classPrivateFieldGet: function(e20, t2) {
  if (!t2.has(e20))
    throw new TypeError("attempted to get private field on non-instance");
  return t2.get(e20);
}, __classPrivateFieldSet: function(e20, t2, n2) {
  if (!t2.has(e20))
    throw new TypeError("attempted to set private field on non-instance");
  return t2.set(e20, n2), n2;
}}), To$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), t2.apiDescriptor = {key: (e21) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e21) ? e21 : JSON.stringify(e21), value(e21) {
    if (e21 === null || typeof e21 != "object")
      return JSON.stringify(e21);
    if (Array.isArray(e21))
      return `[${e21.map((e22) => t2.apiDescriptor.value(e22)).join(", ")}]`;
    const n2 = Object.keys(e21);
    return n2.length === 0 ? "{}" : `{ ${n2.map((n3) => `${t2.apiDescriptor.key(n3)}: ${t2.apiDescriptor.value(e21[n3])}`).join(", ")} }`;
  }, pair: ({key: e21, value: n2}) => t2.apiDescriptor.value({[e21]: n2})};
}), Bo$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(To$2, t2);
}), No$2 = /[|\\{}()[\]^$+*?.]/g, ko$2 = function(e20) {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(No$2, "\\$&");
}, Po$2 = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50]}, Oo$2 = r$3(function(e20) {
  var t2 = {};
  for (var n2 in Po$2)
    Po$2.hasOwnProperty(n2) && (t2[Po$2[n2]] = n2);
  var r2 = e20.exports = {rgb: {channels: 3, labels: "rgb"}, hsl: {channels: 3, labels: "hsl"}, hsv: {channels: 3, labels: "hsv"}, hwb: {channels: 3, labels: "hwb"}, cmyk: {channels: 4, labels: "cmyk"}, xyz: {channels: 3, labels: "xyz"}, lab: {channels: 3, labels: "lab"}, lch: {channels: 3, labels: "lch"}, hex: {channels: 1, labels: ["hex"]}, keyword: {channels: 1, labels: ["keyword"]}, ansi16: {channels: 1, labels: ["ansi16"]}, ansi256: {channels: 1, labels: ["ansi256"]}, hcg: {channels: 3, labels: ["h", "c", "g"]}, apple: {channels: 3, labels: ["r16", "g16", "b16"]}, gray: {channels: 1, labels: ["gray"]}};
  for (var i2 in r2)
    if (r2.hasOwnProperty(i2)) {
      if (!("channels" in r2[i2]))
        throw new Error("missing channels property: " + i2);
      if (!("labels" in r2[i2]))
        throw new Error("missing channel labels property: " + i2);
      if (r2[i2].labels.length !== r2[i2].channels)
        throw new Error("channel and label counts mismatch: " + i2);
      var u2 = r2[i2].channels, o2 = r2[i2].labels;
      delete r2[i2].channels, delete r2[i2].labels, Object.defineProperty(r2[i2], "channels", {value: u2}), Object.defineProperty(r2[i2], "labels", {value: o2});
    }
  r2.rgb.hsl = function(e21) {
    var t3, n3, r3 = e21[0] / 255, i3 = e21[1] / 255, u3 = e21[2] / 255, o3 = Math.min(r3, i3, u3), s2 = Math.max(r3, i3, u3), a2 = s2 - o3;
    return s2 === o3 ? t3 = 0 : r3 === s2 ? t3 = (i3 - u3) / a2 : i3 === s2 ? t3 = 2 + (u3 - r3) / a2 : u3 === s2 && (t3 = 4 + (r3 - i3) / a2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (o3 + s2) / 2, [t3, 100 * (s2 === o3 ? 0 : n3 <= 0.5 ? a2 / (s2 + o3) : a2 / (2 - s2 - o3)), 100 * n3];
  }, r2.rgb.hsv = function(e21) {
    var t3, n3, r3, i3, u3, o3 = e21[0] / 255, s2 = e21[1] / 255, a2 = e21[2] / 255, c2 = Math.max(o3, s2, a2), l2 = c2 - Math.min(o3, s2, a2), p2 = function(e22) {
      return (c2 - e22) / 6 / l2 + 0.5;
    };
    return l2 === 0 ? i3 = u3 = 0 : (u3 = l2 / c2, t3 = p2(o3), n3 = p2(s2), r3 = p2(a2), o3 === c2 ? i3 = r3 - n3 : s2 === c2 ? i3 = 1 / 3 + t3 - r3 : a2 === c2 && (i3 = 2 / 3 + n3 - t3), i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1)), [360 * i3, 100 * u3, 100 * c2];
  }, r2.rgb.hwb = function(e21) {
    var t3 = e21[0], n3 = e21[1], i3 = e21[2];
    return [r2.rgb.hsl(e21)[0], 100 * (1 / 255 * Math.min(t3, Math.min(n3, i3))), 100 * (i3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, i3)))];
  }, r2.rgb.cmyk = function(e21) {
    var t3, n3 = e21[0] / 255, r3 = e21[1] / 255, i3 = e21[2] / 255;
    return [100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - i3))) / (1 - t3) || 0), 100 * ((1 - r3 - t3) / (1 - t3) || 0), 100 * ((1 - i3 - t3) / (1 - t3) || 0), 100 * t3];
  }, r2.rgb.keyword = function(e21) {
    var n3 = t2[e21];
    if (n3)
      return n3;
    var r3, i3, u3, o3 = 1 / 0;
    for (var s2 in Po$2)
      if (Po$2.hasOwnProperty(s2)) {
        var a2 = Po$2[s2], c2 = (i3 = e21, u3 = a2, Math.pow(i3[0] - u3[0], 2) + Math.pow(i3[1] - u3[1], 2) + Math.pow(i3[2] - u3[2], 2));
        c2 < o3 && (o3 = c2, r3 = s2);
      }
    return r3;
  }, r2.keyword.rgb = function(e21) {
    return Po$2[e21];
  }, r2.rgb.xyz = function(e21) {
    var t3 = e21[0] / 255, n3 = e21[1] / 255, r3 = e21[2] / 255;
    return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
  }, r2.rgb.lab = function(e21) {
    var t3 = r2.rgb.xyz(e21), n3 = t3[0], i3 = t3[1], u3 = t3[2];
    return i3 /= 100, u3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (i3 = i3 > 8856e-6 ? Math.pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116) - 16, 500 * (n3 - i3), 200 * (i3 - (u3 = u3 > 8856e-6 ? Math.pow(u3, 1 / 3) : 7.787 * u3 + 16 / 116))];
  }, r2.hsl.rgb = function(e21) {
    var t3, n3, r3, i3, u3, o3 = e21[0] / 360, s2 = e21[1] / 100, a2 = e21[2] / 100;
    if (s2 === 0)
      return [u3 = 255 * a2, u3, u3];
    t3 = 2 * a2 - (n3 = a2 < 0.5 ? a2 * (1 + s2) : a2 + s2 - a2 * s2), i3 = [0, 0, 0];
    for (var c2 = 0; c2 < 3; c2++)
      (r3 = o3 + 1 / 3 * -(c2 - 1)) < 0 && r3++, r3 > 1 && r3--, u3 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, i3[c2] = 255 * u3;
    return i3;
  }, r2.hsl.hsv = function(e21) {
    var t3 = e21[0], n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = n3, u3 = Math.max(r3, 0.01);
    return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, i3 *= u3 <= 1 ? u3 : 2 - u3, [t3, 100 * (r3 === 0 ? 2 * i3 / (u3 + i3) : 2 * n3 / (r3 + n3)), 100 * ((r3 + n3) / 2)];
  }, r2.hsv.rgb = function(e21) {
    var t3 = e21[0] / 60, n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = Math.floor(t3) % 6, u3 = t3 - Math.floor(t3), o3 = 255 * r3 * (1 - n3), s2 = 255 * r3 * (1 - n3 * u3), a2 = 255 * r3 * (1 - n3 * (1 - u3));
    switch (r3 *= 255, i3) {
      case 0:
        return [r3, a2, o3];
      case 1:
        return [s2, r3, o3];
      case 2:
        return [o3, r3, a2];
      case 3:
        return [o3, s2, r3];
      case 4:
        return [a2, o3, r3];
      case 5:
        return [r3, o3, s2];
    }
  }, r2.hsv.hsl = function(e21) {
    var t3, n3, r3, i3 = e21[0], u3 = e21[1] / 100, o3 = e21[2] / 100, s2 = Math.max(o3, 0.01);
    return r3 = (2 - u3) * o3, n3 = u3 * s2, [i3, 100 * (n3 = (n3 /= (t3 = (2 - u3) * s2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r3 /= 2)];
  }, r2.hwb.rgb = function(e21) {
    var t3, n3, r3, i3, u3, o3, s2, a2 = e21[0] / 360, c2 = e21[1] / 100, l2 = e21[2] / 100, p2 = c2 + l2;
    switch (p2 > 1 && (c2 /= p2, l2 /= p2), r3 = 6 * a2 - (t3 = Math.floor(6 * a2)), (1 & t3) != 0 && (r3 = 1 - r3), i3 = c2 + r3 * ((n3 = 1 - l2) - c2), t3) {
      default:
      case 6:
      case 0:
        u3 = n3, o3 = i3, s2 = c2;
        break;
      case 1:
        u3 = i3, o3 = n3, s2 = c2;
        break;
      case 2:
        u3 = c2, o3 = n3, s2 = i3;
        break;
      case 3:
        u3 = c2, o3 = i3, s2 = n3;
        break;
      case 4:
        u3 = i3, o3 = c2, s2 = n3;
        break;
      case 5:
        u3 = n3, o3 = c2, s2 = i3;
    }
    return [255 * u3, 255 * o3, 255 * s2];
  }, r2.cmyk.rgb = function(e21) {
    var t3 = e21[0] / 100, n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = e21[3] / 100;
    return [255 * (1 - Math.min(1, t3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, n3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, r3 * (1 - i3) + i3))];
  }, r2.xyz.rgb = function(e21) {
    var t3, n3, r3, i3 = e21[0] / 100, u3 = e21[1] / 100, o3 = e21[2] / 100;
    return n3 = -0.9689 * i3 + 1.8758 * u3 + 0.0415 * o3, r3 = 0.0557 * i3 + -0.204 * u3 + 1.057 * o3, t3 = (t3 = 3.2406 * i3 + -1.5372 * u3 + -0.4986 * o3) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (r3 = Math.min(Math.max(0, r3), 1))];
  }, r2.xyz.lab = function(e21) {
    var t3 = e21[0], n3 = e21[1], r3 = e21[2];
    return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (t3 - n3), 200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
  }, r2.lab.xyz = function(e21) {
    var t3, n3, r3, i3 = e21[0];
    t3 = e21[1] / 500 + (n3 = (i3 + 16) / 116), r3 = n3 - e21[2] / 200;
    var u3 = Math.pow(n3, 3), o3 = Math.pow(t3, 3), s2 = Math.pow(r3, 3);
    return n3 = u3 > 8856e-6 ? u3 : (n3 - 16 / 116) / 7.787, t3 = o3 > 8856e-6 ? o3 : (t3 - 16 / 116) / 7.787, r3 = s2 > 8856e-6 ? s2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
  }, r2.lab.lch = function(e21) {
    var t3, n3 = e21[0], r3 = e21[1], i3 = e21[2];
    return (t3 = 360 * Math.atan2(i3, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + i3 * i3), t3];
  }, r2.lch.lab = function(e21) {
    var t3, n3 = e21[0], r3 = e21[1];
    return t3 = e21[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
  }, r2.rgb.ansi16 = function(e21) {
    var t3 = e21[0], n3 = e21[1], i3 = e21[2], u3 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e21)[2];
    if ((u3 = Math.round(u3 / 50)) === 0)
      return 30;
    var o3 = 30 + (Math.round(i3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
    return u3 === 2 && (o3 += 60), o3;
  }, r2.hsv.ansi16 = function(e21) {
    return r2.rgb.ansi16(r2.hsv.rgb(e21), e21[2]);
  }, r2.rgb.ansi256 = function(e21) {
    var t3 = e21[0], n3 = e21[1], r3 = e21[2];
    return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
  }, r2.ansi16.rgb = function(e21) {
    var t3 = e21 % 10;
    if (t3 === 0 || t3 === 7)
      return e21 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
    var n3 = 0.5 * (1 + ~~(e21 > 50));
    return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
  }, r2.ansi256.rgb = function(e21) {
    if (e21 >= 232) {
      var t3 = 10 * (e21 - 232) + 8;
      return [t3, t3, t3];
    }
    var n3;
    return e21 -= 16, [Math.floor(e21 / 36) / 5 * 255, Math.floor((n3 = e21 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
  }, r2.rgb.hex = function(e21) {
    var t3 = (((255 & Math.round(e21[0])) << 16) + ((255 & Math.round(e21[1])) << 8) + (255 & Math.round(e21[2]))).toString(16).toUpperCase();
    return "000000".substring(t3.length) + t3;
  }, r2.hex.rgb = function(e21) {
    var t3 = e21.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t3)
      return [0, 0, 0];
    var n3 = t3[0];
    t3[0].length === 3 && (n3 = n3.split("").map(function(e22) {
      return e22 + e22;
    }).join(""));
    var r3 = parseInt(n3, 16);
    return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
  }, r2.rgb.hcg = function(e21) {
    var t3, n3 = e21[0] / 255, r3 = e21[1] / 255, i3 = e21[2] / 255, u3 = Math.max(Math.max(n3, r3), i3), o3 = Math.min(Math.min(n3, r3), i3), s2 = u3 - o3;
    return t3 = s2 <= 0 ? 0 : u3 === n3 ? (r3 - i3) / s2 % 6 : u3 === r3 ? 2 + (i3 - n3) / s2 : 4 + (n3 - r3) / s2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * s2, 100 * (s2 < 1 ? o3 / (1 - s2) : 0)];
  }, r2.hsl.hcg = function(e21) {
    var t3 = e21[1] / 100, n3 = e21[2] / 100, r3 = 1, i3 = 0;
    return (r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3)) < 1 && (i3 = (n3 - 0.5 * r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
  }, r2.hsv.hcg = function(e21) {
    var t3 = e21[1] / 100, n3 = e21[2] / 100, r3 = t3 * n3, i3 = 0;
    return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
  }, r2.hcg.rgb = function(e21) {
    var t3 = e21[0] / 360, n3 = e21[1] / 100, r3 = e21[2] / 100;
    if (n3 === 0)
      return [255 * r3, 255 * r3, 255 * r3];
    var i3, u3 = [0, 0, 0], o3 = t3 % 1 * 6, s2 = o3 % 1, a2 = 1 - s2;
    switch (Math.floor(o3)) {
      case 0:
        u3[0] = 1, u3[1] = s2, u3[2] = 0;
        break;
      case 1:
        u3[0] = a2, u3[1] = 1, u3[2] = 0;
        break;
      case 2:
        u3[0] = 0, u3[1] = 1, u3[2] = s2;
        break;
      case 3:
        u3[0] = 0, u3[1] = a2, u3[2] = 1;
        break;
      case 4:
        u3[0] = s2, u3[1] = 0, u3[2] = 1;
        break;
      default:
        u3[0] = 1, u3[1] = 0, u3[2] = a2;
    }
    return i3 = (1 - n3) * r3, [255 * (n3 * u3[0] + i3), 255 * (n3 * u3[1] + i3), 255 * (n3 * u3[2] + i3)];
  }, r2.hcg.hsv = function(e21) {
    var t3 = e21[1] / 100, n3 = t3 + e21[2] / 100 * (1 - t3), r3 = 0;
    return n3 > 0 && (r3 = t3 / n3), [e21[0], 100 * r3, 100 * n3];
  }, r2.hcg.hsl = function(e21) {
    var t3 = e21[1] / 100, n3 = e21[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
    return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e21[0], 100 * r3, 100 * n3];
  }, r2.hcg.hwb = function(e21) {
    var t3 = e21[1] / 100, n3 = t3 + e21[2] / 100 * (1 - t3);
    return [e21[0], 100 * (n3 - t3), 100 * (1 - n3)];
  }, r2.hwb.hcg = function(e21) {
    var t3 = e21[1] / 100, n3 = 1 - e21[2] / 100, r3 = n3 - t3, i3 = 0;
    return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
  }, r2.apple.rgb = function(e21) {
    return [e21[0] / 65535 * 255, e21[1] / 65535 * 255, e21[2] / 65535 * 255];
  }, r2.rgb.apple = function(e21) {
    return [e21[0] / 255 * 65535, e21[1] / 255 * 65535, e21[2] / 255 * 65535];
  }, r2.gray.rgb = function(e21) {
    return [e21[0] / 100 * 255, e21[0] / 100 * 255, e21[0] / 100 * 255];
  }, r2.gray.hsl = r2.gray.hsv = function(e21) {
    return [0, 0, e21[0]];
  }, r2.gray.hwb = function(e21) {
    return [0, 100, e21[0]];
  }, r2.gray.cmyk = function(e21) {
    return [0, 0, 0, e21[0]];
  }, r2.gray.lab = function(e21) {
    return [e21[0], 0, 0];
  }, r2.gray.hex = function(e21) {
    var t3 = 255 & Math.round(e21[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
    return "000000".substring(n3.length) + n3;
  }, r2.rgb.gray = function(e21) {
    return [(e21[0] + e21[1] + e21[2]) / 3 / 255 * 100];
  };
});
function Io$2(e20) {
  var t2 = function() {
    for (var e21 = {}, t3 = Object.keys(Oo$2), n3 = t3.length, r3 = 0; r3 < n3; r3++)
      e21[t3[r3]] = {distance: -1, parent: null};
    return e21;
  }(), n2 = [e20];
  for (t2[e20].distance = 0; n2.length; )
    for (var r2 = n2.pop(), i2 = Object.keys(Oo$2[r2]), u2 = i2.length, o2 = 0; o2 < u2; o2++) {
      var s2 = i2[o2], a2 = t2[s2];
      a2.distance === -1 && (a2.distance = t2[r2].distance + 1, a2.parent = r2, n2.unshift(s2));
    }
  return t2;
}
function Lo$2(e20, t2) {
  return function(n2) {
    return t2(e20(n2));
  };
}
function jo$1(e20, t2) {
  for (var n2 = [t2[e20].parent, e20], r2 = Oo$2[t2[e20].parent][e20], i2 = t2[e20].parent; t2[i2].parent; )
    n2.unshift(t2[i2].parent), r2 = Lo$2(Oo$2[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
  return r2.conversion = n2, r2;
}
var _o$2 = {};
Object.keys(Oo$2).forEach(function(e20) {
  _o$2[e20] = {}, Object.defineProperty(_o$2[e20], "channels", {value: Oo$2[e20].channels}), Object.defineProperty(_o$2[e20], "labels", {value: Oo$2[e20].labels});
  var t2 = function(e21) {
    for (var t3 = Io$2(e21), n2 = {}, r2 = Object.keys(t3), i2 = r2.length, u2 = 0; u2 < i2; u2++) {
      var o2 = r2[u2];
      t3[o2].parent !== null && (n2[o2] = jo$1(o2, t3));
    }
    return n2;
  }(e20);
  Object.keys(t2).forEach(function(n2) {
    var r2 = t2[n2];
    _o$2[e20][n2] = function(e21) {
      var t3 = function(t4) {
        if (t4 == null)
          return t4;
        arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
        var n3 = e21(t4);
        if (typeof n3 == "object")
          for (var r3 = n3.length, i2 = 0; i2 < r3; i2++)
            n3[i2] = Math.round(n3[i2]);
        return n3;
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2), _o$2[e20][n2].raw = function(e21) {
      var t3 = function(t4) {
        return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e21(t4));
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2);
  });
});
var Mo$1, Ro$2 = _o$2, $o$1 = r$3(function(e20) {
  const t2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${n3 + t3}m`;
  }, n2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};5;${n3}m`;
  }, r2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
  };
  Object.defineProperty(e20, "exports", {enumerable: true, get: function() {
    const e21 = new Map(), i2 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
    i2.color.grey = i2.color.gray;
    for (const t3 of Object.keys(i2)) {
      const n3 = i2[t3];
      for (const t4 of Object.keys(n3)) {
        const r3 = n3[t4];
        i2[t4] = {open: `[${r3[0]}m`, close: `[${r3[1]}m`}, n3[t4] = i2[t4], e21.set(r3[0], r3[1]);
      }
      Object.defineProperty(i2, t3, {value: n3, enumerable: false}), Object.defineProperty(i2, "codes", {value: e21, enumerable: false});
    }
    const u2 = (e22) => e22, o2 = (e22, t3, n3) => [e22, t3, n3];
    i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = {ansi: t2(u2, 0)}, i2.color.ansi256 = {ansi256: n2(u2, 0)}, i2.color.ansi16m = {rgb: r2(o2, 0)}, i2.bgColor.ansi = {ansi: t2(u2, 10)}, i2.bgColor.ansi256 = {ansi256: n2(u2, 10)}, i2.bgColor.ansi16m = {rgb: r2(o2, 10)};
    for (let e22 of Object.keys(Ro$2)) {
      if (typeof Ro$2[e22] != "object")
        continue;
      const u3 = Ro$2[e22];
      e22 === "ansi16" && (e22 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e22] = t2(u3.ansi16, 0), i2.bgColor.ansi[e22] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e22] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e22] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e22] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e22] = r2(u3.rgb, 10));
    }
    return i2;
  }});
});
function Vo$1() {
  if (Mo$1 === void 0) {
    var e20 = new ArrayBuffer(2), t2 = new Uint8Array(e20), n2 = new Uint16Array(e20);
    if (t2[0] = 1, t2[1] = 2, n2[0] === 258)
      Mo$1 = "BE";
    else {
      if (n2[0] !== 513)
        throw new Error("unable to figure out endianess");
      Mo$1 = "LE";
    }
  }
  return Mo$1;
}
function Wo$1() {
  return nr$2.location !== void 0 ? nr$2.location.hostname : "";
}
function qo$1() {
  return [];
}
function Uo$1() {
  return 0;
}
function zo$1() {
  return Number.MAX_VALUE;
}
function Go$1() {
  return Number.MAX_VALUE;
}
function Ho$1() {
  return [];
}
function Jo$1() {
  return "Browser";
}
function Xo$1() {
  return nr$2.navigator !== void 0 ? nr$2.navigator.appVersion : "";
}
function Yo$1() {
}
function Ko$1() {
}
function Qo$1() {
  return "javascript";
}
function Zo$1() {
  return "browser";
}
function es$2() {
  return "/tmp";
}
var ts$2 = es$2, ns$2 = {EOL: "\n", arch: Qo$1, platform: Zo$1, tmpdir: ts$2, tmpDir: es$2, networkInterfaces: Yo$1, getNetworkInterfaces: Ko$1, release: Xo$1, type: Jo$1, cpus: Ho$1, totalmem: Go$1, freemem: zo$1, uptime: Uo$1, loadavg: qo$1, hostname: Wo$1, endianness: Vo$1}, rs$2 = (e20, t2) => {
  t2 = t2 || xr$2.argv;
  const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
  return r2 !== -1 && (i2 === -1 || r2 < i2);
}, is$2 = n$3(Object.freeze({__proto__: null, endianness: Vo$1, hostname: Wo$1, loadavg: qo$1, uptime: Uo$1, freemem: zo$1, totalmem: Go$1, cpus: Ho$1, type: Jo$1, release: Xo$1, networkInterfaces: Yo$1, getNetworkInterfaces: Ko$1, arch: Qo$1, platform: Zo$1, tmpDir: es$2, tmpdir: ts$2, EOL: "\n", default: ns$2}));
const us$2 = xr$2.env;
let os$2;
function ss$2(e20) {
  return function(e21) {
    return e21 !== 0 && {level: e21, hasBasic: true, has256: e21 >= 2, has16m: e21 >= 3};
  }(function(e21) {
    if (os$2 === false)
      return 0;
    if (rs$2("color=16m") || rs$2("color=full") || rs$2("color=truecolor"))
      return 3;
    if (rs$2("color=256"))
      return 2;
    if (e21 && !e21.isTTY && os$2 !== true)
      return 0;
    const t2 = os$2 ? 1 : 0;
    if (xr$2.platform === "win32") {
      const e22 = is$2.release().split(".");
      return Number(xr$2.versions.node.split(".")[0]) >= 8 && Number(e22[0]) >= 10 && Number(e22[2]) >= 10586 ? Number(e22[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in us$2)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e22) => e22 in us$2) || us$2.CI_NAME === "codeship" ? 1 : t2;
    if ("TEAMCITY_VERSION" in us$2)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(us$2.TEAMCITY_VERSION) ? 1 : 0;
    if (us$2.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in us$2) {
      const e22 = parseInt((us$2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (us$2.TERM_PROGRAM) {
        case "iTerm.app":
          return e22 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(us$2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(us$2.TERM) || "COLORTERM" in us$2 ? 1 : (us$2.TERM, t2);
  }(e20));
}
rs$2("no-color") || rs$2("no-colors") || rs$2("color=false") ? os$2 = false : (rs$2("color") || rs$2("colors") || rs$2("color=true") || rs$2("color=always")) && (os$2 = true), "FORCE_COLOR" in us$2 && (os$2 = us$2.FORCE_COLOR.length === 0 || parseInt(us$2.FORCE_COLOR, 10) !== 0);
var as$2 = {supportsColor: ss$2, stdout: ss$2(xr$2.stdout), stderr: ss$2(xr$2.stderr)};
const cs$2 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, ls$2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, ps$2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, fs$2 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, ds$2 = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
function hs$2(e20) {
  return e20[0] === "u" && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : ds$2.get(e20) || e20;
}
function gs$2(e20, t2) {
  const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
  let i2;
  for (const t3 of r2)
    if (isNaN(t3)) {
      if (!(i2 = t3.match(ps$2)))
        throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
      n2.push(i2[2].replace(fs$2, (e21, t4, n3) => t4 ? hs$2(t4) : n3));
    } else
      n2.push(Number(t3));
  return n2;
}
function ms$2(e20) {
  ls$2.lastIndex = 0;
  const t2 = [];
  let n2;
  for (; (n2 = ls$2.exec(e20)) !== null; ) {
    const e21 = n2[1];
    if (n2[2]) {
      const r2 = gs$2(e21, n2[2]);
      t2.push([e21].concat(r2));
    } else
      t2.push([e21]);
  }
  return t2;
}
function ys$2(e20, t2) {
  const n2 = {};
  for (const e21 of t2)
    for (const t3 of e21.styles)
      n2[t3[0]] = e21.inverse ? null : t3.slice(1);
  let r2 = e20;
  for (const e21 of Object.keys(n2))
    if (Array.isArray(n2[e21])) {
      if (!(e21 in r2))
        throw new Error(`Unknown Chalk style: ${e21}`);
      r2 = n2[e21].length > 0 ? r2[e21].apply(r2, n2[e21]) : r2[e21];
    }
  return r2;
}
var Ds$2 = (e20, t2) => {
  const n2 = [], r2 = [];
  let i2 = [];
  if (t2.replace(cs$2, (t3, u2, o2, s2, a2, c2) => {
    if (u2)
      i2.push(hs$2(u2));
    else if (s2) {
      const t4 = i2.join("");
      i2 = [], r2.push(n2.length === 0 ? t4 : ys$2(e20, n2)(t4)), n2.push({inverse: o2, styles: ms$2(s2)});
    } else if (a2) {
      if (n2.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      r2.push(ys$2(e20, n2)(i2.join(""))), i2 = [], n2.pop();
    } else
      i2.push(c2);
  }), r2.push(i2.join("")), n2.length > 0) {
    const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(e21);
  }
  return r2.join("");
}, Es$2 = r$3(function(e20) {
  const t2 = as$2.stdout, n2 = xr$2.platform === "win32" && !(xr$2.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
  function o2(e21, n3) {
    n3 = n3 || {};
    const r3 = t2 ? t2.level : 0;
    e21.level = n3.level === void 0 ? r3 : n3.level, e21.enabled = "enabled" in n3 ? n3.enabled : e21.level > 0;
  }
  function s2(e21) {
    if (!this || !(this instanceof s2) || this.template) {
      const t3 = {};
      return o2(t3, e21), t3.template = function() {
        const e22 = [].slice.call(arguments);
        return p2.apply(null, [t3.template].concat(e22));
      }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
    }
    o2(this, e21);
  }
  n2 && ($o$1.blue.open = "[94m");
  for (const e21 of Object.keys($o$1))
    $o$1[e21].closeRe = new RegExp(ko$2($o$1[e21].close), "g"), u2[e21] = {get() {
      const t3 = $o$1[e21];
      return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e21);
    }};
  u2.visible = {get() {
    return c2.call(this, this._styles || [], true, "visible");
  }}, $o$1.color.closeRe = new RegExp(ko$2($o$1.color.close), "g");
  for (const e21 of Object.keys($o$1.color.ansi))
    i2.has(e21) || (u2[e21] = {get() {
      const t3 = this.level;
      return function() {
        const n3 = $o$1.color[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: $o$1.color.close, closeRe: $o$1.color.closeRe};
        return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
      };
    }});
  $o$1.bgColor.closeRe = new RegExp(ko$2($o$1.bgColor.close), "g");
  for (const e21 of Object.keys($o$1.bgColor.ansi)) {
    if (i2.has(e21))
      continue;
    u2["bg" + e21[0].toUpperCase() + e21.slice(1)] = {get() {
      const t3 = this.level;
      return function() {
        const n3 = $o$1.bgColor[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: $o$1.bgColor.close, closeRe: $o$1.bgColor.closeRe};
        return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
      };
    }};
  }
  const a2 = Object.defineProperties(() => {
  }, u2);
  function c2(e21, t3, n3) {
    const r3 = function() {
      return l2.apply(r3, arguments);
    };
    r3._styles = e21, r3._empty = t3;
    const i3 = this;
    return Object.defineProperty(r3, "level", {enumerable: true, get: () => i3.level, set(e22) {
      i3.level = e22;
    }}), Object.defineProperty(r3, "enabled", {enumerable: true, get: () => i3.enabled, set(e22) {
      i3.enabled = e22;
    }}), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = a2, r3;
  }
  function l2() {
    const e21 = arguments, t3 = e21.length;
    let r3 = String(arguments[0]);
    if (t3 === 0)
      return "";
    if (t3 > 1)
      for (let n3 = 1; n3 < t3; n3++)
        r3 += " " + e21[n3];
    if (!this.enabled || this.level <= 0 || !r3)
      return this._empty ? "" : r3;
    const i3 = $o$1.dim.open;
    n2 && this.hasGrey && ($o$1.dim.open = "");
    for (const e22 of this._styles.slice().reverse())
      r3 = e22.open + r3.replace(e22.closeRe, e22.open) + e22.close, r3 = r3.replace(/\r?\n/g, `${e22.close}$&${e22.open}`);
    return $o$1.dim.open = i3, r3;
  }
  function p2(e21, t3) {
    if (!Array.isArray(t3))
      return [].slice.call(arguments, 1).join(" ");
    const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
    for (let e22 = 1; e22 < t3.length; e22++)
      r3.push(String(n3[e22 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e22]));
    return Ds$2(e21, r3.join(""));
  }
  Object.defineProperties(s2.prototype, u2), e20.exports = s2(), e20.exports.supportsColor = t2, e20.exports.default = e20.exports;
}), Cs$2 = Object.defineProperty({commonDeprecatedHandler: (e20, t2, {descriptor: n2}) => {
  const r2 = [`${Es$2.default.yellow(typeof e20 == "string" ? n2.key(e20) : n2.pair(e20))} is deprecated`];
  return t2 && r2.push(`we now treat it as ${Es$2.default.blue(typeof t2 == "string" ? n2.key(t2) : n2.pair(t2))}`), r2.join("; ") + ".";
}}, "__esModule", {value: true}), bs$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(Cs$2, t2);
}), As$2 = Object.defineProperty({commonInvalidHandler: (e20, t2, n2) => [`Invalid ${Es$2.default.red(n2.descriptor.key(e20))} value.`, `Expected ${Es$2.default.blue(n2.schemas[e20].expected(n2))},`, `but received ${Es$2.default.red(n2.descriptor.value(t2))}.`].join(" ")}, "__esModule", {value: true}), vs$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(As$2, t2);
}), Fs$2 = [], Ss$2 = [], xs$2 = Object.defineProperty({levenUnknownHandler: (e20, t2, {descriptor: n2, logger: r2, schemas: i2}) => {
  const u2 = [`Ignored unknown option ${Es$2.default.yellow(n2.pair({key: e20, value: t2}))}.`], o2 = Object.keys(i2).sort().find((t3) => function(e21, t4) {
    if (e21 === t4)
      return 0;
    var n3 = e21;
    e21.length > t4.length && (e21 = t4, t4 = n3);
    var r3 = e21.length, i3 = t4.length;
    if (r3 === 0)
      return i3;
    if (i3 === 0)
      return r3;
    for (; r3 > 0 && e21.charCodeAt(~-r3) === t4.charCodeAt(~-i3); )
      r3--, i3--;
    if (r3 === 0)
      return i3;
    for (var u3, o3, s2, a2, c2 = 0; c2 < r3 && e21.charCodeAt(c2) === t4.charCodeAt(c2); )
      c2++;
    if (i3 -= c2, (r3 -= c2) == 0)
      return i3;
    for (var l2 = 0, p2 = 0; l2 < r3; )
      Ss$2[c2 + l2] = e21.charCodeAt(c2 + l2), Fs$2[l2] = ++l2;
    for (; p2 < i3; )
      for (u3 = t4.charCodeAt(c2 + p2), s2 = p2++, o3 = p2, l2 = 0; l2 < r3; l2++)
        a2 = u3 === Ss$2[c2 + l2] ? s2 : s2 + 1, s2 = Fs$2[l2], o3 = Fs$2[l2] = s2 > o3 ? a2 > o3 ? o3 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
    return o3;
  }(e20, t3) < 3);
  o2 && u2.push(`Did you mean ${Es$2.default.blue(n2.key(o2))}?`), r2.warn(u2.join(" "));
}}, "__esModule", {value: true}), ws$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(xs$2, t2);
}), Ts$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(bs$2, t2), wo$2.__exportStar(vs$2, t2), wo$2.__exportStar(ws$2, t2);
});
const Bs$2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function Ns$2(e20, t2) {
  const n2 = new e20(t2), r2 = Object.create(n2);
  for (const e21 of Bs$2)
    e21 in t2 && (r2[e21] = Is$2(t2[e21], n2, Ps$2.prototype[e21].length));
  return r2;
}
var ks$2 = Ns$2;
class Ps$2 {
  constructor(e20) {
    this.name = e20.name;
  }
  static create(e20) {
    return Ns$2(this, e20);
  }
  default(e20) {
  }
  expected(e20) {
    return "nothing";
  }
  validate(e20, t2) {
    return false;
  }
  deprecated(e20, t2) {
    return false;
  }
  forward(e20, t2) {
  }
  redirect(e20, t2) {
  }
  overlap(e20, t2, n2) {
    return e20;
  }
  preprocess(e20, t2) {
    return e20;
  }
  postprocess(e20, t2) {
    return e20;
  }
}
var Os$2 = Ps$2;
function Is$2(e20, t2, n2) {
  return typeof e20 == "function" ? (...r2) => e20(...r2.slice(0, n2 - 1), t2, ...r2.slice(n2 - 1)) : () => e20;
}
var Ls$2 = Object.defineProperty({createSchema: ks$2, Schema: Os$2}, "__esModule", {value: true});
class js$2 extends Ls$2.Schema {
  constructor(e20) {
    super(e20), this._sourceName = e20.sourceName;
  }
  expected(e20) {
    return e20.schemas[this._sourceName].expected(e20);
  }
  validate(e20, t2) {
    return t2.schemas[this._sourceName].validate(e20, t2);
  }
  redirect(e20, t2) {
    return this._sourceName;
  }
}
var _s$2 = js$2, Ms$2 = Object.defineProperty({AliasSchema: _s$2}, "__esModule", {value: true});
class Rs$2 extends Ls$2.Schema {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
}
var $s$2 = Rs$2, Vs$2 = Object.defineProperty({AnySchema: $s$2}, "__esModule", {value: true});
class Ws$2 extends Ls$2.Schema {
  constructor(e20) {
    var {valueSchema: t2, name: n2 = t2.name} = e20, r2 = wo$2.__rest(e20, ["valueSchema", "name"]);
    super(Object.assign({}, r2, {name: n2})), this._valueSchema = t2;
  }
  expected(e20) {
    return `an array of ${this._valueSchema.expected(e20)}`;
  }
  validate(e20, t2) {
    if (!Array.isArray(e20))
      return false;
    const n2 = [];
    for (const r2 of e20) {
      const e21 = t2.normalizeValidateResult(this._valueSchema.validate(r2, t2), r2);
      e21 !== true && n2.push(e21.value);
    }
    return n2.length === 0 || {value: n2};
  }
  deprecated(e20, t2) {
    const n2 = [];
    for (const r2 of e20) {
      const e21 = t2.normalizeDeprecatedResult(this._valueSchema.deprecated(r2, t2), r2);
      e21 !== false && n2.push(...e21.map(({value: e22}) => ({value: [e22]})));
    }
    return n2;
  }
  forward(e20, t2) {
    const n2 = [];
    for (const r2 of e20) {
      const e21 = t2.normalizeForwardResult(this._valueSchema.forward(r2, t2), r2);
      n2.push(...e21.map(Us$2));
    }
    return n2;
  }
  redirect(e20, t2) {
    const n2 = [], r2 = [];
    for (const i2 of e20) {
      const e21 = t2.normalizeRedirectResult(this._valueSchema.redirect(i2, t2), i2);
      "remain" in e21 && n2.push(e21.remain), r2.push(...e21.redirect.map(Us$2));
    }
    return n2.length === 0 ? {redirect: r2} : {redirect: r2, remain: n2};
  }
  overlap(e20, t2) {
    return e20.concat(t2);
  }
}
var qs$2 = Ws$2;
function Us$2({from: e20, to: t2}) {
  return {from: [e20], to: t2};
}
var zs$2 = Object.defineProperty({ArraySchema: qs$2}, "__esModule", {value: true});
class Gs$2 extends Ls$2.Schema {
  expected() {
    return "true or false";
  }
  validate(e20) {
    return typeof e20 == "boolean";
  }
}
var Hs$2 = Gs$2, Js$2 = Object.defineProperty({BooleanSchema: Hs$2}, "__esModule", {value: true});
var Xs$2 = function(e20, t2) {
  const n2 = Object.create(null);
  for (const r2 of e20) {
    const e21 = r2[t2];
    if (n2[e21])
      throw new Error(`Duplicate ${t2} ${JSON.stringify(e21)}`);
    n2[e21] = r2;
  }
  return n2;
};
var Ys$2 = function(e20, t2) {
  const n2 = new Map();
  for (const r2 of e20) {
    const e21 = r2[t2];
    if (n2.has(e21))
      throw new Error(`Duplicate ${t2} ${JSON.stringify(e21)}`);
    n2.set(e21, r2);
  }
  return n2;
};
var Ks$2 = function() {
  const e20 = Object.create(null);
  return (t2) => {
    const n2 = JSON.stringify(t2);
    return !!e20[n2] || (e20[n2] = true, false);
  };
};
var Qs$2 = function(e20, t2) {
  const n2 = [], r2 = [];
  for (const i2 of e20)
    t2(i2) ? n2.push(i2) : r2.push(i2);
  return [n2, r2];
};
var Zs$2 = function(e20) {
  return e20 === Math.floor(e20);
};
var ea$1 = function(e20, t2) {
  if (e20 === t2)
    return 0;
  const n2 = typeof e20, r2 = typeof t2, i2 = ["undefined", "object", "boolean", "number", "string"];
  return n2 !== r2 ? i2.indexOf(n2) - i2.indexOf(r2) : n2 !== "string" ? Number(e20) - Number(t2) : e20.localeCompare(t2);
};
var ta$1 = function(e20) {
  return e20 === void 0 ? {} : e20;
};
var na$1 = function(e20, t2) {
  return e20 === true || (e20 === false ? {value: t2} : e20);
};
var ra$1 = function(e20, t2, n2 = false) {
  return e20 !== false && (e20 === true ? !!n2 || [{value: t2}] : "value" in e20 ? [e20] : e20.length !== 0 && e20);
};
function ia$1(e20, t2) {
  return typeof e20 == "string" || "key" in e20 ? {from: t2, to: e20} : "from" in e20 ? {from: e20.from, to: e20.to} : {from: t2, to: e20.to};
}
var ua$1 = ia$1;
function oa$1(e20, t2) {
  return e20 === void 0 ? [] : Array.isArray(e20) ? e20.map((e21) => ia$1(e21, t2)) : [ia$1(e20, t2)];
}
var sa$1 = oa$1;
var aa$1 = function(e20, t2) {
  const n2 = oa$1(typeof e20 == "object" && "redirect" in e20 ? e20.redirect : e20, t2);
  return n2.length === 0 ? {remain: t2, redirect: n2} : typeof e20 == "object" && "remain" in e20 ? {remain: e20.remain, redirect: n2} : {redirect: n2};
}, ca$1 = Object.defineProperty({recordFromArray: Xs$2, mapFromArray: Ys$2, createAutoChecklist: Ks$2, partition: Qs$2, isInt: Zs$2, comparePrimitive: ea$1, normalizeDefaultResult: ta$1, normalizeValidateResult: na$1, normalizeDeprecatedResult: ra$1, normalizeTransferResult: ua$1, normalizeForwardResult: sa$1, normalizeRedirectResult: aa$1}, "__esModule", {value: true});
class la$1 extends Ls$2.Schema {
  constructor(e20) {
    super(e20), this._choices = ca$1.mapFromArray(e20.choices.map((e21) => e21 && typeof e21 == "object" ? e21 : {value: e21}), "value");
  }
  expected({descriptor: e20}) {
    const t2 = Array.from(this._choices.keys()).map((e21) => this._choices.get(e21)).filter((e21) => !e21.deprecated).map((e21) => e21.value).sort(ca$1.comparePrimitive).map(e20.value), n2 = t2.slice(0, -2), r2 = t2.slice(-2);
    return n2.concat(r2.join(" or ")).join(", ");
  }
  validate(e20) {
    return this._choices.has(e20);
  }
  deprecated(e20) {
    const t2 = this._choices.get(e20);
    return !(!t2 || !t2.deprecated) && {value: e20};
  }
  forward(e20) {
    const t2 = this._choices.get(e20);
    return t2 ? t2.forward : void 0;
  }
  redirect(e20) {
    const t2 = this._choices.get(e20);
    return t2 ? t2.redirect : void 0;
  }
}
var pa$1 = la$1, fa$1 = Object.defineProperty({ChoiceSchema: pa$1}, "__esModule", {value: true});
class da$1 extends Ls$2.Schema {
  expected() {
    return "a number";
  }
  validate(e20, t2) {
    return typeof e20 == "number";
  }
}
var ha$1 = da$1, ga$1 = Object.defineProperty({NumberSchema: ha$1}, "__esModule", {value: true});
class ma$1 extends ga$1.NumberSchema {
  expected() {
    return "an integer";
  }
  validate(e20, t2) {
    return t2.normalizeValidateResult(super.validate(e20, t2), e20) === true && ca$1.isInt(e20);
  }
}
var ya$1 = ma$1, Da$1 = Object.defineProperty({IntegerSchema: ya$1}, "__esModule", {value: true});
class Ea$1 extends Ls$2.Schema {
  expected() {
    return "a string";
  }
  validate(e20) {
    return typeof e20 == "string";
  }
}
var Ca$1 = Ea$1, ba$1 = Object.defineProperty({StringSchema: Ca$1}, "__esModule", {value: true}), Aa$1 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(Ms$2, t2), wo$2.__exportStar(Vs$2, t2), wo$2.__exportStar(zs$2, t2), wo$2.__exportStar(Js$2, t2), wo$2.__exportStar(fa$1, t2), wo$2.__exportStar(Da$1, t2), wo$2.__exportStar(ga$1, t2), wo$2.__exportStar(ba$1, t2);
}), va$1 = To$2.apiDescriptor, Fa$1 = xs$2.levenUnknownHandler, Sa$1 = vs$2.commonInvalidHandler, xa$1 = Cs$2.commonDeprecatedHandler, wa$1 = Object.defineProperty({defaultDescriptor: va$1, defaultUnknownHandler: Fa$1, defaultInvalidHandler: Sa$1, defaultDeprecatedHandler: xa$1}, "__esModule", {value: true});
class Ta$1 {
  constructor(e20, t2) {
    const {logger: n2 = console, descriptor: r2 = wa$1.defaultDescriptor, unknown: i2 = wa$1.defaultUnknownHandler, invalid: u2 = wa$1.defaultInvalidHandler, deprecated: o2 = wa$1.defaultDeprecatedHandler} = t2 || {};
    this._utils = {descriptor: r2, logger: n2 || {warn: () => {
    }}, schemas: ca$1.recordFromArray(e20, "name"), normalizeDefaultResult: ca$1.normalizeDefaultResult, normalizeDeprecatedResult: ca$1.normalizeDeprecatedResult, normalizeForwardResult: ca$1.normalizeForwardResult, normalizeRedirectResult: ca$1.normalizeRedirectResult, normalizeValidateResult: ca$1.normalizeValidateResult}, this._unknownHandler = i2, this._invalidHandler = u2, this._deprecatedHandler = o2, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = ca$1.createAutoChecklist();
  }
  normalize(e20) {
    const t2 = {}, n2 = [e20], r2 = () => {
      for (; n2.length !== 0; ) {
        const e21 = n2.shift(), r3 = this._applyNormalization(e21, t2);
        n2.push(...r3);
      }
    };
    r2();
    for (const e21 of Object.keys(this._utils.schemas)) {
      const r3 = this._utils.schemas[e21];
      if (!(e21 in t2)) {
        const t3 = ca$1.normalizeDefaultResult(r3.default(this._utils));
        "value" in t3 && n2.push({[e21]: t3.value});
      }
    }
    r2();
    for (const e21 of Object.keys(this._utils.schemas)) {
      const n3 = this._utils.schemas[e21];
      e21 in t2 && (t2[e21] = n3.postprocess(t2[e21], this._utils));
    }
    return t2;
  }
  _applyNormalization(e20, t2) {
    const n2 = [], [r2, i2] = ca$1.partition(Object.keys(e20), (e21) => e21 in this._utils.schemas);
    for (const i3 of r2) {
      const r3 = this._utils.schemas[i3], u2 = r3.preprocess(e20[i3], this._utils), o2 = ca$1.normalizeValidateResult(r3.validate(u2, this._utils), u2);
      if (o2 !== true) {
        const {value: e21} = o2, t3 = this._invalidHandler(i3, e21, this._utils);
        throw typeof t3 == "string" ? new Error(t3) : t3;
      }
      const s2 = ({from: e21, to: t3}) => {
        n2.push(typeof t3 == "string" ? {[t3]: e21} : {[t3.key]: t3.value});
      }, a2 = ({value: e21, redirectTo: t3}) => {
        const n3 = ca$1.normalizeDeprecatedResult(r3.deprecated(e21, this._utils), u2, true);
        if (n3 !== false)
          if (n3 === true)
            this._hasDeprecationWarned(i3) || this._utils.logger.warn(this._deprecatedHandler(i3, t3, this._utils));
          else
            for (const {value: e22} of n3) {
              const n4 = {key: i3, value: e22};
              if (!this._hasDeprecationWarned(n4)) {
                const r4 = typeof t3 == "string" ? {key: t3, value: e22} : t3;
                this._utils.logger.warn(this._deprecatedHandler(n4, r4, this._utils));
              }
            }
      };
      ca$1.normalizeForwardResult(r3.forward(u2, this._utils), u2).forEach(s2);
      const c2 = ca$1.normalizeRedirectResult(r3.redirect(u2, this._utils), u2);
      if (c2.redirect.forEach(s2), "remain" in c2) {
        const e21 = c2.remain;
        t2[i3] = i3 in t2 ? r3.overlap(t2[i3], e21, this._utils) : e21, a2({value: e21});
      }
      for (const {from: e21, to: t3} of c2.redirect)
        a2({value: e21, redirectTo: t3});
    }
    for (const r3 of i2) {
      const i3 = e20[r3], u2 = this._unknownHandler(r3, i3, this._utils);
      if (u2)
        for (const e21 of Object.keys(u2)) {
          const r4 = {[e21]: u2[e21]};
          e21 in this._utils.schemas ? n2.push(r4) : Object.assign(t2, r4);
        }
    }
    return n2;
  }
}
var Ba$1 = Ta$1, Na$1 = Object.defineProperty({normalize: (e20, t2, n2) => new Ta$1(t2, n2).normalize(e20), Normalizer: Ba$1}, "__esModule", {value: true}), ka$1 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(Bo$2, t2), wo$2.__exportStar(Ts$2, t2), wo$2.__exportStar(Aa$1, t2), wo$2.__exportStar(Na$1, t2), wo$2.__exportStar(Ls$2, t2);
});
const Pa$1 = [], Oa$1 = [], Ia$1 = (e20, t2) => {
  if (e20 === t2)
    return 0;
  const n2 = e20;
  e20.length > t2.length && (e20 = t2, t2 = n2);
  let r2 = e20.length, i2 = t2.length;
  for (; r2 > 0 && e20.charCodeAt(~-r2) === t2.charCodeAt(~-i2); )
    r2--, i2--;
  let u2, o2, s2, a2, c2 = 0;
  for (; c2 < r2 && e20.charCodeAt(c2) === t2.charCodeAt(c2); )
    c2++;
  if (r2 -= c2, i2 -= c2, r2 === 0)
    return i2;
  let l2 = 0, p2 = 0;
  for (; l2 < r2; )
    Oa$1[l2] = e20.charCodeAt(c2 + l2), Pa$1[l2] = ++l2;
  for (; p2 < i2; )
    for (u2 = t2.charCodeAt(c2 + p2), s2 = p2++, o2 = p2, l2 = 0; l2 < r2; l2++)
      a2 = u2 === Oa$1[l2] ? s2 : s2 + 1, s2 = Pa$1[l2], o2 = Pa$1[l2] = s2 > o2 ? a2 > o2 ? o2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
  return o2;
};
var La$1 = Ia$1, ja$1 = Ia$1;
La$1.default = ja$1;
var _a$1 = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50]};
const Ma$1 = {};
for (const e20 of Object.keys(_a$1))
  Ma$1[_a$1[e20]] = e20;
const Ra$1 = {rgb: {channels: 3, labels: "rgb"}, hsl: {channels: 3, labels: "hsl"}, hsv: {channels: 3, labels: "hsv"}, hwb: {channels: 3, labels: "hwb"}, cmyk: {channels: 4, labels: "cmyk"}, xyz: {channels: 3, labels: "xyz"}, lab: {channels: 3, labels: "lab"}, lch: {channels: 3, labels: "lch"}, hex: {channels: 1, labels: ["hex"]}, keyword: {channels: 1, labels: ["keyword"]}, ansi16: {channels: 1, labels: ["ansi16"]}, ansi256: {channels: 1, labels: ["ansi256"]}, hcg: {channels: 3, labels: ["h", "c", "g"]}, apple: {channels: 3, labels: ["r16", "g16", "b16"]}, gray: {channels: 1, labels: ["gray"]}};
var $a$1 = Ra$1;
for (const e20 of Object.keys(Ra$1)) {
  if (!("channels" in Ra$1[e20]))
    throw new Error("missing channels property: " + e20);
  if (!("labels" in Ra$1[e20]))
    throw new Error("missing channel labels property: " + e20);
  if (Ra$1[e20].labels.length !== Ra$1[e20].channels)
    throw new Error("channel and label counts mismatch: " + e20);
  const {channels: t2, labels: n2} = Ra$1[e20];
  delete Ra$1[e20].channels, delete Ra$1[e20].labels, Object.defineProperty(Ra$1[e20], "channels", {value: t2}), Object.defineProperty(Ra$1[e20], "labels", {value: n2});
}
function Va$1(e20) {
  const t2 = function() {
    const e21 = {}, t3 = Object.keys($a$1);
    for (let n3 = t3.length, r2 = 0; r2 < n3; r2++)
      e21[t3[r2]] = {distance: -1, parent: null};
    return e21;
  }(), n2 = [e20];
  for (t2[e20].distance = 0; n2.length; ) {
    const e21 = n2.pop(), r2 = Object.keys($a$1[e21]);
    for (let i2 = r2.length, u2 = 0; u2 < i2; u2++) {
      const i3 = r2[u2], o2 = t2[i3];
      o2.distance === -1 && (o2.distance = t2[e21].distance + 1, o2.parent = e21, n2.unshift(i3));
    }
  }
  return t2;
}
function Wa$1(e20, t2) {
  return function(n2) {
    return t2(e20(n2));
  };
}
function qa$1(e20, t2) {
  const n2 = [t2[e20].parent, e20];
  let r2 = $a$1[t2[e20].parent][e20], i2 = t2[e20].parent;
  for (; t2[i2].parent; )
    n2.unshift(t2[i2].parent), r2 = Wa$1($a$1[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
  return r2.conversion = n2, r2;
}
Ra$1.rgb.hsl = function(e20) {
  const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.min(t2, n2, r2), u2 = Math.max(t2, n2, r2), o2 = u2 - i2;
  let s2, a2;
  u2 === i2 ? s2 = 0 : t2 === u2 ? s2 = (n2 - r2) / o2 : n2 === u2 ? s2 = 2 + (r2 - t2) / o2 : r2 === u2 && (s2 = 4 + (t2 - n2) / o2), s2 = Math.min(60 * s2, 360), s2 < 0 && (s2 += 360);
  const c2 = (i2 + u2) / 2;
  return a2 = u2 === i2 ? 0 : c2 <= 0.5 ? o2 / (u2 + i2) : o2 / (2 - u2 - i2), [s2, 100 * a2, 100 * c2];
}, Ra$1.rgb.hsv = function(e20) {
  let t2, n2, r2, i2, u2;
  const o2 = e20[0] / 255, s2 = e20[1] / 255, a2 = e20[2] / 255, c2 = Math.max(o2, s2, a2), l2 = c2 - Math.min(o2, s2, a2), p2 = function(e21) {
    return (c2 - e21) / 6 / l2 + 0.5;
  };
  return l2 === 0 ? (i2 = 0, u2 = 0) : (u2 = l2 / c2, t2 = p2(o2), n2 = p2(s2), r2 = p2(a2), o2 === c2 ? i2 = r2 - n2 : s2 === c2 ? i2 = 1 / 3 + t2 - r2 : a2 === c2 && (i2 = 2 / 3 + n2 - t2), i2 < 0 ? i2 += 1 : i2 > 1 && (i2 -= 1)), [360 * i2, 100 * u2, 100 * c2];
}, Ra$1.rgb.hwb = function(e20) {
  const t2 = e20[0], n2 = e20[1];
  let r2 = e20[2];
  const i2 = Ra$1.rgb.hsl(e20)[0], u2 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
  return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [i2, 100 * u2, 100 * r2];
}, Ra$1.rgb.cmyk = function(e20) {
  const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.min(1 - t2, 1 - n2, 1 - r2);
  return [100 * ((1 - t2 - i2) / (1 - i2) || 0), 100 * ((1 - n2 - i2) / (1 - i2) || 0), 100 * ((1 - r2 - i2) / (1 - i2) || 0), 100 * i2];
}, Ra$1.rgb.keyword = function(e20) {
  const t2 = Ma$1[e20];
  if (t2)
    return t2;
  let n2, r2 = 1 / 0;
  for (const t3 of Object.keys(_a$1)) {
    const o2 = (u2 = _a$1[t3], ((i2 = e20)[0] - u2[0]) ** 2 + (i2[1] - u2[1]) ** 2 + (i2[2] - u2[2]) ** 2);
    o2 < r2 && (r2 = o2, n2 = t3);
  }
  var i2, u2;
  return n2;
}, Ra$1.keyword.rgb = function(e20) {
  return _a$1[e20];
}, Ra$1.rgb.xyz = function(e20) {
  let t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255;
  t2 = t2 > 0.04045 ? ((t2 + 0.055) / 1.055) ** 2.4 : t2 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
  return [100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2), 100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)];
}, Ra$1.rgb.lab = function(e20) {
  const t2 = Ra$1.rgb.xyz(e20);
  let n2 = t2[0], r2 = t2[1], i2 = t2[2];
  n2 /= 95.047, r2 /= 100, i2 /= 108.883, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, i2 = i2 > 8856e-6 ? i2 ** (1 / 3) : 7.787 * i2 + 16 / 116;
  return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - i2)];
}, Ra$1.hsl.rgb = function(e20) {
  const t2 = e20[0] / 360, n2 = e20[1] / 100, r2 = e20[2] / 100;
  let i2, u2, o2;
  if (n2 === 0)
    return o2 = 255 * r2, [o2, o2, o2];
  i2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
  const s2 = 2 * r2 - i2, a2 = [0, 0, 0];
  for (let e21 = 0; e21 < 3; e21++)
    u2 = t2 + 1 / 3 * -(e21 - 1), u2 < 0 && u2++, u2 > 1 && u2--, o2 = 6 * u2 < 1 ? s2 + 6 * (i2 - s2) * u2 : 2 * u2 < 1 ? i2 : 3 * u2 < 2 ? s2 + (i2 - s2) * (2 / 3 - u2) * 6 : s2, a2[e21] = 255 * o2;
  return a2;
}, Ra$1.hsl.hsv = function(e20) {
  const t2 = e20[0];
  let n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = n2;
  const u2 = Math.max(r2, 0.01);
  r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, i2 *= u2 <= 1 ? u2 : 2 - u2;
  return [t2, 100 * (r2 === 0 ? 2 * i2 / (u2 + i2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
}, Ra$1.hsv.rgb = function(e20) {
  const t2 = e20[0] / 60, n2 = e20[1] / 100;
  let r2 = e20[2] / 100;
  const i2 = Math.floor(t2) % 6, u2 = t2 - Math.floor(t2), o2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * u2), a2 = 255 * r2 * (1 - n2 * (1 - u2));
  switch (r2 *= 255, i2) {
    case 0:
      return [r2, a2, o2];
    case 1:
      return [s2, r2, o2];
    case 2:
      return [o2, r2, a2];
    case 3:
      return [o2, s2, r2];
    case 4:
      return [a2, o2, r2];
    case 5:
      return [r2, o2, s2];
  }
}, Ra$1.hsv.hsl = function(e20) {
  const t2 = e20[0], n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = Math.max(r2, 0.01);
  let u2, o2;
  o2 = (2 - n2) * r2;
  const s2 = (2 - n2) * i2;
  return u2 = n2 * i2, u2 /= s2 <= 1 ? s2 : 2 - s2, u2 = u2 || 0, o2 /= 2, [t2, 100 * u2, 100 * o2];
}, Ra$1.hwb.rgb = function(e20) {
  const t2 = e20[0] / 360;
  let n2 = e20[1] / 100, r2 = e20[2] / 100;
  const i2 = n2 + r2;
  let u2;
  i2 > 1 && (n2 /= i2, r2 /= i2);
  const o2 = Math.floor(6 * t2), s2 = 1 - r2;
  u2 = 6 * t2 - o2, (1 & o2) != 0 && (u2 = 1 - u2);
  const a2 = n2 + u2 * (s2 - n2);
  let c2, l2, p2;
  switch (o2) {
    default:
    case 6:
    case 0:
      c2 = s2, l2 = a2, p2 = n2;
      break;
    case 1:
      c2 = a2, l2 = s2, p2 = n2;
      break;
    case 2:
      c2 = n2, l2 = s2, p2 = a2;
      break;
    case 3:
      c2 = n2, l2 = a2, p2 = s2;
      break;
    case 4:
      c2 = a2, l2 = n2, p2 = s2;
      break;
    case 5:
      c2 = s2, l2 = n2, p2 = a2;
  }
  return [255 * c2, 255 * l2, 255 * p2];
}, Ra$1.cmyk.rgb = function(e20) {
  const t2 = e20[0] / 100, n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = e20[3] / 100;
  return [255 * (1 - Math.min(1, t2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, n2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, r2 * (1 - i2) + i2))];
}, Ra$1.xyz.rgb = function(e20) {
  const t2 = e20[0] / 100, n2 = e20[1] / 100, r2 = e20[2] / 100;
  let i2, u2, o2;
  return i2 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, u2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, o2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, i2 = i2 > 31308e-7 ? 1.055 * i2 ** (1 / 2.4) - 0.055 : 12.92 * i2, u2 = u2 > 31308e-7 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, o2 = o2 > 31308e-7 ? 1.055 * o2 ** (1 / 2.4) - 0.055 : 12.92 * o2, i2 = Math.min(Math.max(0, i2), 1), u2 = Math.min(Math.max(0, u2), 1), o2 = Math.min(Math.max(0, o2), 1), [255 * i2, 255 * u2, 255 * o2];
}, Ra$1.xyz.lab = function(e20) {
  let t2 = e20[0], n2 = e20[1], r2 = e20[2];
  t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 8856e-6 ? t2 ** (1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
  return [116 * n2 - 16, 500 * (t2 - n2), 200 * (n2 - r2)];
}, Ra$1.lab.xyz = function(e20) {
  let t2, n2, r2;
  n2 = (e20[0] + 16) / 116, t2 = e20[1] / 500 + n2, r2 = n2 - e20[2] / 200;
  const i2 = n2 ** 3, u2 = t2 ** 3, o2 = r2 ** 3;
  return n2 = i2 > 8856e-6 ? i2 : (n2 - 16 / 116) / 7.787, t2 = u2 > 8856e-6 ? u2 : (t2 - 16 / 116) / 7.787, r2 = o2 > 8856e-6 ? o2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [t2, n2, r2];
}, Ra$1.lab.lch = function(e20) {
  const t2 = e20[0], n2 = e20[1], r2 = e20[2];
  let i2;
  i2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, i2 < 0 && (i2 += 360);
  return [t2, Math.sqrt(n2 * n2 + r2 * r2), i2];
}, Ra$1.lch.lab = function(e20) {
  const t2 = e20[0], n2 = e20[1], r2 = e20[2] / 360 * 2 * Math.PI;
  return [t2, n2 * Math.cos(r2), n2 * Math.sin(r2)];
}, Ra$1.rgb.ansi16 = function(e20, t2 = null) {
  const [n2, r2, i2] = e20;
  let u2 = t2 === null ? Ra$1.rgb.hsv(e20)[2] : t2;
  if (u2 = Math.round(u2 / 50), u2 === 0)
    return 30;
  let o2 = 30 + (Math.round(i2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
  return u2 === 2 && (o2 += 60), o2;
}, Ra$1.hsv.ansi16 = function(e20) {
  return Ra$1.rgb.ansi16(Ra$1.hsv.rgb(e20), e20[2]);
}, Ra$1.rgb.ansi256 = function(e20) {
  const t2 = e20[0], n2 = e20[1], r2 = e20[2];
  if (t2 === n2 && n2 === r2)
    return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
  return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
}, Ra$1.ansi16.rgb = function(e20) {
  let t2 = e20 % 10;
  if (t2 === 0 || t2 === 7)
    return e20 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
  const n2 = 0.5 * (1 + ~~(e20 > 50));
  return [(1 & t2) * n2 * 255, (t2 >> 1 & 1) * n2 * 255, (t2 >> 2 & 1) * n2 * 255];
}, Ra$1.ansi256.rgb = function(e20) {
  if (e20 >= 232) {
    const t3 = 10 * (e20 - 232) + 8;
    return [t3, t3, t3];
  }
  let t2;
  e20 -= 16;
  return [Math.floor(e20 / 36) / 5 * 255, Math.floor((t2 = e20 % 36) / 6) / 5 * 255, t2 % 6 / 5 * 255];
}, Ra$1.rgb.hex = function(e20) {
  const t2 = (((255 & Math.round(e20[0])) << 16) + ((255 & Math.round(e20[1])) << 8) + (255 & Math.round(e20[2]))).toString(16).toUpperCase();
  return "000000".substring(t2.length) + t2;
}, Ra$1.hex.rgb = function(e20) {
  const t2 = e20.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!t2)
    return [0, 0, 0];
  let n2 = t2[0];
  t2[0].length === 3 && (n2 = n2.split("").map((e21) => e21 + e21).join(""));
  const r2 = parseInt(n2, 16);
  return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
}, Ra$1.rgb.hcg = function(e20) {
  const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.max(Math.max(t2, n2), r2), u2 = Math.min(Math.min(t2, n2), r2), o2 = i2 - u2;
  let s2, a2;
  return s2 = o2 < 1 ? u2 / (1 - o2) : 0, a2 = o2 <= 0 ? 0 : i2 === t2 ? (n2 - r2) / o2 % 6 : i2 === n2 ? 2 + (r2 - t2) / o2 : 4 + (t2 - n2) / o2, a2 /= 6, a2 %= 1, [360 * a2, 100 * o2, 100 * s2];
}, Ra$1.hsl.hcg = function(e20) {
  const t2 = e20[1] / 100, n2 = e20[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
  let i2 = 0;
  return r2 < 1 && (i2 = (n2 - 0.5 * r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
}, Ra$1.hsv.hcg = function(e20) {
  const t2 = e20[1] / 100, n2 = e20[2] / 100, r2 = t2 * n2;
  let i2 = 0;
  return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
}, Ra$1.hcg.rgb = function(e20) {
  const t2 = e20[0] / 360, n2 = e20[1] / 100, r2 = e20[2] / 100;
  if (n2 === 0)
    return [255 * r2, 255 * r2, 255 * r2];
  const i2 = [0, 0, 0], u2 = t2 % 1 * 6, o2 = u2 % 1, s2 = 1 - o2;
  let a2 = 0;
  switch (Math.floor(u2)) {
    case 0:
      i2[0] = 1, i2[1] = o2, i2[2] = 0;
      break;
    case 1:
      i2[0] = s2, i2[1] = 1, i2[2] = 0;
      break;
    case 2:
      i2[0] = 0, i2[1] = 1, i2[2] = o2;
      break;
    case 3:
      i2[0] = 0, i2[1] = s2, i2[2] = 1;
      break;
    case 4:
      i2[0] = o2, i2[1] = 0, i2[2] = 1;
      break;
    default:
      i2[0] = 1, i2[1] = 0, i2[2] = s2;
  }
  return a2 = (1 - n2) * r2, [255 * (n2 * i2[0] + a2), 255 * (n2 * i2[1] + a2), 255 * (n2 * i2[2] + a2)];
}, Ra$1.hcg.hsv = function(e20) {
  const t2 = e20[1] / 100, n2 = t2 + e20[2] / 100 * (1 - t2);
  let r2 = 0;
  return n2 > 0 && (r2 = t2 / n2), [e20[0], 100 * r2, 100 * n2];
}, Ra$1.hcg.hsl = function(e20) {
  const t2 = e20[1] / 100, n2 = e20[2] / 100 * (1 - t2) + 0.5 * t2;
  let r2 = 0;
  return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e20[0], 100 * r2, 100 * n2];
}, Ra$1.hcg.hwb = function(e20) {
  const t2 = e20[1] / 100, n2 = t2 + e20[2] / 100 * (1 - t2);
  return [e20[0], 100 * (n2 - t2), 100 * (1 - n2)];
}, Ra$1.hwb.hcg = function(e20) {
  const t2 = e20[1] / 100, n2 = 1 - e20[2] / 100, r2 = n2 - t2;
  let i2 = 0;
  return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
}, Ra$1.apple.rgb = function(e20) {
  return [e20[0] / 65535 * 255, e20[1] / 65535 * 255, e20[2] / 65535 * 255];
}, Ra$1.rgb.apple = function(e20) {
  return [e20[0] / 255 * 65535, e20[1] / 255 * 65535, e20[2] / 255 * 65535];
}, Ra$1.gray.rgb = function(e20) {
  return [e20[0] / 100 * 255, e20[0] / 100 * 255, e20[0] / 100 * 255];
}, Ra$1.gray.hsl = function(e20) {
  return [0, 0, e20[0]];
}, Ra$1.gray.hsv = Ra$1.gray.hsl, Ra$1.gray.hwb = function(e20) {
  return [0, 100, e20[0]];
}, Ra$1.gray.cmyk = function(e20) {
  return [0, 0, 0, e20[0]];
}, Ra$1.gray.lab = function(e20) {
  return [e20[0], 0, 0];
}, Ra$1.gray.hex = function(e20) {
  const t2 = 255 & Math.round(e20[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
  return "000000".substring(n2.length) + n2;
}, Ra$1.rgb.gray = function(e20) {
  return [(e20[0] + e20[1] + e20[2]) / 3 / 255 * 100];
};
const Ua$1 = {};
Object.keys($a$1).forEach((e20) => {
  Ua$1[e20] = {}, Object.defineProperty(Ua$1[e20], "channels", {value: $a$1[e20].channels}), Object.defineProperty(Ua$1[e20], "labels", {value: $a$1[e20].labels});
  const t2 = function(e21) {
    const t3 = Va$1(e21), n2 = {}, r2 = Object.keys(t3);
    for (let e22 = r2.length, i2 = 0; i2 < e22; i2++) {
      const e23 = r2[i2];
      t3[e23].parent !== null && (n2[e23] = qa$1(e23, t3));
    }
    return n2;
  }(e20);
  Object.keys(t2).forEach((n2) => {
    const r2 = t2[n2];
    Ua$1[e20][n2] = function(e21) {
      const t3 = function(...t4) {
        const n3 = t4[0];
        if (n3 == null)
          return n3;
        n3.length > 1 && (t4 = n3);
        const r3 = e21(t4);
        if (typeof r3 == "object")
          for (let e22 = r3.length, t5 = 0; t5 < e22; t5++)
            r3[t5] = Math.round(r3[t5]);
        return r3;
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2), Ua$1[e20][n2].raw = function(e21) {
      const t3 = function(...t4) {
        const n3 = t4[0];
        return n3 == null ? n3 : (n3.length > 1 && (t4 = n3), e21(t4));
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2);
  });
});
var za$1 = Ua$1, Ga$1 = r$3(function(e20) {
  const t2 = (e21, t3) => (...n3) => `[${e21(...n3) + t3}m`, n2 = (e21, t3) => (...n3) => {
    const r3 = e21(...n3);
    return `[${38 + t3};5;${r3}m`;
  }, r2 = (e21, t3) => (...n3) => {
    const r3 = e21(...n3);
    return `[${38 + t3};2;${r3[0]};${r3[1]};${r3[2]}m`;
  }, i2 = (e21) => e21, u2 = (e21, t3, n3) => [e21, t3, n3], o2 = (e21, t3, n3) => {
    Object.defineProperty(e21, t3, {get: () => {
      const r3 = n3();
      return Object.defineProperty(e21, t3, {value: r3, enumerable: true, configurable: true}), r3;
    }, enumerable: true, configurable: true});
  };
  let s2;
  const a2 = (e21, t3, n3, r3) => {
    s2 === void 0 && (s2 = za$1);
    const i3 = r3 ? 10 : 0, u3 = {};
    for (const [r4, o3] of Object.entries(s2)) {
      const s3 = r4 === "ansi16" ? "ansi" : r4;
      r4 === t3 ? u3[s3] = e21(n3, i3) : typeof o3 == "object" && (u3[s3] = e21(o3[t3], i3));
    }
    return u3;
  };
  Object.defineProperty(e20, "exports", {enumerable: true, get: function() {
    const e21 = new Map(), s3 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
    s3.color.gray = s3.color.blackBright, s3.bgColor.bgGray = s3.bgColor.bgBlackBright, s3.color.grey = s3.color.blackBright, s3.bgColor.bgGrey = s3.bgColor.bgBlackBright;
    for (const [t3, n3] of Object.entries(s3)) {
      for (const [t4, r3] of Object.entries(n3))
        s3[t4] = {open: `[${r3[0]}m`, close: `[${r3[1]}m`}, n3[t4] = s3[t4], e21.set(r3[0], r3[1]);
      Object.defineProperty(s3, t3, {value: n3, enumerable: false});
    }
    return Object.defineProperty(s3, "codes", {value: e21, enumerable: false}), s3.color.close = "[39m", s3.bgColor.close = "[49m", o2(s3.color, "ansi", () => a2(t2, "ansi16", i2, false)), o2(s3.color, "ansi256", () => a2(n2, "ansi256", i2, false)), o2(s3.color, "ansi16m", () => a2(r2, "rgb", u2, false)), o2(s3.bgColor, "ansi", () => a2(t2, "ansi16", i2, true)), o2(s3.bgColor, "ansi256", () => a2(n2, "ansi256", i2, true)), o2(s3.bgColor, "ansi16m", () => a2(r2, "rgb", u2, true)), s3;
  }});
});
function Ha$1() {
  return false;
}
function Ja$1() {
  throw new Error("tty.ReadStream is not implemented");
}
function Xa$1() {
  throw new Error("tty.ReadStream is not implemented");
}
var Ya$1 = {isatty: Ha$1, ReadStream: Ja$1, WriteStream: Xa$1}, Ka$1 = (e20, t2 = xr$2.argv) => {
  const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
  return r2 !== -1 && (i2 === -1 || r2 < i2);
}, Qa$1 = n$3(Object.freeze({__proto__: null, isatty: Ha$1, ReadStream: Ja$1, WriteStream: Xa$1, default: Ya$1}));
const {env: Za$1} = xr$2;
let ec;
function tc(e20) {
  return e20 !== 0 && {level: e20, hasBasic: true, has256: e20 >= 2, has16m: e20 >= 3};
}
function nc(e20, t2) {
  if (ec === 0)
    return 0;
  if (Ka$1("color=16m") || Ka$1("color=full") || Ka$1("color=truecolor"))
    return 3;
  if (Ka$1("color=256"))
    return 2;
  if (e20 && !t2 && ec === void 0)
    return 0;
  const n2 = ec || 0;
  if (Za$1.TERM === "dumb")
    return n2;
  if (xr$2.platform === "win32") {
    const e21 = is$2.release().split(".");
    return Number(e21[0]) >= 10 && Number(e21[2]) >= 10586 ? Number(e21[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in Za$1)
    return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e21) => e21 in Za$1) || Za$1.CI_NAME === "codeship" ? 1 : n2;
  if ("TEAMCITY_VERSION" in Za$1)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Za$1.TEAMCITY_VERSION) ? 1 : 0;
  if (Za$1.COLORTERM === "truecolor")
    return 3;
  if ("TERM_PROGRAM" in Za$1) {
    const e21 = parseInt((Za$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (Za$1.TERM_PROGRAM) {
      case "iTerm.app":
        return e21 >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(Za$1.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Za$1.TERM) || "COLORTERM" in Za$1 ? 1 : n2;
}
Ka$1("no-color") || Ka$1("no-colors") || Ka$1("color=false") || Ka$1("color=never") ? ec = 0 : (Ka$1("color") || Ka$1("colors") || Ka$1("color=true") || Ka$1("color=always")) && (ec = 1), "FORCE_COLOR" in Za$1 && (ec = Za$1.FORCE_COLOR === "true" ? 1 : Za$1.FORCE_COLOR === "false" ? 0 : Za$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(Za$1.FORCE_COLOR, 10), 3));
var rc = {supportsColor: function(e20) {
  return tc(nc(e20, e20 && e20.isTTY));
}, stdout: tc(nc(true, Qa$1.isatty(1))), stderr: tc(nc(true, Qa$1.isatty(2)))};
var ic = {stringReplaceAll: (e20, t2, n2) => {
  let r2 = e20.indexOf(t2);
  if (r2 === -1)
    return e20;
  const i2 = t2.length;
  let u2 = 0, o2 = "";
  do {
    o2 += e20.substr(u2, r2 - u2) + t2 + n2, u2 = r2 + i2, r2 = e20.indexOf(t2, u2);
  } while (r2 !== -1);
  return o2 += e20.substr(u2), o2;
}, stringEncaseCRLFWithFirstIndex: (e20, t2, n2, r2) => {
  let i2 = 0, u2 = "";
  do {
    const o2 = e20[r2 - 1] === "\r";
    u2 += e20.substr(i2, (o2 ? r2 - 1 : r2) - i2) + t2 + (o2 ? "\r\n" : "\n") + n2, i2 = r2 + 1, r2 = e20.indexOf("\n", i2);
  } while (r2 !== -1);
  return u2 += e20.substr(i2), u2;
}};
const uc = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, oc = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, sc = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ac = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, cc = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
function lc(e20) {
  const t2 = e20[0] === "u", n2 = e20[1] === "{";
  return t2 && !n2 && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e20.slice(2, -1), 16)) : cc.get(e20) || e20;
}
function pc(e20, t2) {
  const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
  let i2;
  for (const t3 of r2) {
    const r3 = Number(t3);
    if (Number.isNaN(r3)) {
      if (!(i2 = t3.match(sc)))
        throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
      n2.push(i2[2].replace(ac, (e21, t4, n3) => t4 ? lc(t4) : n3));
    } else
      n2.push(r3);
  }
  return n2;
}
function fc(e20) {
  oc.lastIndex = 0;
  const t2 = [];
  let n2;
  for (; (n2 = oc.exec(e20)) !== null; ) {
    const e21 = n2[1];
    if (n2[2]) {
      const r2 = pc(e21, n2[2]);
      t2.push([e21].concat(r2));
    } else
      t2.push([e21]);
  }
  return t2;
}
function dc(e20, t2) {
  const n2 = {};
  for (const e21 of t2)
    for (const t3 of e21.styles)
      n2[t3[0]] = e21.inverse ? null : t3.slice(1);
  let r2 = e20;
  for (const [e21, t3] of Object.entries(n2))
    if (Array.isArray(t3)) {
      if (!(e21 in r2))
        throw new Error(`Unknown Chalk style: ${e21}`);
      r2 = t3.length > 0 ? r2[e21](...t3) : r2[e21];
    }
  return r2;
}
var hc = (e20, t2) => {
  const n2 = [], r2 = [];
  let i2 = [];
  if (t2.replace(uc, (t3, u2, o2, s2, a2, c2) => {
    if (u2)
      i2.push(lc(u2));
    else if (s2) {
      const t4 = i2.join("");
      i2 = [], r2.push(n2.length === 0 ? t4 : dc(e20, n2)(t4)), n2.push({inverse: o2, styles: fc(s2)});
    } else if (a2) {
      if (n2.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      r2.push(dc(e20, n2)(i2.join(""))), i2 = [], n2.pop();
    } else
      i2.push(c2);
  }), r2.push(i2.join("")), n2.length > 0) {
    const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(e21);
  }
  return r2.join("");
};
const {stdout: gc, stderr: mc} = rc, {stringReplaceAll: yc, stringEncaseCRLFWithFirstIndex: Dc} = ic, {isArray: Ec} = Array, Cc = ["ansi", "ansi", "ansi256", "ansi16m"], bc = Object.create(null);
class Ac {
  constructor(e20) {
    return vc(e20);
  }
}
const vc = (e20) => {
  const t2 = {};
  return ((e21, t3 = {}) => {
    if (t3.level && !(Number.isInteger(t3.level) && t3.level >= 0 && t3.level <= 3))
      throw new Error("The `level` option should be an integer from 0 to 3");
    const n2 = gc ? gc.level : 0;
    e21.level = t3.level === void 0 ? n2 : t3.level;
  })(t2, e20), t2.template = (...e21) => kc(t2.template, ...e21), Object.setPrototypeOf(t2, Fc.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
    throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
  }, t2.template.Instance = Ac, t2.template;
};
function Fc(e20) {
  return vc(e20);
}
for (const [e20, t2] of Object.entries(Ga$1))
  bc[e20] = {get() {
    const n2 = Tc(this, wc(t2.open, t2.close, this._styler), this._isEmpty);
    return Object.defineProperty(this, e20, {value: n2}), n2;
  }};
bc.visible = {get() {
  const e20 = Tc(this, this._styler, true);
  return Object.defineProperty(this, "visible", {value: e20}), e20;
}};
const Sc = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
for (const e20 of Sc)
  bc[e20] = {get() {
    const {level: t2} = this;
    return function(...n2) {
      const r2 = wc(Ga$1.color[Cc[t2]][e20](...n2), Ga$1.color.close, this._styler);
      return Tc(this, r2, this._isEmpty);
    };
  }};
for (const e20 of Sc) {
  bc["bg" + e20[0].toUpperCase() + e20.slice(1)] = {get() {
    const {level: t2} = this;
    return function(...n2) {
      const r2 = wc(Ga$1.bgColor[Cc[t2]][e20](...n2), Ga$1.bgColor.close, this._styler);
      return Tc(this, r2, this._isEmpty);
    };
  }};
}
const xc = Object.defineProperties(() => {
}, Object.assign(Object.assign({}, bc), {}, {level: {enumerable: true, get() {
  return this._generator.level;
}, set(e20) {
  this._generator.level = e20;
}}})), wc = (e20, t2, n2) => {
  let r2, i2;
  return n2 === void 0 ? (r2 = e20, i2 = t2) : (r2 = n2.openAll + e20, i2 = t2 + n2.closeAll), {open: e20, close: t2, openAll: r2, closeAll: i2, parent: n2};
}, Tc = (e20, t2, n2) => {
  const r2 = (...e21) => Ec(e21[0]) && Ec(e21[0].raw) ? Bc(r2, kc(r2, ...e21)) : Bc(r2, e21.length === 1 ? "" + e21[0] : e21.join(" "));
  return Object.setPrototypeOf(r2, xc), r2._generator = e20, r2._styler = t2, r2._isEmpty = n2, r2;
}, Bc = (e20, t2) => {
  if (e20.level <= 0 || !t2)
    return e20._isEmpty ? "" : t2;
  let n2 = e20._styler;
  if (n2 === void 0)
    return t2;
  const {openAll: r2, closeAll: i2} = n2;
  if (t2.indexOf("") !== -1)
    for (; n2 !== void 0; )
      t2 = yc(t2, n2.close, n2.open), n2 = n2.parent;
  const u2 = t2.indexOf("\n");
  return u2 !== -1 && (t2 = Dc(t2, i2, r2, u2)), r2 + t2 + i2;
};
let Nc;
const kc = (e20, ...t2) => {
  const [n2] = t2;
  if (!Ec(n2) || !Ec(n2.raw))
    return t2.join(" ");
  const r2 = t2.slice(1), i2 = [n2.raw[0]];
  for (let e21 = 1; e21 < n2.length; e21++)
    i2.push(String(r2[e21 - 1]).replace(/[{}\\]/g, "\\$&"), String(n2.raw[e21]));
  return Nc === void 0 && (Nc = hc), Nc(e20, i2.join(""));
};
Object.defineProperties(Fc.prototype, bc);
const Pc = Fc();
Pc.supportsColor = gc, Pc.stderr = Fc({level: mc ? mc.level : 0}), Pc.stderr.supportsColor = mc;
var Oc = Pc;
const Ic = ["_"], Lc = {key: (e20) => e20.length === 1 ? `-${e20}` : `--${e20}`, value: (e20) => ka$1.apiDescriptor.value(e20), pair: ({key: e20, value: t2}) => t2 === false ? `--no-${e20}` : t2 === true ? Lc.key(e20) : t2 === "" ? `${Lc.key(e20)} without an argument` : `${Lc.key(e20)}=${t2}`};
class jc extends ka$1.ChoiceSchema {
  constructor({name: e20, flags: t2}) {
    super({name: e20, choices: t2}), this._flags = [...t2].sort();
  }
  preprocess(e20, t2) {
    if (typeof e20 == "string" && e20.length > 0 && !this._flags.includes(e20)) {
      const n2 = this._flags.find((t3) => La$1(t3, e20) < 3);
      if (n2)
        return t2.logger.warn([`Unknown flag ${Oc.yellow(t2.descriptor.value(e20))},`, `did you mean ${Oc.blue(t2.descriptor.value(n2))}?`].join(" ")), n2;
    }
    return e20;
  }
  expected() {
    return "a flag";
  }
}
let _c;
function Mc(e20, t2, {logger: n2, isCLI: r2 = false, passThrough: i2 = false} = {}) {
  const u2 = i2 ? Array.isArray(i2) ? (e21, t3) => i2.includes(e21) ? {[e21]: t3} : void 0 : (e21, t3) => ({[e21]: t3}) : (e21, t3, n3) => {
    const r3 = jn$2(n3.schemas, Ic);
    return ka$1.levenUnknownHandler(e21, t3, Object.assign(Object.assign({}, n3), {}, {schemas: r3}));
  }, o2 = r2 ? Lc : ka$1.apiDescriptor, s2 = function(e21, {isCLI: t3}) {
    const n3 = [];
    t3 && n3.push(ka$1.AnySchema.create({name: "_"}));
    for (const r3 of e21)
      n3.push(Rc(r3, {isCLI: t3, optionInfos: e21})), r3.alias && t3 && n3.push(ka$1.AliasSchema.create({name: r3.alias, sourceName: r3.name}));
    return n3;
  }(t2, {isCLI: r2}), a2 = new ka$1.Normalizer(s2, {logger: n2, unknown: u2, descriptor: o2}), c2 = n2 !== false;
  c2 && _c && (a2._hasDeprecationWarned = _c);
  const l2 = a2.normalize(e20);
  return c2 && (_c = a2._hasDeprecationWarned), l2;
}
function Rc(e20, {isCLI: t2, optionInfos: n2}) {
  let r2;
  const i2 = {name: e20.name}, u2 = {};
  switch (e20.type) {
    case "int":
      r2 = ka$1.IntegerSchema, t2 && (i2.preprocess = (e21) => Number(e21));
      break;
    case "string":
      r2 = ka$1.StringSchema;
      break;
    case "choice":
      r2 = ka$1.ChoiceSchema, i2.choices = e20.choices.map((t3) => typeof t3 == "object" && t3.redirect ? Object.assign(Object.assign({}, t3), {}, {redirect: {to: {key: e20.name, value: t3.redirect}}}) : t3);
      break;
    case "boolean":
      r2 = ka$1.BooleanSchema;
      break;
    case "flag":
      r2 = jc, i2.flags = n2.flatMap((e21) => [e21.alias, e21.description && e21.name, e21.oppositeDescription && `no-${e21.name}`].filter(Boolean));
      break;
    case "path":
      r2 = ka$1.StringSchema;
      break;
    default:
      throw new Error(`Unexpected type ${e20.type}`);
  }
  if (e20.exception ? i2.validate = (t3, n3, r3) => e20.exception(t3) || n3.validate(t3, r3) : i2.validate = (e21, t3, n3) => e21 === void 0 || t3.validate(e21, n3), e20.redirect && (u2.redirect = (t3) => t3 ? {to: {key: e20.redirect.option, value: e20.redirect.value}} : void 0), e20.deprecated && (u2.deprecated = true), t2 && !e20.array) {
    const e21 = i2.preprocess || ((e22) => e22);
    i2.preprocess = (t3, n3, r3) => n3.preprocess(e21(Array.isArray(t3) ? Ln$2(t3) : t3), r3);
  }
  return e20.array ? ka$1.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, t2 ? {preprocess: (e21) => Array.isArray(e21) ? e21 : [e21]} : {}), u2), {}, {valueSchema: r2.create(i2)})) : r2.create(Object.assign(Object.assign({}, i2), u2));
}
var $c = {normalizeApiOptions: function(e20, t2, n2) {
  return Mc(e20, t2, n2);
}, normalizeCliOptions: function(e20, t2, n2) {
  return Mc(e20, t2, Object.assign({isCLI: true}, n2));
}};
const {isNonEmptyArray: Vc} = yi$2;
function Wc(e20, t2) {
  const {ignoreDecorators: n2} = t2 || {};
  if (!n2) {
    const t3 = e20.declaration && e20.declaration.decorators || e20.decorators;
    if (Vc(t3))
      return Wc(t3[0]);
  }
  return e20.range ? e20.range[0] : e20.start;
}
function qc(e20) {
  return e20.range ? e20.range[1] : e20.end;
}
function Uc(e20, t2) {
  return Wc(e20) === Wc(t2);
}
var zc = {locStart: Wc, locEnd: qc, hasSameLocStart: Uc, hasSameLoc: function(e20, t2) {
  return Uc(e20, t2) && function(e21, t3) {
    return qc(e21) === qc(t3);
  }(e20, t2);
}}, Gc = Object.defineProperty({default: /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, matchToToken: function(e20) {
  var t2 = {type: "invalid", value: e20[0], closed: void 0};
  return e20[1] ? (t2.type = "string", t2.closed = !(!e20[3] && !e20[4])) : e20[5] ? t2.type = "comment" : e20[6] ? (t2.type = "comment", t2.closed = !!e20[7]) : e20[8] ? t2.type = "regex" : e20[9] ? t2.type = "number" : e20[10] ? t2.type = "name" : e20[11] ? t2.type = "punctuator" : e20[12] && (t2.type = "whitespace"), t2;
}}, "__esModule", {value: true}), Hc = rl, Jc = il, Xc = function(e20) {
  let t2 = true;
  for (let n2 = 0; n2 < e20.length; n2++) {
    let r2 = e20.charCodeAt(n2);
    if ((64512 & r2) == 55296 && n2 + 1 < e20.length) {
      const t3 = e20.charCodeAt(++n2);
      (64512 & t3) == 56320 && (r2 = 65536 + ((1023 & r2) << 10) + (1023 & t3));
    }
    if (t2) {
      if (t2 = false, !rl(r2))
        return false;
    } else if (!il(r2))
      return false;
  }
  return !t2;
};
let Yc = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Kc = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
const Qc = new RegExp("[" + Yc + "]"), Zc = new RegExp("[" + Yc + Kc + "]");
Yc = Kc = null;
const el = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], tl = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function nl(e20, t2) {
  let n2 = 65536;
  for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
    if (n2 += t2[r2], n2 > e20)
      return false;
    if (n2 += t2[r2 + 1], n2 >= e20)
      return true;
  }
  return false;
}
function rl(e20) {
  return e20 < 65 ? e20 === 36 : e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Qc.test(String.fromCharCode(e20)) : nl(e20, el)));
}
function il(e20) {
  return e20 < 48 ? e20 === 36 : e20 < 58 || !(e20 < 65) && (e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Zc.test(String.fromCharCode(e20)) : nl(e20, el) || nl(e20, tl))));
}
var ul = Object.defineProperty({isIdentifierStart: Hc, isIdentifierChar: Jc, isIdentifierName: Xc}, "__esModule", {value: true}), ol = ml, sl = yl, al = Dl, cl = function(e20, t2) {
  return yl(e20, t2) || Dl(e20);
}, ll = function(e20) {
  return dl.has(e20);
};
const pl = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], fl = ["eval", "arguments"], dl = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), hl = new Set(pl), gl = new Set(fl);
function ml(e20, t2) {
  return t2 && e20 === "await" || e20 === "enum";
}
function yl(e20, t2) {
  return ml(e20, t2) || hl.has(e20);
}
function Dl(e20) {
  return gl.has(e20);
}
var El = Object.defineProperty({isReservedWord: ol, isStrictReservedWord: sl, isStrictBindOnlyReservedWord: al, isStrictBindReservedWord: cl, isKeyword: ll}, "__esModule", {value: true}), Cl = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true}), Object.defineProperty(t2, "isIdentifierName", {enumerable: true, get: function() {
    return ul.isIdentifierName;
  }}), Object.defineProperty(t2, "isIdentifierChar", {enumerable: true, get: function() {
    return ul.isIdentifierChar;
  }}), Object.defineProperty(t2, "isIdentifierStart", {enumerable: true, get: function() {
    return ul.isIdentifierStart;
  }}), Object.defineProperty(t2, "isReservedWord", {enumerable: true, get: function() {
    return El.isReservedWord;
  }}), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", {enumerable: true, get: function() {
    return El.isStrictBindOnlyReservedWord;
  }}), Object.defineProperty(t2, "isStrictBindReservedWord", {enumerable: true, get: function() {
    return El.isStrictBindReservedWord;
  }}), Object.defineProperty(t2, "isStrictReservedWord", {enumerable: true, get: function() {
    return El.isStrictReservedWord;
  }}), Object.defineProperty(t2, "isKeyword", {enumerable: true, get: function() {
    return El.isKeyword;
  }});
}), bl = /[|\\{}()[\]^$+*?.]/g, Al = function(e20) {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(bl, "\\$&");
}, vl = r$3(function(e20) {
  const t2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${n3 + t3}m`;
  }, n2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};5;${n3}m`;
  }, r2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
  };
  Object.defineProperty(e20, "exports", {enumerable: true, get: function() {
    const e21 = new Map(), i2 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
    i2.color.grey = i2.color.gray;
    for (const t3 of Object.keys(i2)) {
      const n3 = i2[t3];
      for (const t4 of Object.keys(n3)) {
        const r3 = n3[t4];
        i2[t4] = {open: `[${r3[0]}m`, close: `[${r3[1]}m`}, n3[t4] = i2[t4], e21.set(r3[0], r3[1]);
      }
      Object.defineProperty(i2, t3, {value: n3, enumerable: false}), Object.defineProperty(i2, "codes", {value: e21, enumerable: false});
    }
    const u2 = (e22) => e22, o2 = (e22, t3, n3) => [e22, t3, n3];
    i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = {ansi: t2(u2, 0)}, i2.color.ansi256 = {ansi256: n2(u2, 0)}, i2.color.ansi16m = {rgb: r2(o2, 0)}, i2.bgColor.ansi = {ansi: t2(u2, 10)}, i2.bgColor.ansi256 = {ansi256: n2(u2, 10)}, i2.bgColor.ansi16m = {rgb: r2(o2, 10)};
    for (let e22 of Object.keys(Ro$2)) {
      if (typeof Ro$2[e22] != "object")
        continue;
      const u3 = Ro$2[e22];
      e22 === "ansi16" && (e22 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e22] = t2(u3.ansi16, 0), i2.bgColor.ansi[e22] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e22] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e22] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e22] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e22] = r2(u3.rgb, 10));
    }
    return i2;
  }});
}), Fl = (e20, t2) => {
  t2 = t2 || xr$2.argv;
  const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
  return r2 !== -1 && (i2 === -1 || r2 < i2);
};
const Sl = xr$2.env;
let xl;
function wl(e20) {
  return function(e21) {
    return e21 !== 0 && {level: e21, hasBasic: true, has256: e21 >= 2, has16m: e21 >= 3};
  }(function(e21) {
    if (xl === false)
      return 0;
    if (Fl("color=16m") || Fl("color=full") || Fl("color=truecolor"))
      return 3;
    if (Fl("color=256"))
      return 2;
    if (e21 && !e21.isTTY && xl !== true)
      return 0;
    const t2 = xl ? 1 : 0;
    if (xr$2.platform === "win32") {
      const e22 = is$2.release().split(".");
      return Number(xr$2.versions.node.split(".")[0]) >= 8 && Number(e22[0]) >= 10 && Number(e22[2]) >= 10586 ? Number(e22[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Sl)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e22) => e22 in Sl) || Sl.CI_NAME === "codeship" ? 1 : t2;
    if ("TEAMCITY_VERSION" in Sl)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Sl.TEAMCITY_VERSION) ? 1 : 0;
    if (Sl.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Sl) {
      const e22 = parseInt((Sl.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Sl.TERM_PROGRAM) {
        case "iTerm.app":
          return e22 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Sl.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Sl.TERM) || "COLORTERM" in Sl ? 1 : (Sl.TERM, t2);
  }(e20));
}
Fl("no-color") || Fl("no-colors") || Fl("color=false") ? xl = false : (Fl("color") || Fl("colors") || Fl("color=true") || Fl("color=always")) && (xl = true), "FORCE_COLOR" in Sl && (xl = Sl.FORCE_COLOR.length === 0 || parseInt(Sl.FORCE_COLOR, 10) !== 0);
var Tl = {supportsColor: wl, stdout: wl(xr$2.stdout), stderr: wl(xr$2.stderr)};
const Bl = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Nl = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, kl = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Pl = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Ol = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
function Il(e20) {
  return e20[0] === "u" && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : Ol.get(e20) || e20;
}
function Ll(e20, t2) {
  const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
  let i2;
  for (const t3 of r2)
    if (isNaN(t3)) {
      if (!(i2 = t3.match(kl)))
        throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
      n2.push(i2[2].replace(Pl, (e21, t4, n3) => t4 ? Il(t4) : n3));
    } else
      n2.push(Number(t3));
  return n2;
}
function jl(e20) {
  Nl.lastIndex = 0;
  const t2 = [];
  let n2;
  for (; (n2 = Nl.exec(e20)) !== null; ) {
    const e21 = n2[1];
    if (n2[2]) {
      const r2 = Ll(e21, n2[2]);
      t2.push([e21].concat(r2));
    } else
      t2.push([e21]);
  }
  return t2;
}
function _l(e20, t2) {
  const n2 = {};
  for (const e21 of t2)
    for (const t3 of e21.styles)
      n2[t3[0]] = e21.inverse ? null : t3.slice(1);
  let r2 = e20;
  for (const e21 of Object.keys(n2))
    if (Array.isArray(n2[e21])) {
      if (!(e21 in r2))
        throw new Error(`Unknown Chalk style: ${e21}`);
      r2 = n2[e21].length > 0 ? r2[e21].apply(r2, n2[e21]) : r2[e21];
    }
  return r2;
}
var Ml = (e20, t2) => {
  const n2 = [], r2 = [];
  let i2 = [];
  if (t2.replace(Bl, (t3, u2, o2, s2, a2, c2) => {
    if (u2)
      i2.push(Il(u2));
    else if (s2) {
      const t4 = i2.join("");
      i2 = [], r2.push(n2.length === 0 ? t4 : _l(e20, n2)(t4)), n2.push({inverse: o2, styles: jl(s2)});
    } else if (a2) {
      if (n2.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      r2.push(_l(e20, n2)(i2.join(""))), i2 = [], n2.pop();
    } else
      i2.push(c2);
  }), r2.push(i2.join("")), n2.length > 0) {
    const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(e21);
  }
  return r2.join("");
}, Rl = r$3(function(e20) {
  const t2 = Tl.stdout, n2 = xr$2.platform === "win32" && !(xr$2.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
  function o2(e21, n3) {
    n3 = n3 || {};
    const r3 = t2 ? t2.level : 0;
    e21.level = n3.level === void 0 ? r3 : n3.level, e21.enabled = "enabled" in n3 ? n3.enabled : e21.level > 0;
  }
  function s2(e21) {
    if (!this || !(this instanceof s2) || this.template) {
      const t3 = {};
      return o2(t3, e21), t3.template = function() {
        const e22 = [].slice.call(arguments);
        return p2.apply(null, [t3.template].concat(e22));
      }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
    }
    o2(this, e21);
  }
  n2 && (vl.blue.open = "[94m");
  for (const e21 of Object.keys(vl))
    vl[e21].closeRe = new RegExp(Al(vl[e21].close), "g"), u2[e21] = {get() {
      const t3 = vl[e21];
      return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e21);
    }};
  u2.visible = {get() {
    return c2.call(this, this._styles || [], true, "visible");
  }}, vl.color.closeRe = new RegExp(Al(vl.color.close), "g");
  for (const e21 of Object.keys(vl.color.ansi))
    i2.has(e21) || (u2[e21] = {get() {
      const t3 = this.level;
      return function() {
        const n3 = vl.color[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: vl.color.close, closeRe: vl.color.closeRe};
        return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
      };
    }});
  vl.bgColor.closeRe = new RegExp(Al(vl.bgColor.close), "g");
  for (const e21 of Object.keys(vl.bgColor.ansi)) {
    if (i2.has(e21))
      continue;
    u2["bg" + e21[0].toUpperCase() + e21.slice(1)] = {get() {
      const t3 = this.level;
      return function() {
        const n3 = vl.bgColor[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: vl.bgColor.close, closeRe: vl.bgColor.closeRe};
        return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
      };
    }};
  }
  const a2 = Object.defineProperties(() => {
  }, u2);
  function c2(e21, t3, n3) {
    const r3 = function() {
      return l2.apply(r3, arguments);
    };
    r3._styles = e21, r3._empty = t3;
    const i3 = this;
    return Object.defineProperty(r3, "level", {enumerable: true, get: () => i3.level, set(e22) {
      i3.level = e22;
    }}), Object.defineProperty(r3, "enabled", {enumerable: true, get: () => i3.enabled, set(e22) {
      i3.enabled = e22;
    }}), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = a2, r3;
  }
  function l2() {
    const e21 = arguments, t3 = e21.length;
    let r3 = String(arguments[0]);
    if (t3 === 0)
      return "";
    if (t3 > 1)
      for (let n3 = 1; n3 < t3; n3++)
        r3 += " " + e21[n3];
    if (!this.enabled || this.level <= 0 || !r3)
      return this._empty ? "" : r3;
    const i3 = vl.dim.open;
    n2 && this.hasGrey && (vl.dim.open = "");
    for (const e22 of this._styles.slice().reverse())
      r3 = e22.open + r3.replace(e22.closeRe, e22.open) + e22.close, r3 = r3.replace(/\r?\n/g, `${e22.close}$&${e22.open}`);
    return vl.dim.open = i3, r3;
  }
  function p2(e21, t3) {
    if (!Array.isArray(t3))
      return [].slice.call(arguments, 1).join(" ");
    const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
    for (let e22 = 1; e22 < t3.length; e22++)
      r3.push(String(n3[e22 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e22]));
    return Ml(e21, r3.join(""));
  }
  Object.defineProperties(s2.prototype, u2), e20.exports = s2(), e20.exports.supportsColor = t2, e20.exports.default = e20.exports;
}), $l = Hl, Vl = Jl, Wl = function(e20, t2 = {}) {
  if (Hl(t2)) {
    const n2 = Jl(t2);
    return function(e21, t3) {
      let n3 = "";
      for (const {type: r2, value: i2} of Gl(t3)) {
        const t4 = e21[r2];
        n3 += t4 ? i2.split(Ul).map((e22) => t4(e22)).join("\n") : i2;
      }
      return n3;
    }(function(e21) {
      return {keyword: e21.cyan, capitalized: e21.yellow, jsxIdentifier: e21.yellow, punctuator: e21.yellow, number: e21.magenta, string: e21.green, regex: e21.magenta, comment: e21.grey, invalid: e21.white.bgRed.bold};
    }(n2), e20);
  }
  return e20;
};
const ql = new Set(["as", "async", "from", "get", "of", "set"]);
const Ul = /\r\n|[\n\r\u2028\u2029]/, zl = /^[()[\]{}]$/;
let Gl;
{
  const e20 = /^[a-z][\w-]*$/i, t2 = function(t3, n2, r2) {
    if (t3.type === "name") {
      if ((0, Cl.isKeyword)(t3.value) || (0, Cl.isStrictReservedWord)(t3.value, true) || ql.has(t3.value))
        return "keyword";
      if (e20.test(t3.value) && (r2[n2 - 1] === "<" || r2.substr(n2 - 2, 2) == "</"))
        return "jsxIdentifier";
      if (t3.value[0] !== t3.value[0].toLowerCase())
        return "capitalized";
    }
    return t3.type === "punctuator" && zl.test(t3.value) ? "bracket" : t3.type !== "invalid" || t3.value !== "@" && t3.value !== "#" ? t3.type : "punctuator";
  };
  Gl = function* (e21) {
    let n2;
    for (; n2 = Gc.default.exec(e21); ) {
      const r2 = Gc.matchToToken(n2);
      yield {type: t2(r2, n2.index, e21), value: r2.value};
    }
  };
}
function Hl(e20) {
  return !!Rl.supportsColor || e20.forceColor;
}
function Jl(e20) {
  return e20.forceColor ? new Rl.constructor({enabled: true, level: 1}) : Rl;
}
var Xl = Object.defineProperty({shouldHighlight: $l, getChalk: Vl, default: Wl}, "__esModule", {value: true}), Yl = ep, Kl = function(e20, t2, n2, r2 = {}) {
  if (!Ql) {
    Ql = true;
    const e21 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    if (xr$2.emitWarning)
      xr$2.emitWarning(e21, "DeprecationWarning");
    else {
      new Error(e21).name = "DeprecationWarning", console.warn(new Error(e21));
    }
  }
  n2 = Math.max(n2, 0);
  return ep(e20, {start: {column: n2, line: t2}}, r2);
};
let Ql = false;
const Zl = /\r\n|[\n\r\u2028\u2029]/;
function ep(e20, t2, n2 = {}) {
  const r2 = (n2.highlightCode || n2.forceColor) && (0, Xl.shouldHighlight)(n2), i2 = (0, Xl.getChalk)(n2), u2 = function(e21) {
    return {gutter: e21.grey, marker: e21.red.bold, message: e21.red.bold};
  }(i2), o2 = (e21, t3) => r2 ? e21(t3) : t3, s2 = e20.split(Zl), {start: a2, end: c2, markerLines: l2} = function(e21, t3, n3) {
    const r3 = Object.assign({column: 0, line: -1}, e21.start), i3 = Object.assign({}, r3, e21.end), {linesAbove: u3 = 2, linesBelow: o3 = 3} = n3 || {}, s3 = r3.line, a3 = r3.column, c3 = i3.line, l3 = i3.column;
    let p3 = Math.max(s3 - (u3 + 1), 0), f3 = Math.min(t3.length, c3 + o3);
    s3 === -1 && (p3 = 0), c3 === -1 && (f3 = t3.length);
    const d3 = c3 - s3, h2 = {};
    if (d3)
      for (let e22 = 0; e22 <= d3; e22++) {
        const n4 = e22 + s3;
        if (a3)
          if (e22 === 0) {
            const e23 = t3[n4 - 1].length;
            h2[n4] = [a3, e23 - a3 + 1];
          } else if (e22 === d3)
            h2[n4] = [0, l3];
          else {
            const r4 = t3[n4 - e22].length;
            h2[n4] = [0, r4];
          }
        else
          h2[n4] = true;
      }
    else
      h2[s3] = a3 === l3 ? !a3 || [a3, 0] : [a3, l3 - a3];
    return {start: p3, end: f3, markerLines: h2};
  }(t2, s2, n2), p2 = t2.start && typeof t2.start.column == "number", f2 = String(c2).length;
  let d2 = (r2 ? (0, Xl.default)(e20, n2) : e20).split(Zl).slice(a2, c2).map((e21, t3) => {
    const r3 = a2 + 1 + t3, i3 = ` ${` ${r3}`.slice(-f2)} |`, s3 = l2[r3], c3 = !l2[r3 + 1];
    if (s3) {
      let t4 = "";
      if (Array.isArray(s3)) {
        const r4 = e21.slice(0, Math.max(s3[0] - 1, 0)).replace(/[^\t]/g, " "), a3 = s3[1] || 1;
        t4 = ["\n ", o2(u2.gutter, i3.replace(/\d/g, " ")), " ", r4, o2(u2.marker, "^").repeat(a3)].join(""), c3 && n2.message && (t4 += " " + o2(u2.message, n2.message));
      }
      return [o2(u2.marker, ">"), o2(u2.gutter, i3), e21.length > 0 ? ` ${e21}` : "", t4].join("");
    }
    return ` ${o2(u2.gutter, i3)}${e21.length > 0 ? ` ${e21}` : ""}`;
  }).join("\n");
  return n2.message && !p2 && (d2 = `${" ".repeat(f2 + 1)}${n2.message}
${d2}`), r2 ? i2.reset(d2) : d2;
}
var tp = Object.defineProperty({codeFrameColumns: Yl, default: Kl}, "__esModule", {value: true}), np = n$3(mu$1);
const {ConfigError: rp} = bo$2, {locStart: ip, locEnd: up} = zc, op = Object.getOwnPropertyNames, sp = Object.getOwnPropertyDescriptor;
function ap(e20) {
  const t2 = {};
  for (const n2 of e20.plugins)
    if (n2.parsers)
      for (const e21 of op(n2.parsers))
        Object.defineProperty(t2, e21, sp(n2.parsers, e21));
  return t2;
}
function cp(e20, t2 = ap(e20)) {
  if (typeof e20.parser == "function")
    return {parse: e20.parser, astFormat: "estree", locStart: ip, locEnd: up};
  if (typeof e20.parser == "string") {
    if (Object.prototype.hasOwnProperty.call(t2, e20.parser))
      return t2[e20.parser];
    throw new rp(`Couldn't resolve parser "${e20.parser}". Parsers must be explicitly added to the standalone bundle.`);
  }
}
var lp = {parse: function(e20, t2) {
  const n2 = ap(t2), r2 = Object.defineProperties({}, Object.fromEntries(Object.keys(n2).map((e21) => [e21, {enumerable: true, get: () => n2[e21].parse}]))), i2 = cp(t2, n2);
  try {
    return i2.preprocess && (e20 = i2.preprocess(e20, t2)), {text: e20, ast: i2.parse(e20, r2, t2)};
  } catch (t3) {
    const {loc: n3} = t3;
    if (n3) {
      const {codeFrameColumns: r3} = tp;
      throw t3.codeFrame = r3(e20, n3, {highlightCode: true}), t3.message += "\n" + t3.codeFrame, t3;
    }
    throw t3.stack;
  }
}, resolveParser: cp};
const {UndefinedParserError: pp} = bo$2, {getSupportInfo: fp} = Qr$2, {resolveParser: dp} = lp, hp = {astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null};
function gp(e20, t2) {
  const n2 = np.basename(e20).toLowerCase(), r2 = fp({plugins: t2}).languages.filter((e21) => e21.since !== null);
  let i2 = r2.find((e21) => e21.extensions && e21.extensions.some((e22) => n2.endsWith(e22)) || e21.filenames && e21.filenames.some((e22) => e22.toLowerCase() === n2));
  if (!i2 && !n2.includes(".")) {
    const t3 = function(e21) {
      if (typeof e21 != "string")
        return "";
      let t4;
      try {
        t4 = go$2.openSync(e21, "r");
      } catch {
        return "";
      }
      try {
        const e22 = new mo$2(t4).next().toString("utf8"), n3 = e22.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
        if (n3)
          return n3[1];
        const r3 = e22.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
        return r3 ? r3[1] : "";
      } catch {
        return "";
      } finally {
        try {
          go$2.closeSync(t4);
        } catch {
        }
      }
    }(e20);
    i2 = r2.find((e21) => e21.interpreters && e21.interpreters.includes(t3));
  }
  return i2 && i2.parsers[0];
}
var mp = {normalize: function(e20, t2 = {}) {
  const n2 = Object.assign({}, e20), r2 = fp({plugins: e20.plugins, showUnreleased: true, showDeprecated: true}).options, i2 = Object.assign(Object.assign({}, hp), Object.fromEntries(r2.filter((e21) => e21.default !== void 0).map((e21) => [e21.name, e21.default])));
  if (!n2.parser)
    if (n2.filepath) {
      if (n2.parser = gp(n2.filepath, n2.plugins), !n2.parser)
        throw new pp(`No parser could be inferred for file: ${n2.filepath}`);
    } else {
      (t2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
    }
  const u2 = dp($c.normalizeApiOptions(n2, [r2.find((e21) => e21.name === "parser")], {passThrough: true, logger: false}));
  n2.astFormat = u2.astFormat, n2.locEnd = u2.locEnd, n2.locStart = u2.locStart;
  const o2 = function(e21) {
    const {astFormat: t3} = e21;
    if (!t3)
      throw new Error("getPlugin() requires astFormat to be set");
    const n3 = e21.plugins.find((e22) => e22.printers && e22.printers[t3]);
    if (!n3)
      throw new Error(`Couldn't find plugin for AST format "${t3}"`);
    return n3;
  }(n2);
  n2.printer = o2.printers[n2.astFormat];
  const s2 = Object.fromEntries(r2.filter((e21) => e21.pluginDefaults && e21.pluginDefaults[o2.name] !== void 0).map((e21) => [e21.name, e21.pluginDefaults[o2.name]])), a2 = Object.assign(Object.assign({}, i2), s2);
  for (const [e21, t3] of Object.entries(a2))
    n2[e21] !== null && n2[e21] !== void 0 || (n2[e21] = t3);
  return n2.parser === "json" && (n2.trailingComma = "none"), $c.normalizeApiOptions(n2, r2, Object.assign({passThrough: Object.keys(hp)}, t2));
}, hiddenDefaults: hp, inferParser: gp};
var yp = function e(t2, n2, r2) {
  if (Array.isArray(t2))
    return t2.map((t3) => e(t3, n2, r2)).filter(Boolean);
  if (!t2 || typeof t2 != "object")
    return t2;
  const i2 = n2.printer.massageAstNode;
  let u2;
  u2 = i2 && i2.ignoredProperties ? i2.ignoredProperties : new Set();
  const o2 = {};
  for (const [r3, i3] of Object.entries(t2))
    u2.has(r3) || typeof i3 == "function" || (o2[r3] = e(i3, n2, t2));
  if (i2) {
    const e20 = i2(t2, o2, r2);
    if (e20 === null)
      return;
    if (e20)
      return e20;
  }
  return o2;
}, Dp = typeof Object.create == "function" ? function(e20, t2) {
  e20.super_ = t2, e20.prototype = Object.create(t2.prototype, {constructor: {value: e20, enumerable: false, writable: true, configurable: true}});
} : function(e20, t2) {
  e20.super_ = t2;
  var n2 = function() {
  };
  n2.prototype = t2.prototype, e20.prototype = new n2(), e20.prototype.constructor = e20;
};
function Ep(e20, t2) {
  var n2 = {seen: [], stylize: bp};
  return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Sp(t2) ? n2.showHidden = t2 : t2 && jp(n2, t2), Tp(n2.showHidden) && (n2.showHidden = false), Tp(n2.depth) && (n2.depth = 2), Tp(n2.colors) && (n2.colors = false), Tp(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = Cp), Ap(n2, e20, n2.depth);
}
function Cp(e20, t2) {
  var n2 = Ep.styles[t2];
  return n2 ? "[" + Ep.colors[n2][0] + "m" + e20 + "[" + Ep.colors[n2][1] + "m" : e20;
}
function bp(e20, t2) {
  return e20;
}
function Ap(e20, t2, n2) {
  if (e20.customInspect && t2 && Op(t2.inspect) && t2.inspect !== Ep && (!t2.constructor || t2.constructor.prototype !== t2)) {
    var r2 = t2.inspect(n2, e20);
    return wp(r2) || (r2 = Ap(e20, r2, n2)), r2;
  }
  var i2 = function(e21, t3) {
    if (Tp(t3))
      return e21.stylize("undefined", "undefined");
    if (wp(t3)) {
      var n3 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e21.stylize(n3, "string");
    }
    if (r3 = t3, typeof r3 == "number")
      return e21.stylize("" + t3, "number");
    var r3;
    if (Sp(t3))
      return e21.stylize("" + t3, "boolean");
    if (xp(t3))
      return e21.stylize("null", "null");
  }(e20, t2);
  if (i2)
    return i2;
  var u2 = Object.keys(t2), o2 = function(e21) {
    var t3 = {};
    return e21.forEach(function(e22, n3) {
      t3[e22] = true;
    }), t3;
  }(u2);
  if (e20.showHidden && (u2 = Object.getOwnPropertyNames(t2)), Pp(t2) && (u2.indexOf("message") >= 0 || u2.indexOf("description") >= 0))
    return vp(t2);
  if (u2.length === 0) {
    if (Op(t2)) {
      var s2 = t2.name ? ": " + t2.name : "";
      return e20.stylize("[Function" + s2 + "]", "special");
    }
    if (Bp(t2))
      return e20.stylize(RegExp.prototype.toString.call(t2), "regexp");
    if (kp(t2))
      return e20.stylize(Date.prototype.toString.call(t2), "date");
    if (Pp(t2))
      return vp(t2);
  }
  var a2, c2, l2 = "", p2 = false, f2 = ["{", "}"];
  (a2 = t2, Array.isArray(a2) && (p2 = true, f2 = ["[", "]"]), Op(t2)) && (l2 = " [Function" + (t2.name ? ": " + t2.name : "") + "]");
  return Bp(t2) && (l2 = " " + RegExp.prototype.toString.call(t2)), kp(t2) && (l2 = " " + Date.prototype.toUTCString.call(t2)), Pp(t2) && (l2 = " " + vp(t2)), u2.length !== 0 || p2 && t2.length != 0 ? n2 < 0 ? Bp(t2) ? e20.stylize(RegExp.prototype.toString.call(t2), "regexp") : e20.stylize("[Object]", "special") : (e20.seen.push(t2), c2 = p2 ? function(e21, t3, n3, r3, i3) {
    for (var u3 = [], o3 = 0, s3 = t3.length; o3 < s3; ++o3)
      _p(t3, String(o3)) ? u3.push(Fp(e21, t3, n3, r3, String(o3), true)) : u3.push("");
    return i3.forEach(function(i4) {
      i4.match(/^\d+$/) || u3.push(Fp(e21, t3, n3, r3, i4, true));
    }), u3;
  }(e20, t2, n2, o2, u2) : u2.map(function(r3) {
    return Fp(e20, t2, n2, o2, r3, p2);
  }), e20.seen.pop(), function(e21, t3, n3) {
    if (e21.reduce(function(e22, t4) {
      return t4.indexOf("\n"), e22 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return n3[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e21.join(",\n  ") + " " + n3[1];
    return n3[0] + t3 + " " + e21.join(", ") + " " + n3[1];
  }(c2, l2, f2)) : f2[0] + l2 + f2[1];
}
function vp(e20) {
  return "[" + Error.prototype.toString.call(e20) + "]";
}
function Fp(e20, t2, n2, r2, i2, u2) {
  var o2, s2, a2;
  if ((a2 = Object.getOwnPropertyDescriptor(t2, i2) || {value: t2[i2]}).get ? s2 = a2.set ? e20.stylize("[Getter/Setter]", "special") : e20.stylize("[Getter]", "special") : a2.set && (s2 = e20.stylize("[Setter]", "special")), _p(r2, i2) || (o2 = "[" + i2 + "]"), s2 || (e20.seen.indexOf(a2.value) < 0 ? (s2 = xp(n2) ? Ap(e20, a2.value, null) : Ap(e20, a2.value, n2 - 1)).indexOf("\n") > -1 && (s2 = u2 ? s2.split("\n").map(function(e21) {
    return "  " + e21;
  }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e21) {
    return "   " + e21;
  }).join("\n")) : s2 = e20.stylize("[Circular]", "special")), Tp(o2)) {
    if (u2 && i2.match(/^\d+$/))
      return s2;
    (o2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e20.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e20.stylize(o2, "string"));
  }
  return o2 + ": " + s2;
}
function Sp(e20) {
  return typeof e20 == "boolean";
}
function xp(e20) {
  return e20 === null;
}
function wp(e20) {
  return typeof e20 == "string";
}
function Tp(e20) {
  return e20 === void 0;
}
function Bp(e20) {
  return Np(e20) && Lp(e20) === "[object RegExp]";
}
function Np(e20) {
  return typeof e20 == "object" && e20 !== null;
}
function kp(e20) {
  return Np(e20) && Lp(e20) === "[object Date]";
}
function Pp(e20) {
  return Np(e20) && (Lp(e20) === "[object Error]" || e20 instanceof Error);
}
function Op(e20) {
  return typeof e20 == "function";
}
function Ip(e20) {
  return e20 === null || typeof e20 == "boolean" || typeof e20 == "number" || typeof e20 == "string" || typeof e20 == "symbol" || e20 === void 0;
}
function Lp(e20) {
  return Object.prototype.toString.call(e20);
}
function jp(e20, t2) {
  if (!t2 || !Np(t2))
    return e20;
  for (var n2 = Object.keys(t2), r2 = n2.length; r2--; )
    e20[n2[r2]] = t2[n2[r2]];
  return e20;
}
function _p(e20, t2) {
  return Object.prototype.hasOwnProperty.call(e20, t2);
}
function Mp(e20, t2) {
  if (e20 === t2)
    return 0;
  for (var n2 = e20.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
    if (e20[i2] !== t2[i2]) {
      n2 = e20[i2], r2 = t2[i2];
      break;
    }
  return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
}
Ep.colors = {bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39]}, Ep.styles = {special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red"};
var Rp, $p = Object.prototype.hasOwnProperty, Vp = Object.keys || function(e20) {
  var t2 = [];
  for (var n2 in e20)
    $p.call(e20, n2) && t2.push(n2);
  return t2;
}, Wp = Array.prototype.slice;
function qp() {
  return Rp !== void 0 ? Rp : Rp = function() {
  }.name === "foo";
}
function Up(e20) {
  return Object.prototype.toString.call(e20);
}
function zp(e20) {
  return !fo$2(e20) && (typeof nr$2.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e20) : !!e20 && (e20 instanceof DataView || !!(e20.buffer && e20.buffer instanceof ArrayBuffer))));
}
function Gp(e20, t2) {
  e20 || Qp(e20, true, t2, "==", Zp);
}
var Hp = /\s*function\s+([^\(\s]*)\s*/;
function Jp(e20) {
  if (Op(e20)) {
    if (qp())
      return e20.name;
    var t2 = e20.toString().match(Hp);
    return t2 && t2[1];
  }
}
function Xp(e20) {
  this.name = "AssertionError", this.actual = e20.actual, this.expected = e20.expected, this.operator = e20.operator, e20.message ? (this.message = e20.message, this.generatedMessage = false) : (this.message = function(e21) {
    return Yp(Kp(e21.actual), 128) + " " + e21.operator + " " + Yp(Kp(e21.expected), 128);
  }(this), this.generatedMessage = true);
  var t2 = e20.stackStartFunction || Qp;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, t2);
  else {
    var n2 = new Error();
    if (n2.stack) {
      var r2 = n2.stack, i2 = Jp(t2), u2 = r2.indexOf("\n" + i2);
      if (u2 >= 0) {
        var o2 = r2.indexOf("\n", u2 + 1);
        r2 = r2.substring(o2 + 1);
      }
      this.stack = r2;
    }
  }
}
function Yp(e20, t2) {
  return typeof e20 == "string" ? e20.length < t2 ? e20 : e20.slice(0, t2) : e20;
}
function Kp(e20) {
  if (qp() || !Op(e20))
    return Ep(e20);
  var t2 = Jp(e20);
  return "[Function" + (t2 ? ": " + t2 : "") + "]";
}
function Qp(e20, t2, n2, r2, i2) {
  throw new Xp({message: n2, actual: e20, expected: t2, operator: r2, stackStartFunction: i2});
}
function Zp(e20, t2) {
  e20 || Qp(e20, true, t2, "==", Zp);
}
function ef(e20, t2, n2) {
  e20 != t2 && Qp(e20, t2, n2, "==", ef);
}
function tf(e20, t2, n2) {
  e20 == t2 && Qp(e20, t2, n2, "!=", tf);
}
function nf(e20, t2, n2) {
  uf(e20, t2, false) || Qp(e20, t2, n2, "deepEqual", nf);
}
function rf(e20, t2, n2) {
  uf(e20, t2, true) || Qp(e20, t2, n2, "deepStrictEqual", rf);
}
function uf(e20, t2, n2, r2) {
  if (e20 === t2)
    return true;
  if (fo$2(e20) && fo$2(t2))
    return Mp(e20, t2) === 0;
  if (kp(e20) && kp(t2))
    return e20.getTime() === t2.getTime();
  if (Bp(e20) && Bp(t2))
    return e20.source === t2.source && e20.global === t2.global && e20.multiline === t2.multiline && e20.lastIndex === t2.lastIndex && e20.ignoreCase === t2.ignoreCase;
  if (e20 !== null && typeof e20 == "object" || t2 !== null && typeof t2 == "object") {
    if (zp(e20) && zp(t2) && Up(e20) === Up(t2) && !(e20 instanceof Float32Array || e20 instanceof Float64Array))
      return Mp(new Uint8Array(e20.buffer), new Uint8Array(t2.buffer)) === 0;
    if (fo$2(e20) !== fo$2(t2))
      return false;
    var i2 = (r2 = r2 || {actual: [], expected: []}).actual.indexOf(e20);
    return i2 !== -1 && i2 === r2.expected.indexOf(t2) || (r2.actual.push(e20), r2.expected.push(t2), function(e21, t3, n3, r3) {
      if (e21 == null || t3 == null)
        return false;
      if (Ip(e21) || Ip(t3))
        return e21 === t3;
      if (n3 && Object.getPrototypeOf(e21) !== Object.getPrototypeOf(t3))
        return false;
      var i3 = of(e21), u2 = of(t3);
      if (i3 && !u2 || !i3 && u2)
        return false;
      if (i3)
        return uf(e21 = Wp.call(e21), t3 = Wp.call(t3), n3);
      var o2, s2, a2 = Vp(e21), c2 = Vp(t3);
      if (a2.length !== c2.length)
        return false;
      for (a2.sort(), c2.sort(), s2 = a2.length - 1; s2 >= 0; s2--)
        if (a2[s2] !== c2[s2])
          return false;
      for (s2 = a2.length - 1; s2 >= 0; s2--)
        if (!uf(e21[o2 = a2[s2]], t3[o2], n3, r3))
          return false;
      return true;
    }(e20, t2, n2, r2));
  }
  return n2 ? e20 === t2 : e20 == t2;
}
function of(e20) {
  return Object.prototype.toString.call(e20) == "[object Arguments]";
}
function sf(e20, t2, n2) {
  uf(e20, t2, false) && Qp(e20, t2, n2, "notDeepEqual", sf);
}
function af(e20, t2, n2) {
  uf(e20, t2, true) && Qp(e20, t2, n2, "notDeepStrictEqual", af);
}
function cf(e20, t2, n2) {
  e20 !== t2 && Qp(e20, t2, n2, "===", cf);
}
function lf(e20, t2, n2) {
  e20 === t2 && Qp(e20, t2, n2, "!==", lf);
}
function pf(e20, t2) {
  if (!e20 || !t2)
    return false;
  if (Object.prototype.toString.call(t2) == "[object RegExp]")
    return t2.test(e20);
  try {
    if (e20 instanceof t2)
      return true;
  } catch (e21) {
  }
  return !Error.isPrototypeOf(t2) && t2.call({}, e20) === true;
}
function ff(e20, t2, n2, r2) {
  var i2;
  if (typeof t2 != "function")
    throw new TypeError('"block" argument must be a function');
  typeof n2 == "string" && (r2 = n2, n2 = null), i2 = function(e21) {
    var t3;
    try {
      e21();
    } catch (e22) {
      t3 = e22;
    }
    return t3;
  }(t2), r2 = (n2 && n2.name ? " (" + n2.name + ")." : ".") + (r2 ? " " + r2 : "."), e20 && !i2 && Qp(i2, n2, "Missing expected exception" + r2);
  var u2 = typeof r2 == "string", o2 = !e20 && i2 && !n2;
  if ((!e20 && Pp(i2) && u2 && pf(i2, n2) || o2) && Qp(i2, n2, "Got unwanted exception" + r2), e20 && i2 && n2 && !pf(i2, n2) || !e20 && i2)
    throw i2;
}
function df(e20, t2, n2) {
  ff(true, e20, t2, n2);
}
function hf(e20, t2, n2) {
  ff(false, e20, t2, n2);
}
function gf(e20) {
  if (e20)
    throw e20;
}
Gp.AssertionError = Xp, Dp(Xp, Error), Gp.fail = Qp, Gp.ok = Zp, Gp.equal = ef, Gp.notEqual = tf, Gp.deepEqual = nf, Gp.deepStrictEqual = rf, Gp.notDeepEqual = sf, Gp.notDeepStrictEqual = af, Gp.strictEqual = cf, Gp.notStrictEqual = lf, Gp.throws = df, Gp.doesNotThrow = hf, Gp.ifError = gf;
var mf = n$3(Object.freeze({__proto__: null, default: Gp, AssertionError: Xp, fail: Qp, ok: Zp, assert: Zp, equal: ef, notEqual: tf, deepEqual: nf, deepStrictEqual: rf, notDeepEqual: sf, notDeepStrictEqual: af, strictEqual: cf, notStrictEqual: lf, throws: df, doesNotThrow: hf, ifError: gf}));
const {builders: {line: yf, hardline: Df, breakParent: Ef, indent: Cf, lineSuffix: bf, join: Af, cursor: vf}} = eu$1, {hasNewline: Ff, skipNewline: Sf, skipSpaces: xf, isPreviousLineEmpty: wf, addLeadingComment: Tf, addDanglingComment: Bf, addTrailingComment: Nf} = yi$2, kf = new WeakMap();
function Pf(e20, t2, n2) {
  if (!e20)
    return;
  const {printer: r2, locStart: i2, locEnd: u2} = t2;
  if (n2) {
    if (r2.canAttachComment && r2.canAttachComment(e20)) {
      let t3;
      for (t3 = n2.length - 1; t3 >= 0 && !(i2(n2[t3]) <= i2(e20) && u2(n2[t3]) <= u2(e20)); --t3)
        ;
      return void n2.splice(t3 + 1, 0, e20);
    }
  } else if (kf.has(e20))
    return kf.get(e20);
  const o2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e20, t2) || typeof e20 == "object" && Object.entries(e20).filter(([e21]) => e21 !== "enclosingNode" && e21 !== "precedingNode" && e21 !== "followingNode" && e21 !== "tokens" && e21 !== "comments").map(([, e21]) => e21);
  if (o2) {
    n2 || (n2 = [], kf.set(e20, n2));
    for (const e21 of o2)
      Pf(e21, t2, n2);
    return n2;
  }
}
function Of(e20, t2, n2, r2) {
  const {locStart: i2, locEnd: u2} = n2, o2 = i2(t2), s2 = u2(t2), a2 = Pf(e20, n2);
  let c2, l2, p2 = 0, f2 = a2.length;
  for (; p2 < f2; ) {
    const e21 = p2 + f2 >> 1, r3 = a2[e21], d2 = i2(r3), h2 = u2(r3);
    if (d2 <= o2 && s2 <= h2)
      return Of(r3, t2, n2, r3);
    if (h2 <= o2)
      c2 = r3, p2 = e21 + 1;
    else {
      if (!(s2 <= d2))
        throw new Error("Comment location overlaps with node location");
      l2 = r3, f2 = e21;
    }
  }
  if (r2 && r2.type === "TemplateLiteral") {
    const {quasis: e21} = r2, i3 = $f(e21, t2, n2);
    c2 && $f(e21, c2, n2) !== i3 && (c2 = null), l2 && $f(e21, l2, n2) !== i3 && (l2 = null);
  }
  return {enclosingNode: r2, precedingNode: c2, followingNode: l2};
}
const If = () => false;
const Lf = (e20) => !/[\S\n\u2028\u2029]/.test(e20);
function jf(e20, t2, n2, r2) {
  const {comment: i2, precedingNode: u2} = n2[r2], {locStart: o2, locEnd: s2} = t2;
  let a2 = o2(i2);
  if (u2)
    for (let t3 = r2 - 1; t3 >= 0; t3--) {
      const {comment: r3, precedingNode: i3} = n2[t3];
      if (i3 !== u2 || !Lf(e20.slice(s2(r3), a2)))
        break;
      a2 = o2(r3);
    }
  return Ff(e20, a2, {backwards: true});
}
function _f(e20, t2, n2, r2) {
  const {comment: i2, followingNode: u2} = n2[r2], {locStart: o2, locEnd: s2} = t2;
  let a2 = s2(i2);
  if (u2)
    for (let t3 = r2 + 1; t3 < n2.length; t3++) {
      const {comment: r3, followingNode: i3} = n2[t3];
      if (i3 !== u2 || !Lf(e20.slice(a2, o2(r3))))
        break;
      a2 = s2(r3);
    }
  return Ff(e20, a2);
}
function Mf(e20, t2, n2) {
  const r2 = e20.length;
  if (r2 === 0)
    return;
  const {precedingNode: i2, followingNode: u2, enclosingNode: o2} = e20[0], s2 = n2.printer.getGapRegex && n2.printer.getGapRegex(o2) || /^[\s(]*$/;
  let a2, c2 = n2.locStart(u2);
  for (a2 = r2; a2 > 0; --a2) {
    const {comment: r3, precedingNode: o3, followingNode: l2} = e20[a2 - 1];
    mf.strictEqual(o3, i2), mf.strictEqual(l2, u2);
    const p2 = t2.slice(n2.locEnd(r3), c2);
    if (!s2.test(p2))
      break;
    c2 = n2.locStart(r3);
  }
  for (const [t3, {comment: n3}] of e20.entries())
    t3 < a2 ? Nf(i2, n3) : Tf(u2, n3);
  for (const e21 of [i2, u2])
    e21.comments && e21.comments.length > 1 && e21.comments.sort((e22, t3) => n2.locStart(e22) - n2.locStart(t3));
  e20.length = 0;
}
function Rf(e20, t2) {
  return e20.getValue().printed = true, t2.printer.printComment(e20, t2);
}
function $f(e20, t2, n2) {
  const r2 = n2.locStart(t2) - 1;
  for (let t3 = 1; t3 < e20.length; ++t3)
    if (r2 < n2.locStart(e20[t3]))
      return t3 - 1;
  return 0;
}
function Vf(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2)
    return {};
  let i2 = r2.comments || [];
  n2 && (i2 = i2.filter((e21) => !n2.has(e21)));
  const u2 = r2 === t2.cursorNode;
  if (i2.length === 0) {
    const e21 = u2 ? vf : "";
    return {leading: e21, trailing: e21};
  }
  const o2 = [], s2 = [];
  return e20.each(() => {
    const r3 = e20.getValue();
    if (n2 && n2.has(r3))
      return;
    const {leading: i3, trailing: u3} = r3;
    i3 ? o2.push(function(e21, t3) {
      const n3 = e21.getValue(), r4 = [Rf(e21, t3)], {printer: i4, originalText: u4, locStart: o3, locEnd: s3} = t3;
      if (i4.isBlockComment && i4.isBlockComment(n3)) {
        const e22 = Ff(u4, s3(n3)) ? Ff(u4, o3(n3), {backwards: true}) ? Df : yf : " ";
        r4.push(e22);
      } else
        r4.push(Df);
      const a2 = Sf(u4, xf(u4, s3(n3)));
      return a2 !== false && Ff(u4, a2) && r4.push(Df), r4;
    }(e20, t2)) : u3 && s2.push(function(e21, t3) {
      const n3 = e21.getValue(), r4 = Rf(e21, t3), {printer: i4, originalText: u4, locStart: o3} = t3, s3 = i4.isBlockComment && i4.isBlockComment(n3);
      if (Ff(u4, o3(n3), {backwards: true})) {
        const e22 = wf(u4, n3, o3);
        return bf([Df, e22 ? Df : "", r4]);
      }
      let a2 = [" ", r4];
      return s3 || (a2 = [bf(a2), Ef]), a2;
    }(e20, t2));
  }, "comments"), u2 && (o2.unshift(vf), s2.push(vf)), {leading: o2, trailing: s2};
}
var Wf = {attach: function(e20, t2, n2, r2) {
  if (!Array.isArray(e20))
    return;
  const i2 = [], {locStart: u2, locEnd: o2, printer: {handleComments: s2 = {}}} = r2, {avoidAstMutation: a2, ownLine: c2 = If, endOfLine: l2 = If, remaining: p2 = If} = s2, f2 = e20.map((i3, u3) => Object.assign(Object.assign({}, Of(t2, i3, r2)), {}, {comment: i3, text: n2, options: r2, ast: t2, isLastComment: e20.length - 1 === u3}));
  for (const [e21, t3] of f2.entries()) {
    const {comment: n3, precedingNode: r3, enclosingNode: s3, followingNode: d2, text: h2, options: g2, ast: m2, isLastComment: y2} = t3;
    if (g2.parser === "json" || g2.parser === "json5" || g2.parser === "__js_expression" || g2.parser === "__vue_expression") {
      if (u2(n3) - u2(m2) <= 0) {
        Tf(m2, n3);
        continue;
      }
      if (o2(n3) - o2(m2) >= 0) {
        Nf(m2, n3);
        continue;
      }
    }
    let D2;
    if (a2 ? D2 = [t3] : (n3.enclosingNode = s3, n3.precedingNode = r3, n3.followingNode = d2, D2 = [n3, h2, g2, m2, y2]), jf(h2, g2, f2, e21))
      n3.placement = "ownLine", c2(...D2) || (d2 ? Tf(d2, n3) : r3 ? Nf(r3, n3) : Bf(s3 || m2, n3));
    else if (_f(h2, g2, f2, e21))
      n3.placement = "endOfLine", l2(...D2) || (r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3));
    else if (n3.placement = "remaining", p2(...D2))
      ;
    else if (r3 && d2) {
      const e22 = i2.length;
      if (e22 > 0) {
        i2[e22 - 1].followingNode !== d2 && Mf(i2, h2, g2);
      }
      i2.push(t3);
    } else
      r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3);
  }
  if (Mf(i2, n2, r2), !a2)
    for (const t3 of e20)
      delete t3.precedingNode, delete t3.enclosingNode, delete t3.followingNode;
}, printComments: function(e20, t2, n2, r2) {
  const {leading: i2, trailing: u2} = Vf(e20, n2, r2);
  return i2 || u2 ? [i2, t2, u2] : t2;
}, printCommentsSeparately: Vf, printDanglingComments: function(e20, t2, n2, r2) {
  const i2 = [], u2 = e20.getValue();
  return u2 && u2.comments ? (e20.each(() => {
    const n3 = e20.getValue();
    n3.leading || n3.trailing || r2 && !r2(n3) || i2.push(Rf(e20, t2));
  }, "comments"), i2.length === 0 ? "" : n2 ? Af(Df, i2) : Cf([Df, Af(Df, i2)])) : "";
}, getSortedChildNodes: Pf, ensureAllCommentsPrinted: function(e20) {
  if (e20)
    for (const t2 of e20) {
      if (!t2.printed)
        throw new Error('Comment "' + t2.value.trim() + '" was not printed. Please report this error!');
      delete t2.printed;
    }
}};
function qf(e20, t2) {
  const n2 = Uf(e20.stack, t2);
  return n2 === -1 ? null : e20.stack[n2];
}
function Uf(e20, t2) {
  for (let n2 = e20.length - 1; n2 >= 0; n2 -= 2) {
    const r2 = e20[n2];
    if (r2 && !Array.isArray(r2) && --t2 < 0)
      return n2;
  }
  return -1;
}
var zf = class {
  constructor(e20) {
    this.stack = [e20];
  }
  getName() {
    const {stack: e20} = this, {length: t2} = e20;
    return t2 > 1 ? e20[t2 - 2] : null;
  }
  getValue() {
    return Ln$2(this.stack);
  }
  getNode(e20 = 0) {
    return qf(this, e20);
  }
  getParentNode(e20 = 0) {
    return qf(this, e20 + 1);
  }
  call(e20, ...t2) {
    const {stack: n2} = this, {length: r2} = n2;
    let i2 = Ln$2(n2);
    for (const e21 of t2)
      i2 = i2[e21], n2.push(e21, i2);
    const u2 = e20(this);
    return n2.length = r2, u2;
  }
  callParent(e20, t2 = 0) {
    const n2 = Uf(this.stack, t2 + 1), r2 = this.stack.splice(n2 + 1), i2 = e20(this);
    return this.stack.push(...r2), i2;
  }
  each(e20, ...t2) {
    const {stack: n2} = this, {length: r2} = n2;
    let i2 = Ln$2(n2);
    for (const e21 of t2)
      i2 = i2[e21], n2.push(e21, i2);
    for (let t3 = 0; t3 < i2.length; ++t3)
      n2.push(t3, i2[t3]), e20(this, t3, i2), n2.length -= 2;
    n2.length = r2;
  }
  map(e20, ...t2) {
    const n2 = [];
    return this.each((t3, r2, i2) => {
      n2[r2] = e20(t3, r2, i2);
    }, ...t2), n2;
  }
  try(e20) {
    const {stack: t2} = this, n2 = [...t2];
    try {
      return e20();
    } finally {
      t2.length = 0, t2.push(...n2);
    }
  }
  match(...e20) {
    let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
    for (const i2 of e20) {
      if (r2 === void 0)
        return false;
      let e21 = null;
      if (typeof n2 == "number" && (e21 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), i2 && !i2(r2, n2, e21))
        return false;
      n2 = this.stack[t2--], r2 = this.stack[t2--];
    }
    return true;
  }
  findAncestor(e20) {
    let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
    for (; r2; ) {
      let i2 = null;
      if (typeof n2 == "number" && (i2 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), n2 !== null && e20(r2, n2, i2))
        return r2;
      n2 = this.stack[t2--], r2 = this.stack[t2--];
    }
  }
};
const {utils: {stripTrailingHardline: Gf}} = eu$1, {normalize: Hf} = mp;
var Jf = {printSubtree: function(e20, t2, n2, r2) {
  if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
    return n2.printer.embed(e20, t2, (e21, t3, i2) => function(e22, t4, n3, r3, {stripTrailingHardline: i3 = false} = {}) {
      const u2 = Hf(Object.assign(Object.assign(Object.assign({}, n3), t4), {}, {parentParser: n3.parser, originalText: e22}), {passThrough: true}), o2 = lp.parse(e22, u2), {ast: s2} = o2;
      e22 = o2.text;
      const a2 = s2.comments;
      delete s2.comments, Wf.attach(a2, s2, e22, u2), u2[Symbol.for("comments")] = a2 || [], u2[Symbol.for("tokens")] = s2.tokens || [];
      const c2 = r3(s2, u2);
      if (Wf.ensureAllCommentsPrinted(a2), i3)
        return typeof c2 == "string" ? c2.replace(/(?:\r?\n)*$/, "") : Gf(c2);
      return c2;
    }(e21, t3, n2, r2, i2), n2);
}};
const {builders: {hardline: Xf, addAlignmentToDoc: Yf}, utils: {propagateBreaks: Kf}} = eu$1, {printComments: Qf} = Wf;
function Zf(e20, n2, r2 = 0) {
  const {printer: i2} = n2;
  i2.preprocess && (e20 = i2.preprocess(e20, n2));
  const u2 = new Map(), o2 = new zf(e20);
  let s2 = a2();
  return r2 > 0 && (s2 = Yf([Xf, s2], r2, n2.tabWidth)), Kf(s2), s2;
  function a2(e21, t2) {
    return e21 === void 0 || e21 === o2 ? c2(t2) : Array.isArray(e21) ? o2.call(() => c2(t2), ...e21) : o2.call(() => c2(t2), e21);
  }
  function c2(e21) {
    const r3 = o2.getValue(), i3 = r3 && typeof r3 == "object" && e21 === void 0;
    if (i3 && u2.has(r3))
      return u2.get(r3);
    const s3 = function(e22, n3, r4, i4) {
      const u3 = e22.getValue(), {printer: o3} = n3;
      let s4, a3;
      if (o3.hasPrettierIgnore && o3.hasPrettierIgnore(e22))
        ({doc: s4, printedComments: a3} = function(e23, t2) {
          const {originalText: n4, [Symbol.for("comments")]: r5, locStart: i5, locEnd: u4} = t2, o4 = i5(e23), s5 = u4(e23), a4 = new Set();
          for (const e24 of r5)
            i5(e24) >= o4 && u4(e24) <= s5 && (e24.printed = true, a4.add(e24));
          return {doc: n4.slice(o4, s5), printedComments: a4};
        }(u3, n3));
      else {
        if (u3)
          try {
            s4 = Jf.printSubtree(e22, r4, n3, Zf);
          } catch (e23) {
            if (t$3.PRETTIER_DEBUG)
              throw e23;
          }
        s4 || (s4 = o3.print(e22, n3, r4, i4));
      }
      o3.willPrintOwnComments && o3.willPrintOwnComments(e22, n3) || (s4 = Qf(e22, s4, n3, a3));
      return s4;
    }(o2, n2, a2, e21);
    return i3 && u2.set(r3, s3), s3;
  }
}
var ed = Zf;
function td(e20) {
  let t2 = e20.length - 1;
  for (; ; ) {
    const n2 = e20[t2];
    if (!n2 || n2.type !== "Program" && n2.type !== "File")
      break;
    t2--;
  }
  return e20.slice(0, t2 + 1);
}
function nd(e20, t2, n2, r2, i2 = [], u2) {
  const {locStart: o2, locEnd: s2} = n2, a2 = o2(e20), c2 = s2(e20);
  if (!(t2 > c2 || t2 < a2 || u2 === "rangeEnd" && t2 === a2 || u2 === "rangeStart" && t2 === c2)) {
    for (const o3 of Wf.getSortedChildNodes(e20, n2)) {
      const s3 = nd(o3, t2, n2, r2, [e20, ...i2], u2);
      if (s3)
        return s3;
    }
    return !r2 || r2(e20, i2[0]) ? {node: e20, parentNodes: i2} : void 0;
  }
}
const rd = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), id = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function ud(e20, t2, n2) {
  if (!t2)
    return false;
  switch (e20.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return function(e21, t3) {
        return t3 !== "DeclareExportDeclaration" && e21 !== "TypeParameterDeclaration" && (e21 === "Directive" || e21 === "TypeAlias" || e21 === "TSExportAssignment" || e21.startsWith("Declare") || e21.startsWith("TSDeclare") || e21.endsWith("Statement") || e21.endsWith("Declaration"));
      }(t2.type, n2 && n2.type);
    case "json":
    case "json5":
    case "json-stringify":
      return rd.has(t2.type);
    case "graphql":
      return id.has(t2.kind);
    case "vue":
      return t2.tag !== "root";
  }
  return false;
}
var od = {calculateRange: function(e20, t2, n2) {
  let {rangeStart: r2, rangeEnd: i2, locStart: u2, locEnd: o2} = t2;
  mf.ok(i2 > r2);
  const s2 = e20.slice(r2, i2).search(/\S/), a2 = s2 === -1;
  if (!a2)
    for (r2 += s2; i2 > r2 && !/\S/.test(e20[i2 - 1]); --i2)
      ;
  const c2 = nd(n2, r2, t2, (e21, n3) => ud(t2, e21, n3), [], "rangeStart"), l2 = a2 ? c2 : nd(n2, i2, t2, (e21) => ud(t2, e21), [], "rangeEnd");
  if (!c2 || !l2)
    return {rangeStart: 0, rangeEnd: 0};
  let p2, f2;
  if ((({parser: e21}) => e21 === "json" || e21 === "json5" || e21 === "json-stringify")(t2)) {
    const e21 = function(e22, t3) {
      const n3 = [e22.node, ...e22.parentNodes], r3 = new Set([t3.node, ...t3.parentNodes]);
      return n3.find((e23) => rd.has(e23.type) && r3.has(e23));
    }(c2, l2);
    p2 = e21, f2 = e21;
  } else
    ({startNode: p2, endNode: f2} = function(e21, t3, {locStart: n3, locEnd: r3}) {
      let i3 = e21.node, u3 = t3.node;
      if (i3 === u3)
        return {startNode: i3, endNode: u3};
      const o3 = n3(e21.node);
      for (const e22 of td(t3.parentNodes)) {
        if (!(n3(e22) >= o3))
          break;
        u3 = e22;
      }
      const s3 = r3(t3.node);
      for (const t4 of td(e21.parentNodes)) {
        if (!(r3(t4) <= s3))
          break;
        i3 = t4;
      }
      return {startNode: i3, endNode: u3};
    }(c2, l2, t2));
  return {rangeStart: Math.min(u2(p2), u2(f2)), rangeEnd: Math.max(o2(p2), o2(f2))};
}, findNodeAtOffset: nd};
const {printer: {printDocToString: sd}, debug: {printDocToDebug: ad}} = eu$1, {getAlignmentSize: cd} = yi$2, {guessEndOfLine: ld, convertEndOfLineToChars: pd, countEndOfLineChars: fd, normalizeEndOfLine: dd} = Di$2, hd = mp.normalize, gd = Symbol("cursor");
function md(e20, t2, n2) {
  const r2 = t2.comments;
  return r2 && (delete t2.comments, Wf.attach(r2, t2, e20, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t2.tokens || [], n2.originalText = e20, r2;
}
function yd(e20, t2, n2 = 0) {
  if (!e20 || e20.trim().length === 0)
    return {formatted: "", cursorOffset: -1, comments: []};
  const {ast: r2, text: i2} = lp.parse(e20, t2);
  if (t2.cursorOffset >= 0) {
    const e21 = od.findNodeAtOffset(r2, t2.cursorOffset, t2);
    e21 && e21.node && (t2.cursorNode = e21.node);
  }
  const u2 = md(i2, r2, t2), o2 = ed(r2, t2, n2), s2 = sd(o2, t2);
  if (Wf.ensureAllCommentsPrinted(u2), n2 > 0) {
    const e21 = s2.formatted.trim();
    s2.cursorNodeStart !== void 0 && (s2.cursorNodeStart -= s2.formatted.indexOf(e21)), s2.formatted = e21 + pd(t2.endOfLine);
  }
  if (t2.cursorOffset >= 0) {
    let e21, n3, r3, o3, a2;
    if (t2.cursorNode && s2.cursorNodeText ? (e21 = t2.locStart(t2.cursorNode), n3 = i2.slice(e21, t2.locEnd(t2.cursorNode)), r3 = t2.cursorOffset - e21, o3 = s2.cursorNodeStart, a2 = s2.cursorNodeText) : (e21 = 0, n3 = i2, r3 = t2.cursorOffset, o3 = 0, a2 = s2.formatted), n3 === a2)
      return {formatted: s2.formatted, cursorOffset: o3 + r3, comments: u2};
    const c2 = [...n3];
    c2.splice(r3, 0, gd);
    const l2 = [...a2], p2 = mn$2.diffArrays(c2, l2);
    let f2 = o3;
    for (const e22 of p2)
      if (e22.removed) {
        if (e22.value.includes(gd))
          break;
      } else
        f2 += e22.count;
    return {formatted: s2.formatted, cursorOffset: f2, comments: u2};
  }
  return {formatted: s2.formatted, cursorOffset: -1, comments: u2};
}
function Dd(e20, t2, n2) {
  return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e20.length ? n2 : t2;
}
function Ed(e20, t2) {
  let {cursorOffset: n2, rangeStart: r2, rangeEnd: i2} = t2;
  return n2 = Dd(e20, n2, -1), r2 = Dd(e20, r2, 0), i2 = Dd(e20, i2, e20.length), Object.assign(Object.assign({}, t2), {}, {cursorOffset: n2, rangeStart: r2, rangeEnd: i2});
}
function Cd(e20, t2) {
  let {cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2} = Ed(e20, t2);
  const o2 = e20.charAt(0) === "\uFEFF";
  if (o2 && (e20 = e20.slice(1), n2--, r2--, i2--), u2 === "auto" && (u2 = ld(e20)), e20.includes("\r")) {
    const t3 = (t4) => fd(e20.slice(0, Math.max(t4, 0)), "\r\n");
    n2 -= t3(n2), r2 -= t3(r2), i2 -= t3(i2), e20 = dd(e20);
  }
  return {hasBOM: o2, text: e20, options: Ed(e20, Object.assign(Object.assign({}, t2), {}, {cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2}))};
}
function bd(e20, t2) {
  const n2 = lp.resolveParser(t2);
  return !n2.hasPragma || n2.hasPragma(e20);
}
function Ad(e20, t2) {
  let n2, {hasBOM: r2, text: i2, options: u2} = Cd(e20, hd(t2));
  return u2.rangeStart >= u2.rangeEnd && i2 !== "" || u2.requirePragma && !bd(i2, u2) ? {formatted: e20, cursorOffset: t2.cursorOffset, comments: []} : (u2.rangeStart > 0 || u2.rangeEnd < i2.length ? n2 = function(e21, t3) {
    const {ast: n3, text: r3} = lp.parse(e21, t3), {rangeStart: i3, rangeEnd: u3} = od.calculateRange(r3, t3, n3), o2 = r3.slice(i3, u3), s2 = Math.min(i3, r3.lastIndexOf("\n", i3) + 1), a2 = r3.slice(s2, i3).match(/^\s*/)[0], c2 = cd(a2, t3.tabWidth), l2 = yd(o2, Object.assign(Object.assign({}, t3), {}, {rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t3.cursorOffset > i3 && t3.cursorOffset <= u3 ? t3.cursorOffset - i3 : -1, endOfLine: "lf"}), c2), p2 = l2.formatted.trimEnd();
    let {cursorOffset: f2} = t3;
    f2 > u3 ? f2 += p2.length - o2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + i3);
    let d2 = r3.slice(0, i3) + p2 + r3.slice(u3);
    if (t3.endOfLine !== "lf") {
      const e22 = pd(t3.endOfLine);
      f2 >= 0 && e22 === "\r\n" && (f2 += fd(d2.slice(0, f2), "\n")), d2 = d2.replace(/\n/g, e22);
    }
    return {formatted: d2, cursorOffset: f2, comments: l2.comments};
  }(i2, u2) : (!u2.requirePragma && u2.insertPragma && u2.printer.insertPragma && !bd(i2, u2) && (i2 = u2.printer.insertPragma(i2)), n2 = yd(i2, u2)), r2 && (n2.formatted = "\uFEFF" + n2.formatted, n2.cursorOffset >= 0 && n2.cursorOffset++), n2);
}
var vd = {formatWithCursor: Ad, parse(e20, t2, n2) {
  const {text: r2, options: i2} = Cd(e20, hd(t2)), u2 = lp.parse(r2, i2);
  return n2 && (u2.ast = yp(u2.ast, i2)), u2;
}, formatAST(e20, t2) {
  t2 = hd(t2);
  const n2 = ed(e20, t2);
  return sd(n2, t2);
}, formatDoc: (e20, t2) => Ad(ad(e20), Object.assign(Object.assign({}, t2), {}, {parser: "__js_expression"})).formatted, printToDoc(e20, t2) {
  t2 = hd(t2);
  const {ast: n2, text: r2} = lp.parse(e20, t2);
  return md(r2, n2, t2), ed(n2, t2);
}, printDocToString: (e20, t2) => sd(e20, hd(t2))};
const {getMaxContinuousCount: Fd, getStringWidth: Sd, getAlignmentSize: xd, getIndentSize: wd, skip: Td, skipWhitespace: Bd, skipSpaces: Nd, skipNewline: kd, skipToLineEnd: Pd, skipEverythingButNewLine: Od, skipInlineComment: Id, skipTrailingComment: Ld, hasNewline: jd, hasNewlineInRange: _d, hasSpaces: Md, isNextLineEmpty: Rd, isNextLineEmptyAfterIndex: $d, isPreviousLineEmpty: Vd, getNextNonSpaceNonCommentCharacterIndex: Wd, makeString: qd, addLeadingComment: Ud, addDanglingComment: zd, addTrailingComment: Gd} = yi$2;
var Hd = {getMaxContinuousCount: Fd, getStringWidth: Sd, getAlignmentSize: xd, getIndentSize: wd, skip: Td, skipWhitespace: Bd, skipSpaces: Nd, skipNewline: kd, skipToLineEnd: Pd, skipEverythingButNewLine: Od, skipInlineComment: Id, skipTrailingComment: Ld, hasNewline: jd, hasNewlineInRange: _d, hasSpaces: Md, isNextLineEmpty: Rd, isNextLineEmptyAfterIndex: $d, isPreviousLineEmpty: Vd, getNextNonSpaceNonCommentCharacterIndex: Wd, makeString: qd, addLeadingComment: Ud, addDanglingComment: zd, addTrailingComment: Gd};
const Jd = ["languageId"];
var Xd = function(e20, t2) {
  const {languageId: n2} = e20, r2 = jn$2(e20, Jd);
  return Object.assign(Object.assign({linguistLanguageId: n2}, r2), t2(e20));
}, Yd = r$3(function(e20) {
  !function() {
    function t2(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function n2(e21) {
      switch (e21.type) {
        case "IfStatement":
          return e21.alternate != null ? e21.alternate : e21.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return e21.body;
      }
      return null;
    }
    e20.exports = {isExpression: function(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }, isStatement: t2, isIterationStatement: function(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }, isSourceElement: function(e21) {
      return t2(e21) || e21 != null && e21.type === "FunctionDeclaration";
    }, isProblematicIfStatement: function(e21) {
      var t3;
      if (e21.type !== "IfStatement")
        return false;
      if (e21.alternate == null)
        return false;
      t3 = e21.consequent;
      do {
        if (t3.type === "IfStatement" && t3.alternate == null)
          return true;
        t3 = n2(t3);
      } while (t3);
      return false;
    }, trailingStatement: n2};
  }();
}), Kd = r$3(function(e20) {
  !function() {
    var t2, n2, r2, i2, u2, o2;
    function s2(e21) {
      return e21 <= 65535 ? String.fromCharCode(e21) : String.fromCharCode(Math.floor((e21 - 65536) / 1024) + 55296) + String.fromCharCode((e21 - 65536) % 1024 + 56320);
    }
    for (n2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/}, t2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/}, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), o2 = 0; o2 < 128; ++o2)
      i2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 === 36 || o2 === 95;
    for (u2 = new Array(128), o2 = 0; o2 < 128; ++o2)
      u2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 >= 48 && o2 <= 57 || o2 === 36 || o2 === 95;
    e20.exports = {isDecimalDigit: function(e21) {
      return 48 <= e21 && e21 <= 57;
    }, isHexDigit: function(e21) {
      return 48 <= e21 && e21 <= 57 || 97 <= e21 && e21 <= 102 || 65 <= e21 && e21 <= 70;
    }, isOctalDigit: function(e21) {
      return e21 >= 48 && e21 <= 55;
    }, isWhiteSpace: function(e21) {
      return e21 === 32 || e21 === 9 || e21 === 11 || e21 === 12 || e21 === 160 || e21 >= 5760 && r2.indexOf(e21) >= 0;
    }, isLineTerminator: function(e21) {
      return e21 === 10 || e21 === 13 || e21 === 8232 || e21 === 8233;
    }, isIdentifierStartES5: function(e21) {
      return e21 < 128 ? i2[e21] : n2.NonAsciiIdentifierStart.test(s2(e21));
    }, isIdentifierPartES5: function(e21) {
      return e21 < 128 ? u2[e21] : n2.NonAsciiIdentifierPart.test(s2(e21));
    }, isIdentifierStartES6: function(e21) {
      return e21 < 128 ? i2[e21] : t2.NonAsciiIdentifierStart.test(s2(e21));
    }, isIdentifierPartES6: function(e21) {
      return e21 < 128 ? u2[e21] : t2.NonAsciiIdentifierPart.test(s2(e21));
    }};
  }();
}), Qd = r$3(function(e20) {
  !function() {
    var t2 = Kd;
    function n2(e21, t3) {
      return !(!t3 && e21 === "yield") && r2(e21, t3);
    }
    function r2(e21, t3) {
      if (t3 && function(e22) {
        switch (e22) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }(e21))
        return true;
      switch (e21.length) {
        case 2:
          return e21 === "if" || e21 === "in" || e21 === "do";
        case 3:
          return e21 === "var" || e21 === "for" || e21 === "new" || e21 === "try";
        case 4:
          return e21 === "this" || e21 === "else" || e21 === "case" || e21 === "void" || e21 === "with" || e21 === "enum";
        case 5:
          return e21 === "while" || e21 === "break" || e21 === "catch" || e21 === "throw" || e21 === "const" || e21 === "yield" || e21 === "class" || e21 === "super";
        case 6:
          return e21 === "return" || e21 === "typeof" || e21 === "delete" || e21 === "switch" || e21 === "export" || e21 === "import";
        case 7:
          return e21 === "default" || e21 === "finally" || e21 === "extends";
        case 8:
          return e21 === "function" || e21 === "continue" || e21 === "debugger";
        case 10:
          return e21 === "instanceof";
        default:
          return false;
      }
    }
    function i2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || n2(e21, t3);
    }
    function u2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || r2(e21, t3);
    }
    function o2(e21) {
      var n3, r3, i3;
      if (e21.length === 0)
        return false;
      if (i3 = e21.charCodeAt(0), !t2.isIdentifierStartES5(i3))
        return false;
      for (n3 = 1, r3 = e21.length; n3 < r3; ++n3)
        if (i3 = e21.charCodeAt(n3), !t2.isIdentifierPartES5(i3))
          return false;
      return true;
    }
    function s2(e21) {
      var n3, r3, i3, u3, o3;
      if (e21.length === 0)
        return false;
      for (o3 = t2.isIdentifierStartES6, n3 = 0, r3 = e21.length; n3 < r3; ++n3) {
        if (55296 <= (i3 = e21.charCodeAt(n3)) && i3 <= 56319) {
          if (++n3 >= r3)
            return false;
          if (!(56320 <= (u3 = e21.charCodeAt(n3)) && u3 <= 57343))
            return false;
          i3 = 1024 * (i3 - 55296) + (u3 - 56320) + 65536;
        }
        if (!o3(i3))
          return false;
        o3 = t2.isIdentifierPartES6;
      }
      return true;
    }
    e20.exports = {isKeywordES5: n2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: u2, isRestrictedWord: function(e21) {
      return e21 === "eval" || e21 === "arguments";
    }, isIdentifierNameES5: o2, isIdentifierNameES6: s2, isIdentifierES5: function(e21, t3) {
      return o2(e21) && !i2(e21, t3);
    }, isIdentifierES6: function(e21, t3) {
      return s2(e21) && !u2(e21, t3);
    }};
  }();
});
const Zd = r$3(function(e20, t2) {
  t2.ast = Yd, t2.code = Kd, t2.keyword = Qd;
}).keyword.isIdentifierNameES5, {getLast: eh, hasNewline: th, skipWhitespace: nh, isNonEmptyArray: rh, isNextLineEmptyAfterIndex: ih, getStringWidth: uh} = yi$2, {locStart: oh, locEnd: sh, hasSameLocStart: ah} = zc, ch = new RegExp("^(?:(?=.)\\s)*:"), lh = new RegExp("^(?:(?=.)\\s)*::");
function ph(e20) {
  return e20.type === "Block" || e20.type === "CommentBlock" || e20.type === "MultiLine";
}
function fh(e20) {
  return e20.type === "Line" || e20.type === "CommentLine" || e20.type === "SingleLine" || e20.type === "HashbangComment" || e20.type === "HTMLOpen" || e20.type === "HTMLClose";
}
const dh = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
function hh(e20) {
  return e20 && dh.has(e20.type);
}
function gh(e20) {
  return e20.type === "NumericLiteral" || e20.type === "Literal" && typeof e20.value == "number";
}
function mh(e20) {
  return e20.type === "StringLiteral" || e20.type === "Literal" && typeof e20.value == "string";
}
function yh(e20) {
  return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression";
}
function Dh(e20) {
  return Sh(e20) && e20.callee.type === "Identifier" && (e20.callee.name === "async" || e20.callee.name === "inject" || e20.callee.name === "fakeAsync");
}
function Eh(e20) {
  return e20.type === "JSXElement" || e20.type === "JSXFragment";
}
function Ch(e20) {
  return e20.kind === "get" || e20.kind === "set";
}
function bh(e20) {
  return Ch(e20) || ah(e20, e20.value);
}
const Ah = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
const vh = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
const Fh = /^(?:skip|[fx]?(?:it|describe|test))$/;
function Sh(e20) {
  return e20 && (e20.type === "CallExpression" || e20.type === "OptionalCallExpression");
}
function xh(e20) {
  return e20 && (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression");
}
function wh(e20) {
  return /^(?:\d+|\d+\.\d+)$/.test(e20);
}
function Th(e20) {
  return e20.quasis.some((e21) => e21.value.raw.includes("\n"));
}
function Bh(e20) {
  return e20.extra ? e20.extra.raw : e20.raw;
}
const Nh = {"==": true, "!=": true, "===": true, "!==": true}, kh = {"*": true, "/": true, "%": true}, Ph = {">>": true, ">>>": true, "<<": true};
const Oh = {};
for (const [e20, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
  for (const n2 of t2)
    Oh[n2] = e20;
function Ih(e20) {
  return Oh[e20];
}
const Lh = new WeakMap();
function jh(e20) {
  if (Lh.has(e20))
    return Lh.get(e20);
  const t2 = [];
  return e20.this && t2.push(e20.this), Array.isArray(e20.parameters) ? t2.push(...e20.parameters) : Array.isArray(e20.params) && t2.push(...e20.params), e20.rest && t2.push(e20.rest), Lh.set(e20, t2), t2;
}
const _h = new WeakMap();
function Mh(e20) {
  if (_h.has(e20))
    return _h.get(e20);
  let t2 = e20.arguments;
  return e20.type === "ImportExpression" && (t2 = [e20.source], e20.attributes && t2.push(e20.attributes)), _h.set(e20, t2), t2;
}
function Rh(e20) {
  return e20.value.trim() === "prettier-ignore" && !e20.unignore;
}
function $h(e20) {
  return e20 && (e20.prettierIgnore || qh(e20, Vh.PrettierIgnore));
}
const Vh = {Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256}, Wh = (e20, t2) => {
  if (typeof e20 == "function" && (t2 = e20, e20 = 0), e20 || t2)
    return (n2, r2, i2) => !(e20 & Vh.Leading && !n2.leading || e20 & Vh.Trailing && !n2.trailing || e20 & Vh.Dangling && (n2.leading || n2.trailing) || e20 & Vh.Block && !ph(n2) || e20 & Vh.Line && !fh(n2) || e20 & Vh.First && r2 !== 0 || e20 & Vh.Last && r2 !== i2.length - 1 || e20 & Vh.PrettierIgnore && !Rh(n2) || t2 && !t2(n2));
};
function qh(e20, t2, n2) {
  if (!e20 || !rh(e20.comments))
    return false;
  const r2 = Wh(t2, n2);
  return !r2 || e20.comments.some(r2);
}
function Uh(e20, t2, n2) {
  if (!e20 || !Array.isArray(e20.comments))
    return [];
  const r2 = Wh(t2, n2);
  return r2 ? e20.comments.filter(r2) : e20.comments;
}
function zh(e20) {
  return Sh(e20) || e20.type === "NewExpression" || e20.type === "ImportExpression";
}
var Gh = {getFunctionParameters: jh, iterateFunctionParametersPath: function(e20, t2) {
  const n2 = e20.getValue();
  let r2 = 0;
  const i2 = (e21) => t2(e21, r2++);
  n2.this && e20.call(i2, "this"), Array.isArray(n2.parameters) ? e20.each(i2, "parameters") : Array.isArray(n2.params) && e20.each(i2, "params"), n2.rest && e20.call(i2, "rest");
}, getCallArguments: Mh, iterateCallArgumentsPath: function(e20, t2) {
  const n2 = e20.getValue();
  n2.type === "ImportExpression" ? (e20.call((e21) => t2(e21, 0), "source"), n2.attributes && e20.call((e21) => t2(e21, 1), "attributes")) : e20.each(t2, "arguments");
}, hasRestParameter: function(e20) {
  if (e20.rest)
    return true;
  const t2 = jh(e20);
  return t2.length > 0 && eh(t2).type === "RestElement";
}, getLeftSide: function(e20) {
  return e20.expressions ? e20.expressions[0] : e20.left || e20.test || e20.callee || e20.object || e20.tag || e20.argument || e20.expression;
}, getLeftSidePathName: function(e20, t2) {
  if (t2.expressions)
    return ["expressions", 0];
  if (t2.left)
    return ["left"];
  if (t2.test)
    return ["test"];
  if (t2.object)
    return ["object"];
  if (t2.callee)
    return ["callee"];
  if (t2.tag)
    return ["tag"];
  if (t2.argument)
    return ["argument"];
  if (t2.expression)
    return ["expression"];
  throw new Error("Unexpected node has no left side.");
}, getParentExportDeclaration: function(e20) {
  const t2 = e20.getParentNode();
  return e20.getName() === "declaration" && hh(t2) ? t2 : null;
}, getTypeScriptMappedTypeModifier: function(e20, t2) {
  return e20 === "+" ? "+" + t2 : e20 === "-" ? "-" + t2 : t2;
}, hasFlowAnnotationComment: function(e20) {
  return rh(e20) && ph(e20[0]) && lh.test(e20[0].value);
}, hasFlowShorthandAnnotationComment: function(e20) {
  return e20.extra && e20.extra.parenthesized && rh(e20.trailingComments) && ph(e20.trailingComments[0]) && ch.test(e20.trailingComments[0].value);
}, hasLeadingOwnLineComment: function(e20, t2) {
  return Eh(t2) ? $h(t2) : qh(t2, Vh.Leading, (t3) => th(e20, sh(t3)));
}, hasNakedLeftSide: function(e20) {
  return e20.type === "AssignmentExpression" || e20.type === "BinaryExpression" || e20.type === "LogicalExpression" || e20.type === "NGPipeExpression" || e20.type === "ConditionalExpression" || Sh(e20) || xh(e20) || e20.type === "SequenceExpression" || e20.type === "TaggedTemplateExpression" || e20.type === "BindExpression" || e20.type === "UpdateExpression" && !e20.prefix || e20.type === "TSAsExpression" || e20.type === "TSNonNullExpression";
}, hasNode: function e2(t2, n2) {
  if (!t2 || typeof t2 != "object")
    return false;
  if (Array.isArray(t2))
    return t2.some((t3) => e2(t3, n2));
  const r2 = n2(t2);
  return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e2(t3, n2));
}, hasIgnoreComment: function(e20) {
  return $h(e20.getValue());
}, hasNodeIgnoreComment: $h, identity: function(e20) {
  return e20;
}, isBinaryish: function(e20) {
  return Ah.has(e20.type);
}, isBlockComment: ph, isCallLikeExpression: zh, isLineComment: fh, isPrettierIgnoreComment: Rh, isCallExpression: Sh, isMemberExpression: xh, isExportDeclaration: hh, isFlowAnnotationComment: function(e20, t2) {
  const n2 = oh(t2), r2 = nh(e20, sh(t2));
  return r2 !== false && e20.slice(n2, n2 + 2) === "/*" && e20.slice(r2, r2 + 2) === "*/";
}, isFunctionCompositionArgs: function(e20) {
  if (e20.length <= 1)
    return false;
  let t2 = 0;
  for (const n2 of e20)
    if (yh(n2)) {
      if (t2 += 1, t2 > 1)
        return true;
    } else if (Sh(n2)) {
      for (const e21 of n2.arguments)
        if (yh(e21))
          return true;
    }
  return false;
}, isFunctionNotation: bh, isFunctionOrArrowExpression: yh, isGetterOrSetter: Ch, isJestEachTemplateLiteral: function(e20, t2) {
  const n2 = /^[fx]?(?:describe|it|test)$/;
  return t2.type === "TaggedTemplateExpression" && t2.quasi === e20 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && n2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && n2.test(t2.tag.object.object.name));
}, isJsxNode: Eh, isLiteral: function(e20) {
  return e20.type === "BooleanLiteral" || e20.type === "DirectiveLiteral" || e20.type === "Literal" || e20.type === "NullLiteral" || e20.type === "NumericLiteral" || e20.type === "BigIntLiteral" || e20.type === "DecimalLiteral" || e20.type === "RegExpLiteral" || e20.type === "StringLiteral" || e20.type === "TemplateLiteral" || e20.type === "TSTypeLiteral" || e20.type === "JSXText";
}, isLongCurriedCallExpression: function(e20) {
  const t2 = e20.getValue(), n2 = e20.getParentNode();
  return Sh(t2) && Sh(n2) && n2.callee === t2 && t2.arguments.length > n2.arguments.length && n2.arguments.length > 0;
}, isSimpleCallArgument: function e3(t2, n2) {
  if (n2 >= 2)
    return false;
  const r2 = (t3) => e3(t3, n2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
  return !(i2 && uh(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e20) => !e20.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e20) => !e20.computed && (e20.shorthand || e20.value && r2(e20.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e20) => e20 === null || r2(e20)) : zh(t2) ? (t2.type === "ImportExpression" || e3(t2.callee, n2)) && Mh(t2).every(r2) : xh(t2) ? e3(t2.object, n2) && e3(t2.property, n2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e3(t2.expression, n2) : e3(t2.argument, n2)));
}, isMemberish: function(e20) {
  return xh(e20) || e20.type === "BindExpression" && Boolean(e20.object);
}, isNumericLiteral: gh, isSignedNumericLiteral: function(e20) {
  return e20.type === "UnaryExpression" && (e20.operator === "+" || e20.operator === "-") && gh(e20.argument);
}, isObjectProperty: function(e20) {
  return e20 && (e20.type === "ObjectProperty" || e20.type === "Property" && !e20.method && e20.kind === "init");
}, isObjectType: function(e20) {
  return e20.type === "ObjectTypeAnnotation" || e20.type === "TSTypeLiteral" || e20.type === "TSMappedType";
}, isObjectTypePropertyAFunction: function(e20) {
  return !(e20.type !== "ObjectTypeProperty" && e20.type !== "ObjectTypeInternalSlot" || e20.value.type !== "FunctionTypeAnnotation" || e20.static || bh(e20));
}, isSimpleType: function(e20) {
  return !!e20 && (!(e20.type !== "GenericTypeAnnotation" && e20.type !== "TSTypeReference" || e20.typeParameters) || !!vh.has(e20.type));
}, isSimpleNumber: wh, isSimpleTemplateLiteral: function(e20) {
  let t2 = "expressions";
  e20.type === "TSTemplateLiteralType" && (t2 = "types");
  const n2 = e20[t2];
  return n2.length !== 0 && n2.every((e21) => {
    if (qh(e21))
      return false;
    if (e21.type === "Identifier" || e21.type === "ThisExpression")
      return true;
    if (xh(e21)) {
      let t3 = e21;
      for (; xh(t3); ) {
        if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
          return false;
        if (t3 = t3.object, qh(t3))
          return false;
      }
      return t3.type === "Identifier" || t3.type === "ThisExpression";
    }
    return false;
  });
}, isStringLiteral: mh, isStringPropSafeToUnquote: function(e20, t2) {
  return t2.parser !== "json" && mh(e20.key) && Bh(e20.key).slice(1, -1) === e20.key.value && (Zd(e20.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e20.type === "ClassProperty") || wh(e20.key.value) && String(Number(e20.key.value)) === e20.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
}, isTemplateOnItsOwnLine: function(e20, t2) {
  return (e20.type === "TemplateLiteral" && Th(e20) || e20.type === "TaggedTemplateExpression" && Th(e20.quasi)) && !th(t2, oh(e20), {backwards: true});
}, isTestCall: function e4(t2, n2) {
  if (t2.type !== "CallExpression")
    return false;
  if (t2.arguments.length === 1) {
    if (Dh(t2) && n2 && e4(n2))
      return yh(t2.arguments[0]);
    if (function(e20) {
      return e20.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e20.callee.name) && e20.arguments.length === 1;
    }(t2))
      return Dh(t2.arguments[0]);
  } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Fh.test(t2.callee.name) || function(e20) {
    return xh(e20.callee) && e20.callee.object.type === "Identifier" && e20.callee.property.type === "Identifier" && Fh.test(e20.callee.object.name) && (e20.callee.property.name === "only" || e20.callee.property.name === "skip");
  }(t2)) && (function(e20) {
    return e20.type === "TemplateLiteral";
  }(t2.arguments[0]) || mh(t2.arguments[0])))
    return !(t2.arguments[2] && !gh(t2.arguments[2])) && ((t2.arguments.length === 2 ? yh(t2.arguments[1]) : function(e20) {
      return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && e20.body.type === "BlockStatement";
    }(t2.arguments[1]) && jh(t2.arguments[1]).length <= 1) || Dh(t2.arguments[1]));
  return false;
}, isTheOnlyJsxElementInMarkdown: function(e20, t2) {
  if (e20.parentParser !== "markdown" && e20.parentParser !== "mdx")
    return false;
  const n2 = t2.getNode();
  if (!n2.expression || !Eh(n2.expression))
    return false;
  const r2 = t2.getParentNode();
  return r2.type === "Program" && r2.body.length === 1;
}, isTSXFile: function(e20) {
  return e20.filepath && /\.tsx$/i.test(e20.filepath);
}, isTypeAnnotationAFunction: function(e20) {
  return !(e20.type !== "TypeAnnotation" && e20.type !== "TSTypeAnnotation" || e20.typeAnnotation.type !== "FunctionTypeAnnotation" || e20.static || ah(e20, e20.typeAnnotation));
}, isNextLineEmpty: (e20, {originalText: t2}) => ih(t2, sh(e20)), needsHardlineAfterDanglingComment: function(e20) {
  if (!qh(e20))
    return false;
  const t2 = eh(Uh(e20, Vh.Dangling));
  return t2 && !ph(t2);
}, rawText: Bh, shouldPrintComma: function(e20, t2 = "es5") {
  return e20.trailingComma === "es5" && t2 === "es5" || e20.trailingComma === "all" && (t2 === "all" || t2 === "es5");
}, isBitwiseOperator: function(e20) {
  return Boolean(Ph[e20]) || e20 === "|" || e20 === "^" || e20 === "&";
}, shouldFlatten: function(e20, t2) {
  return Ih(t2) === Ih(e20) && (e20 !== "**" && ((!Nh[e20] || !Nh[t2]) && (!(t2 === "%" && kh[e20] || e20 === "%" && kh[t2]) && ((t2 === e20 || !kh[t2] || !kh[e20]) && (!Ph[e20] || !Ph[t2])))));
}, startsWithNoLookaheadToken: function e5(t2, n2) {
  switch ((t2 = function(e20) {
    for (; e20.left; )
      e20 = e20.left;
    return e20;
  }(t2)).type) {
    case "FunctionExpression":
    case "ClassExpression":
    case "DoExpression":
      return n2;
    case "ObjectExpression":
      return true;
    case "MemberExpression":
    case "OptionalMemberExpression":
      return e5(t2.object, n2);
    case "TaggedTemplateExpression":
      return t2.tag.type !== "FunctionExpression" && e5(t2.tag, n2);
    case "CallExpression":
    case "OptionalCallExpression":
      return t2.callee.type !== "FunctionExpression" && e5(t2.callee, n2);
    case "ConditionalExpression":
      return e5(t2.test, n2);
    case "UpdateExpression":
      return !t2.prefix && e5(t2.argument, n2);
    case "BindExpression":
      return t2.object && e5(t2.object, n2);
    case "SequenceExpression":
      return e5(t2.expressions[0], n2);
    case "TSAsExpression":
    case "TSNonNullExpression":
      return e5(t2.expression, n2);
    default:
      return false;
  }
}, getPrecedence: Ih, hasComment: qh, getComments: Uh, CommentCheckFlags: Vh};
const {getStringWidth: Hh, getIndentSize: Jh} = yi$2, {builders: {join: Xh, hardline: Yh, softline: Kh, group: Qh, indent: Zh, align: eg, lineSuffixBoundary: tg, addAlignmentToDoc: ng}, printer: {printDocToString: rg}, utils: {mapDoc: ig}} = eu$1, {isBinaryish: ug, isJestEachTemplateLiteral: og, isSimpleTemplateLiteral: sg, hasComment: ag, isMemberExpression: cg} = Gh;
function lg(e20) {
  return e20.replace(/([\\`]|\${)/g, "\\$1");
}
var pg = {printTemplateLiteral: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (r2.type === "TemplateLiteral" && og(r2, e20.getParentNode())) {
    const r3 = function(e21, t3, n3) {
      const r4 = e21.getNode(), i3 = r4.quasis[0].value.raw.trim().split(/\s*\|\s*/);
      if (i3.length > 1 || i3.some((e22) => e22.length > 0)) {
        t3.__inJestEach = true;
        const u3 = e21.map(n3, "expressions");
        t3.__inJestEach = false;
        const o3 = [], s3 = u3.map((e22) => "${" + rg(e22, Object.assign(Object.assign({}, t3), {}, {printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf"})).formatted + "}"), a2 = [{hasLineBreak: false, cells: []}];
        for (let e22 = 1; e22 < r4.quasis.length; e22++) {
          const t4 = Ln$2(a2), n4 = s3[e22 - 1];
          t4.cells.push(n4), n4.includes("\n") && (t4.hasLineBreak = true), r4.quasis[e22].value.raw.includes("\n") && a2.push({hasLineBreak: false, cells: []});
        }
        const c2 = Math.max(i3.length, ...a2.map((e22) => e22.cells.length)), l2 = Array.from({length: c2}).fill(0), p2 = [{cells: i3}, ...a2.filter((e22) => e22.cells.length > 0)];
        for (const {cells: e22} of p2.filter((e23) => !e23.hasLineBreak))
          for (const [t4, n4] of e22.entries())
            l2[t4] = Math.max(l2[t4], Hh(n4));
        return o3.push(tg, "`", Zh([Yh, Xh(Yh, p2.map((e22) => Xh(" | ", e22.cells.map((t4, n4) => e22.hasLineBreak ? t4 : t4 + " ".repeat(l2[n4] - Hh(t4))))))]), Yh, "`"), o3;
      }
    }(e20, n2, t2);
    if (r3)
      return r3;
  }
  let i2 = "expressions";
  r2.type === "TSTemplateLiteralType" && (i2 = "types");
  const u2 = [];
  let o2 = e20.map(t2, i2);
  const s2 = sg(r2);
  return s2 && (o2 = o2.map((e21) => rg(e21, Object.assign(Object.assign({}, n2), {}, {printWidth: Number.POSITIVE_INFINITY})).formatted)), u2.push(tg, "`"), e20.each((e21) => {
    const a2 = e21.getName();
    if (u2.push(t2()), a2 < o2.length) {
      const {tabWidth: t3} = n2, c2 = e21.getValue(), l2 = Jh(c2.value.raw, t3);
      let p2 = o2[a2];
      if (!s2) {
        const e22 = r2[i2][a2];
        (ag(e22) || cg(e22) || e22.type === "ConditionalExpression" || e22.type === "SequenceExpression" || e22.type === "TSAsExpression" || ug(e22)) && (p2 = [Zh([Kh, p2]), Kh]);
      }
      const f2 = l2 === 0 && c2.value.raw.endsWith("\n") ? eg(Number.NEGATIVE_INFINITY, p2) : ng(p2, l2, t3);
      u2.push(Qh(["${", f2, tg, "}"]));
    }
  }, "quasis"), u2.push("`"), u2;
}, printTemplateExpressions: function(e20, t2) {
  return e20.map((e21) => function(e22, t3) {
    const n2 = e22.getValue();
    let r2 = t3();
    return ag(n2) && (r2 = Qh([Zh([Kh, r2]), Kh])), ["${", r2, tg, "}"];
  }(e21, t2), "expressions");
}, escapeTemplateCharacters: function(e20, t2) {
  return ig(e20, (e21) => typeof e21 == "string" ? t2 ? e21.replace(/(\\*)`/g, "$1$1\\`") : lg(e21) : e21);
}, uncookTemplateElementValue: lg};
const {builders: {indent: fg, softline: dg, literalline: hg, dedentToRoot: gg}} = eu$1, {escapeTemplateCharacters: mg} = pg;
var yg = function(e20, t2, n2) {
  let r2 = e20.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e21, t3) => "\\".repeat(t3.length / 2) + "`");
  const i2 = function(e21) {
    const t3 = e21.match(/^([^\S\n]*)\S/m);
    return t3 === null ? "" : t3[1];
  }(r2), u2 = i2 !== "";
  u2 && (r2 = r2.replace(new RegExp(`^${i2}`, "gm"), ""));
  const o2 = mg(n2(r2, {parser: "markdown", __inJsTemplate: true}, {stripTrailingHardline: true}), true);
  return ["`", u2 ? fg([dg, o2]) : [hg, gg(o2)], dg, "`"];
};
const {isNonEmptyArray: Dg} = yi$2, {builders: {indent: Eg, hardline: Cg, softline: bg}, utils: {mapDoc: Ag, replaceEndOfLine: vg, cleanDoc: Fg}} = eu$1, {printTemplateExpressions: Sg} = pg;
var xg = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.quasis.map((e21) => e21.value.raw);
  let u2 = 0;
  return function(e21, t3, n3) {
    if (t3.quasis.length === 1 && !t3.quasis[0].value.raw.trim())
      return "``";
    const r3 = function(e22, t4) {
      if (!Dg(t4))
        return e22;
      let n4 = 0;
      const r4 = Ag(Fg(e22), (e23) => typeof e23 == "string" && e23.includes("@prettier-placeholder") ? e23.split(/@prettier-placeholder-(\d+)-id/).map((e24, r5) => r5 % 2 == 0 ? vg(e24) : (n4++, t4[e24])) : e23);
      return t4.length === n4 ? r4 : null;
    }(e21, n3);
    if (!r3)
      throw new Error("Couldn't insert all the expressions");
    return ["`", Eg([Cg, r3]), bg, "`"];
  }(n2(i2.reduce((e21, t3, n3) => n3 === 0 ? t3 : e21 + "@prettier-placeholder-" + u2++ + "-id" + t3, ""), {parser: "scss"}, {stripTrailingHardline: true}), r2, Sg(e20, t2));
};
const {builders: {indent: wg, join: Tg, hardline: Bg}} = eu$1, {escapeTemplateCharacters: Ng, printTemplateExpressions: kg} = pg;
function Pg(e20) {
  const t2 = [];
  let n2 = false;
  const r2 = e20.map((e21) => e21.trim());
  for (const [e21, i2] of r2.entries())
    i2 !== "" && (r2[e21 - 1] === "" && n2 ? t2.push([Bg, i2]) : t2.push(i2), n2 = true);
  return t2.length === 0 ? null : Tg(Bg, t2);
}
var Og = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.quasis.length;
  if (i2 === 1 && r2.quasis[0].value.raw.trim() === "")
    return "``";
  const u2 = kg(e20, t2), o2 = [];
  for (let e21 = 0; e21 < i2; e21++) {
    const t3 = e21 === 0, s2 = e21 === i2 - 1, a2 = r2.quasis[e21].value.cooked, c2 = a2.split("\n"), l2 = c2.length, p2 = u2[e21], f2 = l2 > 2 && c2[0].trim() === "" && c2[1].trim() === "", d2 = l2 > 2 && c2[l2 - 1].trim() === "" && c2[l2 - 2].trim() === "", h2 = c2.every((e22) => /^\s*(?:#[^\n\r]*)?$/.test(e22));
    if (!s2 && /#[^\n\r]*$/.test(c2[l2 - 1]))
      return null;
    let g2 = null;
    g2 = h2 ? Pg(c2) : n2(a2, {parser: "graphql"}, {stripTrailingHardline: true}), g2 ? (g2 = Ng(g2, false), !t3 && f2 && o2.push(""), o2.push(g2), !s2 && d2 && o2.push("")) : t3 || s2 || !f2 || o2.push(""), p2 && o2.push(p2);
  }
  return ["`", wg([Bg, Tg(Bg, o2)]), Bg, "`"];
};
const {builders: {indent: Ig, line: Lg, hardline: jg, group: _g}, utils: {mapDoc: Mg}} = eu$1, {printTemplateExpressions: Rg, uncookTemplateElementValue: $g} = pg;
let Vg = 0;
var Wg = function(e20, t2, n2, r2, {parser: i2}) {
  const u2 = e20.getValue(), o2 = Vg;
  Vg = Vg + 1 >>> 0;
  const s2 = (e21) => `PRETTIER_HTML_PLACEHOLDER_${e21}_${o2}_IN_JS`, a2 = u2.quasis.map((e21, t3, n3) => t3 === n3.length - 1 ? e21.value.cooked : e21.value.cooked + s2(t3)).join(""), c2 = Rg(e20, t2);
  if (c2.length === 0 && a2.trim().length === 0)
    return "``";
  const l2 = new RegExp(s2("(\\d+)"), "g");
  let p2 = 0;
  const f2 = n2(a2, {parser: i2, __onHtmlRoot(e21) {
    p2 = e21.children.length;
  }}, {stripTrailingHardline: true}), d2 = Mg(f2, (e21) => {
    if (typeof e21 != "string")
      return e21;
    const t3 = [], n3 = e21.split(l2);
    for (let e22 = 0; e22 < n3.length; e22++) {
      let i3 = n3[e22];
      if (e22 % 2 == 0) {
        i3 && (i3 = $g(i3), r2.__embeddedInHtml && (i3 = i3.replace(/<\/(script)\b/gi, "<\\/$1")), t3.push(i3));
        continue;
      }
      const u3 = Number(i3);
      t3.push(c2[u3]);
    }
    return t3;
  }), h2 = /^\s/.test(a2) ? " " : "", g2 = /\s$/.test(a2) ? " " : "", m2 = r2.htmlWhitespaceSensitivity === "ignore" ? jg : h2 && g2 ? Lg : null;
  return _g(m2 ? ["`", Ig([m2, _g(d2)]), m2, "`"] : ["`", h2, p2 > 1 ? Ig(_g(d2)) : _g(d2), g2, "`"]);
};
const {hasComment: qg, CommentCheckFlags: Ug, isObjectProperty: zg} = Gh;
function Gg(e20) {
  return function(e21) {
    const t2 = e21.getValue(), n2 = e21.getParentNode(), r2 = e21.getParentNode(1);
    return r2 && t2.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e22) => e22.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
  }(e20) || function(e21) {
    const t2 = e21.getParentNode();
    if (!t2 || t2.type !== "TaggedTemplateExpression")
      return false;
    const n2 = t2.tag.type === "ParenthesizedExpression" ? t2.tag.expression : t2.tag;
    switch (n2.type) {
      case "MemberExpression":
        return Jg(n2.object) || Xg(n2);
      case "CallExpression":
        return Jg(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (Jg(n2.callee.object.object) || Xg(n2.callee.object)) || n2.callee.object.type === "CallExpression" && Jg(n2.callee.object.callee));
      case "Identifier":
        return n2.name === "css";
      default:
        return false;
    }
  }(e20) || function(e21) {
    const t2 = e21.getParentNode(), n2 = e21.getParentNode(1);
    return n2 && t2.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
  }(e20) || function(e21) {
    return e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => e22.type === "ArrayExpression" && t2 === "elements", (e22, t2) => zg(e22) && e22.key.type === "Identifier" && e22.key.name === "styles" && t2 === "value", ...Hg);
  }(e20) ? "css" : function(e21) {
    const t2 = e21.getValue(), n2 = e21.getParentNode();
    return Yg(t2, "GraphQL") || n2 && (n2.type === "TaggedTemplateExpression" && (n2.tag.type === "MemberExpression" && n2.tag.object.name === "graphql" && n2.tag.property.name === "experimental" || n2.tag.type === "Identifier" && (n2.tag.name === "gql" || n2.tag.name === "graphql")) || n2.type === "CallExpression" && n2.callee.type === "Identifier" && n2.callee.name === "graphql");
  }(e20) ? "graphql" : function(e21) {
    return Yg(e21.getValue(), "HTML") || e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => e22.type === "TaggedTemplateExpression" && e22.tag.type === "Identifier" && e22.tag.name === "html" && t2 === "quasi");
  }(e20) ? "html" : function(e21) {
    return e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => zg(e22) && e22.key.type === "Identifier" && e22.key.name === "template" && t2 === "value", ...Hg);
  }(e20) ? "angular" : function(e21) {
    const t2 = e21.getValue(), n2 = e21.getParentNode();
    return n2 && n2.type === "TaggedTemplateExpression" && t2.quasis.length === 1 && n2.tag.type === "Identifier" && (n2.tag.name === "md" || n2.tag.name === "markdown");
  }(e20) ? "markdown" : void 0;
}
const Hg = [(e20, t2) => e20.type === "ObjectExpression" && t2 === "properties", (e20, t2) => e20.type === "CallExpression" && e20.callee.type === "Identifier" && e20.callee.name === "Component" && t2 === "arguments", (e20, t2) => e20.type === "Decorator" && t2 === "expression"];
function Jg(e20) {
  return e20.type === "Identifier" && e20.name === "styled";
}
function Xg(e20) {
  return /^[A-Z]/.test(e20.object.name) && e20.property.name === "extend";
}
function Yg(e20, t2) {
  return qg(e20, Ug.Block | Ug.Leading, ({value: e21}) => e21 === ` ${t2} `);
}
var Kg = function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  if (i2.type !== "TemplateLiteral" || function({quasis: e21}) {
    return e21.some(({value: {cooked: e22}}) => e22 === null);
  }(i2))
    return;
  const u2 = Gg(e20);
  return u2 ? u2 === "markdown" ? yg(e20, t2, n2) : u2 === "css" ? xg(e20, t2, n2) : u2 === "graphql" ? Og(e20, t2, n2) : u2 === "html" || u2 === "angular" ? Wg(e20, t2, n2, r2, {parser: u2}) : void 0 : void 0;
};
const {isBlockComment: Qg} = Gh, Zg = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), em = (e20) => {
  for (const t2 of e20.quasis)
    delete t2.value;
};
function tm(e20, t2, n2) {
  if (e20.type === "Program" && delete t2.sourceType, e20.type !== "BigIntLiteral" && e20.type !== "BigIntLiteralTypeAnnotation" || t2.value && (t2.value = t2.value.toLowerCase()), e20.type !== "BigIntLiteral" && e20.type !== "Literal" || t2.bigint && (t2.bigint = t2.bigint.toLowerCase()), e20.type === "DecimalLiteral" && (t2.value = Number(t2.value)), e20.type === "Literal" && t2.decimal && (t2.decimal = Number(t2.decimal)), e20.type === "EmptyStatement")
    return null;
  if (e20.type === "JSXText")
    return null;
  if (e20.type === "JSXExpressionContainer" && (e20.expression.type === "Literal" || e20.expression.type === "StringLiteral") && e20.expression.value === " ")
    return null;
  if (e20.type !== "Property" && e20.type !== "ObjectProperty" && e20.type !== "MethodDefinition" && e20.type !== "ClassProperty" && e20.type !== "ClassMethod" && e20.type !== "PropertyDefinition" && e20.type !== "TSDeclareMethod" && e20.type !== "TSPropertySignature" && e20.type !== "ObjectTypeProperty" || typeof e20.key != "object" || !e20.key || e20.key.type !== "Literal" && e20.key.type !== "NumericLiteral" && e20.key.type !== "StringLiteral" && e20.key.type !== "Identifier" || delete t2.key, e20.type === "JSXElement" && e20.openingElement.name.name === "style" && e20.openingElement.attributes.some((e21) => e21.name.name === "jsx"))
    for (const {type: e21, expression: n3} of t2.children)
      e21 === "JSXExpressionContainer" && n3.type === "TemplateLiteral" && em(n3);
  e20.type === "JSXAttribute" && e20.name.name === "css" && e20.value.type === "JSXExpressionContainer" && e20.value.expression.type === "TemplateLiteral" && em(t2.value.expression), e20.type === "JSXAttribute" && e20.value && e20.value.type === "Literal" && /["']|&quot;|&apos;/.test(e20.value.value) && (t2.value.value = t2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
  const r2 = e20.expression || e20.callee;
  if (e20.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
    const n3 = e20.expression.arguments[0].properties;
    for (const [e21, r3] of t2.expression.arguments[0].properties.entries())
      switch (n3[e21].key.name) {
        case "styles":
          r3.value.type === "ArrayExpression" && em(r3.value.elements[0]);
          break;
        case "template":
          r3.value.type === "TemplateLiteral" && em(r3.value);
      }
  }
  if (e20.type !== "TaggedTemplateExpression" || e20.tag.type !== "MemberExpression" && (e20.tag.type !== "Identifier" || e20.tag.name !== "gql" && e20.tag.name !== "graphql" && e20.tag.name !== "css" && e20.tag.name !== "md" && e20.tag.name !== "markdown" && e20.tag.name !== "html") && e20.tag.type !== "CallExpression" || em(t2.quasi), e20.type === "TemplateLiteral") {
    (e20.leadingComments && e20.leadingComments.some((e21) => Qg(e21) && ["GraphQL", "HTML"].some((t3) => e21.value === ` ${t3} `)) || n2.type === "CallExpression" && n2.callee.name === "graphql" || !e20.leadingComments) && em(t2);
  }
  return e20.type === "InterpreterDirective" && (t2.value = t2.value.trimEnd()), e20.type !== "TSIntersectionType" && e20.type !== "TSUnionType" || e20.types.length !== 1 ? void 0 : t2.types[0];
}
tm.ignoredProperties = Zg;
var nm = tm;
const rm = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  const t2 = e20.match(/(?:\r?\n)/g) || [];
  if (t2.length === 0)
    return;
  const n2 = t2.filter((e21) => e21 === "\r\n").length;
  return n2 > t2.length - n2 ? "\r\n" : "\n";
};
var im = rm;
im.graceful = (e20) => typeof e20 == "string" && rm(e20) || "\n";
var um = function(e20) {
  const t2 = e20.match(hm);
  return t2 ? t2[0].trimLeft() : "";
}, om = function(e20) {
  const t2 = e20.match(hm);
  return t2 && t2[0] ? e20.substring(t2[0].length) : e20;
}, sm = function(e20) {
  return bm(e20).pragmas;
}, am = bm, cm = function({comments: e20 = "", pragmas: t2 = {}}) {
  const n2 = (0, pm().default)(e20) || lm().EOL, r2 = " *", i2 = Object.keys(t2), u2 = i2.map((e21) => Am(e21, t2[e21])).reduce((e21, t3) => e21.concat(t3), []).map((e21) => " * " + e21 + n2).join("");
  if (!e20) {
    if (i2.length === 0)
      return "";
    if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
      const e21 = t2[i2[0]];
      return `/** ${Am(i2[0], e21)[0]} */`;
    }
  }
  const o2 = e20.split(n2).map((e21) => ` * ${e21}`).join(n2) + n2;
  return "/**" + n2 + (e20 ? o2 : "") + (e20 && i2.length ? r2 + n2 : "") + u2 + " */";
};
function lm() {
  const e20 = is$2;
  return lm = function() {
    return e20;
  }, e20;
}
function pm() {
  const e20 = function(e21) {
    return e21 && e21.__esModule ? e21 : {default: e21};
  }(im);
  return pm = function() {
    return e20;
  }, e20;
}
const fm = /\*\/$/, dm = /^\/\*\*/, hm = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, gm = /(^|\s+)\/\/([^\r\n]*)/g, mm = /^(\r?\n)+/, ym = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Dm = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Em = /(\r?\n|^) *\* ?/g, Cm = [];
function bm(e20) {
  const t2 = (0, pm().default)(e20) || lm().EOL;
  e20 = e20.replace(dm, "").replace(fm, "").replace(Em, "$1");
  let n2 = "";
  for (; n2 !== e20; )
    n2 = e20, e20 = e20.replace(ym, `${t2}$1 $2${t2}`);
  e20 = e20.replace(mm, "").trimRight();
  const r2 = Object.create(null), i2 = e20.replace(Dm, "").replace(mm, "").trimRight();
  let u2;
  for (; u2 = Dm.exec(e20); ) {
    const e21 = u2[2].replace(gm, "");
    typeof r2[u2[1]] == "string" || Array.isArray(r2[u2[1]]) ? r2[u2[1]] = Cm.concat(r2[u2[1]], e21) : r2[u2[1]] = e21;
  }
  return {comments: i2, pragmas: r2};
}
function Am(e20, t2) {
  return Cm.concat(t2).map((t3) => `@${e20} ${t3}`.trim());
}
var vm = Object.defineProperty({extract: um, strip: om, parse: sm, parseWithComments: am, print: cm}, "__esModule", {value: true});
const {parseWithComments: Fm, strip: Sm, extract: xm, print: wm} = vm, {getShebang: Tm} = yi$2, {normalizeEndOfLine: Bm} = Di$2;
function Nm(e20) {
  const t2 = Tm(e20);
  t2 && (e20 = e20.slice(t2.length + 1));
  const n2 = xm(e20), {pragmas: r2, comments: i2} = Fm(n2);
  return {shebang: t2, text: e20, pragmas: r2, comments: i2};
}
var km = {hasPragma: function(e20) {
  const t2 = Object.keys(Nm(e20).pragmas);
  return t2.includes("prettier") || t2.includes("format");
}, insertPragma: function(e20) {
  const {shebang: t2, text: n2, pragmas: r2, comments: i2} = Nm(e20), u2 = Sm(n2), o2 = wm({pragmas: Object.assign({format: ""}, r2), comments: i2.trimStart()});
  return (t2 ? `${t2}
` : "") + Bm(o2) + (u2.startsWith("\n") ? "\n" : "\n\n") + u2;
}};
const {getLast: Pm, hasNewline: Om, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Im, getNextNonSpaceNonCommentCharacter: Lm, hasNewlineInRange: jm, addLeadingComment: _m, addTrailingComment: Mm, addDanglingComment: Rm, getNextNonSpaceNonCommentCharacterIndex: $m, isNonEmptyArray: Vm} = yi$2, {isBlockComment: Wm, getFunctionParameters: qm, isPrettierIgnoreComment: Um, isJsxNode: zm, hasFlowShorthandAnnotationComment: Gm, hasFlowAnnotationComment: Hm, hasIgnoreComment: Jm, isCallLikeExpression: Xm, getCallArguments: Ym, isCallExpression: Km, isMemberExpression: Qm, isObjectProperty: Zm, getComments: ey, CommentCheckFlags: ty} = Gh, {locStart: ny, locEnd: ry} = zc;
function iy(e20, t2) {
  const n2 = (e20.body || e20.properties).find(({type: e21}) => e21 !== "EmptyStatement");
  n2 ? _m(n2, t2) : Rm(e20, t2);
}
function uy(e20, t2) {
  e20.type === "BlockStatement" ? iy(e20, t2) : _m(e20, t2);
}
function oy({comment: e20, followingNode: t2}) {
  return !(!t2 || !Ly(e20)) && (_m(t2, e20), true);
}
function sy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
  if (!n2 || n2.type !== "IfStatement" || !r2)
    return false;
  return Lm(i2, e20, ry) === ")" ? (Mm(t2, e20), true) : t2 === n2.consequent && r2 === n2.alternate ? (t2.type === "BlockStatement" ? Mm(t2, e20) : Rm(n2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : r2.type === "IfStatement" ? (uy(r2.consequent, e20), true) : n2.consequent === r2 && (_m(r2, e20), true);
}
function ay({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
  if (!n2 || n2.type !== "WhileStatement" || !r2)
    return false;
  return Lm(i2, e20, ry) === ")" ? (Mm(t2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : n2.body === r2 && (_m(r2, e20), true);
}
function cy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
  return !(!n2 || n2.type !== "TryStatement" && n2.type !== "CatchClause" || !r2) && (n2.type === "CatchClause" && t2 ? (Mm(t2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : r2.type === "TryStatement" ? (uy(r2.finalizer, e20), true) : r2.type === "CatchClause" && (uy(r2.body, e20), true));
}
function ly({comment: e20, enclosingNode: t2, followingNode: n2}) {
  return !(!Qm(t2) || !n2 || n2.type !== "Identifier") && (_m(t2, e20), true);
}
function py({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
  const u2 = t2 && !jm(i2, ry(t2), ny(e20));
  return !(t2 && u2 || !n2 || n2.type !== "ConditionalExpression" && n2.type !== "TSConditionalType" || !r2) && (_m(r2, e20), true);
}
function fy({comment: e20, precedingNode: t2, enclosingNode: n2}) {
  return !(!Zm(n2) || !n2.shorthand || n2.key !== t2 || n2.value.type !== "AssignmentPattern") && (Mm(n2.value.left, e20), true);
}
function dy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
  if (n2 && (n2.type === "ClassDeclaration" || n2.type === "ClassExpression" || n2.type === "DeclareClass" || n2.type === "DeclareInterface" || n2.type === "InterfaceDeclaration" || n2.type === "TSInterfaceDeclaration")) {
    if (Vm(n2.decorators) && (!r2 || r2.type !== "Decorator"))
      return Mm(Pm(n2.decorators), e20), true;
    if (n2.body && r2 === n2.body)
      return iy(n2.body, e20), true;
    if (r2) {
      for (const i2 of ["implements", "extends", "mixins"])
        if (n2[i2] && r2 === n2[i2][0])
          return !t2 || t2 !== n2.id && t2 !== n2.typeParameters && t2 !== n2.superClass ? Rm(n2, e20, i2) : Mm(t2, e20), true;
    }
  }
  return false;
}
function hy({comment: e20, precedingNode: t2, enclosingNode: n2, text: r2}) {
  return (n2 && t2 && (n2.type === "Property" || n2.type === "TSDeclareMethod" || n2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && n2.key === t2 && Lm(r2, t2, ry) !== ":" || !(!t2 || !n2 || t2.type !== "Decorator" || n2.type !== "ClassMethod" && n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" && n2.type !== "TSAbstractClassProperty" && n2.type !== "TSAbstractMethodDefinition" && n2.type !== "TSDeclareMethod" && n2.type !== "MethodDefinition")) && (Mm(t2, e20), true);
}
function gy({comment: e20, precedingNode: t2, enclosingNode: n2, text: r2}) {
  return Lm(r2, e20, ry) === "(" && (!(!t2 || !n2 || n2.type !== "FunctionDeclaration" && n2.type !== "FunctionExpression" && n2.type !== "ClassMethod" && n2.type !== "MethodDefinition" && n2.type !== "ObjectMethod") && (Mm(t2, e20), true));
}
function my({comment: e20, enclosingNode: t2, text: n2}) {
  if (!t2 || t2.type !== "ArrowFunctionExpression")
    return false;
  const r2 = $m(n2, e20, ry);
  return r2 !== false && n2.slice(r2, r2 + 2) === "=>" && (Rm(t2, e20), true);
}
function yy({comment: e20, enclosingNode: t2, text: n2}) {
  return Lm(n2, e20, ry) === ")" && (t2 && (Iy(t2) && qm(t2).length === 0 || Xm(t2) && Ym(t2).length === 0) ? (Rm(t2, e20), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || qm(t2.value).length !== 0) && (Rm(t2.value, e20), true));
}
function Dy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
  if (t2 && t2.type === "FunctionTypeParam" && n2 && n2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
    return Mm(t2, e20), true;
  if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && n2 && Iy(n2) && Lm(i2, e20, ry) === ")")
    return Mm(t2, e20), true;
  if (n2 && n2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
    const t3 = (() => {
      const e21 = qm(n2);
      if (e21.length > 0)
        return Im(i2, ry(Pm(e21)));
      const t4 = Im(i2, ry(n2.id));
      return t4 !== false && Im(i2, t4 + 1);
    })();
    if (ny(e20) > t3)
      return iy(r2, e20), true;
  }
  return false;
}
function Ey({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "ImportSpecifier") && (_m(t2, e20), true);
}
function Cy({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "LabeledStatement") && (_m(t2, e20), true);
}
function by({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (Mm(t2, e20), true);
}
function Ay({comment: e20, precedingNode: t2, enclosingNode: n2}) {
  return !!(Km(n2) && t2 && n2.callee === t2 && n2.arguments.length > 0) && (_m(n2.arguments[0], e20), true);
}
function vy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
  return !n2 || n2.type !== "UnionTypeAnnotation" && n2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && Um(e20) && (r2.types[0].prettierIgnore = true, e20.unignore = true), false) : (Um(e20) && (r2.prettierIgnore = true, e20.unignore = true), !!t2 && (Mm(t2, e20), true));
}
function Fy({comment: e20, enclosingNode: t2}) {
  return !!Zm(t2) && (_m(t2, e20), true);
}
function Sy({comment: e20, enclosingNode: t2, followingNode: n2, ast: r2, isLastComment: i2}) {
  return r2 && r2.body && r2.body.length === 0 ? (i2 ? Rm(r2, e20) : _m(r2, e20), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !Vm(t2.directives) ? (i2 ? Rm(t2, e20) : _m(t2, e20), true) : !(!n2 || n2.type !== "Program" || n2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (Rm(n2, e20), true);
}
function xy({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (_m(t2, e20), true);
}
function wy({comment: e20, precedingNode: t2, enclosingNode: n2, text: r2}) {
  return !!(t2 && t2.type === "ImportSpecifier" && n2 && n2.type === "ImportDeclaration" && Om(r2, ry(e20))) && (Mm(t2, e20), true);
}
function Ty({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "AssignmentPattern") && (_m(t2, e20), true);
}
function By({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "TypeAlias") && (_m(t2, e20), true);
}
function Ny({comment: e20, enclosingNode: t2, followingNode: n2}) {
  return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !n2 || n2.type !== "ObjectExpression" && n2.type !== "ArrayExpression" && n2.type !== "TemplateLiteral" && n2.type !== "TaggedTemplateExpression" && !Wm(e20)) && (_m(n2, e20), true);
}
function ky({comment: e20, enclosingNode: t2, followingNode: n2, text: r2}) {
  return !(n2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || Lm(r2, e20, ry) !== ";") && (Mm(t2, e20), true);
}
function Py({comment: e20, enclosingNode: t2, followingNode: n2}) {
  if (Um(e20) && t2 && t2.type === "TSMappedType" && n2 && n2.type === "TSTypeParameter" && n2.constraint)
    return t2.prettierIgnore = true, e20.unignore = true, true;
}
function Oy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
  return !(!n2 || n2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (_m(r2.name, e20), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (Mm(t2.constraint, e20), true));
}
function Iy(e20) {
  return e20.type === "ArrowFunctionExpression" || e20.type === "FunctionExpression" || e20.type === "FunctionDeclaration" || e20.type === "ObjectMethod" || e20.type === "ClassMethod" || e20.type === "TSDeclareFunction" || e20.type === "TSCallSignatureDeclaration" || e20.type === "TSConstructSignatureDeclaration" || e20.type === "TSMethodSignature" || e20.type === "TSConstructorType" || e20.type === "TSFunctionType" || e20.type === "TSDeclareMethod";
}
function Ly(e20) {
  return Wm(e20) && e20.value[0] === "*" && /@type\b/.test(e20.value);
}
var jy = {handleOwnLineComment: function(e20) {
  return [Py, Dy, ly, sy, ay, cy, dy, Ey, xy, vy, Sy, wy, Ty, hy, Cy].some((t2) => t2(e20));
}, handleEndOfLineComment: function(e20) {
  return [oy, Dy, py, Ey, sy, ay, cy, dy, Cy, Ay, Fy, Sy, By, Ny].some((t2) => t2(e20));
}, handleRemainingComment: function(e20) {
  return [Py, sy, ay, fy, yy, hy, Sy, my, gy, Oy, by, ky].some((t2) => t2(e20));
}, isTypeCastComment: Ly, getCommentChildNodes: function(e20, t2) {
  if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e20.type === "MethodDefinition" && e20.value && e20.value.type === "FunctionExpression" && qm(e20.value).length === 0 && !e20.value.returnType && !Vm(e20.value.typeParameters) && e20.value.body)
    return [...e20.decorators || [], e20.key, e20.value.body];
}, willPrintOwnComments: function(e20) {
  const t2 = e20.getValue(), n2 = e20.getParentNode();
  return (t2 && (zm(t2) || Gm(t2) || Km(n2) && ((e21) => Hm(ey(e21, ty.Leading)) || Hm(ey(e21, ty.Trailing)))(t2)) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t2)) && (!Jm(e20) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
}};
const {getFunctionParameters: _y, getLeftSidePathName: My, hasFlowShorthandAnnotationComment: Ry, hasNakedLeftSide: $y, hasNode: Vy, isBitwiseOperator: Wy, startsWithNoLookaheadToken: qy, shouldFlatten: Uy, getPrecedence: zy, isCallExpression: Gy, isMemberExpression: Hy, isObjectProperty: Jy} = Gh;
function Xy(e20, t2) {
  const n2 = e20.getParentNode();
  if (!n2)
    return false;
  const r2 = e20.getName(), i2 = e20.getNode();
  if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && function(e21) {
    switch (e21.type) {
      case "ObjectExpression":
        return true;
      default:
        return false;
    }
  }(i2) && Yy(e20))
    return true;
  if (function(e21) {
    return e21.type === "BlockStatement" || e21.type === "BreakStatement" || e21.type === "ClassBody" || e21.type === "ClassDeclaration" || e21.type === "ClassMethod" || e21.type === "ClassProperty" || e21.type === "PropertyDefinition" || e21.type === "ClassPrivateProperty" || e21.type === "ContinueStatement" || e21.type === "DebuggerStatement" || e21.type === "DeclareClass" || e21.type === "DeclareExportAllDeclaration" || e21.type === "DeclareExportDeclaration" || e21.type === "DeclareFunction" || e21.type === "DeclareInterface" || e21.type === "DeclareModule" || e21.type === "DeclareModuleExports" || e21.type === "DeclareVariable" || e21.type === "DoWhileStatement" || e21.type === "EnumDeclaration" || e21.type === "ExportAllDeclaration" || e21.type === "ExportDefaultDeclaration" || e21.type === "ExportNamedDeclaration" || e21.type === "ExpressionStatement" || e21.type === "ForInStatement" || e21.type === "ForOfStatement" || e21.type === "ForStatement" || e21.type === "FunctionDeclaration" || e21.type === "IfStatement" || e21.type === "ImportDeclaration" || e21.type === "InterfaceDeclaration" || e21.type === "LabeledStatement" || e21.type === "MethodDefinition" || e21.type === "ReturnStatement" || e21.type === "SwitchStatement" || e21.type === "ThrowStatement" || e21.type === "TryStatement" || e21.type === "TSDeclareFunction" || e21.type === "TSEnumDeclaration" || e21.type === "TSImportEqualsDeclaration" || e21.type === "TSInterfaceDeclaration" || e21.type === "TSModuleDeclaration" || e21.type === "TSNamespaceExportDeclaration" || e21.type === "TypeAlias" || e21.type === "VariableDeclaration" || e21.type === "WhileStatement" || e21.type === "WithStatement";
  }(i2))
    return false;
  if (t2.parser !== "flow" && Ry(e20.getValue()))
    return true;
  if (i2.type === "Identifier")
    return !!(i2.extra && i2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(i2.name)) || r2 === "left" && i2.name === "async" && n2.type === "ForOfStatement" && !n2.await;
  switch (n2.type) {
    case "ParenthesizedExpression":
      return false;
    case "ClassDeclaration":
    case "ClassExpression":
      if (r2 === "superClass" && (i2.type === "ArrowFunctionExpression" || i2.type === "AssignmentExpression" || i2.type === "AwaitExpression" || i2.type === "BinaryExpression" || i2.type === "ConditionalExpression" || i2.type === "LogicalExpression" || i2.type === "NewExpression" || i2.type === "ObjectExpression" || i2.type === "ParenthesizedExpression" || i2.type === "SequenceExpression" || i2.type === "TaggedTemplateExpression" || i2.type === "UnaryExpression" || i2.type === "UpdateExpression" || i2.type === "YieldExpression" || i2.type === "TSNonNullExpression"))
        return true;
      break;
    case "ExportDefaultDeclaration":
      return Ky(e20, t2) || i2.type === "SequenceExpression";
    case "Decorator":
      if (r2 === "expression") {
        let e21 = false, t3 = false, n3 = i2;
        for (; n3; )
          switch (n3.type) {
            case "MemberExpression":
              t3 = true, n3 = n3.object;
              break;
            case "CallExpression":
              if (t3 || e21)
                return true;
              e21 = true, n3 = n3.callee;
              break;
            case "Identifier":
              return false;
            default:
              return true;
          }
        return true;
      }
      break;
    case "ExpressionStatement":
      if (qy(i2, true))
        return true;
      break;
    case "ArrowFunctionExpression":
      if (r2 === "body" && i2.type !== "SequenceExpression" && qy(i2, false))
        return true;
  }
  switch (i2.type) {
    case "UpdateExpression":
      if (n2.type === "UnaryExpression")
        return i2.prefix && (i2.operator === "++" && n2.operator === "+" || i2.operator === "--" && n2.operator === "-");
    case "UnaryExpression":
      switch (n2.type) {
        case "UnaryExpression":
          return i2.operator === n2.operator && (i2.operator === "+" || i2.operator === "-");
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "TaggedTemplateExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "BinaryExpression":
          return r2 === "left" && n2.operator === "**";
        case "TSNonNullExpression":
          return true;
        default:
          return false;
      }
    case "BinaryExpression":
      if (n2.type === "UpdateExpression" || n2.type === "PipelineTopicExpression" && i2.operator === "|>")
        return true;
      if (i2.operator === "in" && function(e21) {
        let t3 = 0, n3 = e21.getValue();
        for (; n3; ) {
          const r3 = e21.getParentNode(t3++);
          if (r3 && r3.type === "ForStatement" && r3.init === n3)
            return true;
          n3 = r3;
        }
        return false;
      }(e20))
        return true;
      if (i2.operator === "|>" && i2.extra && i2.extra.parenthesized) {
        const t3 = e20.getParentNode(1);
        if (t3.type === "BinaryExpression" && t3.operator === "|>")
          return true;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "LogicalExpression":
      switch (n2.type) {
        case "TSAsExpression":
          return i2.type !== "TSAsExpression";
        case "ConditionalExpression":
          return i2.type === "TSAsExpression";
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return r2 === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "SpreadProperty":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return r2 === "left" && (i2.type === "TSTypeAssertion" || i2.type === "TSAsExpression");
        case "LogicalExpression":
          if (i2.type === "LogicalExpression")
            return n2.operator !== i2.operator;
        case "BinaryExpression": {
          const {operator: e21, type: t3} = i2;
          if (!e21 && t3 !== "TSTypeAssertion")
            return true;
          const u2 = zy(e21), o2 = n2.operator, s2 = zy(o2);
          return s2 > u2 || (r2 === "right" && s2 === u2 || (s2 === u2 && !Uy(o2, e21) || (s2 < u2 && e21 === "%" ? o2 === "+" || o2 === "-" : !!Wy(o2))));
        }
        default:
          return false;
      }
    case "SequenceExpression":
      switch (n2.type) {
        case "ReturnStatement":
        case "ForStatement":
          return false;
        case "ExpressionStatement":
          return r2 !== "expression";
        case "ArrowFunctionExpression":
          return r2 !== "body";
        default:
          return true;
      }
    case "YieldExpression":
      if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
        return true;
      if (r2 === "expression" && i2.argument && i2.argument.type === "PipelinePrimaryTopicReference" && n2.type === "PipelineTopicExpression")
        return true;
    case "AwaitExpression":
      switch (n2.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "ConditionalExpression":
          return r2 === "test";
        case "BinaryExpression":
          return !(!i2.argument && n2.operator === "|>");
        default:
          return false;
      }
    case "TSConditionalType":
      if (r2 === "extendsType" && n2.type === "TSConditionalType")
        return true;
    case "TSFunctionType":
    case "TSConstructorType":
      if (r2 === "checkType" && n2.type === "TSConditionalType")
        return true;
    case "TSUnionType":
    case "TSIntersectionType":
      if ((n2.type === "TSUnionType" || n2.type === "TSIntersectionType") && n2.types.length > 1 && (!i2.types || i2.types.length > 1))
        return true;
    case "TSInferType":
      if (i2.type === "TSInferType" && n2.type === "TSRestType")
        return false;
    case "TSTypeOperator":
      return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || r2 === "objectType" && n2.type === "TSIndexedAccessType" || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && /^TSJSDoc/.test(e20.getParentNode(1).type);
    case "ArrayTypeAnnotation":
      return n2.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
    case "NullableTypeAnnotation":
      return n2.type === "ArrayTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
    case "FunctionTypeAnnotation": {
      const t3 = n2.type === "NullableTypeAnnotation" ? e20.getParentNode(1) : n2;
      return t3.type === "UnionTypeAnnotation" || t3.type === "IntersectionTypeAnnotation" || t3.type === "ArrayTypeAnnotation" || r2 === "objectType" && (t3.type === "IndexedAccessType" || t3.type === "OptionalIndexedAccessType") || t3.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && _y(i2).some((e21) => e21.typeAnnotation && e21.typeAnnotation.type === "NullableTypeAnnotation");
    }
    case "OptionalIndexedAccessType":
      return r2 === "objectType" && n2.type === "IndexedAccessType";
    case "TypeofTypeAnnotation":
      return r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof i2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
        const t3 = e20.getParentNode(1);
        return t3.type === "Program" || t3.type === "BlockStatement";
      }
      return r2 === "object" && n2.type === "MemberExpression" && typeof i2.value == "number";
    case "AssignmentExpression": {
      const t3 = e20.getParentNode(1);
      return r2 === "body" && n2.type === "ArrowFunctionExpression" || (r2 !== "key" || n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" || !n2.computed) && ((r2 !== "init" && r2 !== "update" || n2.type !== "ForStatement") && (n2.type === "ExpressionStatement" ? i2.left.type === "ObjectPattern" : (r2 !== "key" || n2.type !== "TSPropertySignature") && (n2.type !== "AssignmentExpression" && ((n2.type !== "SequenceExpression" || !t3 || t3.type !== "ForStatement" || t3.init !== n2 && t3.update !== n2) && ((r2 !== "value" || n2.type !== "Property" || !t3 || t3.type !== "ObjectPattern" || !t3.properties.includes(n2)) && n2.type !== "NGChainedExpression")))));
    }
    case "ConditionalExpression":
      switch (n2.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSNonNullExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "ConditionalExpression":
          return r2 === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        default:
          return false;
      }
    case "FunctionExpression":
      switch (n2.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "TaggedTemplateExpression":
          return true;
        default:
          return false;
      }
    case "ArrowFunctionExpression":
      switch (n2.type) {
        case "PipelineTopicExpression":
          return Boolean(i2.extra && i2.extra.parenthesized);
        case "BinaryExpression":
          return n2.operator !== "|>" || i2.extra && i2.extra.parenthesized;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return true;
        case "ConditionalExpression":
          return r2 === "test";
        default:
          return false;
      }
    case "ClassExpression":
      switch (n2.type) {
        case "NewExpression":
          return r2 === "callee";
        default:
          return false;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression": {
      const t3 = e20.getParentNode(1);
      if (r2 === "object" && n2.type === "MemberExpression" || r2 === "callee" && (n2.type === "CallExpression" || n2.type === "NewExpression") || n2.type === "TSNonNullExpression" && t3.type === "MemberExpression" && t3.object === n2)
        return true;
    }
    case "CallExpression":
    case "MemberExpression":
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression")) {
        let e21 = i2;
        for (; e21; )
          switch (e21.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              e21 = e21.object;
              break;
            case "TaggedTemplateExpression":
              e21 = e21.tag;
              break;
            case "TSNonNullExpression":
              e21 = e21.expression;
              break;
            default:
              return false;
          }
      }
      return false;
    case "BindExpression":
      return r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression") || r2 === "object" && Hy(n2);
    case "NGPipeExpression":
      return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || n2.type === "ObjectProperty" && (!i2.extra || !i2.extra.parenthesized) || n2.type === "ArrayExpression" || Gy(n2) && n2.arguments[r2] === i2 || r2 === "right" && n2.type === "NGPipeExpression" || r2 === "property" && n2.type === "MemberExpression" || n2.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return r2 === "callee" || r2 === "left" && n2.type === "BinaryExpression" && n2.operator === "<" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && !Gy(n2) && !Jy(n2) && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator" && n2.type !== "YieldExpression";
    case "TypeAnnotation":
      return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e21) {
        return Vy(e21, (e22) => e22.type === "ObjectTypeAnnotation" && Vy(e22, (e23) => e23.type === "FunctionTypeAnnotation" || void 0) || void 0);
      }(i2);
  }
  return false;
}
function Yy(e20) {
  const t2 = e20.getValue(), n2 = e20.getParentNode(), r2 = e20.getName();
  switch (n2.type) {
    case "NGPipeExpression":
      if (typeof r2 == "number" && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2)
        return e20.callParent(Yy);
      break;
    case "ObjectProperty":
      if (r2 === "value") {
        const t3 = e20.getParentNode(1);
        return Ln$2(t3.properties) === n2;
      }
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r2 === "right")
        return e20.callParent(Yy);
      break;
    case "ConditionalExpression":
      if (r2 === "alternate")
        return e20.callParent(Yy);
      break;
    case "UnaryExpression":
      if (n2.prefix)
        return e20.callParent(Yy);
  }
  return false;
}
function Ky(e20, t2) {
  const n2 = e20.getValue(), r2 = e20.getParentNode();
  return n2.type === "FunctionExpression" || n2.type === "ClassExpression" ? r2.type === "ExportDefaultDeclaration" || !Xy(e20, t2) : !(!$y(n2) || r2.type !== "ExportDefaultDeclaration" && Xy(e20, t2)) && e20.call((e21) => Ky(e21, t2), ...My(e20, n2));
}
var Qy = Xy;
var Zy = function(e20, t2) {
  switch (t2.parser) {
    case "json":
    case "json5":
    case "json-stringify":
    case "__js_expression":
    case "__vue_expression":
      return Object.assign(Object.assign({}, e20), {}, {type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e20, comments: [], rootMarker: t2.rootMarker});
    default:
      return e20;
  }
};
const {builders: {join: eD, line: tD, group: nD, softline: rD, indent: iD}} = eu$1;
var uD = {isVueEventBindingExpression: function e6(t2) {
  switch (t2.type) {
    case "MemberExpression":
      switch (t2.property.type) {
        case "Identifier":
        case "NumericLiteral":
        case "StringLiteral":
          return e6(t2.object);
      }
      return false;
    case "Identifier":
      return true;
    default:
      return false;
  }
}, printHtmlBinding: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (t2.__onHtmlBindingRoot && e20.getName() === null && t2.__onHtmlBindingRoot(r2, t2), r2.type === "File")
    return t2.__isVueForBindingLeft ? e20.call((e21) => {
      const t3 = eD([",", tD], e21.map(n2, "params")), {params: r3} = e21.getValue();
      return r3.length === 1 ? t3 : ["(", iD([rD, nD(t3)]), rD, ")"];
    }, "program", "body", 0) : t2.__isVueBindings ? e20.call((e21) => eD([",", tD], e21.map(n2, "params")), "program", "body", 0) : void 0;
}};
const {printComments: oD} = Wf, {getLast: sD} = yi$2, {builders: {join: aD, line: cD, softline: lD, group: pD, indent: fD, align: dD, ifBreak: hD, indentIfBreak: gD}, utils: {cleanDoc: mD, getDocParts: yD, isConcat: DD}} = eu$1, {hasLeadingOwnLineComment: ED, isBinaryish: CD, isJsxNode: bD, shouldFlatten: AD, hasComment: vD, CommentCheckFlags: FD, isCallExpression: SD, isMemberExpression: xD, isObjectProperty: wD} = Gh;
let TD = 0;
function BD(e20, t2, n2, r2, i2) {
  let u2 = [];
  const o2 = e20.getValue();
  if (CD(o2)) {
    AD(o2.operator, o2.left.operator) ? u2 = [...u2, ...e20.call((e21) => BD(e21, t2, n2, true, i2), "left")] : u2.push(pD(t2("left")));
    const s2 = ND(o2), a2 = (o2.operator === "|>" || o2.type === "NGPipeExpression" || o2.operator === "|" && n2.parser === "__vue_expression") && !ED(n2.originalText, o2.right), c2 = o2.type === "NGPipeExpression" ? "|" : o2.operator, l2 = o2.type === "NGPipeExpression" && o2.arguments.length > 0 ? pD(fD([lD, ": ", aD([lD, ":", hD(" ")], e20.map(t2, "arguments").map((e21) => dD(2, pD(e21))))])) : "", p2 = s2 ? [c2, " ", t2("right"), l2] : [a2 ? cD : "", c2, a2 ? " " : cD, t2("right"), l2], f2 = e20.getParentNode(), d2 = vD(o2.left, FD.Trailing | FD.Line), h2 = d2 || !(i2 && o2.type === "LogicalExpression") && f2.type !== o2.type && o2.left.type !== o2.type && o2.right.type !== o2.type;
    if (u2.push(a2 ? "" : " ", h2 ? pD(p2, {shouldBreak: d2}) : p2), r2 && vD(o2)) {
      const t3 = mD(oD(e20, u2, n2));
      u2 = DD(t3) || t3.type === "fill" ? yD(t3) : [t3];
    }
  } else
    u2.push(pD(t2()));
  return u2;
}
function ND(e20) {
  return e20.type === "LogicalExpression" && (e20.right.type === "ObjectExpression" && e20.right.properties.length > 0 || (e20.right.type === "ArrayExpression" && e20.right.elements.length > 0 || !!bD(e20.right)));
}
var kD = {printBinaryishExpression: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = e20.getParentNode(1), o2 = r2 !== i2.body && (i2.type === "IfStatement" || i2.type === "WhileStatement" || i2.type === "SwitchStatement" || i2.type === "DoWhileStatement"), s2 = BD(e20, n2, t2, false, o2);
  if (o2)
    return s2;
  if (SD(i2) && i2.callee === r2 || i2.type === "UnaryExpression" || xD(i2) && !i2.computed)
    return pD([fD([lD, ...s2]), lD]);
  const a2 = i2.type === "ReturnStatement" || i2.type === "ThrowStatement" || i2.type === "JSXExpressionContainer" && u2.type === "JSXAttribute" || r2.operator !== "|" && i2.type === "JsExpressionRoot" || r2.type !== "NGPipeExpression" && (i2.type === "NGRoot" && t2.parser === "__ng_binding" || i2.type === "NGMicrosyntaxExpression" && u2.type === "NGMicrosyntax" && u2.body.length === 1) || r2 === i2.body && i2.type === "ArrowFunctionExpression" || r2 !== i2.body && i2.type === "ForStatement" || i2.type === "ConditionalExpression" && u2.type !== "ReturnStatement" && u2.type !== "ThrowStatement" && !SD(u2) || i2.type === "TemplateLiteral", c2 = i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator" || i2.type === "ClassProperty" || i2.type === "PropertyDefinition" || i2.type === "TSAbstractClassProperty" || i2.type === "ClassPrivateProperty" || wD(i2), l2 = CD(r2.left) && AD(r2.operator, r2.left.operator);
  if (a2 || ND(r2) && !l2 || !ND(r2) && c2)
    return pD(s2);
  if (s2.length === 0)
    return "";
  const p2 = bD(r2.right), f2 = s2.findIndex((e21) => typeof e21 != "string" && !Array.isArray(e21) && e21.type === "group"), d2 = s2.slice(0, f2 === -1 ? 1 : f2 + 1), h2 = s2.slice(d2.length, p2 ? -1 : void 0), g2 = Symbol("logicalChain-" + ++TD), m2 = pD([...d2, fD(h2)], {id: g2});
  if (!p2)
    return m2;
  const y2 = sD(s2);
  return pD([m2, gD(y2, {groupId: g2})]);
}, shouldInlineLogicalExpression: ND};
const {builders: {join: PD, line: OD, group: ID}} = eu$1, {hasNode: LD, hasComment: jD, getComments: _D} = Gh, {printBinaryishExpression: MD} = kD;
function RD(e20, t2, n2) {
  return e20.type === "NGMicrosyntaxKeyedExpression" && e20.key.name === "of" && t2 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
}
var $D = {printAngular: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (r2.type.startsWith("NG"))
    switch (r2.type) {
      case "NGRoot":
        return [n2("node"), jD(r2.node) ? " //" + _D(r2.node)[0].value.trimEnd() : ""];
      case "NGPipeExpression":
        return MD(e20, t2, n2);
      case "NGChainedExpression":
        return ID(PD([";", OD], e20.map((e21) => function(e22) {
          return LD(e22.getValue(), (e23) => {
            switch (e23.type) {
              case void 0:
                return false;
              case "CallExpression":
              case "OptionalCallExpression":
              case "AssignmentExpression":
                return true;
            }
          });
        }(e21) ? n2() : ["(", n2(), ")"], "expressions")));
      case "NGEmptyExpression":
        return "";
      case "NGQuotedExpression":
        return [r2.prefix, ": ", r2.value.trim()];
      case "NGMicrosyntax":
        return e20.map((e21, t3) => [t3 === 0 ? "" : RD(e21.getValue(), t3, r2) ? " " : [";", OD], n2()], "body");
      case "NGMicrosyntaxKey":
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r2.name) ? r2.name : JSON.stringify(r2.name);
      case "NGMicrosyntaxExpression":
        return [n2("expression"), r2.alias === null ? "" : [" as ", n2("alias")]];
      case "NGMicrosyntaxKeyedExpression": {
        const t3 = e20.getName(), i2 = e20.getParentNode(), u2 = RD(r2, t3, i2) || (t3 === 1 && (r2.key.name === "then" || r2.key.name === "else") || t3 === 2 && r2.key.name === "else" && i2.body[t3 - 1].type === "NGMicrosyntaxKeyedExpression" && i2.body[t3 - 1].key.name === "then") && i2.body[0].type === "NGMicrosyntaxExpression";
        return [n2("key"), u2 ? " " : ": ", n2("expression")];
      }
      case "NGMicrosyntaxLet":
        return ["let ", n2("key"), r2.value === null ? "" : [" = ", n2("value")]];
      case "NGMicrosyntaxAs":
        return [n2("key"), " as ", n2("alias")];
      default:
        throw new Error(`Unknown Angular node type: ${JSON.stringify(r2.type)}.`);
    }
}};
const {printComments: VD, printDanglingComments: WD} = Wf, {builders: {line: qD, hardline: UD, softline: zD, group: GD, indent: HD, conditionalGroup: JD, fill: XD, ifBreak: YD, lineSuffixBoundary: KD, join: QD}, utils: {willBreak: ZD}} = eu$1, {getLast: eE, getPreferredQuote: tE} = yi$2, {isJsxNode: nE, rawText: rE, isLiteral: iE, isCallExpression: uE, isStringLiteral: oE, isBinaryish: sE, hasComment: aE, CommentCheckFlags: cE, hasNodeIgnoreComment: lE} = Gh, {willPrintOwnComments: pE} = jy, fE = (e20) => e20 === "" || e20 === qD || e20 === UD || e20 === zD;
function dE(e20, t2, n2) {
  const r2 = e20.getValue();
  if (r2.type === "JSXElement" && function(e21) {
    if (e21.children.length === 0)
      return true;
    if (e21.children.length > 1)
      return false;
    const t3 = e21.children[0];
    return iE(t3) && !bE(t3);
  }(r2))
    return [n2("openingElement"), n2("closingElement")];
  const i2 = r2.type === "JSXElement" ? n2("openingElement") : n2("openingFragment"), u2 = r2.type === "JSXElement" ? n2("closingElement") : n2("closingFragment");
  if (r2.children.length === 1 && r2.children[0].type === "JSXExpressionContainer" && (r2.children[0].expression.type === "TemplateLiteral" || r2.children[0].expression.type === "TaggedTemplateExpression"))
    return [i2, ...e20.map(n2, "children"), u2];
  r2.children = r2.children.map((e21) => function(e22) {
    return e22.type === "JSXExpressionContainer" && iE(e22.expression) && e22.expression.value === " " && !aE(e22.expression);
  }(e21) ? {type: "JSXText", value: " ", raw: " "} : e21);
  const o2 = r2.children.filter(nE).length > 0, s2 = r2.children.filter((e21) => e21.type === "JSXExpressionContainer").length > 1, a2 = r2.type === "JSXElement" && r2.openingElement.attributes.length > 1;
  let c2 = ZD(i2) || o2 || a2 || s2;
  const l2 = e20.getParentNode().rootMarker === "mdx", p2 = t2.singleQuote ? "{' '}" : '{" "}', f2 = l2 ? " " : YD([p2, zD], " "), d2 = function(e21, t3, n3, r3, i3) {
    const u3 = [];
    return e21.each((e22, t4, o3) => {
      const s3 = e22.getValue();
      if (iE(s3)) {
        const e23 = rE(s3);
        if (bE(s3)) {
          const n4 = e23.split(DE);
          if (n4[0] === "") {
            if (u3.push(""), n4.shift(), /\n/.test(n4[0])) {
              const e24 = o3[t4 + 1];
              u3.push(gE(i3, n4[1], s3, e24));
            } else
              u3.push(r3);
            n4.shift();
          }
          let a3;
          if (eE(n4) === "" && (n4.pop(), a3 = n4.pop()), n4.length === 0)
            return;
          for (const [e24, t5] of n4.entries())
            e24 % 2 == 1 ? u3.push(qD) : u3.push(t5);
          if (a3 !== void 0)
            if (/\n/.test(a3)) {
              const e24 = o3[t4 + 1];
              u3.push(gE(i3, eE(u3), s3, e24));
            } else
              u3.push(r3);
          else {
            const e24 = o3[t4 + 1];
            u3.push(hE(i3, eE(u3), s3, e24));
          }
        } else
          /\n/.test(e23) ? e23.match(/\n/g).length > 1 && u3.push("", UD) : u3.push("", r3);
      } else {
        const e23 = n3();
        u3.push(e23);
        const r4 = o3[t4 + 1];
        if (r4 && bE(r4)) {
          const e24 = CE(rE(r4)).split(DE)[0];
          u3.push(hE(i3, e24, s3, r4));
        } else
          u3.push(UD);
      }
    }, "children"), u3;
  }(e20, 0, n2, f2, r2.openingElement && r2.openingElement.name && r2.openingElement.name.name === "fbt"), h2 = r2.children.some((e21) => bE(e21));
  for (let e21 = d2.length - 2; e21 >= 0; e21--) {
    const t3 = d2[e21] === "" && d2[e21 + 1] === "", n3 = d2[e21] === UD && d2[e21 + 1] === "" && d2[e21 + 2] === UD, r3 = (d2[e21] === zD || d2[e21] === UD) && d2[e21 + 1] === "" && d2[e21 + 2] === f2, i3 = d2[e21] === f2 && d2[e21 + 1] === "" && (d2[e21 + 2] === zD || d2[e21 + 2] === UD), u3 = d2[e21] === f2 && d2[e21 + 1] === "" && d2[e21 + 2] === f2, o3 = d2[e21] === zD && d2[e21 + 1] === "" && d2[e21 + 2] === UD || d2[e21] === UD && d2[e21 + 1] === "" && d2[e21 + 2] === zD;
    n3 && h2 || t3 || r3 || u3 || o3 ? d2.splice(e21, 2) : i3 && d2.splice(e21 + 1, 2);
  }
  for (; d2.length > 0 && fE(eE(d2)); )
    d2.pop();
  for (; d2.length > 1 && fE(d2[0]) && fE(d2[1]); )
    d2.shift(), d2.shift();
  const g2 = [];
  for (const [e21, t3] of d2.entries()) {
    if (t3 === f2) {
      if (e21 === 1 && d2[e21 - 1] === "") {
        if (d2.length === 2) {
          g2.push(p2);
          continue;
        }
        g2.push([p2, UD]);
        continue;
      }
      if (e21 === d2.length - 1) {
        g2.push(p2);
        continue;
      }
      if (d2[e21 - 1] === "" && d2[e21 - 2] === UD) {
        g2.push(p2);
        continue;
      }
    }
    g2.push(t3), ZD(t3) && (c2 = true);
  }
  const m2 = h2 ? XD(g2) : GD(g2, {shouldBreak: true});
  if (l2)
    return m2;
  const y2 = GD([i2, HD([UD, m2]), UD, u2]);
  return c2 ? y2 : JD([GD([i2, ...d2, u2]), y2]);
}
function hE(e20, t2, n2, r2) {
  return e20 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t2.length === 1 ? zD : UD : zD;
}
function gE(e20, t2, n2, r2) {
  return e20 ? UD : t2.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? UD : zD : UD;
}
function mE(e20, t2, n2) {
  return function(e21, t3, n3) {
    const r2 = e21.getParentNode();
    if (!r2)
      return t3;
    if ({ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true}[r2.type])
      return t3;
    const i2 = e21.match(void 0, (e22) => e22.type === "ArrowFunctionExpression", uE, (e22) => e22.type === "JSXExpressionContainer"), u2 = Qy(e21, n3);
    return GD([u2 ? "" : YD("("), HD([zD, t3]), zD, u2 ? "" : YD(")")], {shouldBreak: i2});
  }(e20, VD(e20, dE(e20, t2, n2), t2), t2);
}
function yE(e20, t2, n2) {
  const r2 = e20.getValue();
  return ["{", e20.call((e21) => {
    const r3 = ["...", n2()], i2 = e21.getValue();
    return aE(i2) && pE(e21) ? [HD([zD, VD(e21, r3, t2)]), zD] : r3;
  }, r2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
const DE = new RegExp("([ \n\r	]+)"), EE = new RegExp("[^ \n\r	]"), CE = (e20) => e20.replace(new RegExp("(?:^" + DE.source + "|" + DE.source + "$)"), "");
function bE(e20) {
  return iE(e20) && (EE.test(rE(e20)) || !/\n/.test(rE(e20)));
}
var AE = {hasJsxIgnoreComment: function(e20) {
  const t2 = e20.getValue(), n2 = e20.getParentNode();
  if (!(n2 && t2 && nE(t2) && nE(n2)))
    return false;
  let r2 = null;
  for (let e21 = n2.children.indexOf(t2); e21 > 0; e21--) {
    const t3 = n2.children[e21 - 1];
    if (t3.type !== "JSXText" || bE(t3)) {
      r2 = t3;
      break;
    }
  }
  return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && lE(r2.expression);
}, printJsx: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (r2.type.startsWith("JSX"))
    switch (r2.type) {
      case "JSXAttribute":
        return function(e21, t3, n3) {
          const r3 = e21.getValue(), i2 = [];
          if (i2.push(n3("name")), r3.value) {
            let e22;
            if (oE(r3.value)) {
              let n4 = rE(r3.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
              const i3 = tE(n4, t3.jsxSingleQuote ? "'" : '"'), u2 = i3 === "'" ? "&apos;" : "&quot;";
              n4 = n4.slice(1, -1).replace(new RegExp(i3, "g"), u2), e22 = [i3, n4, i3];
            } else
              e22 = n3("value");
            i2.push("=", e22);
          }
          return i2;
        }(e20, t2, n2);
      case "JSXIdentifier":
        return String(r2.name);
      case "JSXNamespacedName":
        return QD(":", [n2("namespace"), n2("name")]);
      case "JSXMemberExpression":
        return QD(".", [n2("object"), n2("property")]);
      case "JSXSpreadAttribute":
        return yE(e20, t2, n2);
      case "JSXSpreadChild":
        return yE(e20, t2, n2);
      case "JSXExpressionContainer":
        return function(e21, t3, n3) {
          const r3 = e21.getValue(), i2 = e21.getParentNode(0), u2 = r3.expression.type === "JSXEmptyExpression" || !aE(r3.expression) && (r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression" || r3.expression.type === "ArrowFunctionExpression" || uE(r3.expression) || r3.expression.type === "FunctionExpression" || r3.expression.type === "TemplateLiteral" || r3.expression.type === "TaggedTemplateExpression" || r3.expression.type === "DoExpression" || nE(i2) && (r3.expression.type === "ConditionalExpression" || sE(r3.expression)));
          return GD(u2 ? ["{", n3("expression"), KD, "}"] : ["{", HD([zD, n3("expression")]), zD, KD, "}"]);
        }(e20, 0, n2);
      case "JSXFragment":
      case "JSXElement":
        return mE(e20, t2, n2);
      case "JSXOpeningElement":
        return function(e21, t3, n3) {
          const r3 = e21.getValue(), i2 = r3.name && aE(r3.name) || r3.typeParameters && aE(r3.typeParameters);
          if (r3.selfClosing && r3.attributes.length === 0 && !i2)
            return ["<", n3("name"), n3("typeParameters"), " />"];
          if (r3.attributes && r3.attributes.length === 1 && r3.attributes[0].value && oE(r3.attributes[0].value) && !r3.attributes[0].value.value.includes("\n") && !i2 && !aE(r3.attributes[0]))
            return GD(["<", n3("name"), n3("typeParameters"), " ", ...e21.map(n3, "attributes"), r3.selfClosing ? " />" : ">"]);
          const u2 = r3.attributes.length > 0 && aE(eE(r3.attributes), cE.Trailing), o2 = r3.attributes.length === 0 && !i2 || (t3.bracketSameLine || t3.jsxBracketSameLine) && (!i2 || r3.attributes.length > 0) && !u2, s2 = r3.attributes && r3.attributes.some((e22) => e22.value && oE(e22.value) && e22.value.value.includes("\n"));
          return GD(["<", n3("name"), n3("typeParameters"), HD(e21.map(() => [qD, n3()], "attributes")), r3.selfClosing ? qD : o2 ? ">" : zD, r3.selfClosing ? "/>" : o2 ? "" : ">"], {shouldBreak: s2});
        }(e20, t2, n2);
      case "JSXClosingElement":
        return function(e21, t3, n3) {
          const r3 = e21.getValue(), i2 = [];
          i2.push("</");
          const u2 = n3("name");
          return aE(r3.name, cE.Leading | cE.Line) ? i2.push(HD([UD, u2]), UD) : aE(r3.name, cE.Leading | cE.Block) ? i2.push(" ", u2) : i2.push(u2), i2.push(">"), i2;
        }(e20, 0, n2);
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        return function(e21, t3) {
          const n3 = e21.getValue(), r3 = aE(n3), i2 = aE(n3, cE.Line), u2 = n3.type === "JSXOpeningFragment";
          return [u2 ? "<" : "</", HD([i2 ? UD : r3 && !u2 ? " " : "", WD(e21, t3, true)]), i2 ? UD : "", ">"];
        }(e20, t2);
      case "JSXEmptyExpression":
        return function(e21, t3) {
          const n3 = e21.getValue(), r3 = aE(n3, cE.Line);
          return [WD(e21, t3, !r3), r3 ? UD : ""];
        }(e20, t2);
      case "JSXText":
        throw new Error("JSXTest should be handled by JSXElement");
      default:
        throw new Error(`Unknown JSX node type: ${JSON.stringify(r2.type)}.`);
    }
}};
Ze$3({target: "Array", proto: true}, {flat: function() {
  var e20 = arguments.length ? arguments[0] : void 0, t2 = q$3(this), n2 = Le$3(t2.length), r2 = Wn$2(t2, 0);
  return r2.length = $n$2(r2, t2, t2, n2, 0, e20 === void 0 ? 1 : Oe$3(e20)), r2;
}});
const {isNonEmptyArray: vE} = yi$2, {builders: {indent: FE, join: SE, line: xE}} = eu$1, {isFlowAnnotationComment: wE} = Gh;
function TE(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2.typeAnnotation)
    return "";
  const i2 = e20.getParentNode(), u2 = r2.definite || i2 && i2.type === "VariableDeclarator" && i2.definite, o2 = i2.type === "DeclareFunction" && i2.id === r2;
  return wE(t2.originalText, r2.typeAnnotation) ? [" /*: ", n2("typeAnnotation"), " */"] : [o2 ? "" : u2 ? "!: " : ": ", n2("typeAnnotation")];
}
var BE = {printOptionalToken: function(e20) {
  const t2 = e20.getValue();
  return !t2.optional || t2.type === "Identifier" && t2 === e20.getParentNode().key ? "" : t2.type === "OptionalCallExpression" || t2.type === "OptionalMemberExpression" && t2.computed ? "?." : "?";
}, printFunctionTypeParameters: function(e20, t2, n2) {
  const r2 = e20.getValue();
  return r2.typeArguments ? n2("typeArguments") : r2.typeParameters ? n2("typeParameters") : "";
}, printBindExpressionCallee: function(e20, t2, n2) {
  return ["::", n2("callee")];
}, printTypeScriptModifiers: function(e20, t2, n2) {
  const r2 = e20.getValue();
  return vE(r2.modifiers) ? [SE(" ", e20.map(n2, "modifiers")), " "] : "";
}, printTypeAnnotation: TE, printRestSpread: function(e20, t2, n2) {
  return ["...", n2("argument"), TE(e20, t2, n2)];
}, adjustClause: function(e20, t2, n2) {
  return e20.type === "EmptyStatement" ? ";" : e20.type === "BlockStatement" || n2 ? [" ", t2] : FE([xE, t2]);
}};
const {printDanglingComments: NE} = Wf, {builders: {line: kE, softline: PE, hardline: OE, group: IE, indent: LE, ifBreak: jE, fill: _E}} = eu$1, {getLast: ME, hasNewline: RE} = yi$2, {shouldPrintComma: $E, hasComment: VE, CommentCheckFlags: WE, isNextLineEmpty: qE, isNumericLiteral: UE, isSignedNumericLiteral: zE} = Gh, {locStart: GE} = zc, {printOptionalToken: HE, printTypeAnnotation: JE} = BE;
function XE(e20, t2) {
  return e20.elements.length > 1 && e20.elements.every((e21) => e21 && (UE(e21) || zE(e21) && !VE(e21.argument)) && !VE(e21, WE.Trailing | WE.Line, (e22) => !RE(t2.originalText, GE(e22), {backwards: true})));
}
function YE(e20, t2, n2, r2) {
  const i2 = [];
  let u2 = [];
  return e20.each((e21) => {
    i2.push(u2, IE(r2())), u2 = [",", kE], e21.getValue() && qE(e21.getValue(), t2) && u2.push(PE);
  }, n2), i2;
}
function KE(e20, t2, n2, r2) {
  const i2 = [];
  return e20.each((e21, u2, o2) => {
    const s2 = u2 === o2.length - 1;
    i2.push([n2(), s2 ? r2 : ","]), s2 || i2.push(qE(e21.getValue(), t2) ? [OE, OE] : VE(o2[u2 + 1], WE.Leading | WE.Line) ? OE : kE);
  }, "elements"), _E(i2);
}
var QE = {printArray: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [], u2 = r2.type === "TupleExpression" ? "#[" : "[";
  if (r2.elements.length === 0)
    VE(r2, WE.Dangling) ? i2.push(IE([u2, NE(e20, t2), PE, "]"])) : i2.push(u2, "]");
  else {
    const o2 = ME(r2.elements), s2 = !(o2 && o2.type === "RestElement"), a2 = o2 === null, c2 = Symbol("array"), l2 = !t2.__inJestEach && r2.elements.length > 1 && r2.elements.every((e21, t3, n3) => {
      const r3 = e21 && e21.type;
      if (r3 !== "ArrayExpression" && r3 !== "ObjectExpression")
        return false;
      const i3 = n3[t3 + 1];
      if (i3 && r3 !== i3.type)
        return false;
      const u3 = r3 === "ArrayExpression" ? "elements" : "properties";
      return e21[u3] && e21[u3].length > 1;
    }), p2 = XE(r2, t2), f2 = s2 ? a2 ? "," : $E(t2) ? p2 ? jE(",", "", {groupId: c2}) : jE(",") : "" : "";
    i2.push(IE([u2, LE([PE, p2 ? KE(e20, t2, n2, f2) : [YE(e20, t2, "elements", n2), f2], NE(e20, t2, true)]), PE, "]"], {shouldBreak: l2, id: c2}));
  }
  return i2.push(HE(e20), JE(e20, t2, n2)), i2;
}, printArrayItems: YE, isConciselyPrintedArray: XE};
const {printDanglingComments: ZE} = Wf, {getLast: eC, getPenultimate: tC} = yi$2, {getFunctionParameters: nC, hasComment: rC, CommentCheckFlags: iC, isFunctionCompositionArgs: uC, isJsxNode: oC, isLongCurriedCallExpression: sC, shouldPrintComma: aC, getCallArguments: cC, iterateCallArgumentsPath: lC, isNextLineEmpty: pC, isCallExpression: fC, isStringLiteral: dC, isObjectProperty: hC} = Gh, {builders: {line: gC, hardline: mC, softline: yC, group: DC, indent: EC, conditionalGroup: CC, ifBreak: bC, breakParent: AC}, utils: {willBreak: vC}} = eu$1, {ArgExpansionBailout: FC} = bo$2, {isConciselyPrintedArray: SC} = QE;
function xC(e20, t2 = false) {
  return e20.type === "ObjectExpression" && (e20.properties.length > 0 || rC(e20)) || e20.type === "ArrayExpression" && (e20.elements.length > 0 || rC(e20)) || e20.type === "TSTypeAssertion" && xC(e20.expression) || e20.type === "TSAsExpression" && xC(e20.expression) || e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && (!e20.returnType || !e20.returnType.typeAnnotation || e20.returnType.typeAnnotation.type !== "TSTypeReference" || (n2 = e20.body).type === "BlockStatement" && (n2.body.some((e21) => e21.type !== "EmptyStatement") || rC(n2, iC.Dangling))) && (e20.body.type === "BlockStatement" || e20.body.type === "ArrowFunctionExpression" && xC(e20.body, true) || e20.body.type === "ObjectExpression" || e20.body.type === "ArrayExpression" || !t2 && (fC(e20.body) || e20.body.type === "ConditionalExpression") || oC(e20.body)) || e20.type === "DoExpression" || e20.type === "ModuleExpression";
  var n2;
}
var wC = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "ImportExpression", u2 = cC(r2);
  if (u2.length === 0)
    return ["(", ZE(e20, t2, true), ")"];
  if (function(e21) {
    return e21.length === 2 && e21[0].type === "ArrowFunctionExpression" && nC(e21[0]).length === 0 && e21[0].body.type === "BlockStatement" && e21[1].type === "ArrayExpression" && !e21.some((e22) => rC(e22));
  }(u2))
    return ["(", n2(["arguments", 0]), ", ", n2(["arguments", 1]), ")"];
  let o2 = false, s2 = false;
  const a2 = u2.length - 1, c2 = [];
  lC(e20, (e21, r3) => {
    const i3 = e21.getNode(), u3 = [n2()];
    r3 === a2 || (pC(i3, t2) ? (r3 === 0 && (s2 = true), o2 = true, u3.push(",", mC, mC)) : u3.push(",", gC)), c2.push(u3);
  });
  const l2 = i2 || r2.callee && r2.callee.type === "Import" || !aC(t2, "all") ? "" : ",";
  function p2() {
    return DC(["(", EC([gC, ...c2]), l2, gC, ")"], {shouldBreak: true});
  }
  if (o2 || e20.getParentNode().type !== "Decorator" && uC(u2))
    return p2();
  const f2 = function(e21) {
    if (e21.length !== 2)
      return false;
    const [t3, n3] = e21;
    if (t3.type === "ModuleExpression" && function(e22) {
      return e22.type === "ObjectExpression" && e22.properties.length === 1 && hC(e22.properties[0]) && e22.properties[0].key.type === "Identifier" && e22.properties[0].key.name === "type" && dC(e22.properties[0].value) && e22.properties[0].value.value === "module";
    }(n3))
      return true;
    return !rC(t3) && (t3.type === "FunctionExpression" || t3.type === "ArrowFunctionExpression" && t3.body.type === "BlockStatement") && n3.type !== "FunctionExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "ConditionalExpression" && !xC(n3);
  }(u2), d2 = function(e21, t3) {
    const n3 = eC(e21), r3 = tC(e21);
    return !rC(n3, iC.Leading) && !rC(n3, iC.Trailing) && xC(n3) && (!r3 || r3.type !== n3.type) && (e21.length !== 2 || r3.type !== "ArrowFunctionExpression" || n3.type !== "ArrayExpression") && !(e21.length > 1 && n3.type === "ArrayExpression" && SC(n3, t3));
  }(u2, t2);
  if (f2 || d2) {
    if (f2 ? c2.slice(1).some(vC) : c2.slice(0, -1).some(vC))
      return p2();
    let t3 = [];
    try {
      e20.try(() => {
        lC(e20, (e21, r3) => {
          f2 && r3 === 0 && (t3 = [[n2([], {expandFirstArg: true}), c2.length > 1 ? "," : "", s2 ? mC : gC, s2 ? mC : ""], ...c2.slice(1)]), d2 && r3 === a2 && (t3 = [...c2.slice(0, -1), n2([], {expandLastArg: true})]);
        });
      });
    } catch (e21) {
      if (e21 instanceof FC)
        return p2();
      throw e21;
    }
    return [c2.some(vC) ? AC : "", CC([["(", ...t3, ")"], f2 ? ["(", DC(t3[0], {shouldBreak: true}), ...t3.slice(1), ")"] : ["(", ...c2.slice(0, -1), DC(eC(t3), {shouldBreak: true}), ")"], p2()])];
  }
  const h2 = ["(", EC([yC, ...c2]), bC(l2), yC, ")"];
  return sC(e20) ? h2 : DC(h2, {shouldBreak: c2.some(vC) || o2});
};
const {builders: {softline: TC, group: BC, indent: NC, label: kC}} = eu$1, {isNumericLiteral: PC, isMemberExpression: OC, isCallExpression: IC} = Gh, {printOptionalToken: LC} = BE;
function jC(e20, t2, n2) {
  const r2 = n2("property"), i2 = e20.getValue(), u2 = LC(e20);
  return i2.computed ? !i2.property || PC(i2.property) ? [u2, "[", r2, "]"] : BC([u2, "[", NC([TC, r2]), TC, "]"]) : [u2, ".", r2];
}
var _C = {printMemberExpression: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = e20.getParentNode();
  let u2, o2 = 0;
  do {
    u2 = e20.getParentNode(o2), o2++;
  } while (u2 && (OC(u2) || u2.type === "TSNonNullExpression"));
  const s2 = n2("object"), a2 = jC(e20, t2, n2), c2 = u2 && (u2.type === "NewExpression" || u2.type === "BindExpression" || u2.type === "AssignmentExpression" && u2.left.type !== "Identifier") || r2.computed || r2.object.type === "Identifier" && r2.property.type === "Identifier" && !OC(i2) || (i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator") && (IC(r2.object) && r2.object.arguments.length > 0 || r2.object.type === "TSNonNullExpression" && IC(r2.object.expression) && r2.object.expression.arguments.length > 0 || s2.label === "member-chain");
  return kC(s2.label === "member-chain" ? "member-chain" : "member", [s2, c2 ? a2 : BC(NC([TC, a2]))]);
}, printMemberLookup: jC};
const {printComments: MC} = Wf, {getLast: RC, isNextLineEmptyAfterIndex: $C, getNextNonSpaceNonCommentCharacterIndex: VC} = yi$2, {isCallExpression: WC, isMemberExpression: qC, isFunctionOrArrowExpression: UC, isLongCurriedCallExpression: zC, isMemberish: GC, isNumericLiteral: HC, isSimpleCallArgument: JC, hasComment: XC, CommentCheckFlags: YC, isNextLineEmpty: KC} = Gh, {locEnd: QC} = zc, {builders: {join: ZC, hardline: eb, group: tb, indent: nb, conditionalGroup: rb, breakParent: ib, label: ub}, utils: {willBreak: ob}} = eu$1, {printMemberLookup: sb} = _C, {printOptionalToken: ab, printFunctionTypeParameters: cb, printBindExpressionCallee: lb} = BE;
var pb = function(e20, t2, n2) {
  const r2 = e20.getParentNode(), i2 = !r2 || r2.type === "ExpressionStatement", u2 = [];
  function o2(e21) {
    const {originalText: n3} = t2, r3 = VC(n3, e21, QC);
    return n3.charAt(r3) === ")" ? r3 !== false && $C(n3, r3 + 1) : KC(e21, t2);
  }
  function s2(e21) {
    const r3 = e21.getValue();
    WC(r3) && (GC(r3.callee) || WC(r3.callee)) ? (u2.unshift({node: r3, printed: [MC(e21, [ab(e21), cb(e21, t2, n2), wC(e21, t2, n2)], t2), o2(r3) ? eb : ""]}), e21.call((e22) => s2(e22), "callee")) : GC(r3) ? (u2.unshift({node: r3, needsParens: Qy(e21, t2), printed: MC(e21, qC(r3) ? sb(e21, t2, n2) : lb(e21, t2, n2), t2)}), e21.call((e22) => s2(e22), "object")) : r3.type === "TSNonNullExpression" ? (u2.unshift({node: r3, printed: MC(e21, "!", t2)}), e21.call((e22) => s2(e22), "expression")) : u2.unshift({node: r3, printed: n2()});
  }
  const a2 = e20.getValue();
  u2.unshift({node: a2, printed: [ab(e20), cb(e20, t2, n2), wC(e20, t2, n2)]}), a2.callee && e20.call((e21) => s2(e21), "callee");
  const c2 = [];
  let l2 = [u2[0]], p2 = 1;
  for (; p2 < u2.length && (u2[p2].node.type === "TSNonNullExpression" || WC(u2[p2].node) || qC(u2[p2].node) && u2[p2].node.computed && HC(u2[p2].node.property)); ++p2)
    l2.push(u2[p2]);
  if (!WC(u2[0].node))
    for (; p2 + 1 < u2.length && (GC(u2[p2].node) && GC(u2[p2 + 1].node)); ++p2)
      l2.push(u2[p2]);
  c2.push(l2), l2 = [];
  let f2 = false;
  for (; p2 < u2.length; ++p2) {
    if (f2 && GC(u2[p2].node)) {
      if (u2[p2].node.computed && HC(u2[p2].node.property)) {
        l2.push(u2[p2]);
        continue;
      }
      c2.push(l2), l2 = [], f2 = false;
    }
    (WC(u2[p2].node) || u2[p2].node.type === "ImportExpression") && (f2 = true), l2.push(u2[p2]), XC(u2[p2].node, YC.Trailing) && (c2.push(l2), l2 = [], f2 = false);
  }
  function d2(e21) {
    return /^[A-Z]|^[$_]+$/.test(e21);
  }
  l2.length > 0 && c2.push(l2);
  const h2 = c2.length >= 2 && !XC(c2[1][0].node) && function(e21) {
    const n3 = e21[1].length > 0 && e21[1][0].node.computed;
    if (e21[0].length === 1) {
      const r4 = e21[0][0].node;
      return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || i2 && function(e22) {
        return e22.length <= t2.tabWidth;
      }(r4.name) || n3);
    }
    const r3 = RC(e21[0]).node;
    return qC(r3) && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
  }(c2);
  function g2(e21) {
    const t3 = e21.map((e22) => e22.printed);
    return e21.length > 0 && RC(e21).needsParens ? ["(", ...t3, ")"] : t3;
  }
  const m2 = c2.map(g2), y2 = m2, D2 = h2 ? 3 : 2, E2 = c2.flat(), C2 = E2.slice(1, -1).some((e21) => XC(e21.node, YC.Leading)) || E2.slice(0, -1).some((e21) => XC(e21.node, YC.Trailing)) || c2[D2] && XC(c2[D2][0].node, YC.Leading);
  if (c2.length <= D2 && !C2)
    return zC(e20) ? y2 : tb(y2);
  const b2 = RC(c2[h2 ? 1 : 0]).node, A2 = !WC(b2) && o2(b2), v2 = [g2(c2[0]), h2 ? c2.slice(1, 2).map(g2) : "", A2 ? eb : "", function(e21) {
    return e21.length === 0 ? "" : nb(tb([eb, ZC(eb, e21.map(g2))]));
  }(c2.slice(h2 ? 2 : 1))], F2 = u2.map(({node: e21}) => e21).filter(WC);
  let S2;
  return S2 = C2 || F2.length > 2 && F2.some((e21) => !e21.arguments.every((e22) => JC(e22, 0))) || m2.slice(0, -1).some(ob) || function() {
    const e21 = RC(RC(c2)).node, t3 = RC(m2);
    return WC(e21) && ob(t3) && F2.slice(0, -1).some((e22) => e22.arguments.some(UC));
  }() ? tb(v2) : [ob(y2) || A2 ? ib : "", rb([y2, v2])], ub("member-chain", S2);
};
const {builders: {join: fb, group: db}} = eu$1, {getCallArguments: hb, hasFlowAnnotationComment: gb, isCallExpression: mb, isMemberish: yb, isStringLiteral: Db, isTemplateOnItsOwnLine: Eb, isTestCall: Cb, iterateCallArgumentsPath: bb} = Gh, {printOptionalToken: Ab, printFunctionTypeParameters: vb} = BE;
var Fb = {printCallExpression: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = r2.type === "NewExpression", o2 = r2.type === "ImportExpression", s2 = Ab(e20), a2 = hb(r2);
  if (a2.length > 0 && (!o2 && !u2 && function(e21, t3) {
    if (e21.callee.type !== "Identifier")
      return false;
    if (e21.callee.name === "require")
      return true;
    if (e21.callee.name === "define") {
      const n3 = hb(e21);
      return t3.type === "ExpressionStatement" && (n3.length === 1 || n3.length === 2 && n3[0].type === "ArrayExpression" || n3.length === 3 && Db(n3[0]) && n3[1].type === "ArrayExpression");
    }
    return false;
  }(r2, i2) || a2.length === 1 && Eb(a2[0], t2.originalText) || !u2 && Cb(r2, i2))) {
    const r3 = [];
    return bb(e20, () => {
      r3.push(n2());
    }), [u2 ? "new " : "", n2("callee"), s2, vb(e20, t2, n2), "(", fb(", ", r3), ")"];
  }
  const c2 = (t2.parser === "babel" || t2.parser === "babel-flow") && r2.callee && r2.callee.type === "Identifier" && gb(r2.callee.trailingComments);
  if (c2 && (r2.callee.trailingComments[0].printed = true), !o2 && !u2 && yb(r2.callee) && !e20.call((e21) => Qy(e21, t2), "callee"))
    return pb(e20, t2, n2);
  const l2 = [u2 ? "new " : "", o2 ? "import" : n2("callee"), s2, c2 ? `/*:: ${r2.callee.trailingComments[0].value.slice(2).trim()} */` : "", vb(e20, t2, n2), wC(e20, t2, n2)];
  return o2 || mb(r2.callee) ? db(l2) : l2;
}};
const {isNonEmptyArray: Sb, getStringWidth: xb} = yi$2, {builders: {line: wb, group: Tb, indent: Bb, indentIfBreak: Nb}, utils: {cleanDoc: kb, willBreak: Pb}} = eu$1, {hasLeadingOwnLineComment: Ob, isBinaryish: Ib, isStringLiteral: Lb, isLiteral: jb, isNumericLiteral: _b, isCallExpression: Mb, isMemberExpression: Rb, getCallArguments: $b, rawText: Vb, hasComment: Wb, isSignedNumericLiteral: qb, isObjectProperty: Ub} = Gh, {shouldInlineLogicalExpression: zb} = kD, {printCallExpression: Gb} = Fb;
function Hb(e20, t2, n2, r2, i2, u2) {
  const o2 = function(e21, t3, n3, r3, i3) {
    const u3 = e21.getValue(), o3 = u3[i3];
    if (!o3)
      return "only-left";
    const s3 = !Jb(o3);
    if (e21.match(Jb, Xb, (e22) => !s3 || e22.type !== "ExpressionStatement" && e22.type !== "VariableDeclaration"))
      return s3 ? o3.type === "ArrowFunctionExpression" && o3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
    if (!s3 && Jb(o3.right) || Ob(t3.originalText, o3))
      return "break-after-operator";
    if (o3.type === "CallExpression" && o3.callee.name === "require" || t3.parser === "json5" || t3.parser === "json")
      return "never-break-after-operator";
    if (function(e22) {
      if (Xb(e22)) {
        const t4 = e22.left || e22.id;
        return t4.type === "ObjectPattern" && t4.properties.length > 2 && t4.properties.some((e23) => Ub(e23) && (!e23.shorthand || e23.value && e23.value.type === "AssignmentPattern"));
      }
      return false;
    }(u3) || function(e22) {
      const t4 = function(e23) {
        if (function(e24) {
          return e24.type === "TSTypeAliasDeclaration" || e24.type === "TypeAlias";
        }(e23) && e23.typeParameters && e23.typeParameters.params)
          return e23.typeParameters.params;
        return null;
      }(e22);
      if (Sb(t4)) {
        const n4 = e22.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
        if (t4.length > 1 && t4.some((e23) => e23[n4] || e23.default))
          return true;
      }
      return false;
    }(u3) || function(e22) {
      if (e22.type !== "VariableDeclarator")
        return false;
      const {typeAnnotation: t4} = e22.id;
      if (!t4 || !t4.typeAnnotation)
        return false;
      const n4 = Yb(t4.typeAnnotation);
      return Sb(n4) && n4.length > 1 && n4.some((e23) => Sb(Yb(e23)) || e23.type === "TSConditionalType");
    }(u3))
      return "break-lhs";
    const a2 = function(e22, t4, n4) {
      if (!Ub(e22))
        return false;
      t4 = kb(t4);
      const r4 = 3;
      return typeof t4 == "string" && xb(t4) < n4.tabWidth + r4;
    }(u3, r3, t3);
    if (e21.call(() => function(e22, t4, n4, r4) {
      const i4 = e22.getValue();
      if (Ib(i4) && !zb(i4))
        return true;
      switch (i4.type) {
        case "StringLiteralTypeAnnotation":
        case "SequenceExpression":
          return true;
        case "ConditionalExpression": {
          const {test: e23} = i4;
          return Ib(e23) && !zb(e23);
        }
        case "ClassExpression":
          return Sb(i4.decorators);
      }
      if (r4)
        return false;
      let u4 = i4;
      const o4 = [];
      for (; ; )
        if (u4.type === "UnaryExpression")
          u4 = u4.argument, o4.push("argument");
        else {
          if (u4.type !== "TSNonNullExpression")
            break;
          u4 = u4.expression, o4.push("expression");
        }
      if (Lb(u4) || e22.call(() => Kb(e22, t4, n4), ...o4))
        return true;
      return false;
    }(e21, t3, n3, a2), i3))
      return "break-after-operator";
    if (a2 || o3.type === "TemplateLiteral" || o3.type === "TaggedTemplateExpression" || o3.type === "BooleanLiteral" || _b(o3) || o3.type === "ClassExpression")
      return "never-break-after-operator";
    return "fluid";
  }(e20, t2, n2, r2, u2), s2 = n2(u2, {assignmentLayout: o2});
  switch (o2) {
    case "break-after-operator":
      return Tb([Tb(r2), i2, Tb(Bb([wb, s2]))]);
    case "never-break-after-operator":
      return Tb([Tb(r2), i2, " ", s2]);
    case "fluid": {
      const e21 = Symbol("assignment");
      return Tb([Tb(r2), i2, Tb(Bb(wb), {id: e21}), Nb(s2, {groupId: e21})]);
    }
    case "break-lhs":
      return Tb([r2, i2, " ", Tb(s2)]);
    case "chain":
      return [Tb(r2), i2, wb, s2];
    case "chain-tail":
      return [Tb(r2), i2, Bb([wb, s2])];
    case "chain-tail-arrow-chain":
      return [Tb(r2), i2, s2];
    case "only-left":
      return r2;
  }
}
function Jb(e20) {
  return e20.type === "AssignmentExpression";
}
function Xb(e20) {
  return Jb(e20) || e20.type === "VariableDeclarator";
}
function Yb(e20) {
  return function(e21) {
    return e21.type === "TSTypeReference" || e21.type === "GenericTypeAnnotation";
  }(e20) && e20.typeParameters && e20.typeParameters.params ? e20.typeParameters.params : null;
}
function Kb(e20, t2, n2, r2 = false) {
  const i2 = e20.getValue(), u2 = () => Kb(e20, t2, n2, true);
  if (i2.type === "TSNonNullExpression")
    return e20.call(u2, "expression");
  if (Mb(i2)) {
    if (Gb(e20, t2, n2).label === "member-chain")
      return false;
    const r3 = $b(i2);
    return !!(r3.length === 0 || r3.length === 1 && function(e21, {printWidth: t3}) {
      if (Wb(e21))
        return false;
      const n3 = 0.25 * t3;
      if (e21.type === "ThisExpression" || e21.type === "Identifier" && e21.name.length <= n3 || qb(e21) && !Wb(e21.argument))
        return true;
      const r4 = e21.type === "Literal" && "regex" in e21 && e21.regex.pattern || e21.type === "RegExpLiteral" && e21.pattern;
      if (r4)
        return r4.length <= n3;
      if (Lb(e21))
        return Vb(e21).length <= n3;
      if (e21.type === "TemplateLiteral")
        return e21.expressions.length === 0 && e21.quasis[0].value.raw.length <= n3 && !e21.quasis[0].value.raw.includes("\n");
      return jb(e21);
    }(r3[0], t2)) && (!function(e21, t3) {
      const n3 = function(e22) {
        return e22.typeParameters && e22.typeParameters.params || e22.typeArguments && e22.typeArguments.params;
      }(e21);
      if (Sb(n3)) {
        if (n3.length > 1)
          return true;
        if (n3.length === 1) {
          const e22 = n3[0];
          if (e22.type === "TSUnionType" || e22.type === "UnionTypeAnnotation" || e22.type === "TSIntersectionType" || e22.type === "IntersectionTypeAnnotation")
            return true;
        }
        const r4 = e21.typeParameters ? "typeParameters" : "typeArguments";
        if (Pb(t3(r4)))
          return true;
      }
      return false;
    }(i2, n2) && e20.call(u2, "callee"));
  }
  return Rb(i2) ? e20.call(u2, "object") : r2 && (i2.type === "Identifier" || i2.type === "ThisExpression");
}
var Qb = {printVariableDeclarator: function(e20, t2, n2) {
  return Hb(e20, t2, n2, n2("id"), " =", "init");
}, printAssignmentExpression: function(e20, t2, n2) {
  const r2 = e20.getValue();
  return Hb(e20, t2, n2, n2("left"), [" ", r2.operator], "right");
}, printAssignment: Hb};
const {getNextNonSpaceNonCommentCharacter: Zb} = yi$2, {printDanglingComments: eA} = Wf, {builders: {line: tA, hardline: nA, softline: rA, group: iA, indent: uA, ifBreak: oA}, utils: {removeLines: sA, willBreak: aA}} = eu$1, {getFunctionParameters: cA, iterateFunctionParametersPath: lA, isSimpleType: pA, isTestCall: fA, isTypeAnnotationAFunction: dA, isObjectType: hA, isObjectTypePropertyAFunction: gA, hasRestParameter: mA, shouldPrintComma: yA, hasComment: DA, isNextLineEmpty: EA} = Gh, {locEnd: CA} = zc, {ArgExpansionBailout: bA} = bo$2, {printFunctionTypeParameters: AA} = BE;
function vA(e20) {
  if (!e20)
    return false;
  const t2 = cA(e20);
  if (t2.length !== 1)
    return false;
  const [n2] = t2;
  return !DA(n2) && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && hA(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && hA(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
}
var FA = {printFunctionParameters: function(e20, t2, n2, r2, i2) {
  const u2 = e20.getValue(), o2 = cA(u2), s2 = i2 ? AA(e20, n2, t2) : "";
  if (o2.length === 0)
    return [s2, "(", eA(e20, n2, true, (e21) => Zb(n2.originalText, e21, CA) === ")"), ")"];
  const a2 = e20.getParentNode(), c2 = fA(a2), l2 = vA(u2), p2 = [];
  if (lA(e20, (e21, r3) => {
    const i3 = r3 === o2.length - 1;
    i3 && u2.rest && p2.push("..."), p2.push(t2()), i3 || (p2.push(","), c2 || l2 ? p2.push(" ") : EA(o2[r3], n2) ? p2.push(nA, nA) : p2.push(tA));
  }), r2) {
    if (aA(s2) || aA(p2))
      throw new bA();
    return iA([sA(s2), "(", sA(p2), ")"]);
  }
  const f2 = o2.every((e21) => !e21.decorators);
  return l2 && f2 || c2 ? [s2, "(", ...p2, ")"] : (gA(a2) || dA(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === u2) && o2.length === 1 && o2[0].name === null && u2.this !== o2[0] && o2[0].typeAnnotation && u2.typeParameters === null && pA(o2[0].typeAnnotation) && !u2.rest ? n2.arrowParens === "always" ? ["(", ...p2, ")"] : p2 : [s2, "(", uA([rA, ...p2]), oA(!mA(u2) && yA(n2, "all") ? "," : ""), rA, ")"];
}, shouldHugFunctionParameters: vA, shouldGroupFunctionParameters: function(e20, t2) {
  const n2 = function(e21) {
    let t3;
    return e21.returnType ? (t3 = e21.returnType, t3.typeAnnotation && (t3 = t3.typeAnnotation)) : e21.typeAnnotation && (t3 = e21.typeAnnotation), t3;
  }(e20);
  if (!n2)
    return false;
  const r2 = e20.typeParameters && e20.typeParameters.params;
  if (r2) {
    if (r2.length > 1)
      return false;
    if (r2.length === 1) {
      const e21 = r2[0];
      if (e21.constraint || e21.default)
        return false;
    }
  }
  return cA(e20).length === 1 && (hA(n2) || aA(t2));
}};
const {printComments: SA, printDanglingComments: xA} = Wf, {getLast: wA} = yi$2, {builders: {group: TA, join: BA, line: NA, softline: kA, indent: PA, align: OA, ifBreak: IA}} = eu$1, {locStart: LA} = zc, {isSimpleType: jA, isObjectType: _A, hasLeadingOwnLineComment: MA, isObjectTypePropertyAFunction: RA, shouldPrintComma: $A} = Gh, {printAssignment: VA} = Qb, {printFunctionParameters: WA, shouldGroupFunctionParameters: qA} = FA, {printArrayItems: UA} = QE;
function zA(e20) {
  if (jA(e20) || _A(e20))
    return true;
  if (e20.type === "UnionTypeAnnotation" || e20.type === "TSUnionType") {
    const t2 = e20.types.filter((e21) => e21.type === "VoidTypeAnnotation" || e21.type === "TSVoidKeyword" || e21.type === "NullLiteralTypeAnnotation" || e21.type === "TSNullKeyword").length, n2 = e20.types.some((e21) => e21.type === "ObjectTypeAnnotation" || e21.type === "TSTypeLiteral" || e21.type === "GenericTypeAnnotation" || e21.type === "TSTypeReference");
    if (e20.types.length - 1 === t2 && n2)
      return true;
  }
  return false;
}
var GA = {printOpaqueType: function(e20, t2, n2) {
  const r2 = t2.semi ? ";" : "", i2 = e20.getValue(), u2 = [];
  return u2.push("opaque type ", n2("id"), n2("typeParameters")), i2.supertype && u2.push(": ", n2("supertype")), i2.impltype && u2.push(" = ", n2("impltype")), u2.push(r2), u2;
}, printTypeAlias: function(e20, t2, n2) {
  const r2 = t2.semi ? ";" : "", i2 = e20.getValue(), u2 = [];
  i2.declare && u2.push("declare "), u2.push("type ", n2("id"), n2("typeParameters"));
  const o2 = i2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [VA(e20, t2, n2, u2, " =", o2), r2];
}, printIntersectionType: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = e20.map(n2, "types"), u2 = [];
  let o2 = false;
  for (let e21 = 0; e21 < i2.length; ++e21)
    e21 === 0 ? u2.push(i2[e21]) : _A(r2.types[e21 - 1]) && _A(r2.types[e21]) ? u2.push([" & ", o2 ? PA(i2[e21]) : i2[e21]]) : _A(r2.types[e21 - 1]) || _A(r2.types[e21]) ? (e21 > 1 && (o2 = true), u2.push(" & ", e21 > 1 ? PA(i2[e21]) : i2[e21])) : u2.push(PA([" &", NA, i2[e21]]));
  return TA(u2);
}, printUnionType: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = !(i2.type === "TypeParameterInstantiation" || i2.type === "TSTypeParameterInstantiation" || i2.type === "GenericTypeAnnotation" || i2.type === "TSTypeReference" || i2.type === "TSTypeAssertion" || i2.type === "TupleTypeAnnotation" || i2.type === "TSTupleType" || i2.type === "FunctionTypeParam" && !i2.name && e20.getParentNode(1).this !== i2 || (i2.type === "TypeAlias" || i2.type === "VariableDeclarator" || i2.type === "TSTypeAliasDeclaration") && MA(t2.originalText, r2)), o2 = zA(r2), s2 = e20.map((e21) => {
    let r3 = n2();
    return o2 || (r3 = OA(2, r3)), SA(e21, r3, t2);
  }, "types");
  if (o2)
    return BA(" | ", s2);
  const a2 = u2 && !MA(t2.originalText, r2), c2 = [IA([a2 ? NA : "", "| "]), BA([NA, "| "], s2)];
  return Qy(e20, t2) ? TA([PA(c2), kA]) : i2.type === "TupleTypeAnnotation" && i2.types.length > 1 || i2.type === "TSTupleType" && i2.elementTypes.length > 1 ? TA([PA([IA(["(", kA]), c2]), kA, IA(")")]) : TA(u2 ? PA(c2) : c2);
}, printFunctionType: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [], u2 = e20.getParentNode(0), o2 = e20.getParentNode(1), s2 = e20.getParentNode(2);
  let a2 = r2.type === "TSFunctionType" || !((u2.type === "ObjectTypeProperty" || u2.type === "ObjectTypeInternalSlot") && !u2.variance && !u2.optional && LA(u2) === LA(r2) || u2.type === "ObjectTypeCallProperty" || s2 && s2.type === "DeclareFunction"), c2 = a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation");
  const l2 = c2 && a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation") && o2.type === "ArrowFunctionExpression";
  RA(u2) && (a2 = true, c2 = true), l2 && i2.push("(");
  const p2 = WA(e20, n2, t2, false, true), f2 = r2.returnType || r2.predicate || r2.typeAnnotation ? [a2 ? " => " : ": ", n2("returnType"), n2("predicate"), n2("typeAnnotation")] : "", d2 = qA(r2, f2);
  return i2.push(d2 ? TA(p2) : p2), f2 && i2.push(f2), l2 && i2.push(")"), TA(i2);
}, printTupleType: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "TSTupleType" ? "elementTypes" : "types", u2 = r2[i2].length > 0 && wA(r2[i2]).type === "TSRestType";
  return TA(["[", PA([kA, UA(e20, t2, i2, n2)]), IA($A(t2, "all") && !u2 ? "," : ""), xA(e20, t2, true), kA, "]"]);
}, printIndexedAccessType: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "OptionalIndexedAccessType" && r2.optional ? "?.[" : "[";
  return [n2("objectType"), i2, n2("indexType"), "]"];
}, shouldHugType: zA};
const {printDanglingComments: HA} = Wf, {builders: {join: JA, line: XA, hardline: YA, softline: KA, group: QA, indent: ZA, ifBreak: ev}} = eu$1, {isTestCall: tv, hasComment: nv, CommentCheckFlags: rv, isTSXFile: iv, shouldPrintComma: uv, getFunctionParameters: ov} = Gh, {createGroupIdMapper: sv} = yi$2, {shouldHugType: av} = GA, cv = sv("typeParameters");
function lv(e20, t2) {
  const n2 = e20.getValue();
  if (!nv(n2, rv.Dangling))
    return "";
  const r2 = !nv(n2, rv.Line), i2 = HA(e20, t2, r2);
  return r2 ? i2 : [i2, YA];
}
var pv = {printTypeParameter: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [], u2 = e20.getParentNode();
  return u2.type === "TSMappedType" ? (i2.push("[", n2("name")), r2.constraint && i2.push(" in ", n2("constraint")), u2.nameType && i2.push(" as ", e20.callParent(() => n2("nameType"))), i2.push("]"), i2) : (r2.variance && i2.push(n2("variance")), i2.push(n2("name")), r2.bound && i2.push(": ", n2("bound")), r2.constraint && i2.push(" extends ", n2("constraint")), r2.default && i2.push(" = ", n2("default")), i2);
}, printTypeParameters: function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  if (!i2[r2])
    return "";
  if (!Array.isArray(i2[r2]))
    return n2(r2);
  const u2 = e20.getNode(2);
  if (u2 && tv(u2) || i2[r2].length === 0 || i2[r2].length === 1 && (av(i2[r2][0]) || i2[r2][0].type === "NullableTypeAnnotation"))
    return ["<", JA(", ", e20.map(n2, r2)), lv(e20, t2), ">"];
  const o2 = i2.type === "TSTypeParameterInstantiation" ? "" : ov(i2).length === 1 && iv(t2) && !i2[r2][0].constraint && e20.getParentNode().type === "ArrowFunctionExpression" ? "," : uv(t2, "all") ? ev(",") : "";
  return QA(["<", ZA([KA, JA([",", XA], e20.map(n2, r2))]), o2, KA, ">"], {id: cv(i2)});
}, getTypeParametersGroupId: cv};
const {printComments: fv} = Wf, {printString: dv, printNumber: hv} = yi$2, {isNumericLiteral: gv, isSimpleNumber: mv, isStringLiteral: yv, isStringPropSafeToUnquote: Dv, rawText: Ev} = Gh, {printAssignment: Cv} = Qb, bv = new WeakMap();
function Av(e20, t2, n2) {
  const r2 = e20.getNode();
  if (r2.computed)
    return ["[", n2("key"), "]"];
  const i2 = e20.getParentNode(), {key: u2} = r2;
  if (r2.type === "ClassPrivateProperty" && u2.type === "Identifier")
    return ["#", n2("key")];
  if (t2.quoteProps === "consistent" && !bv.has(i2)) {
    const e21 = (i2.properties || i2.body || i2.members).some((e22) => !e22.computed && e22.key && yv(e22.key) && !Dv(e22, t2));
    bv.set(i2, e21);
  }
  if ((u2.type === "Identifier" || gv(u2) && mv(hv(Ev(u2))) && String(u2.value) === hv(Ev(u2)) && t2.parser !== "typescript" && t2.parser !== "babel-ts") && (t2.parser === "json" || t2.quoteProps === "consistent" && bv.get(i2))) {
    const n3 = dv(JSON.stringify(u2.type === "Identifier" ? u2.name : u2.value.toString()), t2);
    return e20.call((e21) => fv(e21, n3, t2), "key");
  }
  return Dv(r2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !bv.get(i2)) ? e20.call((e21) => fv(e21, /^\d/.test(u2.value) ? hv(u2.value) : u2.value, t2), "key") : n2("key");
}
var vv = {printProperty: function(e20, t2, n2) {
  return e20.getValue().shorthand ? n2("value") : Cv(e20, t2, n2, Av(e20, t2, n2), ":", "value");
}, printPropertyKey: Av};
const {printDanglingComments: Fv, printCommentsSeparately: Sv} = Wf, {getNextNonSpaceNonCommentCharacterIndex: xv} = yi$2, {builders: {line: wv, softline: Tv, group: Bv, indent: Nv, ifBreak: kv, hardline: Pv, join: Ov, indentIfBreak: Iv}, utils: {removeLines: Lv, willBreak: jv}} = eu$1, {ArgExpansionBailout: _v} = bo$2, {getFunctionParameters: Mv, hasLeadingOwnLineComment: Rv, isFlowAnnotationComment: $v, isJsxNode: Vv, isTemplateOnItsOwnLine: Wv, shouldPrintComma: qv, startsWithNoLookaheadToken: Uv, isBinaryish: zv, isLineComment: Gv, hasComment: Hv, getComments: Jv, CommentCheckFlags: Xv, isCallLikeExpression: Yv, isCallExpression: Kv, getCallArguments: Qv, hasNakedLeftSide: Zv, getLeftSide: eF} = Gh, {locEnd: tF} = zc, {printFunctionParameters: nF, shouldGroupFunctionParameters: rF} = FA, {printPropertyKey: iF} = vv, {printFunctionTypeParameters: uF} = BE;
function oF(e20, t2, n2) {
  const r2 = e20.getNode(), i2 = nF(e20, n2, t2), u2 = aF(e20, n2, t2), o2 = rF(r2, u2), s2 = [uF(e20, t2, n2), Bv([o2 ? Bv(i2) : i2, u2])];
  return r2.body ? s2.push(" ", n2("body")) : s2.push(t2.semi ? ";" : ""), s2;
}
function sF(e20, t2) {
  if (t2.arrowParens === "always")
    return false;
  if (t2.arrowParens === "avoid") {
    return function(e21) {
      const t3 = Mv(e21);
      return !(t3.length !== 1 || e21.typeParameters || Hv(e21, Xv.Dangling) || t3[0].type !== "Identifier" || t3[0].typeAnnotation || Hv(t3[0]) || t3[0].optional || e21.predicate || e21.returnType);
    }(e20.getValue());
  }
  return false;
}
function aF(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2("returnType");
  if (r2.returnType && $v(n2.originalText, r2.returnType))
    return [" /*: ", i2, " */"];
  const u2 = [i2];
  return r2.returnType && r2.returnType.typeAnnotation && u2.unshift(": "), r2.predicate && u2.push(r2.returnType ? " " : ": ", t2("predicate")), u2;
}
function cF(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
  r2.argument && (!function(e21, t3) {
    if (Rv(e21.originalText, t3))
      return true;
    if (Zv(t3)) {
      let n3, r3 = t3;
      for (; n3 = eF(r3); )
        if (r3 = n3, Rv(e21.originalText, r3))
          return true;
    }
    return false;
  }(t2, r2.argument) ? zv(r2.argument) || r2.argument.type === "SequenceExpression" ? u2.push(Bv([kv(" (", " "), Nv([Tv, n2("argument")]), Tv, kv(")")])) : u2.push(" ", n2("argument")) : u2.push([" (", Nv([Pv, n2("argument")]), Pv, ")"]));
  const o2 = Jv(r2), s2 = Ln$2(o2), a2 = s2 && Gv(s2);
  return a2 && u2.push(i2), Hv(r2, Xv.Dangling) && u2.push(" ", Fv(e20, t2, true)), a2 || u2.push(i2), u2;
}
var lF = {printFunction: function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  let u2 = false;
  if ((i2.type === "FunctionDeclaration" || i2.type === "FunctionExpression") && r2 && r2.expandLastArg) {
    const t3 = e20.getParentNode();
    Kv(t3) && Qv(t3).length > 1 && (u2 = true);
  }
  const o2 = [];
  i2.type === "TSDeclareFunction" && i2.declare && o2.push("declare "), i2.async && o2.push("async "), i2.generator ? o2.push("function* ") : o2.push("function "), i2.id && o2.push(t2("id"));
  const s2 = nF(e20, t2, n2, u2), a2 = aF(e20, t2, n2), c2 = rF(i2, a2);
  return o2.push(uF(e20, n2, t2), Bv([c2 ? Bv(s2) : s2, a2]), i2.body ? " " : "", t2("body")), !n2.semi || !i2.declare && i2.body || o2.push(";"), o2;
}, printArrowFunction: function(e20, t2, n2, r2) {
  let i2 = e20.getValue();
  const u2 = [], o2 = [];
  let s2 = false;
  if (function a3() {
    const c3 = function(e21, t3, n3, r3) {
      const i3 = [];
      if (e21.getValue().async && i3.push("async "), sF(e21, t3))
        i3.push(n3(["params", 0]));
      else {
        const u4 = r3 && (r3.expandLastArg || r3.expandFirstArg);
        let o3 = aF(e21, n3, t3);
        if (u4) {
          if (jv(o3))
            throw new _v();
          o3 = Bv(Lv(o3));
        }
        i3.push(Bv([nF(e21, n3, t3, u4, true), o3]));
      }
      const u3 = Fv(e21, t3, true, (e22) => {
        const n4 = xv(t3.originalText, e22, tF);
        return n4 !== false && t3.originalText.slice(n4, n4 + 2) === "=>";
      });
      return u3 && i3.push(" ", u3), i3;
    }(e20, t2, n2, r2);
    if (u2.length === 0)
      u2.push(c3);
    else {
      const {leading: n3, trailing: r3} = Sv(e20, t2);
      u2.push([n3, c3]), o2.unshift(r3);
    }
    s2 = s2 || i2.returnType && Mv(i2).length > 0 || i2.typeParameters || Mv(i2).some((e21) => e21.type !== "Identifier"), i2.body.type !== "ArrowFunctionExpression" || r2 && r2.expandLastArg ? o2.unshift(n2("body", r2)) : (i2 = i2.body, e20.call(a3, "body"));
  }(), u2.length > 1)
    return function(e21, t3, n3, r3, i3, u3) {
      const o3 = e21.getName(), s3 = e21.getParentNode(), a3 = Yv(s3) && o3 === "callee", c3 = Boolean(t3 && t3.assignmentLayout), l3 = u3.body.type !== "BlockStatement" && u3.body.type !== "ObjectExpression", p3 = a3 && l3 || t3 && t3.assignmentLayout === "chain-tail-arrow-chain", f2 = Symbol("arrow-chain");
      return Bv([Bv(Nv([a3 || c3 ? Tv : "", Bv(Ov([" =>", wv], n3), {shouldBreak: r3})]), {id: f2, shouldBreak: p3}), " =>", Iv(l3 ? Nv([wv, i3]) : [" ", i3], {groupId: f2}), a3 ? kv(Tv, "", {groupId: f2}) : ""]);
    }(e20, r2, u2, s2, o2, i2);
  const a2 = u2;
  if (a2.push(" =>"), !Rv(t2.originalText, i2.body) && (i2.body.type === "ArrayExpression" || i2.body.type === "ObjectExpression" || i2.body.type === "BlockStatement" || Vv(i2.body) || Wv(i2.body, t2.originalText) || i2.body.type === "ArrowFunctionExpression" || i2.body.type === "DoExpression"))
    return Bv([...a2, " ", o2]);
  if (i2.body.type === "SequenceExpression")
    return Bv([...a2, Bv([" (", Nv([Tv, o2]), Tv, ")"])]);
  const c2 = (r2 && r2.expandLastArg || e20.getParentNode().type === "JSXExpressionContainer") && !Hv(i2), l2 = r2 && r2.expandLastArg && qv(t2, "all"), p2 = i2.body.type === "ConditionalExpression" && !Uv(i2.body, false);
  return Bv([...a2, Bv([Nv([wv, p2 ? kv("", "(") : "", o2, p2 ? kv("", ")") : ""]), c2 ? [kv(l2 ? "," : ""), Tv] : ""])]);
}, printMethod: function(e20, t2, n2) {
  const r2 = e20.getNode(), {kind: i2} = r2, u2 = r2.value || r2, o2 = [];
  return i2 && i2 !== "init" && i2 !== "method" && i2 !== "constructor" ? (mf.ok(i2 === "get" || i2 === "set"), o2.push(i2, " ")) : u2.async && o2.push("async "), u2.generator && o2.push("*"), o2.push(iF(e20, t2, n2), r2.optional || r2.key.optional ? "?" : ""), r2 === u2 ? o2.push(oF(e20, t2, n2)) : u2.type === "FunctionExpression" ? o2.push(e20.call((e21) => oF(e21, t2, n2), "value")) : o2.push(n2("value")), o2;
}, printReturnStatement: function(e20, t2, n2) {
  return ["return", cF(e20, t2, n2)];
}, printThrowStatement: function(e20, t2, n2) {
  return ["throw", cF(e20, t2, n2)];
}, printMethodInternal: oF, shouldPrintParamsWithoutParens: sF};
const {isNonEmptyArray: pF, hasNewline: fF} = yi$2, {builders: {line: dF, hardline: hF, join: gF, breakParent: mF, group: yF}} = eu$1, {locStart: DF, locEnd: EF} = zc, {getParentExportDeclaration: CF} = Gh;
function bF(e20, t2) {
  return e20.decorators.some((e21) => fF(t2.originalText, EF(e21)));
}
function AF(e20) {
  if (e20.type !== "ExportDefaultDeclaration" && e20.type !== "ExportNamedDeclaration" && e20.type !== "DeclareExportDeclaration")
    return false;
  const t2 = e20.declaration && e20.declaration.decorators;
  return pF(t2) && DF(e20, {ignoreDecorators: true}) > DF(t2[0]);
}
var vF = {printDecorators: function(e20, t2, n2) {
  const r2 = e20.getValue(), {decorators: i2} = r2;
  if (!pF(i2) || AF(e20.getParentNode()))
    return;
  const u2 = r2.type === "ClassExpression" || r2.type === "ClassDeclaration" || bF(r2, t2);
  return [CF(e20) ? hF : u2 ? mF : "", gF(dF, e20.map(n2, "decorators")), dF];
}, printClassMemberDecorators: function(e20, t2, n2) {
  const r2 = e20.getValue();
  return yF([gF(dF, e20.map(n2, "decorators")), bF(r2, t2) ? hF : dF]);
}, printDecoratorsBeforeExport: function(e20, t2, n2) {
  return [gF(hF, e20.map(n2, "declaration", "decorators")), hF];
}, hasDecoratorsBeforeExport: AF};
const {isNonEmptyArray: FF, createGroupIdMapper: SF} = yi$2, {printComments: xF, printDanglingComments: wF} = Wf, {builders: {join: TF, line: BF, hardline: NF, softline: kF, group: PF, indent: OF, ifBreak: IF}} = eu$1, {hasComment: LF, CommentCheckFlags: jF} = Gh, {getTypeParametersGroupId: _F} = pv, {printMethod: MF} = lF, {printOptionalToken: RF, printTypeAnnotation: $F} = BE, {printPropertyKey: VF} = vv, {printAssignment: WF} = Qb, {printClassMemberDecorators: qF} = vF;
const UF = SF("heritageGroup");
function zF(e20) {
  return e20.typeParameters && !LF(e20.typeParameters, jF.Trailing | jF.Line) && !function(e21) {
    return ["superClass", "extends", "mixins", "implements"].filter((t2) => Boolean(e21[t2])).length > 1;
  }(e20);
}
function GF(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  if (!FF(i2[r2]))
    return "";
  const u2 = wF(e20, t2, true, ({marker: e21}) => e21 === r2);
  return [zF(i2) ? IF(" ", BF, {groupId: _F(i2.typeParameters)}) : BF, u2, u2 && NF, r2, PF(OF([BF, TF([",", BF], e20.map(n2, r2))]))];
}
function HF(e20, t2, n2) {
  const r2 = n2("superClass");
  return e20.getParentNode().type === "AssignmentExpression" ? PF(IF(["(", OF([kF, r2]), kF, ")"], r2)) : r2;
}
var JF = {printClass: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [];
  r2.declare && i2.push("declare "), r2.abstract && i2.push("abstract "), i2.push("class");
  const u2 = r2.id && LF(r2.id, jF.Trailing) || r2.superClass && LF(r2.superClass) || FF(r2.extends) || FF(r2.mixins) || FF(r2.implements), o2 = [], s2 = [];
  if (r2.id && o2.push(" ", n2("id")), o2.push(n2("typeParameters")), r2.superClass) {
    const r3 = ["extends ", HF(e20, t2, n2), n2("superTypeParameters")], i3 = e20.call((e21) => xF(e21, r3, t2), "superClass");
    u2 ? s2.push(BF, PF(i3)) : s2.push(" ", i3);
  } else
    s2.push(GF(e20, t2, n2, "extends"));
  if (s2.push(GF(e20, t2, n2, "mixins"), GF(e20, t2, n2, "implements")), u2) {
    let e21;
    e21 = zF(r2) ? [...o2, OF(s2)] : OF([...o2, s2]), i2.push(PF(e21, {id: UF(r2)}));
  } else
    i2.push(...o2, ...s2);
  return i2.push(" ", n2("body")), i2;
}, printClassMethod: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [];
  return FF(r2.decorators) && i2.push(qF(e20, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.readonly && i2.push("readonly "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractMethodDefinition" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), i2.push(MF(e20, t2, n2)), i2;
}, printClassProperty: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [], u2 = t2.semi ? ";" : "";
  return FF(r2.decorators) && i2.push(qF(e20, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractClassProperty" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), r2.readonly && i2.push("readonly "), r2.variance && i2.push(n2("variance")), i2.push(VF(e20, t2, n2), RF(e20), $F(e20, t2, n2)), [WF(e20, t2, n2, i2, " =", "value"), u2];
}, printHardlineAfterHeritage: function(e20) {
  return IF(NF, "", {groupId: UF(e20)});
}};
const {isNonEmptyArray: XF} = yi$2, {builders: {join: YF, line: KF, group: QF, indent: ZF, ifBreak: eS}} = eu$1, {hasComment: tS, identity: nS, CommentCheckFlags: rS} = Gh, {getTypeParametersGroupId: iS} = pv, {printTypeScriptModifiers: uS} = BE;
var oS = {printInterface: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [];
  r2.declare && i2.push("declare "), r2.type === "TSInterfaceDeclaration" && i2.push(r2.abstract ? "abstract " : "", uS(e20, t2, n2)), i2.push("interface");
  const u2 = [], o2 = [];
  r2.type !== "InterfaceTypeAnnotation" && u2.push(" ", n2("id"), n2("typeParameters"));
  const s2 = r2.typeParameters && !tS(r2.typeParameters, rS.Trailing | rS.Line);
  return XF(r2.extends) && o2.push(s2 ? eS(" ", KF, {groupId: iS(r2.typeParameters)}) : KF, "extends ", (r2.extends.length === 1 ? nS : ZF)(YF([",", KF], e20.map(n2, "extends")))), r2.id && tS(r2.id, rS.Trailing) || XF(r2.extends) ? s2 ? i2.push(QF([...u2, ZF(o2)])) : i2.push(QF(ZF([...u2, ...o2]))) : i2.push(...u2, ...o2), i2.push(" ", n2("body")), QF(i2);
}};
const {isNonEmptyArray: sS} = yi$2, {builders: {softline: aS, group: cS, indent: lS, join: pS, line: fS, ifBreak: dS, hardline: hS}} = eu$1, {printDanglingComments: gS} = Wf, {hasComment: mS, CommentCheckFlags: yS, shouldPrintComma: DS, needsHardlineAfterDanglingComment: ES} = Gh, {locStart: CS, hasSameLoc: bS} = zc, {hasDecoratorsBeforeExport: AS, printDecoratorsBeforeExport: vS} = vF;
function FS(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2.source)
    return "";
  const i2 = [];
  return xS(r2, t2) || i2.push(" from"), i2.push(" ", n2("source")), i2;
}
function SS(e20, t2, n2) {
  const r2 = e20.getValue();
  if (xS(r2, t2))
    return "";
  const i2 = [" "];
  if (sS(r2.specifiers)) {
    const u2 = [], o2 = [];
    if (e20.each(() => {
      const t3 = e20.getValue().type;
      if (t3 === "ExportNamespaceSpecifier" || t3 === "ExportDefaultSpecifier" || t3 === "ImportNamespaceSpecifier" || t3 === "ImportDefaultSpecifier")
        u2.push(n2());
      else {
        if (t3 !== "ExportSpecifier" && t3 !== "ImportSpecifier")
          throw new Error(`Unknown specifier type ${JSON.stringify(t3)}`);
        o2.push(n2());
      }
    }, "specifiers"), i2.push(pS(", ", u2)), o2.length > 0) {
      u2.length > 0 && i2.push(", ");
      o2.length > 1 || u2.length > 0 || r2.specifiers.some((e21) => mS(e21)) ? i2.push(cS(["{", lS([t2.bracketSpacing ? fS : aS, pS([",", fS], o2)]), dS(DS(t2) ? "," : ""), t2.bracketSpacing ? fS : aS, "}"])) : i2.push(["{", t2.bracketSpacing ? " " : "", ...o2, t2.bracketSpacing ? " " : "", "}"]);
    }
  } else
    i2.push("{}");
  return i2;
}
function xS(e20, t2) {
  const {type: n2, importKind: r2, source: i2, specifiers: u2} = e20;
  return n2 === "ImportDeclaration" && !sS(u2) && r2 !== "type" && !/{\s*}/.test(t2.originalText.slice(CS(e20), CS(i2)));
}
function wS(e20, t2, n2) {
  const r2 = e20.getNode();
  return sS(r2.assertions) ? [" assert {", t2.bracketSpacing ? " " : "", pS(", ", e20.map(n2, "assertions")), t2.bracketSpacing ? " " : "", "}"] : "";
}
var TS = {printImportDeclaration: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [], {importKind: o2} = r2;
  return u2.push("import"), o2 && o2 !== "value" && u2.push(" ", o2), u2.push(SS(e20, t2, n2), FS(e20, t2, n2), wS(e20, t2, n2), i2), u2;
}, printExportDeclaration: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [];
  AS(r2) && i2.push(vS(e20, t2, n2));
  const {type: u2, exportKind: o2, declaration: s2} = r2;
  return i2.push("export"), (r2.default || u2 === "ExportDefaultDeclaration") && i2.push(" default"), mS(r2, yS.Dangling) && (i2.push(" ", gS(e20, t2, true)), ES(r2) && i2.push(hS)), s2 ? i2.push(" ", n2("declaration")) : i2.push(o2 === "type" ? " type" : "", SS(e20, t2, n2), FS(e20, t2, n2), wS(e20, t2, n2)), function(e21, t3) {
    if (!t3.semi)
      return false;
    const {type: n3, declaration: r3} = e21, i3 = e21.default || n3 === "ExportDefaultDeclaration";
    if (!r3)
      return true;
    const {type: u3} = r3;
    if (i3 && u3 !== "ClassDeclaration" && u3 !== "FunctionDeclaration" && u3 !== "TSInterfaceDeclaration" && u3 !== "DeclareClass" && u3 !== "DeclareFunction" && u3 !== "TSDeclareFunction" && u3 !== "EnumDeclaration")
      return true;
    return false;
  }(r2, t2) && i2.push(";"), i2;
}, printExportAllDeclaration: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [], {exportKind: o2, exported: s2} = r2;
  return u2.push("export"), o2 === "type" && u2.push(" type"), u2.push(" *"), s2 && u2.push(" as ", n2("exported")), u2.push(FS(e20, t2, n2), wS(e20, t2, n2), i2), u2;
}, printModuleSpecifier: function(e20, t2, n2) {
  const r2 = e20.getNode(), {type: i2, importKind: u2} = r2, o2 = [];
  i2 === "ImportSpecifier" && u2 && o2.push(u2, " ");
  const s2 = i2.startsWith("Import"), a2 = s2 ? "imported" : "local", c2 = s2 ? "local" : "exported";
  let l2 = "", p2 = "";
  return i2 === "ExportNamespaceSpecifier" || i2 === "ImportNamespaceSpecifier" ? l2 = "*" : r2[a2] && (l2 = n2(a2)), !r2[c2] || r2[a2] && bS(r2[a2], r2[c2]) || (p2 = n2(c2)), o2.push(l2, l2 && p2 ? " as " : "", p2), o2;
}};
const {printDanglingComments: BS} = Wf, {builders: {line: NS, softline: kS, group: PS, indent: OS, ifBreak: IS, hardline: LS}} = eu$1, {getLast: jS, hasNewlineInRange: _S, hasNewline: MS, isNonEmptyArray: RS} = yi$2, {shouldPrintComma: $S, hasComment: VS, getComments: WS, CommentCheckFlags: qS, isNextLineEmpty: US} = Gh, {locStart: zS, locEnd: GS} = zc, {printOptionalToken: HS, printTypeAnnotation: JS} = BE, {shouldHugFunctionParameters: XS} = FA, {shouldHugType: YS} = GA, {printHardlineAfterHeritage: KS} = JF;
var QS = {printObject: function(e20, t2, n2) {
  const r2 = t2.semi ? ";" : "", i2 = e20.getValue();
  let u2;
  u2 = i2.type === "TSTypeLiteral" ? "members" : i2.type === "TSInterfaceBody" ? "body" : "properties";
  const o2 = i2.type === "ObjectTypeAnnotation", s2 = [u2];
  o2 && s2.push("indexers", "callProperties", "internalSlots");
  const a2 = s2.map((e21) => i2[e21][0]).sort((e21, t3) => zS(e21) - zS(t3))[0], c2 = e20.getParentNode(0), l2 = o2 && c2 && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass") && e20.getName() === "body", p2 = i2.type === "TSInterfaceBody" || l2 || i2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && i2.properties.some((e21) => e21.value && (e21.value.type === "ObjectPattern" || e21.value.type === "ArrayPattern")) || i2.type !== "ObjectPattern" && a2 && _S(t2.originalText, zS(i2), zS(a2)), f2 = l2 ? ";" : i2.type === "TSInterfaceBody" || i2.type === "TSTypeLiteral" ? IS(r2, ";") : ",", d2 = i2.type === "RecordExpression" ? "#{" : i2.exact ? "{|" : "{", h2 = i2.exact ? "|}" : "}", g2 = [];
  for (const t3 of s2)
    e20.each((e21) => {
      const t4 = e21.getValue();
      g2.push({node: t4, printed: n2(), loc: zS(t4)});
    }, t3);
  s2.length > 1 && g2.sort((e21, t3) => e21.loc - t3.loc);
  let m2 = [];
  const y2 = g2.map((e21) => {
    const n3 = [...m2, PS(e21.printed)];
    return m2 = [f2, NS], e21.node.type !== "TSPropertySignature" && e21.node.type !== "TSMethodSignature" && e21.node.type !== "TSConstructSignatureDeclaration" || !VS(e21.node, qS.PrettierIgnore) || m2.shift(), US(e21.node, t2) && m2.push(LS), n3;
  });
  if (i2.inexact) {
    let n3;
    if (VS(i2, qS.Dangling)) {
      const r3 = VS(i2, qS.Line);
      n3 = [BS(e20, t2, true), r3 || MS(t2.originalText, GS(jS(WS(i2)))) ? LS : NS, "..."];
    } else
      n3 = ["..."];
    y2.push([...m2, ...n3]);
  }
  const D2 = jS(i2[u2]), E2 = !(i2.inexact || D2 && D2.type === "RestElement" || D2 && (D2.type === "TSPropertySignature" || D2.type === "TSCallSignatureDeclaration" || D2.type === "TSMethodSignature" || D2.type === "TSConstructSignatureDeclaration") && VS(D2, qS.PrettierIgnore));
  let C2;
  if (y2.length === 0) {
    if (!VS(i2, qS.Dangling))
      return [d2, h2, JS(e20, t2, n2)];
    C2 = PS([d2, BS(e20, t2), kS, h2, HS(e20), JS(e20, t2, n2)]);
  } else
    C2 = [l2 && RS(i2.properties) ? KS(c2) : "", d2, OS([t2.bracketSpacing ? NS : kS, ...y2]), IS(E2 && (f2 !== "," || $S(t2)) ? f2 : ""), t2.bracketSpacing ? NS : kS, h2, HS(e20), JS(e20, t2, n2)];
  return e20.match((e21) => e21.type === "ObjectPattern" && !e21.decorators, (e21, t3, n3) => XS(e21) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || e20.match(YS, (e21, t3) => t3 === "typeAnnotation", (e21, t3) => t3 === "typeAnnotation", (e21, t3, n3) => XS(e21) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || !p2 && e20.match((e21) => e21.type === "ObjectPattern", (e21) => e21.type === "AssignmentExpression" || e21.type === "VariableDeclarator") ? C2 : PS(C2, {shouldBreak: p2});
}};
const {printDanglingComments: ZS} = Wf, {printString: ex, printNumber: tx} = yi$2, {builders: {hardline: nx, softline: rx, group: ix, indent: ux}} = eu$1, {getParentExportDeclaration: ox, isFunctionNotation: sx, isGetterOrSetter: ax, rawText: cx, shouldPrintComma: lx} = Gh, {locStart: px, locEnd: fx} = zc, {printClass: dx} = JF, {printOpaqueType: hx, printTypeAlias: gx, printIntersectionType: mx, printUnionType: yx, printFunctionType: Dx, printTupleType: Ex, printIndexedAccessType: Cx} = GA, {printInterface: bx} = oS, {printTypeParameter: Ax, printTypeParameters: vx} = pv, {printExportDeclaration: Fx, printExportAllDeclaration: Sx} = TS, {printArrayItems: xx} = QE, {printObject: wx} = QS, {printPropertyKey: Tx} = vv, {printOptionalToken: Bx, printTypeAnnotation: Nx, printRestSpread: kx} = BE;
function Px(e20, t2) {
  const n2 = ox(e20);
  return n2 ? (mf.strictEqual(n2.type, "DeclareExportDeclaration"), t2) : ["declare ", t2];
}
var Ox = {printFlow: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
  switch (r2.type) {
    case "DeclareClass":
      return Px(e20, dx(e20, t2, n2));
    case "DeclareFunction":
      return Px(e20, ["function ", n2("id"), r2.predicate ? " " : "", n2("predicate"), i2]);
    case "DeclareModule":
      return Px(e20, ["module ", n2("id"), " ", n2("body")]);
    case "DeclareModuleExports":
      return Px(e20, ["module.exports", ": ", n2("typeAnnotation"), i2]);
    case "DeclareVariable":
      return Px(e20, ["var ", n2("id"), i2]);
    case "DeclareOpaqueType":
      return Px(e20, hx(e20, t2, n2));
    case "DeclareInterface":
      return Px(e20, bx(e20, t2, n2));
    case "DeclareTypeAlias":
      return Px(e20, gx(e20, t2, n2));
    case "DeclareExportDeclaration":
      return Px(e20, Fx(e20, t2, n2));
    case "DeclareExportAllDeclaration":
      return Px(e20, Sx(e20, t2, n2));
    case "OpaqueType":
      return hx(e20, t2, n2);
    case "TypeAlias":
      return gx(e20, t2, n2);
    case "IntersectionTypeAnnotation":
      return mx(e20, t2, n2);
    case "UnionTypeAnnotation":
      return yx(e20, t2, n2);
    case "FunctionTypeAnnotation":
      return Dx(e20, t2, n2);
    case "TupleTypeAnnotation":
      return Ex(e20, t2, n2);
    case "GenericTypeAnnotation":
      return [n2("id"), vx(e20, t2, n2, "typeParameters")];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return Cx(e20, t2, n2);
    case "TypeAnnotation":
      return n2("typeAnnotation");
    case "TypeParameter":
      return Ax(e20, t2, n2);
    case "TypeofTypeAnnotation":
      return ["typeof ", n2("argument")];
    case "ExistsTypeAnnotation":
      return "*";
    case "EmptyTypeAnnotation":
      return "empty";
    case "MixedTypeAnnotation":
      return "mixed";
    case "ArrayTypeAnnotation":
      return [n2("elementType"), "[]"];
    case "BooleanLiteralTypeAnnotation":
      return String(r2.value);
    case "EnumDeclaration":
      return ["enum ", n2("id"), " ", n2("body")];
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      if (r2.type === "EnumSymbolBody" || r2.explicitType) {
        let e21 = null;
        switch (r2.type) {
          case "EnumBooleanBody":
            e21 = "boolean";
            break;
          case "EnumNumberBody":
            e21 = "number";
            break;
          case "EnumStringBody":
            e21 = "string";
            break;
          case "EnumSymbolBody":
            e21 = "symbol";
        }
        u2.push("of ", e21, " ");
      }
      if (r2.members.length !== 0 || r2.hasUnknownMembers) {
        const i3 = r2.members.length > 0 ? [nx, xx(e20, t2, "members", n2), r2.hasUnknownMembers || lx(t2) ? "," : ""] : [];
        u2.push(ix(["{", ux([...i3, ...r2.hasUnknownMembers ? [nx, "..."] : []]), ZS(e20, t2, true), nx, "}"]));
      } else
        u2.push(ix(["{", ZS(e20, t2), rx, "}"]));
      return u2;
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
      return [n2("id"), " = ", typeof r2.init == "object" ? n2("init") : String(r2.init)];
    case "EnumDefaultedMember":
      return n2("id");
    case "FunctionTypeParam": {
      const t3 = r2.name ? n2("name") : e20.getParentNode().this === r2 ? "this" : "";
      return [t3, Bx(e20), t3 ? ": " : "", n2("typeAnnotation")];
    }
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return bx(e20, t2, n2);
    case "ClassImplements":
    case "InterfaceExtends":
      return [n2("id"), n2("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", n2("typeAnnotation")];
    case "Variance": {
      const {kind: e21} = r2;
      return mf.ok(e21 === "plus" || e21 === "minus"), e21 === "plus" ? "+" : "-";
    }
    case "ObjectTypeCallProperty":
      return r2.static && u2.push("static "), u2.push(n2("value")), u2;
    case "ObjectTypeIndexer":
      return [r2.variance ? n2("variance") : "", "[", n2("id"), r2.id ? ": " : "", n2("key"), "]: ", n2("value")];
    case "ObjectTypeProperty": {
      let i3 = "";
      return r2.proto ? i3 = "proto " : r2.static && (i3 = "static "), [i3, ax(r2) ? r2.kind + " " : "", r2.variance ? n2("variance") : "", Tx(e20, t2, n2), Bx(e20), sx(r2) ? "" : ": ", n2("value")];
    }
    case "ObjectTypeAnnotation":
      return wx(e20, t2, n2);
    case "ObjectTypeInternalSlot":
      return [r2.static ? "static " : "", "[[", n2("id"), "]]", Bx(e20), r2.method ? "" : ": ", n2("value")];
    case "ObjectTypeSpreadProperty":
      return kx(e20, t2, n2);
    case "QualifiedTypeIdentifier":
      return [n2("qualification"), ".", n2("id")];
    case "StringLiteralTypeAnnotation":
      return ex(cx(r2), t2);
    case "NumberLiteralTypeAnnotation":
      mf.strictEqual(typeof r2.value, "number");
    case "BigIntLiteralTypeAnnotation":
      return r2.extra ? tx(r2.extra.raw) : tx(r2.raw);
    case "TypeCastExpression":
      return ["(", n2("expression"), Nx(e20, t2, n2), ")"];
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation": {
      const i3 = vx(e20, t2, n2, "params");
      if (t2.parser === "flow") {
        const e21 = px(r2), n3 = fx(r2), u3 = t2.originalText.lastIndexOf("/*", e21), o2 = t2.originalText.indexOf("*/", n3);
        if (u3 !== -1 && o2 !== -1) {
          const e22 = t2.originalText.slice(u3 + 2, o2).trim();
          if (e22.startsWith("::") && !e22.includes("/*") && !e22.includes("*/"))
            return ["/*:: ", i3, " */"];
        }
      }
      return i3;
    }
    case "InferredPredicate":
      return "%checks";
    case "DeclaredPredicate":
      return ["%checks(", n2("value"), ")"];
    case "AnyTypeAnnotation":
      return "any";
    case "BooleanTypeAnnotation":
      return "boolean";
    case "BigIntTypeAnnotation":
      return "bigint";
    case "NullLiteralTypeAnnotation":
      return "null";
    case "NumberTypeAnnotation":
      return "number";
    case "SymbolTypeAnnotation":
      return "symbol";
    case "StringTypeAnnotation":
      return "string";
    case "VoidTypeAnnotation":
      return "void";
    case "ThisTypeAnnotation":
      return "this";
    case "Node":
    case "Printable":
    case "SourceLocation":
    case "Position":
    case "Statement":
    case "Function":
    case "Pattern":
    case "Expression":
    case "Declaration":
    case "Specifier":
    case "NamedSpecifier":
    case "Comment":
    case "MemberTypeAnnotation":
    case "Type":
      throw new Error("unprintable type: " + JSON.stringify(r2.type));
  }
}};
const {hasNewlineInRange: Ix} = yi$2, {isJsxNode: Lx, isBlockComment: jx, getComments: _x, isCallExpression: Mx, isMemberExpression: Rx} = Gh, {locStart: $x, locEnd: Vx} = zc, {builders: {line: Wx, softline: qx, group: Ux, indent: zx, align: Gx, ifBreak: Hx, dedent: Jx, breakParent: Xx}} = eu$1;
function Yx(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "alternate" : "falseType", o2 = e20.getParentNode(), s2 = i2 ? n2("test") : [n2("checkType"), " ", "extends", " ", n2("extendsType")];
  return o2.type === r2.type && o2[u2] === r2 ? Gx(2, s2) : s2;
}
const Kx = new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
var Qx = {printTernary: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "consequent" : "trueType", o2 = i2 ? "alternate" : "falseType", s2 = i2 ? ["test"] : ["checkType", "extendsType"], a2 = r2[u2], c2 = r2[o2], l2 = [];
  let p2 = false;
  const f2 = e20.getParentNode(), d2 = f2.type === r2.type && s2.some((e21) => f2[e21] === r2);
  let h2, g2, m2 = f2.type === r2.type && !d2, y2 = 0;
  do {
    g2 = h2 || r2, h2 = e20.getParentNode(y2), y2++;
  } while (h2 && h2.type === r2.type && s2.every((e21) => h2[e21] !== g2));
  const D2 = h2 || f2, E2 = g2;
  if (i2 && (Lx(r2[s2[0]]) || Lx(a2) || Lx(c2) || function(e21) {
    const t3 = [e21];
    for (let e22 = 0; e22 < t3.length; e22++) {
      const n3 = t3[e22];
      for (const e23 of ["test", "consequent", "alternate"]) {
        const r3 = n3[e23];
        if (Lx(r3))
          return true;
        r3.type === "ConditionalExpression" && t3.push(r3);
      }
    }
    return false;
  }(E2))) {
    p2 = true, m2 = true;
    const e21 = (e22) => [Hx("("), zx([qx, e22]), qx, Hx(")")], t3 = (e22) => e22.type === "NullLiteral" || e22.type === "Literal" && e22.value === null || e22.type === "Identifier" && e22.name === "undefined";
    l2.push(" ? ", t3(a2) ? n2(u2) : e21(n2(u2)), " : ", c2.type === r2.type || t3(c2) ? n2(o2) : e21(n2(o2)));
  } else {
    const e21 = [Wx, "? ", a2.type === r2.type ? Hx("", "(") : "", Gx(2, n2(u2)), a2.type === r2.type ? Hx("", ")") : "", Wx, ": ", c2.type === r2.type ? n2(o2) : Gx(2, n2(o2))];
    l2.push(f2.type !== r2.type || f2[o2] === r2 || d2 ? e21 : t2.useTabs ? Jx(zx(e21)) : Gx(Math.max(0, t2.tabWidth - 2), e21));
  }
  const C2 = [...s2.map((e21) => _x(r2[e21])), _x(a2), _x(c2)].flat().some((e21) => jx(e21) && Ix(t2.originalText, $x(e21), Vx(e21))), b2 = !p2 && (Rx(f2) || f2.type === "NGPipeExpression" && f2.left === r2) && !f2.computed, A2 = function(e21) {
    const t3 = e21.getValue();
    if (t3.type !== "ConditionalExpression")
      return false;
    let n3, r3 = t3;
    for (let t4 = 0; !n3; t4++) {
      const i3 = e21.getParentNode(t4);
      Mx(i3) && i3.callee === r3 || Rx(i3) && i3.object === r3 || i3.type === "TSNonNullExpression" && i3.expression === r3 ? r3 = i3 : i3.type === "NewExpression" && i3.callee === r3 || i3.type === "TSAsExpression" && i3.expression === r3 ? (n3 = e21.getParentNode(t4 + 1), r3 = i3) : n3 = i3;
    }
    return r3 !== t3 && n3[Kx.get(n3.type)] === r3;
  }(e20), v2 = (F2 = [Yx(e20, 0, n2), m2 ? l2 : zx(l2), i2 && b2 && !A2 ? qx : ""], f2 === D2 ? Ux(F2, {shouldBreak: C2}) : C2 ? [F2, Xx] : F2);
  var F2;
  return d2 || A2 ? Ux([zx([qx, v2]), qx]) : v2;
}};
const {builders: {hardline: Zx}} = eu$1, {getLeftSidePathName: ew, hasNakedLeftSide: tw, isJsxNode: nw, isTheOnlyJsxElementInMarkdown: rw, hasComment: iw, CommentCheckFlags: uw, isNextLineEmpty: ow} = Gh, {shouldPrintParamsWithoutParens: sw} = lF;
function aw(e20, t2, n2, r2) {
  const i2 = e20.getValue(), u2 = [], o2 = i2.type === "ClassBody", s2 = function(e21) {
    for (let t3 = e21.length - 1; t3 >= 0; t3--) {
      const n3 = e21[t3];
      if (n3.type !== "EmptyStatement")
        return n3;
    }
  }(i2[r2]);
  return e20.each((e21, r3, i3) => {
    const a2 = e21.getValue();
    if (a2.type === "EmptyStatement")
      return;
    const c2 = n2();
    t2.semi || o2 || rw(t2, e21) || !function(e22, t3) {
      if (e22.getNode().type !== "ExpressionStatement")
        return false;
      return e22.call((e23) => cw(e23, t3), "expression");
    }(e21, t2) ? u2.push(c2) : iw(a2, uw.Leading) ? u2.push(n2([], {needsSemi: true})) : u2.push(";", c2), !t2.semi && o2 && lw(a2) && function(e22, t3) {
      const n3 = e22.key && e22.key.name;
      if (!(n3 !== "static" && n3 !== "get" && n3 !== "set" || e22.value || e22.typeAnnotation))
        return true;
      if (!t3)
        return false;
      if (t3.static || t3.accessibility)
        return false;
      if (!t3.computed) {
        const e23 = t3.key && t3.key.name;
        if (e23 === "in" || e23 === "instanceof")
          return true;
      }
      if (lw(t3) && t3.variance && !t3.static && !t3.declare)
        return true;
      switch (t3.type) {
        case "ClassProperty":
        case "PropertyDefinition":
        case "TSAbstractClassProperty":
          return t3.computed;
        case "MethodDefinition":
        case "TSAbstractMethodDefinition":
        case "ClassMethod":
        case "ClassPrivateMethod": {
          if ((t3.value ? t3.value.async : t3.async) || t3.kind === "get" || t3.kind === "set")
            return false;
          const e23 = t3.value ? t3.value.generator : t3.generator;
          return !(!t3.computed && !e23);
        }
        case "TSIndexSignature":
          return true;
      }
      return false;
    }(a2, i3[r3 + 1]) && u2.push(";"), a2 !== s2 && (u2.push(Zx), ow(a2, t2) && u2.push(Zx));
  }, r2), u2;
}
function cw(e20, t2) {
  const n2 = e20.getValue();
  switch (n2.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return true;
    case "ArrowFunctionExpression":
      if (!sw(e20, t2))
        return true;
      break;
    case "UnaryExpression": {
      const {prefix: e21, operator: t3} = n2;
      if (e21 && (t3 === "+" || t3 === "-"))
        return true;
      break;
    }
    case "BindExpression":
      if (!n2.object)
        return true;
      break;
    case "Literal":
      if (n2.regex)
        return true;
      break;
    default:
      if (nw(n2))
        return true;
  }
  return !!Qy(e20, t2) || !!tw(n2) && e20.call((e21) => cw(e21, t2), ...ew(e20, n2));
}
const lw = ({type: e20}) => e20 === "ClassProperty" || e20 === "PropertyDefinition" || e20 === "ClassPrivateProperty";
var pw = {printBody: function(e20, t2, n2) {
  return aw(e20, t2, n2, "body");
}, printSwitchCaseConsequent: function(e20, t2, n2) {
  return aw(e20, t2, n2, "consequent");
}};
const {printDanglingComments: fw} = Wf, {isNonEmptyArray: dw} = yi$2, {builders: {hardline: hw, indent: gw}} = eu$1, {hasComment: mw, CommentCheckFlags: yw, isNextLineEmpty: Dw} = Gh, {printHardlineAfterHeritage: Ew} = JF, {printBody: Cw} = pw;
function bw(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = dw(r2.directives), u2 = r2.body.some((e21) => e21.type !== "EmptyStatement"), o2 = mw(r2, yw.Dangling);
  if (!i2 && !u2 && !o2)
    return "";
  const s2 = [];
  if (i2 && e20.each((e21, r3, i3) => {
    s2.push(n2()), (r3 < i3.length - 1 || u2 || o2) && (s2.push(hw), Dw(e21.getValue(), t2) && s2.push(hw));
  }, "directives"), u2 && s2.push(Cw(e20, t2, n2)), o2 && s2.push(fw(e20, t2, true)), r2.type === "Program") {
    const t3 = e20.getParentNode();
    t3 && t3.type === "ModuleExpression" || s2.push(hw);
  }
  return s2;
}
var Aw = {printBlock: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [];
  if (r2.type === "StaticBlock" && i2.push("static "), r2.type === "ClassBody" && dw(r2.body)) {
    const t3 = e20.getParentNode();
    i2.push(Ew(t3));
  }
  i2.push("{");
  const u2 = bw(e20, t2, n2);
  if (u2)
    i2.push(gw([hw, u2]), hw);
  else {
    const t3 = e20.getParentNode(), n3 = e20.getParentNode(1);
    t3.type === "ArrowFunctionExpression" || t3.type === "FunctionExpression" || t3.type === "FunctionDeclaration" || t3.type === "ObjectMethod" || t3.type === "ClassMethod" || t3.type === "ClassPrivateMethod" || t3.type === "ForStatement" || t3.type === "WhileStatement" || t3.type === "DoWhileStatement" || t3.type === "DoExpression" || t3.type === "CatchClause" && !n3.finalizer || t3.type === "TSModuleDeclaration" || t3.type === "TSDeclareFunction" || r2.type === "StaticBlock" || r2.type === "ClassBody" || i2.push(hw);
  }
  return i2.push("}"), i2;
}, printBlockBody: bw};
const {printDanglingComments: vw} = Wf, {hasNewlineInRange: Fw} = yi$2, {builders: {join: Sw, line: xw, hardline: ww, softline: Tw, group: Bw, indent: Nw, conditionalGroup: kw, ifBreak: Pw}} = eu$1, {isLiteral: Ow, getTypeScriptMappedTypeModifier: Iw, shouldPrintComma: Lw, isCallExpression: jw, isMemberExpression: _w} = Gh, {locStart: Mw, locEnd: Rw} = zc, {printOptionalToken: $w, printTypeScriptModifiers: Vw} = BE, {printTernary: Ww} = Qx, {printFunctionParameters: qw, shouldGroupFunctionParameters: Uw} = FA, {printTemplateLiteral: zw} = pg, {printArrayItems: Gw} = QE, {printObject: Hw} = QS, {printClassProperty: Jw, printClassMethod: Xw} = JF, {printTypeParameter: Yw, printTypeParameters: Kw} = pv, {printPropertyKey: Qw} = vv, {printFunction: Zw, printMethodInternal: eT} = lF, {printInterface: tT} = oS, {printBlock: nT} = Aw, {printTypeAlias: rT, printIntersectionType: iT, printUnionType: uT, printFunctionType: oT, printTupleType: sT, printIndexedAccessType: aT} = GA;
var cT = {printTypescript: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2.type.startsWith("TS"))
    return;
  if (r2.type.endsWith("Keyword"))
    return r2.type.slice(2, -7).toLowerCase();
  const i2 = t2.semi ? ";" : "", u2 = [];
  switch (r2.type) {
    case "TSThisType":
      return "this";
    case "TSTypeAssertion": {
      const e21 = !(r2.expression.type === "ArrayExpression" || r2.expression.type === "ObjectExpression"), t3 = Bw(["<", Nw([Tw, n2("typeAnnotation")]), Tw, ">"]), i3 = [Pw("("), Nw([Tw, n2("expression")]), Tw, Pw(")")];
      return e21 ? kw([[t3, n2("expression")], [t3, Bw(i3, {shouldBreak: true})], [t3, n2("expression")]]) : Bw([t3, n2("expression")]);
    }
    case "TSDeclareFunction":
      return Zw(e20, n2, t2);
    case "TSExportAssignment":
      return ["export = ", n2("expression"), i2];
    case "TSModuleBlock":
      return nT(e20, t2, n2);
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      return Hw(e20, t2, n2);
    case "TSTypeAliasDeclaration":
      return rT(e20, t2, n2);
    case "TSQualifiedName":
      return Sw(".", [n2("left"), n2("right")]);
    case "TSAbstractMethodDefinition":
    case "TSDeclareMethod":
      return Xw(e20, t2, n2);
    case "TSAbstractClassProperty":
      return Jw(e20, t2, n2);
    case "TSInterfaceHeritage":
    case "TSExpressionWithTypeArguments":
      return u2.push(n2("expression")), r2.typeParameters && u2.push(n2("typeParameters")), u2;
    case "TSTemplateLiteralType":
      return zw(e20, n2, t2);
    case "TSNamedTupleMember":
      return [n2("label"), r2.optional ? "?" : "", ": ", n2("elementType")];
    case "TSRestType":
      return ["...", n2("typeAnnotation")];
    case "TSOptionalType":
      return [n2("typeAnnotation"), "?"];
    case "TSInterfaceDeclaration":
      return tT(e20, t2, n2);
    case "TSClassImplements":
      return [n2("expression"), n2("typeParameters")];
    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return Kw(e20, t2, n2, "params");
    case "TSTypeParameter":
      return Yw(e20, t2, n2);
    case "TSAsExpression": {
      u2.push(n2("expression"), " as ", n2("typeAnnotation"));
      const t3 = e20.getParentNode();
      return jw(t3) && t3.callee === r2 || _w(t3) && t3.object === r2 ? Bw([Nw([Tw, ...u2]), Tw]) : u2;
    }
    case "TSArrayType":
      return [n2("elementType"), "[]"];
    case "TSPropertySignature":
      return r2.readonly && u2.push("readonly "), u2.push(Qw(e20, t2, n2), $w(e20)), r2.typeAnnotation && u2.push(": ", n2("typeAnnotation")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
    case "TSParameterProperty":
      return r2.accessibility && u2.push(r2.accessibility + " "), r2.export && u2.push("export "), r2.static && u2.push("static "), r2.override && u2.push("override "), r2.readonly && u2.push("readonly "), u2.push(n2("parameter")), u2;
    case "TSTypeQuery":
      return ["typeof ", n2("exprName")];
    case "TSIndexSignature": {
      const u3 = e20.getParentNode(), o2 = r2.parameters.length > 1 ? Pw(Lw(t2) ? "," : "") : "", s2 = Bw([Nw([Tw, Sw([", ", Tw], e20.map(n2, "parameters"))]), o2, Tw]);
      return [r2.export ? "export " : "", r2.accessibility ? [r2.accessibility, " "] : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.declare ? "declare " : "", "[", r2.parameters ? s2 : "", r2.typeAnnotation ? "]: " : "]", r2.typeAnnotation ? n2("typeAnnotation") : "", u3.type === "ClassBody" ? i2 : ""];
    }
    case "TSTypePredicate":
      return [r2.asserts ? "asserts " : "", n2("parameterName"), r2.typeAnnotation ? [" is ", n2("typeAnnotation")] : ""];
    case "TSNonNullExpression":
      return [n2("expression"), "!"];
    case "TSImportType":
      return [r2.isTypeOf ? "typeof " : "", "import(", n2(r2.parameter ? "parameter" : "argument"), ")", r2.qualifier ? [".", n2("qualifier")] : "", Kw(e20, t2, n2, "typeParameters")];
    case "TSLiteralType":
      return n2("literal");
    case "TSIndexedAccessType":
      return aT(e20, t2, n2);
    case "TSConstructSignatureDeclaration":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
      if (r2.type === "TSConstructorType" && r2.abstract && u2.push("abstract "), r2.type !== "TSCallSignatureDeclaration" && u2.push("new "), u2.push(Bw(qw(e20, n2, t2, false, true))), r2.returnType || r2.typeAnnotation) {
        const e21 = r2.type === "TSConstructorType";
        u2.push(e21 ? " => " : ": ", n2("returnType"), n2("typeAnnotation"));
      }
      return u2;
    case "TSTypeOperator":
      return [r2.operator, " ", n2("typeAnnotation")];
    case "TSMappedType": {
      const u3 = Fw(t2.originalText, Mw(r2), Rw(r2));
      return Bw(["{", Nw([t2.bracketSpacing ? xw : Tw, r2.readonly ? [Iw(r2.readonly, "readonly"), " "] : "", Vw(e20, t2, n2), n2("typeParameter"), r2.optional ? Iw(r2.optional, "?") : "", r2.typeAnnotation ? ": " : "", n2("typeAnnotation"), Pw(i2)]), vw(e20, t2, true), t2.bracketSpacing ? xw : Tw, "}"], {shouldBreak: u3});
    }
    case "TSMethodSignature": {
      const i3 = r2.kind && r2.kind !== "method" ? `${r2.kind} ` : "";
      u2.push(r2.accessibility ? [r2.accessibility, " "] : "", i3, r2.export ? "export " : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.abstract ? "abstract " : "", r2.declare ? "declare " : "", r2.computed ? "[" : "", n2("key"), r2.computed ? "]" : "", $w(e20));
      const o2 = qw(e20, n2, t2, false, true), s2 = r2.returnType ? "returnType" : "typeAnnotation", a2 = r2[s2], c2 = a2 ? n2(s2) : "", l2 = Uw(r2, c2);
      return u2.push(l2 ? Bw(o2) : o2), a2 && u2.push(": ", Bw(c2)), Bw(u2);
    }
    case "TSNamespaceExportDeclaration":
      return u2.push("export as namespace ", n2("id")), t2.semi && u2.push(";"), Bw(u2);
    case "TSEnumDeclaration":
      return r2.declare && u2.push("declare "), r2.modifiers && u2.push(Vw(e20, t2, n2)), r2.const && u2.push("const "), u2.push("enum ", n2("id"), " "), r2.members.length === 0 ? u2.push(Bw(["{", vw(e20, t2), Tw, "}"])) : u2.push(Bw(["{", Nw([ww, Gw(e20, t2, "members", n2), Lw(t2, "es5") ? "," : ""]), vw(e20, t2, true), ww, "}"])), u2;
    case "TSEnumMember":
      return u2.push(n2("id")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
    case "TSImportEqualsDeclaration":
      return r2.isExport && u2.push("export "), u2.push("import "), r2.importKind && r2.importKind !== "value" && u2.push(r2.importKind, " "), u2.push(n2("id"), " = ", n2("moduleReference")), t2.semi && u2.push(";"), Bw(u2);
    case "TSExternalModuleReference":
      return ["require(", n2("expression"), ")"];
    case "TSModuleDeclaration": {
      const o2 = e20.getParentNode(), s2 = Ow(r2.id), a2 = o2.type === "TSModuleDeclaration", c2 = r2.body && r2.body.type === "TSModuleDeclaration";
      if (a2)
        u2.push(".");
      else {
        r2.declare && u2.push("declare "), u2.push(Vw(e20, t2, n2));
        const i3 = t2.originalText.slice(Mw(r2), Mw(r2.id));
        r2.id.type === "Identifier" && r2.id.name === "global" && !/namespace|module/.test(i3) || u2.push(s2 || /(?:^|\s)module(?:\s|$)/.test(i3) ? "module " : "namespace ");
      }
      return u2.push(n2("id")), c2 ? u2.push(n2("body")) : r2.body ? u2.push(" ", Bw(n2("body"))) : u2.push(i2), u2;
    }
    case "TSPrivateIdentifier":
      return r2.escapedText;
    case "TSConditionalType":
      return Ww(e20, t2, n2);
    case "TSInferType":
      return ["infer", " ", n2("typeParameter")];
    case "TSIntersectionType":
      return iT(e20, t2, n2);
    case "TSUnionType":
      return uT(e20, t2, n2);
    case "TSFunctionType":
      return oT(e20, t2, n2);
    case "TSTupleType":
      return sT(e20, t2, n2);
    case "TSTypeReference":
      return [n2("typeName"), Kw(e20, t2, n2, "typeParameters")];
    case "TSTypeAnnotation":
      return n2("typeAnnotation");
    case "TSEmptyBodyFunctionExpression":
      return eT(e20, t2, n2);
    case "TSJSDocAllType":
      return "*";
    case "TSJSDocUnknownType":
      return "?";
    case "TSJSDocNullableType":
      return ["?", n2("typeAnnotation")];
    case "TSJSDocNonNullableType":
      return ["!", n2("typeAnnotation")];
    default:
      throw new Error(`Unknown TypeScript node type: ${JSON.stringify(r2.type)}.`);
  }
}};
const {hasNewline: lT} = yi$2, {builders: {join: pT, hardline: fT}, utils: {replaceTextEndOfLine: dT}} = eu$1, {isLineComment: hT, isBlockComment: gT} = Gh, {locStart: mT, locEnd: yT} = zc;
var DT = {printComment: function(e20, t2) {
  const n2 = e20.getValue();
  if (hT(n2))
    return t2.originalText.slice(mT(n2), yT(n2)).trimEnd();
  if (gT(n2)) {
    if (function(e22) {
      const t3 = `*${e22.value}*`.split("\n");
      return t3.length > 1 && t3.every((e23) => e23.trim()[0] === "*");
    }(n2)) {
      const e22 = function(e23) {
        const t3 = e23.value.split("\n");
        return ["/*", pT(fT, t3.map((e24, n3) => n3 === 0 ? e24.trimEnd() : " " + (n3 < t3.length - 1 ? e24.trim() : e24.trimStart()))), "*/"];
      }(n2);
      return n2.trailing && !lT(t2.originalText, mT(n2), {backwards: true}) ? [fT, e22] : e22;
    }
    const e21 = yT(n2), r2 = t2.originalText.slice(e21 - 3, e21) === "*-/";
    return ["/*", dT(n2.value), r2 ? "*-/" : "*/"];
  }
  throw new Error("Not a comment: " + JSON.stringify(n2));
}};
const {printString: ET, printNumber: CT} = yi$2;
function bT(e20) {
  return e20.toLowerCase();
}
function AT({pattern: e20, flags: t2}) {
  return `/${e20}/${t2 = [...t2].sort().join("")}`;
}
var vT = {printLiteral: function(e20, t2) {
  const n2 = e20.getNode();
  switch (n2.type) {
    case "RegExpLiteral":
      return AT(n2);
    case "BigIntLiteral":
      return bT(n2.bigint || n2.extra.raw);
    case "NumericLiteral":
      return CT(n2.extra.raw);
    case "StringLiteral":
      return ET(n2.extra.raw, t2);
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(n2.value);
    case "DecimalLiteral":
      return CT(n2.value) + "m";
    case "Literal": {
      if (n2.regex)
        return AT(n2.regex);
      if (n2.bigint)
        return bT(n2.raw);
      if (n2.decimal)
        return CT(n2.decimal) + "m";
      const {value: e21} = n2;
      return typeof e21 == "number" ? CT(n2.raw) : typeof e21 == "string" ? ET(n2.raw, t2) : String(e21);
    }
  }
}};
const {printDanglingComments: FT} = Wf, {hasNewline: ST} = yi$2, {builders: {join: xT, line: wT, hardline: TT, softline: BT, group: NT, indent: kT}, utils: {replaceTextEndOfLine: PT}} = eu$1, {insertPragma: OT} = km, {hasFlowShorthandAnnotationComment: IT, hasComment: LT, CommentCheckFlags: jT, isTheOnlyJsxElementInMarkdown: _T, isBlockComment: MT, isLineComment: RT, isNextLineEmpty: $T, needsHardlineAfterDanglingComment: VT, rawText: WT, hasIgnoreComment: qT, isCallExpression: UT, isMemberExpression: zT} = Gh, {locStart: GT, locEnd: HT} = zc, {printHtmlBinding: JT, isVueEventBindingExpression: XT} = uD, {printAngular: YT} = $D, {printJsx: KT, hasJsxIgnoreComment: QT} = AE, {printFlow: ZT} = Ox, {printTypescript: eB} = cT, {printOptionalToken: tB, printBindExpressionCallee: nB, printTypeAnnotation: rB, adjustClause: iB, printRestSpread: uB} = BE, {printImportDeclaration: oB, printExportDeclaration: sB, printExportAllDeclaration: aB, printModuleSpecifier: cB} = TS, {printTernary: lB} = Qx, {printTemplateLiteral: pB} = pg, {printArray: fB} = QE, {printObject: dB} = QS, {printClass: hB, printClassMethod: gB, printClassProperty: mB} = JF, {printProperty: yB} = vv, {printFunction: DB, printArrowFunction: EB, printMethod: CB, printReturnStatement: bB, printThrowStatement: AB} = lF, {printCallExpression: vB} = Fb, {printVariableDeclarator: FB, printAssignmentExpression: SB} = Qb, {printBinaryishExpression: xB} = kD, {printSwitchCaseConsequent: wB} = pw, {printMemberExpression: TB} = _C, {printBlock: BB, printBlockBody: NB} = Aw, {printComment: kB} = DT, {printLiteral: PB} = vT, {printDecorators: OB} = vF;
function IB(e20, t2) {
  const n2 = WT(e20), r2 = n2.slice(1, -1);
  if (r2.includes('"') || r2.includes("'"))
    return n2;
  const i2 = t2.singleQuote ? "'" : '"';
  return i2 + r2 + i2;
}
var LB = {preprocess: Zy, print: function(e20, t2, n2, r2) {
  const i2 = function(e21, t3, n3, r3) {
    const i3 = e21.getValue(), u3 = t3.semi ? ";" : "";
    if (!i3)
      return "";
    if (typeof i3 == "string")
      return i3;
    for (const r4 of [PB, JT, YT, KT, ZT, eB]) {
      const i4 = r4(e21, t3, n3);
      if (i4 !== void 0)
        return i4;
    }
    let o3 = [];
    switch (i3.type) {
      case "JsExpressionRoot":
        return n3("node");
      case "JsonRoot":
        return [n3("node"), TT];
      case "File":
        return i3.program && i3.program.interpreter && o3.push(n3(["program", "interpreter"])), o3.push(n3("program")), o3;
      case "Program":
        return NB(e21, t3, n3);
      case "EmptyStatement":
        return "";
      case "ExpressionStatement":
        if (i3.directive)
          return [IB(i3.expression, t3), u3];
        if (t3.parser === "__vue_event_binding") {
          const t4 = e21.getParentNode();
          if (t4.type === "Program" && t4.body.length === 1 && t4.body[0] === i3)
            return [n3("expression"), XT(i3.expression) ? ";" : ""];
        }
        return [n3("expression"), _T(t3, e21) ? "" : u3];
      case "ParenthesizedExpression":
        return !LT(i3.expression) && (i3.expression.type === "ObjectExpression" || i3.expression.type === "ArrayExpression") ? ["(", n3("expression"), ")"] : NT(["(", kT([BT, n3("expression")]), BT, ")"]);
      case "AssignmentExpression":
        return SB(e21, t3, n3);
      case "VariableDeclarator":
        return FB(e21, t3, n3);
      case "BinaryExpression":
      case "LogicalExpression":
        return xB(e21, t3, n3);
      case "AssignmentPattern":
        return [n3("left"), " = ", n3("right")];
      case "OptionalMemberExpression":
      case "MemberExpression":
        return TB(e21, t3, n3);
      case "MetaProperty":
        return [n3("meta"), ".", n3("property")];
      case "BindExpression":
        return i3.object && o3.push(n3("object")), o3.push(NT(kT([BT, nB(e21, t3, n3)]))), o3;
      case "Identifier":
        return [i3.name, tB(e21), rB(e21, t3, n3)];
      case "V8IntrinsicIdentifier":
        return ["%", i3.name];
      case "SpreadElement":
      case "SpreadElementPattern":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
        return uB(e21, t3, n3);
      case "FunctionDeclaration":
      case "FunctionExpression":
        return DB(e21, n3, t3, r3);
      case "ArrowFunctionExpression":
        return EB(e21, t3, n3, r3);
      case "YieldExpression":
        return o3.push("yield"), i3.delegate && o3.push("*"), i3.argument && o3.push(" ", n3("argument")), o3;
      case "AwaitExpression":
        if (o3.push("await"), i3.argument) {
          o3.push(" ", n3("argument"));
          const t4 = e21.getParentNode();
          if (UT(t4) && t4.callee === i3 || zT(t4) && t4.object === i3) {
            o3 = [kT([BT, ...o3]), BT];
            const t5 = e21.findAncestor((e22) => e22.type === "AwaitExpression" || e22.type === "BlockStatement");
            if (!t5 || t5.type !== "AwaitExpression")
              return NT(o3);
          }
        }
        return o3;
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return sB(e21, t3, n3);
      case "ExportAllDeclaration":
        return aB(e21, t3, n3);
      case "ImportDeclaration":
        return oB(e21, t3, n3);
      case "ImportSpecifier":
      case "ExportSpecifier":
      case "ImportNamespaceSpecifier":
      case "ExportNamespaceSpecifier":
      case "ImportDefaultSpecifier":
      case "ExportDefaultSpecifier":
        return cB(e21, t3, n3);
      case "ImportAttribute":
        return [n3("key"), ": ", n3("value")];
      case "Import":
        return "import";
      case "BlockStatement":
      case "StaticBlock":
      case "ClassBody":
        return BB(e21, t3, n3);
      case "ThrowStatement":
        return AB(e21, t3, n3);
      case "ReturnStatement":
        return bB(e21, t3, n3);
      case "NewExpression":
      case "ImportExpression":
      case "OptionalCallExpression":
      case "CallExpression":
        return vB(e21, t3, n3);
      case "ObjectExpression":
      case "ObjectPattern":
      case "RecordExpression":
        return dB(e21, t3, n3);
      case "ObjectProperty":
      case "Property":
        return i3.method || i3.kind === "get" || i3.kind === "set" ? CB(e21, t3, n3) : yB(e21, t3, n3);
      case "ObjectMethod":
        return CB(e21, t3, n3);
      case "Decorator":
        return ["@", n3("expression")];
      case "ArrayExpression":
      case "ArrayPattern":
      case "TupleExpression":
        return fB(e21, t3, n3);
      case "SequenceExpression": {
        const t4 = e21.getParentNode(0);
        if (t4.type === "ExpressionStatement" || t4.type === "ForStatement") {
          const t5 = [];
          return e21.each((e22, r4) => {
            r4 === 0 ? t5.push(n3()) : t5.push(",", kT([wT, n3()]));
          }, "expressions"), NT(t5);
        }
        return NT(xT([",", wT], e21.map(n3, "expressions")));
      }
      case "ThisExpression":
        return "this";
      case "Super":
        return "super";
      case "Directive":
        return [n3("value"), u3];
      case "DirectiveLiteral":
        return IB(i3, t3);
      case "UnaryExpression":
        return o3.push(i3.operator), /[a-z]$/.test(i3.operator) && o3.push(" "), LT(i3.argument) ? o3.push(NT(["(", kT([BT, n3("argument")]), BT, ")"])) : o3.push(n3("argument")), o3;
      case "UpdateExpression":
        return o3.push(n3("argument"), i3.operator), i3.prefix && o3.reverse(), o3;
      case "ConditionalExpression":
        return lB(e21, t3, n3);
      case "VariableDeclaration": {
        const t4 = e21.map(n3, "declarations"), r4 = e21.getParentNode(), s3 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", a3 = i3.declarations.some((e22) => e22.init);
        let c2;
        return t4.length !== 1 || LT(i3.declarations[0]) ? t4.length > 0 && (c2 = kT(t4[0])) : c2 = t4[0], o3 = [i3.declare ? "declare " : "", i3.kind, c2 ? [" ", c2] : "", kT(t4.slice(1).map((e22) => [",", a3 && !s3 ? TT : wT, e22]))], s3 && r4.body !== i3 || o3.push(u3), NT(o3);
      }
      case "WithStatement":
        return NT(["with (", n3("object"), ")", iB(i3.body, n3("body"))]);
      case "IfStatement": {
        const r4 = iB(i3.consequent, n3("consequent")), u4 = NT(["if (", NT([kT([BT, n3("test")]), BT]), ")", r4]);
        if (o3.push(u4), i3.alternate) {
          const r5 = LT(i3.consequent, jT.Trailing | jT.Line) || VT(i3), u5 = i3.consequent.type === "BlockStatement" && !r5;
          o3.push(u5 ? " " : TT), LT(i3, jT.Dangling) && o3.push(FT(e21, t3, true), r5 ? TT : " "), o3.push("else", NT(iB(i3.alternate, n3("alternate"), i3.alternate.type === "IfStatement")));
        }
        return o3;
      }
      case "ForStatement": {
        const r4 = iB(i3.body, n3("body")), u4 = FT(e21, t3, true), o4 = u4 ? [u4, BT] : "";
        return i3.init || i3.test || i3.update ? [o4, NT(["for (", NT([kT([BT, n3("init"), ";", wT, n3("test"), ";", wT, n3("update")]), BT]), ")", r4])] : [o4, NT(["for (;;)", r4])];
      }
      case "WhileStatement":
        return NT(["while (", NT([kT([BT, n3("test")]), BT]), ")", iB(i3.body, n3("body"))]);
      case "ForInStatement":
        return NT(["for (", n3("left"), " in ", n3("right"), ")", iB(i3.body, n3("body"))]);
      case "ForOfStatement":
        return NT(["for", i3.await ? " await" : "", " (", n3("left"), " of ", n3("right"), ")", iB(i3.body, n3("body"))]);
      case "DoWhileStatement": {
        const e22 = iB(i3.body, n3("body"));
        return o3 = [NT(["do", e22])], i3.body.type === "BlockStatement" ? o3.push(" ") : o3.push(TT), o3.push("while (", NT([kT([BT, n3("test")]), BT]), ")", u3), o3;
      }
      case "DoExpression":
        return [i3.async ? "async " : "", "do ", n3("body")];
      case "BreakStatement":
        return o3.push("break"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
      case "ContinueStatement":
        return o3.push("continue"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
      case "LabeledStatement":
        return i3.body.type === "EmptyStatement" ? [n3("label"), ":;"] : [n3("label"), ": ", n3("body")];
      case "TryStatement":
        return ["try ", n3("block"), i3.handler ? [" ", n3("handler")] : "", i3.finalizer ? [" finally ", n3("finalizer")] : ""];
      case "CatchClause":
        if (i3.param) {
          const e22 = LT(i3.param, (e23) => !MT(e23) || e23.leading && ST(t3.originalText, HT(e23)) || e23.trailing && ST(t3.originalText, GT(e23), {backwards: true})), r4 = n3("param");
          return ["catch ", e22 ? ["(", kT([BT, r4]), BT, ") "] : ["(", r4, ") "], n3("body")];
        }
        return ["catch ", n3("body")];
      case "SwitchStatement":
        return [NT(["switch (", kT([BT, n3("discriminant")]), BT, ")"]), " {", i3.cases.length > 0 ? kT([TT, xT(TT, e21.map((e22, r4, i4) => {
          const u4 = e22.getValue();
          return [n3(), r4 !== i4.length - 1 && $T(u4, t3) ? TT : ""];
        }, "cases"))]) : "", TT, "}"];
      case "SwitchCase": {
        i3.test ? o3.push("case ", n3("test"), ":") : o3.push("default:");
        const r4 = i3.consequent.filter((e22) => e22.type !== "EmptyStatement");
        if (r4.length > 0) {
          const i4 = wB(e21, t3, n3);
          o3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? [" ", i4] : kT([TT, i4]));
        }
        return o3;
      }
      case "DebuggerStatement":
        return ["debugger", u3];
      case "ClassDeclaration":
      case "ClassExpression":
        return hB(e21, t3, n3);
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "MethodDefinition":
        return gB(e21, t3, n3);
      case "ClassProperty":
      case "PropertyDefinition":
      case "ClassPrivateProperty":
        return mB(e21, t3, n3);
      case "TemplateElement":
        return PT(i3.value.raw);
      case "TemplateLiteral":
        return pB(e21, n3, t3);
      case "TaggedTemplateExpression":
        return [n3("tag"), n3("typeParameters"), n3("quasi")];
      case "PrivateIdentifier":
        return ["#", n3("name")];
      case "PrivateName":
        return ["#", n3("id")];
      case "InterpreterDirective":
        return o3.push("#!", i3.value, TT), $T(i3, t3) && o3.push(TT), o3;
      case "TopicReference":
        return "%";
      case "ArgumentPlaceholder":
        return "?";
      case "ModuleExpression": {
        o3.push("module {");
        const e22 = n3("body");
        return e22 && o3.push(kT([TT, e22]), TT), o3.push("}"), o3;
      }
      default:
        throw new Error("unknown type: " + JSON.stringify(i3.type));
    }
  }(e20, t2, n2, r2);
  if (!i2)
    return "";
  const u2 = e20.getValue(), {type: o2} = u2;
  if (o2 === "ClassMethod" || o2 === "ClassPrivateMethod" || o2 === "ClassProperty" || o2 === "PropertyDefinition" || o2 === "TSAbstractClassProperty" || o2 === "ClassPrivateProperty" || o2 === "MethodDefinition" || o2 === "TSAbstractMethodDefinition" || o2 === "TSDeclareMethod")
    return i2;
  const s2 = OB(e20, t2, n2);
  if (s2)
    return NT([...s2, i2]);
  if (!Qy(e20, t2))
    return r2 && r2.needsSemi ? [";", i2] : i2;
  const a2 = [r2 && r2.needsSemi ? ";(" : "(", i2];
  if (IT(u2)) {
    const [e21] = u2.trailingComments;
    a2.push(" /*", e21.value.trimStart(), "*/"), e21.printed = true;
  }
  return a2.push(")"), a2;
}, embed: Kg, insertPragma: OT, massageAstNode: nm, hasPrettierIgnore: (e20) => qT(e20) || QT(e20), willPrintOwnComments: jy.willPrintOwnComments, canAttachComment: function(e20) {
  return e20.type && !MT(e20) && !RT(e20) && e20.type !== "EmptyStatement" && e20.type !== "TemplateElement" && e20.type !== "Import" && e20.type !== "TSEmptyBodyFunctionExpression";
}, printComment: kB, isBlockComment: MT, handleComments: {avoidAstMutation: true, ownLine: jy.handleOwnLineComment, endOfLine: jy.handleEndOfLineComment, remaining: jy.handleRemainingComment}, getCommentChildNodes: jy.getCommentChildNodes};
const {builders: {hardline: jB, indent: _B, join: MB}} = eu$1;
const RB = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
function $B(e20, t2) {
  const {type: n2} = e20;
  if (n2 !== "ObjectProperty" || e20.key.type !== "Identifier") {
    if (n2 === "UnaryExpression" && e20.operator === "+")
      return t2.argument;
    if (n2 !== "ArrayExpression")
      return n2 === "TemplateLiteral" ? {type: "StringLiteral", value: e20.quasis[0].value.cooked} : void 0;
    for (const [n3, r2] of e20.elements.entries())
      r2 === null && t2.elements.splice(n3, 0, {type: "NullLiteral"});
  } else
    t2.key = {type: "StringLiteral", value: e20.key.name};
}
$B.ignoredProperties = RB;
var VB = {preprocess: Zy, print: function(e20, t2, n2) {
  const r2 = e20.getValue();
  switch (r2.type) {
    case "JsonRoot":
      return [n2("node"), jB];
    case "ArrayExpression": {
      if (r2.elements.length === 0)
        return "[]";
      const t3 = e20.map(() => e20.getValue() === null ? "null" : n2(), "elements");
      return ["[", _B([jB, MB([",", jB], t3)]), jB, "]"];
    }
    case "ObjectExpression":
      return r2.properties.length === 0 ? "{}" : ["{", _B([jB, MB([",", jB], e20.map(n2, "properties"))]), jB, "}"];
    case "ObjectProperty":
      return [n2("key"), ": ", n2("value")];
    case "UnaryExpression":
      return [r2.operator === "+" ? "" : r2.operator, n2("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return r2.value ? "true" : "false";
    case "StringLiteral":
    case "NumericLiteral":
      return JSON.stringify(r2.value);
    case "Identifier": {
      const t3 = e20.getParentNode();
      return t3 && t3.type === "ObjectProperty" && t3.key === r2 ? JSON.stringify(r2.name) : r2.name;
    }
    case "TemplateLiteral":
      return n2(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(r2.value.cooked);
    default:
      throw new Error("unknown type: " + JSON.stringify(r2.type));
  }
}, massageAstNode: $B};
var WB = {bracketSpacing: {since: "0.0.0", category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets."}, singleQuote: {since: "0.0.0", category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes."}, proseWrap: {since: "1.8.2", category: "Common", type: "choice", default: [{since: "1.8.2", value: true}, {since: "1.9.0", value: "preserve"}], description: "How to wrap prose.", choices: [{since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width."}, {since: "1.9.0", value: "never", description: "Do not wrap prose."}, {since: "1.9.0", value: "preserve", description: "Wrap prose as-is."}]}, bracketSameLine: {since: "2.4.0", category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line."}};
var qB = {arrowParens: {since: "1.9.0", category: "JavaScript", type: "choice", default: [{since: "1.9.0", value: "avoid"}, {since: "2.0.0", value: "always"}], description: "Include parentheses around a sole arrow function parameter.", choices: [{value: "always", description: "Always include parens. Example: `(x) => x`"}, {value: "avoid", description: "Omit parens when possible. Example: `x => x`"}]}, bracketSameLine: WB.bracketSameLine, bracketSpacing: WB.bracketSpacing, jsxBracketSameLine: {since: "0.17.0", category: "JavaScript", type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0"}, semi: {since: "1.0.0", category: "JavaScript", type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."}, singleQuote: WB.singleQuote, jsxSingleQuote: {since: "1.15.0", category: "JavaScript", type: "boolean", default: false, description: "Use single quotes in JSX."}, quoteProps: {since: "1.17.0", category: "JavaScript", type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{value: "as-needed", description: "Only add quotes around object properties where required."}, {value: "consistent", description: "If at least one property in an object requires quotes, quote all properties."}, {value: "preserve", description: "Respect the input use of quotes in object properties."}]}, trailingComma: {since: "0.0.0", category: "JavaScript", type: "choice", default: [{since: "0.0.0", value: false}, {since: "0.19.0", value: "none"}, {since: "2.0.0", value: "es5"}], description: "Print trailing commas wherever possible when multi-line.", choices: [{value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"}, {value: "none", description: "No trailing commas."}, {value: "all", description: "Trailing commas wherever possible (including function arguments)."}]}}, UB = {name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183}, zB = {name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378}, GB = {name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924}, HB = {name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174}, JB = {name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423}, XB = {name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175};
var YB = {languages: [Xd(UB, (e20) => ({since: "0.0.0", parsers: ["babel", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e20.interpreters, "zx"], extensions: [...e20.extensions.filter((e21) => e21 !== ".jsx"), ".wxs"]})), Xd(UB, () => ({name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"]})), Xd(UB, () => ({name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0})), Xd(zB, () => ({since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"]})), Xd(GB, () => ({since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"]})), Xd(HB, () => ({name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"]})), Xd(HB, (e20) => ({since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e20.extensions.filter((e21) => e21 !== ".jsonl")})), Xd(JB, (e20) => ({since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e20.filenames, ".eslintrc"]})), Xd(XB, () => ({since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"]}))], options: qB, printers: {estree: LB, "estree-json": VB}, parsers: void 0};
const {isFrontMatterNode: KB} = yi$2, QB = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
function ZB(e20, t2, n2) {
  if (KB(e20) && e20.lang === "yaml" && delete t2.value, e20.type === "css-comment" && n2.type === "css-root" && n2.nodes.length > 0) {
    if ((n2.nodes[0] === e20 || KB(n2.nodes[0]) && n2.nodes[1] === e20) && (delete t2.text, /^\*\s*@(?:format|prettier)\s*$/.test(e20.text)))
      return null;
    if (n2.type === "css-root" && Ln$2(n2.nodes) === e20)
      return null;
  }
  if (e20.type === "value-root" && delete t2.text, e20.type !== "media-query" && e20.type !== "media-query-list" && e20.type !== "media-feature-expression" || delete t2.value, e20.type === "css-rule" && delete t2.params, e20.type === "selector-combinator" && (t2.value = t2.value.replace(/\s+/g, " ")), e20.type === "media-feature" && (t2.value = t2.value.replace(/ /g, "")), (e20.type === "value-word" && (e20.isColor && e20.isHex || ["initial", "inherit", "unset", "revert"].includes(t2.value.replace().toLowerCase())) || e20.type === "media-feature" || e20.type === "selector-root-invalid" || e20.type === "selector-pseudo") && (t2.value = t2.value.toLowerCase()), e20.type === "css-decl" && (t2.prop = t2.prop.toLowerCase()), e20.type !== "css-atrule" && e20.type !== "css-import" || (t2.name = t2.name.toLowerCase()), e20.type === "value-number" && (t2.unit = t2.unit.toLowerCase()), e20.type !== "media-feature" && e20.type !== "media-keyword" && e20.type !== "media-type" && e20.type !== "media-unknown" && e20.type !== "media-url" && e20.type !== "media-value" && e20.type !== "selector-attribute" && e20.type !== "selector-string" && e20.type !== "selector-class" && e20.type !== "selector-combinator" && e20.type !== "value-string" || !t2.value || (t2.value = t2.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e20.type === "selector-attribute" && (t2.attribute = t2.attribute.trim(), t2.namespace && typeof t2.namespace == "string" && (t2.namespace = t2.namespace.trim(), t2.namespace.length === 0 && (t2.namespace = true)), t2.value && (t2.value = t2.value.trim().replace(/^["']|["']$/g, ""), delete t2.quoted)), e20.type !== "media-value" && e20.type !== "media-type" && e20.type !== "value-number" && e20.type !== "selector-root-invalid" && e20.type !== "selector-class" && e20.type !== "selector-combinator" && e20.type !== "selector-tag" || !t2.value || (t2.value = t2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e21, t3, n3) => {
    const r2 = Number(t3);
    return Number.isNaN(r2) ? e21 : r2 + n3.toLowerCase();
  })), e20.type === "selector-tag") {
    const n3 = e20.value.toLowerCase();
    ["from", "to"].includes(n3) && (t2.value = n3);
  }
  e20.type === "css-atrule" && e20.name.toLowerCase() === "supports" && delete t2.value, e20.type === "selector-unknown" && delete t2.value;
}
ZB.ignoredProperties = QB;
var eN = ZB;
const {builders: {hardline: tN, markAsRoot: nN}} = eu$1;
var rN = function(e20, t2) {
  if (e20.lang === "yaml") {
    const n2 = e20.value.trim(), r2 = n2 ? t2(n2, {parser: "yaml"}, {stripTrailingHardline: true}) : "";
    return nN([e20.startDelimiter, tN, r2, r2 ? tN : "", e20.endDelimiter]);
  }
};
const {builders: {hardline: iN}} = eu$1;
var uN = function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (r2.type === "front-matter") {
    const e21 = rN(r2, n2);
    return e21 ? [e21, iN] : "";
  }
};
const oN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
var sN = function(e20) {
  const t2 = e20.match(oN);
  if (!t2)
    return {content: e20};
  const {startDelimiter: n2, language: r2, value: i2 = "", endDelimiter: u2} = t2.groups;
  let o2 = r2.trim() || "yaml";
  if (n2 === "+++" && (o2 = "toml"), o2 !== "yaml" && n2 !== u2)
    return {content: e20};
  const [s2] = t2;
  return {frontMatter: {type: "front-matter", lang: o2, value: i2, startDelimiter: n2, endDelimiter: u2, raw: s2.replace(/\n$/, "")}, content: s2.replace(/[^\n]/g, " ") + e20.slice(s2.length)};
};
var aN = {hasPragma: function(e20) {
  return km.hasPragma(sN(e20).content);
}, insertPragma: function(e20) {
  const {frontMatter: t2, content: n2} = sN(e20);
  return (t2 ? t2.raw + "\n\n" : "") + km.insertPragma(n2);
}};
const {isNonEmptyArray: cN} = yi$2, lN = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), pN = new Set(["import", "use", "forward"]);
function fN(e20, t2) {
  const n2 = Array.isArray(t2) ? t2 : [t2];
  let r2, i2 = -1;
  for (; r2 = e20.getParentNode(++i2); )
    if (n2.includes(r2.type))
      return i2;
  return -1;
}
function dN(e20, t2) {
  const n2 = fN(e20, t2);
  return n2 === -1 ? null : e20.getParentNode(n2);
}
function hN(e20) {
  return e20.type === "value-operator" && e20.value === "*";
}
function gN(e20) {
  return e20.type === "value-operator" && e20.value === "/";
}
function mN(e20) {
  return e20.type === "value-operator" && e20.value === "+";
}
function yN(e20) {
  return e20.type === "value-operator" && e20.value === "-";
}
function DN(e20) {
  return e20.type === "value-operator" && e20.value === "%";
}
function EN(e20) {
  return e20.type === "value-comma_group" && e20.groups && e20.groups[1] && e20.groups[1].type === "value-colon";
}
function CN(e20) {
  return e20.type === "value-paren_group" && e20.groups && e20.groups[0] && EN(e20.groups[0]);
}
function bN(e20) {
  return e20 && e20.type === "value-colon";
}
var AN = {getAncestorCounter: fN, getAncestorNode: dN, getPropOfDeclNode: function(e20) {
  const t2 = dN(e20, "css-decl");
  return t2 && t2.prop && t2.prop.toLowerCase();
}, hasSCSSInterpolation: function(e20) {
  if (cN(e20)) {
    for (let t2 = e20.length - 1; t2 > 0; t2--)
      if (e20[t2].type === "word" && e20[t2].value === "{" && e20[t2 - 1].type === "word" && e20[t2 - 1].value.endsWith("#"))
        return true;
  }
  return false;
}, hasStringOrFunction: function(e20) {
  if (cN(e20)) {
    for (let t2 = 0; t2 < e20.length; t2++)
      if (e20[t2].type === "string" || e20[t2].type === "func")
        return true;
  }
  return false;
}, maybeToLowerCase: function(e20) {
  return e20.includes("$") || e20.includes("@") || e20.includes("#") || e20.startsWith("%") || e20.startsWith("--") || e20.startsWith(":--") || e20.includes("(") && e20.includes(")") ? e20 : e20.toLowerCase();
}, insideValueFunctionNode: function(e20, t2) {
  const n2 = dN(e20, "value-func");
  return n2 && n2.value && n2.value.toLowerCase() === t2;
}, insideICSSRuleNode: function(e20) {
  const t2 = dN(e20, "css-rule");
  return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
}, insideAtRuleNode: function(e20, t2) {
  const n2 = Array.isArray(t2) ? t2 : [t2], r2 = dN(e20, "css-atrule");
  return r2 && n2.includes(r2.name.toLowerCase());
}, insideURLFunctionInImportAtRuleNode: function(e20) {
  const t2 = e20.getValue(), n2 = dN(e20, "css-atrule");
  return n2 && n2.name === "import" && t2.groups[0].value === "url" && t2.groups.length === 2;
}, isKeyframeAtRuleKeywords: function(e20, t2) {
  const n2 = dN(e20, "css-atrule");
  return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t2.toLowerCase());
}, isWideKeywords: function(e20) {
  return ["initial", "inherit", "unset", "revert"].includes(e20.toLowerCase());
}, isSCSS: function(e20, t2) {
  return e20 === "less" || e20 === "scss" ? e20 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
}, isSCSSVariable: function(e20) {
  return Boolean(e20 && e20.type === "word" && e20.value.startsWith("$"));
}, isLastNode: function(e20, t2) {
  const n2 = e20.getParentNode();
  if (!n2)
    return false;
  const {nodes: r2} = n2;
  return r2 && r2.indexOf(t2) === r2.length - 1;
}, isLessParser: function(e20) {
  return e20.parser === "css" || e20.parser === "less";
}, isSCSSControlDirectiveNode: function(e20) {
  return e20.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e20.name);
}, isDetachedRulesetDeclarationNode: function(e20) {
  return !!e20.selector && (typeof e20.selector == "string" && /^@.+:.*$/.test(e20.selector) || e20.selector.value && /^@.+:.*$/.test(e20.selector.value));
}, isRelationalOperatorNode: function(e20) {
  return e20.type === "value-word" && ["<", ">", "<=", ">="].includes(e20.value);
}, isEqualityOperatorNode: function(e20) {
  return e20.type === "value-word" && ["==", "!="].includes(e20.value);
}, isMultiplicationNode: hN, isDivisionNode: gN, isAdditionNode: mN, isSubtractionNode: yN, isModuloNode: DN, isMathOperatorNode: function(e20) {
  return hN(e20) || gN(e20) || mN(e20) || yN(e20) || DN(e20);
}, isEachKeywordNode: function(e20) {
  return e20.type === "value-word" && e20.value === "in";
}, isForKeywordNode: function(e20) {
  return e20.type === "value-word" && ["from", "through", "end"].includes(e20.value);
}, isURLFunctionNode: function(e20) {
  return e20.type === "value-func" && e20.value.toLowerCase() === "url";
}, isIfElseKeywordNode: function(e20) {
  return e20.type === "value-word" && ["and", "or", "not"].includes(e20.value);
}, hasComposesNode: function(e20) {
  return e20.value && e20.value.type === "value-root" && e20.value.group && e20.value.group.type === "value-value" && e20.prop.toLowerCase() === "composes";
}, hasParensAroundNode: function(e20) {
  return e20.value && e20.value.group && e20.value.group.group && e20.value.group.group.type === "value-paren_group" && e20.value.group.group.open !== null && e20.value.group.group.close !== null;
}, hasEmptyRawBefore: function(e20) {
  return e20.raws && e20.raws.before === "";
}, isSCSSNestedPropertyNode: function(e20) {
  return !!e20.selector && e20.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
}, isDetachedRulesetCallNode: function(e20) {
  return e20.raws && e20.raws.params && /^\(\s*\)$/.test(e20.raws.params);
}, isTemplatePlaceholderNode: function(e20) {
  return e20.name.startsWith("prettier-placeholder");
}, isTemplatePropNode: function(e20) {
  return e20.prop.startsWith("@prettier-placeholder");
}, isPostcssSimpleVarNode: function(e20, t2) {
  return e20.value === "$$" && e20.type === "value-func" && t2 && t2.type === "value-word" && !t2.raws.before;
}, isKeyValuePairNode: EN, isKeyValuePairInParenGroupNode: CN, isKeyInValuePairNode: function(e20, t2) {
  if (!EN(t2))
    return false;
  const {groups: n2} = t2, r2 = n2.indexOf(e20);
  return r2 !== -1 && bN(n2[r2 + 1]);
}, isSCSSMapItemNode: function(e20) {
  const t2 = e20.getValue();
  if (t2.groups.length === 0)
    return false;
  const n2 = e20.getParentNode(1);
  if (!(CN(t2) || n2 && CN(n2)))
    return false;
  const r2 = dN(e20, "css-decl");
  return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!CN(n2) || n2.type === "value-func");
}, isInlineValueCommentNode: function(e20) {
  return e20.type === "value-comment" && e20.inline;
}, isHashNode: function(e20) {
  return e20.type === "value-word" && e20.value === "#";
}, isLeftCurlyBraceNode: function(e20) {
  return e20.type === "value-word" && e20.value === "{";
}, isRightCurlyBraceNode: function(e20) {
  return e20.type === "value-word" && e20.value === "}";
}, isWordNode: function(e20) {
  return ["value-word", "value-atword"].includes(e20.type);
}, isColonNode: bN, isMediaAndSupportsKeywords: function(e20) {
  return e20.value && ["not", "and", "or"].includes(e20.value.toLowerCase());
}, isColorAdjusterFuncNode: function(e20) {
  return e20.type === "value-func" && lN.has(e20.value.toLowerCase());
}, lastLineHasInlineComment: function(e20) {
  return /\/\//.test(e20.split(/[\n\r]/).pop());
}, stringifyNode: function e7(t2) {
  if (t2.groups) {
    return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n3, r3, i2) => n3 + e7(r3) + (t2.groups[0].type === "comma_group" && i2 !== t2.groups.length - 1 ? "," : ""), "") + (t2.close && t2.close.value ? t2.close.value : "");
  }
  const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
  return n2 + r2 + (t2.type === "atword" ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e7(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
}, isAtWordPlaceholderNode: function(e20) {
  return e20 && e20.type === "value-atword" && e20.value.startsWith("prettier-placeholder-");
}, isModuleRuleName: function(e20) {
  return pN.has(e20);
}}, vN = function(e20, t2) {
  let n2 = 0;
  for (let r2 = 0; r2 < e20.line - 1; ++r2)
    n2 = t2.indexOf("\n", n2) + 1;
  return n2 + e20.column;
};
const {getLast: FN, skipEverythingButNewLine: SN} = yi$2;
function xN(e20, t2) {
  return typeof e20.sourceIndex == "number" ? e20.sourceIndex : e20.source ? vN(e20.source.start, t2) - 1 : null;
}
function wN(e20, t2) {
  if (e20.type === "css-comment" && e20.inline)
    return SN(t2, e20.source.startOffset);
  const n2 = e20.nodes && FN(e20.nodes);
  return n2 && e20.source && !e20.source.end && (e20 = n2), e20.source && e20.source.end ? vN(e20.source.end, t2) : null;
}
function TN(e20, t2, n2) {
  e20.source && (e20.source.startOffset = xN(e20, n2) + t2, e20.source.endOffset = wN(e20, n2) + t2);
  for (const r2 in e20) {
    const i2 = e20[r2];
    r2 !== "source" && i2 && typeof i2 == "object" && TN(i2, t2, n2);
  }
}
function BN(e20) {
  let t2 = e20.source.startOffset;
  return typeof e20.prop == "string" && (t2 += e20.prop.length), e20.type === "css-atrule" && typeof e20.name == "string" && (t2 += 1 + e20.name.length + e20.raws.afterName.match(/^\s*:?\s*/)[0].length), e20.type !== "css-atrule" && e20.raws && typeof e20.raws.between == "string" && (t2 += e20.raws.between.length), t2;
}
var NN = {locStart: function(e20) {
  return e20.source.startOffset;
}, locEnd: function(e20) {
  return e20.source.endOffset;
}, calculateLoc: function e8(t2, n2) {
  t2.source && (t2.source.startOffset = xN(t2, n2), t2.source.endOffset = wN(t2, n2));
  for (const r2 in t2) {
    const i2 = t2[r2];
    r2 !== "source" && i2 && typeof i2 == "object" && (i2.type === "value-root" || i2.type === "value-unknown" ? TN(i2, BN(t2), i2.text || i2.value) : e8(i2, n2));
  }
}, replaceQuotesInInlineComments: function(e20) {
  let t2, n2 = "initial", r2 = "initial", i2 = false;
  const u2 = [];
  for (let o2 = 0; o2 < e20.length; o2++) {
    const s2 = e20[o2];
    switch (n2) {
      case "initial":
        if (s2 === "'") {
          n2 = "single-quotes";
          continue;
        }
        if (s2 === '"') {
          n2 = "double-quotes";
          continue;
        }
        if ((s2 === "u" || s2 === "U") && e20.slice(o2, o2 + 4).toLowerCase() === "url(") {
          n2 = "url", o2 += 3;
          continue;
        }
        if (s2 === "*" && e20[o2 - 1] === "/") {
          n2 = "comment-block";
          continue;
        }
        if (s2 === "/" && e20[o2 - 1] === "/") {
          n2 = "comment-inline", t2 = o2 - 1;
          continue;
        }
        continue;
      case "single-quotes":
        if (s2 === "'" && e20[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
          return e20;
        continue;
      case "double-quotes":
        if (s2 === '"' && e20[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
          return e20;
        continue;
      case "url":
        if (s2 === ")" && (n2 = "initial"), s2 === "\n" || s2 === "\r")
          return e20;
        if (s2 === "'") {
          n2 = "single-quotes", r2 = "url";
          continue;
        }
        if (s2 === '"') {
          n2 = "double-quotes", r2 = "url";
          continue;
        }
        continue;
      case "comment-block":
        s2 === "/" && e20[o2 - 1] === "*" && (n2 = "initial");
        continue;
      case "comment-inline":
        s2 !== '"' && s2 !== "'" && s2 !== "*" || (i2 = true), s2 !== "\n" && s2 !== "\r" || (i2 && u2.push([t2, o2]), n2 = "initial", i2 = false);
        continue;
    }
  }
  for (const [t3, n3] of u2)
    e20 = e20.slice(0, t3) + e20.slice(t3, n3).replace(/["'*]/g, " ") + e20.slice(n3);
  return e20;
}};
const {printNumber: kN, printString: PN, hasNewline: ON, isFrontMatterNode: IN, isNextLineEmpty: LN, isNonEmptyArray: jN} = yi$2, {builders: {join: _N, line: MN, hardline: RN, softline: $N, group: VN, fill: WN, indent: qN, dedent: UN, ifBreak: zN, breakParent: GN}, utils: {removeLines: HN, getDocParts: JN}} = eu$1, {insertPragma: XN} = aN, {getAncestorNode: YN, getPropOfDeclNode: KN, maybeToLowerCase: QN, insideValueFunctionNode: ZN, insideICSSRuleNode: ek, insideAtRuleNode: tk, insideURLFunctionInImportAtRuleNode: nk, isKeyframeAtRuleKeywords: rk, isWideKeywords: ik, isSCSS: uk, isLastNode: ok, isLessParser: sk, isSCSSControlDirectiveNode: ak, isDetachedRulesetDeclarationNode: ck, isRelationalOperatorNode: lk, isEqualityOperatorNode: pk, isMultiplicationNode: fk, isDivisionNode: dk, isAdditionNode: hk, isSubtractionNode: gk, isMathOperatorNode: mk, isEachKeywordNode: yk, isForKeywordNode: Dk, isURLFunctionNode: Ek, isIfElseKeywordNode: Ck, hasComposesNode: bk, hasParensAroundNode: Ak, hasEmptyRawBefore: vk, isKeyValuePairNode: Fk, isKeyInValuePairNode: Sk, isDetachedRulesetCallNode: xk, isTemplatePlaceholderNode: wk, isTemplatePropNode: Tk, isPostcssSimpleVarNode: Bk, isSCSSMapItemNode: Nk, isInlineValueCommentNode: kk, isHashNode: Pk, isLeftCurlyBraceNode: Ok, isRightCurlyBraceNode: Ik, isWordNode: Lk, isColonNode: jk, isMediaAndSupportsKeywords: _k, isColorAdjusterFuncNode: Mk, lastLineHasInlineComment: Rk, isAtWordPlaceholderNode: $k} = AN, {locStart: Vk, locEnd: Wk} = NN;
function qk(e20) {
  return e20.trailingComma === "es5" || e20.trailingComma === "all";
}
function Uk(e20, t2, n2) {
  const r2 = [];
  return e20.each((e21, i2, u2) => {
    const o2 = u2[i2 - 1];
    if (o2 && o2.type === "css-comment" && o2.text.trim() === "prettier-ignore") {
      const n3 = e21.getValue();
      r2.push(t2.originalText.slice(Vk(n3), Wk(n3)));
    } else
      r2.push(n2());
    i2 !== u2.length - 1 && (u2[i2 + 1].type === "css-comment" && !ON(t2.originalText, Vk(u2[i2 + 1]), {backwards: true}) && !IN(u2[i2]) || u2[i2 + 1].type === "css-atrule" && u2[i2 + 1].name === "else" && u2[i2].type !== "css-comment" ? r2.push(" ") : (r2.push(t2.__isHTMLStyleAttribute ? MN : RN), LN(t2.originalText, e21.getValue(), Wk) && !IN(u2[i2]) && r2.push(RN)));
  }, "nodes"), r2;
}
const zk = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Gk = new RegExp(zk.source + `|(${/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source})?(${/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source})(${/[A-Za-z]+/g.source})?`, "g");
function Hk(e20, t2) {
  return e20.replace(zk, (e21) => PN(e21, t2));
}
function Jk(e20, t2) {
  const n2 = t2.singleQuote ? "'" : '"';
  return e20.includes('"') || e20.includes("'") ? e20 : n2 + e20 + n2;
}
function Xk(e20) {
  return e20.replace(Gk, (e21, t2, n2, r2, i2) => !n2 && r2 ? Yk(r2) + QN(i2 || "") : e21);
}
function Yk(e20) {
  return kN(e20).replace(/\.0(?=$|e)/, "");
}
var Kk = {print: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2)
    return "";
  if (typeof r2 == "string")
    return r2;
  switch (r2.type) {
    case "front-matter":
      return [r2.raw, RN];
    case "css-root": {
      const i2 = Uk(e20, t2, n2), u2 = r2.raws.after.trim();
      return [i2, u2 ? ` ${u2}` : "", JN(i2).length > 0 ? RN : ""];
    }
    case "css-comment": {
      const e21 = r2.inline || r2.raws.inline, n3 = t2.originalText.slice(Vk(r2), Wk(r2));
      return e21 ? n3.trimEnd() : n3;
    }
    case "css-rule":
      return [n2("selector"), r2.important ? " !important" : "", r2.nodes ? [r2.selector && r2.selector.type === "selector-unknown" && Rk(r2.selector.value) ? MN : " ", "{", r2.nodes.length > 0 ? qN([RN, Uk(e20, t2, n2)]) : "", RN, "}", ck(r2) ? ";" : ""] : ";"];
    case "css-decl": {
      const i2 = e20.getParentNode(), {between: u2} = r2.raws, o2 = u2.trim(), s2 = o2 === ":";
      let a2 = bk(r2) ? HN(n2("value")) : n2("value");
      return !s2 && Rk(o2) && (a2 = qN([RN, UN(a2)])), [r2.raws.before.replace(/[\s;]/g, ""), ek(e20) ? r2.prop : QN(r2.prop), o2.startsWith("//") ? " " : "", o2, r2.extend ? "" : " ", sk(t2) && r2.extend && r2.selector ? ["extend(", n2("selector"), ")"] : "", a2, r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "", r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "", r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "", r2.nodes ? [" {", qN([$N, Uk(e20, t2, n2)]), $N, "}"] : Tk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";" ? "" : t2.__isHTMLStyleAttribute && ok(e20, r2) ? zN(";") : ";"];
    }
    case "css-atrule": {
      const i2 = e20.getParentNode(), u2 = wk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";";
      if (sk(t2)) {
        if (r2.mixin)
          return [n2("selector"), r2.important ? " !important" : "", u2 ? "" : ";"];
        if (r2.function)
          return [r2.name, n2("params"), u2 ? "" : ";"];
        if (r2.variable)
          return ["@", r2.name, ": ", r2.value ? n2("value") : "", r2.raws.between.trim() ? r2.raws.between.trim() + " " : "", r2.nodes ? ["{", qN([r2.nodes.length > 0 ? $N : "", Uk(e20, t2, n2)]), $N, "}"] : "", u2 ? "" : ";"];
      }
      return ["@", xk(r2) || r2.name.endsWith(":") ? r2.name : QN(r2.name), r2.params ? [xk(r2) ? "" : wk(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? [RN, RN] : /^\s*\n/.test(r2.raws.afterName) ? RN : " " : " ", n2("params")] : "", r2.selector ? qN([" ", n2("selector")]) : "", r2.value ? VN([" ", n2("value"), ak(r2) ? Ak(r2) ? " " : MN : ""]) : r2.name === "else" ? " " : "", r2.nodes ? [ak(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && Rk(r2.selector.value) || !r2.selector && typeof r2.params == "string" && Rk(r2.params) ? MN : " ", "{", qN([r2.nodes.length > 0 ? $N : "", Uk(e20, t2, n2)]), $N, "}"] : u2 ? "" : ";"];
    }
    case "media-query-list": {
      const t3 = [];
      return e20.each((e21) => {
        const r3 = e21.getValue();
        r3.type === "media-query" && r3.value === "" || t3.push(n2());
      }, "nodes"), VN(qN(_N(MN, t3)));
    }
    case "media-query":
      return [_N(" ", e20.map(n2, "nodes")), ok(e20, r2) ? "" : ","];
    case "media-type":
      return Xk(Hk(r2.value, t2));
    case "media-feature-expression":
      return r2.nodes ? ["(", ...e20.map(n2, "nodes"), ")"] : r2.value;
    case "media-feature":
      return QN(Hk(r2.value.replace(/ +/g, " "), t2));
    case "media-colon":
      return [r2.value, " "];
    case "media-value":
      return Xk(Hk(r2.value, t2));
    case "media-keyword":
      return Hk(r2.value, t2);
    case "media-url":
      return Hk(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t2);
    case "media-unknown":
      return r2.value;
    case "selector-root":
      return VN([tk(e20, "custom-selector") ? [YN(e20, "css-atrule").customSelector, MN] : "", _N([",", tk(e20, ["extend", "custom-selector", "nest"]) ? MN : RN], e20.map(n2, "nodes"))]);
    case "selector-selector":
      return VN(qN(e20.map(n2, "nodes")));
    case "selector-comment":
      return r2.value;
    case "selector-string":
      return Hk(r2.value, t2);
    case "selector-tag": {
      const t3 = e20.getParentNode(), n3 = t3 && t3.nodes.indexOf(r2), i2 = n3 && t3.nodes[n3 - 1];
      return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", i2.type === "selector-nesting" ? r2.value : Xk(rk(e20, r2.value) ? r2.value.toLowerCase() : r2.value)];
    }
    case "selector-id":
      return ["#", r2.value];
    case "selector-class":
      return [".", Xk(Hk(r2.value, t2))];
    case "selector-attribute":
      return ["[", r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.attribute.trim(), r2.operator ? r2.operator : "", r2.value ? Jk(Hk(r2.value.trim(), t2), t2) : "", r2.insensitive ? " i" : "", "]"];
    case "selector-combinator":
      if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
        const t3 = e20.getParentNode();
        return [t3.type === "selector-selector" && t3.nodes[0] === r2 ? "" : MN, r2.value, ok(e20, r2) ? "" : " "];
      }
      return [r2.value.trim().startsWith("(") ? MN : "", Xk(Hk(r2.value.trim(), t2)) || MN];
    case "selector-universal":
      return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.value];
    case "selector-pseudo":
      return [QN(r2.value), jN(r2.nodes) ? ["(", _N(", ", e20.map(n2, "nodes")), ")"] : ""];
    case "selector-nesting":
      return r2.value;
    case "selector-unknown": {
      const n3 = YN(e20, "css-rule");
      if (n3 && n3.isSCSSNesterProperty)
        return Xk(Hk(QN(r2.value), t2));
      const i2 = e20.getParentNode();
      if (i2.raws && i2.raws.selector) {
        const e21 = Vk(i2), n4 = e21 + i2.raws.selector.length;
        return t2.originalText.slice(e21, n4).trim();
      }
      const u2 = e20.getParentNode(1);
      if (i2.type === "value-paren_group" && u2 && u2.type === "value-func" && u2.value === "selector") {
        const e21 = Vk(i2.open) + 1, n4 = Wk(i2.close) - 1, r3 = t2.originalText.slice(e21, n4).trim();
        return Rk(r3) ? [GN, r3] : r3;
      }
      return r2.value;
    }
    case "value-value":
    case "value-root":
      return n2("group");
    case "value-comment":
      return t2.originalText.slice(Vk(r2), Wk(r2));
    case "value-comma_group": {
      const t3 = e20.getParentNode(), i2 = e20.getParentNode(1), u2 = KN(e20), o2 = u2 && t3.type === "value-value" && (u2 === "grid" || u2.startsWith("grid-template")), s2 = YN(e20, "css-atrule"), a2 = s2 && ak(s2), c2 = r2.groups.some((e21) => kk(e21)), l2 = e20.map(n2, "groups"), p2 = [], f2 = ZN(e20, "url");
      let d2 = false, h2 = false;
      for (let n3 = 0; n3 < r2.groups.length; ++n3) {
        p2.push(l2[n3]);
        const u3 = r2.groups[n3 - 1], c3 = r2.groups[n3], g2 = r2.groups[n3 + 1], m2 = r2.groups[n3 + 2];
        if (f2) {
          (g2 && hk(g2) || hk(c3)) && p2.push(" ");
          continue;
        }
        if (tk(e20, "forward") && c3.type === "value-word" && c3.value && u3.type === "value-word" && u3.value === "as" && g2.type === "value-operator" && g2.value === "*")
          continue;
        if (!g2)
          continue;
        if (c3.type === "value-word" && c3.value.endsWith("-") && $k(g2))
          continue;
        const y2 = c3.type === "value-string" && c3.value.startsWith("#{"), D2 = d2 && g2.type === "value-string" && g2.value.endsWith("}");
        if (y2 || D2) {
          d2 = !d2;
          continue;
        }
        if (d2)
          continue;
        if (jk(c3) || jk(g2))
          continue;
        if (c3.type === "value-atword" && c3.value === "")
          continue;
        if (c3.value === "~")
          continue;
        if (c3.value && c3.value.includes("\\") && g2 && g2.type !== "value-comment")
          continue;
        if (u3 && u3.value && u3.value.indexOf("\\") === u3.value.length - 1 && c3.type === "value-operator" && c3.value === "/")
          continue;
        if (c3.value === "\\")
          continue;
        if (Bk(c3, g2))
          continue;
        if (Pk(c3) || Ok(c3) || Ik(g2) || Ok(g2) && vk(g2) || Ik(c3) && vk(g2))
          continue;
        if (c3.value === "--" && Pk(g2))
          continue;
        const E2 = mk(c3), C2 = mk(g2);
        if ((E2 && Pk(g2) || C2 && Ik(c3)) && vk(g2))
          continue;
        if (!u3 && dk(c3))
          continue;
        if (ZN(e20, "calc") && (hk(c3) || hk(g2) || gk(c3) || gk(g2)) && vk(g2))
          continue;
        const b2 = (hk(c3) || gk(c3)) && n3 === 0 && (g2.type === "value-number" || g2.isHex) && i2 && Mk(i2) && !vk(g2), A2 = m2 && m2.type === "value-func" || m2 && Lk(m2) || c3.type === "value-func" || Lk(c3), v2 = g2.type === "value-func" || Lk(g2) || u3 && u3.type === "value-func" || u3 && Lk(u3);
        if (fk(g2) || fk(c3) || ZN(e20, "calc") || b2 || !(dk(g2) && !A2 || dk(c3) && !v2 || hk(g2) && !A2 || hk(c3) && !v2 || gk(g2) || gk(c3)) || !(vk(g2) || E2 && (!u3 || u3 && mk(u3))))
          if (kk(c3)) {
            if (t3.type === "value-paren_group") {
              p2.push(UN(RN));
              continue;
            }
            p2.push(RN);
          } else
            a2 && (pk(g2) || lk(g2) || Ck(g2) || yk(c3) || Dk(c3)) || s2 && s2.name.toLowerCase() === "namespace" ? p2.push(" ") : o2 ? c3.source && g2.source && c3.source.start.line !== g2.source.start.line ? (p2.push(RN), h2 = true) : p2.push(" ") : C2 ? p2.push(" ") : g2 && g2.value === "..." || $k(c3) && $k(g2) && Wk(c3) === Vk(g2) || p2.push(MN);
      }
      return c2 && p2.push(GN), h2 && p2.unshift(RN), a2 ? VN(qN(p2)) : nk(e20) ? VN(WN(p2)) : VN(qN(WN(p2)));
    }
    case "value-paren_group": {
      const i2 = e20.getParentNode();
      if (i2 && Ek(i2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
        return [r2.open ? n2("open") : "", _N(",", e20.map(n2, "groups")), r2.close ? n2("close") : ""];
      if (!r2.open) {
        const t3 = e20.map(n2, "groups"), r3 = [];
        for (let e21 = 0; e21 < t3.length; e21++)
          e21 !== 0 && r3.push([",", MN]), r3.push(t3[e21]);
        return VN(qN(WN(r3)));
      }
      const u2 = Nk(e20), o2 = Ln$2(r2.groups), s2 = o2 && o2.type === "value-comment", a2 = Sk(r2, i2), c2 = VN([r2.open ? n2("open") : "", qN([$N, _N([",", MN], e20.map((e21) => {
        const t3 = e21.getValue(), r3 = n2();
        if (Fk(t3) && t3.type === "value-comma_group" && t3.groups && t3.groups[0].type !== "value-paren_group" && t3.groups[2] && t3.groups[2].type === "value-paren_group") {
          const e22 = JN(r3.contents.contents);
          return e22[1] = VN(e22[1]), VN(UN(r3));
        }
        return r3;
      }, "groups"))]), zN(!s2 && uk(t2.parser, t2.originalText) && u2 && qk(t2) ? "," : ""), $N, r2.close ? n2("close") : ""], {shouldBreak: u2 && !a2});
      return a2 ? UN(c2) : c2;
    }
    case "value-func":
      return [r2.value, tk(e20, "supports") && _k(r2) ? " " : "", n2("group")];
    case "value-paren":
      return r2.value;
    case "value-number":
      return [Yk(r2.value), QN(r2.unit)];
    case "value-operator":
      return r2.value;
    case "value-word":
      return r2.isColor && r2.isHex || ik(r2.value) ? r2.value.toLowerCase() : r2.value;
    case "value-colon": {
      const t3 = e20.getParentNode(), n3 = t3 && t3.groups.indexOf(r2), i2 = n3 && t3.groups[n3 - 1];
      return [r2.value, i2 && typeof i2.value == "string" && Ln$2(i2.value) === "\\" || ZN(e20, "url") ? "" : MN];
    }
    case "value-comma":
      return [r2.value, " "];
    case "value-string":
      return PN(r2.raws.quote + r2.value + r2.raws.quote, t2);
    case "value-atword":
      return ["@", r2.value];
    case "value-unicode-range":
    case "value-unknown":
      return r2.value;
    default:
      throw new Error(`Unknown postcss type ${JSON.stringify(r2.type)}`);
  }
}, embed: uN, insertPragma: XN, massageAstNode: eN}, Qk = {singleQuote: WB.singleQuote}, Zk = {name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437}, eP = {name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198}, tP = {name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329};
var nP = {languages: [Xd({name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50}, (e20) => ({since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e20.extensions, ".wxss"]})), Xd(Zk, () => ({since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"]})), Xd(eP, () => ({since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"]})), Xd(tP, () => ({since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"]}))], options: Qk, printers: {postcss: Kk}, parsers: void 0};
var rP = {locStart: function(e20) {
  return e20.loc.start.offset;
}, locEnd: function(e20) {
  return e20.loc.end.offset;
}};
function iP(e20, t2) {
  if (e20.type === "TextNode") {
    const n2 = e20.chars.trim();
    if (!n2)
      return null;
    t2.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
  }
  e20.type === "AttrNode" && e20.name.toLowerCase() === "class" && delete t2.value;
}
iP.ignoredProperties = new Set(["loc", "selfClosing"]);
var uP = iP;
const oP = new Set(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
function sP(e20) {
  return aP(e20, ["TextNode"]) && !/\S/.test(e20.chars);
}
function aP(e20, t2) {
  return e20 && t2.includes(e20.type);
}
function cP(e20, t2) {
  return aP(e20.getParentNode(0), t2);
}
function lP(e20, t2) {
  const n2 = e20.getValue(), r2 = e20.getParentNode(0) || {}, i2 = r2.children || r2.body || r2.parts || [], u2 = i2.indexOf(n2);
  return u2 !== -1 && i2[u2 + t2];
}
function pP(e20, t2 = 1) {
  return lP(e20, -t2);
}
function fP(e20) {
  return lP(e20, 1);
}
function dP(e20) {
  return aP(e20, ["MustacheCommentStatement"]) && typeof e20.value == "string" && e20.value.trim() === "prettier-ignore";
}
var hP = {getNextNode: fP, getPreviousNode: pP, hasPrettierIgnore: function(e20) {
  const t2 = e20.getValue(), n2 = pP(e20, 2);
  return dP(t2) || dP(n2);
}, isLastNodeOfSiblings: function(e20) {
  const t2 = e20.getValue(), n2 = e20.getParentNode(0);
  return !(!cP(e20, ["ElementNode"]) || Ln$2(n2.children) !== t2) || !(!cP(e20, ["Block"]) || Ln$2(n2.body) !== t2);
}, isNextNodeOfSomeType: function(e20, t2) {
  return aP(fP(e20), t2);
}, isNodeOfSomeType: aP, isParentOfSomeType: cP, isPreviousNodeOfSomeType: function(e20, t2) {
  return aP(pP(e20), t2);
}, isVoid: function(e20) {
  return function(e21) {
    return aP(e21, ["ElementNode"]) && typeof e21.tag == "string" && (function(e22) {
      return e22.toUpperCase() === e22;
    }(e21.tag[0]) || e21.tag.includes("."));
  }(e20) && e20.children.every((e21) => sP(e21)) || oP.has(e20.tag);
}, isWhitespaceNode: sP};
const {builders: {dedent: gP, fill: mP, group: yP, hardline: DP, ifBreak: EP, indent: CP, join: bP, line: AP, softline: vP}, utils: {getDocParts: FP, replaceTextEndOfLine: SP}} = eu$1, {isNonEmptyArray: xP} = yi$2, {locStart: wP, locEnd: TP} = rP, {getNextNode: BP, getPreviousNode: NP, hasPrettierIgnore: kP, isLastNodeOfSiblings: PP, isNextNodeOfSomeType: OP, isNodeOfSomeType: IP, isParentOfSomeType: LP, isPreviousNodeOfSomeType: jP, isVoid: _P, isWhitespaceNode: MP} = hP;
function RP(e20, t2) {
  return wP(e20) - wP(t2);
}
function $P(e20, t2, n2) {
  const r2 = e20.getValue().children.every((e21) => MP(e21));
  return t2.htmlWhitespaceSensitivity === "ignore" && r2 ? "" : e20.map((e21, r3) => {
    const i2 = n2();
    return r3 === 0 && t2.htmlWhitespaceSensitivity === "ignore" ? [vP, i2] : i2;
  }, "children");
}
function VP(e20) {
  return _P(e20) ? EP([vP, "/>"], [" />", vP]) : EP([vP, ">"], ">");
}
function WP(e20) {
  return [e20.escaped === false ? "{{{" : "{{", e20.strip && e20.strip.open ? "~" : ""];
}
function qP(e20) {
  const t2 = e20.escaped === false ? "}}}" : "}}";
  return [e20.strip && e20.strip.close ? "~" : "", t2];
}
function UP(e20) {
  return [WP(e20), e20.closeStrip.open ? "~" : "", "/"];
}
function zP(e20) {
  const t2 = qP(e20);
  return [e20.closeStrip.close ? "~" : "", t2];
}
function GP(e20) {
  return [WP(e20), e20.inverseStrip.open ? "~" : ""];
}
function HP(e20) {
  const t2 = qP(e20);
  return [e20.inverseStrip.close ? "~" : "", t2];
}
function JP(e20, t2) {
  const n2 = e20.getValue(), r2 = function(e21) {
    return [WP(e21), e21.openStrip.open ? "~" : "", "#"];
  }(n2), i2 = function(e21) {
    const t3 = qP(e21);
    return [e21.openStrip.close ? "~" : "", t3];
  }(n2), u2 = [aO(e20, t2)], o2 = cO(e20, t2);
  if (o2 && u2.push(AP, o2), xP(n2.program.blockParams)) {
    const e21 = lO(n2.program);
    u2.push(AP, e21);
  }
  return yP([r2, CP(u2), vP, i2]);
}
function XP(e20, t2) {
  return [t2.htmlWhitespaceSensitivity === "ignore" ? DP : "", GP(e20), "else", HP(e20)];
}
function YP(e20, t2) {
  const n2 = e20.getParentNode(1);
  return [GP(n2), "else if ", cO(e20, t2), HP(n2)];
}
function KP(e20, t2, n2) {
  const r2 = e20.getValue();
  if (n2.htmlWhitespaceSensitivity === "ignore") {
    return [QP(r2) ? vP : DP, UP(r2), t2("path"), zP(r2)];
  }
  return [UP(r2), t2("path"), zP(r2)];
}
function QP(e20) {
  return IP(e20, ["BlockStatement"]) && e20.program.body.every((e21) => MP(e21));
}
function ZP(e20) {
  return IP(e20, ["BlockStatement"]) && e20.inverse;
}
function eO(e20, t2, n2) {
  if (QP(e20.getValue()))
    return "";
  const r2 = t2("program");
  return n2.htmlWhitespaceSensitivity === "ignore" ? CP([DP, r2]) : CP(r2);
}
function tO(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2("inverse"), u2 = n2.htmlWhitespaceSensitivity === "ignore" ? [DP, i2] : i2;
  return function(e21) {
    return ZP(e21) && e21.inverse.body.length === 1 && IP(e21.inverse.body[0], ["BlockStatement"]) && e21.inverse.body[0].path.parts[0] === "if";
  }(r2) ? u2 : ZP(r2) ? [XP(r2, n2), CP(u2)] : "";
}
function nO(e20) {
  return FP(bP(AP, function(e21) {
    return e21.split(/[\t\n\f\r ]+/);
  }(e20)));
}
function rO(e20) {
  return (e20 = typeof e20 == "string" ? e20 : "").split("\n").length - 1;
}
function iO(e20 = 0) {
  return new Array(Math.min(e20, 2)).fill(DP);
}
function uO(e20, t2) {
  const n2 = {quote: '"', regex: /"/g}, r2 = {quote: "'", regex: /'/g}, i2 = e20.singleQuote ? r2 : n2, u2 = i2 === r2 ? n2 : r2;
  let o2 = false;
  if (t2.includes(i2.quote) || t2.includes(u2.quote)) {
    o2 = (t2.match(i2.regex) || []).length > (t2.match(u2.regex) || []).length;
  }
  return o2 ? u2 : i2;
}
function oO(e20, t2) {
  const n2 = aO(e20, t2), r2 = cO(e20, t2);
  return r2 ? CP([n2, AP, yP(r2)]) : n2;
}
function sO(e20, t2) {
  const n2 = aO(e20, t2), r2 = cO(e20, t2);
  return r2 ? [CP([n2, AP, r2]), vP] : n2;
}
function aO(e20, t2) {
  return t2("path");
}
function cO(e20, t2) {
  const n2 = e20.getValue(), r2 = [];
  if (n2.params.length > 0) {
    const n3 = e20.map(t2, "params");
    r2.push(...n3);
  }
  if (n2.hash && n2.hash.pairs.length > 0) {
    const e21 = t2("hash");
    r2.push(e21);
  }
  return r2.length === 0 ? "" : bP(AP, r2);
}
function lO(e20) {
  return ["as |", e20.blockParams.join(" "), "|"];
}
var pO = {print: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2)
    return "";
  if (kP(e20))
    return t2.originalText.slice(wP(r2), TP(r2));
  switch (r2.type) {
    case "Block":
    case "Program":
    case "Template":
      return yP(e20.map(n2, "body"));
    case "ElementNode": {
      const i2 = yP(function(e21, t3) {
        const n3 = e21.getValue(), r3 = ["attributes", "modifiers", "comments"].filter((e22) => xP(n3[e22])), i3 = r3.flatMap((e22) => n3[e22]).sort(RP);
        for (const n4 of r3)
          e21.each((e22) => {
            const n5 = i3.indexOf(e22.getValue());
            i3.splice(n5, 1, [AP, t3()]);
          }, n4);
        xP(n3.blockParams) && i3.push(AP, lO(n3));
        return ["<", n3.tag, CP(i3), VP(n3)];
      }(e20, n2)), u2 = t2.htmlWhitespaceSensitivity === "ignore" && OP(e20, ["ElementNode"]) ? vP : "";
      if (_P(r2))
        return [i2, u2];
      const o2 = ["</", r2.tag, ">"];
      return r2.children.length === 0 ? [i2, CP(o2), u2] : t2.htmlWhitespaceSensitivity === "ignore" ? [i2, CP($P(e20, t2, n2)), DP, CP(o2), u2] : [i2, CP(yP($P(e20, t2, n2))), CP(o2), u2];
    }
    case "BlockStatement": {
      const i2 = e20.getParentNode(1);
      return i2 && i2.inverse && i2.inverse.body.length === 1 && i2.inverse.body[0] === r2 && i2.inverse.body[0].path.parts[0] === "if" ? [YP(e20, n2), eO(e20, n2, t2), tO(e20, n2, t2)] : [JP(e20, n2), yP([eO(e20, n2, t2), tO(e20, n2, t2), KP(e20, n2, t2)])];
    }
    case "ElementModifierStatement":
      return yP(["{{", sO(e20, n2), "}}"]);
    case "MustacheStatement":
      return yP([WP(r2), sO(e20, n2), qP(r2)]);
    case "SubExpression":
      return yP(["(", oO(e20, n2), vP, ")"]);
    case "AttrNode": {
      const e21 = r2.value.type === "TextNode";
      if (e21 && r2.value.chars === "" && wP(r2.value) === TP(r2.value))
        return r2.name;
      const i2 = e21 ? uO(t2, r2.value.chars).quote : r2.value.type === "ConcatStatement" ? uO(t2, r2.value.parts.filter((e22) => e22.type === "TextNode").map((e22) => e22.chars).join("")).quote : "", u2 = n2("value");
      return [r2.name, "=", i2, r2.name === "class" && i2 ? yP(CP(u2)) : u2, i2];
    }
    case "ConcatStatement":
      return e20.map(n2, "parts");
    case "Hash":
      return bP(AP, e20.map(n2, "pairs"));
    case "HashPair":
      return [r2.key, "=", n2("value")];
    case "TextNode": {
      let n3 = r2.chars.replace(/{{/g, "\\{{");
      const i2 = function(e21) {
        for (let t3 = 0; t3 < 2; t3++) {
          const n4 = e21.getParentNode(t3);
          if (n4 && n4.type === "AttrNode")
            return n4.name.toLowerCase();
        }
      }(e20);
      if (i2) {
        if (i2 === "class") {
          const t3 = n3.trim().split(/\s+/).join(" ");
          let r3 = false, i3 = false;
          return LP(e20, ["ConcatStatement"]) && (jP(e20, ["MustacheStatement"]) && /^\s/.test(n3) && (r3 = true), OP(e20, ["MustacheStatement"]) && /\s$/.test(n3) && t3 !== "" && (i3 = true)), [r3 ? AP : "", t3, i3 ? AP : ""];
        }
        return SP(n3);
      }
      const u2 = /^[\t\n\f\r ]*$/.test(n3), o2 = !NP(e20), s2 = !BP(e20);
      if (t2.htmlWhitespaceSensitivity !== "ignore") {
        const t3 = /^[\t\n\f\r ]*/, r3 = /[\t\n\f\r ]*$/, i3 = s2 && LP(e20, ["Template"]), a3 = o2 && LP(e20, ["Template"]);
        if (u2) {
          if (a3 || i3)
            return "";
          let t4 = [AP];
          const r4 = rO(n3);
          return r4 && (t4 = iO(r4)), PP(e20) && (t4 = t4.map((e21) => gP(e21))), t4;
        }
        const [c3] = n3.match(t3), [l3] = n3.match(r3);
        let p3 = [];
        if (c3) {
          p3 = [AP];
          const e21 = rO(c3);
          e21 && (p3 = iO(e21)), n3 = n3.replace(t3, "");
        }
        let f3 = [];
        if (l3) {
          if (!i3) {
            f3 = [AP];
            const t4 = rO(l3);
            t4 && (f3 = iO(t4)), PP(e20) && (f3 = f3.map((e21) => gP(e21)));
          }
          n3 = n3.replace(r3, "");
        }
        return [...p3, mP(nO(n3)), ...f3];
      }
      const a2 = rO(n3);
      let c2 = function(e21) {
        return rO(((e21 = typeof e21 == "string" ? e21 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
      }(n3), l2 = function(e21) {
        return rO(((e21 = typeof e21 == "string" ? e21 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
      }(n3);
      if ((o2 || s2) && u2 && LP(e20, ["Block", "ElementNode", "Template"]))
        return "";
      u2 && a2 ? (c2 = Math.min(a2, 2), l2 = 0) : (OP(e20, ["BlockStatement", "ElementNode"]) && (l2 = Math.max(l2, 1)), jP(e20, ["BlockStatement", "ElementNode"]) && (c2 = Math.max(c2, 1)));
      let p2 = "", f2 = "";
      return l2 === 0 && OP(e20, ["MustacheStatement"]) && (f2 = " "), c2 === 0 && jP(e20, ["MustacheStatement"]) && (p2 = " "), o2 && (c2 = 0, p2 = ""), s2 && (l2 = 0, f2 = ""), n3 = n3.replace(/^[\t\n\f\r ]+/g, p2).replace(/[\t\n\f\r ]+$/, f2), [...iO(c2), mP(nO(n3)), ...iO(l2)];
    }
    case "MustacheCommentStatement": {
      const e21 = wP(r2), n3 = TP(r2), i2 = t2.originalText.charAt(e21 + 2) === "~", u2 = t2.originalText.charAt(n3 - 3) === "~", o2 = r2.value.includes("}}") ? "--" : "";
      return ["{{", i2 ? "~" : "", "!", o2, r2.value, o2, u2 ? "~" : "", "}}"];
    }
    case "PathExpression":
      return r2.original;
    case "BooleanLiteral":
      return String(r2.value);
    case "CommentStatement":
      return ["<!--", r2.value, "-->"];
    case "StringLiteral":
      return function(e21, t3) {
        const {quote: n3, regex: r3} = uO(t3, e21);
        return [n3, e21.replace(r3, `\\${n3}`), n3];
      }(r2.value, t2);
    case "NumberLiteral":
      return String(r2.value);
    case "UndefinedLiteral":
      return "undefined";
    case "NullLiteral":
      return "null";
    default:
      throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
  }
}, massageAstNode: uP};
var fO = {languages: [Xd({name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155}, () => ({since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"]}))], printers: {glimmer: pO}, parsers: void 0};
var dO = {hasPragma: function(e20) {
  return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e20);
}, insertPragma: function(e20) {
  return "# @format\n\n" + e20;
}};
var hO = {locStart: function(e20) {
  return typeof e20.start == "number" ? e20.start : e20.loc && e20.loc.start;
}, locEnd: function(e20) {
  return typeof e20.end == "number" ? e20.end : e20.loc && e20.loc.end;
}};
const {builders: {join: gO, hardline: mO, line: yO, softline: DO, group: EO, indent: CO, ifBreak: bO}} = eu$1, {isNextLineEmpty: AO, isNonEmptyArray: vO} = yi$2, {insertPragma: FO} = dO, {locStart: SO, locEnd: xO} = hO;
function wO(e20, t2, n2) {
  if (n2.directives.length === 0)
    return "";
  const r2 = gO(yO, e20.map(t2, "directives"));
  return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? EO([yO, r2]) : [" ", EO(CO([DO, r2]))];
}
function TO(e20, t2, n2) {
  const r2 = e20.getValue().length;
  return e20.map((e21, i2) => {
    const u2 = n2();
    return AO(t2.originalText, e21.getValue(), xO) && i2 < r2 - 1 ? [u2, mO] : u2;
  });
}
function BO(e20, t2, n2) {
  const r2 = e20.getNode(), i2 = [], {interfaces: u2} = r2, o2 = e20.map((e21) => n2(e21), "interfaces");
  for (let e21 = 0; e21 < u2.length; e21++) {
    const n3 = u2[e21];
    i2.push(o2[e21]);
    const r3 = u2[e21 + 1];
    if (r3) {
      const e22 = t2.originalText.slice(n3.loc.end, r3.loc.start), u3 = e22.includes("#"), o3 = e22.replace(/#.*/g, "").trim();
      i2.push(o3 === "," ? "," : " &", u3 ? yO : " ");
    }
  }
  return i2;
}
function NO() {
}
NO.ignoredProperties = new Set(["loc", "comments"]);
var kO = {print: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2)
    return "";
  if (typeof r2 == "string")
    return r2;
  switch (r2.kind) {
    case "Document": {
      const r3 = [];
      return e20.each((e21, i2, u2) => {
        r3.push(n2()), i2 !== u2.length - 1 && (r3.push(mO), AO(t2.originalText, e21.getValue(), xO) && r3.push(mO));
      }, "definitions"), [...r3, mO];
    }
    case "OperationDefinition": {
      const i2 = t2.originalText[SO(r2)] !== "{", u2 = Boolean(r2.name);
      return [i2 ? r2.operation : "", i2 && u2 ? [" ", n2("name")] : "", i2 && !u2 && vO(r2.variableDefinitions) ? " " : "", vO(r2.variableDefinitions) ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "variableDefinitions"))]), DO, ")"]) : "", wO(e20, n2, r2), r2.selectionSet && (i2 || u2) ? " " : "", n2("selectionSet")];
    }
    case "FragmentDefinition":
      return ["fragment ", n2("name"), vO(r2.variableDefinitions) ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "variableDefinitions"))]), DO, ")"]) : "", " on ", n2("typeCondition"), wO(e20, n2, r2), " ", n2("selectionSet")];
    case "SelectionSet":
      return ["{", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "selections"))]), mO, "}"];
    case "Field":
      return EO([r2.alias ? [n2("alias"), ": "] : "", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : "", wO(e20, n2, r2), r2.selectionSet ? " " : "", n2("selectionSet")]);
    case "Name":
      return r2.value;
    case "StringValue":
      return r2.block ? ['"""', mO, gO(mO, r2.value.replace(/"""/g, "\\$&").split("\n")), mO, '"""'] : ['"', r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
    case "IntValue":
    case "FloatValue":
    case "EnumValue":
      return r2.value;
    case "BooleanValue":
      return r2.value ? "true" : "false";
    case "NullValue":
      return "null";
    case "Variable":
      return ["$", n2("name")];
    case "ListValue":
      return EO(["[", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "values"))]), DO, "]"]);
    case "ObjectValue":
      return EO(["{", t2.bracketSpacing && r2.fields.length > 0 ? " " : "", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "fields"))]), DO, bO("", t2.bracketSpacing && r2.fields.length > 0 ? " " : ""), "}"]);
    case "ObjectField":
    case "Argument":
      return [n2("name"), ": ", n2("value")];
    case "Directive":
      return ["@", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : ""];
    case "NamedType":
      return n2("name");
    case "VariableDefinition":
      return [n2("variable"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wO(e20, n2, r2)];
    case "ObjectTypeExtension":
    case "ObjectTypeDefinition":
      return [n2("description"), r2.description ? mO : "", r2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BO(e20, t2, n2)] : "", wO(e20, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))]), mO, "}"] : ""];
    case "FieldDefinition":
      return [n2("description"), r2.description ? mO : "", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : "", ": ", n2("type"), wO(e20, n2, r2)];
    case "DirectiveDefinition":
      return [n2("description"), r2.description ? mO : "", "directive ", "@", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : "", r2.repeatable ? " repeatable" : "", " on ", gO(" | ", e20.map(n2, "locations"))];
    case "EnumTypeExtension":
    case "EnumTypeDefinition":
      return [n2("description"), r2.description ? mO : "", r2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n2("name"), wO(e20, n2, r2), r2.values.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "values"))]), mO, "}"] : ""];
    case "EnumValueDefinition":
      return [n2("description"), r2.description ? mO : "", n2("name"), wO(e20, n2, r2)];
    case "InputValueDefinition":
      return [n2("description"), r2.description ? r2.description.block ? mO : yO : "", n2("name"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wO(e20, n2, r2)];
    case "InputObjectTypeExtension":
    case "InputObjectTypeDefinition":
      return [n2("description"), r2.description ? mO : "", r2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", n2("name"), wO(e20, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))]), mO, "}"] : ""];
    case "SchemaDefinition":
      return ["schema", wO(e20, n2, r2), " {", r2.operationTypes.length > 0 ? CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "operationTypes"))]) : "", mO, "}"];
    case "OperationTypeDefinition":
      return [n2("operation"), ": ", n2("type")];
    case "InterfaceTypeExtension":
    case "InterfaceTypeDefinition":
      return [n2("description"), r2.description ? mO : "", r2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BO(e20, t2, n2)] : "", wO(e20, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))]), mO, "}"] : ""];
    case "FragmentSpread":
      return ["...", n2("name"), wO(e20, n2, r2)];
    case "InlineFragment":
      return ["...", r2.typeCondition ? [" on ", n2("typeCondition")] : "", wO(e20, n2, r2), " ", n2("selectionSet")];
    case "UnionTypeExtension":
    case "UnionTypeDefinition":
      return EO([n2("description"), r2.description ? mO : "", EO([r2.kind === "UnionTypeExtension" ? "extend " : "", "union ", n2("name"), wO(e20, n2, r2), r2.types.length > 0 ? [" =", bO("", " "), CO([bO([yO, "  "]), gO([yO, "| "], e20.map(n2, "types"))])] : ""])]);
    case "ScalarTypeExtension":
    case "ScalarTypeDefinition":
      return [n2("description"), r2.description ? mO : "", r2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n2("name"), wO(e20, n2, r2)];
    case "NonNullType":
      return [n2("type"), "!"];
    case "ListType":
      return ["[", n2("type"), "]"];
    default:
      throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
  }
}, massageAstNode: NO, hasPrettierIgnore: function(e20) {
  const t2 = e20.getValue();
  return t2 && Array.isArray(t2.comments) && t2.comments.some((e21) => e21.value.trim() === "prettier-ignore");
}, insertPragma: FO, printComment: function(e20) {
  const t2 = e20.getValue();
  if (t2.kind === "Comment")
    return "#" + t2.value.trimEnd();
  throw new Error("Not a comment: " + JSON.stringify(t2));
}, canAttachComment: function(e20) {
  return e20.kind && e20.kind !== "Comment";
}}, PO = {bracketSpacing: WB.bracketSpacing};
var OO = {languages: [Xd({name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139}, () => ({since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"]}))], options: PO, printers: {graphql: kO}, parsers: void 0};
var IO = {locStart: function(e20) {
  return e20.position.start.offset;
}, locEnd: function(e20) {
  return e20.position.end.offset;
}};
const {getLast: LO} = yi$2, {locStart: jO, locEnd: _O} = IO, {cjkPattern: MO, kPattern: RO, punctuationPattern: $O} = {cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"}, VO = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], WO = [...VO, "tableCell", "paragraph", "heading"], qO = new RegExp(RO), UO = new RegExp($O);
function zO(e20, t2) {
  const [, n2, r2, i2] = t2.slice(e20.position.start.offset, e20.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
  return {numberText: n2, marker: r2, leadingSpaces: i2};
}
var GO = {mapAst: function(e20, t2) {
  return function e21(n2, r2, i2) {
    const u2 = Object.assign({}, t2(n2, r2, i2));
    return u2.children && (u2.children = u2.children.map((t3, n3) => e21(t3, n3, [u2, ...i2]))), u2;
  }(e20, null, []);
}, splitText: function(e20, t2) {
  const n2 = "non-cjk", r2 = "cj-letter", i2 = "cjk-punctuation", u2 = [], o2 = (t2.proseWrap === "preserve" ? e20 : e20.replace(new RegExp(`(${MO})
(${MO})`, "g"), "$1$2")).split(/([\t\n ]+)/);
  for (const [e21, t3] of o2.entries()) {
    if (e21 % 2 == 1) {
      u2.push({type: "whitespace", value: /\n/.test(t3) ? "\n" : " "});
      continue;
    }
    if ((e21 === 0 || e21 === o2.length - 1) && t3 === "")
      continue;
    const a2 = t3.split(new RegExp(`(${MO})`));
    for (const [e22, t4] of a2.entries())
      (e22 !== 0 && e22 !== a2.length - 1 || t4 !== "") && (e22 % 2 != 0 ? s2(UO.test(t4) ? {type: "word", value: t4, kind: i2, hasLeadingPunctuation: true, hasTrailingPunctuation: true} : {type: "word", value: t4, kind: qO.test(t4) ? "k-letter" : r2, hasLeadingPunctuation: false, hasTrailingPunctuation: false}) : t4 !== "" && s2({type: "word", value: t4, kind: n2, hasLeadingPunctuation: UO.test(t4[0]), hasTrailingPunctuation: UO.test(LO(t4))}));
  }
  return u2;
  function s2(e21) {
    const t3 = LO(u2);
    var o3, s3;
    t3 && t3.type === "word" && (t3.kind === n2 && e21.kind === r2 && !t3.hasTrailingPunctuation || t3.kind === r2 && e21.kind === n2 && !e21.hasLeadingPunctuation ? u2.push({type: "whitespace", value: " "}) : (o3 = n2, s3 = i2, t3.kind === o3 && e21.kind === s3 || t3.kind === s3 && e21.kind === o3 || [t3.value, e21.value].some((e22) => /\u3000/.test(e22)) || u2.push({type: "whitespace", value: ""}))), u2.push(e21);
  }
}, punctuationPattern: $O, getFencedCodeBlockValue: function(e20, t2) {
  const {value: n2} = e20;
  return e20.position.end.offset === t2.length && n2.endsWith("\n") && t2.endsWith("\n") ? n2.slice(0, -1) : n2;
}, getOrderedListItemInfo: zO, hasGitDiffFriendlyOrderedList: function(e20, t2) {
  if (!e20.ordered)
    return false;
  if (e20.children.length < 2)
    return false;
  const n2 = Number(zO(e20.children[0], t2.originalText).numberText), r2 = Number(zO(e20.children[1], t2.originalText).numberText);
  if (n2 === 0 && e20.children.length > 2) {
    const n3 = Number(zO(e20.children[2], t2.originalText).numberText);
    return r2 === 1 && n3 === 1;
  }
  return r2 === 1;
}, INLINE_NODE_TYPES: VO, INLINE_NODE_WRAPPER_TYPES: WO, isAutolink: function(e20) {
  if (!e20 || e20.type !== "link" || e20.children.length !== 1)
    return false;
  const t2 = e20.children[0];
  return t2 && jO(e20) === jO(t2) && _O(e20) === _O(t2);
}};
const {inferParserByLanguage: HO, getMaxContinuousCount: JO} = yi$2, {builders: {hardline: XO, markAsRoot: YO}, utils: {replaceEndOfLine: KO}} = eu$1, {getFencedCodeBlockValue: QO} = GO;
var ZO = function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  if (i2.type === "code" && i2.lang !== null) {
    const e21 = HO(i2.lang, r2);
    if (e21) {
      const t3 = r2.__inJsTemplate ? "~" : "`", u2 = t3.repeat(Math.max(3, JO(i2.value, t3) + 1)), o2 = n2(QO(i2, r2.originalText), {parser: e21}, {stripTrailingHardline: true});
      return YO([u2, i2.lang, i2.meta ? " " + i2.meta : "", XO, KO(o2), XO, u2]);
    }
  }
  switch (i2.type) {
    case "front-matter":
      return rN(i2, n2);
    case "importExport":
      return [n2(i2.value, {parser: "babel"}, {stripTrailingHardline: true}), XO];
    case "jsx":
      return n2(`<$>${i2.value}</$>`, {parser: "__js_expression", rootMarker: "mdx"}, {stripTrailingHardline: true});
  }
  return null;
};
const eI = ["format", "prettier"];
function tI(e20) {
  const t2 = `@(${eI.join("|")})`, n2 = new RegExp([`<!--\\s*${t2}\\s*-->`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${t2}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), r2 = e20.match(n2);
  return r2 && r2.index === 0;
}
var nI = {startWithPragma: tI, hasPragma: (e20) => tI(sN(e20).content.trimStart()), insertPragma: (e20) => {
  const t2 = sN(e20), n2 = `<!-- @${eI[0]} -->`;
  return t2.frontMatter ? `${t2.frontMatter.raw}

${n2}

${t2.content}` : `${n2}

${t2.content}`;
}};
const {getOrderedListItemInfo: rI, mapAst: iI, splitText: uI} = GO, oI = /^.$/us;
function sI(e20, t2, n2) {
  return iI(e20, (e21) => {
    if (!e21.children)
      return e21;
    const r2 = e21.children.reduce((e22, r3) => {
      const i2 = Ln$2(e22);
      return i2 && t2(i2, r3) ? e22.splice(-1, 1, n2(i2, r3)) : e22.push(r3), e22;
    }, []);
    return Object.assign(Object.assign({}, e21), {}, {children: r2});
  });
}
var aI = function(e20, t2) {
  return e20 = function(e21) {
    return sI(e21, (e22, t3) => e22.type === "importExport" && t3.type === "importExport", (e22, t3) => ({type: "importExport", value: e22.value + "\n\n" + t3.value, position: {start: e22.position.start, end: t3.position.end}}));
  }(e20 = function(e21) {
    return iI(e21, (e22) => e22.type !== "import" && e22.type !== "export" ? e22 : Object.assign(Object.assign({}, e22), {}, {type: "importExport"}));
  }(e20 = function(e21, t3) {
    return iI(e21, (e22, n2, [r2]) => {
      if (e22.type !== "text")
        return e22;
      let {value: i2} = e22;
      return r2.type === "paragraph" && (n2 === 0 && (i2 = i2.trimStart()), n2 === r2.children.length - 1 && (i2 = i2.trimEnd())), {type: "sentence", position: e22.position, children: uI(i2, t3)};
    });
  }(e20 = function(e21, t3) {
    return iI(e21, (e22, t4, n3) => {
      if (e22.type === "list" && e22.children.length > 0) {
        for (let t5 = 0; t5 < n3.length; t5++) {
          const r3 = n3[t5];
          if (r3.type === "list" && !r3.isAligned)
            return e22.isAligned = false, e22;
        }
        e22.isAligned = r2(e22);
      }
      return e22;
    });
    function n2(e22) {
      return e22.children.length === 0 ? -1 : e22.children[0].position.start.column - 1;
    }
    function r2(e22) {
      if (!e22.ordered)
        return true;
      const [r3, i2] = e22.children;
      if (rI(r3, t3.originalText).leadingSpaces.length > 1)
        return true;
      const u2 = n2(r3);
      if (u2 === -1)
        return false;
      if (e22.children.length === 1)
        return u2 % t3.tabWidth == 0;
      if (u2 !== n2(i2))
        return false;
      if (u2 % t3.tabWidth == 0)
        return true;
      return rI(i2, t3.originalText).leadingSpaces.length > 1;
    }
  }(e20 = function(e21, t3) {
    return iI(e21, (e22, n2, r2) => {
      if (e22.type === "code") {
        const n3 = /^\n?(?: {4,}|\t)/.test(t3.originalText.slice(e22.position.start.offset, e22.position.end.offset));
        if (e22.isIndented = n3, n3)
          for (let e23 = 0; e23 < r2.length; e23++) {
            const t4 = r2[e23];
            if (t4.hasIndentedCodeblock)
              break;
            t4.type === "list" && (t4.hasIndentedCodeblock = true);
          }
      }
      return e22;
    });
  }(e20 = function(e21) {
    return iI(e21, (e22) => e22.type !== "inlineCode" ? e22 : Object.assign(Object.assign({}, e22), {}, {value: e22.value.replace(/\s+/g, " ")}));
  }(e20 = function(e21) {
    return sI(e21, (e22, t3) => e22.type === "text" && t3.type === "text", (e22, t3) => ({type: "text", value: e22.value + t3.value, position: {start: e22.position.start, end: t3.position.end}}));
  }(e20 = function(e21, t3) {
    return iI(e21, (e22) => e22.type === "text" && e22.value !== "*" && e22.value !== "_" && oI.test(e22.value) && e22.position.end.offset - e22.position.start.offset !== e22.value.length ? Object.assign(Object.assign({}, e22), {}, {value: t3.originalText.slice(e22.position.start.offset, e22.position.end.offset)}) : e22);
  }(e20, t2))), t2), t2), t2)));
};
const {isFrontMatterNode: cI} = yi$2, {startWithPragma: lI} = nI, pI = new Set(["position", "raw"]);
function fI(e20, t2, n2) {
  return e20.type !== "front-matter" && e20.type !== "code" && e20.type !== "yaml" && e20.type !== "import" && e20.type !== "export" && e20.type !== "jsx" || delete t2.value, e20.type === "list" && delete t2.isAligned, e20.type !== "list" && e20.type !== "listItem" || (delete t2.spread, delete t2.loose), e20.type === "text" ? null : (e20.type === "inlineCode" && (t2.value = e20.value.replace(/[\t\n ]+/g, " ")), e20.type === "wikiLink" && (t2.value = e20.value.trim().replace(/[\t\n]+/g, " ")), e20.type !== "definition" && e20.type !== "linkReference" || (t2.label = e20.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e20.type !== "definition" && e20.type !== "link" && e20.type !== "image" || !e20.title || (t2.title = e20.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e20 || cI(n2.children[0]) && n2.children[1] === e20) && e20.type === "html" && lI(e20.value) ? null : void 0);
}
fI.ignoredProperties = pI;
var dI = fI;
const {getLast: hI, getMinNotPresentContinuousCount: gI, getMaxContinuousCount: mI, getStringWidth: yI, isNonEmptyArray: DI} = yi$2, {builders: {breakParent: EI, join: CI, line: bI, literalline: AI, markAsRoot: vI, hardline: FI, softline: SI, ifBreak: xI, fill: wI, align: TI, indent: BI, group: NI, hardlineWithoutBreakParent: kI}, utils: {normalizeDoc: PI, replaceTextEndOfLine: OI}, printer: {printDocToString: II}} = eu$1, {insertPragma: LI} = nI, {locStart: jI, locEnd: _I} = IO, {getFencedCodeBlockValue: MI, hasGitDiffFriendlyOrderedList: RI, splitText: $I, punctuationPattern: VI, INLINE_NODE_TYPES: WI, INLINE_NODE_WRAPPER_TYPES: qI, isAutolink: UI} = GO, zI = new Set(["importExport"]), GI = ["heading", "tableCell", "link", "wikiLink"], HI = new Set(["listItem", "definition", "footnoteDefinition"]);
function JI(e20, t2, n2, r2) {
  const i2 = e20.getValue(), u2 = i2.checked === null ? "" : i2.checked ? "[x] " : "[ ] ";
  return [u2, eL(e20, t2, n2, {processor: (e21, i3) => {
    if (i3 === 0 && e21.getValue().type !== "list")
      return TI(" ".repeat(u2.length), n2());
    const o2 = " ".repeat(function(e22, t3, n3) {
      return e22 < t3 ? t3 : e22 > n3 ? n3 : e22;
    }(t2.tabWidth - r2.length, 0, 3));
    return [o2, TI(o2, n2())];
  }})];
}
function XI(e20, t2) {
  return function(e21, t3, n2) {
    let r2 = -1;
    for (const i2 of t3.children)
      if (i2.type === e21.type && n2(i2) ? r2++ : r2 = -1, i2 === e21)
        return r2;
  }(e20, t2, (t3) => t3.ordered === e20.ordered);
}
function YI(e20, t2) {
  const n2 = Array.isArray(t2) ? t2 : [t2];
  let r2, i2 = -1;
  for (; r2 = e20.getParentNode(++i2); )
    if (n2.includes(r2.type))
      return i2;
  return -1;
}
function KI(e20, t2) {
  const n2 = YI(e20, t2);
  return n2 === -1 ? null : e20.getParentNode(n2);
}
function QI(e20, t2, n2) {
  if (n2.proseWrap === "preserve" && t2 === "\n")
    return FI;
  const r2 = n2.proseWrap === "always" && !KI(e20, GI);
  return t2 !== "" ? r2 ? bI : " " : r2 ? SI : "";
}
function ZI(e20, t2, n2) {
  const r2 = [];
  let i2 = null;
  const {children: u2} = e20.getValue();
  for (const [e21, t3] of u2.entries())
    switch (nL(t3)) {
      case "start":
        i2 === null && (i2 = {index: e21, offset: t3.position.end.offset});
        break;
      case "end":
        i2 !== null && (r2.push({start: i2, end: {index: e21, offset: t3.position.start.offset}}), i2 = null);
    }
  return eL(e20, t2, n2, {processor: (e21, i3) => {
    if (r2.length > 0) {
      const e22 = r2[0];
      if (i3 === e22.start.index)
        return [u2[e22.start.index].value, t2.originalText.slice(e22.start.offset, e22.end.offset), u2[e22.end.index].value];
      if (e22.start.index < i3 && i3 < e22.end.index)
        return false;
      if (i3 === e22.end.index)
        return r2.shift(), false;
    }
    return n2();
  }});
}
function eL(e20, t2, n2, r2 = {}) {
  const {postprocessor: i2} = r2, u2 = r2.processor || (() => n2()), o2 = e20.getValue(), s2 = [];
  let a2;
  return e20.each((e21, n3) => {
    const r3 = e21.getValue(), i3 = u2(e21, n3);
    if (i3 !== false) {
      const e22 = {parts: s2, prevNode: a2, parentNode: o2, options: t2};
      (function(e23, t3) {
        const n4 = t3.parts.length === 0, r4 = WI.includes(e23.type), i4 = e23.type === "html" && qI.includes(t3.parentNode.type);
        return !n4 && !r4 && !i4;
      })(r3, e22) && (s2.push(FI), a2 && zI.has(a2.type) || (function(e23, t3) {
        const n4 = (t3.prevNode && t3.prevNode.type) === e23.type && HI.has(e23.type), r4 = t3.parentNode.type === "listItem" && !t3.parentNode.loose, i4 = t3.prevNode && t3.prevNode.type === "listItem" && t3.prevNode.loose, u3 = nL(t3.prevNode) === "next", o3 = e23.type === "html" && t3.prevNode && t3.prevNode.type === "html" && t3.prevNode.position.end.line + 1 === e23.position.start.line, s3 = e23.type === "html" && t3.parentNode.type === "listItem" && t3.prevNode && t3.prevNode.type === "paragraph" && t3.prevNode.position.end.line + 1 === e23.position.start.line;
        return i4 || !(n4 || r4 || u3 || o3 || s3);
      }(r3, e22) || rL(r3, e22)) && s2.push(FI), rL(r3, e22) && s2.push(FI)), s2.push(i3), a2 = r3;
    }
  }, "children"), i2 ? i2(s2) : s2;
}
function tL(e20) {
  let t2 = e20;
  for (; DI(t2.children); )
    t2 = hI(t2.children);
  return t2;
}
function nL(e20) {
  if (e20.type !== "html")
    return false;
  const t2 = e20.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
  return t2 !== null && (t2[1] ? t2[1] : "next");
}
function rL(e20, t2) {
  const n2 = t2.prevNode && t2.prevNode.type === "list", r2 = e20.type === "code" && e20.isIndented;
  return n2 && r2;
}
function iL(e20, t2 = []) {
  const n2 = [" ", ...Array.isArray(t2) ? t2 : [t2]];
  return new RegExp(n2.map((e21) => `\\${e21}`).join("|")).test(e20) ? `<${e20}>` : e20;
}
function uL(e20, t2, n2 = true) {
  if (!e20)
    return "";
  if (n2)
    return " " + uL(e20, t2, false);
  if ((e20 = e20.replace(/\\(["')])/g, "$1")).includes('"') && e20.includes("'") && !e20.includes(")"))
    return `(${e20})`;
  const r2 = e20.split("'").length - 1, i2 = e20.split('"').length - 1, u2 = r2 > i2 ? '"' : i2 > r2 || t2.singleQuote ? "'" : '"';
  return `${u2}${e20 = (e20 = e20.replace(/\\/, "\\\\")).replace(new RegExp(`(${u2})`, "g"), "\\$1")}${u2}`;
}
var oL = {preprocess: aI, print: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (function(e21) {
    const t3 = KI(e21, ["linkReference", "imageReference"]);
    return t3 && (t3.type !== "linkReference" || t3.referenceType !== "full");
  }(e20))
    return $I(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset), t2).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : QI(e20, n3.value, t2));
  switch (r2.type) {
    case "front-matter":
      return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
    case "root":
      return r2.children.length === 0 ? "" : [PI(ZI(e20, t2, n2)), zI.has(tL(r2).type) ? "" : FI];
    case "paragraph":
      return eL(e20, t2, n2, {postprocessor: wI});
    case "sentence":
      return eL(e20, t2, n2);
    case "word": {
      let t3 = r2.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${VI})(_+)`, `(_+)(${VI}|$)`].join("|"), "g"), (e21, t4, n4, r3, i3) => (n4 ? `${t4}${n4}` : `${r3}${i3}`).replace(/_/g, "\\_"));
      const n3 = (e21, t4, n4) => e21.type === "sentence" && n4 === 0, i2 = (e21, t4, n4) => UI(e21.children[n4 - 1]);
      return t3 !== r2.value && (e20.match(void 0, n3, i2) || e20.match(void 0, n3, (e21, t4, n4) => e21.type === "emphasis" && n4 === 0, i2)) && (t3 = t3.replace(/^(\\?[*_])+/, (e21) => e21.replace(/\\/g, ""))), t3;
    }
    case "whitespace": {
      const n3 = e20.getParentNode(), i2 = n3.children.indexOf(r2), u2 = n3.children[i2 + 1], o2 = u2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(u2.value) ? "never" : t2.proseWrap;
      return QI(e20, r2.value, {proseWrap: o2});
    }
    case "emphasis": {
      let i2;
      if (UI(r2.children[0]))
        i2 = t2.originalText[r2.position.start.offset];
      else {
        const t3 = e20.getParentNode(), n3 = t3.children.indexOf(r2), u2 = t3.children[n3 - 1], o2 = t3.children[n3 + 1];
        i2 = u2 && u2.type === "sentence" && u2.children.length > 0 && hI(u2.children).type === "word" && !hI(u2.children).hasTrailingPunctuation || o2 && o2.type === "sentence" && o2.children.length > 0 && o2.children[0].type === "word" && !o2.children[0].hasLeadingPunctuation || KI(e20, "emphasis") ? "*" : "_";
      }
      return [i2, eL(e20, t2, n2), i2];
    }
    case "strong":
      return ["**", eL(e20, t2, n2), "**"];
    case "delete":
      return ["~~", eL(e20, t2, n2), "~~"];
    case "inlineCode": {
      const e21 = gI(r2.value, "`"), t3 = "`".repeat(e21 || 1), n3 = e21 && !/^\s/.test(r2.value) ? " " : "";
      return [t3, n3, r2.value, n3, t3];
    }
    case "wikiLink": {
      let e21 = "";
      return e21 = t2.proseWrap === "preserve" ? r2.value : r2.value.replace(/[\t\n]+/g, " "), ["[[", e21, "]]"];
    }
    case "link":
      switch (t2.originalText[r2.position.start.offset]) {
        case "<": {
          const e21 = "mailto:";
          return ["<", r2.url.startsWith(e21) && t2.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e21.length) !== e21 ? r2.url.slice(e21.length) : r2.url, ">"];
        }
        case "[":
          return ["[", eL(e20, t2, n2), "](", iL(r2.url, ")"), uL(r2.title, t2), ")"];
        default:
          return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
      }
    case "image":
      return ["![", r2.alt || "", "](", iL(r2.url, ")"), uL(r2.title, t2), ")"];
    case "blockquote":
      return ["> ", TI("> ", eL(e20, t2, n2))];
    case "heading":
      return ["#".repeat(r2.depth) + " ", eL(e20, t2, n2)];
    case "code": {
      if (r2.isIndented) {
        const e22 = " ".repeat(4);
        return TI(e22, [e22, ...OI(r2.value, FI)]);
      }
      const e21 = t2.__inJsTemplate ? "~" : "`", n3 = e21.repeat(Math.max(3, mI(r2.value, e21) + 1));
      return [n3, r2.lang || "", r2.meta ? " " + r2.meta : "", FI, ...OI(MI(r2, t2.originalText), FI), FI, n3];
    }
    case "html": {
      const t3 = e20.getParentNode(), n3 = t3.type === "root" && hI(t3.children) === r2 ? r2.value.trimEnd() : r2.value, i2 = /^<!--.*-->$/s.test(n3);
      return OI(n3, i2 ? FI : vI(AI));
    }
    case "list": {
      const i2 = XI(r2, e20.getParentNode()), u2 = RI(r2, t2);
      return eL(e20, t2, n2, {processor: (e21, o2) => {
        const s2 = function() {
          const e22 = r2.ordered ? (o2 === 0 ? r2.start : u2 ? 1 : r2.start + o2) + (i2 % 2 == 0 ? ". " : ") ") : i2 % 2 == 0 ? "- " : "* ";
          return r2.isAligned || r2.hasIndentedCodeblock ? function(e23, t3) {
            const n3 = r3();
            return e23 + " ".repeat(n3 >= 4 ? 0 : n3);
            function r3() {
              const n4 = e23.length % t3.tabWidth;
              return n4 === 0 ? 0 : t3.tabWidth - n4;
            }
          }(e22, t2) : e22;
        }(), a2 = e21.getValue();
        return a2.children.length === 2 && a2.children[1].type === "html" && a2.children[0].position.start.column !== a2.children[1].position.start.column ? [s2, JI(e21, t2, n2, s2)] : [s2, TI(" ".repeat(s2.length), JI(e21, t2, n2, s2))];
      }});
    }
    case "thematicBreak": {
      const t3 = YI(e20, "list");
      if (t3 === -1)
        return "---";
      return XI(e20.getParentNode(t3), e20.getParentNode(t3 + 1)) % 2 == 0 ? "***" : "---";
    }
    case "linkReference":
      return ["[", eL(e20, t2, n2), "]", r2.referenceType === "full" ? ["[", r2.identifier, "]"] : r2.referenceType === "collapsed" ? "[]" : ""];
    case "imageReference":
      switch (r2.referenceType) {
        case "full":
          return ["![", r2.alt || "", "][", r2.identifier, "]"];
        default:
          return ["![", r2.alt, "]", r2.referenceType === "collapsed" ? "[]" : ""];
      }
    case "definition": {
      const e21 = t2.proseWrap === "always" ? bI : " ";
      return NI(["[", r2.identifier, "]:", BI([e21, iL(r2.url), r2.title === null ? "" : [e21, uL(r2.title, t2, false)]])]);
    }
    case "footnote":
      return ["[^", eL(e20, t2, n2), "]"];
    case "footnoteReference":
      return ["[^", r2.identifier, "]"];
    case "footnoteDefinition": {
      const i2 = e20.getParentNode().children[e20.getName() + 1], u2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t2.proseWrap === "never" || t2.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
      return ["[^", r2.identifier, "]: ", u2 ? eL(e20, t2, n2) : NI([TI(" ".repeat(4), eL(e20, t2, n2, {processor: (e21, t3) => t3 === 0 ? NI([SI, n2()]) : n2()})), i2 && i2.type === "footnoteDefinition" ? SI : ""])];
    }
    case "table":
      return function(e21, t3, n3) {
        const r3 = e21.getValue(), i2 = [], u2 = e21.map((e22) => e22.map((e23, r4) => {
          const u3 = II(n3(), t3).formatted, o3 = yI(u3);
          return i2[r4] = Math.max(i2[r4] || 3, o3), {text: u3, width: o3};
        }, "children"), "children"), o2 = a2(false);
        if (t3.proseWrap !== "never")
          return [EI, o2];
        const s2 = a2(true);
        return [EI, NI(xI(s2, o2))];
        function a2(e22) {
          const t4 = [l2(u2[0], e22), c2(e22)];
          return u2.length > 1 && t4.push(CI(kI, u2.slice(1).map((t5) => l2(t5, e22)))), CI(kI, t4);
        }
        function c2(e22) {
          return `| ${i2.map((t4, n4) => {
            const i3 = r3.align[n4], u3 = i3 === "center" || i3 === "right" ? ":" : "-";
            return `${i3 === "center" || i3 === "left" ? ":" : "-"}${e22 ? "-" : "-".repeat(t4 - 2)}${u3}`;
          }).join(" | ")} |`;
        }
        function l2(e22, t4) {
          return `| ${e22.map(({text: e23, width: n4}, u3) => {
            if (t4)
              return e23;
            const o3 = i2[u3] - n4, s3 = r3.align[u3];
            let a3 = 0;
            s3 === "right" ? a3 = o3 : s3 === "center" && (a3 = Math.floor(o3 / 2));
            const c3 = o3 - a3;
            return `${" ".repeat(a3)}${e23}${" ".repeat(c3)}`;
          }).join(" | ")} |`;
        }
      }(e20, t2, n2);
    case "tableCell":
      return eL(e20, t2, n2);
    case "break":
      return /\s/.test(t2.originalText[r2.position.start.offset]) ? ["  ", vI(AI)] : ["\\", FI];
    case "liquidNode":
      return OI(r2.value, FI);
    case "importExport":
      return [r2.value, FI];
    case "jsx":
      return r2.value;
    case "math":
      return ["$$", FI, r2.value ? [...OI(r2.value, FI), FI] : "", "$$"];
    case "inlineMath":
      return t2.originalText.slice(jI(r2), _I(r2));
    case "tableRow":
    case "listItem":
    default:
      throw new Error(`Unknown markdown type ${JSON.stringify(r2.type)}`);
  }
}, embed: ZO, massageAstNode: dI, hasPrettierIgnore: function(e20) {
  const t2 = Number(e20.getName());
  return t2 !== 0 && nL(e20.getParentNode().children[t2 - 1]) === "next";
}, insertPragma: LI}, sL = {proseWrap: WB.proseWrap, singleQuote: WB.singleQuote}, aL = {name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222};
var cL = {languages: [Xd(aL, (e20) => ({since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e20.filenames, "README"], extensions: e20.extensions.filter((e21) => e21 !== ".mdx")})), Xd(aL, () => ({name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"]}))], options: sL, printers: {mdast: oL}, parsers: void 0};
const {isFrontMatterNode: lL} = yi$2, pL = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
function fL(e20, t2) {
  return e20.type === "text" || e20.type === "comment" || lL(e20) || e20.type === "yaml" || e20.type === "toml" ? null : (e20.type === "attribute" && delete t2.value, void (e20.type === "docType" && delete t2.value));
}
fL.ignoredProperties = pL;
var dL = fL, hL = {"*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"]};
const {inferParserByLanguage: gL, isFrontMatterNode: mL} = yi$2, {builders: {line: yL, hardline: DL, join: EL}, utils: {getDocParts: CL, replaceTextEndOfLine: bL}} = eu$1, {CSS_DISPLAY_TAGS: AL, CSS_DISPLAY_DEFAULT: vL, CSS_WHITE_SPACE_TAGS: FL, CSS_WHITE_SPACE_DEFAULT: SL} = {CSS_DISPLAY_TAGS: {area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block"}, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: {listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap"}, CSS_WHITE_SPACE_DEFAULT: "normal"}, xL = PL(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), wL = function(e20, t2) {
  const n2 = Object.create(null);
  for (const [r2, i2] of Object.entries(e20))
    n2[r2] = t2(i2, r2);
  return n2;
}(hL, PL), TL = new Set(["	", "\n", "\f", "\r", " "]), BL = (e20) => e20.replace(/[\t\n\f\r ]+$/, ""), NL = (e20) => ((e21) => e21.replace(/^[\t\f\r ]*?\n/g, ""))(BL(e20)), kL = (e20) => e20.match(/^[\t\n\f\r ]*/)[0];
function PL(e20) {
  const t2 = Object.create(null);
  for (const n2 of e20)
    t2[n2] = true;
  return t2;
}
function OL(e20) {
  return e20.type === "element" && (e20.fullName === "script" || e20.fullName === "style" || e20.fullName === "svg:style" || UL(e20) && (e20.name === "script" || e20.name === "style"));
}
function IL(e20) {
  return zL(e20).startsWith("pre");
}
function LL(e20) {
  return e20.type === "element" && e20.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e20.name) || e20.cssDisplay.startsWith("table") && e20.cssDisplay !== "table-cell");
}
function jL(e20) {
  return $L(e20) || e20.type === "element" && e20.fullName === "br" || _L(e20);
}
function _L(e20) {
  return ML(e20) && RL(e20);
}
function ML(e20) {
  return e20.hasLeadingSpaces && (e20.prev ? e20.prev.sourceSpan.end.line < e20.sourceSpan.start.line : e20.parent.type === "root" || e20.parent.startSourceSpan.end.line < e20.sourceSpan.start.line);
}
function RL(e20) {
  return e20.hasTrailingSpaces && (e20.next ? e20.next.sourceSpan.start.line > e20.sourceSpan.end.line : e20.parent.type === "root" || e20.parent.endSourceSpan && e20.parent.endSourceSpan.start.line > e20.sourceSpan.end.line);
}
function $L(e20) {
  switch (e20.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(e20.name);
  }
  return false;
}
function VL(e20) {
  const {type: t2, lang: n2} = e20.attrMap;
  return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || n2 === "jsx" ? "babel" : t2 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
}
function WL(e20) {
  return e20 === "block" || e20 === "list-item" || e20.startsWith("table");
}
function qL(e20) {
  return zL(e20).startsWith("pre");
}
function UL(e20) {
  return e20.type === "element" && !e20.hasExplicitNamespace && !["html", "svg"].includes(e20.namespace);
}
function zL(e20) {
  return e20.type === "element" && (!e20.namespace || UL(e20)) && FL[e20.name] || SL;
}
function GL(e20, t2 = function(e21) {
  let t3 = Number.POSITIVE_INFINITY;
  for (const n2 of e21.split("\n")) {
    if (n2.length === 0)
      continue;
    if (!TL.has(n2[0]))
      return 0;
    const e22 = kL(n2).length;
    n2.length !== e22 && e22 < t3 && (t3 = e22);
  }
  return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
}(e20)) {
  return t2 === 0 ? e20 : e20.split("\n").map((e21) => e21.slice(t2)).join("\n");
}
const HL = new Set(["template", "style", "script"]);
function JL(e20, t2) {
  return XL(e20, t2) && !HL.has(e20.fullName);
}
function XL(e20, t2) {
  return t2.parser === "vue" && e20.type === "element" && e20.parent.type === "root" && e20.fullName.toLowerCase() !== "html";
}
function YL(e20, t2) {
  return XL(e20, t2) && (JL(e20, t2) || e20.attrMap.lang && e20.attrMap.lang !== "html");
}
var KL = {HTML_ELEMENT_ATTRIBUTES: wL, HTML_TAGS: xL, htmlTrim: (e20) => ((e21) => e21.replace(/^[\t\n\f\r ]+/, ""))(BL(e20)), htmlTrimPreserveIndentation: NL, hasHtmlWhitespace: (e20) => /[\t\n\f\r ]/.test(e20), getLeadingAndTrailingHtmlWhitespace: (e20) => {
  const [, t2, n2, r2] = e20.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
  return {leadingWhitespace: t2, trailingWhitespace: r2, text: n2};
}, canHaveInterpolation: function(e20) {
  return e20.children && !OL(e20);
}, countChars: function(e20, t2) {
  let n2 = 0;
  for (let r2 = 0; r2 < e20.length; r2++)
    e20[r2] === t2 && n2++;
  return n2;
}, countParents: function(e20, t2) {
  let n2 = 0;
  for (let r2 = e20.stack.length - 1; r2 >= 0; r2--) {
    const i2 = e20.stack[r2];
    i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && n2++;
  }
  return n2;
}, dedentString: GL, forceBreakChildren: LL, forceBreakContent: function(e20) {
  return LL(e20) || e20.type === "element" && e20.children.length > 0 && (["body", "script", "style"].includes(e20.name) || e20.children.some((e21) => function(e22) {
    return e22.children && e22.children.some((e23) => e23.type !== "text");
  }(e21))) || e20.firstChild && e20.firstChild === e20.lastChild && e20.firstChild.type !== "text" && ML(e20.firstChild) && (!e20.lastChild.isTrailingSpaceSensitive || RL(e20.lastChild));
}, forceNextEmptyLine: function(e20) {
  return mL(e20) || e20.next && e20.sourceSpan.end && e20.sourceSpan.end.line + 1 < e20.next.sourceSpan.start.line;
}, getLastDescendant: function e9(t2) {
  return t2.lastChild ? e9(t2.lastChild) : t2;
}, getNodeCssStyleDisplay: function(e20, t2) {
  if (e20.prev && e20.prev.type === "comment") {
    const t3 = e20.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (t3)
      return t3[1];
  }
  let n2 = false;
  if (e20.type === "element" && e20.namespace === "svg") {
    if (!function(e21, t3) {
      let n3 = e21;
      for (; n3; ) {
        if (t3(n3))
          return true;
        n3 = n3.parent;
      }
      return false;
    }(e20, (e21) => e21.fullName === "svg:foreignObject"))
      return e20.name === "svg" ? "inline-block" : "block";
    n2 = true;
  }
  switch (t2.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t2.parser === "vue" && e20.parent && e20.parent.type === "root" ? "block" : e20.type === "element" && (!e20.namespace || n2 || UL(e20)) && AL[e20.name] || vL;
  }
}, getNodeCssStyleWhiteSpace: zL, hasPrettierIgnore: function(e20) {
  return e20.type !== "attribute" && (!!e20.parent && (typeof e20.index == "number" && e20.index !== 0 && function(e21) {
    return e21.type === "comment" && e21.value.trim() === "prettier-ignore";
  }(e20.parent.children[e20.index - 1])));
}, inferScriptParser: function(e20, t2) {
  return e20.name !== "script" || e20.attrMap.src ? e20.name === "style" ? function(e21) {
    const {lang: t3} = e21.attrMap;
    return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
  }(e20) : t2 && YL(e20, t2) ? VL(e20) || !("src" in e20.attrMap) && gL(e20.attrMap.lang, t2) : void 0 : e20.attrMap.lang || e20.attrMap.type ? VL(e20) : "babel";
}, isVueCustomBlock: JL, isVueNonHtmlBlock: YL, isVueSlotAttribute: function(e20) {
  const t2 = e20.fullName;
  return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
}, isVueSfcBindingsAttribute: function(e20, t2) {
  const n2 = e20.parent;
  if (!XL(n2, t2))
    return false;
  const r2 = n2.fullName, i2 = e20.fullName;
  return r2 === "script" && i2 === "setup" || r2 === "style" && i2 === "vars";
}, isDanglingSpaceSensitiveNode: function(e20) {
  return !(t2 = e20.cssDisplay, WL(t2) || t2 === "inline-block" || OL(e20));
  var t2;
}, isIndentationSensitiveNode: IL, isLeadingSpaceSensitiveNode: function(e20, t2) {
  const n2 = function() {
    if (mL(e20))
      return false;
    if ((e20.type === "text" || e20.type === "interpolation") && e20.prev && (e20.prev.type === "text" || e20.prev.type === "interpolation"))
      return true;
    if (!e20.parent || e20.parent.cssDisplay === "none")
      return false;
    if (qL(e20.parent))
      return true;
    if (!e20.prev && (e20.parent.type === "root" || qL(e20) && e20.parent || OL(e20.parent) || JL(e20.parent, t2) || (n3 = e20.parent.cssDisplay, WL(n3) || n3 === "inline-block")))
      return false;
    var n3;
    if (e20.prev && !function(e21) {
      return !WL(e21);
    }(e20.prev.cssDisplay))
      return false;
    return true;
  }();
  return n2 && !e20.prev && e20.parent && e20.parent.tagDefinition && e20.parent.tagDefinition.ignoreFirstLf ? e20.type === "interpolation" : n2;
}, isPreLikeNode: qL, isScriptLikeTag: OL, isTextLikeNode: function(e20) {
  return e20.type === "text" || e20.type === "comment";
}, isTrailingSpaceSensitiveNode: function(e20, t2) {
  return !mL(e20) && (!(e20.type !== "text" && e20.type !== "interpolation" || !e20.next || e20.next.type !== "text" && e20.next.type !== "interpolation") || !(!e20.parent || e20.parent.cssDisplay === "none") && (!!qL(e20.parent) || !(!e20.next && (e20.parent.type === "root" || qL(e20) && e20.parent || OL(e20.parent) || JL(e20.parent, t2) || (n2 = e20.parent.cssDisplay, WL(n2) || n2 === "inline-block"))) && !(e20.next && !function(e21) {
    return !WL(e21);
  }(e20.next.cssDisplay))));
  var n2;
}, isWhitespaceSensitiveNode: function(e20) {
  return OL(e20) || e20.type === "interpolation" || IL(e20);
}, isUnknownNamespace: UL, preferHardlineAsLeadingSpaces: function(e20) {
  return $L(e20) || e20.prev && jL(e20.prev) || _L(e20);
}, preferHardlineAsTrailingSpaces: jL, shouldPreserveContent: function(e20, t2) {
  return !(e20.type !== "ieConditionalComment" || !e20.lastChild || e20.lastChild.isSelfClosing || e20.lastChild.endSourceSpan) || (e20.type === "ieConditionalComment" && !e20.complete || (!(!qL(e20) || !e20.children.some((e21) => e21.type !== "text" && e21.type !== "interpolation")) || !(!YL(e20, t2) || OL(e20) || e20.type === "interpolation")));
}, unescapeQuoteEntities: function(e20) {
  return e20.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
}, getTextValueParts: function(e20, t2 = e20.value) {
  return e20.parent.isWhitespaceSensitive ? e20.parent.isIndentationSensitive ? bL(t2) : bL(GL(NL(t2)), DL) : CL(EL(yL, ((e21) => e21.split(/[\t\n\f\r ]+/))(t2)));
}}, QL = r$3(function(e20, t2) {
  function n2(e21) {
    return t2.$0 <= e21 && e21 <= t2.$9;
  }
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  Object.defineProperty(t2, "__esModule", {value: true}), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e21) {
    return e21 >= t2.$TAB && e21 <= t2.$SPACE || e21 == t2.$NBSP;
  }, t2.isDigit = n2, t2.isAsciiLetter = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$z || e21 >= t2.$A && e21 <= t2.$Z;
  }, t2.isAsciiHexDigit = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$f || e21 >= t2.$A && e21 <= t2.$F || n2(e21);
  }, t2.isNewLine = function(e21) {
    return e21 === t2.$LF || e21 === t2.$CR;
  }, t2.isOctalDigit = function(e21) {
    return t2.$0 <= e21 && e21 <= t2.$7;
  };
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ZL {
  constructor(e20, t2, n2) {
    this.filePath = e20, this.name = t2, this.members = n2;
  }
  assertNoMembers() {
    if (this.members.length)
      throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
  }
}
var ej = ZL;
var tj = class {
  constructor() {
    this.cache = new Map();
  }
  get(e20, t2, n2) {
    const r2 = `"${e20}".${t2}${(n2 = n2 || []).length ? `.${n2.join(".")}` : ""}`;
    let i2 = this.cache.get(r2);
    return i2 || (i2 = new ZL(e20, t2, n2), this.cache.set(r2, i2)), i2;
  }
}, nj = Object.defineProperty({StaticSymbol: ej, StaticSymbolCache: tj}, "__esModule", {value: true});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const rj = /-+([a-z0-9])/g;
var ij = function(e20) {
  return e20.replace(rj, (...e21) => e21[1].toUpperCase());
};
var uj = function(e20, t2) {
  return sj(e20, ":", t2);
};
var oj = function(e20, t2) {
  return sj(e20, ".", t2);
};
function sj(e20, t2, n2) {
  const r2 = e20.indexOf(t2);
  return r2 == -1 ? n2 : [e20.slice(0, r2).trim(), e20.slice(r2 + 1).trim()];
}
function aj(e20, t2, n2) {
  return Array.isArray(e20) ? t2.visitArray(e20, n2) : function(e21) {
    return typeof e21 == "object" && e21 !== null && Object.getPrototypeOf(e21) === bj;
  }(e20) ? t2.visitStringMap(e20, n2) : e20 == null || typeof e20 == "string" || typeof e20 == "number" || typeof e20 == "boolean" ? t2.visitPrimitive(e20, n2) : t2.visitOther(e20, n2);
}
var cj = aj;
var lj = function(e20) {
  return e20 != null;
};
var pj = function(e20) {
  return e20 === void 0 ? null : e20;
};
var fj = class {
  visitArray(e20, t2) {
    return e20.map((e21) => aj(e21, this, t2));
  }
  visitStringMap(e20, t2) {
    const n2 = {};
    return Object.keys(e20).forEach((r2) => {
      n2[r2] = aj(e20[r2], this, t2);
    }), n2;
  }
  visitPrimitive(e20, t2) {
    return e20;
  }
  visitOther(e20, t2) {
    return e20;
  }
}, dj = {assertSync: (e20) => {
  if (Sj(e20))
    throw new Error("Illegal state: value cannot be a promise");
  return e20;
}, then: (e20, t2) => Sj(e20) ? e20.then(t2) : t2(e20), all: (e20) => e20.some(Sj) ? Promise.all(e20) : e20};
var hj = function(e20) {
  throw new Error(`Internal Error: ${e20}`);
};
var gj = function(e20, t2) {
  const n2 = Error(e20);
  return n2[mj] = true, t2 && (n2[yj] = t2), n2;
};
const mj = "ngSyntaxError", yj = "ngParseErrors";
var Dj = function(e20) {
  return e20[mj];
};
var Ej = function(e20) {
  return e20[yj] || [];
};
var Cj = function(e20) {
  return e20.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
};
const bj = Object.getPrototypeOf({});
var Aj = function(e20) {
  let t2 = "";
  for (let n2 = 0; n2 < e20.length; n2++) {
    let r2 = e20.charCodeAt(n2);
    if (r2 >= 55296 && r2 <= 56319 && e20.length > n2 + 1) {
      const t3 = e20.charCodeAt(n2 + 1);
      t3 >= 56320 && t3 <= 57343 && (n2++, r2 = (r2 - 55296 << 10) + t3 - 56320 + 65536);
    }
    r2 <= 127 ? t2 += String.fromCharCode(r2) : r2 <= 2047 ? t2 += String.fromCharCode(r2 >> 6 & 31 | 192, 63 & r2 | 128) : r2 <= 65535 ? t2 += String.fromCharCode(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128) : r2 <= 2097151 && (t2 += String.fromCharCode(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128));
  }
  return t2;
};
var vj = function e10(t2) {
  if (typeof t2 == "string")
    return t2;
  if (t2 instanceof Array)
    return "[" + t2.map(e10).join(", ") + "]";
  if (t2 == null)
    return "" + t2;
  if (t2.overriddenName)
    return `${t2.overriddenName}`;
  if (t2.name)
    return `${t2.name}`;
  if (!t2.toString)
    return "object";
  const n2 = t2.toString();
  if (n2 == null)
    return "" + n2;
  const r2 = n2.indexOf("\n");
  return r2 === -1 ? n2 : n2.substring(0, r2);
};
var Fj = function(e20) {
  return typeof e20 == "function" && e20.hasOwnProperty("__forward_ref__") ? e20() : e20;
};
function Sj(e20) {
  return !!e20 && typeof e20.then == "function";
}
var xj = Sj;
var wj = class {
  constructor(e20) {
    this.full = e20;
    const t2 = e20.split(".");
    this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
  }
};
const Tj = typeof window != "undefined" && window, Bj = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
var Nj = t$3 !== void 0 && t$3 || Tj || Bj, kj = Object.defineProperty({dashCaseToCamelCase: ij, splitAtColon: uj, splitAtPeriod: oj, visitValue: cj, isDefined: lj, noUndefined: pj, ValueTransformer: fj, SyncAsync: dj, error: hj, syntaxError: gj, isSyntaxError: Dj, getParseErrors: Ej, escapeRegExp: Cj, utf8Encode: Aj, stringify: vj, resolveForwardRef: Fj, isPromise: xj, Version: wj, global: Nj}, "__esModule", {value: true}), Pj = r$3(function(e20, t2) {
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  Object.defineProperty(t2, "__esModule", {value: true});
  const n2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function r2(e21) {
    return e21.replace(/\W/g, "_");
  }
  t2.sanitizeIdentifier = r2;
  let i2 = 0;
  function u2(e21) {
    if (!e21 || !e21.reference)
      return null;
    const t3 = e21.reference;
    if (t3 instanceof nj.StaticSymbol)
      return t3.name;
    if (t3.__anonymousType)
      return t3.__anonymousType;
    let n3 = kj.stringify(t3);
    return n3.indexOf("(") >= 0 ? (n3 = "anonymous_" + i2++, t3.__anonymousType = n3) : n3 = r2(n3), n3;
  }
  var o2;
  t2.identifierName = u2, t2.identifierModuleUrl = function(e21) {
    const t3 = e21.reference;
    return t3 instanceof nj.StaticSymbol ? t3.filePath : `./${kj.stringify(t3)}`;
  }, t2.viewClassName = function(e21, t3) {
    return `View_${u2({reference: e21})}_${t3}`;
  }, t2.rendererTypeName = function(e21) {
    return `RenderType_${u2({reference: e21})}`;
  }, t2.hostViewClassName = function(e21) {
    return `HostView_${u2({reference: e21})}`;
  }, t2.componentFactoryName = function(e21) {
    return `${u2({reference: e21})}NgFactory`;
  }, function(e21) {
    e21[e21.Pipe = 0] = "Pipe", e21[e21.Directive = 1] = "Directive", e21[e21.NgModule = 2] = "NgModule", e21[e21.Injectable = 3] = "Injectable";
  }(o2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e21) {
    return e21.value != null ? r2(e21.value) : u2(e21.identifier);
  }, t2.tokenReference = function(e21) {
    return e21.identifier != null ? e21.identifier.reference : e21.value;
  };
  t2.CompileStylesheetMetadata = class {
    constructor({moduleUrl: e21, styles: t3, styleUrls: n3} = {}) {
      this.moduleUrl = e21 || null, this.styles = a2(t3), this.styleUrls = a2(n3);
    }
  };
  t2.CompileTemplateMetadata = class {
    constructor({encapsulation: e21, template: t3, templateUrl: n3, htmlAst: r3, styles: i3, styleUrls: u3, externalStylesheets: o3, animations: s3, ngContentSelectors: l3, interpolation: p2, isInline: f2, preserveWhitespaces: d2}) {
      if (this.encapsulation = e21, this.template = t3, this.templateUrl = n3, this.htmlAst = r3, this.styles = a2(i3), this.styleUrls = a2(u3), this.externalStylesheets = a2(o3), this.animations = s3 ? c2(s3) : [], this.ngContentSelectors = l3 || [], p2 && p2.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = p2, this.isInline = f2, this.preserveWhitespaces = d2;
    }
    toSummary() {
      return {ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations};
    }
  };
  class s2 {
    static create({isHost: e21, type: t3, isComponent: r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: a3, outputs: c3, host: l3, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2}) {
      const b2 = {}, A2 = {}, v2 = {};
      l3 != null && Object.keys(l3).forEach((e22) => {
        const t4 = l3[e22], r4 = e22.match(n2);
        r4 === null ? v2[e22] = t4 : r4[1] != null ? A2[r4[1]] = t4 : r4[2] != null && (b2[r4[2]] = t4);
      });
      const F2 = {};
      a3 != null && a3.forEach((e22) => {
        const t4 = kj.splitAtColon(e22, [e22, e22]);
        F2[t4[0]] = t4[1];
      });
      const S2 = {};
      return c3 != null && c3.forEach((e22) => {
        const t4 = kj.splitAtColon(e22, [e22, e22]);
        S2[t4[0]] = t4[1];
      }), new s2({isHost: e21, type: t3, isComponent: !!r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: F2, outputs: S2, hostListeners: b2, hostProperties: A2, hostAttributes: v2, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2});
    }
    constructor({isHost: e21, type: t3, isComponent: n3, selector: r3, exportAs: i3, changeDetection: u3, inputs: o3, outputs: s3, hostListeners: c3, hostProperties: l3, hostAttributes: p2, providers: f2, viewProviders: d2, queries: h2, guards: g2, viewQueries: m2, entryComponents: y2, template: D2, componentViewType: E2, rendererType: C2, componentFactory: b2}) {
      this.isHost = !!e21, this.type = t3, this.isComponent = n3, this.selector = r3, this.exportAs = i3, this.changeDetection = u3, this.inputs = o3, this.outputs = s3, this.hostListeners = c3, this.hostProperties = l3, this.hostAttributes = p2, this.providers = a2(f2), this.viewProviders = a2(d2), this.queries = a2(h2), this.guards = g2, this.viewQueries = a2(m2), this.entryComponents = a2(y2), this.template = D2, this.componentViewType = E2, this.rendererType = C2, this.componentFactory = b2;
    }
    toSummary() {
      return {summaryKind: o2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory};
    }
  }
  t2.CompileDirectiveMetadata = s2;
  t2.CompilePipeMetadata = class {
    constructor({type: e21, name: t3, pure: n3}) {
      this.type = e21, this.name = t3, this.pure = !!n3;
    }
    toSummary() {
      return {summaryKind: o2.Pipe, type: this.type, name: this.name, pure: this.pure};
    }
  };
  t2.CompileShallowModuleMetadata = class {
  };
  t2.CompileNgModuleMetadata = class {
    constructor({type: e21, providers: t3, declaredDirectives: n3, exportedDirectives: r3, declaredPipes: i3, exportedPipes: u3, entryComponents: o3, bootstrapComponents: s3, importedModules: c3, exportedModules: l3, schemas: p2, transitiveModule: f2, id: d2}) {
      this.type = e21 || null, this.declaredDirectives = a2(n3), this.exportedDirectives = a2(r3), this.declaredPipes = a2(i3), this.exportedPipes = a2(u3), this.providers = a2(t3), this.entryComponents = a2(o3), this.bootstrapComponents = a2(s3), this.importedModules = a2(c3), this.exportedModules = a2(l3), this.schemas = a2(p2), this.id = d2 || null, this.transitiveModule = f2 || null;
    }
    toSummary() {
      const e21 = this.transitiveModule;
      return {summaryKind: o2.NgModule, type: this.type, entryComponents: e21.entryComponents, providers: e21.providers, modules: e21.modules, exportedDirectives: e21.exportedDirectives, exportedPipes: e21.exportedPipes};
    }
  };
  function a2(e21) {
    return e21 || [];
  }
  t2.TransitiveCompileNgModuleMetadata = class {
    constructor() {
      this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(e21, t3) {
      this.providers.push({provider: e21, module: t3});
    }
    addDirective(e21) {
      this.directivesSet.has(e21.reference) || (this.directivesSet.add(e21.reference), this.directives.push(e21));
    }
    addExportedDirective(e21) {
      this.exportedDirectivesSet.has(e21.reference) || (this.exportedDirectivesSet.add(e21.reference), this.exportedDirectives.push(e21));
    }
    addPipe(e21) {
      this.pipesSet.has(e21.reference) || (this.pipesSet.add(e21.reference), this.pipes.push(e21));
    }
    addExportedPipe(e21) {
      this.exportedPipesSet.has(e21.reference) || (this.exportedPipesSet.add(e21.reference), this.exportedPipes.push(e21));
    }
    addModule(e21) {
      this.modulesSet.has(e21.reference) || (this.modulesSet.add(e21.reference), this.modules.push(e21));
    }
    addEntryComponent(e21) {
      this.entryComponentsSet.has(e21.componentType) || (this.entryComponentsSet.add(e21.componentType), this.entryComponents.push(e21));
    }
  };
  function c2(e21) {
    return e21.reduce((e22, t3) => {
      const n3 = Array.isArray(t3) ? c2(t3) : t3;
      return e22.concat(n3);
    }, []);
  }
  function l2(e21) {
    return e21.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  t2.ProviderMeta = class {
    constructor(e21, {useClass: t3, useValue: n3, useExisting: r3, useFactory: i3, deps: u3, multi: o3}) {
      this.token = e21, this.useClass = t3 || null, this.useValue = n3, this.useExisting = r3, this.useFactory = i3 || null, this.dependencies = u3 || null, this.multi = !!o3;
    }
  }, t2.flatten = c2, t2.templateSourceUrl = function(e21, t3, n3) {
    let r3;
    return r3 = n3.isInline ? t3.type.reference instanceof nj.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${u2(e21)}/${u2(t3.type)}.html` : n3.templateUrl, t3.type.reference instanceof nj.StaticSymbol ? r3 : l2(r3);
  }, t2.sharedStylesheetJitUrl = function(e21, t3) {
    const n3 = e21.moduleUrl.split(/\/\\/g);
    return l2(`css/${t3}${n3[n3.length - 1]}.ngstyle.js`);
  }, t2.ngModuleJitUrl = function(e21) {
    return l2(`${u2(e21.type)}/module.ngfactory.js`);
  }, t2.templateJitUrl = function(e21, t3) {
    return l2(`${u2(e21)}/${u2(t3.type)}.ngfactory.js`);
  };
}), Oj = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true});
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  class n2 {
    constructor(e21, t3, n3, r3) {
      this.file = e21, this.offset = t3, this.line = n3, this.col = r3;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(e21) {
      const t3 = this.file.content, r3 = t3.length;
      let i3 = this.offset, u3 = this.line, o2 = this.col;
      for (; i3 > 0 && e21 < 0; ) {
        i3--, e21++;
        if (t3.charCodeAt(i3) == QL.$LF) {
          u3--;
          const e22 = t3.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(QL.$LF));
          o2 = e22 > 0 ? i3 - e22 : i3;
        } else
          o2--;
      }
      for (; i3 < r3 && e21 > 0; ) {
        const n3 = t3.charCodeAt(i3);
        i3++, e21--, n3 == QL.$LF ? (u3++, o2 = 0) : o2++;
      }
      return new n2(this.file, i3, u3, o2);
    }
    getContext(e21, t3) {
      const n3 = this.file.content;
      let r3 = this.offset;
      if (r3 != null) {
        r3 > n3.length - 1 && (r3 = n3.length - 1);
        let i3 = r3, u3 = 0, o2 = 0;
        for (; u3 < e21 && r3 > 0 && (r3--, u3++, n3[r3] != "\n" || ++o2 != t3); )
          ;
        for (u3 = 0, o2 = 0; u3 < e21 && i3 < n3.length - 1 && (i3++, u3++, n3[i3] != "\n" || ++o2 != t3); )
          ;
        return {before: n3.substring(r3, this.offset), after: n3.substring(this.offset, i3 + 1)};
      }
      return null;
    }
  }
  t2.ParseLocation = n2;
  class r2 {
    constructor(e21, t3) {
      this.content = e21, this.url = t3;
    }
  }
  t2.ParseSourceFile = r2;
  class i2 {
    constructor(e21, t3, n3 = null) {
      this.start = e21, this.end = t3, this.details = n3;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  }
  var u2;
  t2.ParseSourceSpan = i2, t2.EMPTY_PARSE_LOCATION = new n2(new r2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new i2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e21) {
    e21[e21.WARNING = 0] = "WARNING", e21[e21.ERROR = 1] = "ERROR";
  }(u2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
  t2.ParseError = class {
    constructor(e21, t3, n3 = u2.ERROR) {
      this.span = e21, this.msg = t3, this.level = n3;
    }
    contextualMessage() {
      const e21 = this.span.start.getContext(100, 3);
      return e21 ? `${this.msg} ("${e21.before}[${u2[this.level]} ->]${e21.after}")` : this.msg;
    }
    toString() {
      const e21 = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${e21}`;
    }
  }, t2.typeSourceSpan = function(e21, t3) {
    const u3 = Pj.identifierModuleUrl(t3), o2 = u3 != null ? `in ${e21} ${Pj.identifierName(t3)} in ${u3}` : `in ${e21} ${Pj.identifierName(t3)}`, s2 = new r2("", o2);
    return new i2(new n2(s2, -1, -1, -1), new n2(s2, -1, -1, -1));
  }, t2.r3JitTypeSourceSpan = function(e21, t3, u3) {
    const o2 = new r2("", `in ${e21} ${t3} in ${u3}`);
    return new i2(new n2(o2, -1, -1, -1), new n2(o2, -1, -1, -1));
  };
});
const {ParseSourceSpan: Ij} = Oj, {htmlTrim: Lj, getLeadingAndTrailingHtmlWhitespace: jj, hasHtmlWhitespace: _j, canHaveInterpolation: Mj, getNodeCssStyleDisplay: Rj, isDanglingSpaceSensitiveNode: $j, isIndentationSensitiveNode: Vj, isLeadingSpaceSensitiveNode: Wj, isTrailingSpaceSensitiveNode: qj, isWhitespaceSensitiveNode: Uj} = KL, zj = [function(e20) {
  e20.walk((e21) => {
    if (e21.type === "element" && e21.tagDefinition.ignoreFirstLf && e21.children.length > 0 && e21.children[0].type === "text" && e21.children[0].value[0] === "\n") {
      const [t2, ...n2] = e21.children;
      e21.setChildren(t2.value.length === 1 ? n2 : [t2.clone({value: t2.value.slice(1)}), ...n2]);
    }
  });
}, function(e20) {
  const t2 = (e21) => e21.type === "element" && e21.prev && e21.prev.type === "ieConditionalStartComment" && e21.prev.sourceSpan.end.offset === e21.startSourceSpan.start.offset && e21.firstChild && e21.firstChild.type === "ieConditionalEndComment" && e21.firstChild.sourceSpan.start.offset === e21.startSourceSpan.end.offset;
  e20.walk((e21) => {
    if (e21.children) {
      const n2 = e21.children.map(t2);
      if (n2.some(Boolean)) {
        const t3 = [];
        for (let r2 = 0; r2 < e21.children.length; r2++) {
          const i2 = e21.children[r2];
          if (!n2[r2 + 1])
            if (n2[r2]) {
              const e22 = i2.prev, n3 = i2.firstChild, r3 = new Ij(e22.sourceSpan.start, n3.sourceSpan.end), u2 = new Ij(r3.start, i2.sourceSpan.end);
              t3.push(i2.clone({condition: e22.condition, sourceSpan: u2, startSourceSpan: r3, children: i2.children.slice(1)}));
            } else
              t3.push(i2);
        }
        e21.setChildren(t3);
      }
    }
  });
}, function(e20) {
  return function(e21, t2, n2) {
    e21.walk((e22) => {
      if (e22.children) {
        const r2 = e22.children.map(t2);
        if (r2.some(Boolean)) {
          const t3 = [];
          for (let i2 = 0; i2 < e22.children.length; i2++) {
            const u2 = e22.children[i2];
            if (u2.type !== "text" && !r2[i2]) {
              t3.push(u2);
              continue;
            }
            const o2 = u2.type === "text" ? u2 : u2.clone({type: "text", value: n2(u2)});
            if (t3.length === 0 || Ln$2(t3).type !== "text") {
              t3.push(o2);
              continue;
            }
            const s2 = t3.pop();
            t3.push(s2.clone({value: s2.value + o2.value, sourceSpan: new Ij(s2.sourceSpan.start, o2.sourceSpan.end)}));
          }
          e22.setChildren(t3);
        }
      }
    });
  }(e20, (e21) => e21.type === "cdata", (e21) => `<![CDATA[${e21.value}]]>`);
}, function(e20, t2) {
  if (t2.parser === "html")
    return;
  const n2 = /{{(.+?)}}/s;
  e20.walk((e21) => {
    if (!Mj(e21))
      return;
    const t3 = [];
    for (const r2 of e21.children) {
      if (r2.type !== "text") {
        t3.push(r2);
        continue;
      }
      let e22 = r2.sourceSpan.start, i2 = null;
      const u2 = r2.value.split(n2);
      for (let n3 = 0; n3 < u2.length; n3++, e22 = i2) {
        const r3 = u2[n3];
        n3 % 2 != 0 ? (i2 = e22.moveBy(r3.length + 4), t3.push({type: "interpolation", sourceSpan: new Ij(e22, i2), children: r3.length === 0 ? [] : [{type: "text", value: r3, sourceSpan: new Ij(e22.moveBy(2), i2.moveBy(-2))}]})) : (i2 = e22.moveBy(r3.length), r3.length > 0 && t3.push({type: "text", value: r3, sourceSpan: new Ij(e22, i2)}));
      }
    }
    e21.setChildren(t3);
  });
}, function(e20) {
  e20.walk((e21) => {
    if (!e21.children)
      return;
    if (e21.children.length === 0 || e21.children.length === 1 && e21.children[0].type === "text" && Lj(e21.children[0].value).length === 0)
      return e21.hasDanglingSpaces = e21.children.length > 0, void (e21.children = []);
    const t2 = Uj(e21), n2 = Vj(e21);
    e21.setChildren(e21.children.flatMap((e22) => {
      if (e22.type !== "text" || t2)
        return e22;
      const n3 = [], {leadingWhitespace: r2, text: i2, trailingWhitespace: u2} = jj(e22.value);
      return r2 && n3.push(Gj), i2 && n3.push({type: "text", value: i2, sourceSpan: new Ij(e22.sourceSpan.start.moveBy(r2.length), e22.sourceSpan.end.moveBy(-u2.length))}), u2 && n3.push(Gj), n3;
    }).map((e22, t3, n3) => {
      if (e22 !== Gj)
        return Object.assign(Object.assign({}, e22), {}, {hasLeadingSpaces: n3[t3 - 1] === Gj, hasTrailingSpaces: n3[t3 + 1] === Gj});
    }).filter(Boolean)), e21.isWhitespaceSensitive = t2, e21.isIndentationSensitive = n2;
  });
}, function(e20, t2) {
  e20.walk((e21) => Object.assign(e21, {cssDisplay: Rj(e21, t2)}));
}, function(e20) {
  e20.walk((e21) => Object.assign(e21, {isSelfClosing: !e21.children || e21.type === "element" && (e21.tagDefinition.isVoid || e21.startSourceSpan === e21.endSourceSpan)}));
}, function(e20, t2) {
  e20.walk((e21) => e21.type !== "element" ? e21 : Object.assign(e21, {hasHtmComponentClosingTag: e21.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t2.originalText.slice(e21.endSourceSpan.start.offset, e21.endSourceSpan.end.offset))}));
}, function(e20, t2) {
  e20.walk((e21) => {
    e21.children && (e21.children.length !== 0 ? e21.setChildren(e21.children.map((e22) => Object.assign(Object.assign({}, e22), {}, {isLeadingSpaceSensitive: Wj(e22, t2), isTrailingSpaceSensitive: qj(e22, t2)})).map((e22, t3, n2) => Object.assign(Object.assign({}, e22), {}, {isLeadingSpaceSensitive: (t3 === 0 || n2[t3 - 1].isTrailingSpaceSensitive) && e22.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t3 === n2.length - 1 || n2[t3 + 1].isLeadingSpaceSensitive) && e22.isTrailingSpaceSensitive}))) : e21.isDanglingSpaceSensitive = $j(e21));
  });
}, function(e20) {
  const t2 = (e21) => e21.type === "element" && e21.attrs.length === 0 && e21.children.length === 1 && e21.firstChild.type === "text" && !_j(e21.children[0].value) && !e21.firstChild.hasLeadingSpaces && !e21.firstChild.hasTrailingSpaces && e21.isLeadingSpaceSensitive && !e21.hasLeadingSpaces && e21.isTrailingSpaceSensitive && !e21.hasTrailingSpaces && e21.prev && e21.prev.type === "text" && e21.next && e21.next.type === "text";
  e20.walk((e21) => {
    if (e21.children) {
      const n2 = e21.children.map(t2);
      if (n2.some(Boolean)) {
        const t3 = [];
        for (let r2 = 0; r2 < e21.children.length; r2++) {
          const i2 = e21.children[r2];
          if (n2[r2]) {
            const n3 = t3.pop(), u2 = e21.children[++r2], {isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2} = u2;
            t3.push(n3.clone({value: n3.value + `<${i2.rawName}>` + i2.firstChild.value + `</${i2.rawName}>` + u2.value, sourceSpan: new Ij(n3.sourceSpan.start, u2.sourceSpan.end), isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2}));
          } else
            t3.push(i2);
        }
        e21.setChildren(t3);
      }
    }
  });
}];
const Gj = {type: "whitespace"};
var Hj = function(e20, t2) {
  const n2 = e20.map((e21) => e21);
  for (const e21 of zj)
    e21(n2, t2);
  return n2;
};
var Jj = {hasPragma: function(e20) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e20);
}, insertPragma: function(e20) {
  return "<!-- @format -->\n\n" + e20.replace(/^\s*\n/, "");
}};
var Xj = {locStart: function(e20) {
  return e20.sourceSpan.start.offset;
}, locEnd: function(e20) {
  return e20.sourceSpan.end.offset;
}};
const {isNonEmptyArray: Yj} = yi$2, {builders: {indent: Kj, join: Qj, line: Zj, softline: e_}, utils: {replaceTextEndOfLine: t_}} = eu$1, {locStart: n_, locEnd: r_} = Xj, {isTextLikeNode: i_, getLastDescendant: u_, isPreLikeNode: o_, hasPrettierIgnore: s_, shouldPreserveContent: a_} = KL;
function c_(e20, t2) {
  return e20.lastChild && D_(e20.lastChild) ? "" : [p_(e20, t2), d_(e20, t2)];
}
function l_(e20, t2) {
  return (e20.next ? m_(e20.next) : y_(e20.parent)) ? "" : [h_(e20, t2), f_(e20, t2)];
}
function p_(e20, t2) {
  return y_(e20) ? h_(e20.lastChild, t2) : "";
}
function f_(e20, t2) {
  return D_(e20) ? d_(e20.parent, t2) : E_(e20) ? S_(e20.next) : "";
}
function d_(e20, t2) {
  if (mf(!e20.isSelfClosing), g_(e20, t2))
    return "";
  switch (e20.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (e20.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${e20.rawName}`;
  }
}
function h_(e20, t2) {
  if (g_(e20, t2))
    return "";
  switch (e20.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "element":
      if (e20.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function g_(e20, t2) {
  return !e20.isSelfClosing && !e20.endSourceSpan && (s_(e20) || a_(e20.parent, t2));
}
function m_(e20) {
  return e20.prev && e20.prev.type !== "docType" && !i_(e20.prev) && e20.isLeadingSpaceSensitive && !e20.hasLeadingSpaces;
}
function y_(e20) {
  return e20.lastChild && e20.lastChild.isTrailingSpaceSensitive && !e20.lastChild.hasTrailingSpaces && !i_(u_(e20.lastChild)) && !o_(e20);
}
function D_(e20) {
  return !e20.next && !e20.hasTrailingSpaces && e20.isTrailingSpaceSensitive && i_(u_(e20));
}
function E_(e20) {
  return e20.next && !i_(e20.next) && i_(e20) && e20.isTrailingSpaceSensitive && !e20.hasTrailingSpaces;
}
function C_(e20) {
  return !e20.prev && e20.isLeadingSpaceSensitive && !e20.hasLeadingSpaces;
}
function b_(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!Yj(r2.attrs))
    return r2.isSelfClosing ? " " : "";
  const i2 = r2.prev && r2.prev.type === "comment" && function(e21) {
    const t3 = e21.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
    return !!t3 && (!t3[1] || t3[1].split(/\s+/));
  }(r2.prev.value), u2 = typeof i2 == "boolean" ? () => i2 : Array.isArray(i2) ? (e21) => i2.includes(e21.rawName) : () => false, o2 = e20.map((e21) => {
    const r3 = e21.getValue();
    return u2(r3) ? t_(t2.originalText.slice(n_(r3), r_(r3))) : n2();
  }, "attrs"), s2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, a2 = [Kj([s2 ? " " : Zj, Qj(Zj, o2)])];
  return r2.firstChild && C_(r2.firstChild) || r2.isSelfClosing && y_(r2.parent) || s2 ? a2.push(r2.isSelfClosing ? " " : "") : a2.push(t2.bracketSameLine ? r2.isSelfClosing ? " " : "" : r2.isSelfClosing ? Zj : e_), a2;
}
function A_(e20) {
  return e20.firstChild && C_(e20.firstChild) ? "" : x_(e20);
}
function v_(e20, t2) {
  return e20.prev && E_(e20.prev) ? "" : [F_(e20, t2), S_(e20)];
}
function F_(e20, t2) {
  return C_(e20) ? x_(e20.parent) : m_(e20) ? h_(e20.prev, t2) : "";
}
function S_(e20) {
  switch (e20.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${e20.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return "<!DOCTYPE";
    case "element":
      if (e20.condition)
        return `<!--[if ${e20.condition}]><!--><${e20.rawName}`;
    default:
      return `<${e20.rawName}`;
  }
}
function x_(e20) {
  switch (mf(!e20.isSelfClosing), e20.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (e20.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
var w_ = {printClosingTag: function(e20, t2) {
  return [e20.isSelfClosing ? "" : c_(e20, t2), l_(e20, t2)];
}, printClosingTagStart: c_, printClosingTagStartMarker: d_, printClosingTagEndMarker: h_, printClosingTagSuffix: f_, printClosingTagEnd: l_, needsToBorrowLastChildClosingTagEndMarker: y_, needsToBorrowParentClosingTagStartMarker: D_, needsToBorrowPrevClosingTagEndMarker: m_, printOpeningTag: function(e20, t2, n2) {
  const r2 = e20.getValue();
  return [v_(r2, t2), b_(e20, t2, n2), r2.isSelfClosing ? "" : A_(r2)];
}, printOpeningTagStart: v_, printOpeningTagPrefix: F_, printOpeningTagStartMarker: S_, printOpeningTagEndMarker: x_, needsToBorrowNextOpeningTagStartMarker: E_, needsToBorrowParentOpeningTagEndMarker: C_}, T_ = r$3(function(e20) {
  var n2, r2;
  n2 = t$3, r2 = function() {
    return function(e21, t2) {
      var n3 = t2 && t2.logger || console;
      function r3(e22) {
        return e22 === " " || e22 === "	" || e22 === "\n" || e22 === "\f" || e22 === "\r";
      }
      function i2(t3) {
        var n4, r4 = t3.exec(e21.substring(y2));
        if (r4)
          return n4 = r4[0], y2 += n4.length, n4;
      }
      for (var u2, o2, s2, a2, c2, l2 = e21.length, p2 = /^[ \t\n\r\u000c]+/, f2 = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g2 = /^\d+$/, m2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y2 = 0, D2 = []; ; ) {
        if (i2(f2), y2 >= l2)
          return D2;
        u2 = i2(d2), o2 = [], u2.slice(-1) === "," ? (u2 = u2.replace(h2, ""), C2()) : E2();
      }
      function E2() {
        for (i2(p2), s2 = "", a2 = "in descriptor"; ; ) {
          if (c2 = e21.charAt(y2), a2 === "in descriptor")
            if (r3(c2))
              s2 && (o2.push(s2), s2 = "", a2 = "after descriptor");
            else {
              if (c2 === ",")
                return y2 += 1, s2 && o2.push(s2), void C2();
              if (c2 === "(")
                s2 += c2, a2 = "in parens";
              else {
                if (c2 === "")
                  return s2 && o2.push(s2), void C2();
                s2 += c2;
              }
            }
          else if (a2 === "in parens")
            if (c2 === ")")
              s2 += c2, a2 = "in descriptor";
            else {
              if (c2 === "")
                return o2.push(s2), void C2();
              s2 += c2;
            }
          else if (a2 === "after descriptor")
            if (r3(c2))
              ;
            else {
              if (c2 === "")
                return void C2();
              a2 = "in descriptor", y2 -= 1;
            }
          y2 += 1;
        }
      }
      function C2() {
        var t3, r4, i3, s3, a3, c3, l3, p3, f3, d3 = false, h3 = {};
        for (s3 = 0; s3 < o2.length; s3++)
          c3 = (a3 = o2[s3])[a3.length - 1], l3 = a3.substring(0, a3.length - 1), p3 = parseInt(l3, 10), f3 = parseFloat(l3), g2.test(l3) && c3 === "w" ? ((t3 || r4) && (d3 = true), p3 === 0 ? d3 = true : t3 = p3) : m2.test(l3) && c3 === "x" ? ((t3 || r4 || i3) && (d3 = true), f3 < 0 ? d3 = true : r4 = f3) : g2.test(l3) && c3 === "h" ? ((i3 || r4) && (d3 = true), p3 === 0 ? d3 = true : i3 = p3) : d3 = true;
        d3 ? n3 && n3.error && n3.error("Invalid srcset descriptor found in '" + e21 + "' at '" + a3 + "'.") : (h3.url = u2, t3 && (h3.w = t3), r4 && (h3.d = r4), i3 && (h3.h = i3), D2.push(h3));
      }
    };
  }, e20.exports ? e20.exports = r2() : n2.parseSrcset = r2();
});
const {builders: {group: B_, ifBreak: N_, indent: k_, join: P_, line: O_, softline: I_}} = eu$1;
const L_ = [":", "__", "--", "_", "-"];
function j_(e20) {
  const t2 = e20.search(/[^_-]/);
  if (t2 !== -1)
    for (const n2 of L_) {
      const r2 = e20.indexOf(n2, t2);
      if (r2 !== -1)
        return e20.slice(0, r2);
    }
  return e20;
}
var __ = {printImgSrcset: function(e20) {
  const t2 = T_(e20, {logger: {error(e21) {
    throw new Error(e21);
  }}}), n2 = t2.some(({w: e21}) => e21), r2 = t2.some(({h: e21}) => e21);
  if (n2 + r2 + t2.some(({d: e21}) => e21) > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  const i2 = n2 ? "w" : r2 ? "h" : "d", u2 = n2 ? "w" : r2 ? "h" : "x", o2 = (e21) => Math.max(...e21), s2 = t2.map((e21) => e21.url), a2 = o2(s2.map((e21) => e21.length)), c2 = t2.map((e21) => e21[i2]).map((e21) => e21 ? e21.toString() : ""), l2 = c2.map((e21) => {
    const t3 = e21.indexOf(".");
    return t3 === -1 ? e21.length : t3;
  }), p2 = o2(l2);
  return P_([",", O_], s2.map((e21, t3) => {
    const n3 = [e21], r3 = c2[t3];
    if (r3) {
      const i3 = a2 - e21.length + 1, o3 = p2 - l2[t3], s3 = " ".repeat(i3 + o3);
      n3.push(N_(s3, " "), r3 + u2);
    }
    return n3;
  }));
}, printClassNames: function(e20) {
  const t2 = e20.trim().split(/\s+/), n2 = [];
  let r2;
  for (let e21 = 0; e21 < t2.length; e21++) {
    const i2 = j_(t2[e21]);
    i2 !== r2 && i2 !== t2[e21 - 1] && n2.push([]), Ln$2(n2).push(t2[e21]), r2 = i2;
  }
  return [k_([I_, P_(O_, n2.map((e21) => B_(P_(O_, e21))))]), I_];
}};
const {builders: {group: M_}} = eu$1;
var R_ = {isVueEventBindingExpression: function(e20) {
  const t2 = e20.trim();
  return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t2) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t2);
}, printVueFor: function(e20, t2) {
  const {left: n2, operator: r2, right: i2} = function(e21) {
    const t3 = /(.*?)\s+(in|of)\s+(.*)/s, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, i3 = e21.match(t3);
    if (!i3)
      return;
    const u2 = {};
    u2.for = i3[3].trim();
    const o2 = i3[1].trim().replace(r3, ""), s2 = o2.match(n3);
    s2 ? (u2.alias = o2.replace(n3, ""), u2.iterator1 = s2[1].trim(), s2[2] && (u2.iterator2 = s2[2].trim())) : u2.alias = o2;
    return {left: `${[u2.alias, u2.iterator1, u2.iterator2].filter(Boolean).join(",")}`, operator: i3[2], right: u2.for};
  }(e20);
  return [M_(t2(`function _(${n2}) {}`, {parser: "babel", __isVueForBindingLeft: true})), " ", r2, " ", t2(i2, {parser: "__js_expression"}, {stripTrailingHardline: true})];
}, printVueBindings: function(e20, t2) {
  return t2(`function _(${e20}) {}`, {parser: "babel", __isVueBindings: true});
}};
const {needsToBorrowParentClosingTagStartMarker: $_, printClosingTagStartMarker: V_, needsToBorrowLastChildClosingTagEndMarker: W_, printClosingTagEndMarker: q_, needsToBorrowParentOpeningTagEndMarker: U_, printOpeningTagEndMarker: z_} = w_;
var G_ = function(e20, t2) {
  let n2 = e20.startSourceSpan.end.offset;
  e20.firstChild && U_(e20.firstChild) && (n2 -= z_(e20).length);
  let r2 = e20.endSourceSpan.start.offset;
  return e20.lastChild && $_(e20.lastChild) ? r2 += V_(e20, t2).length : W_(e20) && (r2 -= q_(e20.lastChild, t2).length), t2.originalText.slice(n2, r2);
};
const {builders: {breakParent: H_, group: J_, hardline: X_, indent: Y_, line: K_, fill: Q_, softline: Z_}, utils: {mapDoc: eM, replaceTextEndOfLine: tM}} = eu$1, {printClosingTag: nM, printClosingTagSuffix: rM, needsToBorrowPrevClosingTagEndMarker: iM, printOpeningTagPrefix: uM, printOpeningTag: oM} = w_, {printImgSrcset: sM, printClassNames: aM} = __, {printVueFor: cM, printVueBindings: lM, isVueEventBindingExpression: pM} = R_, {isScriptLikeTag: fM, isVueNonHtmlBlock: dM, inferScriptParser: hM, htmlTrimPreserveIndentation: gM, dedentString: mM, unescapeQuoteEntities: yM, isVueSlotAttribute: DM, isVueSfcBindingsAttribute: EM, getTextValueParts: CM} = KL;
function bM(e20, t2, n2) {
  const r2 = (t3) => new RegExp(t3.join("|")).test(e20.fullName), i2 = () => yM(e20.value);
  let u2 = false;
  const o2 = (e21, t3) => {
    const n3 = e21.type === "NGRoot" ? e21.node.type === "NGMicrosyntax" && e21.node.body.length === 1 && e21.node.body[0].type === "NGMicrosyntaxExpression" ? e21.node.body[0].expression : e21.node : e21.type === "JsExpressionRoot" ? e21.node : e21;
    !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && (t3.parser !== "__vue_expression" || n3.type !== "TemplateLiteral" && n3.type !== "StringLiteral") || (u2 = true);
  }, s2 = (e21, t3 = true) => J_([Y_([Z_, e21]), t3 ? Z_ : ""]), a2 = (e21) => u2 ? ((e22) => J_(e22))(e21) : s2(e21), c2 = (e21, n3) => t2(e21, Object.assign({__onHtmlBindingRoot: o2, __embeddedInHtml: true}, n3), {stripTrailingHardline: true});
  if (e20.fullName === "srcset" && (e20.parent.fullName === "img" || e20.parent.fullName === "source"))
    return s2(sM(i2()));
  if (e20.fullName === "class" && !n2.parentParser) {
    const e21 = i2();
    if (!e21.includes("{{"))
      return aM(e21);
  }
  if (e20.fullName === "style" && !n2.parentParser) {
    const e21 = i2();
    if (!e21.includes("{{"))
      return s2(c2(e21, {parser: "css", __isHTMLStyleAttribute: true}));
  }
  if (n2.parser === "vue") {
    if (e20.fullName === "v-for")
      return cM(i2(), c2);
    if (DM(e20) || EM(e20, n2))
      return lM(i2(), c2);
    const t3 = ["^:", "^v-bind:"], u3 = ["^v-"];
    if (r2(["^@", "^v-on:"])) {
      const e21 = i2();
      return a2(c2(e21, {parser: pM(e21) ? "__js_expression" : "__vue_event_binding"}));
    }
    if (r2(t3))
      return a2(c2(i2(), {parser: "__vue_expression"}));
    if (r2(u3))
      return a2(c2(i2(), {parser: "__js_expression"}));
  }
  if (n2.parser === "angular") {
    const t3 = (e21, t4) => c2(e21, Object.assign(Object.assign({}, t4), {}, {trailingComma: "none"})), n3 = ["^\\*"], u3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], o3 = ["^i18n(-.+)?$"];
    if (r2(["^\\(.+\\)$", "^on-"]))
      return a2(t3(i2(), {parser: "__ng_action"}));
    if (r2(u3))
      return a2(t3(i2(), {parser: "__ng_binding"}));
    if (r2(o3)) {
      const t4 = i2().trim();
      return s2(Q_(CM(e20, t4)), !t4.includes("@@"));
    }
    if (r2(n3))
      return a2(t3(i2(), {parser: "__ng_directive"}));
    const l2 = /{{(.+?)}}/s, p2 = i2();
    if (l2.test(p2)) {
      const e21 = [];
      for (const [n4, r3] of p2.split(l2).entries())
        if (n4 % 2 == 0)
          e21.push(tM(r3));
        else
          try {
            e21.push(J_(["{{", Y_([K_, t3(r3, {parser: "__ng_interpolation", __isInHtmlInterpolation: true})]), K_, "}}"]));
          } catch {
            e21.push("{{", tM(r3), "}}");
          }
      return J_(e21);
    }
  }
  return null;
}
var AM = function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  switch (i2.type) {
    case "element":
      if (fM(i2) || i2.type === "interpolation")
        return;
      if (!i2.isSelfClosing && dM(i2, r2)) {
        const u2 = hM(i2, r2);
        if (!u2)
          return;
        const o2 = G_(i2, r2);
        let s2 = /^\s*$/.test(o2), a2 = "";
        return s2 || (a2 = n2(gM(o2), {parser: u2, __embeddedInHtml: true}, {stripTrailingHardline: true}), s2 = a2 === ""), [uM(i2, r2), J_(oM(e20, r2, t2)), s2 ? "" : X_, a2, s2 ? "" : X_, nM(i2, r2), rM(i2, r2)];
      }
      break;
    case "text":
      if (fM(i2.parent)) {
        const e21 = hM(i2.parent);
        if (e21) {
          const t3 = e21 === "markdown" ? mM(i2.value.replace(/^[^\S\n]*?\n/, "")) : i2.value, u2 = {parser: e21, __embeddedInHtml: true};
          if (r2.parser === "html" && e21 === "babel") {
            let e22 = "script";
            const {attrMap: t4} = i2.parent;
            t4 && (t4.type === "module" || t4.type === "text/babel" && t4["data-type"] === "module") && (e22 = "module"), u2.__babelSourceType = e22;
          }
          return [H_, uM(i2, r2), n2(t3, u2, {stripTrailingHardline: true}), rM(i2, r2)];
        }
      } else if (i2.parent.type === "interpolation") {
        const e21 = {__isInHtmlInterpolation: true, __embeddedInHtml: true};
        return r2.parser === "angular" ? (e21.parser = "__ng_interpolation", e21.trailingComma = "none") : r2.parser === "vue" ? e21.parser = "__vue_expression" : e21.parser = "__js_expression", [Y_([K_, n2(i2.value, e21, {stripTrailingHardline: true})]), i2.parent.next && iM(i2.parent.next) ? " " : K_];
      }
      break;
    case "attribute": {
      if (!i2.value)
        break;
      if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
        return [i2.rawName, "=", i2.value];
      if (r2.parser === "lwc") {
        if (/^{.*}$/s.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
          return [i2.rawName, "=", i2.value];
      }
      const e21 = bM(i2, (e22, t3) => n2(e22, Object.assign({__isInHtmlAttribute: true, __embeddedInHtml: true}, t3), {stripTrailingHardline: true}), r2);
      if (e21)
        return [i2.rawName, '="', J_(eM(e21, (e22) => typeof e22 == "string" ? e22.replace(/"/g, "&quot;") : e22)), '"'];
      break;
    }
    case "front-matter":
      return rN(i2, n2);
  }
};
const {builders: {breakParent: vM, group: FM, ifBreak: SM, line: xM, softline: wM, hardline: TM}, utils: {replaceTextEndOfLine: BM}} = eu$1, {locStart: NM, locEnd: kM} = Xj, {forceBreakChildren: PM, forceNextEmptyLine: OM, isTextLikeNode: IM, hasPrettierIgnore: LM, preferHardlineAsLeadingSpaces: jM} = KL, {printOpeningTagPrefix: _M, needsToBorrowNextOpeningTagStartMarker: MM, printOpeningTagStartMarker: RM, needsToBorrowPrevClosingTagEndMarker: $M, printClosingTagEndMarker: VM, printClosingTagSuffix: WM, needsToBorrowParentClosingTagStartMarker: qM} = w_;
function UM(e20, t2, n2) {
  const r2 = e20.getValue();
  return LM(r2) ? [_M(r2, t2), ...BM(t2.originalText.slice(NM(r2) + (r2.prev && MM(r2.prev) ? RM(r2).length : 0), kM(r2) - (r2.next && $M(r2.next) ? VM(r2, t2).length : 0))), WM(r2, t2)] : n2();
}
function zM(e20, t2) {
  return IM(e20) && IM(t2) ? e20.isTrailingSpaceSensitive ? e20.hasTrailingSpaces ? jM(t2) ? TM : xM : "" : jM(t2) ? TM : wM : MM(e20) && (LM(t2) || t2.firstChild || t2.isSelfClosing || t2.type === "element" && t2.attrs.length > 0) || e20.type === "element" && e20.isSelfClosing && $M(t2) ? "" : !t2.isLeadingSpaceSensitive || jM(t2) || $M(t2) && e20.lastChild && qM(e20.lastChild) && e20.lastChild.lastChild && qM(e20.lastChild.lastChild) ? TM : t2.hasLeadingSpaces ? xM : wM;
}
var GM = {printChildren: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (PM(r2))
    return [vM, ...e20.map((e21) => {
      const r3 = e21.getValue(), i3 = r3.prev ? zM(r3.prev, r3) : "";
      return [i3 ? [i3, OM(r3.prev) ? TM : ""] : "", UM(e21, t2, n2)];
    }, "children")];
  const i2 = r2.children.map(() => Symbol(""));
  return e20.map((e21, r3) => {
    const u2 = e21.getValue();
    if (IM(u2)) {
      if (u2.prev && IM(u2.prev)) {
        const r4 = zM(u2.prev, u2);
        if (r4)
          return OM(u2.prev) ? [TM, TM, UM(e21, t2, n2)] : [r4, UM(e21, t2, n2)];
      }
      return UM(e21, t2, n2);
    }
    const o2 = [], s2 = [], a2 = [], c2 = [], l2 = u2.prev ? zM(u2.prev, u2) : "", p2 = u2.next ? zM(u2, u2.next) : "";
    return l2 && (OM(u2.prev) ? o2.push(TM, TM) : l2 === TM ? o2.push(TM) : IM(u2.prev) ? s2.push(l2) : s2.push(SM("", wM, {groupId: i2[r3 - 1]}))), p2 && (OM(u2) ? IM(u2.next) && c2.push(TM, TM) : p2 === TM ? IM(u2.next) && c2.push(TM) : a2.push(p2)), [...o2, FM([...s2, FM([UM(e21, t2, n2), ...a2], {id: i2[r3]})]), ...c2];
  }, "children");
}};
const {builders: {breakParent: HM, dedentToRoot: JM, group: XM, ifBreak: YM, indentIfBreak: KM, indent: QM, line: ZM, softline: eR}, utils: {replaceTextEndOfLine: tR}} = eu$1, {shouldPreserveContent: nR, isScriptLikeTag: rR, isVueCustomBlock: iR, countParents: uR, forceBreakContent: oR} = KL, {printOpeningTagPrefix: sR, printOpeningTag: aR, printClosingTagSuffix: cR, printClosingTag: lR, needsToBorrowPrevClosingTagEndMarker: pR, needsToBorrowLastChildClosingTagEndMarker: fR} = w_, {printChildren: dR} = GM;
var hR = {printElement: function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (nR(r2, t2))
    return [sR(r2, t2), XM(aR(e20, t2, n2)), ...tR(G_(r2, t2)), ...lR(r2, t2), cR(r2, t2)];
  const i2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, u2 = Symbol("element-attr-group-id"), o2 = (i3) => XM([XM(aR(e20, t2, n2), {id: u2}), i3, lR(r2, t2)]);
  return r2.children.length === 0 ? o2(r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? ZM : "") : o2([oR(r2) ? HM : "", (s2 = [i2 ? YM(eR, "", {groupId: u2}) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? ZM : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? JM(eR) : eR, dR(e20, t2, n2)], i2 ? KM(s2, {groupId: u2}) : !rR(r2) && !iR(r2, t2) || r2.parent.type !== "root" || t2.parser !== "vue" || t2.vueIndentScriptAndStyle ? QM(s2) : s2), (r2.next ? pR(r2.next) : fR(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : i2 ? YM(eR, "", {groupId: u2}) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? ZM : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t2.tabWidth * uR(e20, (e21) => e21.parent && e21.parent.type !== "root")}}$`).test(r2.lastChild.value) ? "" : eR]);
  var s2;
}};
const {builders: {fill: gR, group: mR, hardline: yR, literalline: DR}, utils: {cleanDoc: ER, getDocParts: CR, isConcat: bR, replaceTextEndOfLine: AR}} = eu$1, {countChars: vR, unescapeQuoteEntities: FR, getTextValueParts: SR} = KL, {insertPragma: xR} = Jj, {locStart: wR, locEnd: TR} = Xj, {printClosingTagSuffix: BR, printClosingTagEnd: NR, printOpeningTagPrefix: kR, printOpeningTagStart: PR} = w_, {printElement: OR} = hR, {printChildren: IR} = GM;
var LR = {preprocess: Hj, print: function(e20, t2, n2) {
  const r2 = e20.getValue();
  switch (r2.type) {
    case "front-matter":
      return AR(r2.raw);
    case "root":
      return t2.__onHtmlRoot && t2.__onHtmlRoot(r2), [mR(IR(e20, t2, n2)), yR];
    case "element":
    case "ieConditionalComment":
      return OR(e20, t2, n2);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [PR(r2), NR(r2)];
    case "interpolation":
      return [PR(r2, t2), ...e20.map(n2, "children"), NR(r2, t2)];
    case "text": {
      if (r2.parent.type === "interpolation") {
        const e22 = /\n[^\S\n]*?$/, t3 = e22.test(r2.value), n3 = t3 ? r2.value.replace(e22, "") : r2.value;
        return [...AR(n3), t3 ? yR : ""];
      }
      const e21 = ER([kR(r2, t2), ...SR(r2), BR(r2, t2)]);
      return bR(e21) || e21.type === "fill" ? gR(CR(e21)) : e21;
    }
    case "docType":
      return [mR([PR(r2, t2), " ", r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), NR(r2, t2)];
    case "comment":
      return [kR(r2, t2), ...AR(t2.originalText.slice(wR(r2), TR(r2)), DR), BR(r2, t2)];
    case "attribute": {
      if (r2.value === null)
        return r2.rawName;
      const e21 = FR(r2.value), t3 = vR(e21, "'") < vR(e21, '"') ? "'" : '"';
      return [r2.rawName, "=", t3, ...AR(t3 === '"' ? e21.replace(/"/g, "&quot;") : e21.replace(/'/g, "&apos;")), t3];
    }
    default:
      throw new Error(`Unexpected node type ${r2.type}`);
  }
}, insertPragma: xR, massageAstNode: dL, embed: AM};
var jR = {bracketSameLine: WB.bracketSameLine, htmlWhitespaceSensitivity: {since: "1.15.0", category: "HTML", type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{value: "css", description: "Respect the default value of CSS display property."}, {value: "strict", description: "Whitespaces are considered sensitive."}, {value: "ignore", description: "Whitespaces are considered insensitive."}]}, vueIndentScriptAndStyle: {since: "1.19.0", category: "HTML", type: "boolean", default: false, description: "Indent script and style tags in Vue files."}}, _R = {name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146}, MR = {name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391};
var RR = {languages: [Xd(_R, () => ({name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: []})), Xd(_R, (e20) => ({since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e20.extensions, ".mjml"]})), Xd(_R, () => ({name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: []})), Xd(MR, () => ({since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"]}))], printers: {html: LR}, options: jR, parsers: void 0};
var $R = {isPragma: function(e20) {
  return /^\s*@(?:prettier|format)\s*$/.test(e20);
}, hasPragma: function(e20) {
  return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e20);
}, insertPragma: function(e20) {
  return `# @format

${e20}`;
}};
var VR = {locStart: function(e20) {
  return e20.position.start.offset;
}, locEnd: function(e20) {
  return e20.position.end.offset;
}};
var WR = function(e20, t2, n2, r2) {
  if (e20.getValue().type === "root" && r2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r2.filepath))
    return n2(r2.originalText, Object.assign(Object.assign({}, r2), {}, {parser: "json"}));
};
const {getLast: qR, isNonEmptyArray: UR} = yi$2;
function zR(e20, t2) {
  return e20 && typeof e20.type == "string" && (!t2 || t2.includes(e20.type));
}
function GR(e20) {
  return e20.value.trim() === "prettier-ignore";
}
function HR(e20) {
  return e20 && UR(e20.leadingComments);
}
function JR(e20) {
  return e20 && UR(e20.middleComments);
}
function XR(e20) {
  return e20 && e20.indicatorComment;
}
function YR(e20) {
  return e20 && e20.trailingComment;
}
function KR(e20) {
  return e20 && UR(e20.endComments);
}
function QR(e20) {
  const t2 = [];
  let n2;
  for (const r2 of e20.split(/( +)/))
    r2 !== " " ? n2 === " " ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : n2 === void 0 && t2.unshift(""), n2 = r2;
  return n2 === " " && t2.push((t2.pop() || "") + " "), t2[0] === "" && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
}
var ZR = {getLast: qR, getAncestorCount: function(e20, t2) {
  let n2 = 0;
  const r2 = e20.stack.length - 1;
  for (let i2 = 0; i2 < r2; i2++) {
    const r3 = e20.stack[i2];
    zR(r3) && t2(r3) && n2++;
  }
  return n2;
}, isNode: zR, isEmptyNode: function(e20) {
  return !UR(e20.children) && !function(e21) {
    return HR(e21) || JR(e21) || XR(e21) || YR(e21) || KR(e21);
  }(e20);
}, isInlineNode: function(e20) {
  if (!e20)
    return true;
  switch (e20.type) {
    case "plain":
    case "quoteDouble":
    case "quoteSingle":
    case "alias":
    case "flowMapping":
    case "flowSequence":
      return true;
    default:
      return false;
  }
}, mapNode: function e11(t2, n2, r2) {
  return n2("children" in t2 ? Object.assign(Object.assign({}, t2), {}, {children: t2.children.map((r3) => e11(r3, n2, t2))}) : t2, r2);
}, defineShortcut: function(e20, t2, n2) {
  Object.defineProperty(e20, t2, {get: n2, enumerable: false});
}, isNextLineEmpty: function(e20, t2) {
  let n2 = 0;
  const r2 = t2.length;
  for (let i2 = e20.position.end.offset - 1; i2 < r2; i2++) {
    const e21 = t2[i2];
    if (e21 === "\n" && n2++, n2 === 1 && /\S/.test(e21))
      return false;
    if (n2 === 2)
      return true;
  }
  return false;
}, isLastDescendantNode: function(e20) {
  switch (e20.getValue().type) {
    case "tag":
    case "anchor":
    case "comment":
      return false;
  }
  const t2 = e20.stack.length;
  for (let n2 = 1; n2 < t2; n2++) {
    const t3 = e20.stack[n2], r2 = e20.stack[n2 - 1];
    if (Array.isArray(r2) && typeof t3 == "number" && t3 !== r2.length - 1)
      return false;
  }
  return true;
}, getBlockValueLineContents: function(e20, {parentIndent: t2, isLastDescendant: n2, options: r2}) {
  const i2 = e20.position.start.line === e20.position.end.line ? "" : r2.originalText.slice(e20.position.start.offset, e20.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u2 = e20.indent === null ? ((e21) => e21 ? e21[1].length : Number.POSITIVE_INFINITY)(i2.match(/^( *)\S/m)) : e20.indent - 1 + t2, o2 = i2.split("\n").map((e21) => e21.slice(u2));
  return r2.proseWrap === "preserve" || e20.type === "blockLiteral" ? s2(o2.map((e21) => e21.length === 0 ? [] : [e21])) : s2(o2.map((e21) => e21.length === 0 ? [] : QR(e21)).reduce((e21, t3, n3) => n3 !== 0 && o2[n3 - 1].length > 0 && t3.length > 0 && !/^\s/.test(t3[0]) && !/^\s|\s$/.test(qR(e21)) ? [...e21.slice(0, -1), [...qR(e21), ...t3]] : [...e21, t3], []).map((e21) => e21.reduce((e22, t3) => e22.length > 0 && /\s$/.test(qR(e22)) ? [...e22.slice(0, -1), qR(e22) + " " + t3] : [...e22, t3], [])).map((e21) => r2.proseWrap === "never" ? [e21.join(" ")] : e21));
  function s2(t3) {
    if (e20.chomping === "keep")
      return qR(t3).length === 0 ? t3.slice(0, -1) : t3;
    let r3 = 0;
    for (let e21 = t3.length - 1; e21 >= 0 && t3[e21].length === 0; e21--)
      r3++;
    return r3 === 0 ? t3 : r3 >= 2 && !n2 ? t3.slice(0, -(r3 - 1)) : t3.slice(0, -r3);
  }
}, getFlowScalarLineContents: function(e20, t2, n2) {
  const r2 = t2.split("\n").map((e21, t3, n3) => t3 === 0 && t3 === n3.length - 1 ? e21 : t3 !== 0 && t3 !== n3.length - 1 ? e21.trim() : t3 === 0 ? e21.trimEnd() : e21.trimStart());
  return n2.proseWrap === "preserve" ? r2.map((e21) => e21.length === 0 ? [] : [e21]) : r2.map((e21) => e21.length === 0 ? [] : QR(e21)).reduce((t3, n3, i2) => i2 !== 0 && r2[i2 - 1].length > 0 && n3.length > 0 && (e20 !== "quoteDouble" || !qR(qR(t3)).endsWith("\\")) ? [...t3.slice(0, -1), [...qR(t3), ...n3]] : [...t3, n3], []).map((e21) => n2.proseWrap === "never" ? [e21.join(" ")] : e21);
}, getLastDescendantNode: function e12(t2) {
  return UR(t2.children) ? e12(qR(t2.children)) : t2;
}, hasPrettierIgnore: function(e20) {
  const t2 = e20.getValue();
  if (t2.type === "documentBody") {
    const t3 = e20.getParentNode();
    return KR(t3.head) && GR(qR(t3.head.endComments));
  }
  return HR(t2) && GR(qR(t2.leadingComments));
}, hasLeadingComments: HR, hasMiddleComments: JR, hasIndicatorComment: XR, hasTrailingComment: YR, hasEndComments: KR};
const {defineShortcut: e$, mapNode: t$} = ZR;
function n$(e20) {
  switch (e20.type) {
    case "document":
      e$(e20, "head", () => e20.children[0]), e$(e20, "body", () => e20.children[1]);
      break;
    case "documentBody":
    case "sequenceItem":
    case "flowSequenceItem":
    case "mappingKey":
    case "mappingValue":
      e$(e20, "content", () => e20.children[0]);
      break;
    case "mappingItem":
    case "flowMappingItem":
      e$(e20, "key", () => e20.children[0]), e$(e20, "value", () => e20.children[1]);
  }
  return e20;
}
var r$ = function(e20) {
  return t$(e20, n$);
};
const {builders: {softline: i$, align: u$}} = eu$1, {hasEndComments: o$, isNextLineEmpty: s$, isNode: a$} = ZR, c$ = new WeakMap();
function l$(e20) {
  return o$(e20) && !a$(e20, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
}
var p$ = {alignWithSpaces: function(e20, t2) {
  return u$(" ".repeat(e20), t2);
}, shouldPrintEndComments: l$, printNextEmptyLine: function(e20, t2) {
  const n2 = e20.getValue(), r2 = e20.stack[0];
  let i2;
  return c$.has(r2) ? i2 = c$.get(r2) : (i2 = new Set(), c$.set(r2, i2)), i2.has(n2.position.end.line) || (i2.add(n2.position.end.line), !s$(n2, t2) || l$(e20.getParentNode())) ? "" : i$;
}};
const {builders: {ifBreak: f$, line: d$, softline: h$, hardline: g$, join: m$}} = eu$1, {isEmptyNode: y$, getLast: D$, hasEndComments: E$} = ZR, {printNextEmptyLine: C$, alignWithSpaces: b$} = p$;
function A$(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "flowMapping", u2 = i2 ? "{" : "[", o2 = i2 ? "}" : "]";
  let s2 = h$;
  i2 && r2.children.length > 0 && n2.bracketSpacing && (s2 = d$);
  const a2 = D$(r2.children), c2 = a2 && a2.type === "flowMappingItem" && y$(a2.key) && y$(a2.value);
  return [u2, b$(n2.tabWidth, [s2, v$(e20, t2, n2), n2.trailingComma === "none" ? "" : f$(","), E$(r2) ? [g$, m$(g$, e20.map(t2, "endComments"))] : ""]), c2 ? "" : s2, o2];
}
function v$(e20, t2, n2) {
  const r2 = e20.getValue();
  return e20.map((e21, i2) => [t2(), i2 === r2.children.length - 1 ? "" : [",", d$, r2.children[i2].position.start.line !== r2.children[i2 + 1].position.start.line ? C$(e21, n2.originalText) : ""]], "children");
}
var F$ = {printFlowMapping: A$, printFlowSequence: A$};
const {builders: {conditionalGroup: S$, group: x$, hardline: w$, ifBreak: T$, join: B$, line: N$}} = eu$1, {hasLeadingComments: k$, hasMiddleComments: P$, hasTrailingComment: O$, hasEndComments: I$, isNode: L$, isEmptyNode: j$, isInlineNode: _$} = ZR, {alignWithSpaces: M$} = p$;
function R$(e20, t2) {
  if (!e20)
    return true;
  switch (e20.type) {
    case "plain":
    case "quoteSingle":
    case "quoteDouble":
      break;
    case "alias":
      return true;
    default:
      return false;
  }
  if (t2.proseWrap === "preserve")
    return e20.position.start.line === e20.position.end.line;
  if (/\\$/m.test(t2.originalText.slice(e20.position.start.offset, e20.position.end.offset)))
    return false;
  switch (t2.proseWrap) {
    case "never":
      return !e20.value.includes("\n");
    case "always":
      return !/[\n ]/.test(e20.value);
    default:
      return false;
  }
}
var $$ = function(e20, t2, n2, r2, i2) {
  const {key: u2, value: o2} = e20, s2 = j$(u2), a2 = j$(o2);
  if (s2 && a2)
    return ": ";
  const c2 = r2("key"), l2 = function(e21) {
    return e21.key.content && e21.key.content.type === "alias";
  }(e20) ? " " : "";
  if (a2)
    return e20.type === "flowMappingItem" && t2.type === "flowMapping" ? c2 : e20.type !== "mappingItem" || !R$(u2.content, i2) || O$(u2.content) || t2.tag && t2.tag.value === "tag:yaml.org,2002:set" ? ["? ", M$(2, c2)] : [c2, l2, ":"];
  const p2 = r2("value");
  if (s2)
    return [": ", M$(2, p2)];
  if (k$(o2) || !_$(u2.content))
    return ["? ", M$(2, c2), w$, B$("", n2.map(r2, "value", "leadingComments").map((e21) => [e21, w$])), ": ", M$(2, p2)];
  if (function(e21) {
    if (!e21)
      return true;
    switch (e21.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
        return e21.position.start.line === e21.position.end.line;
      case "alias":
        return true;
      default:
        return false;
    }
  }(u2.content) && !k$(u2.content) && !P$(u2.content) && !O$(u2.content) && !I$(u2) && !k$(o2.content) && !P$(o2.content) && !I$(o2) && R$(o2.content, i2))
    return [c2, l2, ": ", p2];
  const f2 = Symbol("mappingKey"), d2 = x$([T$("? "), x$(M$(2, c2), {id: f2})]), h2 = [w$, ": ", M$(2, p2)], g2 = [l2, ":"];
  k$(o2.content) || I$(o2) && o2.content && !L$(o2.content, ["mapping", "sequence"]) || t2.type === "mapping" && O$(u2.content) && _$(o2.content) || L$(o2.content, ["mapping", "sequence"]) && o2.content.tag === null && o2.content.anchor === null ? g2.push(w$) : o2.content && g2.push(N$), g2.push(p2);
  const m2 = M$(i2.tabWidth, g2);
  return !R$(u2.content, i2) || k$(u2.content) || P$(u2.content) || I$(u2) ? S$([[d2, T$(h2, m2, {groupId: f2})]]) : S$([[c2, m2]]);
};
const {builders: {dedent: V$, dedentToRoot: W$, fill: q$, hardline: U$, join: z$, line: G$, literalline: H$, markAsRoot: J$}, utils: {getDocParts: X$}} = eu$1, {getAncestorCount: Y$, getBlockValueLineContents: K$, hasIndicatorComment: Q$, isLastDescendantNode: Z$, isNode: eV} = ZR, {alignWithSpaces: tV} = p$;
var nV = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = Y$(e20, (e21) => eV(e21, ["sequence", "mapping"])), u2 = Z$(e20), o2 = [r2.type === "blockFolded" ? ">" : "|"];
  r2.indent !== null && o2.push(r2.indent.toString()), r2.chomping !== "clip" && o2.push(r2.chomping === "keep" ? "+" : "-"), Q$(r2) && o2.push(" ", t2("indicatorComment"));
  const s2 = K$(r2, {parentIndent: i2, isLastDescendant: u2, options: n2}), a2 = [];
  for (const [e21, t3] of s2.entries())
    e21 === 0 && a2.push(U$), a2.push(q$(X$(z$(G$, t3)))), e21 !== s2.length - 1 ? a2.push(t3.length === 0 ? U$ : J$(H$)) : r2.chomping === "keep" && u2 && a2.push(W$(t3.length === 0 ? U$ : H$));
  return r2.indent === null ? o2.push(V$(tV(n2.tabWidth, a2))) : o2.push(W$(tV(r2.indent - 1 + i2, a2))), o2;
};
const {builders: {breakParent: rV, fill: iV, group: uV, hardline: oV, join: sV, line: aV, lineSuffix: cV, literalline: lV}, utils: {getDocParts: pV, replaceTextEndOfLine: fV}} = eu$1, {isPreviousLineEmpty: dV} = yi$2, {insertPragma: hV, isPragma: gV} = $R, {locStart: mV} = VR, {getFlowScalarLineContents: yV, getLastDescendantNode: DV, hasLeadingComments: EV, hasMiddleComments: CV, hasTrailingComment: bV, hasEndComments: AV, hasPrettierIgnore: vV, isLastDescendantNode: FV, isNode: SV, isInlineNode: xV} = ZR, {alignWithSpaces: wV, printNextEmptyLine: TV, shouldPrintEndComments: BV} = p$, {printFlowMapping: NV, printFlowSequence: kV} = F$;
function PV(e20, t2) {
  return bV(e20) || t2 && (t2.head.children.length > 0 || AV(t2.head));
}
function OV(e20, t2, n2) {
  const r2 = yV(e20, t2, n2);
  return sV(oV, r2.map((e21) => iV(pV(sV(aV, e21)))));
}
var IV = {preprocess: r$, embed: WR, print: function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = [];
  r2.type !== "mappingValue" && EV(r2) && i2.push([sV(oV, e20.map(n2, "leadingComments")), oV]);
  const {tag: u2, anchor: o2} = r2;
  u2 && i2.push(n2("tag")), u2 && o2 && i2.push(" "), o2 && i2.push(n2("anchor"));
  let s2 = "";
  SV(r2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !FV(e20) && (s2 = TV(e20, t2.originalText)), (u2 || o2) && (SV(r2, ["sequence", "mapping"]) && !CV(r2) ? i2.push(oV) : i2.push(" ")), CV(r2) && i2.push([r2.middleComments.length === 1 ? "" : oV, sV(oV, e20.map(n2, "middleComments")), oV]);
  const a2 = e20.getParentNode();
  return vV(e20) ? i2.push(fV(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), lV)) : i2.push(uV(function(e21, t3, n3, r3, i3) {
    switch (e21.type) {
      case "root": {
        const {children: t4} = e21, r4 = [];
        n3.each((e22, n4) => {
          const u4 = t4[n4], o3 = t4[n4 + 1];
          n4 !== 0 && r4.push(oV), r4.push(i3()), PV(u4, o3) ? (r4.push(oV, "..."), bV(u4) && r4.push(" ", i3("trailingComment"))) : o3 && !bV(o3.head) && r4.push(oV, "---");
        }, "children");
        const u3 = DV(e21);
        return SV(u3, ["blockLiteral", "blockFolded"]) && u3.chomping === "keep" || r4.push(oV), r4;
      }
      case "document": {
        const u3 = [];
        return function(e22, t4, n4, r4) {
          if (n4.children[0] === e22 && /---(?:\s|$)/.test(r4.originalText.slice(mV(e22), mV(e22) + 4)) || e22.head.children.length > 0 || AV(e22.head) || bV(e22.head))
            return "head";
          if (PV(e22, t4))
            return false;
          return !!t4 && "root";
        }(e21, t3.children[n3.getName() + 1], t3, r3) === "head" && ((e21.head.children.length > 0 || e21.head.endComments.length > 0) && u3.push(i3("head")), bV(e21.head) ? u3.push(["---", " ", i3(["head", "trailingComment"])]) : u3.push("---")), function(e22) {
          return e22.body.children.length > 0 || AV(e22.body);
        }(e21) && u3.push(i3("body")), sV(oV, u3);
      }
      case "documentHead":
        return sV(oV, [...n3.map(i3, "children"), ...n3.map(i3, "endComments")]);
      case "documentBody": {
        const {children: t4, endComments: r4} = e21;
        let u3 = "";
        if (t4.length > 0 && r4.length > 0) {
          const t5 = DV(e21);
          SV(t5, ["blockFolded", "blockLiteral"]) ? t5.chomping !== "keep" && (u3 = [oV, oV]) : u3 = oV;
        }
        return [sV(oV, n3.map(i3, "children")), u3, sV(oV, n3.map(i3, "endComments"))];
      }
      case "directive":
        return ["%", sV(" ", [e21.name, ...e21.parameters])];
      case "comment":
        return ["#", e21.value];
      case "alias":
        return ["*", e21.value];
      case "tag":
        return r3.originalText.slice(e21.position.start.offset, e21.position.end.offset);
      case "anchor":
        return ["&", e21.value];
      case "plain":
        return OV(e21.type, r3.originalText.slice(e21.position.start.offset, e21.position.end.offset), r3);
      case "quoteDouble":
      case "quoteSingle": {
        const t4 = "'", n4 = '"', i4 = r3.originalText.slice(e21.position.start.offset + 1, e21.position.end.offset - 1);
        if (e21.type === "quoteSingle" && i4.includes("\\") || e21.type === "quoteDouble" && /\\[^"]/.test(i4)) {
          const u4 = e21.type === "quoteDouble" ? n4 : t4;
          return [u4, OV(e21.type, i4, r3), u4];
        }
        if (i4.includes(n4))
          return [t4, OV(e21.type, e21.type === "quoteDouble" ? i4.replace(/\\"/g, n4).replace(/'/g, t4.repeat(2)) : i4, r3), t4];
        if (i4.includes(t4))
          return [n4, OV(e21.type, e21.type === "quoteSingle" ? i4.replace(/''/g, t4) : i4, r3), n4];
        const u3 = r3.singleQuote ? t4 : n4;
        return [u3, OV(e21.type, i4, r3), u3];
      }
      case "blockFolded":
      case "blockLiteral":
        return nV(n3, i3, r3);
      case "mapping":
      case "sequence":
        return sV(oV, n3.map(i3, "children"));
      case "sequenceItem":
        return ["- ", wV(2, e21.content ? i3("content") : "")];
      case "mappingKey":
      case "mappingValue":
        return e21.content ? i3("content") : "";
      case "mappingItem":
      case "flowMappingItem":
        return $$(e21, t3, n3, i3, r3);
      case "flowMapping":
        return NV(n3, i3, r3);
      case "flowSequence":
        return kV(n3, i3, r3);
      case "flowSequenceItem":
        return i3("content");
      default:
        throw new Error(`Unexpected node type ${e21.type}`);
    }
  }(r2, a2, e20, t2, n2))), bV(r2) && !SV(r2, ["document", "documentHead"]) && i2.push(cV([r2.type !== "mappingValue" || r2.content ? " " : "", a2.type === "mappingKey" && e20.getParentNode(2).type === "mapping" && xV(r2) ? "" : rV, n2("trailingComment")])), BV(r2) && i2.push(wV(r2.type === "sequenceItem" ? 2 : 0, [oV, sV(oV, e20.map((e21) => [dV(t2.originalText, e21.getValue(), mV) ? oV : "", n2()], "endComments"))])), i2.push(s2), i2;
}, massageAstNode: function(e20, t2) {
  if (SV(t2))
    switch (delete t2.position, t2.type) {
      case "comment":
        if (gV(t2.value))
          return null;
        break;
      case "quoteDouble":
      case "quoteSingle":
        t2.type = "quote";
    }
}, insertPragma: hV}, LV = {bracketSpacing: WB.bracketSpacing, singleQuote: WB.singleQuote, proseWrap: WB.proseWrap};
var jV = [YB, nP, fO, OO, cL, RR, {languages: [Xd({name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407}, (e20) => ({since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e20.filenames.filter((e21) => e21 !== "yarn.lock"), ".prettierrc", ".stylelintrc"]}))], printers: {yaml: IV}, options: LV, parsers: void 0}];
const {version: _V} = e$3, {getSupportInfo: MV} = Qr$2;
function RV(e20, t2 = 1) {
  return (...n2) => {
    const r2 = n2[t2] || {}, i2 = r2.plugins || [];
    return n2[t2] = Object.assign(Object.assign({}, r2), {}, {plugins: [...jV, ...Array.isArray(i2) ? i2 : Object.values(i2)]}), e20(...n2);
  };
}
const $V = RV(vd.formatWithCursor);
var VV = {formatWithCursor: $V, format: (e20, t2) => $V(e20, t2).formatted, check(e20, t2) {
  const {formatted: n2} = $V(e20, t2);
  return n2 === e20;
}, doc: eu$1, getSupportInfo: RV(MV, 0), version: _V, util: Hd, __debug: {parse: RV(vd.parse), formatAST: RV(vd.formatAST), formatDoc: RV(vd.formatDoc), printToDoc: RV(vd.printToDoc), printDocToString: RV(vd.printDocToString)}};
var e$2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function t$2(e20) {
  return e20 && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
}
function s$2(e20) {
  var t2 = {exports: {}};
  return e20(t2, t2.exports), t2.exports;
}
var r$2, i$2, a$2 = function(e20) {
  return e20 && e20.Math == Math && e20;
}, n$2 = a$2(typeof globalThis == "object" && globalThis) || a$2(typeof window == "object" && window) || a$2(typeof self == "object" && self) || a$2(typeof e$2 == "object" && e$2) || function() {
  return this;
}() || Function("return this")(), o$2 = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, u$2 = !o$2(function() {
  return Object.defineProperty({}, 1, {get: function() {
    return 7;
  }})[1] != 7;
}), h$2 = {}.propertyIsEnumerable, c$2 = Object.getOwnPropertyDescriptor, p$2 = {f: c$2 && !h$2.call({1: 2}, 1) ? function(e20) {
  var t2 = c$2(this, e20);
  return !!t2 && t2.enumerable;
} : h$2}, l$2 = function(e20, t2) {
  return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
}, d$2 = {}.toString, D$2 = function(e20) {
  return d$2.call(e20).slice(8, -1);
}, m$2 = "".split, f$2 = o$2(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return D$2(e20) == "String" ? m$2.call(e20, "") : Object(e20);
} : Object, y$2 = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, A$2 = function(e20) {
  return f$2(y$2(e20));
}, E$2 = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, C$2 = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, x$2 = function(e20, t2) {
  return arguments.length < 2 ? C$2(n$2[e20]) : n$2[e20] && n$2[e20][t2];
}, F$2 = x$2("navigator", "userAgent") || "", g$2 = n$2.process, b$2 = n$2.Deno, P$2 = g$2 && g$2.versions || b$2 && b$2.version, T$2 = P$2 && P$2.v8;
T$2 ? i$2 = (r$2 = T$2.split("."))[0] < 4 ? 1 : r$2[0] + r$2[1] : F$2 && (!(r$2 = F$2.match(/Edge\/(\d+)/)) || r$2[1] >= 74) && (r$2 = F$2.match(/Chrome\/(\d+)/)) && (i$2 = r$2[1]);
var w$2 = i$2 && +i$2, S$2 = !!Object.getOwnPropertySymbols && !o$2(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && w$2 && w$2 < 41;
}), B$2 = S$2 && !Symbol.sham && typeof Symbol.iterator == "symbol", N$2 = B$2 ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = x$2("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, I$2 = function(e20, t2) {
  try {
    Object.defineProperty(n$2, e20, {value: t2, configurable: true, writable: true});
  } catch (s2) {
    n$2[e20] = t2;
  }
  return t2;
}, v$2 = n$2["__core-js_shared__"] || I$2("__core-js_shared__", {}), k$2 = s$2(function(e20) {
  (e20.exports = function(e21, t2) {
    return v$2[e21] || (v$2[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
}), L$2 = function(e20) {
  return Object(y$2(e20));
}, O$2 = {}.hasOwnProperty, M$2 = Object.hasOwn || function(e20, t2) {
  return O$2.call(L$2(e20), t2);
}, R$2 = 0, j$2 = Math.random(), _$2 = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++R$2 + j$2).toString(36);
}, U$2 = k$2("wks"), q$2 = n$2.Symbol, $$2 = B$2 ? q$2 : q$2 && q$2.withoutSetter || _$2, H$2 = function(e20) {
  return M$2(U$2, e20) && (S$2 || typeof U$2[e20] == "string") || (S$2 && M$2(q$2, e20) ? U$2[e20] = q$2[e20] : U$2[e20] = $$2("Symbol." + e20)), U$2[e20];
}, V$2 = H$2("toPrimitive"), z$2 = function(e20, t2) {
  if (!E$2(e20) || N$2(e20))
    return e20;
  var s2, r2 = e20[V$2];
  if (r2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), s2 = r2.call(e20, t2), !E$2(s2) || N$2(s2))
      return s2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var s3, r3;
    if (t3 === "string" && typeof (s3 = e21.toString) == "function" && !E$2(r3 = s3.call(e21)))
      return r3;
    if (typeof (s3 = e21.valueOf) == "function" && !E$2(r3 = s3.call(e21)))
      return r3;
    if (t3 !== "string" && typeof (s3 = e21.toString) == "function" && !E$2(r3 = s3.call(e21)))
      return r3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, W$2 = function(e20) {
  var t2 = z$2(e20, "string");
  return N$2(t2) ? t2 : String(t2);
}, G$2 = n$2.document, K$2 = E$2(G$2) && E$2(G$2.createElement), X$2 = !u$2 && !o$2(function() {
  return Object.defineProperty((e20 = "div", K$2 ? G$2.createElement(e20) : {}), "a", {get: function() {
    return 7;
  }}).a != 7;
  var e20;
}), J$2 = Object.getOwnPropertyDescriptor, Y$2 = {f: u$2 ? J$2 : function(e20, t2) {
  if (e20 = A$2(e20), t2 = W$2(t2), X$2)
    try {
      return J$2(e20, t2);
    } catch (e21) {
    }
  if (M$2(e20, t2))
    return l$2(!p$2.f.call(e20, t2), e20[t2]);
}}, Q$2 = function(e20) {
  if (!E$2(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, Z$2 = Object.defineProperty, ee$2 = {f: u$2 ? Z$2 : function(e20, t2, s2) {
  if (Q$2(e20), t2 = W$2(t2), Q$2(s2), X$2)
    try {
      return Z$2(e20, t2, s2);
    } catch (e21) {
    }
  if ("get" in s2 || "set" in s2)
    throw TypeError("Accessors not supported");
  return "value" in s2 && (e20[t2] = s2.value), e20;
}}, te$2 = u$2 ? function(e20, t2, s2) {
  return ee$2.f(e20, t2, l$2(1, s2));
} : function(e20, t2, s2) {
  return e20[t2] = s2, e20;
}, se$2 = Function.toString;
typeof v$2.inspectSource != "function" && (v$2.inspectSource = function(e20) {
  return se$2.call(e20);
});
var re$2, ie$2, ae$2, ne$2, oe$2 = v$2.inspectSource, ue$2 = n$2.WeakMap, he$2 = typeof ue$2 == "function" && /native code/.test(oe$2(ue$2)), ce$2 = k$2("keys"), pe$2 = {}, le$2 = n$2.WeakMap;
if (he$2 || v$2.state) {
  var de$2 = v$2.state || (v$2.state = new le$2()), De$2 = de$2.get, me$2 = de$2.has, fe$2 = de$2.set;
  re$2 = function(e20, t2) {
    if (me$2.call(de$2, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, fe$2.call(de$2, e20, t2), t2;
  }, ie$2 = function(e20) {
    return De$2.call(de$2, e20) || {};
  }, ae$2 = function(e20) {
    return me$2.call(de$2, e20);
  };
} else {
  var ye$2 = ce$2[ne$2 = "state"] || (ce$2[ne$2] = _$2(ne$2));
  pe$2[ye$2] = true, re$2 = function(e20, t2) {
    if (M$2(e20, ye$2))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, te$2(e20, ye$2, t2), t2;
  }, ie$2 = function(e20) {
    return M$2(e20, ye$2) ? e20[ye$2] : {};
  }, ae$2 = function(e20) {
    return M$2(e20, ye$2);
  };
}
var Ae$2 = {set: re$2, get: ie$2, has: ae$2, enforce: function(e20) {
  return ae$2(e20) ? ie$2(e20) : re$2(e20, {});
}, getterFor: function(e20) {
  return function(t2) {
    var s2;
    if (!E$2(t2) || (s2 = ie$2(t2)).type !== e20)
      throw TypeError("Incompatible receiver, " + e20 + " required");
    return s2;
  };
}}, Ee$2 = s$2(function(e20) {
  var t2 = Ae$2.get, s2 = Ae$2.enforce, r2 = String(String).split("String");
  (e20.exports = function(e21, t3, i2, a2) {
    var o2, u2 = !!a2 && !!a2.unsafe, h2 = !!a2 && !!a2.enumerable, c2 = !!a2 && !!a2.noTargetGet;
    typeof i2 == "function" && (typeof t3 != "string" || M$2(i2, "name") || te$2(i2, "name", t3), (o2 = s2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e21 !== n$2 ? (u2 ? !c2 && e21[t3] && (h2 = true) : delete e21[t3], h2 ? e21[t3] = i2 : te$2(e21, t3, i2)) : h2 ? e21[t3] = i2 : I$2(t3, i2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || oe$2(this);
  });
}), Ce$2 = Math.ceil, xe$2 = Math.floor, Fe$2 = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? xe$2 : Ce$2)(e20);
}, ge$2 = Math.min, be$2 = function(e20) {
  return e20 > 0 ? ge$2(Fe$2(e20), 9007199254740991) : 0;
}, Pe$2 = Math.max, Te$2 = Math.min, we$2 = function(e20) {
  return function(t2, s2, r2) {
    var i2, a2 = A$2(t2), n2 = be$2(a2.length), o2 = function(e21, t3) {
      var s3 = Fe$2(e21);
      return s3 < 0 ? Pe$2(s3 + t3, 0) : Te$2(s3, t3);
    }(r2, n2);
    if (e20 && s2 != s2) {
      for (; n2 > o2; )
        if ((i2 = a2[o2++]) != i2)
          return true;
    } else
      for (; n2 > o2; o2++)
        if ((e20 || o2 in a2) && a2[o2] === s2)
          return e20 || o2 || 0;
    return !e20 && -1;
  };
}, Se$2 = {includes: we$2(true), indexOf: we$2(false)}.indexOf, Be$2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ne$2 = {f: Object.getOwnPropertyNames || function(e20) {
  return function(e21, t2) {
    var s2, r2 = A$2(e21), i2 = 0, a2 = [];
    for (s2 in r2)
      !M$2(pe$2, s2) && M$2(r2, s2) && a2.push(s2);
    for (; t2.length > i2; )
      M$2(r2, s2 = t2[i2++]) && (~Se$2(a2, s2) || a2.push(s2));
    return a2;
  }(e20, Be$2);
}}, Ie$2 = {f: Object.getOwnPropertySymbols}, ve$2 = x$2("Reflect", "ownKeys") || function(e20) {
  var t2 = Ne$2.f(Q$2(e20)), s2 = Ie$2.f;
  return s2 ? t2.concat(s2(e20)) : t2;
}, ke$2 = function(e20, t2) {
  for (var s2 = ve$2(t2), r2 = ee$2.f, i2 = Y$2.f, a2 = 0; a2 < s2.length; a2++) {
    var n2 = s2[a2];
    M$2(e20, n2) || r2(e20, n2, i2(t2, n2));
  }
}, Le$2 = /#|\.prototype\./, Oe$2 = function(e20, t2) {
  var s2 = Re$2[Me$2(e20)];
  return s2 == _e$2 || s2 != je$2 && (typeof t2 == "function" ? o$2(t2) : !!t2);
}, Me$2 = Oe$2.normalize = function(e20) {
  return String(e20).replace(Le$2, ".").toLowerCase();
}, Re$2 = Oe$2.data = {}, je$2 = Oe$2.NATIVE = "N", _e$2 = Oe$2.POLYFILL = "P", Ue$2 = Oe$2, qe$2 = Y$2.f, $e$2 = function(e20, t2) {
  var s2, r2, i2, a2, o2, u2 = e20.target, h2 = e20.global, c2 = e20.stat;
  if (s2 = h2 ? n$2 : c2 ? n$2[u2] || I$2(u2, {}) : (n$2[u2] || {}).prototype)
    for (r2 in t2) {
      if (a2 = t2[r2], i2 = e20.noTargetGet ? (o2 = qe$2(s2, r2)) && o2.value : s2[r2], !Ue$2(h2 ? r2 : u2 + (c2 ? "." : "#") + r2, e20.forced) && i2 !== void 0) {
        if (typeof a2 == typeof i2)
          continue;
        ke$2(a2, i2);
      }
      (e20.sham || i2 && i2.sham) && te$2(a2, "sham", true), Ee$2(s2, r2, a2, e20);
    }
}, He$2 = Array.isArray || function(e20) {
  return D$2(e20) == "Array";
}, Ve$2 = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, ze$2 = function(e20, t2, s2) {
  if (Ve$2(e20), t2 === void 0)
    return e20;
  switch (s2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(s3) {
        return e20.call(t2, s3);
      };
    case 2:
      return function(s3, r2) {
        return e20.call(t2, s3, r2);
      };
    case 3:
      return function(s3, r2, i2) {
        return e20.call(t2, s3, r2, i2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, We$2 = function(e20, t2, s2, r2, i2, a2, n2, o2) {
  for (var u2, h2 = i2, c2 = 0, p2 = !!n2 && ze$2(n2, o2, 3); c2 < r2; ) {
    if (c2 in s2) {
      if (u2 = p2 ? p2(s2[c2], c2, t2) : s2[c2], a2 > 0 && He$2(u2))
        h2 = We$2(e20, t2, u2, be$2(u2.length), h2, a2 - 1) - 1;
      else {
        if (h2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[h2] = u2;
      }
      h2++;
    }
    c2++;
  }
  return h2;
}, Ge$2 = We$2, Ke$2 = H$2("species"), Xe$2 = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return He$2(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !He$2(t3.prototype) ? E$2(t3) && (t3 = t3[Ke$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
$e$2({target: "Array", proto: true}, {flatMap: function(e20) {
  var t2, s2 = L$2(this), r2 = be$2(s2.length);
  return Ve$2(e20), (t2 = Xe$2(s2, 0)).length = Ge$2(t2, s2, s2, r2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
}});
var Je$2 = function(...e20) {
  let t2;
  for (const [s2, r2] of e20.entries())
    try {
      return {result: r2()};
    } catch (e21) {
      s2 === 0 && (t2 = e21);
    }
  return {error: t2};
}, Ye$2 = (e20) => typeof e20 == "string" ? e20.replace((({onlyFirst: e21 = false} = {}) => {
  const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(t2, e21 ? void 0 : "g");
})(), "") : e20;
const Qe$2 = (e20) => !Number.isNaN(e20) && (e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141));
var Ze$2 = Qe$2, et$2 = Qe$2;
Ze$2.default = et$2;
const tt$2 = (e20) => {
  if (typeof e20 != "string" || e20.length === 0)
    return 0;
  if ((e20 = Ye$2(e20)).length === 0)
    return 0;
  e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
  let t2 = 0;
  for (let s2 = 0; s2 < e20.length; s2++) {
    const r2 = e20.codePointAt(s2);
    r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && s2++, t2 += Ze$2(r2) ? 2 : 1));
  }
  return t2;
};
var st$2 = tt$2, rt$2 = tt$2;
st$2.default = rt$2;
var it$2 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
var at$2 = (e20) => e20[e20.length - 1];
function nt$2(e20, t2) {
  if (e20 == null)
    return {};
  var s2, r2, i2 = function(e21, t3) {
    if (e21 == null)
      return {};
    var s3, r3, i3 = {}, a3 = Object.keys(e21);
    for (r3 = 0; r3 < a3.length; r3++)
      s3 = a3[r3], t3.indexOf(s3) >= 0 || (i3[s3] = e21[s3]);
    return i3;
  }(e20, t2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(e20);
    for (r2 = 0; r2 < a2.length; r2++)
      s2 = a2[r2], t2.indexOf(s2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, s2) && (i2[s2] = e20[s2]);
  }
  return i2;
}
var ot$2, ut$2, ht$2 = function(e20) {
  if (N$2(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, ct$2 = Math.floor, pt$2 = function(e20, t2) {
  var s2 = e20.length, r2 = ct$2(s2 / 2);
  return s2 < 8 ? lt$2(e20, t2) : dt$2(pt$2(e20.slice(0, r2), t2), pt$2(e20.slice(r2), t2), t2);
}, lt$2 = function(e20, t2) {
  for (var s2, r2, i2 = e20.length, a2 = 1; a2 < i2; ) {
    for (r2 = a2, s2 = e20[a2]; r2 && t2(e20[r2 - 1], s2) > 0; )
      e20[r2] = e20[--r2];
    r2 !== a2++ && (e20[r2] = s2);
  }
  return e20;
}, dt$2 = function(e20, t2, s2) {
  for (var r2 = e20.length, i2 = t2.length, a2 = 0, n2 = 0, o2 = []; a2 < r2 || n2 < i2; )
    a2 < r2 && n2 < i2 ? o2.push(s2(e20[a2], t2[n2]) <= 0 ? e20[a2++] : t2[n2++]) : o2.push(a2 < r2 ? e20[a2++] : t2[n2++]);
  return o2;
}, Dt$2 = pt$2, mt$2 = F$2.match(/firefox\/(\d+)/i), ft$2 = !!mt$2 && +mt$2[1], yt$2 = /MSIE|Trident/.test(F$2), At$2 = F$2.match(/AppleWebKit\/(\d+)\./), Et$2 = !!At$2 && +At$2[1], Ct$2 = [], xt$2 = Ct$2.sort, Ft$2 = o$2(function() {
  Ct$2.sort(void 0);
}), gt$2 = o$2(function() {
  Ct$2.sort(null);
}), bt$2 = !!(ut$2 = []["sort"]) && o$2(function() {
  ut$2.call(null, ot$2 || function() {
    throw 1;
  }, 1);
}), Pt$1 = !o$2(function() {
  if (w$2)
    return w$2 < 70;
  if (!(ft$2 && ft$2 > 3)) {
    if (yt$2)
      return true;
    if (Et$2)
      return Et$2 < 603;
    var e20, t2, s2, r2, i2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          s2 = 3;
          break;
        case 68:
        case 71:
          s2 = 4;
          break;
        default:
          s2 = 2;
      }
      for (r2 = 0; r2 < 47; r2++)
        Ct$2.push({k: t2 + r2, v: s2});
    }
    for (Ct$2.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), r2 = 0; r2 < Ct$2.length; r2++)
      t2 = Ct$2[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
    return i2 !== "DGBEFHACIJK";
  }
});
$e$2({target: "Array", proto: true, forced: Ft$2 || !gt$2 || !bt$2 || !Pt$1}, {sort: function(e20) {
  e20 !== void 0 && Ve$2(e20);
  var t2 = L$2(this);
  if (Pt$1)
    return e20 === void 0 ? xt$2.call(t2) : xt$2.call(t2, e20);
  var s2, r2, i2 = [], a2 = be$2(t2.length);
  for (r2 = 0; r2 < a2; r2++)
    r2 in t2 && i2.push(t2[r2]);
  for (s2 = (i2 = Dt$2(i2, function(e21) {
    return function(t3, s3) {
      return s3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, s3) || 0 : ht$2(t3) > ht$2(s3) ? 1 : -1;
    };
  }(e20))).length, r2 = 0; r2 < s2; )
    t2[r2] = i2[r2++];
  for (; r2 < a2; )
    delete t2[r2++];
  return t2;
}});
var Tt$1 = {}, wt$2 = H$2("iterator"), St$1 = Array.prototype, Bt$1 = {};
Bt$1[H$2("toStringTag")] = "z";
var Nt$1 = String(Bt$1) === "[object z]", It$1 = H$2("toStringTag"), vt$2 = D$2(function() {
  return arguments;
}()) == "Arguments", kt$2 = Nt$1 ? D$2 : function(e20) {
  var t2, s2, r2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (s2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), It$1)) == "string" ? s2 : vt$2 ? D$2(t2) : (r2 = D$2(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
}, Lt$1 = H$2("iterator"), Ot$2 = function(e20) {
  if (e20 != null)
    return e20[Lt$1] || e20["@@iterator"] || Tt$1[kt$2(e20)];
}, Mt$1 = function(e20, t2, s2) {
  var r2, i2;
  Q$2(e20);
  try {
    if ((r2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw s2;
      return s2;
    }
    r2 = r2.call(e20);
  } catch (e21) {
    i2 = true, r2 = e21;
  }
  if (t2 === "throw")
    throw s2;
  if (i2)
    throw r2;
  return Q$2(r2), s2;
}, Rt$1 = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, jt$1 = function(e20, t2, s2) {
  var r2, i2, a2, n2, o2, u2, h2, c2, p2 = s2 && s2.that, l2 = !(!s2 || !s2.AS_ENTRIES), d2 = !(!s2 || !s2.IS_ITERATOR), D2 = !(!s2 || !s2.INTERRUPTED), m2 = ze$2(t2, p2, 1 + l2 + D2), f2 = function(e21) {
    return r2 && Mt$1(r2, "normal", e21), new Rt$1(true, e21);
  }, y2 = function(e21) {
    return l2 ? (Q$2(e21), D2 ? m2(e21[0], e21[1], f2) : m2(e21[0], e21[1])) : D2 ? m2(e21, f2) : m2(e21);
  };
  if (d2)
    r2 = e20;
  else {
    if (typeof (i2 = Ot$2(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((c2 = i2) !== void 0 && (Tt$1.Array === c2 || St$1[wt$2] === c2)) {
      for (a2 = 0, n2 = be$2(e20.length); n2 > a2; a2++)
        if ((o2 = y2(e20[a2])) && o2 instanceof Rt$1)
          return o2;
      return new Rt$1(false);
    }
    r2 = function(e21, t3) {
      var s3 = arguments.length < 2 ? Ot$2(e21) : t3;
      if (typeof s3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return Q$2(s3.call(e21));
    }(e20, i2);
  }
  for (u2 = r2.next; !(h2 = u2.call(r2)).done; ) {
    try {
      o2 = y2(h2.value);
    } catch (e21) {
      Mt$1(r2, "throw", e21);
    }
    if (typeof o2 == "object" && o2 && o2 instanceof Rt$1)
      return o2;
  }
  return new Rt$1(false);
};
$e$2({target: "Object", stat: true}, {fromEntries: function(e20) {
  var t2 = {};
  return jt$1(e20, function(e21, s2) {
    !function(e22, t3, s3) {
      var r2 = W$2(t3);
      r2 in e22 ? ee$2.f(e22, r2, l$2(0, s3)) : e22[r2] = s3;
    }(t2, e21, s2);
  }, {AS_ENTRIES: true}), t2;
}});
var _t$1 = _t$1 !== void 0 ? _t$1 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
function Ut$1() {
  throw new Error("setTimeout has not been defined");
}
function qt$1() {
  throw new Error("clearTimeout has not been defined");
}
var $t$1 = Ut$1, Ht$1 = qt$1;
function Vt$1(e20) {
  if ($t$1 === setTimeout)
    return setTimeout(e20, 0);
  if (($t$1 === Ut$1 || !$t$1) && setTimeout)
    return $t$1 = setTimeout, setTimeout(e20, 0);
  try {
    return $t$1(e20, 0);
  } catch (t2) {
    try {
      return $t$1.call(null, e20, 0);
    } catch (t3) {
      return $t$1.call(this, e20, 0);
    }
  }
}
typeof _t$1.setTimeout == "function" && ($t$1 = setTimeout), typeof _t$1.clearTimeout == "function" && (Ht$1 = clearTimeout);
var zt$1, Wt$1 = [], Gt$1 = false, Kt$1 = -1;
function Xt$1() {
  Gt$1 && zt$1 && (Gt$1 = false, zt$1.length ? Wt$1 = zt$1.concat(Wt$1) : Kt$1 = -1, Wt$1.length && Jt$1());
}
function Jt$1() {
  if (!Gt$1) {
    var e20 = Vt$1(Xt$1);
    Gt$1 = true;
    for (var t2 = Wt$1.length; t2; ) {
      for (zt$1 = Wt$1, Wt$1 = []; ++Kt$1 < t2; )
        zt$1 && zt$1[Kt$1].run();
      Kt$1 = -1, t2 = Wt$1.length;
    }
    zt$1 = null, Gt$1 = false, function(e21) {
      if (Ht$1 === clearTimeout)
        return clearTimeout(e21);
      if ((Ht$1 === qt$1 || !Ht$1) && clearTimeout)
        return Ht$1 = clearTimeout, clearTimeout(e21);
      try {
        Ht$1(e21);
      } catch (t3) {
        try {
          return Ht$1.call(null, e21);
        } catch (t4) {
          return Ht$1.call(this, e21);
        }
      }
    }(e20);
  }
}
function Yt$1(e20, t2) {
  this.fun = e20, this.array = t2;
}
Yt$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function Qt$1() {
}
var Zt$1 = Qt$1, es$1 = Qt$1, ts$1 = Qt$1, ss$1 = Qt$1, rs$1 = Qt$1, is$1 = Qt$1, as$1 = Qt$1;
var ns$1 = _t$1.performance || {}, os$1 = ns$1.now || ns$1.mozNow || ns$1.msNow || ns$1.oNow || ns$1.webkitNow || function() {
  return new Date().getTime();
};
var us$1 = new Date();
var hs$1 = {nextTick: function(e20) {
  var t2 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var s2 = 1; s2 < arguments.length; s2++)
      t2[s2 - 1] = arguments[s2];
  Wt$1.push(new Yt$1(e20, t2)), Wt$1.length !== 1 || Gt$1 || Vt$1(Jt$1);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Zt$1, addListener: es$1, once: ts$1, off: ss$1, removeListener: rs$1, removeAllListeners: is$1, emit: as$1, binding: function(e20) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e20) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e20) {
  var t2 = 1e-3 * os$1.call(ns$1), s2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
  return e20 && (s2 -= e20[0], (r2 -= e20[1]) < 0 && (s2--, r2 += 1e9)), [s2, r2];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (new Date() - us$1) / 1e3;
}};
var cs$1 = typeof hs$1 == "object" && hs$1.env && hs$1.env.NODE_DEBUG && /\bsemver\b/i.test(hs$1.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
};
var ps$1 = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, ls$1 = s$2(function(e20, t2) {
  const {MAX_SAFE_COMPONENT_LENGTH: s2} = ps$1, r2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], a2 = t2.t = {};
  let n2 = 0;
  const o2 = (e21, t3, s3) => {
    const o3 = n2++;
    cs$1(o3, t3), a2[e21] = o3, i2[o3] = t3, r2[o3] = new RegExp(t3, s3 ? "g" : void 0);
  };
  o2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o2("MAINVERSION", `(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})`), o2("MAINVERSIONLOOSE", `(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})`), o2("PRERELEASEIDENTIFIER", `(?:${i2[a2.NUMERICIDENTIFIER]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[a2.NUMERICIDENTIFIERLOOSE]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASE", `(?:-(${i2[a2.PRERELEASEIDENTIFIER]}(?:\\.${i2[a2.PRERELEASEIDENTIFIER]})*))`), o2("PRERELEASELOOSE", `(?:-?(${i2[a2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[a2.PRERELEASEIDENTIFIERLOOSE]})*))`), o2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o2("BUILD", `(?:\\+(${i2[a2.BUILDIDENTIFIER]}(?:\\.${i2[a2.BUILDIDENTIFIER]})*))`), o2("FULLPLAIN", `v?${i2[a2.MAINVERSION]}${i2[a2.PRERELEASE]}?${i2[a2.BUILD]}?`), o2("FULL", `^${i2[a2.FULLPLAIN]}$`), o2("LOOSEPLAIN", `[v=\\s]*${i2[a2.MAINVERSIONLOOSE]}${i2[a2.PRERELEASELOOSE]}?${i2[a2.BUILD]}?`), o2("LOOSE", `^${i2[a2.LOOSEPLAIN]}$`), o2("GTLT", "((?:<|>)?=?)"), o2("XRANGEIDENTIFIERLOOSE", `${i2[a2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), o2("XRANGEIDENTIFIER", `${i2[a2.NUMERICIDENTIFIER]}|x|X|\\*`), o2("XRANGEPLAIN", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:${i2[a2.PRERELEASE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:${i2[a2.PRERELEASELOOSE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAIN]}$`), o2("XRANGELOOSE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COERCE", `(^|[^\\d])(\\d{1,${s2}})(?:\\.(\\d{1,${s2}}))?(?:\\.(\\d{1,${s2}}))?(?:$|[^\\d])`), o2("COERCERTL", i2[a2.COERCE], true), o2("LONETILDE", "(?:~>?)"), o2("TILDETRIM", `(\\s*)${i2[a2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", o2("TILDE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAIN]}$`), o2("TILDELOOSE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("LONECARET", "(?:\\^)"), o2("CARETTRIM", `(\\s*)${i2[a2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", o2("CARET", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAIN]}$`), o2("CARETLOOSE", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COMPARATORLOOSE", `^${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]})$|^$`), o2("COMPARATOR", `^${i2[a2.GTLT]}\\s*(${i2[a2.FULLPLAIN]})$|^$`), o2("COMPARATORTRIM", `(\\s*)${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]}|${i2[a2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", o2("HYPHENRANGE", `^\\s*(${i2[a2.XRANGEPLAIN]})\\s+-\\s+(${i2[a2.XRANGEPLAIN]})\\s*$`), o2("HYPHENRANGELOOSE", `^\\s*(${i2[a2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[a2.XRANGEPLAINLOOSE]})\\s*$`), o2("STAR", "(<|>)?=?\\s*\\*"), o2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const ds$1 = ["includePrerelease", "loose", "rtl"];
var Ds$1 = (e20) => e20 ? typeof e20 != "object" ? {loose: true} : ds$1.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
const ms$1 = /^[0-9]+$/, fs$1 = (e20, t2) => {
  const s2 = ms$1.test(e20), r2 = ms$1.test(t2);
  return s2 && r2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : e20 < t2 ? -1 : 1;
};
var ys$1 = {compareIdentifiers: fs$1, rcompareIdentifiers: (e20, t2) => fs$1(t2, e20)};
const {MAX_LENGTH: As$1, MAX_SAFE_INTEGER: Es$1} = ps$1, {re: Cs$1, t: xs$1} = ls$1, {compareIdentifiers: Fs$1} = ys$1;
class gs$1 {
  constructor(e20, t2) {
    if (t2 = Ds$1(t2), e20 instanceof gs$1) {
      if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
        return e20;
      e20 = e20.version;
    } else if (typeof e20 != "string")
      throw new TypeError(`Invalid Version: ${e20}`);
    if (e20.length > As$1)
      throw new TypeError(`version is longer than ${As$1} characters`);
    cs$1("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
    const s2 = e20.trim().match(t2.loose ? Cs$1[xs$1.LOOSE] : Cs$1[xs$1.FULL]);
    if (!s2)
      throw new TypeError(`Invalid Version: ${e20}`);
    if (this.raw = e20, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > Es$1 || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Es$1 || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Es$1 || this.patch < 0)
      throw new TypeError("Invalid patch version");
    s2[4] ? this.prerelease = s2[4].split(".").map((e21) => {
      if (/^[0-9]+$/.test(e21)) {
        const t3 = +e21;
        if (t3 >= 0 && t3 < Es$1)
          return t3;
      }
      return e21;
    }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e20) {
    if (cs$1("SemVer.compare", this.version, this.options, e20), !(e20 instanceof gs$1)) {
      if (typeof e20 == "string" && e20 === this.version)
        return 0;
      e20 = new gs$1(e20, this.options);
    }
    return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
  }
  compareMain(e20) {
    return e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options)), Fs$1(this.major, e20.major) || Fs$1(this.minor, e20.minor) || Fs$1(this.patch, e20.patch);
  }
  comparePre(e20) {
    if (e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
      return -1;
    if (!this.prerelease.length && e20.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e20.prerelease.length)
      return 0;
    let t2 = 0;
    do {
      const s2 = this.prerelease[t2], r2 = e20.prerelease[t2];
      if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (s2 === void 0)
        return -1;
      if (s2 !== r2)
        return Fs$1(s2, r2);
    } while (++t2);
  }
  compareBuild(e20) {
    e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options));
    let t2 = 0;
    do {
      const s2 = this.build[t2], r2 = e20.build[t2];
      if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (s2 === void 0)
        return -1;
      if (s2 !== r2)
        return Fs$1(s2, r2);
    } while (++t2);
  }
  inc(e20, t2) {
    switch (e20) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let e21 = this.prerelease.length;
          for (; --e21 >= 0; )
            typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
          e21 === -1 && this.prerelease.push(0);
        }
        t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e20}`);
    }
    return this.format(), this.raw = this.version, this;
  }
}
var bs$1 = gs$1;
var Ps$1 = (e20, t2, s2) => new bs$1(e20, s2).compare(new bs$1(t2, s2));
var Ts$1 = (e20, t2, s2) => Ps$1(e20, t2, s2) < 0;
var ws$1 = (e20, t2, s2) => Ps$1(e20, t2, s2) >= 0, Ss$1 = s$2(function(e20, t2) {
  function s2() {
    for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
      e21[t3] = arguments[t3];
  }
  function r2() {
    return typeof WeakMap != "undefined" ? new WeakMap() : {add: s2, delete: s2, get: s2, set: s2, has: function(e21) {
      return false;
    }};
  }
  Object.defineProperty(t2, "__esModule", {value: true}), t2.outdent = void 0;
  var i2 = Object.prototype.hasOwnProperty, a2 = function(e21, t3) {
    return i2.call(e21, t3);
  };
  function n2(e21, t3) {
    for (var s3 in t3)
      a2(t3, s3) && (e21[s3] = t3[s3]);
    return e21;
  }
  var o2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, h2 = /^(?:[\r\n]|$)/, c2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function l2(e21, t3, s3) {
    var r3 = 0, i3 = e21[0].match(c2);
    i3 && (r3 = i3[1].length);
    var a3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
    t3 && (e21 = e21.slice(1));
    var n3 = s3.newline, h3 = s3.trimLeadingNewline, p3 = s3.trimTrailingNewline, l3 = typeof n3 == "string", d3 = e21.length;
    return e21.map(function(e22, t4) {
      return e22 = e22.replace(a3, "$1"), t4 === 0 && h3 && (e22 = e22.replace(o2, "")), t4 === d3 - 1 && p3 && (e22 = e22.replace(u2, "")), l3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
        return n3;
      })), e22;
    });
  }
  function d2(e21, t3) {
    for (var s3 = "", r3 = 0, i3 = e21.length; r3 < i3; r3++)
      s3 += e21[r3], r3 < i3 - 1 && (s3 += t3[r3]);
    return s3;
  }
  function D2(e21) {
    return a2(e21, "raw") && a2(e21, "length");
  }
  var m2 = function e21(t3) {
    var s3 = r2(), i3 = r2();
    return n2(function r3(a3) {
      for (var o3 = [], u3 = 1; u3 < arguments.length; u3++)
        o3[u3 - 1] = arguments[u3];
      if (D2(a3)) {
        var c3 = a3, f2 = (o3[0] === r3 || o3[0] === m2) && p2.test(c3[0]) && h2.test(c3[1]), y2 = f2 ? i3 : s3, A2 = y2.get(c3);
        if (A2 || (A2 = l2(c3, f2, t3), y2.set(c3, A2)), o3.length === 0)
          return A2[0];
        var E2 = d2(A2, f2 ? o3.slice(1) : o3);
        return E2;
      }
      return e21(n2(n2({}, t3), a3 || {}));
    }, {string: function(e22) {
      return l2([e22], false, t3)[0];
    }});
  }({trimLeadingNewline: true, trimTrailingNewline: true});
  t2.outdent = m2, t2.default = m2;
  try {
    e20.exports = m2, Object.defineProperty(m2, "__esModule", {value: true}), m2.default = m2, m2.outdent = m2;
  } catch (e21) {
  }
});
const {outdent: Bs$1} = Ss$1, Ns$1 = {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: Bs$1`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: Bs$1`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e20) => typeof e20 == "string" || typeof e20 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: Bs$1`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Bs$1`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Bs$1`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: Bs$1`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
const Is$1 = ["cliName", "cliCategory", "cliDescription"], vs$1 = {compare: Ps$1, lt: Ts$1, gte: ws$1}, ks$1 = "2.4.1", Ls$1 = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: Ns$1}.options;
var Os$1 = {getSupportInfo: function({plugins: e20 = [], showUnreleased: t2 = false, showDeprecated: s2 = false, showInternal: r2 = false} = {}) {
  const i2 = ks$1.split("-", 1)[0], a2 = e20.flatMap((e21) => e21.languages || []).filter(h2), n2 = (o2 = Object.assign({}, ...e20.map(({options: e21}) => e21), Ls$1), u2 = "name", Object.entries(o2).map(([e21, t3]) => Object.assign({[u2]: e21}, t3))).filter((e21) => h2(e21) && c2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
    if (r2)
      return e21;
    return nt$2(e21, Is$1);
  }).map((t3) => {
    t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(h2).sort((e21, t4) => vs$1.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => h2(e21) && c2(e21)), t3.name === "parser" && function(e21, t4, s4) {
      const r3 = new Set(e21.choices.map((e22) => e22.value));
      for (const i3 of t4)
        if (i3.parsers) {
          for (const t5 of i3.parsers)
            if (!r3.has(t5)) {
              r3.add(t5);
              const a3 = s4.find((e22) => e22.parsers && e22.parsers[t5]);
              let n3 = i3.name;
              a3 && a3.name && (n3 += ` (plugin: ${a3.name})`), e21.choices.push({value: t5, description: n3});
            }
        }
    }(t3, a2, e20));
    const s3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
    return Object.assign(Object.assign({}, t3), {}, {pluginDefaults: s3});
  });
  var o2, u2;
  return {languages: a2, options: n2};
  function h2(e21) {
    return t2 || !("since" in e21) || e21.since && vs$1.gte(i2, e21.since);
  }
  function c2(e21) {
    return s2 || !("deprecated" in e21) || e21.deprecated && vs$1.lt(i2, e21.deprecated);
  }
}};
const {getSupportInfo: Ms$1} = Os$1, Rs$1 = /[^\x20-\x7F]/;
function js$1(e20) {
  return (t2, s2, r2) => {
    const i2 = r2 && r2.backwards;
    if (s2 === false)
      return false;
    const {length: a2} = t2;
    let n2 = s2;
    for (; n2 >= 0 && n2 < a2; ) {
      const s3 = t2.charAt(n2);
      if (e20 instanceof RegExp) {
        if (!e20.test(s3))
          return n2;
      } else if (!e20.includes(s3))
        return n2;
      i2 ? n2-- : n2++;
    }
    return (n2 === -1 || n2 === a2) && n2;
  };
}
const _s$1 = js$1(/\s/), Us$1 = js$1(" 	"), qs$1 = js$1(",; 	"), $s$1 = js$1(/[^\n\r]/);
function Hs$1(e20, t2) {
  if (t2 === false)
    return false;
  if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
    for (let s2 = t2 + 2; s2 < e20.length; ++s2)
      if (e20.charAt(s2) === "*" && e20.charAt(s2 + 1) === "/")
        return s2 + 2;
  }
  return t2;
}
function Vs$1(e20, t2) {
  return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? $s$1(e20, t2) : t2);
}
function zs$1(e20, t2, s2) {
  const r2 = s2 && s2.backwards;
  if (t2 === false)
    return false;
  const i2 = e20.charAt(t2);
  if (r2) {
    if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
      return t2 - 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 - 1;
  } else {
    if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
      return t2 + 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
function Ws$1(e20, t2, s2 = {}) {
  const r2 = Us$1(e20, s2.backwards ? t2 - 1 : t2, s2);
  return r2 !== zs$1(e20, r2, s2);
}
function Gs$1(e20, t2) {
  let s2 = null, r2 = t2;
  for (; r2 !== s2; )
    s2 = r2, r2 = qs$1(e20, r2), r2 = Hs$1(e20, r2), r2 = Us$1(e20, r2);
  return r2 = Vs$1(e20, r2), r2 = zs$1(e20, r2), r2 !== false && Ws$1(e20, r2);
}
function Ks$1(e20, t2) {
  let s2 = null, r2 = t2;
  for (; r2 !== s2; )
    s2 = r2, r2 = Us$1(e20, r2), r2 = Hs$1(e20, r2), r2 = Vs$1(e20, r2), r2 = zs$1(e20, r2);
  return r2;
}
function Xs$1(e20, t2, s2) {
  return Ks$1(e20, s2(t2));
}
function Js$1(e20, t2, s2 = 0) {
  let r2 = 0;
  for (let i2 = s2; i2 < e20.length; ++i2)
    e20[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
  return r2;
}
function Ys$1(e20, t2) {
  const s2 = e20.slice(1, -1), r2 = {quote: '"', regex: /"/g}, i2 = {quote: "'", regex: /'/g}, a2 = t2 === "'" ? i2 : r2, n2 = a2 === i2 ? r2 : i2;
  let o2 = a2.quote;
  if (s2.includes(a2.quote) || s2.includes(n2.quote)) {
    o2 = (s2.match(a2.regex) || []).length > (s2.match(n2.regex) || []).length ? n2.quote : a2.quote;
  }
  return o2;
}
function Qs$1(e20, t2, s2) {
  const r2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, a2) => i3 === r2 ? i3 : a2 === t2 ? "\\" + a2 : a2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
  return t2 + i2 + t2;
}
function Zs$1(e20, t2) {
  (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
    const t3 = e21.type || e21.kind || "(unknown type)";
    let s2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
    s2.length > 20 && (s2 = s2.slice(0, 19) + "\u2026");
    return t3 + (s2 ? " " + s2 : "");
  }(e20);
}
var er$1, tr$1 = {inferParserByLanguage: function(e20, t2) {
  const {languages: s2} = Ms$1({plugins: t2.plugins}), r2 = s2.find(({name: t3}) => t3.toLowerCase() === e20) || s2.find(({aliases: t3}) => Array.isArray(t3) && t3.includes(e20)) || s2.find(({extensions: t3}) => Array.isArray(t3) && t3.includes(`.${e20}`));
  return r2 && r2.parsers[0];
}, getStringWidth: function(e20) {
  return e20 ? Rs$1.test(e20) ? st$2(e20) : e20.length : 0;
}, getMaxContinuousCount: function(e20, t2) {
  const s2 = e20.match(new RegExp(`(${it$2(t2)})+`, "g"));
  return s2 === null ? 0 : s2.reduce((e21, s3) => Math.max(e21, s3.length / t2.length), 0);
}, getMinNotPresentContinuousCount: function(e20, t2) {
  const s2 = e20.match(new RegExp(`(${it$2(t2)})+`, "g"));
  if (s2 === null)
    return 0;
  const r2 = new Map();
  let i2 = 0;
  for (const e21 of s2) {
    const s3 = e21.length / t2.length;
    r2.set(s3, true), s3 > i2 && (i2 = s3);
  }
  for (let e21 = 1; e21 < i2; e21++)
    if (!r2.get(e21))
      return e21;
  return i2 + 1;
}, getPenultimate: (e20) => e20[e20.length - 2], getLast: at$2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ks$1, getNextNonSpaceNonCommentCharacterIndex: Xs$1, getNextNonSpaceNonCommentCharacter: function(e20, t2, s2) {
  return e20.charAt(Xs$1(e20, t2, s2));
}, skip: js$1, skipWhitespace: _s$1, skipSpaces: Us$1, skipToLineEnd: qs$1, skipEverythingButNewLine: $s$1, skipInlineComment: Hs$1, skipTrailingComment: Vs$1, skipNewline: zs$1, isNextLineEmptyAfterIndex: Gs$1, isNextLineEmpty: function(e20, t2, s2) {
  return Gs$1(e20, s2(t2));
}, isPreviousLineEmpty: function(e20, t2, s2) {
  let r2 = s2(t2) - 1;
  return r2 = Us$1(e20, r2, {backwards: true}), r2 = zs$1(e20, r2, {backwards: true}), r2 = Us$1(e20, r2, {backwards: true}), r2 !== zs$1(e20, r2, {backwards: true});
}, hasNewline: Ws$1, hasNewlineInRange: function(e20, t2, s2) {
  for (let r2 = t2; r2 < s2; ++r2)
    if (e20.charAt(r2) === "\n")
      return true;
  return false;
}, hasSpaces: function(e20, t2, s2 = {}) {
  return Us$1(e20, s2.backwards ? t2 - 1 : t2, s2) !== t2;
}, getAlignmentSize: Js$1, getIndentSize: function(e20, t2) {
  const s2 = e20.lastIndexOf("\n");
  return s2 === -1 ? 0 : Js$1(e20.slice(s2 + 1).match(/^[\t ]*/)[0], t2);
}, getPreferredQuote: Ys$1, printString: function(e20, t2) {
  return Qs$1(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Ys$1(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
}, printNumber: function(e20) {
  return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}, makeString: Qs$1, addLeadingComment: function(e20, t2) {
  t2.leading = true, t2.trailing = false, Zs$1(e20, t2);
}, addDanglingComment: function(e20, t2, s2) {
  t2.leading = false, t2.trailing = false, s2 && (t2.marker = s2), Zs$1(e20, t2);
}, addTrailingComment: function(e20, t2) {
  t2.leading = false, t2.trailing = true, Zs$1(e20, t2);
}, isFrontMatterNode: function(e20) {
  return e20 && e20.type === "front-matter";
}, getShebang: function(e20) {
  if (!e20.startsWith("#!"))
    return "";
  const t2 = e20.indexOf("\n");
  return t2 === -1 ? e20 : e20.slice(0, t2);
}, isNonEmptyArray: function(e20) {
  return Array.isArray(e20) && e20.length > 0;
}, createGroupIdMapper: function(e20) {
  const t2 = new WeakMap();
  return function(s2) {
    return t2.has(s2) || t2.set(s2, Symbol(e20)), t2.get(s2);
  };
}};
function sr$1() {
  if (er$1 === void 0) {
    var e20 = new ArrayBuffer(2), t2 = new Uint8Array(e20), s2 = new Uint16Array(e20);
    if (t2[0] = 1, t2[1] = 2, s2[0] === 258)
      er$1 = "BE";
    else {
      if (s2[0] !== 513)
        throw new Error("unable to figure out endianess");
      er$1 = "LE";
    }
  }
  return er$1;
}
function rr$1() {
  return _t$1.location !== void 0 ? _t$1.location.hostname : "";
}
function ir$1() {
  return [];
}
function ar$1() {
  return 0;
}
function nr$1() {
  return Number.MAX_VALUE;
}
function or$1() {
  return Number.MAX_VALUE;
}
function ur$1() {
  return [];
}
function hr$1() {
  return "Browser";
}
function cr$1() {
  return _t$1.navigator !== void 0 ? _t$1.navigator.appVersion : "";
}
function pr$1() {
}
function lr$1() {
}
function dr$1() {
  return "javascript";
}
function Dr$1() {
  return "browser";
}
function mr$1() {
  return "/tmp";
}
var fr$1 = mr$1, yr$1 = {EOL: "\n", arch: dr$1, platform: Dr$1, tmpdir: fr$1, tmpDir: mr$1, networkInterfaces: pr$1, getNetworkInterfaces: lr$1, release: cr$1, type: hr$1, cpus: ur$1, totalmem: or$1, freemem: nr$1, uptime: ar$1, loadavg: ir$1, hostname: rr$1, endianness: sr$1}, Ar$1 = Object.freeze({__proto__: null, endianness: sr$1, hostname: rr$1, loadavg: ir$1, uptime: ar$1, freemem: nr$1, totalmem: or$1, cpus: ur$1, type: hr$1, release: cr$1, networkInterfaces: pr$1, getNetworkInterfaces: lr$1, arch: dr$1, platform: Dr$1, tmpDir: mr$1, tmpdir: fr$1, EOL: "\n", default: yr$1});
const Er$1 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  const t2 = e20.match(/(?:\r?\n)/g) || [];
  if (t2.length === 0)
    return;
  const s2 = t2.filter((e21) => e21 === "\r\n").length;
  return s2 > t2.length - s2 ? "\r\n" : "\n";
};
var Cr$1 = Er$1;
Cr$1.graceful = (e20) => typeof e20 == "string" && Er$1(e20) || "\n";
var xr$1 = t$2(Ar$1), Fr$1 = function(e20) {
  const t2 = e20.match(Ir$1);
  return t2 ? t2[0].trimLeft() : "";
}, gr$1 = function(e20) {
  const t2 = e20.match(Ir$1);
  return t2 && t2[0] ? e20.substring(t2[0].length) : e20;
}, br$1 = function(e20) {
  return jr$1(e20).pragmas;
}, Pr$1 = jr$1, Tr$1 = function({comments: e20 = "", pragmas: t2 = {}}) {
  const s2 = (0, Sr$1().default)(e20) || wr$1().EOL, r2 = " *", i2 = Object.keys(t2), a2 = i2.map((e21) => _r$1(e21, t2[e21])).reduce((e21, t3) => e21.concat(t3), []).map((e21) => " * " + e21 + s2).join("");
  if (!e20) {
    if (i2.length === 0)
      return "";
    if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
      const e21 = t2[i2[0]];
      return `/** ${_r$1(i2[0], e21)[0]} */`;
    }
  }
  const n2 = e20.split(s2).map((e21) => ` * ${e21}`).join(s2) + s2;
  return "/**" + s2 + (e20 ? n2 : "") + (e20 && i2.length ? r2 + s2 : "") + a2 + " */";
};
function wr$1() {
  const e20 = xr$1;
  return wr$1 = function() {
    return e20;
  }, e20;
}
function Sr$1() {
  const e20 = (t2 = Cr$1) && t2.__esModule ? t2 : {default: t2};
  var t2;
  return Sr$1 = function() {
    return e20;
  }, e20;
}
const Br$1 = /\*\/$/, Nr$1 = /^\/\*\*/, Ir$1 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, vr$1 = /(^|\s+)\/\/([^\r\n]*)/g, kr$1 = /^(\r?\n)+/, Lr$1 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Or$1 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Mr$1 = /(\r?\n|^) *\* ?/g, Rr$1 = [];
function jr$1(e20) {
  const t2 = (0, Sr$1().default)(e20) || wr$1().EOL;
  e20 = e20.replace(Nr$1, "").replace(Br$1, "").replace(Mr$1, "$1");
  let s2 = "";
  for (; s2 !== e20; )
    s2 = e20, e20 = e20.replace(Lr$1, `${t2}$1 $2${t2}`);
  e20 = e20.replace(kr$1, "").trimRight();
  const r2 = Object.create(null), i2 = e20.replace(Or$1, "").replace(kr$1, "").trimRight();
  let a2;
  for (; a2 = Or$1.exec(e20); ) {
    const e21 = a2[2].replace(vr$1, "");
    typeof r2[a2[1]] == "string" || Array.isArray(r2[a2[1]]) ? r2[a2[1]] = Rr$1.concat(r2[a2[1]], e21) : r2[a2[1]] = e21;
  }
  return {comments: i2, pragmas: r2};
}
function _r$1(e20, t2) {
  return Rr$1.concat(t2).map((t3) => `@${e20} ${t3}`.trim());
}
var Ur$1 = Object.defineProperty({extract: Fr$1, strip: gr$1, parse: br$1, parseWithComments: Pr$1, print: Tr$1}, "__esModule", {value: true});
var qr$1 = {guessEndOfLine: function(e20) {
  const t2 = e20.indexOf("\r");
  return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
}, convertEndOfLineToChars: function(e20) {
  switch (e20) {
    case "cr":
      return "\r";
    case "crlf":
      return "\r\n";
    default:
      return "\n";
  }
}, countEndOfLineChars: function(e20, t2) {
  let s2;
  if (t2 === "\n")
    s2 = /\n/g;
  else if (t2 === "\r")
    s2 = /\r/g;
  else {
    if (t2 !== "\r\n")
      throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
    s2 = /\r\n/g;
  }
  const r2 = e20.match(s2);
  return r2 ? r2.length : 0;
}, normalizeEndOfLine: function(e20) {
  return e20.replace(/\r\n?/g, "\n");
}};
const {parseWithComments: $r$1, strip: Hr$1, extract: Vr$1, print: zr$1} = Ur$1, {getShebang: Wr$1} = tr$1, {normalizeEndOfLine: Gr$1} = qr$1;
function Kr$1(e20) {
  const t2 = Wr$1(e20);
  t2 && (e20 = e20.slice(t2.length + 1));
  const s2 = Vr$1(e20), {pragmas: r2, comments: i2} = $r$1(s2);
  return {shebang: t2, text: e20, pragmas: r2, comments: i2};
}
var Xr$1 = {hasPragma: function(e20) {
  const t2 = Object.keys(Kr$1(e20).pragmas);
  return t2.includes("prettier") || t2.includes("format");
}, insertPragma: function(e20) {
  const {shebang: t2, text: s2, pragmas: r2, comments: i2} = Kr$1(e20), a2 = Hr$1(s2), n2 = zr$1({pragmas: Object.assign({format: ""}, r2), comments: i2.trimStart()});
  return (t2 ? `${t2}
` : "") + Gr$1(n2) + (a2.startsWith("\n") ? "\n" : "\n\n") + a2;
}};
const {isNonEmptyArray: Jr$1} = tr$1;
function Yr$1(e20, t2) {
  const {ignoreDecorators: s2} = t2 || {};
  if (!s2) {
    const t3 = e20.declaration && e20.declaration.decorators || e20.decorators;
    if (Jr$1(t3))
      return Yr$1(t3[0]);
  }
  return e20.range ? e20.range[0] : e20.start;
}
function Qr$1(e20) {
  return e20.range ? e20.range[1] : e20.end;
}
function Zr$1(e20, t2) {
  return Yr$1(e20) === Yr$1(t2);
}
var ei$1 = {locStart: Yr$1, locEnd: Qr$1, hasSameLocStart: Zr$1, hasSameLoc: function(e20, t2) {
  return Zr$1(e20, t2) && function(e21, t3) {
    return Qr$1(e21) === Qr$1(t3);
  }(e20, t2);
}};
const {hasPragma: ti$1} = Xr$1, {locStart: si$1, locEnd: ri$1} = ei$1;
var ii$1 = function(e20) {
  return e20 = typeof e20 == "function" ? {parse: e20} : e20, Object.assign({astFormat: "estree", hasPragma: ti$1, locStart: si$1, locEnd: ri$1}, e20);
};
var ai$1 = function(e20, t2) {
  const s2 = new SyntaxError(e20 + " (" + t2.start.line + ":" + t2.start.column + ")");
  return s2.loc = t2, s2;
};
var ni$1 = function(e20) {
  const {message: t2, loc: s2} = e20;
  return ai$1(t2.replace(/ \(.*\)/, ""), {start: {line: s2 ? s2.line : 0, column: s2 ? s2.column + 1 : 0}});
}, oi$1 = s$2(function(e20) {
  !function() {
    function t2(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function s2(e21) {
      switch (e21.type) {
        case "IfStatement":
          return e21.alternate != null ? e21.alternate : e21.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return e21.body;
      }
      return null;
    }
    e20.exports = {isExpression: function(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }, isStatement: t2, isIterationStatement: function(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }, isSourceElement: function(e21) {
      return t2(e21) || e21 != null && e21.type === "FunctionDeclaration";
    }, isProblematicIfStatement: function(e21) {
      var t3;
      if (e21.type !== "IfStatement")
        return false;
      if (e21.alternate == null)
        return false;
      t3 = e21.consequent;
      do {
        if (t3.type === "IfStatement" && t3.alternate == null)
          return true;
        t3 = s2(t3);
      } while (t3);
      return false;
    }, trailingStatement: s2};
  }();
}), ui$1 = s$2(function(e20) {
  !function() {
    var t2, s2, r2, i2, a2, n2;
    function o2(e21) {
      return e21 <= 65535 ? String.fromCharCode(e21) : String.fromCharCode(Math.floor((e21 - 65536) / 1024) + 55296) + String.fromCharCode((e21 - 65536) % 1024 + 56320);
    }
    for (s2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/}, t2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/}, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), n2 = 0; n2 < 128; ++n2)
      i2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 === 36 || n2 === 95;
    for (a2 = new Array(128), n2 = 0; n2 < 128; ++n2)
      a2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 >= 48 && n2 <= 57 || n2 === 36 || n2 === 95;
    e20.exports = {isDecimalDigit: function(e21) {
      return 48 <= e21 && e21 <= 57;
    }, isHexDigit: function(e21) {
      return 48 <= e21 && e21 <= 57 || 97 <= e21 && e21 <= 102 || 65 <= e21 && e21 <= 70;
    }, isOctalDigit: function(e21) {
      return e21 >= 48 && e21 <= 55;
    }, isWhiteSpace: function(e21) {
      return e21 === 32 || e21 === 9 || e21 === 11 || e21 === 12 || e21 === 160 || e21 >= 5760 && r2.indexOf(e21) >= 0;
    }, isLineTerminator: function(e21) {
      return e21 === 10 || e21 === 13 || e21 === 8232 || e21 === 8233;
    }, isIdentifierStartES5: function(e21) {
      return e21 < 128 ? i2[e21] : s2.NonAsciiIdentifierStart.test(o2(e21));
    }, isIdentifierPartES5: function(e21) {
      return e21 < 128 ? a2[e21] : s2.NonAsciiIdentifierPart.test(o2(e21));
    }, isIdentifierStartES6: function(e21) {
      return e21 < 128 ? i2[e21] : t2.NonAsciiIdentifierStart.test(o2(e21));
    }, isIdentifierPartES6: function(e21) {
      return e21 < 128 ? a2[e21] : t2.NonAsciiIdentifierPart.test(o2(e21));
    }};
  }();
}), hi$1 = s$2(function(e20) {
  !function() {
    var t2 = ui$1;
    function s2(e21, t3) {
      return !(!t3 && e21 === "yield") && r2(e21, t3);
    }
    function r2(e21, t3) {
      if (t3 && function(e22) {
        switch (e22) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }(e21))
        return true;
      switch (e21.length) {
        case 2:
          return e21 === "if" || e21 === "in" || e21 === "do";
        case 3:
          return e21 === "var" || e21 === "for" || e21 === "new" || e21 === "try";
        case 4:
          return e21 === "this" || e21 === "else" || e21 === "case" || e21 === "void" || e21 === "with" || e21 === "enum";
        case 5:
          return e21 === "while" || e21 === "break" || e21 === "catch" || e21 === "throw" || e21 === "const" || e21 === "yield" || e21 === "class" || e21 === "super";
        case 6:
          return e21 === "return" || e21 === "typeof" || e21 === "delete" || e21 === "switch" || e21 === "export" || e21 === "import";
        case 7:
          return e21 === "default" || e21 === "finally" || e21 === "extends";
        case 8:
          return e21 === "function" || e21 === "continue" || e21 === "debugger";
        case 10:
          return e21 === "instanceof";
        default:
          return false;
      }
    }
    function i2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || s2(e21, t3);
    }
    function a2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || r2(e21, t3);
    }
    function n2(e21) {
      var s3, r3, i3;
      if (e21.length === 0)
        return false;
      if (i3 = e21.charCodeAt(0), !t2.isIdentifierStartES5(i3))
        return false;
      for (s3 = 1, r3 = e21.length; s3 < r3; ++s3)
        if (i3 = e21.charCodeAt(s3), !t2.isIdentifierPartES5(i3))
          return false;
      return true;
    }
    function o2(e21) {
      var s3, r3, i3, a3, n3;
      if (e21.length === 0)
        return false;
      for (n3 = t2.isIdentifierStartES6, s3 = 0, r3 = e21.length; s3 < r3; ++s3) {
        if (55296 <= (i3 = e21.charCodeAt(s3)) && i3 <= 56319) {
          if (++s3 >= r3)
            return false;
          if (!(56320 <= (a3 = e21.charCodeAt(s3)) && a3 <= 57343))
            return false;
          i3 = 1024 * (i3 - 55296) + (a3 - 56320) + 65536;
        }
        if (!n3(i3))
          return false;
        n3 = t2.isIdentifierPartES6;
      }
      return true;
    }
    e20.exports = {isKeywordES5: s2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: a2, isRestrictedWord: function(e21) {
      return e21 === "eval" || e21 === "arguments";
    }, isIdentifierNameES5: n2, isIdentifierNameES6: o2, isIdentifierES5: function(e21, t3) {
      return n2(e21) && !i2(e21, t3);
    }, isIdentifierES6: function(e21, t3) {
      return o2(e21) && !a2(e21, t3);
    }};
  }();
});
const ci$1 = s$2(function(e20, t2) {
  t2.ast = oi$1, t2.code = ui$1, t2.keyword = hi$1;
}).keyword.isIdentifierNameES5, {getLast: pi$1, hasNewline: li$1, skipWhitespace: di$1, isNonEmptyArray: Di$1, isNextLineEmptyAfterIndex: mi$1, getStringWidth: fi$1} = tr$1, {locStart: yi$1, locEnd: Ai$1, hasSameLocStart: Ei$1} = ei$1, Ci$1 = new RegExp("^(?:(?=.)\\s)*:"), xi$1 = new RegExp("^(?:(?=.)\\s)*::");
function Fi$1(e20) {
  return e20.type === "Block" || e20.type === "CommentBlock" || e20.type === "MultiLine";
}
function gi$1(e20) {
  return e20.type === "Line" || e20.type === "CommentLine" || e20.type === "SingleLine" || e20.type === "HashbangComment" || e20.type === "HTMLOpen" || e20.type === "HTMLClose";
}
const bi$1 = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
function Pi$1(e20) {
  return e20 && bi$1.has(e20.type);
}
function Ti$1(e20) {
  return e20.type === "NumericLiteral" || e20.type === "Literal" && typeof e20.value == "number";
}
function wi$1(e20) {
  return e20.type === "StringLiteral" || e20.type === "Literal" && typeof e20.value == "string";
}
function Si$1(e20) {
  return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression";
}
function Bi$1(e20) {
  return Mi$1(e20) && e20.callee.type === "Identifier" && (e20.callee.name === "async" || e20.callee.name === "inject" || e20.callee.name === "fakeAsync");
}
function Ni$1(e20) {
  return e20.type === "JSXElement" || e20.type === "JSXFragment";
}
function Ii$1(e20) {
  return e20.kind === "get" || e20.kind === "set";
}
function vi$1(e20) {
  return Ii$1(e20) || Ei$1(e20, e20.value);
}
const ki$1 = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
const Li$1 = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
const Oi$1 = /^(?:skip|[fx]?(?:it|describe|test))$/;
function Mi$1(e20) {
  return e20 && (e20.type === "CallExpression" || e20.type === "OptionalCallExpression");
}
function Ri$1(e20) {
  return e20 && (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression");
}
function ji$1(e20) {
  return /^(?:\d+|\d+\.\d+)$/.test(e20);
}
function _i$1(e20) {
  return e20.quasis.some((e21) => e21.value.raw.includes("\n"));
}
function Ui$1(e20) {
  return e20.extra ? e20.extra.raw : e20.raw;
}
const qi$1 = {"==": true, "!=": true, "===": true, "!==": true}, $i$1 = {"*": true, "/": true, "%": true}, Hi$1 = {">>": true, ">>>": true, "<<": true};
const Vi$1 = {};
for (const [e20, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
  for (const s2 of t2)
    Vi$1[s2] = e20;
function zi$1(e20) {
  return Vi$1[e20];
}
const Wi$1 = new WeakMap();
function Gi$1(e20) {
  if (Wi$1.has(e20))
    return Wi$1.get(e20);
  const t2 = [];
  return e20.this && t2.push(e20.this), Array.isArray(e20.parameters) ? t2.push(...e20.parameters) : Array.isArray(e20.params) && t2.push(...e20.params), e20.rest && t2.push(e20.rest), Wi$1.set(e20, t2), t2;
}
const Ki$1 = new WeakMap();
function Xi$1(e20) {
  if (Ki$1.has(e20))
    return Ki$1.get(e20);
  let t2 = e20.arguments;
  return e20.type === "ImportExpression" && (t2 = [e20.source], e20.attributes && t2.push(e20.attributes)), Ki$1.set(e20, t2), t2;
}
function Ji$1(e20) {
  return e20.value.trim() === "prettier-ignore" && !e20.unignore;
}
function Yi$1(e20) {
  return e20 && (e20.prettierIgnore || ea(e20, Qi$1.PrettierIgnore));
}
const Qi$1 = {Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256}, Zi$1 = (e20, t2) => {
  if (typeof e20 == "function" && (t2 = e20, e20 = 0), e20 || t2)
    return (s2, r2, i2) => !(e20 & Qi$1.Leading && !s2.leading || e20 & Qi$1.Trailing && !s2.trailing || e20 & Qi$1.Dangling && (s2.leading || s2.trailing) || e20 & Qi$1.Block && !Fi$1(s2) || e20 & Qi$1.Line && !gi$1(s2) || e20 & Qi$1.First && r2 !== 0 || e20 & Qi$1.Last && r2 !== i2.length - 1 || e20 & Qi$1.PrettierIgnore && !Ji$1(s2) || t2 && !t2(s2));
};
function ea(e20, t2, s2) {
  if (!e20 || !Di$1(e20.comments))
    return false;
  const r2 = Zi$1(t2, s2);
  return !r2 || e20.comments.some(r2);
}
function ta(e20, t2, s2) {
  if (!e20 || !Array.isArray(e20.comments))
    return [];
  const r2 = Zi$1(t2, s2);
  return r2 ? e20.comments.filter(r2) : e20.comments;
}
function sa(e20) {
  return Mi$1(e20) || e20.type === "NewExpression" || e20.type === "ImportExpression";
}
var ra = {getFunctionParameters: Gi$1, iterateFunctionParametersPath: function(e20, t2) {
  const s2 = e20.getValue();
  let r2 = 0;
  const i2 = (e21) => t2(e21, r2++);
  s2.this && e20.call(i2, "this"), Array.isArray(s2.parameters) ? e20.each(i2, "parameters") : Array.isArray(s2.params) && e20.each(i2, "params"), s2.rest && e20.call(i2, "rest");
}, getCallArguments: Xi$1, iterateCallArgumentsPath: function(e20, t2) {
  const s2 = e20.getValue();
  s2.type === "ImportExpression" ? (e20.call((e21) => t2(e21, 0), "source"), s2.attributes && e20.call((e21) => t2(e21, 1), "attributes")) : e20.each(t2, "arguments");
}, hasRestParameter: function(e20) {
  if (e20.rest)
    return true;
  const t2 = Gi$1(e20);
  return t2.length > 0 && pi$1(t2).type === "RestElement";
}, getLeftSide: function(e20) {
  return e20.expressions ? e20.expressions[0] : e20.left || e20.test || e20.callee || e20.object || e20.tag || e20.argument || e20.expression;
}, getLeftSidePathName: function(e20, t2) {
  if (t2.expressions)
    return ["expressions", 0];
  if (t2.left)
    return ["left"];
  if (t2.test)
    return ["test"];
  if (t2.object)
    return ["object"];
  if (t2.callee)
    return ["callee"];
  if (t2.tag)
    return ["tag"];
  if (t2.argument)
    return ["argument"];
  if (t2.expression)
    return ["expression"];
  throw new Error("Unexpected node has no left side.");
}, getParentExportDeclaration: function(e20) {
  const t2 = e20.getParentNode();
  return e20.getName() === "declaration" && Pi$1(t2) ? t2 : null;
}, getTypeScriptMappedTypeModifier: function(e20, t2) {
  return e20 === "+" ? "+" + t2 : e20 === "-" ? "-" + t2 : t2;
}, hasFlowAnnotationComment: function(e20) {
  return Di$1(e20) && Fi$1(e20[0]) && xi$1.test(e20[0].value);
}, hasFlowShorthandAnnotationComment: function(e20) {
  return e20.extra && e20.extra.parenthesized && Di$1(e20.trailingComments) && Fi$1(e20.trailingComments[0]) && Ci$1.test(e20.trailingComments[0].value);
}, hasLeadingOwnLineComment: function(e20, t2) {
  return Ni$1(t2) ? Yi$1(t2) : ea(t2, Qi$1.Leading, (t3) => li$1(e20, Ai$1(t3)));
}, hasNakedLeftSide: function(e20) {
  return e20.type === "AssignmentExpression" || e20.type === "BinaryExpression" || e20.type === "LogicalExpression" || e20.type === "NGPipeExpression" || e20.type === "ConditionalExpression" || Mi$1(e20) || Ri$1(e20) || e20.type === "SequenceExpression" || e20.type === "TaggedTemplateExpression" || e20.type === "BindExpression" || e20.type === "UpdateExpression" && !e20.prefix || e20.type === "TSAsExpression" || e20.type === "TSNonNullExpression";
}, hasNode: function e13(t2, s2) {
  if (!t2 || typeof t2 != "object")
    return false;
  if (Array.isArray(t2))
    return t2.some((t3) => e13(t3, s2));
  const r2 = s2(t2);
  return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e13(t3, s2));
}, hasIgnoreComment: function(e20) {
  return Yi$1(e20.getValue());
}, hasNodeIgnoreComment: Yi$1, identity: function(e20) {
  return e20;
}, isBinaryish: function(e20) {
  return ki$1.has(e20.type);
}, isBlockComment: Fi$1, isCallLikeExpression: sa, isLineComment: gi$1, isPrettierIgnoreComment: Ji$1, isCallExpression: Mi$1, isMemberExpression: Ri$1, isExportDeclaration: Pi$1, isFlowAnnotationComment: function(e20, t2) {
  const s2 = yi$1(t2), r2 = di$1(e20, Ai$1(t2));
  return r2 !== false && e20.slice(s2, s2 + 2) === "/*" && e20.slice(r2, r2 + 2) === "*/";
}, isFunctionCompositionArgs: function(e20) {
  if (e20.length <= 1)
    return false;
  let t2 = 0;
  for (const s2 of e20)
    if (Si$1(s2)) {
      if (t2 += 1, t2 > 1)
        return true;
    } else if (Mi$1(s2)) {
      for (const e21 of s2.arguments)
        if (Si$1(e21))
          return true;
    }
  return false;
}, isFunctionNotation: vi$1, isFunctionOrArrowExpression: Si$1, isGetterOrSetter: Ii$1, isJestEachTemplateLiteral: function(e20, t2) {
  const s2 = /^[fx]?(?:describe|it|test)$/;
  return t2.type === "TaggedTemplateExpression" && t2.quasi === e20 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && s2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && s2.test(t2.tag.object.object.name));
}, isJsxNode: Ni$1, isLiteral: function(e20) {
  return e20.type === "BooleanLiteral" || e20.type === "DirectiveLiteral" || e20.type === "Literal" || e20.type === "NullLiteral" || e20.type === "NumericLiteral" || e20.type === "BigIntLiteral" || e20.type === "DecimalLiteral" || e20.type === "RegExpLiteral" || e20.type === "StringLiteral" || e20.type === "TemplateLiteral" || e20.type === "TSTypeLiteral" || e20.type === "JSXText";
}, isLongCurriedCallExpression: function(e20) {
  const t2 = e20.getValue(), s2 = e20.getParentNode();
  return Mi$1(t2) && Mi$1(s2) && s2.callee === t2 && t2.arguments.length > s2.arguments.length && s2.arguments.length > 0;
}, isSimpleCallArgument: function e14(t2, s2) {
  if (s2 >= 2)
    return false;
  const r2 = (t3) => e14(t3, s2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
  return !(i2 && fi$1(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e20) => !e20.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e20) => !e20.computed && (e20.shorthand || e20.value && r2(e20.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e20) => e20 === null || r2(e20)) : sa(t2) ? (t2.type === "ImportExpression" || e14(t2.callee, s2)) && Xi$1(t2).every(r2) : Ri$1(t2) ? e14(t2.object, s2) && e14(t2.property, s2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e14(t2.expression, s2) : e14(t2.argument, s2)));
}, isMemberish: function(e20) {
  return Ri$1(e20) || e20.type === "BindExpression" && Boolean(e20.object);
}, isNumericLiteral: Ti$1, isSignedNumericLiteral: function(e20) {
  return e20.type === "UnaryExpression" && (e20.operator === "+" || e20.operator === "-") && Ti$1(e20.argument);
}, isObjectProperty: function(e20) {
  return e20 && (e20.type === "ObjectProperty" || e20.type === "Property" && !e20.method && e20.kind === "init");
}, isObjectType: function(e20) {
  return e20.type === "ObjectTypeAnnotation" || e20.type === "TSTypeLiteral" || e20.type === "TSMappedType";
}, isObjectTypePropertyAFunction: function(e20) {
  return !(e20.type !== "ObjectTypeProperty" && e20.type !== "ObjectTypeInternalSlot" || e20.value.type !== "FunctionTypeAnnotation" || e20.static || vi$1(e20));
}, isSimpleType: function(e20) {
  return !!e20 && (!(e20.type !== "GenericTypeAnnotation" && e20.type !== "TSTypeReference" || e20.typeParameters) || !!Li$1.has(e20.type));
}, isSimpleNumber: ji$1, isSimpleTemplateLiteral: function(e20) {
  let t2 = "expressions";
  e20.type === "TSTemplateLiteralType" && (t2 = "types");
  const s2 = e20[t2];
  return s2.length !== 0 && s2.every((e21) => {
    if (ea(e21))
      return false;
    if (e21.type === "Identifier" || e21.type === "ThisExpression")
      return true;
    if (Ri$1(e21)) {
      let t3 = e21;
      for (; Ri$1(t3); ) {
        if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
          return false;
        if (t3 = t3.object, ea(t3))
          return false;
      }
      return t3.type === "Identifier" || t3.type === "ThisExpression";
    }
    return false;
  });
}, isStringLiteral: wi$1, isStringPropSafeToUnquote: function(e20, t2) {
  return t2.parser !== "json" && wi$1(e20.key) && Ui$1(e20.key).slice(1, -1) === e20.key.value && (ci$1(e20.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e20.type === "ClassProperty") || ji$1(e20.key.value) && String(Number(e20.key.value)) === e20.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
}, isTemplateOnItsOwnLine: function(e20, t2) {
  return (e20.type === "TemplateLiteral" && _i$1(e20) || e20.type === "TaggedTemplateExpression" && _i$1(e20.quasi)) && !li$1(t2, yi$1(e20), {backwards: true});
}, isTestCall: function e15(t2, s2) {
  if (t2.type !== "CallExpression")
    return false;
  if (t2.arguments.length === 1) {
    if (Bi$1(t2) && s2 && e15(s2))
      return Si$1(t2.arguments[0]);
    if (function(e20) {
      return e20.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e20.callee.name) && e20.arguments.length === 1;
    }(t2))
      return Bi$1(t2.arguments[0]);
  } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Oi$1.test(t2.callee.name) || function(e20) {
    return Ri$1(e20.callee) && e20.callee.object.type === "Identifier" && e20.callee.property.type === "Identifier" && Oi$1.test(e20.callee.object.name) && (e20.callee.property.name === "only" || e20.callee.property.name === "skip");
  }(t2)) && (function(e20) {
    return e20.type === "TemplateLiteral";
  }(t2.arguments[0]) || wi$1(t2.arguments[0])))
    return !(t2.arguments[2] && !Ti$1(t2.arguments[2])) && ((t2.arguments.length === 2 ? Si$1(t2.arguments[1]) : function(e20) {
      return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && e20.body.type === "BlockStatement";
    }(t2.arguments[1]) && Gi$1(t2.arguments[1]).length <= 1) || Bi$1(t2.arguments[1]));
  return false;
}, isTheOnlyJsxElementInMarkdown: function(e20, t2) {
  if (e20.parentParser !== "markdown" && e20.parentParser !== "mdx")
    return false;
  const s2 = t2.getNode();
  if (!s2.expression || !Ni$1(s2.expression))
    return false;
  const r2 = t2.getParentNode();
  return r2.type === "Program" && r2.body.length === 1;
}, isTSXFile: function(e20) {
  return e20.filepath && /\.tsx$/i.test(e20.filepath);
}, isTypeAnnotationAFunction: function(e20) {
  return !(e20.type !== "TypeAnnotation" && e20.type !== "TSTypeAnnotation" || e20.typeAnnotation.type !== "FunctionTypeAnnotation" || e20.static || Ei$1(e20, e20.typeAnnotation));
}, isNextLineEmpty: (e20, {originalText: t2}) => mi$1(t2, Ai$1(e20)), needsHardlineAfterDanglingComment: function(e20) {
  if (!ea(e20))
    return false;
  const t2 = pi$1(ta(e20, Qi$1.Dangling));
  return t2 && !Fi$1(t2);
}, rawText: Ui$1, shouldPrintComma: function(e20, t2 = "es5") {
  return e20.trailingComma === "es5" && t2 === "es5" || e20.trailingComma === "all" && (t2 === "all" || t2 === "es5");
}, isBitwiseOperator: function(e20) {
  return Boolean(Hi$1[e20]) || e20 === "|" || e20 === "^" || e20 === "&";
}, shouldFlatten: function(e20, t2) {
  return zi$1(t2) === zi$1(e20) && (e20 !== "**" && ((!qi$1[e20] || !qi$1[t2]) && (!(t2 === "%" && $i$1[e20] || e20 === "%" && $i$1[t2]) && ((t2 === e20 || !$i$1[t2] || !$i$1[e20]) && (!Hi$1[e20] || !Hi$1[t2])))));
}, startsWithNoLookaheadToken: function e16(t2, s2) {
  switch ((t2 = function(e20) {
    for (; e20.left; )
      e20 = e20.left;
    return e20;
  }(t2)).type) {
    case "FunctionExpression":
    case "ClassExpression":
    case "DoExpression":
      return s2;
    case "ObjectExpression":
      return true;
    case "MemberExpression":
    case "OptionalMemberExpression":
      return e16(t2.object, s2);
    case "TaggedTemplateExpression":
      return t2.tag.type !== "FunctionExpression" && e16(t2.tag, s2);
    case "CallExpression":
    case "OptionalCallExpression":
      return t2.callee.type !== "FunctionExpression" && e16(t2.callee, s2);
    case "ConditionalExpression":
      return e16(t2.test, s2);
    case "UpdateExpression":
      return !t2.prefix && e16(t2.argument, s2);
    case "BindExpression":
      return t2.object && e16(t2.object, s2);
    case "SequenceExpression":
      return e16(t2.expressions[0], s2);
    case "TSAsExpression":
    case "TSNonNullExpression":
      return e16(t2.expression, s2);
    default:
      return false;
  }
}, getPrecedence: zi$1, hasComment: ea, getComments: ta, CommentCheckFlags: Qi$1};
const {getLast: ia, hasNewline: aa, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: na, getNextNonSpaceNonCommentCharacter: oa, hasNewlineInRange: ua, addLeadingComment: ha, addTrailingComment: ca, addDanglingComment: pa, getNextNonSpaceNonCommentCharacterIndex: la, isNonEmptyArray: da} = tr$1, {isBlockComment: Da, getFunctionParameters: ma, isPrettierIgnoreComment: fa, isJsxNode: ya, hasFlowShorthandAnnotationComment: Aa, hasFlowAnnotationComment: Ea, hasIgnoreComment: Ca, isCallLikeExpression: xa, getCallArguments: Fa, isCallExpression: ga, isMemberExpression: ba, isObjectProperty: Pa, getComments: Ta, CommentCheckFlags: wa} = ra, {locStart: Sa, locEnd: Ba} = ei$1;
function Na(e20, t2) {
  const s2 = (e20.body || e20.properties).find(({type: e21}) => e21 !== "EmptyStatement");
  s2 ? ha(s2, t2) : pa(e20, t2);
}
function Ia(e20, t2) {
  e20.type === "BlockStatement" ? Na(e20, t2) : ha(e20, t2);
}
function va({comment: e20, followingNode: t2}) {
  return !(!t2 || !un$1(e20)) && (ha(t2, e20), true);
}
function ka({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
  if (!s2 || s2.type !== "IfStatement" || !r2)
    return false;
  return oa(i2, e20, Ba) === ")" ? (ca(t2, e20), true) : t2 === s2.consequent && r2 === s2.alternate ? (t2.type === "BlockStatement" ? ca(t2, e20) : pa(s2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : r2.type === "IfStatement" ? (Ia(r2.consequent, e20), true) : s2.consequent === r2 && (ha(r2, e20), true);
}
function La({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
  if (!s2 || s2.type !== "WhileStatement" || !r2)
    return false;
  return oa(i2, e20, Ba) === ")" ? (ca(t2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : s2.body === r2 && (ha(r2, e20), true);
}
function Oa({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
  return !(!s2 || s2.type !== "TryStatement" && s2.type !== "CatchClause" || !r2) && (s2.type === "CatchClause" && t2 ? (ca(t2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : r2.type === "TryStatement" ? (Ia(r2.finalizer, e20), true) : r2.type === "CatchClause" && (Ia(r2.body, e20), true));
}
function Ma({comment: e20, enclosingNode: t2, followingNode: s2}) {
  return !(!ba(t2) || !s2 || s2.type !== "Identifier") && (ha(t2, e20), true);
}
function Ra({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
  const a2 = t2 && !ua(i2, Ba(t2), Sa(e20));
  return !(t2 && a2 || !s2 || s2.type !== "ConditionalExpression" && s2.type !== "TSConditionalType" || !r2) && (ha(r2, e20), true);
}
function ja({comment: e20, precedingNode: t2, enclosingNode: s2}) {
  return !(!Pa(s2) || !s2.shorthand || s2.key !== t2 || s2.value.type !== "AssignmentPattern") && (ca(s2.value.left, e20), true);
}
function _a({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
  if (s2 && (s2.type === "ClassDeclaration" || s2.type === "ClassExpression" || s2.type === "DeclareClass" || s2.type === "DeclareInterface" || s2.type === "InterfaceDeclaration" || s2.type === "TSInterfaceDeclaration")) {
    if (da(s2.decorators) && (!r2 || r2.type !== "Decorator"))
      return ca(ia(s2.decorators), e20), true;
    if (s2.body && r2 === s2.body)
      return Na(s2.body, e20), true;
    if (r2) {
      for (const i2 of ["implements", "extends", "mixins"])
        if (s2[i2] && r2 === s2[i2][0])
          return !t2 || t2 !== s2.id && t2 !== s2.typeParameters && t2 !== s2.superClass ? pa(s2, e20, i2) : ca(t2, e20), true;
    }
  }
  return false;
}
function Ua({comment: e20, precedingNode: t2, enclosingNode: s2, text: r2}) {
  return (s2 && t2 && (s2.type === "Property" || s2.type === "TSDeclareMethod" || s2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && s2.key === t2 && oa(r2, t2, Ba) !== ":" || !(!t2 || !s2 || t2.type !== "Decorator" || s2.type !== "ClassMethod" && s2.type !== "ClassProperty" && s2.type !== "PropertyDefinition" && s2.type !== "TSAbstractClassProperty" && s2.type !== "TSAbstractMethodDefinition" && s2.type !== "TSDeclareMethod" && s2.type !== "MethodDefinition")) && (ca(t2, e20), true);
}
function qa({comment: e20, precedingNode: t2, enclosingNode: s2, text: r2}) {
  return oa(r2, e20, Ba) === "(" && (!(!t2 || !s2 || s2.type !== "FunctionDeclaration" && s2.type !== "FunctionExpression" && s2.type !== "ClassMethod" && s2.type !== "MethodDefinition" && s2.type !== "ObjectMethod") && (ca(t2, e20), true));
}
function $a({comment: e20, enclosingNode: t2, text: s2}) {
  if (!t2 || t2.type !== "ArrowFunctionExpression")
    return false;
  const r2 = la(s2, e20, Ba);
  return r2 !== false && s2.slice(r2, r2 + 2) === "=>" && (pa(t2, e20), true);
}
function Ha({comment: e20, enclosingNode: t2, text: s2}) {
  return oa(s2, e20, Ba) === ")" && (t2 && (on$1(t2) && ma(t2).length === 0 || xa(t2) && Fa(t2).length === 0) ? (pa(t2, e20), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || ma(t2.value).length !== 0) && (pa(t2.value, e20), true));
}
function Va({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
  if (t2 && t2.type === "FunctionTypeParam" && s2 && s2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
    return ca(t2, e20), true;
  if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && s2 && on$1(s2) && oa(i2, e20, Ba) === ")")
    return ca(t2, e20), true;
  if (s2 && s2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
    const t3 = (() => {
      const e21 = ma(s2);
      if (e21.length > 0)
        return na(i2, Ba(ia(e21)));
      const t4 = na(i2, Ba(s2.id));
      return t4 !== false && na(i2, t4 + 1);
    })();
    if (Sa(e20) > t3)
      return Na(r2, e20), true;
  }
  return false;
}
function za({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "ImportSpecifier") && (ha(t2, e20), true);
}
function Wa({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "LabeledStatement") && (ha(t2, e20), true);
}
function Ga({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (ca(t2, e20), true);
}
function Ka({comment: e20, precedingNode: t2, enclosingNode: s2}) {
  return !!(ga(s2) && t2 && s2.callee === t2 && s2.arguments.length > 0) && (ha(s2.arguments[0], e20), true);
}
function Xa({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
  return !s2 || s2.type !== "UnionTypeAnnotation" && s2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && fa(e20) && (r2.types[0].prettierIgnore = true, e20.unignore = true), false) : (fa(e20) && (r2.prettierIgnore = true, e20.unignore = true), !!t2 && (ca(t2, e20), true));
}
function Ja({comment: e20, enclosingNode: t2}) {
  return !!Pa(t2) && (ha(t2, e20), true);
}
function Ya({comment: e20, enclosingNode: t2, followingNode: s2, ast: r2, isLastComment: i2}) {
  return r2 && r2.body && r2.body.length === 0 ? (i2 ? pa(r2, e20) : ha(r2, e20), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !da(t2.directives) ? (i2 ? pa(t2, e20) : ha(t2, e20), true) : !(!s2 || s2.type !== "Program" || s2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (pa(s2, e20), true);
}
function Qa({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (ha(t2, e20), true);
}
function Za({comment: e20, precedingNode: t2, enclosingNode: s2, text: r2}) {
  return !!(t2 && t2.type === "ImportSpecifier" && s2 && s2.type === "ImportDeclaration" && aa(r2, Ba(e20))) && (ca(t2, e20), true);
}
function en$1({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "AssignmentPattern") && (ha(t2, e20), true);
}
function tn$1({comment: e20, enclosingNode: t2}) {
  return !(!t2 || t2.type !== "TypeAlias") && (ha(t2, e20), true);
}
function sn$1({comment: e20, enclosingNode: t2, followingNode: s2}) {
  return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !s2 || s2.type !== "ObjectExpression" && s2.type !== "ArrayExpression" && s2.type !== "TemplateLiteral" && s2.type !== "TaggedTemplateExpression" && !Da(e20)) && (ha(s2, e20), true);
}
function rn$1({comment: e20, enclosingNode: t2, followingNode: s2, text: r2}) {
  return !(s2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || oa(r2, e20, Ba) !== ";") && (ca(t2, e20), true);
}
function an$1({comment: e20, enclosingNode: t2, followingNode: s2}) {
  if (fa(e20) && t2 && t2.type === "TSMappedType" && s2 && s2.type === "TSTypeParameter" && s2.constraint)
    return t2.prettierIgnore = true, e20.unignore = true, true;
}
function nn$1({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
  return !(!s2 || s2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (ha(r2.name, e20), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (ca(t2.constraint, e20), true));
}
function on$1(e20) {
  return e20.type === "ArrowFunctionExpression" || e20.type === "FunctionExpression" || e20.type === "FunctionDeclaration" || e20.type === "ObjectMethod" || e20.type === "ClassMethod" || e20.type === "TSDeclareFunction" || e20.type === "TSCallSignatureDeclaration" || e20.type === "TSConstructSignatureDeclaration" || e20.type === "TSMethodSignature" || e20.type === "TSConstructorType" || e20.type === "TSFunctionType" || e20.type === "TSDeclareMethod";
}
function un$1(e20) {
  return Da(e20) && e20.value[0] === "*" && /@type\b/.test(e20.value);
}
var hn$1 = {handleOwnLineComment: function(e20) {
  return [an$1, Va, Ma, ka, La, Oa, _a, za, Qa, Xa, Ya, Za, en$1, Ua, Wa].some((t2) => t2(e20));
}, handleEndOfLineComment: function(e20) {
  return [va, Va, Ra, za, ka, La, Oa, _a, Wa, Ka, Ja, Ya, tn$1, sn$1].some((t2) => t2(e20));
}, handleRemainingComment: function(e20) {
  return [an$1, ka, La, ja, Ha, Ua, Ya, $a, qa, nn$1, Ga, rn$1].some((t2) => t2(e20));
}, isTypeCastComment: un$1, getCommentChildNodes: function(e20, t2) {
  if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e20.type === "MethodDefinition" && e20.value && e20.value.type === "FunctionExpression" && ma(e20.value).length === 0 && !e20.value.returnType && !da(e20.value.typeParameters) && e20.value.body)
    return [...e20.decorators || [], e20.key, e20.value.body];
}, willPrintOwnComments: function(e20) {
  const t2 = e20.getValue(), s2 = e20.getParentNode();
  return (t2 && (ya(t2) || Aa(t2) || ga(s2) && ((e21) => Ea(Ta(e21, wa.Leading)) || Ea(Ta(e21, wa.Trailing)))(t2)) || s2 && (s2.type === "JSXSpreadAttribute" || s2.type === "JSXSpreadChild" || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType" || (s2.type === "ClassDeclaration" || s2.type === "ClassExpression") && s2.superClass === t2)) && (!Ca(e20) || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType");
}};
const {getLast: cn$1, getNextNonSpaceNonCommentCharacter: pn$1} = tr$1, {locStart: ln$1, locEnd: dn$1} = ei$1, {isTypeCastComment: Dn$1} = hn$1;
function mn$1(e20) {
  return e20.type === "CallExpression" ? (e20.type = "OptionalCallExpression", e20.callee = mn$1(e20.callee)) : e20.type === "MemberExpression" ? (e20.type = "OptionalMemberExpression", e20.object = mn$1(e20.object)) : e20.type === "TSNonNullExpression" && (e20.expression = mn$1(e20.expression)), e20;
}
function fn$1(e20, t2) {
  let s2;
  if (Array.isArray(e20))
    s2 = e20.entries();
  else {
    if (!e20 || typeof e20 != "object" || typeof e20.type != "string")
      return e20;
    s2 = Object.entries(e20);
  }
  for (const [r2, i2] of s2)
    e20[r2] = fn$1(i2, t2);
  return Array.isArray(e20) ? e20 : t2(e20) || e20;
}
function yn$1(e20) {
  return e20.type === "LogicalExpression" && e20.right.type === "LogicalExpression" && e20.operator === e20.right.operator;
}
function An$1(e20) {
  return yn$1(e20) ? An$1({type: "LogicalExpression", operator: e20.operator, left: An$1({type: "LogicalExpression", operator: e20.operator, left: e20.left, right: e20.right.left, range: [ln$1(e20.left), dn$1(e20.right.left)]}), right: e20.right.right, range: [ln$1(e20), dn$1(e20)]}) : e20;
}
var En$1 = function(e20, t2) {
  if (t2.parser === "typescript" && t2.originalText.includes("@")) {
    const {esTreeNodeToTSNodeMap: s2, tsNodeToESTreeNodeMap: r2} = t2.tsParseResult;
    e20 = fn$1(e20, (e21) => {
      const t3 = s2.get(e21);
      if (!t3)
        return;
      const i2 = t3.decorators;
      if (!Array.isArray(i2))
        return;
      const a2 = r2.get(t3);
      if (a2 !== e21)
        return;
      const n2 = a2.decorators;
      if (!Array.isArray(n2) || n2.length !== i2.length || i2.some((e22) => {
        const t4 = r2.get(e22);
        return !t4 || !n2.includes(t4);
      })) {
        const {start: e22, end: t4} = a2.loc;
        throw ai$1("Leading decorators must be attached to a class declaration", {start: {line: e22.line, column: e22.column + 1}, end: {line: t4.line, column: t4.column + 1}});
      }
    });
  }
  if (t2.parser !== "typescript" && t2.parser !== "flow" && t2.parser !== "espree" && t2.parser !== "meriyah") {
    const t3 = new Set();
    e20 = fn$1(e20, (e21) => {
      e21.leadingComments && e21.leadingComments.some(Dn$1) && t3.add(ln$1(e21));
    }), e20 = fn$1(e20, (e21) => {
      if (e21.type === "ParenthesizedExpression") {
        const {expression: s2} = e21;
        if (s2.type === "TypeCastExpression")
          return s2.range = e21.range, s2;
        const r2 = ln$1(e21);
        if (!t3.has(r2))
          return s2.extra = Object.assign(Object.assign({}, s2.extra), {}, {parenthesized: true}), s2;
      }
    });
  }
  return e20 = fn$1(e20, (e21) => {
    switch (e21.type) {
      case "ChainExpression":
        return mn$1(e21.expression);
      case "LogicalExpression":
        if (yn$1(e21))
          return An$1(e21);
        break;
      case "VariableDeclaration": {
        const s2 = cn$1(e21.declarations);
        s2 && s2.init && function(e22, s3) {
          if (t2.originalText[dn$1(s3)] === ";")
            return;
          e22.range = [ln$1(e22), dn$1(s3)];
        }(e21, s2);
        break;
      }
      case "TSParenthesizedType":
        return e21.typeAnnotation.range = [ln$1(e21), dn$1(e21)], e21.typeAnnotation;
      case "TSTypeParameter":
        if (typeof e21.name == "string") {
          const t3 = ln$1(e21);
          e21.name = {type: "Identifier", name: e21.name, range: [t3, t3 + e21.name.length]};
        }
        break;
      case "SequenceExpression": {
        const t3 = cn$1(e21.expressions);
        e21.range = [ln$1(e21), Math.min(dn$1(t3), dn$1(e21))];
        break;
      }
      case "ClassProperty":
        e21.key && e21.key.type === "TSPrivateIdentifier" && pn$1(t2.originalText, e21.key, dn$1) === "?" && (e21.optional = true);
    }
  });
};
class Cn$1 {
  constructor(e20, t2 = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = e20, this.keyword = t2.keyword, this.beforeExpr = !!t2.beforeExpr, this.startsExpr = !!t2.startsExpr, this.rightAssociative = !!t2.rightAssociative, this.isLoop = !!t2.isLoop, this.isAssign = !!t2.isAssign, this.prefix = !!t2.prefix, this.postfix = !!t2.postfix, this.binop = t2.binop != null ? t2.binop : null, this.updateContext = null;
  }
}
const xn$1 = new Map();
function Fn$1(e20, t2 = {}) {
  t2.keyword = e20;
  const s2 = new Cn$1(e20, t2);
  return xn$1.set(e20, s2), s2;
}
function gn$1(e20, t2) {
  return new Cn$1(e20, {beforeExpr: true, binop: t2});
}
const bn$1 = {num: new Cn$1("num", {startsExpr: true}), bigint: new Cn$1("bigint", {startsExpr: true}), decimal: new Cn$1("decimal", {startsExpr: true}), regexp: new Cn$1("regexp", {startsExpr: true}), string: new Cn$1("string", {startsExpr: true}), name: new Cn$1("name", {startsExpr: true}), privateName: new Cn$1("#name", {startsExpr: true}), eof: new Cn$1("eof"), bracketL: new Cn$1("[", {beforeExpr: true, startsExpr: true}), bracketHashL: new Cn$1("#[", {beforeExpr: true, startsExpr: true}), bracketBarL: new Cn$1("[|", {beforeExpr: true, startsExpr: true}), bracketR: new Cn$1("]"), bracketBarR: new Cn$1("|]"), braceL: new Cn$1("{", {beforeExpr: true, startsExpr: true}), braceBarL: new Cn$1("{|", {beforeExpr: true, startsExpr: true}), braceHashL: new Cn$1("#{", {beforeExpr: true, startsExpr: true}), braceR: new Cn$1("}", {beforeExpr: true}), braceBarR: new Cn$1("|}"), parenL: new Cn$1("(", {beforeExpr: true, startsExpr: true}), parenR: new Cn$1(")"), comma: new Cn$1(",", {beforeExpr: true}), semi: new Cn$1(";", {beforeExpr: true}), colon: new Cn$1(":", {beforeExpr: true}), doubleColon: new Cn$1("::", {beforeExpr: true}), dot: new Cn$1("."), question: new Cn$1("?", {beforeExpr: true}), questionDot: new Cn$1("?."), arrow: new Cn$1("=>", {beforeExpr: true}), template: new Cn$1("template"), ellipsis: new Cn$1("...", {beforeExpr: true}), backQuote: new Cn$1("`", {startsExpr: true}), dollarBraceL: new Cn$1("${", {beforeExpr: true, startsExpr: true}), at: new Cn$1("@"), hash: new Cn$1("#", {startsExpr: true}), interpreterDirective: new Cn$1("#!..."), eq: new Cn$1("=", {beforeExpr: true, isAssign: true}), assign: new Cn$1("_=", {beforeExpr: true, isAssign: true}), slashAssign: new Cn$1("_=", {beforeExpr: true, isAssign: true}), moduloAssign: new Cn$1("_=", {beforeExpr: true, isAssign: true}), incDec: new Cn$1("++/--", {prefix: true, postfix: true, startsExpr: true}), bang: new Cn$1("!", {beforeExpr: true, prefix: true, startsExpr: true}), tilde: new Cn$1("~", {beforeExpr: true, prefix: true, startsExpr: true}), pipeline: gn$1("|>", 0), nullishCoalescing: gn$1("??", 1), logicalOR: gn$1("||", 1), logicalAND: gn$1("&&", 2), bitwiseOR: gn$1("|", 3), bitwiseXOR: gn$1("^", 4), bitwiseAND: gn$1("&", 5), equality: gn$1("==/!=/===/!==", 6), relational: gn$1("</>/<=/>=", 7), bitShift: gn$1("<</>>/>>>", 8), plusMin: new Cn$1("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}), modulo: new Cn$1("%", {binop: 10, startsExpr: true}), star: new Cn$1("*", {binop: 10}), slash: gn$1("/", 10), exponent: new Cn$1("**", {beforeExpr: true, binop: 11, rightAssociative: true}), _break: Fn$1("break"), _case: Fn$1("case", {beforeExpr: true}), _catch: Fn$1("catch"), _continue: Fn$1("continue"), _debugger: Fn$1("debugger"), _default: Fn$1("default", {beforeExpr: true}), _do: Fn$1("do", {isLoop: true, beforeExpr: true}), _else: Fn$1("else", {beforeExpr: true}), _finally: Fn$1("finally"), _for: Fn$1("for", {isLoop: true}), _function: Fn$1("function", {startsExpr: true}), _if: Fn$1("if"), _return: Fn$1("return", {beforeExpr: true}), _switch: Fn$1("switch"), _throw: Fn$1("throw", {beforeExpr: true, prefix: true, startsExpr: true}), _try: Fn$1("try"), _var: Fn$1("var"), _const: Fn$1("const"), _while: Fn$1("while", {isLoop: true}), _with: Fn$1("with"), _new: Fn$1("new", {beforeExpr: true, startsExpr: true}), _this: Fn$1("this", {startsExpr: true}), _super: Fn$1("super", {startsExpr: true}), _class: Fn$1("class", {startsExpr: true}), _extends: Fn$1("extends", {beforeExpr: true}), _export: Fn$1("export"), _import: Fn$1("import", {startsExpr: true}), _null: Fn$1("null", {startsExpr: true}), _true: Fn$1("true", {startsExpr: true}), _false: Fn$1("false", {startsExpr: true}), _in: Fn$1("in", {beforeExpr: true, binop: 7}), _instanceof: Fn$1("instanceof", {beforeExpr: true, binop: 7}), _typeof: Fn$1("typeof", {beforeExpr: true, prefix: true, startsExpr: true}), _void: Fn$1("void", {beforeExpr: true, prefix: true, startsExpr: true}), _delete: Fn$1("delete", {beforeExpr: true, prefix: true, startsExpr: true})}, Pn$1 = /\r\n?|[\n\u2028\u2029]/, Tn$1 = new RegExp(Pn$1.source, "g");
function wn$1(e20) {
  switch (e20) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;
    default:
      return false;
  }
}
const Sn$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Bn$1 = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function Nn$1(e20) {
  switch (e20) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return true;
    default:
      return false;
  }
}
class In$1 {
  constructor(e20, t2) {
    this.line = void 0, this.column = void 0, this.line = e20, this.column = t2;
  }
}
class vn$1 {
  constructor(e20, t2) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e20, this.end = t2;
  }
}
function kn$1(e20, t2) {
  e20.trailingComments === void 0 ? e20.trailingComments = t2 : e20.trailingComments.unshift(...t2);
}
function Ln$1(e20, t2) {
  e20.innerComments === void 0 ? e20.innerComments = t2 : t2 !== void 0 && e20.innerComments.unshift(...t2);
}
function On$1(e20, t2, s2) {
  let r2 = null, i2 = t2.length;
  for (; r2 === null && i2 > 0; )
    r2 = t2[--i2];
  r2 === null || r2.start > s2.start ? Ln$1(e20, s2.comments) : kn$1(r2, s2.comments);
}
const Mn$1 = Object.freeze({SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"}), Rn$1 = Un$1({AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.', PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."}, Mn$1.SyntaxError), jn$1 = Un$1({ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`}, Mn$1.SourceTypeModuleError);
function _n$1(e20, t2) {
  return t2 === "flow" && e20 === "PatternIsOptional" ? "OptionalBindingPattern" : e20;
}
function Un$1(e20, t2, s2) {
  const r2 = {};
  return Object.keys(e20).forEach((i2) => {
    r2[i2] = Object.freeze({code: t2, reasonCode: _n$1(i2, s2), template: e20[i2]});
  }), Object.freeze(r2);
}
class qn$1 {
  constructor(e20, t2) {
    this.token = void 0, this.preserveSpace = void 0, this.token = e20, this.preserveSpace = !!t2;
  }
}
const $n$1 = {brace: new qn$1("{"), template: new qn$1("`", true)};
bn$1.braceR.updateContext = (e20) => {
  e20.pop();
}, bn$1.braceL.updateContext = bn$1.braceHashL.updateContext = bn$1.dollarBraceL.updateContext = (e20) => {
  e20.push($n$1.brace);
}, bn$1.backQuote.updateContext = (e20) => {
  e20[e20.length - 1] === $n$1.template ? e20.pop() : e20.push($n$1.template);
};
let Hn$1 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Vn$1 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
const zn$1 = new RegExp("[" + Hn$1 + "]"), Wn$1 = new RegExp("[" + Hn$1 + Vn$1 + "]");
Hn$1 = Vn$1 = null;
const Gn$1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], Kn$1 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Xn$1(e20, t2) {
  let s2 = 65536;
  for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
    if (s2 += t2[r2], s2 > e20)
      return false;
    if (s2 += t2[r2 + 1], s2 >= e20)
      return true;
  }
  return false;
}
function Jn$1(e20) {
  return e20 < 65 ? e20 === 36 : e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && zn$1.test(String.fromCharCode(e20)) : Xn$1(e20, Gn$1)));
}
function Yn$1(e20) {
  return e20 < 48 ? e20 === 36 : e20 < 58 || !(e20 < 65) && (e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Wn$1.test(String.fromCharCode(e20)) : Xn$1(e20, Gn$1) || Xn$1(e20, Kn$1))));
}
const Qn$1 = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Zn$1 = ["eval", "arguments"], eo$1 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), to$1 = new Set(Qn$1), so$1 = new Set(Zn$1);
function ro$1(e20, t2) {
  return t2 && e20 === "await" || e20 === "enum";
}
function io$1(e20, t2) {
  return ro$1(e20, t2) || to$1.has(e20);
}
function ao$1(e20) {
  return so$1.has(e20);
}
function no$1(e20, t2) {
  return io$1(e20, t2) || ao$1(e20);
}
function oo$1(e20) {
  return eo$1.has(e20);
}
const uo$1 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
class ho$1 {
  constructor(e20) {
    this.var = new Set(), this.lexical = new Set(), this.functions = new Set(), this.flags = e20;
  }
}
class co$1 {
  constructor(e20, t2) {
    this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = e20, this.inModule = t2;
  }
  get inFunction() {
    return (2 & this.currentVarScopeFlags()) > 0;
  }
  get allowSuper() {
    return (16 & this.currentThisScopeFlags()) > 0;
  }
  get allowDirectSuper() {
    return (32 & this.currentThisScopeFlags()) > 0;
  }
  get inClass() {
    return (64 & this.currentThisScopeFlags()) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const e20 = this.currentThisScopeFlags();
    return (64 & e20) > 0 && (2 & e20) == 0;
  }
  get inStaticBlock() {
    for (let e20 = this.scopeStack.length - 1; ; e20--) {
      const {flags: t2} = this.scopeStack[e20];
      if (128 & t2)
        return true;
      if (323 & t2)
        return false;
    }
  }
  get inNonArrowFunction() {
    return (2 & this.currentThisScopeFlags()) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(e20) {
    return new ho$1(e20);
  }
  enter(e20) {
    this.scopeStack.push(this.createScope(e20));
  }
  exit() {
    this.scopeStack.pop();
  }
  treatFunctionsAsVarInScope(e20) {
    return !!(2 & e20.flags || !this.inModule && 1 & e20.flags);
  }
  declareName(e20, t2, s2) {
    let r2 = this.currentScope();
    if (8 & t2 || 16 & t2)
      this.checkRedeclarationInScope(r2, e20, t2, s2), 16 & t2 ? r2.functions.add(e20) : r2.lexical.add(e20), 8 & t2 && this.maybeExportDefined(r2, e20);
    else if (4 & t2)
      for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r2 = this.scopeStack[i2], this.checkRedeclarationInScope(r2, e20, t2, s2), r2.var.add(e20), this.maybeExportDefined(r2, e20), !(259 & r2.flags)); --i2)
        ;
    this.inModule && 1 & r2.flags && this.undefinedExports.delete(e20);
  }
  maybeExportDefined(e20, t2) {
    this.inModule && 1 & e20.flags && this.undefinedExports.delete(t2);
  }
  checkRedeclarationInScope(e20, t2, s2, r2) {
    this.isRedeclaredInScope(e20, t2, s2) && this.raise(r2, Rn$1.VarRedeclaration, t2);
  }
  isRedeclaredInScope(e20, t2, s2) {
    return !!(1 & s2) && (8 & s2 ? e20.lexical.has(t2) || e20.functions.has(t2) || e20.var.has(t2) : 16 & s2 ? e20.lexical.has(t2) || !this.treatFunctionsAsVarInScope(e20) && e20.var.has(t2) : e20.lexical.has(t2) && !(8 & e20.flags && e20.lexical.values().next().value === t2) || !this.treatFunctionsAsVarInScope(e20) && e20.functions.has(t2));
  }
  checkLocalExport(e20) {
    const {name: t2} = e20, s2 = this.scopeStack[0];
    s2.lexical.has(t2) || s2.var.has(t2) || s2.functions.has(t2) || this.undefinedExports.set(t2, e20.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let e20 = this.scopeStack.length - 1; ; e20--) {
      const {flags: t2} = this.scopeStack[e20];
      if (259 & t2)
        return t2;
    }
  }
  currentThisScopeFlags() {
    for (let e20 = this.scopeStack.length - 1; ; e20--) {
      const {flags: t2} = this.scopeStack[e20];
      if (323 & t2 && !(4 & t2))
        return t2;
    }
  }
}
class po$1 extends ho$1 {
  constructor(...e20) {
    super(...e20), this.declareFunctions = new Set();
  }
}
class lo$1 extends co$1 {
  createScope(e20) {
    return new po$1(e20);
  }
  declareName(e20, t2, s2) {
    const r2 = this.currentScope();
    if (2048 & t2)
      return this.checkRedeclarationInScope(r2, e20, t2, s2), this.maybeExportDefined(r2, e20), void r2.declareFunctions.add(e20);
    super.declareName(...arguments);
  }
  isRedeclaredInScope(e20, t2, s2) {
    return !!super.isRedeclaredInScope(...arguments) || !!(2048 & s2) && (!e20.declareFunctions.has(t2) && (e20.lexical.has(t2) || e20.functions.has(t2)));
  }
  checkLocalExport(e20) {
    this.scopeStack[0].declareFunctions.has(e20.name) || super.checkLocalExport(e20);
  }
}
class Do$1 {
  constructor() {
    this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null}, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.lineStart = 0, this.type = bn$1.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [$n$1.brace], this.exprAllowed = true, this.containsEsc = false, this.strictErrors = new Map(), this.tokensLength = 0;
  }
  init(e20) {
    this.strict = e20.strictMode !== false && (e20.strictMode === true || e20.sourceType === "module"), this.curLine = e20.startLine, this.startLoc = this.endLoc = this.curPosition();
  }
  curPosition() {
    return new In$1(this.curLine, this.pos - this.lineStart);
  }
  clone(e20) {
    const t2 = new Do$1(), s2 = Object.keys(this);
    for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) {
      const i3 = s2[r2];
      let a2 = this[i3];
      !e20 && Array.isArray(a2) && (a2 = a2.slice()), t2[i3] = a2;
    }
    return t2;
  }
}
var mo$1 = function(e20) {
  return e20 >= 48 && e20 <= 57;
};
const fo$1 = new Set([103, 109, 115, 105, 121, 117, 100]), yo$1 = {decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120]}, Ao$1 = {bin: [48, 49]};
Ao$1.oct = [...Ao$1.bin, 50, 51, 52, 53, 54, 55], Ao$1.dec = [...Ao$1.oct, 56, 57], Ao$1.hex = [...Ao$1.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
class Eo$1 {
  constructor(e20) {
    this.type = e20.type, this.value = e20.value, this.start = e20.start, this.end = e20.end, this.loc = new vn$1(e20.startLoc, e20.endLoc);
  }
}
class Co$1 {
  constructor() {
    this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();
  }
}
class xo$1 {
  constructor(e20) {
    this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = e20;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new Co$1());
  }
  exit() {
    const e20 = this.stack.pop(), t2 = this.current();
    for (const [s2, r2] of Array.from(e20.undefinedPrivateNames))
      t2 ? t2.undefinedPrivateNames.has(s2) || t2.undefinedPrivateNames.set(s2, r2) : this.raise(r2, Rn$1.InvalidPrivateFieldResolution, s2);
  }
  declarePrivateName(e20, t2, s2) {
    const r2 = this.current();
    let i2 = r2.privateNames.has(e20);
    if (3 & t2) {
      const s3 = i2 && r2.loneAccessors.get(e20);
      if (s3) {
        const a2 = 4 & s3, n2 = 4 & t2;
        i2 = (3 & s3) === (3 & t2) || a2 !== n2, i2 || r2.loneAccessors.delete(e20);
      } else
        i2 || r2.loneAccessors.set(e20, t2);
    }
    i2 && this.raise(s2, Rn$1.PrivateNameRedeclaration, e20), r2.privateNames.add(e20), r2.undefinedPrivateNames.delete(e20);
  }
  usePrivateName(e20, t2) {
    let s2;
    for (s2 of this.stack)
      if (s2.privateNames.has(e20))
        return;
    s2 ? s2.undefinedPrivateNames.set(e20, t2) : this.raise(t2, Rn$1.InvalidPrivateFieldResolution, e20);
  }
}
class Fo$1 {
  constructor(e20 = 0) {
    this.type = void 0, this.type = e20;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}
class go$1 extends Fo$1 {
  constructor(e20) {
    super(e20), this.errors = new Map();
  }
  recordDeclarationError(e20, t2) {
    this.errors.set(e20, t2);
  }
  clearDeclarationError(e20) {
    this.errors.delete(e20);
  }
  iterateErrors(e20) {
    this.errors.forEach(e20);
  }
}
class bo$1 {
  constructor(e20) {
    this.stack = [new Fo$1()], this.raise = e20;
  }
  enter(e20) {
    this.stack.push(e20);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(e20, t2) {
    const {stack: s2} = this;
    let r2 = s2.length - 1, i2 = s2[r2];
    for (; !i2.isCertainlyParameterDeclaration(); ) {
      if (!i2.canBeArrowParameterDeclaration())
        return;
      i2.recordDeclarationError(e20, t2), i2 = s2[--r2];
    }
    this.raise(e20, t2);
  }
  recordParenthesizedIdentifierError(e20, t2) {
    const {stack: s2} = this, r2 = s2[s2.length - 1];
    if (r2.isCertainlyParameterDeclaration())
      this.raise(e20, t2);
    else {
      if (!r2.canBeArrowParameterDeclaration())
        return;
      r2.recordDeclarationError(e20, t2);
    }
  }
  recordAsyncArrowParametersError(e20, t2) {
    const {stack: s2} = this;
    let r2 = s2.length - 1, i2 = s2[r2];
    for (; i2.canBeArrowParameterDeclaration(); )
      i2.type === 2 && i2.recordDeclarationError(e20, t2), i2 = s2[--r2];
  }
  validateAsPattern() {
    const {stack: e20} = this, t2 = e20[e20.length - 1];
    t2.canBeArrowParameterDeclaration() && t2.iterateErrors((t3, s2) => {
      this.raise(s2, t3);
      let r2 = e20.length - 2, i2 = e20[r2];
      for (; i2.canBeArrowParameterDeclaration(); )
        i2.clearDeclarationError(s2), i2 = e20[--r2];
    });
  }
}
function Po$1() {
  return new Fo$1();
}
class To$1 {
  constructor() {
    this.stacks = [];
  }
  enter(e20) {
    this.stacks.push(e20);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (2 & this.currentFlags()) > 0;
  }
  get hasYield() {
    return (1 & this.currentFlags()) > 0;
  }
  get hasReturn() {
    return (4 & this.currentFlags()) > 0;
  }
  get hasIn() {
    return (8 & this.currentFlags()) > 0;
  }
}
function wo$1(e20, t2) {
  return (e20 ? 2 : 0) | (t2 ? 1 : 0);
}
class So$1 {
  constructor() {
    this.shorthandAssign = -1, this.doubleProto = -1, this.optionalParameters = -1;
  }
}
class Bo$1 {
  constructor(e20, t2, s2) {
    this.type = "", this.start = t2, this.end = 0, this.loc = new vn$1(s2), e20 != null && e20.options.ranges && (this.range = [t2, 0]), e20 != null && e20.filename && (this.loc.filename = e20.filename);
  }
}
const No$1 = Bo$1.prototype;
function Io$1(e20) {
  const {type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2, name: o2} = e20, u2 = Object.create(No$1);
  return u2.type = t2, u2.start = s2, u2.end = r2, u2.loc = i2, u2.range = a2, u2.extra = n2, u2.name = o2, t2 === "Placeholder" && (u2.expectedNode = e20.expectedNode), u2;
}
function vo$1(e20) {
  const {type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2} = e20;
  if (t2 === "Placeholder")
    return function(e21) {
      return Io$1(e21);
    }(e20);
  const o2 = Object.create(No$1);
  return o2.type = "StringLiteral", o2.start = s2, o2.end = r2, o2.loc = i2, o2.range = a2, o2.extra = n2, o2.value = e20.value, o2;
}
No$1.__clone = function() {
  const e20 = new Bo$1(), t2 = Object.keys(this);
  for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
    const r3 = t2[s2];
    r3 !== "leadingComments" && r3 !== "trailingComments" && r3 !== "innerComments" && (e20[r3] = this[r3]);
  }
  return e20;
};
const ko$1 = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Lo$1 = Un$1({AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment."}, Mn$1.SyntaxError, "flow");
function Oo$1(e20) {
  return e20.importKind === "type" || e20.importKind === "typeof";
}
function Mo(e20) {
  return (e20.type === bn$1.name || !!e20.type.keyword) && e20.value !== "from";
}
const Ro$1 = {const: "declare export var", let: "declare export var", type: "export type", interface: "export interface"};
const jo = /\*?\s*@((?:no)?flow)\b/;
const _o$1 = {quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666"}, Uo = /^[\da-fA-F]+$/, qo = /^\d+$/, $o = Un$1({AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"}, Mn$1.SyntaxError, "jsx");
function Ho(e20) {
  return !!e20 && (e20.type === "JSXOpeningFragment" || e20.type === "JSXClosingFragment");
}
function Vo(e20) {
  if (e20.type === "JSXIdentifier")
    return e20.name;
  if (e20.type === "JSXNamespacedName")
    return e20.namespace.name + ":" + e20.name.name;
  if (e20.type === "JSXMemberExpression")
    return Vo(e20.object) + "." + Vo(e20.property);
  throw new Error("Node had unexpected type: " + e20.type);
}
$n$1.j_oTag = new qn$1("<tag"), $n$1.j_cTag = new qn$1("</tag"), $n$1.j_expr = new qn$1("<tag>...</tag>", true), bn$1.jsxName = new Cn$1("jsxName"), bn$1.jsxText = new Cn$1("jsxText", {beforeExpr: true}), bn$1.jsxTagStart = new Cn$1("jsxTagStart", {startsExpr: true}), bn$1.jsxTagEnd = new Cn$1("jsxTagEnd"), bn$1.jsxTagStart.updateContext = (e20) => {
  e20.push($n$1.j_expr, $n$1.j_oTag);
};
class zo extends ho$1 {
  constructor(...e20) {
    super(...e20), this.types = new Set(), this.enums = new Set(), this.constEnums = new Set(), this.classes = new Set(), this.exportOnlyBindings = new Set();
  }
}
class Wo extends co$1 {
  createScope(e20) {
    return new zo(e20);
  }
  declareName(e20, t2, s2) {
    const r2 = this.currentScope();
    if (1024 & t2)
      return this.maybeExportDefined(r2, e20), void r2.exportOnlyBindings.add(e20);
    super.declareName(...arguments), 2 & t2 && (1 & t2 || (this.checkRedeclarationInScope(r2, e20, t2, s2), this.maybeExportDefined(r2, e20)), r2.types.add(e20)), 256 & t2 && r2.enums.add(e20), 512 & t2 && r2.constEnums.add(e20), 128 & t2 && r2.classes.add(e20);
  }
  isRedeclaredInScope(e20, t2, s2) {
    if (e20.enums.has(t2)) {
      if (256 & s2) {
        return !!(512 & s2) !== e20.constEnums.has(t2);
      }
      return true;
    }
    return 128 & s2 && e20.classes.has(t2) ? !!e20.lexical.has(t2) && !!(1 & s2) : !!(2 & s2 && e20.types.has(t2)) || super.isRedeclaredInScope(...arguments);
  }
  checkLocalExport(e20) {
    const t2 = this.scopeStack[0], {name: s2} = e20;
    t2.types.has(s2) || t2.exportOnlyBindings.has(s2) || super.checkLocalExport(e20);
  }
}
function Go(e20) {
  if (e20 == null)
    throw new Error(`Unexpected ${e20} value.`);
  return e20;
}
function Ko(e20) {
  if (!e20)
    throw new Error("Assert fail");
}
const Xo = Un$1({AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."}, Mn$1.SyntaxError, "typescript");
function Jo(e20) {
  return e20 === "private" || e20 === "public" || e20 === "protected";
}
bn$1.placeholder = new Cn$1("%%", {startsExpr: true});
const Yo = Un$1({ClassNameIsRequired: "A class name is required."}, Mn$1.SyntaxError);
function Qo(e20, t2) {
  return e20.some((e21) => Array.isArray(e21) ? e21[0] === t2 : e21 === t2);
}
function Zo(e20, t2, s2) {
  const r2 = e20.find((e21) => Array.isArray(e21) ? e21[0] === t2 : e21 === t2);
  return r2 && Array.isArray(r2) ? r2[1][s2] : null;
}
const eu = ["minimal", "fsharp", "hack", "smart"], tu = ["%", "#"], su = ["hash", "bar"];
const ru = {estree: (e20) => class extends e20 {
  parseRegExpLiteral({pattern: e21, flags: t2}) {
    let s2 = null;
    try {
      s2 = new RegExp(e21, t2);
    } catch (e22) {
    }
    const r2 = this.estreeParseLiteral(s2);
    return r2.regex = {pattern: e21, flags: t2}, r2;
  }
  parseBigIntLiteral(e21) {
    let t2;
    try {
      t2 = BigInt(e21);
    } catch (e22) {
      t2 = null;
    }
    const s2 = this.estreeParseLiteral(t2);
    return s2.bigint = String(s2.value || e21), s2;
  }
  parseDecimalLiteral(e21) {
    const t2 = this.estreeParseLiteral(null);
    return t2.decimal = String(t2.value || e21), t2;
  }
  estreeParseLiteral(e21) {
    return this.parseLiteral(e21, "Literal");
  }
  parseStringLiteral(e21) {
    return this.estreeParseLiteral(e21);
  }
  parseNumericLiteral(e21) {
    return this.estreeParseLiteral(e21);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(e21) {
    return this.estreeParseLiteral(e21);
  }
  directiveToStmt(e21) {
    const t2 = e21.value, s2 = this.startNodeAt(e21.start, e21.loc.start), r2 = this.startNodeAt(t2.start, t2.loc.start);
    return r2.value = t2.extra.expressionValue, r2.raw = t2.extra.raw, s2.expression = this.finishNodeAt(r2, "Literal", t2.end, t2.loc.end), s2.directive = t2.extra.raw.slice(1, -1), this.finishNodeAt(s2, "ExpressionStatement", e21.end, e21.loc.end);
  }
  initFunction(e21, t2) {
    super.initFunction(e21, t2), e21.expression = false;
  }
  checkDeclaration(e21) {
    e21 != null && this.isObjectProperty(e21) ? this.checkDeclaration(e21.value) : super.checkDeclaration(e21);
  }
  getObjectOrClassMethodParams(e21) {
    return e21.value.params;
  }
  isValidDirective(e21) {
    var t2;
    return e21.type === "ExpressionStatement" && e21.expression.type === "Literal" && typeof e21.expression.value == "string" && !((t2 = e21.expression.extra) != null && t2.parenthesized);
  }
  stmtToDirective(e21) {
    const t2 = e21.expression.value, s2 = super.stmtToDirective(e21);
    return this.addExtra(s2.value, "expressionValue", t2), s2;
  }
  parseBlockBody(e21, ...t2) {
    super.parseBlockBody(e21, ...t2);
    const s2 = e21.directives.map((e22) => this.directiveToStmt(e22));
    e21.body = s2.concat(e21.body), delete e21.directives;
  }
  pushClassMethod(e21, t2, s2, r2, i2, a2) {
    this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true), t2.typeParameters && (t2.value.typeParameters = t2.typeParameters, delete t2.typeParameters), e21.body.push(t2);
  }
  parseMaybePrivateName(...e21) {
    const t2 = super.parseMaybePrivateName(...e21);
    return t2.type === "PrivateName" && this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t2) : t2;
  }
  convertPrivateNameToPrivateIdentifier(e21) {
    const t2 = super.getPrivateNameSV(e21);
    return delete (e21 = e21).id, e21.name = t2, e21.type = "PrivateIdentifier", e21;
  }
  isPrivateName(e21) {
    return this.getPluginOption("estree", "classFeatures") ? e21.type === "PrivateIdentifier" : super.isPrivateName(e21);
  }
  getPrivateNameSV(e21) {
    return this.getPluginOption("estree", "classFeatures") ? e21.name : super.getPrivateNameSV(e21);
  }
  parseLiteral(e21, t2) {
    const s2 = super.parseLiteral(e21, t2);
    return s2.raw = s2.extra.raw, delete s2.extra, s2;
  }
  parseFunctionBody(e21, t2, s2 = false) {
    super.parseFunctionBody(e21, t2, s2), e21.expression = e21.body.type !== "BlockStatement";
  }
  parseMethod(e21, t2, s2, r2, i2, a2, n2 = false) {
    let o2 = this.startNode();
    return o2.kind = e21.kind, o2 = super.parseMethod(o2, t2, s2, r2, i2, a2, n2), o2.type = "FunctionExpression", delete o2.kind, e21.value = o2, a2 === "ClassPrivateMethod" && (e21.computed = false), a2 = "MethodDefinition", this.finishNode(e21, a2);
  }
  parseClassProperty(...e21) {
    const t2 = super.parseClassProperty(...e21);
    return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition"), t2;
  }
  parseClassPrivateProperty(...e21) {
    const t2 = super.parseClassPrivateProperty(...e21);
    return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition", t2.computed = false), t2;
  }
  parseObjectMethod(e21, t2, s2, r2, i2) {
    const a2 = super.parseObjectMethod(e21, t2, s2, r2, i2);
    return a2 && (a2.type = "Property", a2.kind === "method" && (a2.kind = "init"), a2.shorthand = false), a2;
  }
  parseObjectProperty(e21, t2, s2, r2, i2) {
    const a2 = super.parseObjectProperty(e21, t2, s2, r2, i2);
    return a2 && (a2.kind = "init", a2.type = "Property"), a2;
  }
  isAssignable(e21, t2) {
    return e21 != null && this.isObjectProperty(e21) ? this.isAssignable(e21.value, t2) : super.isAssignable(e21, t2);
  }
  toAssignable(e21, t2 = false) {
    return e21 != null && this.isObjectProperty(e21) ? (this.toAssignable(e21.value, t2), e21) : super.toAssignable(e21, t2);
  }
  toAssignableObjectExpressionProp(e21, ...t2) {
    e21.kind === "get" || e21.kind === "set" ? this.raise(e21.key.start, Rn$1.PatternHasAccessor) : e21.method ? this.raise(e21.key.start, Rn$1.PatternHasMethod) : super.toAssignableObjectExpressionProp(e21, ...t2);
  }
  finishCallExpression(e21, t2) {
    if (super.finishCallExpression(e21, t2), e21.callee.type === "Import") {
      var s2;
      if (e21.type = "ImportExpression", e21.source = e21.arguments[0], this.hasPlugin("importAssertions"))
        e21.attributes = (s2 = e21.arguments[1]) != null ? s2 : null;
      delete e21.arguments, delete e21.callee;
    }
    return e21;
  }
  toReferencedArguments(e21) {
    e21.type !== "ImportExpression" && super.toReferencedArguments(e21);
  }
  parseExport(e21) {
    switch (super.parseExport(e21), e21.type) {
      case "ExportAllDeclaration":
        e21.exported = null;
        break;
      case "ExportNamedDeclaration":
        e21.specifiers.length === 1 && e21.specifiers[0].type === "ExportNamespaceSpecifier" && (e21.type = "ExportAllDeclaration", e21.exported = e21.specifiers[0].exported, delete e21.specifiers);
    }
    return e21;
  }
  parseSubscript(e21, t2, s2, r2, i2) {
    const a2 = super.parseSubscript(e21, t2, s2, r2, i2);
    if (i2.optionalChainMember) {
      if (a2.type !== "OptionalMemberExpression" && a2.type !== "OptionalCallExpression" || (a2.type = a2.type.substring(8)), i2.stop) {
        const e22 = this.startNodeAtNode(a2);
        return e22.expression = a2, this.finishNode(e22, "ChainExpression");
      }
    } else
      a2.type !== "MemberExpression" && a2.type !== "CallExpression" || (a2.optional = false);
    return a2;
  }
  hasPropertyAsPrivateName(e21) {
    return e21.type === "ChainExpression" && (e21 = e21.expression), super.hasPropertyAsPrivateName(e21);
  }
  isOptionalChain(e21) {
    return e21.type === "ChainExpression";
  }
  isObjectProperty(e21) {
    return e21.type === "Property" && e21.kind === "init" && !e21.method;
  }
  isObjectMethod(e21) {
    return e21.method || e21.kind === "get" || e21.kind === "set";
  }
}, jsx: (e20) => class extends e20 {
  jsxReadToken() {
    let e21 = "", t2 = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, $o.UnterminatedJsxContent);
      const s2 = this.input.charCodeAt(this.state.pos);
      switch (s2) {
        case 60:
        case 123:
          return this.state.pos === this.state.start ? s2 === 60 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(s2) : (e21 += this.input.slice(t2, this.state.pos), this.finishToken(bn$1.jsxText, e21));
        case 38:
          e21 += this.input.slice(t2, this.state.pos), e21 += this.jsxReadEntity(), t2 = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          wn$1(s2) ? (e21 += this.input.slice(t2, this.state.pos), e21 += this.jsxReadNewLine(true), t2 = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(e21) {
    const t2 = this.input.charCodeAt(this.state.pos);
    let s2;
    return ++this.state.pos, t2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s2 = e21 ? "\n" : "\r\n") : s2 = String.fromCharCode(t2), ++this.state.curLine, this.state.lineStart = this.state.pos, s2;
  }
  jsxReadString(e21) {
    let t2 = "", s2 = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn$1.UnterminatedString);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === e21)
        break;
      r2 === 38 ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadEntity(), s2 = this.state.pos) : wn$1(r2) ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadNewLine(false), s2 = this.state.pos) : ++this.state.pos;
    }
    return t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
  }
  jsxReadEntity() {
    let e21, t2 = "", s2 = 0, r2 = this.input[this.state.pos];
    const i2 = ++this.state.pos;
    for (; this.state.pos < this.length && s2++ < 10; ) {
      if (r2 = this.input[this.state.pos++], r2 === ";") {
        t2[0] === "#" ? t2[1] === "x" ? (t2 = t2.substr(2), Uo.test(t2) && (e21 = String.fromCodePoint(parseInt(t2, 16)))) : (t2 = t2.substr(1), qo.test(t2) && (e21 = String.fromCodePoint(parseInt(t2, 10)))) : e21 = _o$1[t2];
        break;
      }
      t2 += r2;
    }
    return e21 || (this.state.pos = i2, "&");
  }
  jsxReadWord() {
    let e21;
    const t2 = this.state.pos;
    do {
      e21 = this.input.charCodeAt(++this.state.pos);
    } while (Yn$1(e21) || e21 === 45);
    return this.finishToken(bn$1.jsxName, this.input.slice(t2, this.state.pos));
  }
  jsxParseIdentifier() {
    const e21 = this.startNode();
    return this.match(bn$1.jsxName) ? e21.name = this.state.value : this.state.type.keyword ? e21.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(e21, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
    if (!this.eat(bn$1.colon))
      return s2;
    const r2 = this.startNodeAt(e21, t2);
    return r2.namespace = s2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const e21 = this.state.start, t2 = this.state.startLoc;
    let s2 = this.jsxParseNamespacedName();
    if (s2.type === "JSXNamespacedName")
      return s2;
    for (; this.eat(bn$1.dot); ) {
      const r2 = this.startNodeAt(e21, t2);
      r2.object = s2, r2.property = this.jsxParseIdentifier(), s2 = this.finishNode(r2, "JSXMemberExpression");
    }
    return s2;
  }
  jsxParseAttributeValue() {
    let e21;
    switch (this.state.type) {
      case bn$1.braceL:
        return e21 = this.startNode(), this.next(), e21 = this.jsxParseExpressionContainer(e21), e21.expression.type === "JSXEmptyExpression" && this.raise(e21.start, $o.AttributeIsEmpty), e21;
      case bn$1.jsxTagStart:
      case bn$1.string:
        return this.parseExprAtom();
      default:
        throw this.raise(this.state.start, $o.UnsupportedJsxValue);
    }
  }
  jsxParseEmptyExpression() {
    const e21 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
    return this.finishNodeAt(e21, "JSXEmptyExpression", this.state.start, this.state.startLoc);
  }
  jsxParseSpreadChild(e21) {
    return this.next(), e21.expression = this.parseExpression(), this.expect(bn$1.braceR), this.finishNode(e21, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(e21) {
    if (this.match(bn$1.braceR))
      e21.expression = this.jsxParseEmptyExpression();
    else {
      const t2 = this.parseExpression();
      e21.expression = t2;
    }
    return this.expect(bn$1.braceR), this.finishNode(e21, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const e21 = this.startNode();
    return this.eat(bn$1.braceL) ? (this.expect(bn$1.ellipsis), e21.argument = this.parseMaybeAssignAllowIn(), this.expect(bn$1.braceR), this.finishNode(e21, "JSXSpreadAttribute")) : (e21.name = this.jsxParseNamespacedName(), e21.value = this.eat(bn$1.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(e21, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(e21, t2) {
    const s2 = this.startNodeAt(e21, t2);
    return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXOpeningFragment")) : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
  }
  jsxParseOpeningElementAfterName(e21) {
    const t2 = [];
    for (; !this.match(bn$1.slash) && !this.match(bn$1.jsxTagEnd); )
      t2.push(this.jsxParseAttribute());
    return e21.attributes = t2, e21.selfClosing = this.eat(bn$1.slash), this.expect(bn$1.jsxTagEnd), this.finishNode(e21, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(e21, t2) {
    const s2 = this.startNodeAt(e21, t2);
    return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingFragment")) : (s2.name = this.jsxParseElementName(), this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingElement"));
  }
  jsxParseElementAt(e21, t2) {
    const s2 = this.startNodeAt(e21, t2), r2 = [], i2 = this.jsxParseOpeningElementAt(e21, t2);
    let a2 = null;
    if (!i2.selfClosing) {
      e:
        for (; ; )
          switch (this.state.type) {
            case bn$1.jsxTagStart:
              if (e21 = this.state.start, t2 = this.state.startLoc, this.next(), this.eat(bn$1.slash)) {
                a2 = this.jsxParseClosingElementAt(e21, t2);
                break e;
              }
              r2.push(this.jsxParseElementAt(e21, t2));
              break;
            case bn$1.jsxText:
              r2.push(this.parseExprAtom());
              break;
            case bn$1.braceL: {
              const e22 = this.startNode();
              this.next(), this.match(bn$1.ellipsis) ? r2.push(this.jsxParseSpreadChild(e22)) : r2.push(this.jsxParseExpressionContainer(e22));
              break;
            }
            default:
              throw this.unexpected();
          }
      Ho(i2) && !Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagFragment) : !Ho(i2) && Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name)) : Ho(i2) || Ho(a2) || Vo(a2.name) !== Vo(i2.name) && this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name));
    }
    if (Ho(i2) ? (s2.openingFragment = i2, s2.closingFragment = a2) : (s2.openingElement = i2, s2.closingElement = a2), s2.children = r2, this.isRelational("<"))
      throw this.raise(this.state.start, $o.UnwrappedAdjacentJSXElements);
    return Ho(i2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
  }
  jsxParseElement() {
    const e21 = this.state.start, t2 = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(e21, t2);
  }
  parseExprAtom(e21) {
    return this.match(bn$1.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(bn$1.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33 ? (this.finishToken(bn$1.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(e21);
  }
  createLookaheadState(e21) {
    const t2 = super.createLookaheadState(e21);
    return t2.inPropertyName = e21.inPropertyName, t2;
  }
  getTokenFromCode(e21) {
    if (this.state.inPropertyName)
      return super.getTokenFromCode(e21);
    const t2 = this.curContext();
    if (t2 === $n$1.j_expr)
      return this.jsxReadToken();
    if (t2 === $n$1.j_oTag || t2 === $n$1.j_cTag) {
      if (Jn$1(e21))
        return this.jsxReadWord();
      if (e21 === 62)
        return ++this.state.pos, this.finishToken(bn$1.jsxTagEnd);
      if ((e21 === 34 || e21 === 39) && t2 === $n$1.j_oTag)
        return this.jsxReadString(e21);
    }
    return e21 === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(e21);
  }
  updateContext(e21) {
    super.updateContext(e21);
    const {context: t2, type: s2} = this.state;
    if (s2 === bn$1.slash && e21 === bn$1.jsxTagStart)
      t2.splice(-2, 2, $n$1.j_cTag), this.state.exprAllowed = false;
    else if (s2 === bn$1.jsxTagEnd) {
      const s3 = t2.pop();
      s3 === $n$1.j_oTag && e21 === bn$1.slash || s3 === $n$1.j_cTag ? (t2.pop(), this.state.exprAllowed = t2[t2.length - 1] === $n$1.j_expr) : this.state.exprAllowed = true;
    } else
      !s2.keyword || e21 !== bn$1.dot && e21 !== bn$1.questionDot ? this.state.exprAllowed = s2.beforeExpr : this.state.exprAllowed = false;
  }
}, flow: (e20) => class extends e20 {
  constructor(...e21) {
    super(...e21), this.flowPragma = void 0;
  }
  getScopeHandler() {
    return lo$1;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(e21, t2) {
    return e21 !== bn$1.string && e21 !== bn$1.semi && e21 !== bn$1.interpreterDirective && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e21, t2);
  }
  addComment(e21) {
    if (this.flowPragma === void 0) {
      const t2 = jo.exec(e21.value);
      if (t2)
        if (t2[1] === "flow")
          this.flowPragma = "flow";
        else {
          if (t2[1] !== "noflow")
            throw new Error("Unexpected flow pragma");
          this.flowPragma = "noflow";
        }
    }
    return super.addComment(e21);
  }
  flowParseTypeInitialiser(e21) {
    const t2 = this.state.inType;
    this.state.inType = true, this.expect(e21 || bn$1.colon);
    const s2 = this.flowParseType();
    return this.state.inType = t2, s2;
  }
  flowParsePredicate() {
    const e21 = this.startNode(), t2 = this.state.start;
    return this.next(), this.expectContextual("checks"), this.state.lastTokStart > t2 + 1 && this.raise(t2, Lo$1.UnexpectedSpaceBetweenModuloChecks), this.eat(bn$1.parenL) ? (e21.value = this.parseExpression(), this.expect(bn$1.parenR), this.finishNode(e21, "DeclaredPredicate")) : this.finishNode(e21, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    const e21 = this.state.inType;
    this.state.inType = true, this.expect(bn$1.colon);
    let t2 = null, s2 = null;
    return this.match(bn$1.modulo) ? (this.state.inType = e21, s2 = this.flowParsePredicate()) : (t2 = this.flowParseType(), this.state.inType = e21, this.match(bn$1.modulo) && (s2 = this.flowParsePredicate())), [t2, s2];
  }
  flowParseDeclareClass(e21) {
    return this.next(), this.flowParseInterfaceish(e21, true), this.finishNode(e21, "DeclareClass");
  }
  flowParseDeclareFunction(e21) {
    this.next();
    const t2 = e21.id = this.parseIdentifier(), s2 = this.startNode(), r2 = this.startNode();
    this.isRelational("<") ? s2.typeParameters = this.flowParseTypeParameterDeclaration() : s2.typeParameters = null, this.expect(bn$1.parenL);
    const i2 = this.flowParseFunctionTypeParams();
    return s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(bn$1.parenR), [s2.returnType, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(s2, "FunctionTypeAnnotation"), t2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(t2), this.semicolon(), this.scope.declareName(e21.id.name, 2048, e21.id.start), this.finishNode(e21, "DeclareFunction");
  }
  flowParseDeclare(e21, t2) {
    if (this.match(bn$1._class))
      return this.flowParseDeclareClass(e21);
    if (this.match(bn$1._function))
      return this.flowParseDeclareFunction(e21);
    if (this.match(bn$1._var))
      return this.flowParseDeclareVariable(e21);
    if (this.eatContextual("module"))
      return this.match(bn$1.dot) ? this.flowParseDeclareModuleExports(e21) : (t2 && this.raise(this.state.lastTokStart, Lo$1.NestedDeclareModule), this.flowParseDeclareModule(e21));
    if (this.isContextual("type"))
      return this.flowParseDeclareTypeAlias(e21);
    if (this.isContextual("opaque"))
      return this.flowParseDeclareOpaqueType(e21);
    if (this.isContextual("interface"))
      return this.flowParseDeclareInterface(e21);
    if (this.match(bn$1._export))
      return this.flowParseDeclareExportDeclaration(e21, t2);
    throw this.unexpected();
  }
  flowParseDeclareVariable(e21) {
    return this.next(), e21.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e21.id.name, 5, e21.id.start), this.semicolon(), this.finishNode(e21, "DeclareVariable");
  }
  flowParseDeclareModule(e21) {
    this.scope.enter(0), this.match(bn$1.string) ? e21.id = this.parseExprAtom() : e21.id = this.parseIdentifier();
    const t2 = e21.body = this.startNode(), s2 = t2.body = [];
    for (this.expect(bn$1.braceL); !this.match(bn$1.braceR); ) {
      let e22 = this.startNode();
      this.match(bn$1._import) ? (this.next(), this.isContextual("type") || this.match(bn$1._typeof) || this.raise(this.state.lastTokStart, Lo$1.InvalidNonTypeImportInDeclareModule), this.parseImport(e22)) : (this.expectContextual("declare", Lo$1.UnsupportedStatementInDeclareModule), e22 = this.flowParseDeclare(e22, true)), s2.push(e22);
    }
    this.scope.exit(), this.expect(bn$1.braceR), this.finishNode(t2, "BlockStatement");
    let r2 = null, i2 = false;
    return s2.forEach((e22) => {
      !function(e23) {
        return e23.type === "DeclareExportAllDeclaration" || e23.type === "DeclareExportDeclaration" && (!e23.declaration || e23.declaration.type !== "TypeAlias" && e23.declaration.type !== "InterfaceDeclaration");
      }(e22) ? e22.type === "DeclareModuleExports" && (i2 && this.raise(e22.start, Lo$1.DuplicateDeclareModuleExports), r2 === "ES" && this.raise(e22.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "CommonJS", i2 = true) : (r2 === "CommonJS" && this.raise(e22.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "ES");
    }), e21.kind = r2 || "CommonJS", this.finishNode(e21, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(e21, t2) {
    if (this.expect(bn$1._export), this.eat(bn$1._default))
      return this.match(bn$1._function) || this.match(bn$1._class) ? e21.declaration = this.flowParseDeclare(this.startNode()) : (e21.declaration = this.flowParseType(), this.semicolon()), e21.default = true, this.finishNode(e21, "DeclareExportDeclaration");
    if (this.match(bn$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !t2) {
      const e22 = this.state.value, t3 = Ro$1[e22];
      throw this.raise(this.state.start, Lo$1.UnsupportedDeclareExportKind, e22, t3);
    }
    if (this.match(bn$1._var) || this.match(bn$1._function) || this.match(bn$1._class) || this.isContextual("opaque"))
      return e21.declaration = this.flowParseDeclare(this.startNode()), e21.default = false, this.finishNode(e21, "DeclareExportDeclaration");
    if (this.match(bn$1.star) || this.match(bn$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
      return (e21 = this.parseExport(e21)).type === "ExportNamedDeclaration" && (e21.type = "ExportDeclaration", e21.default = false, delete e21.exportKind), e21.type = "Declare" + e21.type, e21;
    throw this.unexpected();
  }
  flowParseDeclareModuleExports(e21) {
    return this.next(), this.expectContextual("exports"), e21.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e21, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(e21) {
    return this.next(), this.flowParseTypeAlias(e21), e21.type = "DeclareTypeAlias", e21;
  }
  flowParseDeclareOpaqueType(e21) {
    return this.next(), this.flowParseOpaqueType(e21, true), e21.type = "DeclareOpaqueType", e21;
  }
  flowParseDeclareInterface(e21) {
    return this.next(), this.flowParseInterfaceish(e21), this.finishNode(e21, "DeclareInterface");
  }
  flowParseInterfaceish(e21, t2 = false) {
    if (e21.id = this.flowParseRestrictedIdentifier(!t2, true), this.scope.declareName(e21.id.name, t2 ? 17 : 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.extends = [], e21.implements = [], e21.mixins = [], this.eat(bn$1._extends))
      do {
        e21.extends.push(this.flowParseInterfaceExtends());
      } while (!t2 && this.eat(bn$1.comma));
    if (this.isContextual("mixins")) {
      this.next();
      do {
        e21.mixins.push(this.flowParseInterfaceExtends());
      } while (this.eat(bn$1.comma));
    }
    if (this.isContextual("implements")) {
      this.next();
      do {
        e21.implements.push(this.flowParseInterfaceExtends());
      } while (this.eat(bn$1.comma));
    }
    e21.body = this.flowParseObjectType({allowStatic: t2, allowExact: false, allowSpread: false, allowProto: t2, allowInexact: false});
  }
  flowParseInterfaceExtends() {
    const e21 = this.startNode();
    return e21.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterInstantiation() : e21.typeParameters = null, this.finishNode(e21, "InterfaceExtends");
  }
  flowParseInterface(e21) {
    return this.flowParseInterfaceish(e21), this.finishNode(e21, "InterfaceDeclaration");
  }
  checkNotUnderscore(e21) {
    e21 === "_" && this.raise(this.state.start, Lo$1.UnexpectedReservedUnderscore);
  }
  checkReservedType(e21, t2, s2) {
    ko$1.has(e21) && this.raise(t2, s2 ? Lo$1.AssignReservedType : Lo$1.UnexpectedReservedType, e21);
  }
  flowParseRestrictedIdentifier(e21, t2) {
    return this.checkReservedType(this.state.value, this.state.start, t2), this.parseIdentifier(e21);
  }
  flowParseTypeAlias(e21) {
    return e21.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e21.id.name, 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.right = this.flowParseTypeInitialiser(bn$1.eq), this.semicolon(), this.finishNode(e21, "TypeAlias");
  }
  flowParseOpaqueType(e21, t2) {
    return this.expectContextual("type"), e21.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e21.id.name, 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.supertype = null, this.match(bn$1.colon) && (e21.supertype = this.flowParseTypeInitialiser(bn$1.colon)), e21.impltype = null, t2 || (e21.impltype = this.flowParseTypeInitialiser(bn$1.eq)), this.semicolon(), this.finishNode(e21, "OpaqueType");
  }
  flowParseTypeParameter(e21 = false) {
    const t2 = this.state.start, s2 = this.startNode(), r2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
    return s2.name = i2.name, s2.variance = r2, s2.bound = i2.typeAnnotation, this.match(bn$1.eq) ? (this.eat(bn$1.eq), s2.default = this.flowParseType()) : e21 && this.raise(t2, Lo$1.MissingTypeParamDefault), this.finishNode(s2, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const e21 = this.state.inType, t2 = this.startNode();
    t2.params = [], this.state.inType = true, this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected();
    let s2 = false;
    do {
      const e22 = this.flowParseTypeParameter(s2);
      t2.params.push(e22), e22.default && (s2 = true), this.isRelational(">") || this.expect(bn$1.comma);
    } while (!this.isRelational(">"));
    return this.expectRelational(">"), this.state.inType = e21, this.finishNode(t2, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const e21 = this.startNode(), t2 = this.state.inType;
    e21.params = [], this.state.inType = true, this.expectRelational("<");
    const s2 = this.state.noAnonFunctionType;
    for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
      e21.params.push(this.flowParseType()), this.isRelational(">") || this.expect(bn$1.comma);
    return this.state.noAnonFunctionType = s2, this.expectRelational(">"), this.state.inType = t2, this.finishNode(e21, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const e21 = this.startNode(), t2 = this.state.inType;
    for (e21.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
      e21.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(bn$1.comma);
    return this.expectRelational(">"), this.state.inType = t2, this.finishNode(e21, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const e21 = this.startNode();
    if (this.expectContextual("interface"), e21.extends = [], this.eat(bn$1._extends))
      do {
        e21.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(bn$1.comma));
    return e21.body = this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false}), this.finishNode(e21, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(bn$1.num) || this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
  }
  flowParseObjectTypeIndexer(e21, t2, s2) {
    return e21.static = t2, this.lookahead().type === bn$1.colon ? (e21.id = this.flowParseObjectPropertyKey(), e21.key = this.flowParseTypeInitialiser()) : (e21.id = null, e21.key = this.flowParseType()), this.expect(bn$1.bracketR), e21.value = this.flowParseTypeInitialiser(), e21.variance = s2, this.finishNode(e21, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(e21, t2) {
    return e21.static = t2, e21.id = this.flowParseObjectPropertyKey(), this.expect(bn$1.bracketR), this.expect(bn$1.bracketR), this.isRelational("<") || this.match(bn$1.parenL) ? (e21.method = true, e21.optional = false, e21.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e21.start, e21.loc.start))) : (e21.method = false, this.eat(bn$1.question) && (e21.optional = true), e21.value = this.flowParseTypeInitialiser()), this.finishNode(e21, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(e21) {
    for (e21.params = [], e21.rest = null, e21.typeParameters = null, e21.this = null, this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(bn$1.parenL), this.match(bn$1._this) && (e21.this = this.flowParseFunctionTypeParam(true), e21.this.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
      e21.params.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
    return this.eat(bn$1.ellipsis) && (e21.rest = this.flowParseFunctionTypeParam(false)), this.expect(bn$1.parenR), e21.returnType = this.flowParseTypeInitialiser(), this.finishNode(e21, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(e21, t2) {
    const s2 = this.startNode();
    return e21.static = t2, e21.value = this.flowParseObjectTypeMethodish(s2), this.finishNode(e21, "ObjectTypeCallProperty");
  }
  flowParseObjectType({allowStatic: e21, allowExact: t2, allowSpread: s2, allowProto: r2, allowInexact: i2}) {
    const a2 = this.state.inType;
    this.state.inType = true;
    const n2 = this.startNode();
    let o2, u2;
    n2.callProperties = [], n2.properties = [], n2.indexers = [], n2.internalSlots = [];
    let h2 = false;
    for (t2 && this.match(bn$1.braceBarL) ? (this.expect(bn$1.braceBarL), o2 = bn$1.braceBarR, u2 = true) : (this.expect(bn$1.braceL), o2 = bn$1.braceR, u2 = false), n2.exact = u2; !this.match(o2); ) {
      let t3 = false, a3 = null, o3 = null;
      const c3 = this.startNode();
      if (r2 && this.isContextual("proto")) {
        const t4 = this.lookahead();
        t4.type !== bn$1.colon && t4.type !== bn$1.question && (this.next(), a3 = this.state.start, e21 = false);
      }
      if (e21 && this.isContextual("static")) {
        const e22 = this.lookahead();
        e22.type !== bn$1.colon && e22.type !== bn$1.question && (this.next(), t3 = true);
      }
      const p2 = this.flowParseVariance();
      if (this.eat(bn$1.bracketL))
        a3 != null && this.unexpected(a3), this.eat(bn$1.bracketL) ? (p2 && this.unexpected(p2.start), n2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, t3))) : n2.indexers.push(this.flowParseObjectTypeIndexer(c3, t3, p2));
      else if (this.match(bn$1.parenL) || this.isRelational("<"))
        a3 != null && this.unexpected(a3), p2 && this.unexpected(p2.start), n2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, t3));
      else {
        let e22 = "init";
        if (this.isContextual("get") || this.isContextual("set")) {
          const t4 = this.lookahead();
          t4.type !== bn$1.name && t4.type !== bn$1.string && t4.type !== bn$1.num || (e22 = this.state.value, this.next());
        }
        const r3 = this.flowParseObjectTypeProperty(c3, t3, a3, p2, e22, s2, i2 != null ? i2 : !u2);
        r3 === null ? (h2 = true, o3 = this.state.lastTokStart) : n2.properties.push(r3);
      }
      this.flowObjectTypeSemicolon(), !o3 || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.raise(o3, Lo$1.UnexpectedExplicitInexactInObject);
    }
    this.expect(o2), s2 && (n2.inexact = h2);
    const c2 = this.finishNode(n2, "ObjectTypeAnnotation");
    return this.state.inType = a2, c2;
  }
  flowParseObjectTypeProperty(e21, t2, s2, r2, i2, a2, n2) {
    if (this.eat(bn$1.ellipsis)) {
      return this.match(bn$1.comma) || this.match(bn$1.semi) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) ? (a2 ? n2 || this.raise(this.state.lastTokStart, Lo$1.InexactInsideExact) : this.raise(this.state.lastTokStart, Lo$1.InexactInsideNonObject), r2 && this.raise(r2.start, Lo$1.InexactVariance), null) : (a2 || this.raise(this.state.lastTokStart, Lo$1.UnexpectedSpreadType), s2 != null && this.unexpected(s2), r2 && this.raise(r2.start, Lo$1.SpreadVariance), e21.argument = this.flowParseType(), this.finishNode(e21, "ObjectTypeSpreadProperty"));
    }
    {
      e21.key = this.flowParseObjectPropertyKey(), e21.static = t2, e21.proto = s2 != null, e21.kind = i2;
      let n3 = false;
      return this.isRelational("<") || this.match(bn$1.parenL) ? (e21.method = true, s2 != null && this.unexpected(s2), r2 && this.unexpected(r2.start), e21.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e21.start, e21.loc.start)), i2 !== "get" && i2 !== "set" || this.flowCheckGetterSetterParams(e21), !a2 && e21.key.name === "constructor" && e21.value.this && this.raise(e21.value.this.start, Lo$1.ThisParamBannedInConstructor)) : (i2 !== "init" && this.unexpected(), e21.method = false, this.eat(bn$1.question) && (n3 = true), e21.value = this.flowParseTypeInitialiser(), e21.variance = r2), e21.optional = n3, this.finishNode(e21, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(e21) {
    const t2 = e21.kind === "get" ? 0 : 1, s2 = e21.start, r2 = e21.value.params.length + (e21.value.rest ? 1 : 0);
    e21.value.this && this.raise(e21.value.this.start, e21.kind === "get" ? Lo$1.GetterMayNotHaveThisParam : Lo$1.SetterMayNotHaveThisParam), r2 !== t2 && (e21.kind === "get" ? this.raise(s2, Rn$1.BadGetterArity) : this.raise(s2, Rn$1.BadSetterArity)), e21.kind === "set" && e21.value.rest && this.raise(s2, Rn$1.BadSetterRestParameter);
  }
  flowObjectTypeSemicolon() {
    this.eat(bn$1.semi) || this.eat(bn$1.comma) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(e21, t2, s2) {
    e21 = e21 || this.state.start, t2 = t2 || this.state.startLoc;
    let r2 = s2 || this.flowParseRestrictedIdentifier(true);
    for (; this.eat(bn$1.dot); ) {
      const s3 = this.startNodeAt(e21, t2);
      s3.qualification = r2, s3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(s3, "QualifiedTypeIdentifier");
    }
    return r2;
  }
  flowParseGenericType(e21, t2, s2) {
    const r2 = this.startNodeAt(e21, t2);
    return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(e21, t2, s2), this.isRelational("<") && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const e21 = this.startNode();
    return this.expect(bn$1._typeof), e21.argument = this.flowParsePrimaryType(), this.finishNode(e21, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const e21 = this.startNode();
    for (e21.types = [], this.expect(bn$1.bracketL); this.state.pos < this.length && !this.match(bn$1.bracketR) && (e21.types.push(this.flowParseType()), !this.match(bn$1.bracketR)); )
      this.expect(bn$1.comma);
    return this.expect(bn$1.bracketR), this.finishNode(e21, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(e21) {
    let t2 = null, s2 = false, r2 = null;
    const i2 = this.startNode(), a2 = this.lookahead(), n2 = this.state.type === bn$1._this;
    return a2.type === bn$1.colon || a2.type === bn$1.question ? (n2 && !e21 && this.raise(i2.start, Lo$1.ThisParamMustBeFirst), t2 = this.parseIdentifier(n2), this.eat(bn$1.question) && (s2 = true, n2 && this.raise(i2.start, Lo$1.ThisParamMayNotBeOptional)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), i2.name = t2, i2.optional = s2, i2.typeAnnotation = r2, this.finishNode(i2, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(e21) {
    const t2 = this.startNodeAt(e21.start, e21.loc.start);
    return t2.name = null, t2.optional = false, t2.typeAnnotation = e21, this.finishNode(t2, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(e21 = []) {
    let t2 = null, s2 = null;
    for (this.match(bn$1._this) && (s2 = this.flowParseFunctionTypeParam(true), s2.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
      e21.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
    return this.eat(bn$1.ellipsis) && (t2 = this.flowParseFunctionTypeParam(false)), {params: e21, rest: t2, _this: s2};
  }
  flowIdentToTypeAnnotation(e21, t2, s2, r2) {
    switch (r2.name) {
      case "any":
        return this.finishNode(s2, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(s2, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(s2, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(s2, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(s2, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(s2, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(s2, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(r2.name), this.flowParseGenericType(e21, t2, r2);
    }
  }
  flowParsePrimaryType() {
    const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.startNode();
    let r2, i2, a2 = false;
    const n2 = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case bn$1.name:
        return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e21, t2, s2, this.parseIdentifier());
      case bn$1.braceL:
        return this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true});
      case bn$1.braceBarL:
        return this.flowParseObjectType({allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false});
      case bn$1.bracketL:
        return this.state.noAnonFunctionType = false, i2 = this.flowParseTupleType(), this.state.noAnonFunctionType = n2, i2;
      case bn$1.relational:
        if (this.state.value === "<")
          return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(bn$1.parenL), r2 = this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
        break;
      case bn$1.parenL:
        if (this.next(), !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis))
          if (this.match(bn$1.name) || this.match(bn$1._this)) {
            const e22 = this.lookahead().type;
            a2 = e22 !== bn$1.question && e22 !== bn$1.colon;
          } else
            a2 = true;
        if (a2) {
          if (this.state.noAnonFunctionType = false, i2 = this.flowParseType(), this.state.noAnonFunctionType = n2, this.state.noAnonFunctionType || !(this.match(bn$1.comma) || this.match(bn$1.parenR) && this.lookahead().type === bn$1.arrow))
            return this.expect(bn$1.parenR), i2;
          this.eat(bn$1.comma);
        }
        return r2 = i2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i2)]) : this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
      case bn$1.string:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case bn$1._true:
      case bn$1._false:
        return s2.value = this.match(bn$1._true), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
      case bn$1.plusMin:
        if (this.state.value === "-") {
          if (this.next(), this.match(bn$1.num))
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
          if (this.match(bn$1.bigint))
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
          throw this.raise(this.state.start, Lo$1.UnexpectedSubtractionOperand);
        }
        throw this.unexpected();
      case bn$1.num:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case bn$1.bigint:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case bn$1._void:
        return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
      case bn$1._null:
        return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
      case bn$1._this:
        return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
      case bn$1.star:
        return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
      default:
        if (this.state.type.keyword === "typeof")
          return this.flowParseTypeofType();
        if (this.state.type.keyword) {
          const e22 = this.state.type.label;
          return this.next(), super.createIdentifier(s2, e22);
        }
    }
    throw this.unexpected();
  }
  flowParsePostfixType() {
    const e21 = this.state.start, t2 = this.state.startLoc;
    let s2 = this.flowParsePrimaryType(), r2 = false;
    for (; (this.match(bn$1.bracketL) || this.match(bn$1.questionDot)) && !this.canInsertSemicolon(); ) {
      const i2 = this.startNodeAt(e21, t2), a2 = this.eat(bn$1.questionDot);
      r2 = r2 || a2, this.expect(bn$1.bracketL), !a2 && this.match(bn$1.bracketR) ? (i2.elementType = s2, this.next(), s2 = this.finishNode(i2, "ArrayTypeAnnotation")) : (i2.objectType = s2, i2.indexType = this.flowParseType(), this.expect(bn$1.bracketR), r2 ? (i2.optional = a2, s2 = this.finishNode(i2, "OptionalIndexedAccessType")) : s2 = this.finishNode(i2, "IndexedAccessType"));
    }
    return s2;
  }
  flowParsePrefixType() {
    const e21 = this.startNode();
    return this.eat(bn$1.question) ? (e21.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e21, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    const e21 = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(bn$1.arrow)) {
      const t2 = this.startNodeAt(e21.start, e21.loc.start);
      return t2.params = [this.reinterpretTypeAsFunctionTypeParam(e21)], t2.rest = null, t2.this = null, t2.returnType = this.flowParseType(), t2.typeParameters = null, this.finishNode(t2, "FunctionTypeAnnotation");
    }
    return e21;
  }
  flowParseIntersectionType() {
    const e21 = this.startNode();
    this.eat(bn$1.bitwiseAND);
    const t2 = this.flowParseAnonFunctionWithoutParens();
    for (e21.types = [t2]; this.eat(bn$1.bitwiseAND); )
      e21.types.push(this.flowParseAnonFunctionWithoutParens());
    return e21.types.length === 1 ? t2 : this.finishNode(e21, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const e21 = this.startNode();
    this.eat(bn$1.bitwiseOR);
    const t2 = this.flowParseIntersectionType();
    for (e21.types = [t2]; this.eat(bn$1.bitwiseOR); )
      e21.types.push(this.flowParseIntersectionType());
    return e21.types.length === 1 ? t2 : this.finishNode(e21, "UnionTypeAnnotation");
  }
  flowParseType() {
    const e21 = this.state.inType;
    this.state.inType = true;
    const t2 = this.flowParseUnionType();
    return this.state.inType = e21, t2;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === bn$1.name && this.state.value === "_") {
      const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.parseIdentifier();
      return this.flowParseGenericType(e21, t2, s2);
    }
    return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    const e21 = this.startNode();
    return e21.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e21, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(e21) {
    const t2 = e21 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(bn$1.colon) && (t2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t2)), t2;
  }
  typeCastToParameter(e21) {
    return e21.expression.typeAnnotation = e21.typeAnnotation, this.resetEndLocation(e21.expression, e21.typeAnnotation.end, e21.typeAnnotation.loc.end), e21.expression;
  }
  flowParseVariance() {
    let e21 = null;
    return this.match(bn$1.plusMin) && (e21 = this.startNode(), this.state.value === "+" ? e21.kind = "plus" : e21.kind = "minus", this.next(), this.finishNode(e21, "Variance")), e21;
  }
  parseFunctionBody(e21, t2, s2 = false) {
    return t2 ? this.forwardNoArrowParamsConversionAt(e21, () => super.parseFunctionBody(e21, true, s2)) : super.parseFunctionBody(e21, false, s2);
  }
  parseFunctionBodyAndFinish(e21, t2, s2 = false) {
    if (this.match(bn$1.colon)) {
      const t3 = this.startNode();
      [t3.typeAnnotation, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), e21.returnType = t3.typeAnnotation ? this.finishNode(t3, "TypeAnnotation") : null;
    }
    super.parseFunctionBodyAndFinish(e21, t2, s2);
  }
  parseStatement(e21, t2) {
    if (this.state.strict && this.match(bn$1.name) && this.state.value === "interface") {
      const e22 = this.lookahead();
      if (e22.type === bn$1.name || oo$1(e22.value)) {
        const e23 = this.startNode();
        return this.next(), this.flowParseInterface(e23);
      }
    } else if (this.shouldParseEnums() && this.isContextual("enum")) {
      const e22 = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(e22);
    }
    const s2 = super.parseStatement(e21, t2);
    return this.flowPragma !== void 0 || this.isValidDirective(s2) || (this.flowPragma = null), s2;
  }
  parseExpressionStatement(e21, t2) {
    if (t2.type === "Identifier") {
      if (t2.name === "declare") {
        if (this.match(bn$1._class) || this.match(bn$1.name) || this.match(bn$1._function) || this.match(bn$1._var) || this.match(bn$1._export))
          return this.flowParseDeclare(e21);
      } else if (this.match(bn$1.name)) {
        if (t2.name === "interface")
          return this.flowParseInterface(e21);
        if (t2.name === "type")
          return this.flowParseTypeAlias(e21);
        if (t2.name === "opaque")
          return this.flowParseOpaqueType(e21, false);
      }
    }
    return super.parseExpressionStatement(e21, t2);
  }
  shouldParseExportDeclaration() {
    return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    return (!this.match(bn$1.name) || !(this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) && super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual("enum")) {
      const e21 = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(e21);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(e21, t2, s2, r2) {
    if (!this.match(bn$1.question))
      return e21;
    if (this.state.maybeInArrowParameters) {
      const t3 = this.lookaheadCharCode();
      if (t3 === 44 || t3 === 61 || t3 === 58 || t3 === 41)
        return this.setOptionalParametersError(r2), e21;
    }
    this.expect(bn$1.question);
    const i2 = this.state.clone(), a2 = this.state.noArrowAt, n2 = this.startNodeAt(t2, s2);
    let {consequent: o2, failed: u2} = this.tryParseConditionalConsequent(), [h2, c2] = this.getArrowLikeExpressions(o2);
    if (u2 || c2.length > 0) {
      const e22 = [...a2];
      if (c2.length > 0) {
        this.state = i2, this.state.noArrowAt = e22;
        for (let t3 = 0; t3 < c2.length; t3++)
          e22.push(c2[t3].start);
        ({consequent: o2, failed: u2} = this.tryParseConditionalConsequent()), [h2, c2] = this.getArrowLikeExpressions(o2);
      }
      u2 && h2.length > 1 && this.raise(i2.start, Lo$1.AmbiguousConditionalArrow), u2 && h2.length === 1 && (this.state = i2, e22.push(h2[0].start), this.state.noArrowAt = e22, {consequent: o2, failed: u2} = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = a2, this.expect(bn$1.colon), n2.test = e21, n2.consequent = o2, n2.alternate = this.forwardNoArrowParamsConversionAt(n2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(n2, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const e21 = this.parseMaybeAssignAllowIn(), t2 = !this.match(bn$1.colon);
    return this.state.noArrowParamsConversionAt.pop(), {consequent: e21, failed: t2};
  }
  getArrowLikeExpressions(e21, t2) {
    const s2 = [e21], r2 = [];
    for (; s2.length !== 0; ) {
      const e22 = s2.pop();
      e22.type === "ArrowFunctionExpression" ? (e22.typeParameters || !e22.returnType ? this.finishArrowValidation(e22) : r2.push(e22), s2.push(e22.body)) : e22.type === "ConditionalExpression" && (s2.push(e22.consequent), s2.push(e22.alternate));
    }
    return t2 ? (r2.forEach((e22) => this.finishArrowValidation(e22)), [r2, []]) : function(e22, t3) {
      const s3 = [], r3 = [];
      for (let i2 = 0; i2 < e22.length; i2++)
        (t3(e22[i2], i2, e22) ? s3 : r3).push(e22[i2]);
      return [s3, r3];
    }(r2, (e22) => e22.params.every((e23) => this.isAssignable(e23, true)));
  }
  finishArrowValidation(e21) {
    var t2;
    this.toAssignableList(e21.params, (t2 = e21.extra) == null ? void 0 : t2.trailingComma, false), this.scope.enter(6), super.checkParams(e21, false, true), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(e21, t2) {
    let s2;
    return this.state.noArrowParamsConversionAt.indexOf(e21.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s2 = t2(), this.state.noArrowParamsConversionAt.pop()) : s2 = t2(), s2;
  }
  parseParenItem(e21, t2, s2) {
    if (e21 = super.parseParenItem(e21, t2, s2), this.eat(bn$1.question) && (e21.optional = true, this.resetEndLocation(e21)), this.match(bn$1.colon)) {
      const r2 = this.startNodeAt(t2, s2);
      return r2.expression = e21, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
    }
    return e21;
  }
  assertModuleNodeAllowed(e21) {
    e21.type === "ImportDeclaration" && (e21.importKind === "type" || e21.importKind === "typeof") || e21.type === "ExportNamedDeclaration" && e21.exportKind === "type" || e21.type === "ExportAllDeclaration" && e21.exportKind === "type" || super.assertModuleNodeAllowed(e21);
  }
  parseExport(e21) {
    const t2 = super.parseExport(e21);
    return t2.type !== "ExportNamedDeclaration" && t2.type !== "ExportAllDeclaration" || (t2.exportKind = t2.exportKind || "value"), t2;
  }
  parseExportDeclaration(e21) {
    if (this.isContextual("type")) {
      e21.exportKind = "type";
      const t2 = this.startNode();
      return this.next(), this.match(bn$1.braceL) ? (e21.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(e21), null) : this.flowParseTypeAlias(t2);
    }
    if (this.isContextual("opaque")) {
      e21.exportKind = "type";
      const t2 = this.startNode();
      return this.next(), this.flowParseOpaqueType(t2, false);
    }
    if (this.isContextual("interface")) {
      e21.exportKind = "type";
      const t2 = this.startNode();
      return this.next(), this.flowParseInterface(t2);
    }
    if (this.shouldParseEnums() && this.isContextual("enum")) {
      e21.exportKind = "value";
      const t2 = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(t2);
    }
    return super.parseExportDeclaration(e21);
  }
  eatExportStar(e21) {
    return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== bn$1.star) && (e21.exportKind = "type", this.next(), this.next(), true);
  }
  maybeParseExportNamespaceSpecifier(e21) {
    const t2 = this.state.start, s2 = super.maybeParseExportNamespaceSpecifier(e21);
    return s2 && e21.exportKind === "type" && this.unexpected(t2), s2;
  }
  parseClassId(e21, t2, s2) {
    super.parseClassId(e21, t2, s2), this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(e21, t2, s2) {
    const r2 = this.state.start;
    if (this.isContextual("declare")) {
      if (this.parseClassMemberFromModifier(e21, t2))
        return;
      t2.declare = true;
    }
    super.parseClassMember(e21, t2, s2), t2.declare && (t2.type !== "ClassProperty" && t2.type !== "ClassPrivateProperty" && t2.type !== "PropertyDefinition" ? this.raise(r2, Lo$1.DeclareClassElement) : t2.value && this.raise(t2.value.start, Lo$1.DeclareClassFieldInitializer));
  }
  isIterator(e21) {
    return e21 === "iterator" || e21 === "asyncIterator";
  }
  readIterator() {
    const e21 = super.readWord1(), t2 = "@@" + e21;
    this.isIterator(e21) && this.state.inType || this.raise(this.state.pos, Rn$1.InvalidIdentifier, t2), this.finishToken(bn$1.name, t2);
  }
  getTokenFromCode(e21) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    return e21 === 123 && t2 === 124 ? this.finishOp(bn$1.braceBarL, 2) : !this.state.inType || e21 !== 62 && e21 !== 60 ? this.state.inType && e21 === 63 ? t2 === 46 ? this.finishOp(bn$1.questionDot, 2) : this.finishOp(bn$1.question, 1) : function(e22, t3) {
      return e22 === 64 && t3 === 64;
    }(e21, t2) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e21) : this.finishOp(bn$1.relational, 1);
  }
  isAssignable(e21, t2) {
    return e21.type === "TypeCastExpression" ? this.isAssignable(e21.expression, t2) : super.isAssignable(e21, t2);
  }
  toAssignable(e21, t2 = false) {
    return e21.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(e21), t2) : super.toAssignable(e21, t2);
  }
  toAssignableList(e21, t2, s2) {
    for (let t3 = 0; t3 < e21.length; t3++) {
      const s3 = e21[t3];
      (s3 == null ? void 0 : s3.type) === "TypeCastExpression" && (e21[t3] = this.typeCastToParameter(s3));
    }
    return super.toAssignableList(e21, t2, s2);
  }
  toReferencedList(e21, t2) {
    for (let r2 = 0; r2 < e21.length; r2++) {
      var s2;
      const i2 = e21[r2];
      !i2 || i2.type !== "TypeCastExpression" || (s2 = i2.extra) != null && s2.parenthesized || !(e21.length > 1) && t2 || this.raise(i2.typeAnnotation.start, Lo$1.TypeCastInPattern);
    }
    return e21;
  }
  parseArrayLike(e21, t2, s2, r2) {
    const i2 = super.parseArrayLike(e21, t2, s2, r2);
    return t2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
  }
  checkLVal(e21, ...t2) {
    if (e21.type !== "TypeCastExpression")
      return super.checkLVal(e21, ...t2);
  }
  parseClassProperty(e21) {
    return this.match(bn$1.colon) && (e21.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e21);
  }
  parseClassPrivateProperty(e21) {
    return this.match(bn$1.colon) && (e21.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e21);
  }
  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(bn$1.colon) || super.isClassProperty();
  }
  isNonstaticConstructor(e21) {
    return !this.match(bn$1.colon) && super.isNonstaticConstructor(e21);
  }
  pushClassMethod(e21, t2, s2, r2, i2, a2) {
    if (t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e21, t2, s2, r2, i2, a2), t2.params && i2) {
      const e22 = t2.params;
      e22.length > 0 && this.isThisParam(e22[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
    } else if (t2.type === "MethodDefinition" && i2 && t2.value.params) {
      const e22 = t2.value.params;
      e22.length > 0 && this.isThisParam(e22[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
    }
  }
  pushClassPrivateMethod(e21, t2, s2, r2) {
    t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e21, t2, s2, r2);
  }
  parseClassSuper(e21) {
    if (super.parseClassSuper(e21), e21.superClass && this.isRelational("<") && (e21.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
      this.next();
      const t2 = e21.implements = [];
      do {
        const e22 = this.startNode();
        e22.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? e22.typeParameters = this.flowParseTypeParameterInstantiation() : e22.typeParameters = null, t2.push(this.finishNode(e22, "ClassImplements"));
      } while (this.eat(bn$1.comma));
    }
  }
  checkGetterSetterParams(e21) {
    super.checkGetterSetterParams(e21);
    const t2 = this.getObjectOrClassMethodParams(e21);
    if (t2.length > 0) {
      const s2 = t2[0];
      this.isThisParam(s2) && e21.kind === "get" ? this.raise(s2.start, Lo$1.GetterMayNotHaveThisParam) : this.isThisParam(s2) && this.raise(s2.start, Lo$1.SetterMayNotHaveThisParam);
    }
  }
  parsePropertyName(e21, t2) {
    const s2 = this.flowParseVariance(), r2 = super.parsePropertyName(e21, t2);
    return e21.variance = s2, r2;
  }
  parseObjPropValue(e21, t2, s2, r2, i2, a2, n2, o2) {
    let u2;
    e21.variance && this.unexpected(e21.variance.start), delete e21.variance, this.isRelational("<") && !n2 && (u2 = this.flowParseTypeParameterDeclaration(), this.match(bn$1.parenL) || this.unexpected()), super.parseObjPropValue(e21, t2, s2, r2, i2, a2, n2, o2), u2 && ((e21.value || e21).typeParameters = u2);
  }
  parseAssignableListItemTypes(e21) {
    return this.eat(bn$1.question) && (e21.type !== "Identifier" && this.raise(e21.start, Lo$1.PatternIsOptional), this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamMayNotBeOptional), e21.optional = true), this.match(bn$1.colon) ? e21.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamAnnotationRequired), this.match(bn$1.eq) && this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamNoDefault), this.resetEndLocation(e21), e21;
  }
  parseMaybeDefault(e21, t2, s2) {
    const r2 = super.parseMaybeDefault(e21, t2, s2);
    return r2.type === "AssignmentPattern" && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, Lo$1.TypeBeforeInitializer), r2;
  }
  shouldParseDefaultImport(e21) {
    return Oo$1(e21) ? Mo(this.state) : super.shouldParseDefaultImport(e21);
  }
  parseImportSpecifierLocal(e21, t2, s2, r2) {
    t2.local = Oo$1(e21) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e21.specifiers.push(this.finishNode(t2, s2));
  }
  maybeParseDefaultImportSpecifier(e21) {
    e21.importKind = "value";
    let t2 = null;
    if (this.match(bn$1._typeof) ? t2 = "typeof" : this.isContextual("type") && (t2 = "type"), t2) {
      const s2 = this.lookahead();
      t2 === "type" && s2.type === bn$1.star && this.unexpected(s2.start), (Mo(s2) || s2.type === bn$1.braceL || s2.type === bn$1.star) && (this.next(), e21.importKind = t2);
    }
    return super.maybeParseDefaultImportSpecifier(e21);
  }
  parseImportSpecifier(e21) {
    const t2 = this.startNode(), s2 = this.match(bn$1.string), r2 = this.parseModuleExportName();
    let i2 = null;
    r2.type === "Identifier" && (r2.name === "type" ? i2 = "type" : r2.name === "typeof" && (i2 = "typeof"));
    let a2 = false;
    if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
      const e22 = this.parseIdentifier(true);
      i2 === null || this.match(bn$1.name) || this.state.type.keyword ? (t2.imported = r2, t2.importKind = null, t2.local = this.parseIdentifier()) : (t2.imported = e22, t2.importKind = i2, t2.local = Io$1(e22));
    } else {
      if (i2 !== null && (this.match(bn$1.name) || this.state.type.keyword))
        t2.imported = this.parseIdentifier(true), t2.importKind = i2;
      else {
        if (s2)
          throw this.raise(t2.start, Rn$1.ImportBindingIsString, r2.value);
        t2.imported = r2, t2.importKind = null;
      }
      this.eatContextual("as") ? t2.local = this.parseIdentifier() : (a2 = true, t2.local = Io$1(t2.imported));
    }
    const n2 = Oo$1(e21), o2 = Oo$1(t2);
    n2 && o2 && this.raise(t2.start, Lo$1.ImportTypeShorthandOnlyInPureImport), (n2 || o2) && this.checkReservedType(t2.local.name, t2.local.start, true), !a2 || n2 || o2 || this.checkReservedWord(t2.local.name, t2.start, true, true), this.checkLVal(t2.local, "import specifier", 9), e21.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case bn$1._this:
        return this.parseIdentifier(true);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(e21, t2) {
    const s2 = e21.kind;
    s2 !== "get" && s2 !== "set" && this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e21, t2);
  }
  parseVarId(e21, t2) {
    super.parseVarId(e21, t2), this.match(bn$1.colon) && (e21.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e21.id));
  }
  parseAsyncArrowFromCallExpression(e21, t2) {
    if (this.match(bn$1.colon)) {
      const t3 = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = true, e21.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t3;
    }
    return super.parseAsyncArrowFromCallExpression(e21, t2);
  }
  shouldParseAsyncArrow() {
    return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(e21, t2) {
    var s2;
    let r2, i2 = null;
    if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
      if (i2 = this.state.clone(), r2 = this.tryParse(() => super.parseMaybeAssign(e21, t2), i2), !r2.error)
        return r2.node;
      const {context: s3} = this.state, a3 = s3[s3.length - 1];
      a3 === $n$1.j_oTag ? s3.length -= 2 : a3 === $n$1.j_expr && (s3.length -= 1);
    }
    if ((s2 = r2) != null && s2.error || this.isRelational("<")) {
      var a2, n2;
      let s3;
      i2 = i2 || this.state.clone();
      const o2 = this.tryParse((r3) => {
        var i3;
        s3 = this.flowParseTypeParameterDeclaration();
        const a3 = this.forwardNoArrowParamsConversionAt(s3, () => {
          const r4 = super.parseMaybeAssign(e21, t2);
          return this.resetStartLocationFromNode(r4, s3), r4;
        });
        (i3 = a3.extra) != null && i3.parenthesized && r3();
        const n3 = this.maybeUnwrapTypeCastExpression(a3);
        return n3.type !== "ArrowFunctionExpression" && r3(), n3.typeParameters = s3, this.resetStartLocationFromNode(n3, s3), a3;
      }, i2);
      let u2 = null;
      if (o2.node && this.maybeUnwrapTypeCastExpression(o2.node).type === "ArrowFunctionExpression") {
        if (!o2.error && !o2.aborted)
          return o2.node.async && this.raise(s3.start, Lo$1.UnexpectedTypeParameterBeforeAsyncArrowFunction), o2.node;
        u2 = o2.node;
      }
      if ((a2 = r2) != null && a2.node)
        return this.state = r2.failState, r2.node;
      if (u2)
        return this.state = o2.failState, u2;
      if ((n2 = r2) != null && n2.thrown)
        throw r2.error;
      if (o2.thrown)
        throw o2.error;
      throw this.raise(s3.start, Lo$1.UnexpectedTokenAfterTypeParameter);
    }
    return super.parseMaybeAssign(e21, t2);
  }
  parseArrow(e21) {
    if (this.match(bn$1.colon)) {
      const t2 = this.tryParse(() => {
        const t3 = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        const s2 = this.startNode();
        return [s2.typeAnnotation, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t3, this.canInsertSemicolon() && this.unexpected(), this.match(bn$1.arrow) || this.unexpected(), s2;
      });
      if (t2.thrown)
        return null;
      t2.error && (this.state = t2.failState), e21.returnType = t2.node.typeAnnotation ? this.finishNode(t2.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(e21);
  }
  shouldParseArrow(e21) {
    return this.match(bn$1.colon) || super.shouldParseArrow(e21);
  }
  setArrowFunctionParameters(e21, t2) {
    this.state.noArrowParamsConversionAt.indexOf(e21.start) !== -1 ? e21.params = t2 : super.setArrowFunctionParameters(e21, t2);
  }
  checkParams(e21, t2, s2) {
    if (!s2 || this.state.noArrowParamsConversionAt.indexOf(e21.start) === -1) {
      for (let t3 = 0; t3 < e21.params.length; t3++)
        this.isThisParam(e21.params[t3]) && t3 > 0 && this.raise(e21.params[t3].start, Lo$1.ThisParamMustBeFirst);
      return super.checkParams(...arguments);
    }
  }
  parseParenAndDistinguishExpression(e21) {
    return super.parseParenAndDistinguishExpression(e21 && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }
  parseSubscripts(e21, t2, s2, r2) {
    if (e21.type === "Identifier" && e21.name === "async" && this.state.noArrowAt.indexOf(t2) !== -1) {
      this.next();
      const r3 = this.startNodeAt(t2, s2);
      r3.callee = e21, r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), e21 = this.finishNode(r3, "CallExpression");
    } else if (e21.type === "Identifier" && e21.name === "async" && this.isRelational("<")) {
      const i2 = this.state.clone(), a2 = this.tryParse((e22) => this.parseAsyncArrowWithTypeParameters(t2, s2) || e22(), i2);
      if (!a2.error && !a2.aborted)
        return a2.node;
      const n2 = this.tryParse(() => super.parseSubscripts(e21, t2, s2, r2), i2);
      if (n2.node && !n2.error)
        return n2.node;
      if (a2.node)
        return this.state = a2.failState, a2.node;
      if (n2.node)
        return this.state = n2.failState, n2.node;
      throw a2.error || n2.error;
    }
    return super.parseSubscripts(e21, t2, s2, r2);
  }
  parseSubscript(e21, t2, s2, r2, i2) {
    if (this.match(bn$1.questionDot) && this.isLookaheadToken_lt()) {
      if (i2.optionalChainMember = true, r2)
        return i2.stop = true, e21;
      this.next();
      const a2 = this.startNodeAt(t2, s2);
      return a2.callee = e21, a2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(bn$1.parenL), a2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), a2.optional = true, this.finishCallExpression(a2, true);
    }
    if (!r2 && this.shouldParseTypes() && this.isRelational("<")) {
      const r3 = this.startNodeAt(t2, s2);
      r3.callee = e21;
      const a2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(bn$1.parenL), r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), i2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, i2.optionalChainMember)));
      if (a2.node)
        return a2.error && (this.state = a2.failState), a2.node;
    }
    return super.parseSubscript(e21, t2, s2, r2, i2);
  }
  parseNewArguments(e21) {
    let t2 = null;
    this.shouldParseTypes() && this.isRelational("<") && (t2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e21.typeArguments = t2, super.parseNewArguments(e21);
  }
  parseAsyncArrowWithTypeParameters(e21, t2) {
    const s2 = this.startNodeAt(e21, t2);
    if (this.parseFunctionParams(s2), this.parseArrow(s2))
      return this.parseArrowExpression(s2, void 0, true);
  }
  readToken_mult_modulo(e21) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (e21 === 42 && t2 === 47 && this.state.hasFlowComment)
      return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
    super.readToken_mult_modulo(e21);
  }
  readToken_pipe_amp(e21) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    e21 !== 124 || t2 !== 125 ? super.readToken_pipe_amp(e21) : this.finishOp(bn$1.braceBarR, 2);
  }
  parseTopLevel(e21, t2) {
    const s2 = super.parseTopLevel(e21, t2);
    return this.state.hasFlowComment && this.raise(this.state.pos, Lo$1.UnterminatedFlowComment), s2;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment())
      return this.state.hasFlowComment && this.unexpected(null, Lo$1.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
    if (!this.state.hasFlowComment)
      return super.skipBlockComment();
    {
      const e21 = this.input.indexOf("*-/", this.state.pos += 2);
      if (e21 === -1)
        throw this.raise(this.state.pos - 2, Rn$1.UnterminatedComment);
      this.state.pos = e21 + 3;
    }
  }
  skipFlowComment() {
    const {pos: e21} = this.state;
    let t2 = 2;
    for (; [32, 9].includes(this.input.charCodeAt(e21 + t2)); )
      t2++;
    const s2 = this.input.charCodeAt(t2 + e21), r2 = this.input.charCodeAt(t2 + e21 + 1);
    return s2 === 58 && r2 === 58 ? t2 + 2 : this.input.slice(t2 + e21, t2 + e21 + 12) === "flow-include" ? t2 + 12 : s2 === 58 && r2 !== 58 && t2;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1)
      throw this.raise(this.state.pos, Rn$1.UnterminatedComment);
  }
  flowEnumErrorBooleanMemberNotInitialized(e21, {enumName: t2, memberName: s2}) {
    this.raise(e21, Lo$1.EnumBooleanMemberNotInitialized, s2, t2);
  }
  flowEnumErrorInvalidMemberName(e21, {enumName: t2, memberName: s2}) {
    const r2 = s2[0].toUpperCase() + s2.slice(1);
    this.raise(e21, Lo$1.EnumInvalidMemberName, s2, r2, t2);
  }
  flowEnumErrorDuplicateMemberName(e21, {enumName: t2, memberName: s2}) {
    this.raise(e21, Lo$1.EnumDuplicateMemberName, s2, t2);
  }
  flowEnumErrorInconsistentMemberValues(e21, {enumName: t2}) {
    this.raise(e21, Lo$1.EnumInconsistentMemberValues, t2);
  }
  flowEnumErrorInvalidExplicitType(e21, {enumName: t2, suppliedType: s2}) {
    return this.raise(e21, s2 === null ? Lo$1.EnumInvalidExplicitTypeUnknownSupplied : Lo$1.EnumInvalidExplicitType, t2, s2);
  }
  flowEnumErrorInvalidMemberInitializer(e21, {enumName: t2, explicitType: s2, memberName: r2}) {
    let i2 = null;
    switch (s2) {
      case "boolean":
      case "number":
      case "string":
        i2 = Lo$1.EnumInvalidMemberInitializerPrimaryType;
        break;
      case "symbol":
        i2 = Lo$1.EnumInvalidMemberInitializerSymbolType;
        break;
      default:
        i2 = Lo$1.EnumInvalidMemberInitializerUnknownType;
    }
    return this.raise(e21, i2, t2, r2, s2);
  }
  flowEnumErrorNumberMemberNotInitialized(e21, {enumName: t2, memberName: s2}) {
    this.raise(e21, Lo$1.EnumNumberMemberNotInitialized, t2, s2);
  }
  flowEnumErrorStringMemberInconsistentlyInitailized(e21, {enumName: t2}) {
    this.raise(e21, Lo$1.EnumStringMemberInconsistentlyInitailized, t2);
  }
  flowEnumMemberInit() {
    const e21 = this.state.start, t2 = () => this.match(bn$1.comma) || this.match(bn$1.braceR);
    switch (this.state.type) {
      case bn$1.num: {
        const s2 = this.parseNumericLiteral(this.state.value);
        return t2() ? {type: "number", pos: s2.start, value: s2} : {type: "invalid", pos: e21};
      }
      case bn$1.string: {
        const s2 = this.parseStringLiteral(this.state.value);
        return t2() ? {type: "string", pos: s2.start, value: s2} : {type: "invalid", pos: e21};
      }
      case bn$1._true:
      case bn$1._false: {
        const s2 = this.parseBooleanLiteral(this.match(bn$1._true));
        return t2() ? {type: "boolean", pos: s2.start, value: s2} : {type: "invalid", pos: e21};
      }
      default:
        return {type: "invalid", pos: e21};
    }
  }
  flowEnumMemberRaw() {
    const e21 = this.state.start;
    return {id: this.parseIdentifier(true), init: this.eat(bn$1.eq) ? this.flowEnumMemberInit() : {type: "none", pos: e21}};
  }
  flowEnumCheckExplicitTypeMismatch(e21, t2, s2) {
    const {explicitType: r2} = t2;
    r2 !== null && r2 !== s2 && this.flowEnumErrorInvalidMemberInitializer(e21, t2);
  }
  flowEnumMembers({enumName: e21, explicitType: t2}) {
    const s2 = new Set(), r2 = {booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: []};
    let i2 = false;
    for (; !this.match(bn$1.braceR); ) {
      if (this.eat(bn$1.ellipsis)) {
        i2 = true;
        break;
      }
      const a2 = this.startNode(), {id: n2, init: o2} = this.flowEnumMemberRaw(), u2 = n2.name;
      if (u2 === "")
        continue;
      /^[a-z]/.test(u2) && this.flowEnumErrorInvalidMemberName(n2.start, {enumName: e21, memberName: u2}), s2.has(u2) && this.flowEnumErrorDuplicateMemberName(n2.start, {enumName: e21, memberName: u2}), s2.add(u2);
      const h2 = {enumName: e21, explicitType: t2, memberName: u2};
      switch (a2.id = n2, o2.type) {
        case "boolean":
          this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "boolean"), a2.init = o2.value, r2.booleanMembers.push(this.finishNode(a2, "EnumBooleanMember"));
          break;
        case "number":
          this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "number"), a2.init = o2.value, r2.numberMembers.push(this.finishNode(a2, "EnumNumberMember"));
          break;
        case "string":
          this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "string"), a2.init = o2.value, r2.stringMembers.push(this.finishNode(a2, "EnumStringMember"));
          break;
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(o2.pos, h2);
        case "none":
          switch (t2) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(o2.pos, h2);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(o2.pos, h2);
              break;
            default:
              r2.defaultedMembers.push(this.finishNode(a2, "EnumDefaultedMember"));
          }
      }
      this.match(bn$1.braceR) || this.expect(bn$1.comma);
    }
    return {members: r2, hasUnknownMembers: i2};
  }
  flowEnumStringMembers(e21, t2, {enumName: s2}) {
    if (e21.length === 0)
      return t2;
    if (t2.length === 0)
      return e21;
    if (t2.length > e21.length) {
      for (const t3 of e21)
        this.flowEnumErrorStringMemberInconsistentlyInitailized(t3.start, {enumName: s2});
      return t2;
    }
    for (const e22 of t2)
      this.flowEnumErrorStringMemberInconsistentlyInitailized(e22.start, {enumName: s2});
    return e21;
  }
  flowEnumParseExplicitType({enumName: e21}) {
    if (this.eatContextual("of")) {
      if (!this.match(bn$1.name))
        throw this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName: e21, suppliedType: null});
      const {value: t2} = this.state;
      return this.next(), t2 !== "boolean" && t2 !== "number" && t2 !== "string" && t2 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName: e21, suppliedType: t2}), t2;
    }
    return null;
  }
  flowEnumBody(e21, {enumName: t2, nameLoc: s2}) {
    const r2 = this.flowEnumParseExplicitType({enumName: t2});
    this.expect(bn$1.braceL);
    const {members: i2, hasUnknownMembers: a2} = this.flowEnumMembers({enumName: t2, explicitType: r2});
    switch (e21.hasUnknownMembers = a2, r2) {
      case "boolean":
        return e21.explicitType = true, e21.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumBooleanBody");
      case "number":
        return e21.explicitType = true, e21.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumNumberBody");
      case "string":
        return e21.explicitType = true, e21.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, {enumName: t2}), this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody");
      case "symbol":
        return e21.members = i2.defaultedMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumSymbolBody");
      default: {
        const r3 = () => (e21.members = [], this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody"));
        e21.explicitType = false;
        const a3 = i2.booleanMembers.length, n2 = i2.numberMembers.length, o2 = i2.stringMembers.length, u2 = i2.defaultedMembers.length;
        if (a3 || n2 || o2 || u2) {
          if (a3 || n2) {
            if (!n2 && !o2 && a3 >= u2) {
              for (const e22 of i2.defaultedMembers)
                this.flowEnumErrorBooleanMemberNotInitialized(e22.start, {enumName: t2, memberName: e22.id.name});
              return e21.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumBooleanBody");
            }
            if (!a3 && !o2 && n2 >= u2) {
              for (const e22 of i2.defaultedMembers)
                this.flowEnumErrorNumberMemberNotInitialized(e22.start, {enumName: t2, memberName: e22.id.name});
              return e21.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumNumberBody");
            }
            return this.flowEnumErrorInconsistentMemberValues(s2, {enumName: t2}), r3();
          }
          return e21.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, {enumName: t2}), this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody");
        }
        return r3();
      }
    }
  }
  flowParseEnumDeclaration(e21) {
    const t2 = this.parseIdentifier();
    return e21.id = t2, e21.body = this.flowEnumBody(this.startNode(), {enumName: t2.name, nameLoc: t2.start}), this.finishNode(e21, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const e21 = this.nextTokenStart();
    if (this.input.charCodeAt(e21) === 60) {
      const t2 = this.input.charCodeAt(e21 + 1);
      return t2 !== 60 && t2 !== 61;
    }
    return false;
  }
  maybeUnwrapTypeCastExpression(e21) {
    return e21.type === "TypeCastExpression" ? e21.expression : e21;
  }
}, typescript: (e20) => class extends e20 {
  getScopeHandler() {
    return Wo;
  }
  tsIsIdentifier() {
    return this.match(bn$1.name);
  }
  tsTokenCanFollowModifier() {
    return (this.match(bn$1.bracketL) || this.match(bn$1.braceL) || this.match(bn$1.star) || this.match(bn$1.ellipsis) || this.match(bn$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    return this.next(), this.tsTokenCanFollowModifier();
  }
  tsParseModifier(e21, t2) {
    if (!this.match(bn$1.name))
      return;
    const s2 = this.state.value;
    if (e21.indexOf(s2) !== -1) {
      if (t2 && this.tsIsStartOfStaticBlocks())
        return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
        return s2;
    }
  }
  tsParseModifiers(e21, t2, s2, r2, i2) {
    const a2 = (t3, s3, r3, i3) => {
      s3 === r3 && e21[i3] && this.raise(t3, Xo.InvalidModifiersOrder, r3, i3);
    }, n2 = (t3, s3, r3, i3) => {
      (e21[r3] && s3 === i3 || e21[i3] && s3 === r3) && this.raise(t3, Xo.IncompatibleModifiers, r3, i3);
    };
    for (; ; ) {
      const o2 = this.state.start, u2 = this.tsParseModifier(t2.concat(s2 != null ? s2 : []), i2);
      if (!u2)
        break;
      Jo(u2) ? e21.accessibility ? this.raise(o2, Xo.DuplicateAccessibilityModifier) : (a2(o2, u2, u2, "override"), a2(o2, u2, u2, "static"), a2(o2, u2, u2, "readonly"), e21.accessibility = u2) : (Object.hasOwnProperty.call(e21, u2) ? this.raise(o2, Xo.DuplicateModifier, u2) : (a2(o2, u2, "static", "readonly"), a2(o2, u2, "static", "override"), a2(o2, u2, "override", "readonly"), a2(o2, u2, "abstract", "override"), n2(o2, u2, "declare", "override"), n2(o2, u2, "static", "abstract")), e21[u2] = true), s2 != null && s2.includes(u2) && this.raise(o2, r2, u2);
    }
  }
  tsIsListTerminator(e21) {
    switch (e21) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(bn$1.braceR);
      case "HeritageClauseElement":
        return this.match(bn$1.braceL);
      case "TupleElementTypes":
        return this.match(bn$1.bracketR);
      case "TypeParametersOrArguments":
        return this.isRelational(">");
    }
    throw new Error("Unreachable");
  }
  tsParseList(e21, t2) {
    const s2 = [];
    for (; !this.tsIsListTerminator(e21); )
      s2.push(t2());
    return s2;
  }
  tsParseDelimitedList(e21, t2) {
    return Go(this.tsParseDelimitedListWorker(e21, t2, true));
  }
  tsParseDelimitedListWorker(e21, t2, s2) {
    const r2 = [];
    for (; !this.tsIsListTerminator(e21); ) {
      const i2 = t2();
      if (i2 == null)
        return;
      if (r2.push(i2), !this.eat(bn$1.comma)) {
        if (this.tsIsListTerminator(e21))
          break;
        return void (s2 && this.expect(bn$1.comma));
      }
    }
    return r2;
  }
  tsParseBracketedList(e21, t2, s2, r2) {
    r2 || (s2 ? this.expect(bn$1.bracketL) : this.expectRelational("<"));
    const i2 = this.tsParseDelimitedList(e21, t2);
    return s2 ? this.expect(bn$1.bracketR) : this.expectRelational(">"), i2;
  }
  tsParseImportType() {
    const e21 = this.startNode();
    return this.expect(bn$1._import), this.expect(bn$1.parenL), this.match(bn$1.string) || this.raise(this.state.start, Xo.UnsupportedImportTypeArgument), e21.argument = this.parseExprAtom(), this.expect(bn$1.parenR), this.eat(bn$1.dot) && (e21.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSImportType");
  }
  tsParseEntityName(e21) {
    let t2 = this.parseIdentifier();
    for (; this.eat(bn$1.dot); ) {
      const s2 = this.startNodeAtNode(t2);
      s2.left = t2, s2.right = this.parseIdentifier(e21), t2 = this.finishNode(s2, "TSQualifiedName");
    }
    return t2;
  }
  tsParseTypeReference() {
    const e21 = this.startNode();
    return e21.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSTypeReference");
  }
  tsParseThisTypePredicate(e21) {
    this.next();
    const t2 = this.startNodeAtNode(e21);
    return t2.parameterName = e21, t2.typeAnnotation = this.tsParseTypeAnnotation(false), t2.asserts = false, this.finishNode(t2, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const e21 = this.startNode();
    return this.next(), this.finishNode(e21, "TSThisType");
  }
  tsParseTypeQuery() {
    const e21 = this.startNode();
    return this.expect(bn$1._typeof), this.match(bn$1._import) ? e21.exprName = this.tsParseImportType() : e21.exprName = this.tsParseEntityName(true), this.finishNode(e21, "TSTypeQuery");
  }
  tsParseTypeParameter() {
    const e21 = this.startNode();
    return e21.name = this.tsParseTypeParameterName(), e21.constraint = this.tsEatThenParseType(bn$1._extends), e21.default = this.tsEatThenParseType(bn$1.eq), this.finishNode(e21, "TSTypeParameter");
  }
  tsTryParseTypeParameters() {
    if (this.isRelational("<"))
      return this.tsParseTypeParameters();
  }
  tsParseTypeParameters() {
    const e21 = this.startNode();
    return this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected(), e21.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), e21.params.length === 0 && this.raise(e21.start, Xo.EmptyTypeParameters), this.finishNode(e21, "TSTypeParameterDeclaration");
  }
  tsTryNextParseConstantContext() {
    return this.lookahead().type === bn$1._const ? (this.next(), this.tsParseTypeReference()) : null;
  }
  tsFillSignature(e21, t2) {
    const s2 = e21 === bn$1.arrow;
    t2.typeParameters = this.tsTryParseTypeParameters(), this.expect(bn$1.parenL), t2.parameters = this.tsParseBindingListForSignature(), (s2 || this.match(e21)) && (t2.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e21));
  }
  tsParseBindingListForSignature() {
    return this.parseBindingList(bn$1.parenR, 41).map((e21) => (e21.type !== "Identifier" && e21.type !== "RestElement" && e21.type !== "ObjectPattern" && e21.type !== "ArrayPattern" && this.raise(e21.start, Xo.UnsupportedSignatureParameterKind, e21.type), e21));
  }
  tsParseTypeMemberSemicolon() {
    this.eat(bn$1.comma) || this.isLineTerminator() || this.expect(bn$1.semi);
  }
  tsParseSignatureMember(e21, t2) {
    return this.tsFillSignature(bn$1.colon, t2), this.tsParseTypeMemberSemicolon(), this.finishNode(t2, e21);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), this.eat(bn$1.name) && this.match(bn$1.colon);
  }
  tsTryParseIndexSignature(e21) {
    if (!this.match(bn$1.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
      return;
    this.expect(bn$1.bracketL);
    const t2 = this.parseIdentifier();
    t2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t2), this.expect(bn$1.bracketR), e21.parameters = [t2];
    const s2 = this.tsTryParseTypeAnnotation();
    return s2 && (e21.typeAnnotation = s2), this.tsParseTypeMemberSemicolon(), this.finishNode(e21, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(e21, t2) {
    this.eat(bn$1.question) && (e21.optional = true);
    const s2 = e21;
    if (this.match(bn$1.parenL) || this.isRelational("<")) {
      t2 && this.raise(e21.start, Xo.ReadonlyForMethodSignature);
      const r2 = s2;
      if (r2.kind && this.isRelational("<") && this.raise(this.state.pos, Xo.AccesorCannotHaveTypeParameters), this.tsFillSignature(bn$1.colon, r2), this.tsParseTypeMemberSemicolon(), r2.kind === "get")
        r2.parameters.length > 0 && (this.raise(this.state.pos, Rn$1.BadGetterArity), this.isThisParam(r2.parameters[0]) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter));
      else if (r2.kind === "set") {
        if (r2.parameters.length !== 1)
          this.raise(this.state.pos, Rn$1.BadSetterArity);
        else {
          const e22 = r2.parameters[0];
          this.isThisParam(e22) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter), e22.type === "Identifier" && e22.optional && this.raise(this.state.pos, Xo.SetAccesorCannotHaveOptionalParameter), e22.type === "RestElement" && this.raise(this.state.pos, Xo.SetAccesorCannotHaveRestParameter);
        }
        r2.typeAnnotation && this.raise(r2.typeAnnotation.start, Xo.SetAccesorCannotHaveReturnType);
      } else
        r2.kind = "method";
      return this.finishNode(r2, "TSMethodSignature");
    }
    {
      const e22 = s2;
      t2 && (e22.readonly = true);
      const r2 = this.tsTryParseTypeAnnotation();
      return r2 && (e22.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(e22, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const e21 = this.startNode();
    if (this.match(bn$1.parenL) || this.isRelational("<"))
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", e21);
    if (this.match(bn$1._new)) {
      const t3 = this.startNode();
      return this.next(), this.match(bn$1.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e21) : (e21.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e21, false));
    }
    this.tsParseModifiers(e21, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], Xo.InvalidModifierOnTypeMember);
    const t2 = this.tsTryParseIndexSignature(e21);
    return t2 || (this.parsePropertyName(e21, false), e21.computed || e21.key.type !== "Identifier" || e21.key.name !== "get" && e21.key.name !== "set" || !this.tsTokenCanFollowModifier() || (e21.kind = e21.key.name, this.parsePropertyName(e21, false)), this.tsParsePropertyOrMethodSignature(e21, !!e21.readonly));
  }
  tsParseTypeLiteral() {
    const e21 = this.startNode();
    return e21.members = this.tsParseObjectTypeMembers(), this.finishNode(e21, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(bn$1.braceL);
    const e21 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(bn$1.braceR), e21;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(bn$1.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(bn$1.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(bn$1._in))));
  }
  tsParseMappedTypeParameter() {
    const e21 = this.startNode();
    return e21.name = this.tsParseTypeParameterName(), e21.constraint = this.tsExpectThenParseType(bn$1._in), this.finishNode(e21, "TSTypeParameter");
  }
  tsParseMappedType() {
    const e21 = this.startNode();
    return this.expect(bn$1.braceL), this.match(bn$1.plusMin) ? (e21.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (e21.readonly = true), this.expect(bn$1.bracketL), e21.typeParameter = this.tsParseMappedTypeParameter(), e21.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(bn$1.bracketR), this.match(bn$1.plusMin) ? (e21.optional = this.state.value, this.next(), this.expect(bn$1.question)) : this.eat(bn$1.question) && (e21.optional = true), e21.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(bn$1.braceR), this.finishNode(e21, "TSMappedType");
  }
  tsParseTupleType() {
    const e21 = this.startNode();
    e21.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let t2 = false, s2 = null;
    return e21.elementTypes.forEach((e22) => {
      var r2;
      let {type: i2} = e22;
      !t2 || i2 === "TSRestType" || i2 === "TSOptionalType" || i2 === "TSNamedTupleMember" && e22.optional || this.raise(e22.start, Xo.OptionalTypeBeforeRequired), t2 = t2 || i2 === "TSNamedTupleMember" && e22.optional || i2 === "TSOptionalType", i2 === "TSRestType" && (i2 = (e22 = e22.typeAnnotation).type);
      const a2 = i2 === "TSNamedTupleMember";
      s2 = (r2 = s2) != null ? r2 : a2, s2 !== a2 && this.raise(e22.start, Xo.MixedLabeledAndUnlabeledElements);
    }), this.finishNode(e21, "TSTupleType");
  }
  tsParseTupleElementType() {
    const {start: e21, startLoc: t2} = this.state, s2 = this.eat(bn$1.ellipsis);
    let r2 = this.tsParseType();
    const i2 = this.eat(bn$1.question);
    if (this.eat(bn$1.colon)) {
      const e22 = this.startNodeAtNode(r2);
      e22.optional = i2, r2.type !== "TSTypeReference" || r2.typeParameters || r2.typeName.type !== "Identifier" ? (this.raise(r2.start, Xo.InvalidTupleMemberLabel), e22.label = r2) : e22.label = r2.typeName, e22.elementType = this.tsParseType(), r2 = this.finishNode(e22, "TSNamedTupleMember");
    } else if (i2) {
      const e22 = this.startNodeAtNode(r2);
      e22.typeAnnotation = r2, r2 = this.finishNode(e22, "TSOptionalType");
    }
    if (s2) {
      const s3 = this.startNodeAt(e21, t2);
      s3.typeAnnotation = r2, r2 = this.finishNode(s3, "TSRestType");
    }
    return r2;
  }
  tsParseParenthesizedType() {
    const e21 = this.startNode();
    return this.expect(bn$1.parenL), e21.typeAnnotation = this.tsParseType(), this.expect(bn$1.parenR), this.finishNode(e21, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(e21, t2) {
    const s2 = this.startNode();
    return e21 === "TSConstructorType" && (s2.abstract = !!t2, t2 && this.next(), this.next()), this.tsFillSignature(bn$1.arrow, s2), this.finishNode(s2, e21);
  }
  tsParseLiteralTypeNode() {
    const e21 = this.startNode();
    return e21.literal = (() => {
      switch (this.state.type) {
        case bn$1.num:
        case bn$1.bigint:
        case bn$1.string:
        case bn$1._true:
        case bn$1._false:
          return this.parseExprAtom();
        default:
          throw this.unexpected();
      }
    })(), this.finishNode(e21, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const e21 = this.startNode();
    return e21.literal = this.parseTemplate(false), this.finishNode(e21, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const e21 = this.tsParseThisTypeNode();
    return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e21) : e21;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case bn$1.name:
      case bn$1._void:
      case bn$1._null: {
        const e21 = this.match(bn$1._void) ? "TSVoidKeyword" : this.match(bn$1._null) ? "TSNullKeyword" : function(e22) {
          switch (e22) {
            case "any":
              return "TSAnyKeyword";
            case "boolean":
              return "TSBooleanKeyword";
            case "bigint":
              return "TSBigIntKeyword";
            case "never":
              return "TSNeverKeyword";
            case "number":
              return "TSNumberKeyword";
            case "object":
              return "TSObjectKeyword";
            case "string":
              return "TSStringKeyword";
            case "symbol":
              return "TSSymbolKeyword";
            case "undefined":
              return "TSUndefinedKeyword";
            case "unknown":
              return "TSUnknownKeyword";
            default:
              return;
          }
        }(this.state.value);
        if (e21 !== void 0 && this.lookaheadCharCode() !== 46) {
          const t2 = this.startNode();
          return this.next(), this.finishNode(t2, e21);
        }
        return this.tsParseTypeReference();
      }
      case bn$1.string:
      case bn$1.num:
      case bn$1.bigint:
      case bn$1._true:
      case bn$1._false:
        return this.tsParseLiteralTypeNode();
      case bn$1.plusMin:
        if (this.state.value === "-") {
          const e21 = this.startNode(), t2 = this.lookahead();
          if (t2.type !== bn$1.num && t2.type !== bn$1.bigint)
            throw this.unexpected();
          return e21.literal = this.parseMaybeUnary(), this.finishNode(e21, "TSLiteralType");
        }
        break;
      case bn$1._this:
        return this.tsParseThisTypeOrThisTypePredicate();
      case bn$1._typeof:
        return this.tsParseTypeQuery();
      case bn$1._import:
        return this.tsParseImportType();
      case bn$1.braceL:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case bn$1.bracketL:
        return this.tsParseTupleType();
      case bn$1.parenL:
        return this.tsParseParenthesizedType();
      case bn$1.backQuote:
        return this.tsParseTemplateLiteralType();
    }
    throw this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let e21 = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(bn$1.bracketL); )
      if (this.match(bn$1.bracketR)) {
        const t2 = this.startNodeAtNode(e21);
        t2.elementType = e21, this.expect(bn$1.bracketR), e21 = this.finishNode(t2, "TSArrayType");
      } else {
        const t2 = this.startNodeAtNode(e21);
        t2.objectType = e21, t2.indexType = this.tsParseType(), this.expect(bn$1.bracketR), e21 = this.finishNode(t2, "TSIndexedAccessType");
      }
    return e21;
  }
  tsParseTypeOperator(e21) {
    const t2 = this.startNode();
    return this.expectContextual(e21), t2.operator = e21, t2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), e21 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t2), this.finishNode(t2, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(e21) {
    switch (e21.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(e21.start, Xo.UnexpectedReadonly);
    }
  }
  tsParseInferType() {
    const e21 = this.startNode();
    this.expectContextual("infer");
    const t2 = this.startNode();
    return t2.name = this.tsParseTypeParameterName(), e21.typeParameter = this.finishNode(t2, "TSTypeParameter"), this.finishNode(e21, "TSInferType");
  }
  tsParseTypeOperatorOrHigher() {
    const e21 = ["keyof", "unique", "readonly"].find((e22) => this.isContextual(e22));
    return e21 ? this.tsParseTypeOperator(e21) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
  }
  tsParseUnionOrIntersectionType(e21, t2, s2) {
    const r2 = this.startNode(), i2 = this.eat(s2), a2 = [];
    do {
      a2.push(t2());
    } while (this.eat(s2));
    return a2.length !== 1 || i2 ? (r2.types = a2, this.finishNode(r2, e21)) : a2[0];
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), bn$1.bitwiseAND);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), bn$1.bitwiseOR);
  }
  tsIsStartOfFunctionType() {
    return !!this.isRelational("<") || this.match(bn$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (this.match(bn$1.name) || this.match(bn$1._this))
      return this.next(), true;
    if (this.match(bn$1.braceL)) {
      let e21 = 1;
      for (this.next(); e21 > 0; )
        this.match(bn$1.braceL) ? ++e21 : this.match(bn$1.braceR) && --e21, this.next();
      return true;
    }
    if (this.match(bn$1.bracketL)) {
      let e21 = 1;
      for (this.next(); e21 > 0; )
        this.match(bn$1.bracketL) ? ++e21 : this.match(bn$1.bracketR) && --e21, this.next();
      return true;
    }
    return false;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    if (this.next(), this.match(bn$1.parenR) || this.match(bn$1.ellipsis))
      return true;
    if (this.tsSkipParameterStart()) {
      if (this.match(bn$1.colon) || this.match(bn$1.comma) || this.match(bn$1.question) || this.match(bn$1.eq))
        return true;
      if (this.match(bn$1.parenR) && (this.next(), this.match(bn$1.arrow)))
        return true;
    }
    return false;
  }
  tsParseTypeOrTypePredicateAnnotation(e21) {
    return this.tsInType(() => {
      const t2 = this.startNode();
      this.expect(e21);
      const s2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (r2 && this.match(bn$1._this)) {
        let e22 = this.tsParseThisTypeOrThisTypePredicate();
        return e22.type === "TSThisType" ? (s2.parameterName = e22, s2.asserts = true, s2.typeAnnotation = null, e22 = this.finishNode(s2, "TSTypePredicate")) : (this.resetStartLocationFromNode(e22, s2), e22.asserts = true), t2.typeAnnotation = e22, this.finishNode(t2, "TSTypeAnnotation");
      }
      const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!i2)
        return r2 ? (s2.parameterName = this.parseIdentifier(), s2.asserts = r2, s2.typeAnnotation = null, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t2);
      const a2 = this.tsParseTypeAnnotation(false);
      return s2.parameterName = i2, s2.typeAnnotation = a2, s2.asserts = r2, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    return this.match(bn$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon) : void 0;
  }
  tsTryParseTypeAnnotation() {
    return this.match(bn$1.colon) ? this.tsParseTypeAnnotation() : void 0;
  }
  tsTryParseType() {
    return this.tsEatThenParseType(bn$1.colon);
  }
  tsParseTypePredicatePrefix() {
    const e21 = this.parseIdentifier();
    if (this.isContextual("is") && !this.hasPrecedingLineBreak())
      return this.next(), e21;
  }
  tsParseTypePredicateAsserts() {
    if (!this.match(bn$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak())
      return false;
    const e21 = this.state.containsEsc;
    return this.next(), !(!this.match(bn$1.name) && !this.match(bn$1._this)) && (e21 && this.raise(this.state.lastTokStart, Rn$1.InvalidEscapedReservedWord, "asserts"), true);
  }
  tsParseTypeAnnotation(e21 = true, t2 = this.startNode()) {
    return this.tsInType(() => {
      e21 && this.expect(bn$1.colon), t2.typeAnnotation = this.tsParseType();
    }), this.finishNode(t2, "TSTypeAnnotation");
  }
  tsParseType() {
    Ko(this.state.inType);
    const e21 = this.tsParseNonConditionalType();
    if (this.hasPrecedingLineBreak() || !this.eat(bn$1._extends))
      return e21;
    const t2 = this.startNodeAtNode(e21);
    return t2.checkType = e21, t2.extendsType = this.tsParseNonConditionalType(), this.expect(bn$1.question), t2.trueType = this.tsParseType(), this.expect(bn$1.colon), t2.falseType = this.tsParseType(), this.finishNode(t2, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual("abstract") && this.lookahead().type === bn$1._new;
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(bn$1._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    const e21 = this.startNode(), t2 = this.tsTryNextParseConstantContext();
    return e21.typeAnnotation = t2 || this.tsNextThenParseType(), this.expectRelational(">"), e21.expression = this.parseMaybeUnary(), this.finishNode(e21, "TSTypeAssertion");
  }
  tsParseHeritageClause(e21) {
    const t2 = this.state.start, s2 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
    return s2.length || this.raise(t2, Xo.EmptyHeritageClauseType, e21), s2;
  }
  tsParseExpressionWithTypeArguments() {
    const e21 = this.startNode();
    return e21.expression = this.tsParseEntityName(false), this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSExpressionWithTypeArguments");
  }
  tsParseInterfaceDeclaration(e21) {
    this.match(bn$1.name) ? (e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript interface declaration", 130)) : (e21.id = null, this.raise(this.state.start, Xo.MissingInterfaceName)), e21.typeParameters = this.tsTryParseTypeParameters(), this.eat(bn$1._extends) && (e21.extends = this.tsParseHeritageClause("extends"));
    const t2 = this.startNode();
    return t2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e21.body = this.finishNode(t2, "TSInterfaceBody"), this.finishNode(e21, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(e21) {
    return e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript type alias", 2), e21.typeParameters = this.tsTryParseTypeParameters(), e21.typeAnnotation = this.tsInType(() => {
      if (this.expect(bn$1.eq), this.isContextual("intrinsic") && this.lookahead().type !== bn$1.dot) {
        const e22 = this.startNode();
        return this.next(), this.finishNode(e22, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(e21, "TSTypeAliasDeclaration");
  }
  tsInNoContext(e21) {
    const t2 = this.state.context;
    this.state.context = [t2[0]];
    try {
      return e21();
    } finally {
      this.state.context = t2;
    }
  }
  tsInType(e21) {
    const t2 = this.state.inType;
    this.state.inType = true;
    try {
      return e21();
    } finally {
      this.state.inType = t2;
    }
  }
  tsEatThenParseType(e21) {
    return this.match(e21) ? this.tsNextThenParseType() : void 0;
  }
  tsExpectThenParseType(e21) {
    return this.tsDoThenParseType(() => this.expect(e21));
  }
  tsNextThenParseType() {
    return this.tsDoThenParseType(() => this.next());
  }
  tsDoThenParseType(e21) {
    return this.tsInType(() => (e21(), this.tsParseType()));
  }
  tsParseEnumMember() {
    const e21 = this.startNode();
    return e21.id = this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(bn$1.eq) && (e21.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e21, "TSEnumMember");
  }
  tsParseEnumDeclaration(e21, t2) {
    return t2 && (e21.const = true), e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript enum declaration", t2 ? 779 : 267), this.expect(bn$1.braceL), e21.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(bn$1.braceR), this.finishNode(e21, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const e21 = this.startNode();
    return this.scope.enter(0), this.expect(bn$1.braceL), this.parseBlockOrModuleBlockBody(e21.body = [], void 0, true, bn$1.braceR), this.scope.exit(), this.finishNode(e21, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(e21, t2 = false) {
    if (e21.id = this.parseIdentifier(), t2 || this.checkLVal(e21.id, "module or namespace declaration", 1024), this.eat(bn$1.dot)) {
      const t3 = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(t3, true), e21.body = t3;
    } else
      this.scope.enter(256), this.prodParam.enter(0), e21.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
    return this.finishNode(e21, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(e21) {
    return this.isContextual("global") ? (e21.global = true, e21.id = this.parseIdentifier()) : this.match(bn$1.string) ? e21.id = this.parseExprAtom() : this.unexpected(), this.match(bn$1.braceL) ? (this.scope.enter(256), this.prodParam.enter(0), e21.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e21, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(e21, t2) {
    e21.isExport = t2 || false, e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "import equals declaration", 9), this.expect(bn$1.eq);
    const s2 = this.tsParseModuleReference();
    return e21.importKind === "type" && s2.type !== "TSExternalModuleReference" && this.raise(s2.start, Xo.ImportAliasHasImportType), e21.moduleReference = s2, this.semicolon(), this.finishNode(e21, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual("require") && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
  }
  tsParseExternalModuleReference() {
    const e21 = this.startNode();
    if (this.expectContextual("require"), this.expect(bn$1.parenL), !this.match(bn$1.string))
      throw this.unexpected();
    return e21.expression = this.parseExprAtom(), this.expect(bn$1.parenR), this.finishNode(e21, "TSExternalModuleReference");
  }
  tsLookAhead(e21) {
    const t2 = this.state.clone(), s2 = e21();
    return this.state = t2, s2;
  }
  tsTryParseAndCatch(e21) {
    const t2 = this.tryParse((t3) => e21() || t3());
    if (!t2.aborted && t2.node)
      return t2.error && (this.state = t2.failState), t2.node;
  }
  tsTryParse(e21) {
    const t2 = this.state.clone(), s2 = e21();
    return s2 !== void 0 && s2 !== false ? s2 : void (this.state = t2);
  }
  tsTryParseDeclare(e21) {
    if (this.isLineTerminator())
      return;
    let t2, s2 = this.state.type;
    return this.isContextual("let") && (s2 = bn$1._var, t2 = "let"), this.tsInAmbientContext(() => {
      switch (s2) {
        case bn$1._function:
          return e21.declare = true, this.parseFunctionStatement(e21, false, true);
        case bn$1._class:
          return e21.declare = true, this.parseClass(e21, true, false);
        case bn$1._const:
          if (this.match(bn$1._const) && this.isLookaheadContextual("enum"))
            return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e21, true);
        case bn$1._var:
          return t2 = t2 || this.state.value, this.parseVarStatement(e21, t2);
        case bn$1.name: {
          const t3 = this.state.value;
          return t3 === "global" ? this.tsParseAmbientExternalModuleDeclaration(e21) : this.tsParseDeclaration(e21, t3, true);
        }
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, true);
  }
  tsParseExpressionStatement(e21, t2) {
    switch (t2.name) {
      case "declare": {
        const t3 = this.tsTryParseDeclare(e21);
        if (t3)
          return t3.declare = true, t3;
        break;
      }
      case "global":
        if (this.match(bn$1.braceL)) {
          this.scope.enter(256), this.prodParam.enter(0);
          const s2 = e21;
          return s2.global = true, s2.id = t2, s2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s2, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(e21, t2.name, false);
    }
  }
  tsParseDeclaration(e21, t2, s2) {
    switch (t2) {
      case "abstract":
        if (this.tsCheckLineTerminator(s2) && (this.match(bn$1._class) || this.match(bn$1.name)))
          return this.tsParseAbstractDeclaration(e21);
        break;
      case "enum":
        if (s2 || this.match(bn$1.name))
          return s2 && this.next(), this.tsParseEnumDeclaration(e21, false);
        break;
      case "interface":
        if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
          return this.tsParseInterfaceDeclaration(e21);
        break;
      case "module":
        if (this.tsCheckLineTerminator(s2)) {
          if (this.match(bn$1.string))
            return this.tsParseAmbientExternalModuleDeclaration(e21);
          if (this.match(bn$1.name))
            return this.tsParseModuleOrNamespaceDeclaration(e21);
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
          return this.tsParseModuleOrNamespaceDeclaration(e21);
        break;
      case "type":
        if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
          return this.tsParseTypeAliasDeclaration(e21);
    }
  }
  tsCheckLineTerminator(e21) {
    return e21 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(e21, t2) {
    if (!this.isRelational("<"))
      return;
    const s2 = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = true;
    const r2 = this.tsTryParseAndCatch(() => {
      const s3 = this.startNodeAt(e21, t2);
      return s3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s3), s3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(bn$1.arrow), s3;
    });
    return this.state.maybeInArrowParameters = s2, r2 ? this.parseArrowExpression(r2, null, true) : void 0;
  }
  tsParseTypeArguments() {
    const e21 = this.startNode();
    return e21.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e21.params.length === 0 && this.raise(e21.start, Xo.EmptyTypeArguments), this.expectRelational(">"), this.finishNode(e21, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    if (this.match(bn$1.name))
      switch (this.state.value) {
        case "abstract":
        case "declare":
        case "enum":
        case "interface":
        case "module":
        case "namespace":
        case "type":
          return true;
      }
    return false;
  }
  isExportDefaultSpecifier() {
    return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(e21, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    let i2, a2 = false, n2 = false;
    if (e21 !== void 0) {
      const t3 = {};
      this.tsParseModifiers(t3, ["public", "private", "protected", "override", "readonly"]), i2 = t3.accessibility, n2 = t3.override, a2 = t3.readonly, e21 === false && (i2 || a2 || n2) && this.raise(s2, Xo.UnexpectedParameterModifier);
    }
    const o2 = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(o2);
    const u2 = this.parseMaybeDefault(o2.start, o2.loc.start, o2);
    if (i2 || a2 || n2) {
      const e22 = this.startNodeAt(s2, r2);
      return t2.length && (e22.decorators = t2), i2 && (e22.accessibility = i2), a2 && (e22.readonly = a2), n2 && (e22.override = n2), u2.type !== "Identifier" && u2.type !== "AssignmentPattern" && this.raise(e22.start, Xo.UnsupportedParameterPropertyKind), e22.parameter = u2, this.finishNode(e22, "TSParameterProperty");
    }
    return t2.length && (o2.decorators = t2), u2;
  }
  parseFunctionBodyAndFinish(e21, t2, s2 = false) {
    this.match(bn$1.colon) && (e21.returnType = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon));
    const r2 = t2 === "FunctionDeclaration" ? "TSDeclareFunction" : t2 === "ClassMethod" ? "TSDeclareMethod" : void 0;
    r2 && !this.match(bn$1.braceL) && this.isLineTerminator() ? this.finishNode(e21, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(e21.start, Xo.DeclareFunctionHasImplementation), e21.declare) ? super.parseFunctionBodyAndFinish(e21, r2, s2) : super.parseFunctionBodyAndFinish(e21, t2, s2);
  }
  registerFunctionStatementId(e21) {
    !e21.body && e21.id ? this.checkLVal(e21.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
  }
  tsCheckForInvalidTypeCasts(e21) {
    e21.forEach((e22) => {
      (e22 == null ? void 0 : e22.type) === "TSTypeCastExpression" && this.raise(e22.typeAnnotation.start, Xo.UnexpectedTypeAnnotation);
    });
  }
  toReferencedList(e21, t2) {
    return this.tsCheckForInvalidTypeCasts(e21), e21;
  }
  parseArrayLike(...e21) {
    const t2 = super.parseArrayLike(...e21);
    return t2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t2.elements), t2;
  }
  parseSubscript(e21, t2, s2, r2, i2) {
    if (!this.hasPrecedingLineBreak() && this.match(bn$1.bang)) {
      this.state.exprAllowed = false, this.next();
      const r3 = this.startNodeAt(t2, s2);
      return r3.expression = e21, this.finishNode(r3, "TSNonNullExpression");
    }
    let a2 = false;
    if (this.match(bn$1.questionDot) && this.lookaheadCharCode() === 60) {
      if (r2)
        return i2.stop = true, e21;
      i2.optionalChainMember = a2 = true, this.next();
    }
    if (this.isRelational("<")) {
      let n2;
      const o2 = this.tsTryParseAndCatch(() => {
        if (!r2 && this.atPossibleAsyncArrow(e21)) {
          const e22 = this.tsTryParseGenericAsyncArrowFunction(t2, s2);
          if (e22)
            return e22;
        }
        const o3 = this.startNodeAt(t2, s2);
        o3.callee = e21;
        const u2 = this.tsParseTypeArguments();
        if (u2) {
          if (a2 && !this.match(bn$1.parenL) && (n2 = this.state.pos, this.unexpected()), !r2 && this.eat(bn$1.parenL))
            return o3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.tsCheckForInvalidTypeCasts(o3.arguments), o3.typeParameters = u2, i2.optionalChainMember && (o3.optional = a2), this.finishCallExpression(o3, i2.optionalChainMember);
          if (this.match(bn$1.backQuote)) {
            const r3 = this.parseTaggedTemplateExpression(e21, t2, s2, i2);
            return r3.typeParameters = u2, r3;
          }
        }
        this.unexpected();
      });
      if (n2 && this.unexpected(n2, bn$1.parenL), o2)
        return o2;
    }
    return super.parseSubscript(e21, t2, s2, r2, i2);
  }
  parseNewArguments(e21) {
    if (this.isRelational("<")) {
      const t2 = this.tsTryParseAndCatch(() => {
        const e22 = this.tsParseTypeArguments();
        return this.match(bn$1.parenL) || this.unexpected(), e22;
      });
      t2 && (e21.typeParameters = t2);
    }
    super.parseNewArguments(e21);
  }
  parseExprOp(e21, t2, s2, r2) {
    if (Go(bn$1._in.binop) > r2 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
      const i2 = this.startNodeAt(t2, s2);
      i2.expression = e21;
      const a2 = this.tsTryNextParseConstantContext();
      return i2.typeAnnotation = a2 || this.tsNextThenParseType(), this.finishNode(i2, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, t2, s2, r2);
    }
    return super.parseExprOp(e21, t2, s2, r2);
  }
  checkReservedWord(e21, t2, s2, r2) {
  }
  checkDuplicateExports() {
  }
  parseImport(e21) {
    if (e21.importKind = "value", this.match(bn$1.name) || this.match(bn$1.star) || this.match(bn$1.braceL)) {
      let t3 = this.lookahead();
      if (!this.isContextual("type") || t3.type === bn$1.comma || t3.type === bn$1.name && t3.value === "from" || t3.type === bn$1.eq || (e21.importKind = "type", this.next(), t3 = this.lookahead()), this.match(bn$1.name) && t3.type === bn$1.eq)
        return this.tsParseImportEqualsDeclaration(e21);
    }
    const t2 = super.parseImport(e21);
    return t2.importKind === "type" && t2.specifiers.length > 1 && t2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(t2.start, Xo.TypeImportCannotSpecifyDefaultAndNamed), t2;
  }
  parseExport(e21) {
    if (this.match(bn$1._import))
      return this.next(), this.isContextual("type") && this.lookaheadCharCode() !== 61 ? (e21.importKind = "type", this.next()) : e21.importKind = "value", this.tsParseImportEqualsDeclaration(e21, true);
    if (this.eat(bn$1.eq)) {
      const t2 = e21;
      return t2.expression = this.parseExpression(), this.semicolon(), this.finishNode(t2, "TSExportAssignment");
    }
    if (this.eatContextual("as")) {
      const t2 = e21;
      return this.expectContextual("namespace"), t2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t2, "TSNamespaceExportDeclaration");
    }
    return this.isContextual("type") && this.lookahead().type === bn$1.braceL ? (this.next(), e21.exportKind = "type") : e21.exportKind = "value", super.parseExport(e21);
  }
  isAbstractClass() {
    return this.isContextual("abstract") && this.lookahead().type === bn$1._class;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const e21 = this.startNode();
      return this.next(), e21.abstract = true, this.parseClass(e21, true, true), e21;
    }
    if (this.state.value === "interface") {
      const e21 = this.startNode();
      this.next();
      const t2 = this.tsParseInterfaceDeclaration(e21);
      if (t2)
        return t2;
    }
    return super.parseExportDefaultExpression();
  }
  parseStatementContent(e21, t2) {
    if (this.state.type === bn$1._const) {
      const e22 = this.lookahead();
      if (e22.type === bn$1.name && e22.value === "enum") {
        const e23 = this.startNode();
        return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e23, true);
      }
    }
    return super.parseStatementContent(e21, t2);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(e21, t2) {
    return t2.some((t3) => Jo(t3) ? e21.accessibility === t3 : !!e21[t3]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual("static") && this.lookaheadCharCode() === 123;
  }
  parseClassMember(e21, t2, s2) {
    const r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers(t2, r2, void 0, void 0, true);
    const i2 = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t2, r2) && this.raise(this.state.pos, Xo.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(e21, t2)) : this.parseClassMemberWithIsStatic(e21, t2, s2, !!t2.static);
    };
    t2.declare ? this.tsInAmbientContext(i2) : i2();
  }
  parseClassMemberWithIsStatic(e21, t2, s2, r2) {
    const i2 = this.tsTryParseIndexSignature(t2);
    if (i2)
      return e21.body.push(i2), t2.abstract && this.raise(t2.start, Xo.IndexSignatureHasAbstract), t2.accessibility && this.raise(t2.start, Xo.IndexSignatureHasAccessibility, t2.accessibility), t2.declare && this.raise(t2.start, Xo.IndexSignatureHasDeclare), void (t2.override && this.raise(t2.start, Xo.IndexSignatureHasOverride));
    !this.state.inAbstractClass && t2.abstract && this.raise(t2.start, Xo.NonAbstractClassHasAbstractMethod), t2.override && (s2.hadSuperClass || this.raise(t2.start, Xo.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(e21, t2, s2, r2);
  }
  parsePostMemberNameModifiers(e21) {
    this.eat(bn$1.question) && (e21.optional = true), e21.readonly && this.match(bn$1.parenL) && this.raise(e21.start, Xo.ClassMethodHasReadonly), e21.declare && this.match(bn$1.parenL) && this.raise(e21.start, Xo.ClassMethodHasDeclare);
  }
  parseExpressionStatement(e21, t2) {
    return (t2.type === "Identifier" ? this.tsParseExpressionStatement(e21, t2) : void 0) || super.parseExpressionStatement(e21, t2);
  }
  shouldParseExportDeclaration() {
    return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
  }
  parseConditional(e21, t2, s2, r2) {
    if (!this.state.maybeInArrowParameters || !this.match(bn$1.question))
      return super.parseConditional(e21, t2, s2, r2);
    const i2 = this.tryParse(() => super.parseConditional(e21, t2, s2));
    return i2.node ? (i2.error && (this.state = i2.failState), i2.node) : (i2.error && super.setOptionalParametersError(r2, i2.error), e21);
  }
  parseParenItem(e21, t2, s2) {
    if (e21 = super.parseParenItem(e21, t2, s2), this.eat(bn$1.question) && (e21.optional = true, this.resetEndLocation(e21)), this.match(bn$1.colon)) {
      const r2 = this.startNodeAt(t2, s2);
      return r2.expression = e21, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
    }
    return e21;
  }
  parseExportDeclaration(e21) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.eatContextual("declare");
    if (r2 && (this.isContextual("declare") || !this.shouldParseExportDeclaration()))
      throw this.raise(this.state.start, Xo.ExpectedAmbientAfterExportDeclare);
    let i2;
    return this.match(bn$1.name) && (i2 = this.tsTryParseExportDeclaration()), i2 || (i2 = super.parseExportDeclaration(e21)), i2 && (i2.type === "TSInterfaceDeclaration" || i2.type === "TSTypeAliasDeclaration" || r2) && (e21.exportKind = "type"), i2 && r2 && (this.resetStartLocation(i2, t2, s2), i2.declare = true), i2;
  }
  parseClassId(e21, t2, s2) {
    if ((!t2 || s2) && this.isContextual("implements"))
      return;
    super.parseClassId(e21, t2, s2, e21.declare ? 1024 : 139);
    const r2 = this.tsTryParseTypeParameters();
    r2 && (e21.typeParameters = r2);
  }
  parseClassPropertyAnnotation(e21) {
    !e21.optional && this.eat(bn$1.bang) && (e21.definite = true);
    const t2 = this.tsTryParseTypeAnnotation();
    t2 && (e21.typeAnnotation = t2);
  }
  parseClassProperty(e21) {
    if (this.parseClassPropertyAnnotation(e21), this.state.isAmbientContext && this.match(bn$1.eq) && this.raise(this.state.start, Xo.DeclareClassFieldHasInitializer), e21.abstract && this.match(bn$1.eq)) {
      const {key: t2} = e21;
      this.raise(this.state.start, Xo.AbstractPropertyHasInitializer, t2.type !== "Identifier" || e21.computed ? `[${this.input.slice(t2.start, t2.end)}]` : t2.name);
    }
    return super.parseClassProperty(e21);
  }
  parseClassPrivateProperty(e21) {
    return e21.abstract && this.raise(e21.start, Xo.PrivateElementHasAbstract), e21.accessibility && this.raise(e21.start, Xo.PrivateElementHasAccessibility, e21.accessibility), this.parseClassPropertyAnnotation(e21), super.parseClassPrivateProperty(e21);
  }
  pushClassMethod(e21, t2, s2, r2, i2, a2) {
    const n2 = this.tsTryParseTypeParameters();
    n2 && i2 && this.raise(n2.start, Xo.ConstructorHasTypeParameters), !t2.declare || t2.kind !== "get" && t2.kind !== "set" || this.raise(t2.start, Xo.DeclareAccessor, t2.kind), n2 && (t2.typeParameters = n2), super.pushClassMethod(e21, t2, s2, r2, i2, a2);
  }
  pushClassPrivateMethod(e21, t2, s2, r2) {
    const i2 = this.tsTryParseTypeParameters();
    i2 && (t2.typeParameters = i2), super.pushClassPrivateMethod(e21, t2, s2, r2);
  }
  parseClassSuper(e21) {
    super.parseClassSuper(e21), e21.superClass && this.isRelational("<") && (e21.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (e21.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(e21, ...t2) {
    const s2 = this.tsTryParseTypeParameters();
    s2 && (e21.typeParameters = s2), super.parseObjPropValue(e21, ...t2);
  }
  parseFunctionParams(e21, t2) {
    const s2 = this.tsTryParseTypeParameters();
    s2 && (e21.typeParameters = s2), super.parseFunctionParams(e21, t2);
  }
  parseVarId(e21, t2) {
    super.parseVarId(e21, t2), e21.id.type === "Identifier" && this.eat(bn$1.bang) && (e21.definite = true);
    const s2 = this.tsTryParseTypeAnnotation();
    s2 && (e21.id.typeAnnotation = s2, this.resetEndLocation(e21.id));
  }
  parseAsyncArrowFromCallExpression(e21, t2) {
    return this.match(bn$1.colon) && (e21.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e21, t2);
  }
  parseMaybeAssign(...e21) {
    var t2, s2, r2, i2, a2, n2, o2;
    let u2, h2, c2, p2;
    if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
      if (u2 = this.state.clone(), h2 = this.tryParse(() => super.parseMaybeAssign(...e21), u2), !h2.error)
        return h2.node;
      const {context: t3} = this.state;
      t3[t3.length - 1] === $n$1.j_oTag ? t3.length -= 2 : t3[t3.length - 1] === $n$1.j_expr && (t3.length -= 1);
    }
    if (!((t2 = h2) != null && t2.error || this.isRelational("<")))
      return super.parseMaybeAssign(...e21);
    u2 = u2 || this.state.clone();
    const l2 = this.tryParse((t3) => {
      var s3, r3;
      p2 = this.tsParseTypeParameters();
      const i3 = super.parseMaybeAssign(...e21);
      return (i3.type !== "ArrowFunctionExpression" || (s3 = i3.extra) != null && s3.parenthesized) && t3(), ((r3 = p2) == null ? void 0 : r3.params.length) !== 0 && this.resetStartLocationFromNode(i3, p2), i3.typeParameters = p2, i3;
    }, u2);
    if (!l2.error && !l2.aborted)
      return l2.node;
    if (!h2 && (Ko(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(...e21), u2), !c2.error))
      return c2.node;
    if ((s2 = h2) != null && s2.node)
      return this.state = h2.failState, h2.node;
    if (l2.node)
      return this.state = l2.failState, l2.node;
    if ((r2 = c2) != null && r2.node)
      return this.state = c2.failState, c2.node;
    if ((i2 = h2) != null && i2.thrown)
      throw h2.error;
    if (l2.thrown)
      throw l2.error;
    if ((a2 = c2) != null && a2.thrown)
      throw c2.error;
    throw ((n2 = h2) == null ? void 0 : n2.error) || l2.error || ((o2 = c2) == null ? void 0 : o2.error);
  }
  parseMaybeUnary(e21) {
    return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e21);
  }
  parseArrow(e21) {
    if (this.match(bn$1.colon)) {
      const t2 = this.tryParse((e22) => {
        const t3 = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon);
        return !this.canInsertSemicolon() && this.match(bn$1.arrow) || e22(), t3;
      });
      if (t2.aborted)
        return;
      t2.thrown || (t2.error && (this.state = t2.failState), e21.returnType = t2.node);
    }
    return super.parseArrow(e21);
  }
  parseAssignableListItemTypes(e21) {
    this.eat(bn$1.question) && (e21.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(e21.start, Xo.PatternIsOptional), e21.optional = true);
    const t2 = this.tsTryParseTypeAnnotation();
    return t2 && (e21.typeAnnotation = t2), this.resetEndLocation(e21), e21;
  }
  isAssignable(e21, t2) {
    switch (e21.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(e21.expression, t2);
      case "TSParameterProperty":
        return true;
      default:
        return super.isAssignable(e21, t2);
    }
  }
  toAssignable(e21, t2 = false) {
    switch (e21.type) {
      case "TSTypeCastExpression":
        return super.toAssignable(this.typeCastToParameter(e21), t2);
      case "TSParameterProperty":
        return super.toAssignable(e21, t2);
      case "ParenthesizedExpression":
        return this.toAssignableParenthesizedExpression(e21, t2);
      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        return e21.expression = this.toAssignable(e21.expression, t2), e21;
      default:
        return super.toAssignable(e21, t2);
    }
  }
  toAssignableParenthesizedExpression(e21, t2) {
    switch (e21.expression.type) {
      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        return e21.expression = this.toAssignable(e21.expression, t2), e21;
      default:
        return super.toAssignable(e21, t2);
    }
  }
  checkLVal(e21, t2, ...s2) {
    var r2;
    switch (e21.type) {
      case "TSTypeCastExpression":
        return;
      case "TSParameterProperty":
        return void this.checkLVal(e21.parameter, "parameter property", ...s2);
      case "TSAsExpression":
      case "TSTypeAssertion":
        if (!(s2[0] || t2 === "parenthesized expression" || (r2 = e21.extra) != null && r2.parenthesized)) {
          this.raise(e21.start, Rn$1.InvalidLhs, t2);
          break;
        }
        return void this.checkLVal(e21.expression, "parenthesized expression", ...s2);
      case "TSNonNullExpression":
        return void this.checkLVal(e21.expression, t2, ...s2);
      default:
        return void super.checkLVal(e21, t2, ...s2);
    }
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case bn$1._this:
        return this.parseIdentifier(true);
      default:
        return super.parseBindingAtom();
    }
  }
  parseMaybeDecoratorArguments(e21) {
    if (this.isRelational("<")) {
      const t2 = this.tsParseTypeArguments();
      if (this.match(bn$1.parenL)) {
        const s2 = super.parseMaybeDecoratorArguments(e21);
        return s2.typeParameters = t2, s2;
      }
      this.unexpected(this.state.start, bn$1.parenL);
    }
    return super.parseMaybeDecoratorArguments(e21);
  }
  checkCommaAfterRest(e21) {
    this.state.isAmbientContext && this.match(bn$1.comma) && this.lookaheadCharCode() === e21 ? this.next() : super.checkCommaAfterRest(e21);
  }
  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(bn$1.bang) || this.match(bn$1.colon) || super.isClassProperty();
  }
  parseMaybeDefault(...e21) {
    const t2 = super.parseMaybeDefault(...e21);
    return t2.type === "AssignmentPattern" && t2.typeAnnotation && t2.right.start < t2.typeAnnotation.start && this.raise(t2.typeAnnotation.start, Xo.TypeAnnotationAfterAssign), t2;
  }
  getTokenFromCode(e21) {
    return !this.state.inType || e21 !== 62 && e21 !== 60 ? super.getTokenFromCode(e21) : this.finishOp(bn$1.relational, 1);
  }
  reScan_lt_gt() {
    if (this.match(bn$1.relational)) {
      const e21 = this.input.charCodeAt(this.state.start);
      e21 !== 60 && e21 !== 62 || (this.state.pos -= 1, this.readToken_lt_gt(e21));
    }
  }
  toAssignableList(e21) {
    for (let t2 = 0; t2 < e21.length; t2++) {
      const s2 = e21[t2];
      if (s2)
        switch (s2.type) {
          case "TSTypeCastExpression":
            e21[t2] = this.typeCastToParameter(s2);
            break;
          case "TSAsExpression":
          case "TSTypeAssertion":
            this.state.maybeInArrowParameters ? this.raise(s2.start, Xo.UnexpectedTypeCastInParameter) : e21[t2] = this.typeCastToParameter(s2);
        }
    }
    return super.toAssignableList(...arguments);
  }
  typeCastToParameter(e21) {
    return e21.expression.typeAnnotation = e21.typeAnnotation, this.resetEndLocation(e21.expression, e21.typeAnnotation.end, e21.typeAnnotation.loc.end), e21.expression;
  }
  shouldParseArrow(e21) {
    return this.match(bn$1.colon) ? e21.every((e22) => this.isAssignable(e22, true)) : super.shouldParseArrow(e21);
  }
  shouldParseAsyncArrow() {
    return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(e21) {
    if (this.isRelational("<")) {
      const t2 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
      t2 && (e21.typeParameters = t2);
    }
    return super.jsxParseOpeningElementAfterName(e21);
  }
  getGetterSetterExpectedParamCount(e21) {
    const t2 = super.getGetterSetterExpectedParamCount(e21), s2 = this.getObjectOrClassMethodParams(e21)[0];
    return s2 && this.isThisParam(s2) ? t2 + 1 : t2;
  }
  parseCatchClauseParam() {
    const e21 = super.parseCatchClauseParam(), t2 = this.tsTryParseTypeAnnotation();
    return t2 && (e21.typeAnnotation = t2, this.resetEndLocation(e21)), e21;
  }
  tsInAmbientContext(e21) {
    const t2 = this.state.isAmbientContext;
    this.state.isAmbientContext = true;
    try {
      return e21();
    } finally {
      this.state.isAmbientContext = t2;
    }
  }
  parseClass(e21, ...t2) {
    const s2 = this.state.inAbstractClass;
    this.state.inAbstractClass = !!e21.abstract;
    try {
      return super.parseClass(e21, ...t2);
    } finally {
      this.state.inAbstractClass = s2;
    }
  }
  tsParseAbstractDeclaration(e21) {
    if (this.match(bn$1._class))
      return e21.abstract = true, this.parseClass(e21, true, false);
    if (this.isContextual("interface")) {
      if (!this.hasFollowingLineBreak())
        return e21.abstract = true, this.raise(e21.start, Xo.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(e21);
    } else
      this.unexpected(null, bn$1._class);
  }
  parseMethod(...e21) {
    const t2 = super.parseMethod(...e21);
    if (t2.abstract) {
      if (this.hasPlugin("estree") ? !!t2.value.body : !!t2.body) {
        const {key: e22} = t2;
        this.raise(t2.start, Xo.AbstractMethodHasImplementation, e22.type !== "Identifier" || t2.computed ? `[${this.input.slice(e22.start, e22.end)}]` : e22.name);
      }
    }
    return t2;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier().name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
  }
}, v8intrinsic: (e20) => class extends e20 {
  parseV8Intrinsic() {
    if (this.match(bn$1.modulo)) {
      const e21 = this.state.start, t2 = this.startNode();
      if (this.eat(bn$1.modulo), this.match(bn$1.name)) {
        const e22 = this.parseIdentifierName(this.state.start), s2 = this.createIdentifier(t2, e22);
        if (s2.type = "V8IntrinsicIdentifier", this.match(bn$1.parenL))
          return s2;
      }
      this.unexpected(e21);
    }
  }
  parseExprAtom() {
    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
  }
}, placeholders: (e20) => class extends e20 {
  parsePlaceholder(e21) {
    if (this.match(bn$1.placeholder)) {
      const t2 = this.startNode();
      return this.next(), this.assertNoSpace("Unexpected space in placeholder."), t2.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(bn$1.placeholder), this.finishPlaceholder(t2, e21);
    }
  }
  finishPlaceholder(e21, t2) {
    const s2 = !(!e21.expectedNode || e21.type !== "Placeholder");
    return e21.expectedNode = t2, s2 ? e21 : this.finishNode(e21, "Placeholder");
  }
  getTokenFromCode(e21) {
    return e21 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(bn$1.placeholder, 2) : super.getTokenFromCode(...arguments);
  }
  parseExprAtom() {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
  }
  parseIdentifier() {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
  }
  checkReservedWord(e21) {
    e21 !== void 0 && super.checkReservedWord(...arguments);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
  }
  checkLVal(e21) {
    e21.type !== "Placeholder" && super.checkLVal(...arguments);
  }
  toAssignable(e21) {
    return e21 && e21.type === "Placeholder" && e21.expectedNode === "Expression" ? (e21.expectedNode = "Pattern", e21) : super.toAssignable(...arguments);
  }
  isLet(e21) {
    if (super.isLet(e21))
      return true;
    if (!this.isContextual("let"))
      return false;
    if (e21)
      return false;
    return this.lookahead().type === bn$1.placeholder;
  }
  verifyBreakContinue(e21) {
    e21.label && e21.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
  }
  parseExpressionStatement(e21, t2) {
    if (t2.type !== "Placeholder" || t2.extra && t2.extra.parenthesized)
      return super.parseExpressionStatement(...arguments);
    if (this.match(bn$1.colon)) {
      const s2 = e21;
      return s2.label = this.finishPlaceholder(t2, "Identifier"), this.next(), s2.body = this.parseStatement("label"), this.finishNode(s2, "LabeledStatement");
    }
    return this.semicolon(), e21.name = t2.name, this.finishPlaceholder(e21, "Statement");
  }
  parseBlock() {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
  }
  parseFunctionId() {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
  }
  parseClass(e21, t2, s2) {
    const r2 = t2 ? "ClassDeclaration" : "ClassExpression";
    this.next(), this.takeDecorators(e21);
    const i2 = this.state.strict, a2 = this.parsePlaceholder("Identifier");
    if (a2)
      if (this.match(bn$1._extends) || this.match(bn$1.placeholder) || this.match(bn$1.braceL))
        e21.id = a2;
      else {
        if (s2 || !t2)
          return e21.id = null, e21.body = this.finishPlaceholder(a2, "ClassBody"), this.finishNode(e21, r2);
        this.unexpected(null, Yo.ClassNameIsRequired);
      }
    else
      this.parseClassId(e21, t2, s2);
    return this.parseClassSuper(e21), e21.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e21.superClass, i2), this.finishNode(e21, r2);
  }
  parseExport(e21) {
    const t2 = this.parsePlaceholder("Identifier");
    if (!t2)
      return super.parseExport(...arguments);
    if (!this.isContextual("from") && !this.match(bn$1.comma))
      return e21.specifiers = [], e21.source = null, e21.declaration = this.finishPlaceholder(t2, "Declaration"), this.finishNode(e21, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    const s2 = this.startNode();
    return s2.exported = t2, e21.specifiers = [this.finishNode(s2, "ExportDefaultSpecifier")], super.parseExport(e21);
  }
  isExportDefaultSpecifier() {
    if (this.match(bn$1._default)) {
      const e21 = this.nextTokenStart();
      if (this.isUnparsedContextual(e21, "from") && this.input.startsWith(bn$1.placeholder.label, this.nextTokenStartSince(e21 + 4)))
        return true;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(e21) {
    return !!(e21.specifiers && e21.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
  }
  checkExport(e21) {
    const {specifiers: t2} = e21;
    t2 != null && t2.length && (e21.specifiers = t2.filter((e22) => e22.exported.type === "Placeholder")), super.checkExport(e21), e21.specifiers = t2;
  }
  parseImport(e21) {
    const t2 = this.parsePlaceholder("Identifier");
    if (!t2)
      return super.parseImport(...arguments);
    if (e21.specifiers = [], !this.isContextual("from") && !this.match(bn$1.comma))
      return e21.source = this.finishPlaceholder(t2, "StringLiteral"), this.semicolon(), this.finishNode(e21, "ImportDeclaration");
    const s2 = this.startNodeAtNode(t2);
    if (s2.local = t2, this.finishNode(s2, "ImportDefaultSpecifier"), e21.specifiers.push(s2), this.eat(bn$1.comma)) {
      this.maybeParseStarImportSpecifier(e21) || this.parseNamedImportSpecifiers(e21);
    }
    return this.expectContextual("from"), e21.source = this.parseImportSource(), this.semicolon(), this.finishNode(e21, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
  }
}}, iu = Object.keys(ru), au = {sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true};
const nu = (e20) => e20.type === "ParenthesizedExpression" ? nu(e20.expression) : e20;
const ou = {kind: "loop"}, uu = {kind: "switch"}, hu = /[\uD800-\uDFFF]/u, cu = /in(?:stanceof)?/y;
class pu extends class extends class extends class extends class extends class extends class extends class extends class extends class {
  constructor() {
    this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
  }
  hasPlugin(e20) {
    return this.plugins.has(e20);
  }
  getPluginOption(e20, t2) {
    if (this.hasPlugin(e20))
      return this.plugins.get(e20)[t2];
  }
} {
  addComment(e20) {
    this.filename && (e20.loc.filename = this.filename), this.state.comments.push(e20);
  }
  processComment(e20) {
    const {commentStack: t2} = this.state, s2 = t2.length;
    if (s2 === 0)
      return;
    let r2 = s2 - 1;
    const i2 = t2[r2];
    i2.start === e20.end && (i2.leadingNode = e20, r2--);
    const {start: a2} = e20;
    for (; r2 >= 0; r2--) {
      const s3 = t2[r2], i3 = s3.end;
      if (!(i3 > a2)) {
        i3 === a2 && (s3.trailingNode = e20);
        break;
      }
      s3.containingNode = e20, this.finalizeComment(s3), t2.splice(r2, 1);
    }
  }
  finalizeComment(e20) {
    const {comments: t2} = e20;
    if (e20.leadingNode !== null || e20.trailingNode !== null)
      e20.leadingNode !== null && kn$1(e20.leadingNode, t2), e20.trailingNode !== null && (e20.trailingNode.leadingComments = t2);
    else {
      const {containingNode: s2, start: r2} = e20;
      if (this.input.charCodeAt(r2 - 1) === 44)
        switch (s2.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            On$1(s2, s2.properties, e20);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            On$1(s2, s2.arguments, e20);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            On$1(s2, s2.params, e20);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            On$1(s2, s2.elements, e20);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            On$1(s2, s2.specifiers, e20);
            break;
          default:
            Ln$1(s2, t2);
        }
      else
        Ln$1(s2, t2);
    }
  }
  finalizeRemainingComments() {
    const {commentStack: e20} = this.state;
    for (let t2 = e20.length - 1; t2 >= 0; t2--)
      this.finalizeComment(e20[t2]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(e20) {
    const {commentStack: t2} = this.state, {length: s2} = t2;
    if (s2 === 0)
      return;
    const r2 = t2[s2 - 1];
    r2.leadingNode === e20 && (r2.leadingNode = null);
  }
} {
  getLocationForPosition(e20) {
    let t2;
    return t2 = e20 === this.state.start ? this.state.startLoc : e20 === this.state.lastTokStart ? this.state.lastTokStartLoc : e20 === this.state.end ? this.state.endLoc : e20 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(e21, t3) {
      let s2, r2 = 1, i2 = 0;
      for (Tn$1.lastIndex = 0; (s2 = Tn$1.exec(e21)) && s2.index < t3; )
        r2++, i2 = Tn$1.lastIndex;
      return new In$1(r2, t3 - i2);
    }(this.input, e20), t2;
  }
  raise(e20, {code: t2, reasonCode: s2, template: r2}, ...i2) {
    return this.raiseWithData(e20, {code: t2, reasonCode: s2}, r2, ...i2);
  }
  raiseOverwrite(e20, {code: t2, template: s2}, ...r2) {
    const i2 = this.getLocationForPosition(e20), a2 = s2.replace(/%(\d+)/g, (e21, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
    if (this.options.errorRecovery) {
      const t3 = this.state.errors;
      for (let s3 = t3.length - 1; s3 >= 0; s3--) {
        const r3 = t3[s3];
        if (r3.pos === e20)
          return Object.assign(r3, {message: a2});
        if (r3.pos < e20)
          break;
      }
    }
    return this._raise({code: t2, loc: i2, pos: e20}, a2);
  }
  raiseWithData(e20, t2, s2, ...r2) {
    const i2 = this.getLocationForPosition(e20), a2 = s2.replace(/%(\d+)/g, (e21, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
    return this._raise(Object.assign({loc: i2, pos: e20}, t2), a2);
  }
  _raise(e20, t2) {
    const s2 = new SyntaxError(t2);
    if (Object.assign(s2, e20), this.options.errorRecovery)
      return this.isLookahead || this.state.errors.push(s2), s2;
    throw s2;
  }
} {
  constructor(e20, t2) {
    super(), this.isLookahead = void 0, this.tokens = [], this.state = new Do$1(), this.state.init(e20), this.input = t2, this.length = t2.length, this.isLookahead = false;
  }
  pushToken(e20) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(e20), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Eo$1(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(e20) {
    return !!this.match(e20) && (this.next(), true);
  }
  match(e20) {
    return this.state.type === e20;
  }
  createLookaheadState(e20) {
    return {pos: e20.pos, value: null, type: e20.type, start: e20.start, end: e20.end, lastTokEnd: e20.end, context: [this.curContext()], inType: e20.inType};
  }
  lookahead() {
    const e20 = this.state;
    this.state = this.createLookaheadState(e20), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
    const t2 = this.state;
    return this.state = e20, t2;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(e20) {
    return Sn$1.lastIndex = e20, Sn$1.test(this.input) ? Sn$1.lastIndex : e20;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  codePointAtPos(e20) {
    let t2 = this.input.charCodeAt(e20);
    if ((64512 & t2) == 55296 && ++e20 < this.input.length) {
      const s2 = this.input.charCodeAt(e20);
      (64512 & s2) == 56320 && (t2 = 65536 + ((1023 & t2) << 10) + (1023 & s2));
    }
    return t2;
  }
  setStrict(e20) {
    this.state.strict = e20, e20 && (this.state.strictErrors.forEach((e21, t2) => this.raise(t2, e21)), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    const e20 = this.curContext();
    e20.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(bn$1.eof) : e20 === $n$1.template ? this.readTmplToken() : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment() {
    let e20;
    this.isLookahead || (e20 = this.state.curPosition());
    const t2 = this.state.pos, s2 = this.input.indexOf("*/", t2 + 2);
    if (s2 === -1)
      throw this.raise(t2, Rn$1.UnterminatedComment);
    for (this.state.pos = s2 + 2, Tn$1.lastIndex = t2 + 2; Tn$1.test(this.input) && Tn$1.lastIndex <= s2; )
      ++this.state.curLine, this.state.lineStart = Tn$1.lastIndex;
    if (this.isLookahead)
      return;
    const r2 = {type: "CommentBlock", value: this.input.slice(t2 + 2, s2), start: t2, end: s2 + 2, loc: new vn$1(e20, this.state.curPosition())};
    return this.options.tokens && this.pushToken(r2), r2;
  }
  skipLineComment(e20) {
    const t2 = this.state.pos;
    let s2;
    this.isLookahead || (s2 = this.state.curPosition());
    let r2 = this.input.charCodeAt(this.state.pos += e20);
    if (this.state.pos < this.length)
      for (; !wn$1(r2) && ++this.state.pos < this.length; )
        r2 = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead)
      return;
    const i2 = this.state.pos, a2 = {type: "CommentLine", value: this.input.slice(t2 + e20, i2), start: t2, end: i2, loc: new vn$1(s2, this.state.curPosition())};
    return this.options.tokens && this.pushToken(a2), a2;
  }
  skipSpace() {
    const e20 = this.state.pos, t2 = [];
    e:
      for (; this.state.pos < this.length; ) {
        const s2 = this.input.charCodeAt(this.state.pos);
        switch (s2) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const e21 = this.skipBlockComment();
                e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
                break;
              }
              case 47: {
                const e21 = this.skipLineComment(2);
                e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Nn$1(s2))
              ++this.state.pos;
            else if (s2 !== 45 || this.inModule) {
              if (s2 !== 60 || this.inModule)
                break e;
              {
                const e21 = this.state.pos;
                if (this.input.charCodeAt(e21 + 1) !== 33 || this.input.charCodeAt(e21 + 2) !== 45 || this.input.charCodeAt(e21 + 3) !== 45)
                  break e;
                {
                  const e22 = this.skipLineComment(4);
                  e22 !== void 0 && (this.addComment(e22), this.options.attachComment && t2.push(e22));
                }
              }
            } else {
              const s3 = this.state.pos;
              if (this.input.charCodeAt(s3 + 1) !== 45 || this.input.charCodeAt(s3 + 2) !== 62 || !(e20 === 0 || this.state.lineStart > e20))
                break e;
              {
                const e21 = this.skipLineComment(3);
                e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
              }
            }
        }
      }
    if (t2.length > 0) {
      const s2 = {start: e20, end: this.state.pos, comments: t2, leadingNode: null, trailingNode: null, containingNode: null};
      this.state.commentStack.push(s2);
    }
  }
  finishToken(e20, t2) {
    this.state.end = this.state.pos;
    const s2 = this.state.type;
    this.state.type = e20, this.state.value = t2, this.isLookahead || (this.state.endLoc = this.state.curPosition(), this.updateContext(s2));
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const e20 = this.state.pos + 1, t2 = this.codePointAtPos(e20);
    if (t2 >= 48 && t2 <= 57)
      throw this.raise(this.state.pos, Rn$1.UnexpectedDigitAfterHash);
    if (t2 === 123 || t2 === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
        throw this.raise(this.state.pos, t2 === 123 ? Rn$1.RecordExpressionHashIncorrectStartSyntaxType : Rn$1.TupleExpressionHashIncorrectStartSyntaxType);
      this.state.pos += 2, t2 === 123 ? this.finishToken(bn$1.braceHashL) : this.finishToken(bn$1.bracketHashL);
    } else
      Jn$1(t2) ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1(t2))) : t2 === 92 ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1())) : this.finishOp(bn$1.hash, 1);
  }
  readToken_dot() {
    const e20 = this.input.charCodeAt(this.state.pos + 1);
    e20 >= 48 && e20 <= 57 ? this.readNumber(true) : e20 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(bn$1.ellipsis)) : (++this.state.pos, this.finishToken(bn$1.dot));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.slashAssign, 2) : this.finishOp(bn$1.slash, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2)
      return false;
    let e20 = this.input.charCodeAt(this.state.pos + 1);
    if (e20 !== 33)
      return false;
    const t2 = this.state.pos;
    for (this.state.pos += 1; !wn$1(e20) && ++this.state.pos < this.length; )
      e20 = this.input.charCodeAt(this.state.pos);
    const s2 = this.input.slice(t2 + 2, this.state.pos);
    return this.finishToken(bn$1.interpreterDirective, s2), true;
  }
  readToken_mult_modulo(e20) {
    let t2 = e20 === 42 ? bn$1.star : bn$1.modulo, s2 = 1, r2 = this.input.charCodeAt(this.state.pos + 1);
    e20 === 42 && r2 === 42 && (s2++, r2 = this.input.charCodeAt(this.state.pos + 2), t2 = bn$1.exponent), r2 !== 61 || this.state.inType || (s2++, t2 = e20 === 37 ? bn$1.moduloAssign : bn$1.assign), this.finishOp(t2, s2);
  }
  readToken_pipe_amp(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (t2 !== e20) {
      if (e20 === 124) {
        if (t2 === 62)
          return void this.finishOp(bn$1.pipeline, 2);
        if (this.hasPlugin("recordAndTuple") && t2 === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectEndSyntaxType);
          return this.state.pos += 2, void this.finishToken(bn$1.braceBarR);
        }
        if (this.hasPlugin("recordAndTuple") && t2 === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectEndSyntaxType);
          return this.state.pos += 2, void this.finishToken(bn$1.bracketBarR);
        }
      }
      t2 !== 61 ? this.finishOp(e20 === 124 ? bn$1.bitwiseOR : bn$1.bitwiseAND, 1) : this.finishOp(bn$1.assign, 2);
    } else
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(e20 === 124 ? bn$1.logicalOR : bn$1.logicalAND, 2);
  }
  readToken_caret() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.bitwiseXOR, 1);
  }
  readToken_plus_min(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    t2 !== e20 ? t2 === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.plusMin, 1) : this.finishOp(bn$1.incDec, 2);
  }
  readToken_lt_gt(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    let s2 = 1;
    if (t2 === e20)
      return s2 = e20 === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.state.pos + s2) === 61 ? void this.finishOp(bn$1.assign, s2 + 1) : void this.finishOp(bn$1.bitShift, s2);
    t2 === 61 && (s2 = 2), this.finishOp(bn$1.relational, s2);
  }
  readToken_eq_excl(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (t2 !== 61)
      return e20 === 61 && t2 === 62 ? (this.state.pos += 2, void this.finishToken(bn$1.arrow)) : void this.finishOp(e20 === 61 ? bn$1.eq : bn$1.bang, 1);
    this.finishOp(bn$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
  }
  readToken_question() {
    const e20 = this.input.charCodeAt(this.state.pos + 1), t2 = this.input.charCodeAt(this.state.pos + 2);
    e20 === 63 ? t2 === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(bn$1.nullishCoalescing, 2) : e20 !== 46 || t2 >= 48 && t2 <= 57 ? (++this.state.pos, this.finishToken(bn$1.question)) : (this.state.pos += 2, this.finishToken(bn$1.questionDot));
  }
  getTokenFromCode(e20) {
    switch (e20) {
      case 46:
        return void this.readToken_dot();
      case 40:
        return ++this.state.pos, void this.finishToken(bn$1.parenL);
      case 41:
        return ++this.state.pos, void this.finishToken(bn$1.parenR);
      case 59:
        return ++this.state.pos, void this.finishToken(bn$1.semi);
      case 44:
        return ++this.state.pos, void this.finishToken(bn$1.comma);
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectStartSyntaxType);
          this.state.pos += 2, this.finishToken(bn$1.bracketBarL);
        } else
          ++this.state.pos, this.finishToken(bn$1.bracketL);
        return;
      case 93:
        return ++this.state.pos, void this.finishToken(bn$1.bracketR);
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectStartSyntaxType);
          this.state.pos += 2, this.finishToken(bn$1.braceBarL);
        } else
          ++this.state.pos, this.finishToken(bn$1.braceL);
        return;
      case 125:
        return ++this.state.pos, void this.finishToken(bn$1.braceR);
      case 58:
        return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(bn$1.doubleColon, 2) : (++this.state.pos, this.finishToken(bn$1.colon)));
      case 63:
        return void this.readToken_question();
      case 96:
        return ++this.state.pos, void this.finishToken(bn$1.backQuote);
      case 48: {
        const e21 = this.input.charCodeAt(this.state.pos + 1);
        if (e21 === 120 || e21 === 88)
          return void this.readRadixNumber(16);
        if (e21 === 111 || e21 === 79)
          return void this.readRadixNumber(8);
        if (e21 === 98 || e21 === 66)
          return void this.readRadixNumber(2);
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return void this.readNumber(false);
      case 34:
      case 39:
        return void this.readString(e20);
      case 47:
        return void this.readToken_slash();
      case 37:
      case 42:
        return void this.readToken_mult_modulo(e20);
      case 124:
      case 38:
        return void this.readToken_pipe_amp(e20);
      case 94:
        return void this.readToken_caret();
      case 43:
      case 45:
        return void this.readToken_plus_min(e20);
      case 60:
      case 62:
        return void this.readToken_lt_gt(e20);
      case 61:
      case 33:
        return void this.readToken_eq_excl(e20);
      case 126:
        return void this.finishOp(bn$1.tilde, 1);
      case 64:
        return ++this.state.pos, void this.finishToken(bn$1.at);
      case 35:
        return void this.readToken_numberSign();
      case 92:
        return void this.readWord();
      default:
        if (Jn$1(e20))
          return void this.readWord(e20);
    }
    throw this.raise(this.state.pos, Rn$1.InvalidOrUnexpectedToken, String.fromCodePoint(e20));
  }
  finishOp(e20, t2) {
    const s2 = this.input.slice(this.state.pos, this.state.pos + t2);
    this.state.pos += t2, this.finishToken(e20, s2);
  }
  readRegexp() {
    const e20 = this.state.start + 1;
    let t2, s2, {pos: r2} = this.state;
    for (; ; ++r2) {
      if (r2 >= this.length)
        throw this.raise(e20, Rn$1.UnterminatedRegExp);
      const i3 = this.input.charCodeAt(r2);
      if (wn$1(i3))
        throw this.raise(e20, Rn$1.UnterminatedRegExp);
      if (t2)
        t2 = false;
      else {
        if (i3 === 91)
          s2 = true;
        else if (i3 === 93 && s2)
          s2 = false;
        else if (i3 === 47 && !s2)
          break;
        t2 = i3 === 92;
      }
    }
    const i2 = this.input.slice(e20, r2);
    ++r2;
    let a2 = "";
    for (; r2 < this.length; ) {
      const e21 = this.codePointAtPos(r2), t3 = String.fromCharCode(e21);
      if (fo$1.has(e21))
        a2.includes(t3) && this.raise(r2 + 1, Rn$1.DuplicateRegExpFlags);
      else {
        if (!Yn$1(e21) && e21 !== 92)
          break;
        this.raise(r2 + 1, Rn$1.MalformedRegExpFlags);
      }
      ++r2, a2 += t3;
    }
    this.state.pos = r2, this.finishToken(bn$1.regexp, {pattern: i2, flags: a2});
  }
  readInt(e20, t2, s2, r2 = true) {
    const i2 = this.state.pos, a2 = e20 === 16 ? yo$1.hex : yo$1.decBinOct, n2 = e20 === 16 ? Ao$1.hex : e20 === 10 ? Ao$1.dec : e20 === 8 ? Ao$1.oct : Ao$1.bin;
    let o2 = false, u2 = 0;
    for (let i3 = 0, h2 = t2 == null ? 1 / 0 : t2; i3 < h2; ++i3) {
      const t3 = this.input.charCodeAt(this.state.pos);
      let h3;
      if (t3 !== 95) {
        if (h3 = t3 >= 97 ? t3 - 97 + 10 : t3 >= 65 ? t3 - 65 + 10 : mo$1(t3) ? t3 - 48 : 1 / 0, h3 >= e20)
          if (this.options.errorRecovery && h3 <= 9)
            h3 = 0, this.raise(this.state.start + i3 + 2, Rn$1.InvalidDigit, e20);
          else {
            if (!s2)
              break;
            h3 = 0, o2 = true;
          }
        ++this.state.pos, u2 = u2 * e20 + h3;
      } else {
        const e21 = this.input.charCodeAt(this.state.pos - 1), t4 = this.input.charCodeAt(this.state.pos + 1);
        (n2.indexOf(t4) === -1 || a2.indexOf(e21) > -1 || a2.indexOf(t4) > -1 || Number.isNaN(t4)) && this.raise(this.state.pos, Rn$1.UnexpectedNumericSeparator), r2 || this.raise(this.state.pos, Rn$1.NumericSeparatorInEscapeSequence), ++this.state.pos;
      }
    }
    return this.state.pos === i2 || t2 != null && this.state.pos - i2 !== t2 || o2 ? null : u2;
  }
  readRadixNumber(e20) {
    const t2 = this.state.pos;
    let s2 = false;
    this.state.pos += 2;
    const r2 = this.readInt(e20);
    r2 == null && this.raise(this.state.start + 2, Rn$1.InvalidDigit, e20);
    const i2 = this.input.charCodeAt(this.state.pos);
    if (i2 === 110)
      ++this.state.pos, s2 = true;
    else if (i2 === 109)
      throw this.raise(t2, Rn$1.InvalidDecimal);
    if (Jn$1(this.codePointAtPos(this.state.pos)))
      throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
    if (s2) {
      const e21 = this.input.slice(t2, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(bn$1.bigint, e21);
    } else
      this.finishToken(bn$1.num, r2);
  }
  readNumber(e20) {
    const t2 = this.state.pos;
    let s2 = false, r2 = false, i2 = false, a2 = false, n2 = false;
    e20 || this.readInt(10) !== null || this.raise(t2, Rn$1.InvalidNumber);
    const o2 = this.state.pos - t2 >= 2 && this.input.charCodeAt(t2) === 48;
    if (o2) {
      const e21 = this.input.slice(t2, this.state.pos);
      if (this.recordStrictModeErrors(t2, Rn$1.StrictOctalLiteral), !this.state.strict) {
        const s3 = e21.indexOf("_");
        s3 > 0 && this.raise(s3 + t2, Rn$1.ZeroDigitNumericSeparator);
      }
      n2 = o2 && !/[89]/.test(e21);
    }
    let u2 = this.input.charCodeAt(this.state.pos);
    if (u2 !== 46 || n2 || (++this.state.pos, this.readInt(10), s2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 !== 69 && u2 !== 101 || n2 || (u2 = this.input.charCodeAt(++this.state.pos), u2 !== 43 && u2 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(t2, Rn$1.InvalidOrMissingExponent), s2 = true, a2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 === 110 && ((s2 || o2) && this.raise(t2, Rn$1.InvalidBigIntLiteral), ++this.state.pos, r2 = true), u2 === 109 && (this.expectPlugin("decimal", this.state.pos), (a2 || o2) && this.raise(t2, Rn$1.InvalidDecimal), ++this.state.pos, i2 = true), Jn$1(this.codePointAtPos(this.state.pos)))
      throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
    const h2 = this.input.slice(t2, this.state.pos).replace(/[_mn]/g, "");
    if (r2)
      return void this.finishToken(bn$1.bigint, h2);
    if (i2)
      return void this.finishToken(bn$1.decimal, h2);
    const c2 = n2 ? parseInt(h2, 8) : parseFloat(h2);
    this.finishToken(bn$1.num, c2);
  }
  readCodePoint(e20) {
    let t2;
    if (this.input.charCodeAt(this.state.pos) === 123) {
      const s2 = ++this.state.pos;
      if (t2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e20), ++this.state.pos, t2 !== null && t2 > 1114111) {
        if (!e20)
          return null;
        this.raise(s2, Rn$1.InvalidCodePoint);
      }
    } else
      t2 = this.readHexChar(4, false, e20);
    return t2;
  }
  readString(e20) {
    let t2 = "", s2 = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn$1.UnterminatedString);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === e20)
        break;
      if (r2 === 92)
        t2 += this.input.slice(s2, this.state.pos), t2 += this.readEscapedChar(false), s2 = this.state.pos;
      else if (r2 === 8232 || r2 === 8233)
        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
      else {
        if (wn$1(r2))
          throw this.raise(this.state.start, Rn$1.UnterminatedString);
        ++this.state.pos;
      }
    }
    t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
  }
  readTmplToken() {
    let e20 = "", t2 = this.state.pos, s2 = false;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn$1.UnterminatedTemplate);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === 96 || r2 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
        return this.state.pos === this.state.start && this.match(bn$1.template) ? r2 === 36 ? (this.state.pos += 2, void this.finishToken(bn$1.dollarBraceL)) : (++this.state.pos, void this.finishToken(bn$1.backQuote)) : (e20 += this.input.slice(t2, this.state.pos), void this.finishToken(bn$1.template, s2 ? null : e20));
      if (r2 === 92) {
        e20 += this.input.slice(t2, this.state.pos);
        const r3 = this.readEscapedChar(true);
        r3 === null ? s2 = true : e20 += r3, t2 = this.state.pos;
      } else if (wn$1(r2)) {
        switch (e20 += this.input.slice(t2, this.state.pos), ++this.state.pos, r2) {
          case 13:
            this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
          case 10:
            e20 += "\n";
            break;
          default:
            e20 += String.fromCharCode(r2);
        }
        ++this.state.curLine, this.state.lineStart = this.state.pos, t2 = this.state.pos;
      } else
        ++this.state.pos;
    }
  }
  recordStrictModeErrors(e20, t2) {
    this.state.strict && !this.state.strictErrors.has(e20) ? this.raise(e20, t2) : this.state.strictErrors.set(e20, t2);
  }
  readEscapedChar(e20) {
    const t2 = !e20, s2 = this.input.charCodeAt(++this.state.pos);
    switch (++this.state.pos, s2) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120: {
        const e21 = this.readHexChar(2, false, t2);
        return e21 === null ? null : String.fromCharCode(e21);
      }
      case 117: {
        const e21 = this.readCodePoint(t2);
        return e21 === null ? null : String.fromCodePoint(e21);
      }
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
      case 10:
        this.state.lineStart = this.state.pos, ++this.state.curLine;
      case 8232:
      case 8233:
        return "";
      case 56:
      case 57:
        if (e20)
          return null;
        this.recordStrictModeErrors(this.state.pos - 1, Rn$1.StrictNumericEscape);
      default:
        if (s2 >= 48 && s2 <= 55) {
          const t3 = this.state.pos - 1;
          let s3 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s3, 8);
          r2 > 255 && (s3 = s3.slice(0, -1), r2 = parseInt(s3, 8)), this.state.pos += s3.length - 1;
          const i2 = this.input.charCodeAt(this.state.pos);
          if (s3 !== "0" || i2 === 56 || i2 === 57) {
            if (e20)
              return null;
            this.recordStrictModeErrors(t3, Rn$1.StrictNumericEscape);
          }
          return String.fromCharCode(r2);
        }
        return String.fromCharCode(s2);
    }
  }
  readHexChar(e20, t2, s2) {
    const r2 = this.state.pos, i2 = this.readInt(16, e20, t2, false);
    return i2 === null && (s2 ? this.raise(r2, Rn$1.InvalidEscapeSequence) : this.state.pos = r2 - 1), i2;
  }
  readWord1(e20) {
    this.state.containsEsc = false;
    let t2 = "";
    const s2 = this.state.pos;
    let r2 = this.state.pos;
    for (e20 !== void 0 && (this.state.pos += e20 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const e21 = this.codePointAtPos(this.state.pos);
      if (Yn$1(e21))
        this.state.pos += e21 <= 65535 ? 1 : 2;
      else {
        if (e21 !== 92)
          break;
        {
          this.state.containsEsc = true, t2 += this.input.slice(r2, this.state.pos);
          const e22 = this.state.pos, i2 = this.state.pos === s2 ? Jn$1 : Yn$1;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, Rn$1.MissingUnicodeEscape), r2 = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const a2 = this.readCodePoint(true);
          a2 !== null && (i2(a2) || this.raise(e22, Rn$1.EscapedCharNotAnIdentifier), t2 += String.fromCodePoint(a2)), r2 = this.state.pos;
        }
      }
    }
    return t2 + this.input.slice(r2, this.state.pos);
  }
  readWord(e20) {
    const t2 = this.readWord1(e20), s2 = xn$1.get(t2) || bn$1.name;
    this.finishToken(s2, t2);
  }
  checkKeywordEscapes() {
    const e20 = this.state.type.keyword;
    e20 && this.state.containsEsc && this.raise(this.state.start, Rn$1.InvalidEscapedReservedWord, e20);
  }
  updateContext(e20) {
    var t2, s2;
    (t2 = (s2 = this.state.type).updateContext) == null || t2.call(s2, this.state.context);
  }
} {
  addExtra(e20, t2, s2) {
    if (!e20)
      return;
    (e20.extra = e20.extra || {})[t2] = s2;
  }
  isRelational(e20) {
    return this.match(bn$1.relational) && this.state.value === e20;
  }
  expectRelational(e20) {
    this.isRelational(e20) ? this.next() : this.unexpected(null, bn$1.relational);
  }
  isContextual(e20) {
    return this.match(bn$1.name) && this.state.value === e20 && !this.state.containsEsc;
  }
  isUnparsedContextual(e20, t2) {
    const s2 = e20 + t2.length;
    if (this.input.slice(e20, s2) === t2) {
      const e21 = this.input.charCodeAt(s2);
      return !(Yn$1(e21) || (64512 & e21) == 55296);
    }
    return false;
  }
  isLookaheadContextual(e20) {
    const t2 = this.nextTokenStart();
    return this.isUnparsedContextual(t2, e20);
  }
  eatContextual(e20) {
    return this.isContextual(e20) && this.eat(bn$1.name);
  }
  expectContextual(e20, t2) {
    this.eatContextual(e20) || this.unexpected(null, t2);
  }
  canInsertSemicolon() {
    return this.match(bn$1.eof) || this.match(bn$1.braceR) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return Pn$1.test(this.input.slice(this.state.lastTokEnd, this.state.start));
  }
  hasFollowingLineBreak() {
    return Bn$1.lastIndex = this.state.end, Bn$1.test(this.input);
  }
  isLineTerminator() {
    return this.eat(bn$1.semi) || this.canInsertSemicolon();
  }
  semicolon(e20 = true) {
    (e20 ? this.isLineTerminator() : this.eat(bn$1.semi)) || this.raise(this.state.lastTokEnd, Rn$1.MissingSemicolon);
  }
  expect(e20, t2) {
    this.eat(e20) || this.unexpected(t2, e20);
  }
  assertNoSpace(e20 = "Unexpected space.") {
    this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, {code: Mn$1.SyntaxError, reasonCode: "UnexpectedSpace", template: e20});
  }
  unexpected(e20, t2 = {code: Mn$1.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token"}) {
    throw t2 instanceof Cn$1 && (t2 = {code: Mn$1.SyntaxError, reasonCode: "UnexpectedToken", template: `Unexpected token, expected "${t2.label}"`}), this.raise(e20 != null ? e20 : this.state.start, t2);
  }
  expectPlugin(e20, t2) {
    if (!this.hasPlugin(e20))
      throw this.raiseWithData(t2 != null ? t2 : this.state.start, {missingPlugin: [e20]}, `This experimental syntax requires enabling the parser plugin: '${e20}'`);
    return true;
  }
  expectOnePlugin(e20, t2) {
    if (!e20.some((e21) => this.hasPlugin(e21)))
      throw this.raiseWithData(t2 != null ? t2 : this.state.start, {missingPlugin: e20}, `This experimental syntax requires enabling one of the following parser plugin(s): '${e20.join(", ")}'`);
  }
  tryParse(e20, t2 = this.state.clone()) {
    const s2 = {node: null};
    try {
      const r2 = e20((e21 = null) => {
        throw s2.node = e21, s2;
      });
      if (this.state.errors.length > t2.errors.length) {
        const e21 = this.state;
        return this.state = t2, this.state.tokensLength = e21.tokensLength, {node: r2, error: e21.errors[t2.errors.length], thrown: false, aborted: false, failState: e21};
      }
      return {node: r2, error: null, thrown: false, aborted: false, failState: null};
    } catch (e21) {
      const r2 = this.state;
      if (this.state = t2, e21 instanceof SyntaxError)
        return {node: null, error: e21, thrown: true, aborted: false, failState: r2};
      if (e21 === s2)
        return {node: s2.node, error: null, thrown: false, aborted: true, failState: r2};
      throw e21;
    }
  }
  checkExpressionErrors(e20, t2) {
    if (!e20)
      return false;
    const {shorthandAssign: s2, doubleProto: r2, optionalParameters: i2} = e20;
    if (!t2)
      return s2 >= 0 || r2 >= 0 || i2 >= 0;
    s2 >= 0 && this.unexpected(s2), r2 >= 0 && this.raise(r2, Rn$1.DuplicateProto), i2 >= 0 && this.unexpected(i2);
  }
  isLiteralPropertyName() {
    return this.match(bn$1.name) || !!this.state.type.keyword || this.match(bn$1.string) || this.match(bn$1.num) || this.match(bn$1.bigint) || this.match(bn$1.decimal);
  }
  isPrivateName(e20) {
    return e20.type === "PrivateName";
  }
  getPrivateNameSV(e20) {
    return e20.id.name;
  }
  hasPropertyAsPrivateName(e20) {
    return (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression") && this.isPrivateName(e20.property);
  }
  isOptionalChain(e20) {
    return e20.type === "OptionalMemberExpression" || e20.type === "OptionalCallExpression";
  }
  isObjectProperty(e20) {
    return e20.type === "ObjectProperty";
  }
  isObjectMethod(e20) {
    return e20.type === "ObjectMethod";
  }
  initializeScopes(e20 = this.options.sourceType === "module") {
    const t2 = this.state.labels;
    this.state.labels = [];
    const s2 = this.exportedIdentifiers;
    this.exportedIdentifiers = new Set();
    const r2 = this.inModule;
    this.inModule = e20;
    const i2 = this.scope, a2 = this.getScopeHandler();
    this.scope = new a2(this.raise.bind(this), this.inModule);
    const n2 = this.prodParam;
    this.prodParam = new To$1();
    const o2 = this.classScope;
    this.classScope = new xo$1(this.raise.bind(this));
    const u2 = this.expressionScope;
    return this.expressionScope = new bo$1(this.raise.bind(this)), () => {
      this.state.labels = t2, this.exportedIdentifiers = s2, this.inModule = r2, this.scope = i2, this.prodParam = n2, this.classScope = o2, this.expressionScope = u2;
    };
  }
  enterInitialScopes() {
    let e20 = 0;
    this.inModule && (e20 |= 2), this.scope.enter(1), this.prodParam.enter(e20);
  }
} {
  startNode() {
    return new Bo$1(this, this.state.start, this.state.startLoc);
  }
  startNodeAt(e20, t2) {
    return new Bo$1(this, e20, t2);
  }
  startNodeAtNode(e20) {
    return this.startNodeAt(e20.start, e20.loc.start);
  }
  finishNode(e20, t2) {
    return this.finishNodeAt(e20, t2, this.state.lastTokEnd, this.state.lastTokEndLoc);
  }
  finishNodeAt(e20, t2, s2, r2) {
    return e20.type = t2, e20.end = s2, e20.loc.end = r2, this.options.ranges && (e20.range[1] = s2), this.options.attachComment && this.processComment(e20), e20;
  }
  resetStartLocation(e20, t2, s2) {
    e20.start = t2, e20.loc.start = s2, this.options.ranges && (e20.range[0] = t2);
  }
  resetEndLocation(e20, t2 = this.state.lastTokEnd, s2 = this.state.lastTokEndLoc) {
    e20.end = t2, e20.loc.end = s2, this.options.ranges && (e20.range[1] = t2);
  }
  resetStartLocationFromNode(e20, t2) {
    this.resetStartLocation(e20, t2.start, t2.loc.start);
  }
} {
  toAssignable(e20, t2 = false) {
    var s2, r2;
    let i2;
    switch ((e20.type === "ParenthesizedExpression" || (s2 = e20.extra) != null && s2.parenthesized) && (i2 = nu(e20), t2 ? i2.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(e20.start, Rn$1.InvalidParenthesizedAssignment) : i2.type !== "MemberExpression" && this.raise(e20.start, Rn$1.InvalidParenthesizedAssignment) : this.raise(e20.start, Rn$1.InvalidParenthesizedAssignment)), e20.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e20.type = "ObjectPattern";
        for (let s3 = 0, r3 = e20.properties.length, i3 = r3 - 1; s3 < r3; s3++) {
          var a2;
          const r4 = e20.properties[s3], n2 = s3 === i3;
          this.toAssignableObjectExpressionProp(r4, n2, t2), n2 && r4.type === "RestElement" && (a2 = e20.extra) != null && a2.trailingComma && this.raiseRestNotLast(e20.extra.trailingComma);
        }
        break;
      case "ObjectProperty":
        this.toAssignable(e20.value, t2);
        break;
      case "SpreadElement": {
        this.checkToRestConversion(e20), e20.type = "RestElement";
        const s3 = e20.argument;
        this.toAssignable(s3, t2);
        break;
      }
      case "ArrayExpression":
        e20.type = "ArrayPattern", this.toAssignableList(e20.elements, (r2 = e20.extra) == null ? void 0 : r2.trailingComma, t2);
        break;
      case "AssignmentExpression":
        e20.operator !== "=" && this.raise(e20.left.end, Rn$1.MissingEqInAssignment), e20.type = "AssignmentPattern", delete e20.operator, this.toAssignable(e20.left, t2);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(i2, t2);
    }
    return e20;
  }
  toAssignableObjectExpressionProp(e20, t2, s2) {
    if (e20.type === "ObjectMethod") {
      const t3 = e20.kind === "get" || e20.kind === "set" ? Rn$1.PatternHasAccessor : Rn$1.PatternHasMethod;
      this.raise(e20.key.start, t3);
    } else
      e20.type !== "SpreadElement" || t2 ? this.toAssignable(e20, s2) : this.raiseRestNotLast(e20.start);
  }
  toAssignableList(e20, t2, s2) {
    let r2 = e20.length;
    if (r2) {
      const i2 = e20[r2 - 1];
      if ((i2 == null ? void 0 : i2.type) === "RestElement")
        --r2;
      else if ((i2 == null ? void 0 : i2.type) === "SpreadElement") {
        i2.type = "RestElement";
        let e21 = i2.argument;
        this.toAssignable(e21, s2), e21 = nu(e21), e21.type !== "Identifier" && e21.type !== "MemberExpression" && e21.type !== "ArrayPattern" && e21.type !== "ObjectPattern" && this.unexpected(e21.start), t2 && this.raiseTrailingCommaAfterRest(t2), --r2;
      }
    }
    for (let t3 = 0; t3 < r2; t3++) {
      const r3 = e20[t3];
      r3 && (this.toAssignable(r3, s2), r3.type === "RestElement" && this.raiseRestNotLast(r3.start));
    }
    return e20;
  }
  isAssignable(e20, t2) {
    switch (e20.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return true;
      case "ObjectExpression": {
        const t3 = e20.properties.length - 1;
        return e20.properties.every((e21, s2) => e21.type !== "ObjectMethod" && (s2 === t3 || e21.type !== "SpreadElement") && this.isAssignable(e21));
      }
      case "ObjectProperty":
        return this.isAssignable(e20.value);
      case "SpreadElement":
        return this.isAssignable(e20.argument);
      case "ArrayExpression":
        return e20.elements.every((e21) => e21 === null || this.isAssignable(e21));
      case "AssignmentExpression":
        return e20.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(e20.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !t2;
      default:
        return false;
    }
  }
  toReferencedList(e20, t2) {
    return e20;
  }
  toReferencedListDeep(e20, t2) {
    this.toReferencedList(e20, t2);
    for (const t3 of e20)
      (t3 == null ? void 0 : t3.type) === "ArrayExpression" && this.toReferencedListDeep(t3.elements);
  }
  parseSpread(e20, t2) {
    const s2 = this.startNode();
    return this.next(), s2.argument = this.parseMaybeAssignAllowIn(e20, void 0, t2), this.finishNode(s2, "SpreadElement");
  }
  parseRestBinding() {
    const e20 = this.startNode();
    return this.next(), e20.argument = this.parseBindingAtom(), this.finishNode(e20, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case bn$1.bracketL: {
        const e20 = this.startNode();
        return this.next(), e20.elements = this.parseBindingList(bn$1.bracketR, 93, true), this.finishNode(e20, "ArrayPattern");
      }
      case bn$1.braceL:
        return this.parseObjectLike(bn$1.braceR, true);
    }
    return this.parseIdentifier();
  }
  parseBindingList(e20, t2, s2, r2) {
    const i2 = [];
    let a2 = true;
    for (; !this.eat(e20); )
      if (a2 ? a2 = false : this.expect(bn$1.comma), s2 && this.match(bn$1.comma))
        i2.push(null);
      else {
        if (this.eat(e20))
          break;
        if (this.match(bn$1.ellipsis)) {
          i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(t2), this.expect(e20);
          break;
        }
        {
          const e21 = [];
          for (this.match(bn$1.at) && this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedParameterDecorator); this.match(bn$1.at); )
            e21.push(this.parseDecorator());
          i2.push(this.parseAssignableListItem(r2, e21));
        }
      }
    return i2;
  }
  parseAssignableListItem(e20, t2) {
    const s2 = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(s2);
    const r2 = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
    return t2.length && (s2.decorators = t2), r2;
  }
  parseAssignableListItemTypes(e20) {
    return e20;
  }
  parseMaybeDefault(e20, t2, s2) {
    var r2, i2, a2;
    if (t2 = (r2 = t2) != null ? r2 : this.state.startLoc, e20 = (i2 = e20) != null ? i2 : this.state.start, s2 = (a2 = s2) != null ? a2 : this.parseBindingAtom(), !this.eat(bn$1.eq))
      return s2;
    const n2 = this.startNodeAt(e20, t2);
    return n2.left = s2, n2.right = this.parseMaybeAssignAllowIn(), this.finishNode(n2, "AssignmentPattern");
  }
  checkLVal(e20, t2, s2 = 64, r2, i2, a2 = false) {
    switch (e20.type) {
      case "Identifier": {
        const {name: t3} = e20;
        this.state.strict && (a2 ? no$1(t3, this.inModule) : ao$1(t3)) && this.raise(e20.start, s2 === 64 ? Rn$1.StrictEvalArguments : Rn$1.StrictEvalArgumentsBinding, t3), r2 && (r2.has(t3) ? this.raise(e20.start, Rn$1.ParamDupe) : r2.add(t3)), i2 && t3 === "let" && this.raise(e20.start, Rn$1.LetInLexicalBinding), 64 & s2 || this.scope.declareName(t3, s2, e20.start);
        break;
      }
      case "MemberExpression":
        s2 !== 64 && this.raise(e20.start, Rn$1.InvalidPropertyBindingPattern);
        break;
      case "ObjectPattern":
        for (let t3 of e20.properties) {
          if (this.isObjectProperty(t3))
            t3 = t3.value;
          else if (this.isObjectMethod(t3))
            continue;
          this.checkLVal(t3, "object destructuring pattern", s2, r2, i2);
        }
        break;
      case "ArrayPattern":
        for (const t3 of e20.elements)
          t3 && this.checkLVal(t3, "array destructuring pattern", s2, r2, i2);
        break;
      case "AssignmentPattern":
        this.checkLVal(e20.left, "assignment pattern", s2, r2);
        break;
      case "RestElement":
        this.checkLVal(e20.argument, "rest element", s2, r2);
        break;
      case "ParenthesizedExpression":
        this.checkLVal(e20.expression, "parenthesized expression", s2, r2);
        break;
      default:
        this.raise(e20.start, s2 === 64 ? Rn$1.InvalidLhs : Rn$1.InvalidLhsBinding, t2);
    }
  }
  checkToRestConversion(e20) {
    e20.argument.type !== "Identifier" && e20.argument.type !== "MemberExpression" && this.raise(e20.argument.start, Rn$1.InvalidRestAssignmentPattern);
  }
  checkCommaAfterRest(e20) {
    this.match(bn$1.comma) && (this.lookaheadCharCode() === e20 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
  }
  raiseRestNotLast(e20) {
    throw this.raise(e20, Rn$1.ElementAfterRest);
  }
  raiseTrailingCommaAfterRest(e20) {
    this.raise(e20, Rn$1.RestTrailingComma);
  }
} {
  checkProto(e20, t2, s2, r2) {
    if (e20.type === "SpreadElement" || this.isObjectMethod(e20) || e20.computed || e20.shorthand)
      return;
    const i2 = e20.key;
    if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
      if (t2)
        return void this.raise(i2.start, Rn$1.RecordNoProto);
      s2.used && (r2 ? r2.doubleProto === -1 && (r2.doubleProto = i2.start) : this.raise(i2.start, Rn$1.DuplicateProto)), s2.used = true;
    }
  }
  shouldExitDescending(e20, t2) {
    return e20.type === "ArrowFunctionExpression" && e20.start === t2;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const e20 = this.parseExpression();
    return this.match(bn$1.eof) || this.unexpected(), this.finalizeRemainingComments(), e20.comments = this.state.comments, e20.errors = this.state.errors, this.options.tokens && (e20.tokens = this.tokens), e20;
  }
  parseExpression(e20, t2) {
    return e20 ? this.disallowInAnd(() => this.parseExpressionBase(t2)) : this.allowInAnd(() => this.parseExpressionBase(t2));
  }
  parseExpressionBase(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.parseMaybeAssign(e20);
    if (this.match(bn$1.comma)) {
      const i2 = this.startNodeAt(t2, s2);
      for (i2.expressions = [r2]; this.eat(bn$1.comma); )
        i2.expressions.push(this.parseMaybeAssign(e20));
      return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
    }
    return r2;
  }
  parseMaybeAssignDisallowIn(e20, t2) {
    return this.disallowInAnd(() => this.parseMaybeAssign(e20, t2));
  }
  parseMaybeAssignAllowIn(e20, t2) {
    return this.allowInAnd(() => this.parseMaybeAssign(e20, t2));
  }
  setOptionalParametersError(e20, t2) {
    var s2;
    e20.optionalParameters = (s2 = t2 == null ? void 0 : t2.pos) != null ? s2 : this.state.start;
  }
  parseMaybeAssign(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    if (this.isContextual("yield") && this.prodParam.hasYield) {
      let e21 = this.parseYield();
      return t2 && (e21 = t2.call(this, e21, s2, r2)), e21;
    }
    let i2;
    e20 ? i2 = false : (e20 = new So$1(), i2 = true), (this.match(bn$1.parenL) || this.match(bn$1.name)) && (this.state.potentialArrowAt = this.state.start);
    let a2 = this.parseMaybeConditional(e20);
    if (t2 && (a2 = t2.call(this, a2, s2, r2)), this.state.type.isAssign) {
      const t3 = this.startNodeAt(s2, r2), i3 = this.state.value;
      t3.operator = i3;
      if (a2.type === "BinaryExpression" && a2.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack")
        throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, i3);
      return this.match(bn$1.eq) ? (t3.left = this.toAssignable(a2, true), e20.doubleProto = -1) : t3.left = a2, e20.shorthandAssign >= t3.left.start && (e20.shorthandAssign = -1), this.checkLVal(a2, "assignment expression"), this.next(), t3.right = this.parseMaybeAssign(), this.finishNode(t3, "AssignmentExpression");
    }
    return i2 && this.checkExpressionErrors(e20, true), a2;
  }
  parseMaybeConditional(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprOps(e20);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseConditional(i2, t2, s2, e20);
  }
  parseConditional(e20, t2, s2, r2) {
    if (this.eat(bn$1.question)) {
      const r3 = this.startNodeAt(t2, s2);
      return r3.test = e20, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(bn$1.colon), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
    }
    return e20;
  }
  parseMaybeUnaryOrPrivate(e20) {
    return this.match(bn$1.privateName) ? this.parsePrivateName() : this.parseMaybeUnary(e20);
  }
  parseExprOps(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(e20);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseExprOp(i2, t2, s2, -1);
  }
  parseExprOp(e20, t2, s2, r2) {
    if (this.isPrivateName(e20)) {
      const t3 = this.getPrivateNameSV(e20), {start: s3} = e20;
      (r2 >= bn$1._in.binop || !this.prodParam.hasIn || !this.match(bn$1._in)) && this.raise(s3, Rn$1.PrivateInExpectedIn, t3), this.classScope.usePrivateName(t3, s3);
    }
    let i2 = this.state.type.binop;
    if (i2 != null && (this.prodParam.hasIn || !this.match(bn$1._in)) && i2 > r2) {
      const a2 = this.state.type;
      if (a2 === bn$1.pipeline) {
        if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
          return e20;
        this.checkPipelineAtInfixOperator(e20, t2);
      }
      const n2 = this.startNodeAt(t2, s2);
      n2.left = e20, n2.operator = this.state.value;
      const o2 = a2 === bn$1.logicalOR || a2 === bn$1.logicalAND, u2 = a2 === bn$1.nullishCoalescing;
      if (u2 && (i2 = bn$1.logicalAND.binop), this.next(), a2 === bn$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.match(bn$1.name) && this.state.value === "await" && this.prodParam.hasAwait)
        throw this.raise(this.state.start, Rn$1.UnexpectedAwaitAfterPipelineBody);
      n2.right = this.parseExprOpRightExpr(a2, i2), this.finishNode(n2, o2 || u2 ? "LogicalExpression" : "BinaryExpression");
      const h2 = this.state.type;
      if (u2 && (h2 === bn$1.logicalOR || h2 === bn$1.logicalAND) || o2 && h2 === bn$1.nullishCoalescing)
        throw this.raise(this.state.start, Rn$1.MixingCoalesceWithLogical);
      return this.parseExprOp(n2, t2, s2, r2);
    }
    return e20;
  }
  parseExprOpRightExpr(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    switch (e20) {
      case bn$1.pipeline:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => {
              const r3 = this.parseHackPipeBody(e20, t2);
              return this.checkHackPipeBodyEarlyErrors(s2), r3;
            });
          case "smart":
            return this.withTopicBindingContext(() => {
              const i2 = this.parseHackPipeBody(e20, t2);
              return this.parseSmartPipelineBodyInStyle(i2, s2, r2);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t2));
        }
      default:
        return this.parseExprOpBaseRightExpr(e20, t2);
    }
  }
  parseExprOpBaseRightExpr(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, r2, e20.rightAssociative ? t2 - 1 : t2);
  }
  parseHackPipeBody(e20, t2) {
    if (this.prodParam.hasYield && this.isContextual("yield"))
      throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, this.state.value);
    return this.parseExprOpBaseRightExpr(e20, t2);
  }
  checkExponentialAfterUnary(e20) {
    this.match(bn$1.exponent) && this.raise(e20.argument.start, Rn$1.UnexpectedTokenUnaryExponentiation);
  }
  parseMaybeUnary(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.isContextual("await");
    if (i2 && this.isAwaitAllowed()) {
      this.next();
      const e21 = this.parseAwait(s2, r2);
      return t2 || this.checkExponentialAfterUnary(e21), e21;
    }
    const a2 = this.match(bn$1.incDec), n2 = this.startNode();
    if (this.state.type.prefix) {
      n2.operator = this.state.value, n2.prefix = true, this.match(bn$1._throw) && this.expectPlugin("throwExpressions");
      const s3 = this.match(bn$1._delete);
      if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e20, true), this.state.strict && s3) {
        const e21 = n2.argument;
        e21.type === "Identifier" ? this.raise(n2.start, Rn$1.StrictDelete) : this.hasPropertyAsPrivateName(e21) && this.raise(n2.start, Rn$1.DeletePrivateField);
      }
      if (!a2)
        return t2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
    }
    const o2 = this.parseUpdate(n2, a2, e20);
    if (i2) {
      if ((this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(bn$1.modulo)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(s2, Rn$1.AwaitNotInAsyncContext), this.parseAwait(s2, r2);
    }
    return o2;
  }
  parseUpdate(e20, t2, s2) {
    if (t2)
      return this.checkLVal(e20.argument, "prefix operation"), this.finishNode(e20, "UpdateExpression");
    const r2 = this.state.start, i2 = this.state.startLoc;
    let a2 = this.parseExprSubscripts(s2);
    if (this.checkExpressionErrors(s2, false))
      return a2;
    for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
      const e21 = this.startNodeAt(r2, i2);
      e21.operator = this.state.value, e21.prefix = false, e21.argument = a2, this.checkLVal(a2, "postfix operation"), this.next(), a2 = this.finishNode(e21, "UpdateExpression");
    }
    return a2;
  }
  parseExprSubscripts(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(e20);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseSubscripts(i2, t2, s2);
  }
  parseSubscripts(e20, t2, s2, r2) {
    const i2 = {optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e20), stop: false};
    do {
      e20 = this.parseSubscript(e20, t2, s2, r2, i2), i2.maybeAsyncArrow = false;
    } while (!i2.stop);
    return e20;
  }
  parseSubscript(e20, t2, s2, r2, i2) {
    if (!r2 && this.eat(bn$1.doubleColon))
      return this.parseBind(e20, t2, s2, r2, i2);
    if (this.match(bn$1.backQuote))
      return this.parseTaggedTemplateExpression(e20, t2, s2, i2);
    let a2 = false;
    if (this.match(bn$1.questionDot)) {
      if (r2 && this.lookaheadCharCode() === 40)
        return i2.stop = true, e20;
      i2.optionalChainMember = a2 = true, this.next();
    }
    if (!r2 && this.match(bn$1.parenL))
      return this.parseCoverCallAndAsyncArrowHead(e20, t2, s2, i2, a2);
    {
      const r3 = this.eat(bn$1.bracketL);
      return r3 || a2 || this.eat(bn$1.dot) ? this.parseMember(e20, t2, s2, i2, r3, a2) : (i2.stop = true, e20);
    }
  }
  parseMember(e20, t2, s2, r2, i2, a2) {
    const n2 = this.startNodeAt(t2, s2);
    n2.object = e20, n2.computed = i2;
    const o2 = !i2 && this.match(bn$1.privateName) && this.state.value, u2 = i2 ? this.parseExpression() : o2 ? this.parsePrivateName() : this.parseIdentifier(true);
    return o2 !== false && (n2.object.type === "Super" && this.raise(t2, Rn$1.SuperPrivateField), this.classScope.usePrivateName(o2, u2.start)), n2.property = u2, i2 && this.expect(bn$1.bracketR), r2.optionalChainMember ? (n2.optional = a2, this.finishNode(n2, "OptionalMemberExpression")) : this.finishNode(n2, "MemberExpression");
  }
  parseBind(e20, t2, s2, r2, i2) {
    const a2 = this.startNodeAt(t2, s2);
    return a2.object = e20, a2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(a2, "BindExpression"), t2, s2, r2);
  }
  parseCoverCallAndAsyncArrowHead(e20, t2, s2, r2, i2) {
    const a2 = this.state.maybeInArrowParameters;
    let n2 = null;
    this.state.maybeInArrowParameters = true, this.next();
    let o2 = this.startNodeAt(t2, s2);
    return o2.callee = e20, r2.maybeAsyncArrow && (this.expressionScope.enter(new go$1(2)), n2 = new So$1()), r2.optionalChainMember && (o2.optional = i2), o2.arguments = i2 ? this.parseCallExpressionArguments(bn$1.parenR) : this.parseCallExpressionArguments(bn$1.parenR, e20.type === "Import", e20.type !== "Super", o2, n2), this.finishCallExpression(o2, r2.optionalChainMember), r2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i2 ? (r2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t2, s2), o2)) : (r2.maybeAsyncArrow && (this.checkExpressionErrors(n2, true), this.expressionScope.exit()), this.toReferencedArguments(o2)), this.state.maybeInArrowParameters = a2, o2;
  }
  toReferencedArguments(e20, t2) {
    this.toReferencedListDeep(e20.arguments, t2);
  }
  parseTaggedTemplateExpression(e20, t2, s2, r2) {
    const i2 = this.startNodeAt(t2, s2);
    return i2.tag = e20, i2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(t2, Rn$1.OptionalChainingNoTemplate), this.finishNode(i2, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(e20) {
    return e20.type === "Identifier" && e20.name === "async" && this.state.lastTokEnd === e20.end && !this.canInsertSemicolon() && e20.end - e20.start == 5 && e20.start === this.state.potentialArrowAt;
  }
  finishCallExpression(e20, t2) {
    if (e20.callee.type === "Import")
      if (e20.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e20.arguments.length === 0 || e20.arguments.length > 2)
        this.raise(e20.start, Rn$1.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
      else
        for (const t3 of e20.arguments)
          t3.type === "SpreadElement" && this.raise(t3.start, Rn$1.ImportCallSpreadArgument);
    return this.finishNode(e20, t2 ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(e20, t2, s2, r2, i2) {
    const a2 = [];
    let n2 = true;
    const o2 = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e20); ) {
      if (n2)
        n2 = false;
      else if (this.expect(bn$1.comma), this.match(e20)) {
        !t2 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Rn$1.ImportCallArgumentTrailingComma), r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
        break;
      }
      a2.push(this.parseExprListItem(false, i2, s2));
    }
    return this.state.inFSharpPipelineDirectBody = o2, a2;
  }
  shouldParseAsyncArrow() {
    return this.match(bn$1.arrow) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(e20, t2) {
    var s2;
    return this.resetPreviousNodeTrailingComments(t2), this.expect(bn$1.arrow), this.parseArrowExpression(e20, t2.arguments, true, (s2 = t2.extra) == null ? void 0 : s2.trailingComma), Ln$1(e20, t2.innerComments), Ln$1(e20, t2.callee.trailingComments), e20;
  }
  parseNoCallExpr() {
    const e20 = this.state.start, t2 = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), e20, t2, true);
  }
  parseExprAtom(e20) {
    let t2;
    switch (this.state.type) {
      case bn$1._super:
        return this.parseSuper();
      case bn$1._import:
        return t2 = this.startNode(), this.next(), this.match(bn$1.dot) ? this.parseImportMetaProperty(t2) : (this.match(bn$1.parenL) || this.raise(this.state.lastTokStart, Rn$1.UnsupportedImport), this.finishNode(t2, "Import"));
      case bn$1._this:
        return t2 = this.startNode(), this.next(), this.finishNode(t2, "ThisExpression");
      case bn$1.name: {
        if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
          return this.parseModuleExpression();
        const e21 = this.state.potentialArrowAt === this.state.start, t3 = this.state.containsEsc, s2 = this.parseIdentifier();
        if (!t3 && s2.name === "async" && !this.canInsertSemicolon()) {
          if (this.match(bn$1._function))
            return this.resetPreviousNodeTrailingComments(s2), this.next(), this.parseFunction(this.startNodeAtNode(s2), void 0, true);
          if (this.match(bn$1.name))
            return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(s2)) : s2;
          if (this.match(bn$1._do))
            return this.resetPreviousNodeTrailingComments(s2), this.parseDo(this.startNodeAtNode(s2), true);
        }
        return e21 && this.match(bn$1.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s2), [s2], false)) : s2;
      }
      case bn$1._do:
        return this.parseDo(this.startNode(), false);
      case bn$1.slash:
      case bn$1.slashAssign:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case bn$1.num:
        return this.parseNumericLiteral(this.state.value);
      case bn$1.bigint:
        return this.parseBigIntLiteral(this.state.value);
      case bn$1.decimal:
        return this.parseDecimalLiteral(this.state.value);
      case bn$1.string:
        return this.parseStringLiteral(this.state.value);
      case bn$1._null:
        return this.parseNullLiteral();
      case bn$1._true:
        return this.parseBooleanLiteral(true);
      case bn$1._false:
        return this.parseBooleanLiteral(false);
      case bn$1.parenL: {
        const e21 = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(e21);
      }
      case bn$1.bracketBarL:
      case bn$1.bracketHashL:
        return this.parseArrayLike(this.state.type === bn$1.bracketBarL ? bn$1.bracketBarR : bn$1.bracketR, false, true, e20);
      case bn$1.bracketL:
        return this.parseArrayLike(bn$1.bracketR, true, false, e20);
      case bn$1.braceBarL:
      case bn$1.braceHashL:
        return this.parseObjectLike(this.state.type === bn$1.braceBarL ? bn$1.braceBarR : bn$1.braceR, false, true, e20);
      case bn$1.braceL:
        return this.parseObjectLike(bn$1.braceR, false, false, e20);
      case bn$1._function:
        return this.parseFunctionOrFunctionSent();
      case bn$1.at:
        this.parseDecorators();
      case bn$1._class:
        return t2 = this.startNode(), this.takeDecorators(t2), this.parseClass(t2, false);
      case bn$1._new:
        return this.parseNewOrNewTarget();
      case bn$1.backQuote:
        return this.parseTemplate(false);
      case bn$1.doubleColon: {
        t2 = this.startNode(), this.next(), t2.object = null;
        const e21 = t2.callee = this.parseNoCallExpr();
        if (e21.type === "MemberExpression")
          return this.finishNode(t2, "BindExpression");
        throw this.raise(e21.start, Rn$1.UnsupportedBind);
      }
      case bn$1.privateName:
        return this.raise(this.state.start, Rn$1.PrivateInExpectedIn, this.state.value), this.parsePrivateName();
      case bn$1.moduloAssign:
        if (this.getPluginOption("pipelineOperator", "proposal") !== "hack" || this.getPluginOption("pipelineOperator", "topicToken") !== "%")
          throw this.unexpected();
        this.state.value = "%", this.state.type = bn$1.modulo, this.state.pos--, this.state.end--, this.state.endLoc.column--;
      case bn$1.modulo:
      case bn$1.hash: {
        const e21 = this.getPluginOption("pipelineOperator", "proposal");
        if (e21) {
          t2 = this.startNode();
          const s2 = this.state.start, r2 = this.state.type;
          return this.next(), this.finishTopicReference(t2, s2, e21, r2);
        }
      }
      case bn$1.relational:
        if (this.state.value === "<") {
          const e21 = this.input.codePointAt(this.nextTokenStart());
          (Jn$1(e21) || e21 === 62) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
        }
      default:
        throw this.unexpected();
    }
  }
  finishTopicReference(e20, t2, s2, r2) {
    if (this.testTopicReferenceConfiguration(s2, t2, r2)) {
      let r3;
      return r3 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference", this.topicReferenceIsAllowedInCurrentContext() || (s2 === "smart" ? this.raise(t2, Rn$1.PrimaryTopicNotAllowed) : this.raise(t2, Rn$1.PipeTopicUnbound)), this.registerTopicReference(), this.finishNode(e20, r3);
    }
    throw this.raise(t2, Rn$1.PipeTopicUnconfiguredToken, r2.label);
  }
  testTopicReferenceConfiguration(e20, t2, s2) {
    switch (e20) {
      case "hack": {
        const e21 = this.getPluginOption("pipelineOperator", "topicToken");
        return s2.label === e21;
      }
      case "smart":
        return s2 === bn$1.hash;
      default:
        throw this.raise(t2, Rn$1.PipeTopicRequiresHackPipes);
    }
  }
  parseAsyncArrowUnaryFunction(e20) {
    this.prodParam.enter(wo$1(true, this.prodParam.hasYield));
    const t2 = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, Rn$1.LineTerminatorBeforeArrow), this.expect(bn$1.arrow), this.parseArrowExpression(e20, t2, true), e20;
  }
  parseDo(e20, t2) {
    this.expectPlugin("doExpressions"), t2 && this.expectPlugin("asyncDoExpressions"), e20.async = t2, this.next();
    const s2 = this.state.labels;
    return this.state.labels = [], t2 ? (this.prodParam.enter(2), e20.body = this.parseBlock(), this.prodParam.exit()) : e20.body = this.parseBlock(), this.state.labels = s2, this.finishNode(e20, "DoExpression");
  }
  parseSuper() {
    const e20 = this.startNode();
    return this.next(), !this.match(bn$1.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(e20.start, Rn$1.UnexpectedSuper) : this.raise(e20.start, Rn$1.SuperNotAllowed), this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.dot) || this.raise(e20.start, Rn$1.UnsupportedSuper), this.finishNode(e20, "Super");
  }
  parseMaybePrivateName(e20) {
    return this.match(bn$1.privateName) ? (e20 || this.raise(this.state.start + 1, Rn$1.UnexpectedPrivateField), this.parsePrivateName()) : this.parseIdentifier(true);
  }
  parsePrivateName() {
    const e20 = this.startNode(), t2 = this.startNodeAt(this.state.start + 1, new In$1(this.state.curLine, this.state.start + 1 - this.state.lineStart)), s2 = this.state.value;
    return this.next(), e20.id = this.createIdentifier(t2, s2), this.finishNode(e20, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const e20 = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(bn$1.dot)) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e20), "function");
      return this.next(), this.parseMetaProperty(e20, t2, "sent");
    }
    return this.parseFunction(e20);
  }
  parseMetaProperty(e20, t2, s2) {
    e20.meta = t2, t2.name === "function" && s2 === "sent" && (this.isContextual(s2) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
    const r2 = this.state.containsEsc;
    return e20.property = this.parseIdentifier(true), (e20.property.name !== s2 || r2) && this.raise(e20.property.start, Rn$1.UnsupportedMetaProperty, t2.name, s2), this.finishNode(e20, "MetaProperty");
  }
  parseImportMetaProperty(e20) {
    const t2 = this.createIdentifier(this.startNodeAtNode(e20), "import");
    return this.next(), this.isContextual("meta") && (this.inModule || this.raise(t2.start, jn$1.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(e20, t2, "meta");
  }
  parseLiteralAtNode(e20, t2, s2) {
    return this.addExtra(s2, "rawValue", e20), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = e20, this.next(), this.finishNode(s2, t2);
  }
  parseLiteral(e20, t2) {
    const s2 = this.startNode();
    return this.parseLiteralAtNode(e20, t2, s2);
  }
  parseStringLiteral(e20) {
    return this.parseLiteral(e20, "StringLiteral");
  }
  parseNumericLiteral(e20) {
    return this.parseLiteral(e20, "NumericLiteral");
  }
  parseBigIntLiteral(e20) {
    return this.parseLiteral(e20, "BigIntLiteral");
  }
  parseDecimalLiteral(e20) {
    return this.parseLiteral(e20, "DecimalLiteral");
  }
  parseRegExpLiteral(e20) {
    const t2 = this.parseLiteral(e20.value, "RegExpLiteral");
    return t2.pattern = e20.pattern, t2.flags = e20.flags, t2;
  }
  parseBooleanLiteral(e20) {
    const t2 = this.startNode();
    return t2.value = e20, this.next(), this.finishNode(t2, "BooleanLiteral");
  }
  parseNullLiteral() {
    const e20 = this.startNode();
    return this.next(), this.finishNode(e20, "NullLiteral");
  }
  parseParenAndDistinguishExpression(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc;
    let r2;
    this.next(), this.expressionScope.enter(new go$1(1));
    const i2 = this.state.maybeInArrowParameters, a2 = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
    const n2 = this.state.start, o2 = this.state.startLoc, u2 = [], h2 = new So$1();
    let c2, p2, l2 = true;
    for (; !this.match(bn$1.parenR); ) {
      if (l2)
        l2 = false;
      else if (this.expect(bn$1.comma, h2.optionalParameters === -1 ? null : h2.optionalParameters), this.match(bn$1.parenR)) {
        p2 = this.state.start;
        break;
      }
      if (this.match(bn$1.ellipsis)) {
        const e21 = this.state.start, t3 = this.state.startLoc;
        c2 = this.state.start, u2.push(this.parseParenItem(this.parseRestBinding(), e21, t3)), this.checkCommaAfterRest(41);
        break;
      }
      u2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
    }
    const d2 = this.state.lastTokEnd, D2 = this.state.lastTokEndLoc;
    this.expect(bn$1.parenR), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = a2;
    let m2 = this.startNodeAt(t2, s2);
    if (e20 && this.shouldParseArrow(u2) && (m2 = this.parseArrow(m2)))
      return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(m2, u2, false), m2;
    if (this.expressionScope.exit(), u2.length || this.unexpected(this.state.lastTokStart), p2 && this.unexpected(p2), c2 && this.unexpected(c2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(u2, true), u2.length > 1 ? (r2 = this.startNodeAt(n2, o2), r2.expressions = u2, this.finishNode(r2, "SequenceExpression"), r2.end = d2, r2.loc.end = D2) : r2 = u2[0], !this.options.createParenthesizedExpressions)
      return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", t2), r2;
    const f2 = this.startNodeAt(t2, s2);
    return f2.expression = r2, this.finishNode(f2, "ParenthesizedExpression"), f2;
  }
  shouldParseArrow(e20) {
    return !this.canInsertSemicolon();
  }
  parseArrow(e20) {
    if (this.eat(bn$1.arrow))
      return e20;
  }
  parseParenItem(e20, t2, s2) {
    return e20;
  }
  parseNewOrNewTarget() {
    const e20 = this.startNode();
    if (this.next(), this.match(bn$1.dot)) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e20), "new");
      this.next();
      const s2 = this.parseMetaProperty(e20, t2, "target");
      return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(s2.start, Rn$1.UnexpectedNewTarget), s2;
    }
    return this.parseNew(e20);
  }
  parseNew(e20) {
    return e20.callee = this.parseNoCallExpr(), e20.callee.type === "Import" ? this.raise(e20.callee.start, Rn$1.ImportCallNotNewExpression) : this.isOptionalChain(e20.callee) ? this.raise(this.state.lastTokEnd, Rn$1.OptionalChainingNoNew) : this.eat(bn$1.questionDot) && this.raise(this.state.start, Rn$1.OptionalChainingNoNew), this.parseNewArguments(e20), this.finishNode(e20, "NewExpression");
  }
  parseNewArguments(e20) {
    if (this.eat(bn$1.parenL)) {
      const t2 = this.parseExprList(bn$1.parenR);
      this.toReferencedList(t2), e20.arguments = t2;
    } else
      e20.arguments = [];
  }
  parseTemplateElement(e20) {
    const t2 = this.startNode();
    return this.state.value === null && (e20 || this.raise(this.state.start + 1, Rn$1.InvalidEscapeSequenceTemplate)), t2.value = {raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value}, this.next(), t2.tail = this.match(bn$1.backQuote), this.finishNode(t2, "TemplateElement");
  }
  parseTemplate(e20) {
    const t2 = this.startNode();
    this.next(), t2.expressions = [];
    let s2 = this.parseTemplateElement(e20);
    for (t2.quasis = [s2]; !s2.tail; )
      this.expect(bn$1.dollarBraceL), t2.expressions.push(this.parseTemplateSubstitution()), this.expect(bn$1.braceR), t2.quasis.push(s2 = this.parseTemplateElement(e20));
    return this.next(), this.finishNode(t2, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(e20, t2, s2, r2) {
    s2 && this.expectPlugin("recordAndTuple");
    const i2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const a2 = Object.create(null);
    let n2 = true;
    const o2 = this.startNode();
    for (o2.properties = [], this.next(); !this.match(e20); ) {
      if (n2)
        n2 = false;
      else if (this.expect(bn$1.comma), this.match(e20)) {
        this.addExtra(o2, "trailingComma", this.state.lastTokStart);
        break;
      }
      const i3 = this.parsePropertyDefinition(t2, r2);
      t2 || this.checkProto(i3, s2, a2, r2), s2 && !this.isObjectProperty(i3) && i3.type !== "SpreadElement" && this.raise(i3.start, Rn$1.InvalidRecordProperty), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = i2;
    let u2 = "ObjectExpression";
    return t2 ? u2 = "ObjectPattern" : s2 && (u2 = "RecordExpression"), this.finishNode(o2, u2);
  }
  maybeAsyncOrAccessorProp(e20) {
    return !e20.computed && e20.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(bn$1.bracketL) || this.match(bn$1.star));
  }
  parsePropertyDefinition(e20, t2) {
    let s2 = [];
    if (this.match(bn$1.at))
      for (this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedPropertyDecorator); this.match(bn$1.at); )
        s2.push(this.parseDecorator());
    const r2 = this.startNode();
    let i2, a2, n2 = false, o2 = false, u2 = false;
    if (this.match(bn$1.ellipsis))
      return s2.length && this.unexpected(), e20 ? (this.next(), r2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r2, "RestElement")) : this.parseSpread();
    s2.length && (r2.decorators = s2, s2 = []), r2.method = false, (e20 || t2) && (i2 = this.state.start, a2 = this.state.startLoc), e20 || (n2 = this.eat(bn$1.star));
    const h2 = this.state.containsEsc, c2 = this.parsePropertyName(r2, false);
    if (!e20 && !n2 && !h2 && this.maybeAsyncOrAccessorProp(r2)) {
      const e21 = c2.name;
      e21 !== "async" || this.hasPrecedingLineBreak() || (o2 = true, this.resetPreviousNodeTrailingComments(c2), n2 = this.eat(bn$1.star), this.parsePropertyName(r2, false)), e21 !== "get" && e21 !== "set" || (u2 = true, this.resetPreviousNodeTrailingComments(c2), r2.kind = e21, this.match(bn$1.star) && (n2 = true, this.raise(this.state.pos, Rn$1.AccessorIsGenerator, e21), this.next()), this.parsePropertyName(r2, false));
    }
    return this.parseObjPropValue(r2, i2, a2, n2, o2, e20, u2, t2), r2;
  }
  getGetterSetterExpectedParamCount(e20) {
    return e20.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(e20) {
    return e20.params;
  }
  checkGetterSetterParams(e20) {
    var t2;
    const s2 = this.getGetterSetterExpectedParamCount(e20), r2 = this.getObjectOrClassMethodParams(e20), i2 = e20.start;
    r2.length !== s2 && (e20.kind === "get" ? this.raise(i2, Rn$1.BadGetterArity) : this.raise(i2, Rn$1.BadSetterArity)), e20.kind === "set" && ((t2 = r2[r2.length - 1]) == null ? void 0 : t2.type) === "RestElement" && this.raise(i2, Rn$1.BadSetterRestParameter);
  }
  parseObjectMethod(e20, t2, s2, r2, i2) {
    return i2 ? (this.parseMethod(e20, t2, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e20), e20) : s2 || t2 || this.match(bn$1.parenL) ? (r2 && this.unexpected(), e20.kind = "method", e20.method = true, this.parseMethod(e20, t2, s2, false, false, "ObjectMethod")) : void 0;
  }
  parseObjectProperty(e20, t2, s2, r2, i2) {
    return e20.shorthand = false, this.eat(bn$1.colon) ? (e20.value = r2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(e20, "ObjectProperty")) : e20.computed || e20.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(e20.key.name, e20.key.start, true, false), r2 ? e20.value = this.parseMaybeDefault(t2, s2, Io$1(e20.key)) : this.match(bn$1.eq) && i2 ? (i2.shorthandAssign === -1 && (i2.shorthandAssign = this.state.start), e20.value = this.parseMaybeDefault(t2, s2, Io$1(e20.key))) : e20.value = Io$1(e20.key), e20.shorthand = true, this.finishNode(e20, "ObjectProperty"));
  }
  parseObjPropValue(e20, t2, s2, r2, i2, a2, n2, o2) {
    const u2 = this.parseObjectMethod(e20, r2, i2, a2, n2) || this.parseObjectProperty(e20, t2, s2, a2, o2);
    return u2 || this.unexpected(), u2;
  }
  parsePropertyName(e20, t2) {
    if (this.eat(bn$1.bracketL))
      e20.computed = true, e20.key = this.parseMaybeAssignAllowIn(), this.expect(bn$1.bracketR);
    else {
      const s2 = this.state.inPropertyName;
      this.state.inPropertyName = true;
      const r2 = this.state.type;
      e20.key = r2 === bn$1.num || r2 === bn$1.string || r2 === bn$1.bigint || r2 === bn$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(t2), r2 !== bn$1.privateName && (e20.computed = false), this.state.inPropertyName = s2;
    }
    return e20.key;
  }
  initFunction(e20, t2) {
    e20.id = null, e20.generator = false, e20.async = !!t2;
  }
  parseMethod(e20, t2, s2, r2, i2, a2, n2 = false) {
    this.initFunction(e20, s2), e20.generator = !!t2;
    const o2 = r2;
    return this.scope.enter(18 | (n2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(wo$1(s2, e20.generator)), this.parseFunctionParams(e20, o2), this.parseFunctionBodyAndFinish(e20, a2, true), this.prodParam.exit(), this.scope.exit(), e20;
  }
  parseArrayLike(e20, t2, s2, r2) {
    s2 && this.expectPlugin("recordAndTuple");
    const i2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const a2 = this.startNode();
    return this.next(), a2.elements = this.parseExprList(e20, !s2, r2, a2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a2, s2 ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(e20, t2, s2, r2) {
    this.scope.enter(6);
    let i2 = wo$1(s2, false);
    !this.match(bn$1.bracketL) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(e20, s2);
    const a2 = this.state.maybeInArrowParameters;
    return t2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e20, t2, r2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e20, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(e20, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(e20, t2, s2) {
    e20.params = this.toAssignableList(t2, s2, false);
  }
  parseFunctionBodyAndFinish(e20, t2, s2 = false) {
    this.parseFunctionBody(e20, false, s2), this.finishNode(e20, t2);
  }
  parseFunctionBody(e20, t2, s2 = false) {
    const r2 = t2 && !this.match(bn$1.braceL);
    if (this.expressionScope.enter(Po$1()), r2)
      e20.body = this.parseMaybeAssign(), this.checkParams(e20, false, t2, false);
    else {
      const r3 = this.state.strict, i2 = this.state.labels;
      this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e20.body = this.parseBlock(true, false, (i3) => {
        const a2 = !this.isSimpleParamList(e20.params);
        if (i3 && a2) {
          const t3 = e20.kind !== "method" && e20.kind !== "constructor" || !e20.key ? e20.start : e20.key.end;
          this.raise(t3, Rn$1.IllegalLanguageModeDirective);
        }
        const n2 = !r3 && this.state.strict;
        this.checkParams(e20, !(this.state.strict || t2 || s2 || a2), t2, n2), this.state.strict && e20.id && this.checkLVal(e20.id, "function name", 65, void 0, void 0, n2);
      }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i2;
    }
  }
  isSimpleParamList(e20) {
    for (let t2 = 0, s2 = e20.length; t2 < s2; t2++)
      if (e20[t2].type !== "Identifier")
        return false;
    return true;
  }
  checkParams(e20, t2, s2, r2 = true) {
    const i2 = new Set();
    for (const s3 of e20.params)
      this.checkLVal(s3, "function parameter list", 5, t2 ? null : i2, void 0, r2);
  }
  parseExprList(e20, t2, s2, r2) {
    const i2 = [];
    let a2 = true;
    for (; !this.eat(e20); ) {
      if (a2)
        a2 = false;
      else if (this.expect(bn$1.comma), this.match(e20)) {
        r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
        break;
      }
      i2.push(this.parseExprListItem(t2, s2));
    }
    return i2;
  }
  parseExprListItem(e20, t2, s2) {
    let r2;
    if (this.match(bn$1.comma))
      e20 || this.raise(this.state.pos, Rn$1.UnexpectedToken, ","), r2 = null;
    else if (this.match(bn$1.ellipsis)) {
      const e21 = this.state.start, s3 = this.state.startLoc;
      r2 = this.parseParenItem(this.parseSpread(t2), e21, s3);
    } else if (this.match(bn$1.question)) {
      this.expectPlugin("partialApplication"), s2 || this.raise(this.state.start, Rn$1.UnexpectedArgumentPlaceholder);
      const e21 = this.startNode();
      this.next(), r2 = this.finishNode(e21, "ArgumentPlaceholder");
    } else
      r2 = this.parseMaybeAssignAllowIn(t2, this.parseParenItem);
    return r2;
  }
  parseIdentifier(e20) {
    const t2 = this.startNode(), s2 = this.parseIdentifierName(t2.start, e20);
    return this.createIdentifier(t2, s2);
  }
  createIdentifier(e20, t2) {
    return e20.name = t2, e20.loc.identifierName = t2, this.finishNode(e20, "Identifier");
  }
  parseIdentifierName(e20, t2) {
    let s2;
    const {start: r2, type: i2} = this.state;
    if (i2 === bn$1.name)
      s2 = this.state.value;
    else {
      if (!i2.keyword)
        throw this.unexpected();
      s2 = i2.keyword;
    }
    return t2 ? this.state.type = bn$1.name : this.checkReservedWord(s2, r2, !!i2.keyword, false), this.next(), s2;
  }
  checkReservedWord(e20, t2, s2, r2) {
    if (e20.length > 10)
      return;
    if (!function(e21) {
      return uo$1.has(e21);
    }(e20))
      return;
    if (e20 === "yield") {
      if (this.prodParam.hasYield)
        return void this.raise(t2, Rn$1.YieldBindingIdentifier);
    } else if (e20 === "await") {
      if (this.prodParam.hasAwait)
        return void this.raise(t2, Rn$1.AwaitBindingIdentifier);
      if (this.scope.inStaticBlock)
        return void this.raise(t2, Rn$1.AwaitBindingIdentifierInStaticBlock);
      this.expressionScope.recordAsyncArrowParametersError(t2, Rn$1.AwaitBindingIdentifier);
    } else if (e20 === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
      return void this.raise(t2, Rn$1.ArgumentsInClass);
    if (s2 && oo$1(e20))
      return void this.raise(t2, Rn$1.UnexpectedKeyword, e20);
    (this.state.strict ? r2 ? no$1 : io$1 : ro$1)(e20, this.inModule) && this.raise(t2, Rn$1.UnexpectedReservedWord, e20);
  }
  isAwaitAllowed() {
    return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
  }
  parseAwait(e20, t2) {
    const s2 = this.startNodeAt(e20, t2);
    return this.expressionScope.recordParameterInitializerError(s2.start, Rn$1.AwaitExpressionFormalParameter), this.eat(bn$1.star) && this.raise(s2.start, Rn$1.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
  }
  isAmbiguousAwait() {
    return this.hasPrecedingLineBreak() || this.match(bn$1.plusMin) || this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.backQuote) || this.match(bn$1.regexp) || this.match(bn$1.slash) || this.hasPlugin("v8intrinsic") && this.match(bn$1.modulo);
  }
  parseYield() {
    const e20 = this.startNode();
    this.expressionScope.recordParameterInitializerError(e20.start, Rn$1.YieldInParameter), this.next();
    let t2 = false, s2 = null;
    if (!this.hasPrecedingLineBreak())
      switch (t2 = this.eat(bn$1.star), this.state.type) {
        case bn$1.semi:
        case bn$1.eof:
        case bn$1.braceR:
        case bn$1.parenR:
        case bn$1.bracketR:
        case bn$1.braceBarR:
        case bn$1.colon:
        case bn$1.comma:
          if (!t2)
            break;
        default:
          s2 = this.parseMaybeAssign();
      }
    return e20.delegate = t2, e20.argument = s2, this.finishNode(e20, "YieldExpression");
  }
  checkPipelineAtInfixOperator(e20, t2) {
    this.getPluginOption("pipelineOperator", "proposal") === "smart" && e20.type === "SequenceExpression" && this.raise(t2, Rn$1.PipelineHeadSequenceExpression);
  }
  checkHackPipeBodyEarlyErrors(e20) {
    if (this.match(bn$1.arrow))
      throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, bn$1.arrow.label);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(e20, Rn$1.PipeTopicUnused);
  }
  parseSmartPipelineBodyInStyle(e20, t2, s2) {
    const r2 = this.startNodeAt(t2, s2);
    return this.isSimpleReference(e20) ? (r2.callee = e20, this.finishNode(r2, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(t2), r2.expression = e20, this.finishNode(r2, "PipelineTopicExpression"));
  }
  isSimpleReference(e20) {
    switch (e20.type) {
      case "MemberExpression":
        return !e20.computed && this.isSimpleReference(e20.object);
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(e20) {
    if (this.match(bn$1.arrow))
      throw this.raise(this.state.start, Rn$1.PipelineBodyNoArrow);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(e20, Rn$1.PipelineTopicUnused);
  }
  withTopicBindingContext(e20) {
    const t2 = this.state.topicContext;
    this.state.topicContext = {maxNumOfResolvableTopics: 1, maxTopicIndex: null};
    try {
      return e20();
    } finally {
      this.state.topicContext = t2;
    }
  }
  withSmartMixTopicForbiddingContext(e20) {
    if (this.getPluginOption("pipelineOperator", "proposal") !== "smart")
      return e20();
    {
      const t2 = this.state.topicContext;
      this.state.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
      try {
        return e20();
      } finally {
        this.state.topicContext = t2;
      }
    }
  }
  withSoloAwaitPermittingContext(e20) {
    const t2 = this.state.soloAwait;
    this.state.soloAwait = true;
    try {
      return e20();
    } finally {
      this.state.soloAwait = t2;
    }
  }
  allowInAnd(e20) {
    const t2 = this.prodParam.currentFlags();
    if (8 & ~t2) {
      this.prodParam.enter(8 | t2);
      try {
        return e20();
      } finally {
        this.prodParam.exit();
      }
    }
    return e20();
  }
  disallowInAnd(e20) {
    const t2 = this.prodParam.currentFlags();
    if (8 & t2) {
      this.prodParam.enter(-9 & t2);
      try {
        return e20();
      } finally {
        this.prodParam.exit();
      }
    }
    return e20();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const r2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = true;
    const i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t2, s2, e20);
    return this.state.inFSharpPipelineDirectBody = r2, i2;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const e20 = this.startNode();
    this.next(), this.eat(bn$1.braceL);
    const t2 = this.initializeScopes(true);
    this.enterInitialScopes();
    const s2 = this.startNode();
    try {
      e20.body = this.parseProgram(s2, bn$1.braceR, "module");
    } finally {
      t2();
    }
    return this.eat(bn$1.braceR), this.finishNode(e20, "ModuleExpression");
  }
} {
  parseTopLevel(e20, t2) {
    return e20.program = this.parseProgram(t2), e20.comments = this.state.comments, this.options.tokens && (e20.tokens = function(e21) {
      for (let t3 = 0; t3 < e21.length; t3++) {
        const s2 = e21[t3];
        if (s2.type === bn$1.privateName) {
          const {loc: r2, start: i2, value: a2, end: n2} = s2, o2 = i2 + 1, u2 = new In$1(r2.start.line, r2.start.column + 1);
          e21.splice(t3, 1, new Eo$1({type: bn$1.hash, value: "#", start: i2, end: o2, startLoc: r2.start, endLoc: u2}), new Eo$1({type: bn$1.name, value: a2, start: o2, end: n2, startLoc: u2, endLoc: r2.end}));
        }
      }
      return e21;
    }(this.tokens)), this.finishNode(e20, "File");
  }
  parseProgram(e20, t2 = bn$1.eof, s2 = this.options.sourceType) {
    if (e20.sourceType = s2, e20.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e20, true, true, t2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [e21] of Array.from(this.scope.undefinedExports)) {
        const t3 = this.scope.undefinedExports.get(e21);
        this.raise(t3, Rn$1.ModuleExportUndefined, e21);
      }
    return this.finishNode(e20, "Program");
  }
  stmtToDirective(e20) {
    const t2 = e20;
    t2.type = "Directive", t2.value = t2.expression, delete t2.expression;
    const s2 = t2.value, r2 = this.input.slice(s2.start, s2.end), i2 = s2.value = r2.slice(1, -1);
    return this.addExtra(s2, "raw", r2), this.addExtra(s2, "rawValue", i2), s2.type = "DirectiveLiteral", t2;
  }
  parseInterpreterDirective() {
    if (!this.match(bn$1.interpreterDirective))
      return null;
    const e20 = this.startNode();
    return e20.value = this.state.value, this.next(), this.finishNode(e20, "InterpreterDirective");
  }
  isLet(e20) {
    return !!this.isContextual("let") && this.isLetKeyword(e20);
  }
  isLetKeyword(e20) {
    const t2 = this.nextTokenStart(), s2 = this.codePointAtPos(t2);
    if (s2 === 92 || s2 === 91)
      return true;
    if (e20)
      return false;
    if (s2 === 123)
      return true;
    if (Jn$1(s2)) {
      if (cu.lastIndex = t2, cu.test(this.input)) {
        const e21 = this.codePointAtPos(cu.lastIndex);
        if (!Yn$1(e21) && e21 !== 92)
          return false;
      }
      return true;
    }
    return false;
  }
  parseStatement(e20, t2) {
    return this.match(bn$1.at) && this.parseDecorators(true), this.parseStatementContent(e20, t2);
  }
  parseStatementContent(e20, t2) {
    let s2 = this.state.type;
    const r2 = this.startNode();
    let i2;
    switch (this.isLet(e20) && (s2 = bn$1._var, i2 = "let"), s2) {
      case bn$1._break:
      case bn$1._continue:
        return this.parseBreakContinueStatement(r2, s2.keyword);
      case bn$1._debugger:
        return this.parseDebuggerStatement(r2);
      case bn$1._do:
        return this.parseDoStatement(r2);
      case bn$1._for:
        return this.parseForStatement(r2);
      case bn$1._function:
        if (this.lookaheadCharCode() === 46)
          break;
        return e20 && (this.state.strict ? this.raise(this.state.start, Rn$1.StrictFunction) : e20 !== "if" && e20 !== "label" && this.raise(this.state.start, Rn$1.SloppyFunction)), this.parseFunctionStatement(r2, false, !e20);
      case bn$1._class:
        return e20 && this.unexpected(), this.parseClass(r2, true);
      case bn$1._if:
        return this.parseIfStatement(r2);
      case bn$1._return:
        return this.parseReturnStatement(r2);
      case bn$1._switch:
        return this.parseSwitchStatement(r2);
      case bn$1._throw:
        return this.parseThrowStatement(r2);
      case bn$1._try:
        return this.parseTryStatement(r2);
      case bn$1._const:
      case bn$1._var:
        return i2 = i2 || this.state.value, e20 && i2 !== "var" && this.raise(this.state.start, Rn$1.UnexpectedLexicalDeclaration), this.parseVarStatement(r2, i2);
      case bn$1._while:
        return this.parseWhileStatement(r2);
      case bn$1._with:
        return this.parseWithStatement(r2);
      case bn$1.braceL:
        return this.parseBlock();
      case bn$1.semi:
        return this.parseEmptyStatement(r2);
      case bn$1._import: {
        const e21 = this.lookaheadCharCode();
        if (e21 === 40 || e21 === 46)
          break;
      }
      case bn$1._export: {
        let e21;
        return this.options.allowImportExportEverywhere || t2 || this.raise(this.state.start, Rn$1.UnexpectedImportExport), this.next(), s2 === bn$1._import ? (e21 = this.parseImport(r2), e21.type !== "ImportDeclaration" || e21.importKind && e21.importKind !== "value" || (this.sawUnambiguousESM = true)) : (e21 = this.parseExport(r2), (e21.type !== "ExportNamedDeclaration" || e21.exportKind && e21.exportKind !== "value") && (e21.type !== "ExportAllDeclaration" || e21.exportKind && e21.exportKind !== "value") && e21.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r2), e21;
      }
      default:
        if (this.isAsyncFunction())
          return e20 && this.raise(this.state.start, Rn$1.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r2, true, !e20);
    }
    const a2 = this.state.value, n2 = this.parseExpression();
    return s2 === bn$1.name && n2.type === "Identifier" && this.eat(bn$1.colon) ? this.parseLabeledStatement(r2, a2, n2, e20) : this.parseExpressionStatement(r2, n2);
  }
  assertModuleNodeAllowed(e20) {
    this.options.allowImportExportEverywhere || this.inModule || this.raise(e20.start, jn$1.ImportOutsideModule);
  }
  takeDecorators(e20) {
    const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
    t2.length && (e20.decorators = t2, this.resetStartLocationFromNode(e20, t2[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
  }
  canHaveLeadingDecorator() {
    return this.match(bn$1._class);
  }
  parseDecorators(e20) {
    const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
    for (; this.match(bn$1.at); ) {
      const e21 = this.parseDecorator();
      t2.push(e21);
    }
    if (this.match(bn$1._export))
      e20 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorExportClass);
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(this.state.start, Rn$1.UnexpectedLeadingDecorator);
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators-legacy", "decorators"]);
    const e20 = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      this.state.decoratorStack.push([]);
      const t2 = this.state.start, s2 = this.state.startLoc;
      let r2;
      if (this.eat(bn$1.parenL))
        r2 = this.parseExpression(), this.expect(bn$1.parenR);
      else
        for (r2 = this.parseIdentifier(false); this.eat(bn$1.dot); ) {
          const e21 = this.startNodeAt(t2, s2);
          e21.object = r2, e21.property = this.parseIdentifier(true), e21.computed = false, r2 = this.finishNode(e21, "MemberExpression");
        }
      e20.expression = this.parseMaybeDecoratorArguments(r2), this.state.decoratorStack.pop();
    } else
      e20.expression = this.parseExprSubscripts();
    return this.finishNode(e20, "Decorator");
  }
  parseMaybeDecoratorArguments(e20) {
    if (this.eat(bn$1.parenL)) {
      const t2 = this.startNodeAtNode(e20);
      return t2.callee = e20, t2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.toReferencedList(t2.arguments), this.finishNode(t2, "CallExpression");
    }
    return e20;
  }
  parseBreakContinueStatement(e20, t2) {
    const s2 = t2 === "break";
    return this.next(), this.isLineTerminator() ? e20.label = null : (e20.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e20, t2), this.finishNode(e20, s2 ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(e20, t2) {
    const s2 = t2 === "break";
    let r2;
    for (r2 = 0; r2 < this.state.labels.length; ++r2) {
      const t3 = this.state.labels[r2];
      if (e20.label == null || t3.name === e20.label.name) {
        if (t3.kind != null && (s2 || t3.kind === "loop"))
          break;
        if (e20.label && s2)
          break;
      }
    }
    r2 === this.state.labels.length && this.raise(e20.start, Rn$1.IllegalBreakContinue, t2);
  }
  parseDebuggerStatement(e20) {
    return this.next(), this.semicolon(), this.finishNode(e20, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(bn$1.parenL);
    const e20 = this.parseExpression();
    return this.expect(bn$1.parenR), e20;
  }
  parseDoStatement(e20) {
    return this.next(), this.state.labels.push(ou), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(bn$1._while), e20.test = this.parseHeaderExpression(), this.eat(bn$1.semi), this.finishNode(e20, "DoWhileStatement");
  }
  parseForStatement(e20) {
    this.next(), this.state.labels.push(ou);
    let t2 = -1;
    if (this.isAwaitAllowed() && this.eatContextual("await") && (t2 = this.state.lastTokStart), this.scope.enter(0), this.expect(bn$1.parenL), this.match(bn$1.semi))
      return t2 > -1 && this.unexpected(t2), this.parseFor(e20, null);
    const s2 = this.isContextual("let"), r2 = s2 && this.isLetKeyword();
    if (this.match(bn$1._var) || this.match(bn$1._const) || r2) {
      const s3 = this.startNode(), i3 = r2 ? "let" : this.state.value;
      return this.next(), this.parseVar(s3, true, i3), this.finishNode(s3, "VariableDeclaration"), (this.match(bn$1._in) || this.isContextual("of")) && s3.declarations.length === 1 ? this.parseForIn(e20, s3, t2) : (t2 > -1 && this.unexpected(t2), this.parseFor(e20, s3));
    }
    const i2 = this.match(bn$1.name) && !this.state.containsEsc, a2 = new So$1(), n2 = this.parseExpression(true, a2), o2 = this.isContextual("of");
    if (o2 && (s2 ? this.raise(n2.start, Rn$1.ForOfLet) : t2 === -1 && i2 && n2.type === "Identifier" && n2.name === "async" && this.raise(n2.start, Rn$1.ForOfAsync)), o2 || this.match(bn$1._in)) {
      this.toAssignable(n2, true);
      const s3 = o2 ? "for-of statement" : "for-in statement";
      return this.checkLVal(n2, s3), this.parseForIn(e20, n2, t2);
    }
    return this.checkExpressionErrors(a2, true), t2 > -1 && this.unexpected(t2), this.parseFor(e20, n2);
  }
  parseFunctionStatement(e20, t2, s2) {
    return this.next(), this.parseFunction(e20, 1 | (s2 ? 0 : 2), t2);
  }
  parseIfStatement(e20) {
    return this.next(), e20.test = this.parseHeaderExpression(), e20.consequent = this.parseStatement("if"), e20.alternate = this.eat(bn$1._else) ? this.parseStatement("if") : null, this.finishNode(e20, "IfStatement");
  }
  parseReturnStatement(e20) {
    return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Rn$1.IllegalReturn), this.next(), this.isLineTerminator() ? e20.argument = null : (e20.argument = this.parseExpression(), this.semicolon()), this.finishNode(e20, "ReturnStatement");
  }
  parseSwitchStatement(e20) {
    this.next(), e20.discriminant = this.parseHeaderExpression();
    const t2 = e20.cases = [];
    let s2, r2;
    for (this.expect(bn$1.braceL), this.state.labels.push(uu), this.scope.enter(0); !this.match(bn$1.braceR); )
      if (this.match(bn$1._case) || this.match(bn$1._default)) {
        const e21 = this.match(bn$1._case);
        s2 && this.finishNode(s2, "SwitchCase"), t2.push(s2 = this.startNode()), s2.consequent = [], this.next(), e21 ? s2.test = this.parseExpression() : (r2 && this.raise(this.state.lastTokStart, Rn$1.MultipleDefaultsInSwitch), r2 = true, s2.test = null), this.expect(bn$1.colon);
      } else
        s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
    return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e20, "SwitchStatement");
  }
  parseThrowStatement(e20) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Rn$1.NewlineAfterThrow), e20.argument = this.parseExpression(), this.semicolon(), this.finishNode(e20, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const e20 = this.parseBindingAtom(), t2 = e20.type === "Identifier";
    return this.scope.enter(t2 ? 8 : 0), this.checkLVal(e20, "catch clause", 9), e20;
  }
  parseTryStatement(e20) {
    if (this.next(), e20.block = this.parseBlock(), e20.handler = null, this.match(bn$1._catch)) {
      const t2 = this.startNode();
      this.next(), this.match(bn$1.parenL) ? (this.expect(bn$1.parenL), t2.param = this.parseCatchClauseParam(), this.expect(bn$1.parenR)) : (t2.param = null, this.scope.enter(0)), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e20.handler = this.finishNode(t2, "CatchClause");
    }
    return e20.finalizer = this.eat(bn$1._finally) ? this.parseBlock() : null, e20.handler || e20.finalizer || this.raise(e20.start, Rn$1.NoCatchOrFinally), this.finishNode(e20, "TryStatement");
  }
  parseVarStatement(e20, t2) {
    return this.next(), this.parseVar(e20, false, t2), this.semicolon(), this.finishNode(e20, "VariableDeclaration");
  }
  parseWhileStatement(e20) {
    return this.next(), e20.test = this.parseHeaderExpression(), this.state.labels.push(ou), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e20, "WhileStatement");
  }
  parseWithStatement(e20) {
    return this.state.strict && this.raise(this.state.start, Rn$1.StrictWith), this.next(), e20.object = this.parseHeaderExpression(), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e20, "WithStatement");
  }
  parseEmptyStatement(e20) {
    return this.next(), this.finishNode(e20, "EmptyStatement");
  }
  parseLabeledStatement(e20, t2, s2, r2) {
    for (const e21 of this.state.labels)
      e21.name === t2 && this.raise(s2.start, Rn$1.LabelRedeclaration, t2);
    const i2 = this.state.type.isLoop ? "loop" : this.match(bn$1._switch) ? "switch" : null;
    for (let t3 = this.state.labels.length - 1; t3 >= 0; t3--) {
      const s3 = this.state.labels[t3];
      if (s3.statementStart !== e20.start)
        break;
      s3.statementStart = this.state.start, s3.kind = i2;
    }
    return this.state.labels.push({name: t2, kind: i2, statementStart: this.state.start}), e20.body = this.parseStatement(r2 ? r2.indexOf("label") === -1 ? r2 + "label" : r2 : "label"), this.state.labels.pop(), e20.label = s2, this.finishNode(e20, "LabeledStatement");
  }
  parseExpressionStatement(e20, t2) {
    return e20.expression = t2, this.semicolon(), this.finishNode(e20, "ExpressionStatement");
  }
  parseBlock(e20 = false, t2 = true, s2) {
    const r2 = this.startNode();
    return e20 && this.state.strictErrors.clear(), this.expect(bn$1.braceL), t2 && this.scope.enter(0), this.parseBlockBody(r2, e20, false, bn$1.braceR, s2), t2 && this.scope.exit(), this.finishNode(r2, "BlockStatement");
  }
  isValidDirective(e20) {
    return e20.type === "ExpressionStatement" && e20.expression.type === "StringLiteral" && !e20.expression.extra.parenthesized;
  }
  parseBlockBody(e20, t2, s2, r2, i2) {
    const a2 = e20.body = [], n2 = e20.directives = [];
    this.parseBlockOrModuleBlockBody(a2, t2 ? n2 : void 0, s2, r2, i2);
  }
  parseBlockOrModuleBlockBody(e20, t2, s2, r2, i2) {
    const a2 = this.state.strict;
    let n2 = false, o2 = false;
    for (; !this.match(r2); ) {
      const r3 = this.parseStatement(null, s2);
      if (t2 && !o2) {
        if (this.isValidDirective(r3)) {
          const e21 = this.stmtToDirective(r3);
          t2.push(e21), n2 || e21.value.value !== "use strict" || (n2 = true, this.setStrict(true));
          continue;
        }
        o2 = true, this.state.strictErrors.clear();
      }
      e20.push(r3);
    }
    i2 && i2.call(this, n2), a2 || this.setStrict(false), this.next();
  }
  parseFor(e20, t2) {
    return e20.init = t2, this.semicolon(false), e20.test = this.match(bn$1.semi) ? null : this.parseExpression(), this.semicolon(false), e20.update = this.match(bn$1.parenR) ? null : this.parseExpression(), this.expect(bn$1.parenR), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e20, "ForStatement");
  }
  parseForIn(e20, t2, s2) {
    const r2 = this.match(bn$1._in);
    return this.next(), r2 ? s2 > -1 && this.unexpected(s2) : e20.await = s2 > -1, t2.type !== "VariableDeclaration" || t2.declarations[0].init == null || r2 && !this.state.strict && t2.kind === "var" && t2.declarations[0].id.type === "Identifier" ? t2.type === "AssignmentPattern" && this.raise(t2.start, Rn$1.InvalidLhs, "for-loop") : this.raise(t2.start, Rn$1.ForInOfLoopInitializer, r2 ? "for-in" : "for-of"), e20.left = t2, e20.right = r2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(bn$1.parenR), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e20, r2 ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(e20, t2, s2) {
    const r2 = e20.declarations = [], i2 = this.hasPlugin("typescript");
    for (e20.kind = s2; ; ) {
      const e21 = this.startNode();
      if (this.parseVarId(e21, s2), this.eat(bn$1.eq) ? e21.init = t2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (s2 !== "const" || this.match(bn$1._in) || this.isContextual("of") ? e21.id.type === "Identifier" || t2 && (this.match(bn$1._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Complex binding patterns") : i2 || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Const declarations"), e21.init = null), r2.push(this.finishNode(e21, "VariableDeclarator")), !this.eat(bn$1.comma))
        break;
    }
    return e20;
  }
  parseVarId(e20, t2) {
    e20.id = this.parseBindingAtom(), this.checkLVal(e20.id, "variable declaration", t2 === "var" ? 5 : 9, void 0, t2 !== "var");
  }
  parseFunction(e20, t2 = 0, s2 = false) {
    const r2 = 1 & t2, i2 = 2 & t2, a2 = !(!r2 || 4 & t2);
    this.initFunction(e20, s2), this.match(bn$1.star) && i2 && this.raise(this.state.start, Rn$1.GeneratorInSingleStatementContext), e20.generator = this.eat(bn$1.star), r2 && (e20.id = this.parseFunctionId(a2));
    const n2 = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(wo$1(s2, e20.generator)), r2 || (e20.id = this.parseFunctionId()), this.parseFunctionParams(e20, false), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(e20, r2 ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), r2 && !i2 && this.registerFunctionStatementId(e20), this.state.maybeInArrowParameters = n2, e20;
  }
  parseFunctionId(e20) {
    return e20 || this.match(bn$1.name) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(e20, t2) {
    this.expect(bn$1.parenL), this.expressionScope.enter(new Fo$1(3)), e20.params = this.parseBindingList(bn$1.parenR, 41, false, t2), this.expressionScope.exit();
  }
  registerFunctionStatementId(e20) {
    e20.id && this.scope.declareName(e20.id.name, this.state.strict || e20.generator || e20.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, e20.id.start);
  }
  parseClass(e20, t2, s2) {
    this.next(), this.takeDecorators(e20);
    const r2 = this.state.strict;
    return this.state.strict = true, this.parseClassId(e20, t2, s2), this.parseClassSuper(e20), e20.body = this.parseClassBody(!!e20.superClass, r2), this.finishNode(e20, t2 ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(bn$1.eq) || this.match(bn$1.semi) || this.match(bn$1.braceR);
  }
  isClassMethod() {
    return this.match(bn$1.parenL);
  }
  isNonstaticConstructor(e20) {
    return !(e20.computed || e20.static || e20.key.name !== "constructor" && e20.key.value !== "constructor");
  }
  parseClassBody(e20, t2) {
    this.classScope.enter();
    const s2 = {hadConstructor: false, hadSuperClass: e20};
    let r2 = [];
    const i2 = this.startNode();
    if (i2.body = [], this.expect(bn$1.braceL), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(bn$1.braceR); ) {
        if (this.eat(bn$1.semi)) {
          if (r2.length > 0)
            throw this.raise(this.state.lastTokEnd, Rn$1.DecoratorSemicolon);
          continue;
        }
        if (this.match(bn$1.at)) {
          r2.push(this.parseDecorator());
          continue;
        }
        const e21 = this.startNode();
        r2.length && (e21.decorators = r2, this.resetStartLocationFromNode(e21, r2[0]), r2 = []), this.parseClassMember(i2, e21, s2), e21.kind === "constructor" && e21.decorators && e21.decorators.length > 0 && this.raise(e21.start, Rn$1.DecoratorConstructor);
      }
    }), this.state.strict = t2, this.next(), r2.length)
      throw this.raise(this.state.start, Rn$1.TrailingDecorator);
    return this.classScope.exit(), this.finishNode(i2, "ClassBody");
  }
  parseClassMemberFromModifier(e20, t2) {
    const s2 = this.parseIdentifier(true);
    if (this.isClassMethod()) {
      const r2 = t2;
      return r2.kind = "method", r2.computed = false, r2.key = s2, r2.static = false, this.pushClassMethod(e20, r2, false, false, false, false), true;
    }
    if (this.isClassProperty()) {
      const r2 = t2;
      return r2.computed = false, r2.key = s2, r2.static = false, e20.body.push(this.parseClassProperty(r2)), true;
    }
    return this.resetPreviousNodeTrailingComments(s2), false;
  }
  parseClassMember(e20, t2, s2) {
    const r2 = this.isContextual("static");
    if (r2) {
      if (this.parseClassMemberFromModifier(e20, t2))
        return;
      if (this.eat(bn$1.braceL))
        return void this.parseClassStaticBlock(e20, t2);
    }
    this.parseClassMemberWithIsStatic(e20, t2, s2, r2);
  }
  parseClassMemberWithIsStatic(e20, t2, s2, r2) {
    const i2 = t2, a2 = t2, n2 = t2, o2 = t2, u2 = i2, h2 = i2;
    if (t2.static = r2, this.eat(bn$1.star)) {
      u2.kind = "method";
      const t3 = this.match(bn$1.privateName);
      return this.parseClassElementName(u2), t3 ? void this.pushClassPrivateMethod(e20, a2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsGenerator), void this.pushClassMethod(e20, i2, true, false, false, false));
    }
    const c2 = this.match(bn$1.name) && !this.state.containsEsc, p2 = this.match(bn$1.privateName), l2 = this.parseClassElementName(t2), d2 = this.state.start;
    if (this.parsePostMemberNameModifiers(h2), this.isClassMethod()) {
      if (u2.kind = "method", p2)
        return void this.pushClassPrivateMethod(e20, a2, false, false);
      const r3 = this.isNonstaticConstructor(i2);
      let n3 = false;
      r3 && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(l2.start, Rn$1.DuplicateConstructor), r3 && this.hasPlugin("typescript") && t2.override && this.raise(l2.start, Rn$1.OverrideOnConstructor), s2.hadConstructor = true, n3 = s2.hadSuperClass), this.pushClassMethod(e20, i2, false, false, r3, n3);
    } else if (this.isClassProperty())
      p2 ? this.pushClassPrivateProperty(e20, o2) : this.pushClassProperty(e20, n2);
    else if (c2 && l2.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(l2);
      const t3 = this.eat(bn$1.star);
      h2.optional && this.unexpected(d2), u2.kind = "method";
      const s3 = this.match(bn$1.privateName);
      this.parseClassElementName(u2), this.parsePostMemberNameModifiers(h2), s3 ? this.pushClassPrivateMethod(e20, a2, t3, true) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAsync), this.pushClassMethod(e20, i2, t3, true, false, false));
    } else if (!c2 || l2.name !== "get" && l2.name !== "set" || this.match(bn$1.star) && this.isLineTerminator())
      this.isLineTerminator() ? p2 ? this.pushClassPrivateProperty(e20, o2) : this.pushClassProperty(e20, n2) : this.unexpected();
    else {
      this.resetPreviousNodeTrailingComments(l2), u2.kind = l2.name;
      const t3 = this.match(bn$1.privateName);
      this.parseClassElementName(i2), t3 ? this.pushClassPrivateMethod(e20, a2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAccessor), this.pushClassMethod(e20, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
    }
  }
  parseClassElementName(e20) {
    const {type: t2, value: s2, start: r2} = this.state;
    return t2 !== bn$1.name && t2 !== bn$1.string || !e20.static || s2 !== "prototype" || this.raise(r2, Rn$1.StaticPrototype), t2 === bn$1.privateName && s2 === "constructor" && this.raise(r2, Rn$1.ConstructorClassPrivateField), this.parsePropertyName(e20, true);
  }
  parseClassStaticBlock(e20, t2) {
    var s2;
    this.expectPlugin("classStaticBlock", t2.start), this.scope.enter(208);
    const r2 = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    const i2 = t2.body = [];
    this.parseBlockOrModuleBlockBody(i2, void 0, false, bn$1.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = r2, e20.body.push(this.finishNode(t2, "StaticBlock")), (s2 = t2.decorators) != null && s2.length && this.raise(t2.start, Rn$1.DecoratorStaticBlock);
  }
  pushClassProperty(e20, t2) {
    t2.computed || t2.key.name !== "constructor" && t2.key.value !== "constructor" || this.raise(t2.key.start, Rn$1.ConstructorClassField), e20.body.push(this.parseClassProperty(t2));
  }
  pushClassPrivateProperty(e20, t2) {
    const s2 = this.parseClassPrivateProperty(t2);
    e20.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.start);
  }
  pushClassMethod(e20, t2, s2, r2, i2, a2) {
    e20.body.push(this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true));
  }
  pushClassPrivateMethod(e20, t2, s2, r2) {
    const i2 = this.parseMethod(t2, s2, r2, false, false, "ClassPrivateMethod", true);
    e20.body.push(i2);
    const a2 = i2.kind === "get" ? i2.static ? 6 : 2 : i2.kind === "set" ? i2.static ? 5 : 1 : 0;
    this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), a2, i2.key.start);
  }
  parsePostMemberNameModifiers(e20) {
  }
  parseClassPrivateProperty(e20) {
    return this.parseInitializer(e20), this.semicolon(), this.finishNode(e20, "ClassPrivateProperty");
  }
  parseClassProperty(e20) {
    return this.parseInitializer(e20), this.semicolon(), this.finishNode(e20, "ClassProperty");
  }
  parseInitializer(e20) {
    this.scope.enter(80), this.expressionScope.enter(Po$1()), this.prodParam.enter(0), e20.value = this.eat(bn$1.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(e20, t2, s2, r2 = 139) {
    this.match(bn$1.name) ? (e20.id = this.parseIdentifier(), t2 && this.checkLVal(e20.id, "class name", r2)) : s2 || !t2 ? e20.id = null : this.unexpected(null, Rn$1.MissingClassName);
  }
  parseClassSuper(e20) {
    e20.superClass = this.eat(bn$1._extends) ? this.parseExprSubscripts() : null;
  }
  parseExport(e20) {
    const t2 = this.maybeParseExportDefaultSpecifier(e20), s2 = !t2 || this.eat(bn$1.comma), r2 = s2 && this.eatExportStar(e20), i2 = r2 && this.maybeParseExportNamespaceSpecifier(e20), a2 = s2 && (!i2 || this.eat(bn$1.comma)), n2 = t2 || r2;
    if (r2 && !i2)
      return t2 && this.unexpected(), this.parseExportFrom(e20, true), this.finishNode(e20, "ExportAllDeclaration");
    const o2 = this.maybeParseExportNamedSpecifiers(e20);
    if (t2 && s2 && !r2 && !o2 || i2 && a2 && !o2)
      throw this.unexpected(null, bn$1.braceL);
    let u2;
    if (n2 || o2 ? (u2 = false, this.parseExportFrom(e20, n2)) : u2 = this.maybeParseExportDeclaration(e20), n2 || o2 || u2)
      return this.checkExport(e20, true, false, !!e20.source), this.finishNode(e20, "ExportNamedDeclaration");
    if (this.eat(bn$1._default))
      return e20.declaration = this.parseExportDefaultExpression(), this.checkExport(e20, true, true), this.finishNode(e20, "ExportDefaultDeclaration");
    throw this.unexpected(null, bn$1.braceL);
  }
  eatExportStar(e20) {
    return this.eat(bn$1.star);
  }
  maybeParseExportDefaultSpecifier(e20) {
    if (this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom");
      const t2 = this.startNode();
      return t2.exported = this.parseIdentifier(true), e20.specifiers = [this.finishNode(t2, "ExportDefaultSpecifier")], true;
    }
    return false;
  }
  maybeParseExportNamespaceSpecifier(e20) {
    if (this.isContextual("as")) {
      e20.specifiers || (e20.specifiers = []);
      const t2 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
      return this.next(), t2.exported = this.parseModuleExportName(), e20.specifiers.push(this.finishNode(t2, "ExportNamespaceSpecifier")), true;
    }
    return false;
  }
  maybeParseExportNamedSpecifiers(e20) {
    return !!this.match(bn$1.braceL) && (e20.specifiers || (e20.specifiers = []), e20.specifiers.push(...this.parseExportSpecifiers()), e20.source = null, e20.declaration = null, true);
  }
  maybeParseExportDeclaration(e20) {
    return !!this.shouldParseExportDeclaration() && (e20.specifiers = [], e20.source = null, e20.declaration = this.parseExportDeclaration(e20), true);
  }
  isAsyncFunction() {
    if (!this.isContextual("async"))
      return false;
    const e20 = this.nextTokenStart();
    return !Pn$1.test(this.input.slice(this.state.pos, e20)) && this.isUnparsedContextual(e20, "function");
  }
  parseExportDefaultExpression() {
    const e20 = this.startNode(), t2 = this.isAsyncFunction();
    if (this.match(bn$1._function) || t2)
      return this.next(), t2 && this.next(), this.parseFunction(e20, 5, t2);
    if (this.match(bn$1._class))
      return this.parseClass(e20, true, true);
    if (this.match(bn$1.at))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(e20, true, true);
    if (this.match(bn$1._const) || this.match(bn$1._var) || this.isLet())
      throw this.raise(this.state.start, Rn$1.UnsupportedDefaultExport);
    {
      const e21 = this.parseMaybeAssignAllowIn();
      return this.semicolon(), e21;
    }
  }
  parseExportDeclaration(e20) {
    return this.parseStatement(null);
  }
  isExportDefaultSpecifier() {
    if (this.match(bn$1.name)) {
      const e21 = this.state.value;
      if (e21 === "async" && !this.state.containsEsc || e21 === "let")
        return false;
      if ((e21 === "type" || e21 === "interface") && !this.state.containsEsc) {
        const e22 = this.lookahead();
        if (e22.type === bn$1.name && e22.value !== "from" || e22.type === bn$1.braceL)
          return this.expectOnePlugin(["flow", "typescript"]), false;
      }
    } else if (!this.match(bn$1._default))
      return false;
    const e20 = this.nextTokenStart(), t2 = this.isUnparsedContextual(e20, "from");
    if (this.input.charCodeAt(e20) === 44 || this.match(bn$1.name) && t2)
      return true;
    if (this.match(bn$1._default) && t2) {
      const t3 = this.input.charCodeAt(this.nextTokenStartSince(e20 + 4));
      return t3 === 34 || t3 === 39;
    }
    return false;
  }
  parseExportFrom(e20, t2) {
    if (this.eatContextual("from")) {
      e20.source = this.parseImportSource(), this.checkExport(e20);
      const t3 = this.maybeParseImportAssertions();
      t3 && (e20.assertions = t3);
    } else
      t2 ? this.unexpected() : e20.source = null;
    this.semicolon();
  }
  shouldParseExportDeclaration() {
    if (this.match(bn$1.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
      if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
        return true;
      this.unexpected(this.state.start, Rn$1.DecoratorBeforeExport);
    }
    return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
  }
  checkExport(e20, t2, s2, r2) {
    if (t2) {
      if (s2) {
        if (this.checkDuplicateExports(e20, "default"), this.hasPlugin("exportDefaultFrom")) {
          var i2;
          const t3 = e20.declaration;
          t3.type !== "Identifier" || t3.name !== "from" || t3.end - t3.start != 4 || (i2 = t3.extra) != null && i2.parenthesized || this.raise(t3.start, Rn$1.ExportDefaultFromAsIdentifier);
        }
      } else if (e20.specifiers && e20.specifiers.length)
        for (const t3 of e20.specifiers) {
          const {exported: e21} = t3, s3 = e21.type === "Identifier" ? e21.name : e21.value;
          if (this.checkDuplicateExports(t3, s3), !r2 && t3.local) {
            const {local: e22} = t3;
            e22.type !== "Identifier" ? this.raise(t3.start, Rn$1.ExportBindingIsString, e22.value, s3) : (this.checkReservedWord(e22.name, e22.start, true, false), this.scope.checkLocalExport(e22));
          }
        }
      else if (e20.declaration) {
        if (e20.declaration.type === "FunctionDeclaration" || e20.declaration.type === "ClassDeclaration") {
          const t3 = e20.declaration.id;
          if (!t3)
            throw new Error("Assertion failure");
          this.checkDuplicateExports(e20, t3.name);
        } else if (e20.declaration.type === "VariableDeclaration")
          for (const t3 of e20.declaration.declarations)
            this.checkDeclaration(t3.id);
      }
    }
    if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
      throw this.raise(e20.start, Rn$1.UnsupportedDecoratorExport);
  }
  checkDeclaration(e20) {
    if (e20.type === "Identifier")
      this.checkDuplicateExports(e20, e20.name);
    else if (e20.type === "ObjectPattern")
      for (const t2 of e20.properties)
        this.checkDeclaration(t2);
    else if (e20.type === "ArrayPattern")
      for (const t2 of e20.elements)
        t2 && this.checkDeclaration(t2);
    else
      e20.type === "ObjectProperty" ? this.checkDeclaration(e20.value) : e20.type === "RestElement" ? this.checkDeclaration(e20.argument) : e20.type === "AssignmentPattern" && this.checkDeclaration(e20.left);
  }
  checkDuplicateExports(e20, t2) {
    this.exportedIdentifiers.has(t2) && this.raise(e20.start, t2 === "default" ? Rn$1.DuplicateDefaultExport : Rn$1.DuplicateExport, t2), this.exportedIdentifiers.add(t2);
  }
  parseExportSpecifiers() {
    const e20 = [];
    let t2 = true;
    for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
      if (t2)
        t2 = false;
      else if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
        break;
      const s2 = this.startNode(), r2 = this.match(bn$1.string), i2 = this.parseModuleExportName();
      s2.local = i2, this.eatContextual("as") ? s2.exported = this.parseModuleExportName() : s2.exported = r2 ? vo$1(i2) : Io$1(i2), e20.push(this.finishNode(s2, "ExportSpecifier"));
    }
    return e20;
  }
  parseModuleExportName() {
    if (this.match(bn$1.string)) {
      const e20 = this.parseStringLiteral(this.state.value), t2 = e20.value.match(hu);
      return t2 && this.raise(e20.start, Rn$1.ModuleExportNameHasLoneSurrogate, t2[0].charCodeAt(0).toString(16)), e20;
    }
    return this.parseIdentifier(true);
  }
  parseImport(e20) {
    if (e20.specifiers = [], !this.match(bn$1.string)) {
      const t3 = !this.maybeParseDefaultImportSpecifier(e20) || this.eat(bn$1.comma), s2 = t3 && this.maybeParseStarImportSpecifier(e20);
      t3 && !s2 && this.parseNamedImportSpecifiers(e20), this.expectContextual("from");
    }
    e20.source = this.parseImportSource();
    const t2 = this.maybeParseImportAssertions();
    if (t2)
      e20.assertions = t2;
    else {
      const t3 = this.maybeParseModuleAttributes();
      t3 && (e20.attributes = t3);
    }
    return this.semicolon(), this.finishNode(e20, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(bn$1.string) || this.unexpected(), this.parseExprAtom();
  }
  shouldParseDefaultImport(e20) {
    return this.match(bn$1.name);
  }
  parseImportSpecifierLocal(e20, t2, s2, r2) {
    t2.local = this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e20.specifiers.push(this.finishNode(t2, s2));
  }
  parseAssertEntries() {
    const e20 = [], t2 = new Set();
    do {
      if (this.match(bn$1.braceR))
        break;
      const s2 = this.startNode(), r2 = this.state.value;
      if (t2.has(r2) && this.raise(this.state.start, Rn$1.ModuleAttributesWithDuplicateKeys, r2), t2.add(r2), this.match(bn$1.string) ? s2.key = this.parseStringLiteral(r2) : s2.key = this.parseIdentifier(true), this.expect(bn$1.colon), !this.match(bn$1.string))
        throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
      s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e20.push(s2);
    } while (this.eat(bn$1.comma));
    return e20;
  }
  maybeParseModuleAttributes() {
    if (!this.match(bn$1._with) || this.hasPrecedingLineBreak())
      return this.hasPlugin("moduleAttributes") ? [] : null;
    this.expectPlugin("moduleAttributes"), this.next();
    const e20 = [], t2 = new Set();
    do {
      const s2 = this.startNode();
      if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(s2.key.start, Rn$1.ModuleAttributeDifferentFromType, s2.key.name), t2.has(s2.key.name) && this.raise(s2.key.start, Rn$1.ModuleAttributesWithDuplicateKeys, s2.key.name), t2.add(s2.key.name), this.expect(bn$1.colon), !this.match(bn$1.string))
        throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
      s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e20.push(s2);
    } while (this.eat(bn$1.comma));
    return e20;
  }
  maybeParseImportAssertions() {
    if (!this.isContextual("assert") || this.hasPrecedingLineBreak())
      return this.hasPlugin("importAssertions") ? [] : null;
    this.expectPlugin("importAssertions"), this.next(), this.eat(bn$1.braceL);
    const e20 = this.parseAssertEntries();
    return this.eat(bn$1.braceR), e20;
  }
  maybeParseDefaultImportSpecifier(e20) {
    return !!this.shouldParseDefaultImport(e20) && (this.parseImportSpecifierLocal(e20, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
  }
  maybeParseStarImportSpecifier(e20) {
    if (this.match(bn$1.star)) {
      const t2 = this.startNode();
      return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(e20, t2, "ImportNamespaceSpecifier", "import namespace specifier"), true;
    }
    return false;
  }
  parseNamedImportSpecifiers(e20) {
    let t2 = true;
    for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
      if (t2)
        t2 = false;
      else {
        if (this.eat(bn$1.colon))
          throw this.raise(this.state.start, Rn$1.DestructureNamedImport);
        if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
          break;
      }
      this.parseImportSpecifier(e20);
    }
  }
  parseImportSpecifier(e20) {
    const t2 = this.startNode(), s2 = this.match(bn$1.string);
    if (t2.imported = this.parseModuleExportName(), this.eatContextual("as"))
      t2.local = this.parseIdentifier();
    else {
      const {imported: e21} = t2;
      if (s2)
        throw this.raise(t2.start, Rn$1.ImportBindingIsString, e21.value);
      this.checkReservedWord(e21.name, t2.start, true, true), t2.local = Io$1(e21);
    }
    this.checkLVal(t2.local, "import specifier", 9), e20.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
  }
  isThisParam(e20) {
    return e20.type === "Identifier" && e20.name === "this";
  }
} {
  constructor(e20, t2) {
    super(e20 = function(e21) {
      const t3 = {};
      for (const s2 of Object.keys(au))
        t3[s2] = e21 && e21[s2] != null ? e21[s2] : au[s2];
      return t3;
    }(e20), t2), this.options = e20, this.initializeScopes(), this.plugins = function(e21) {
      const t3 = new Map();
      for (const s2 of e21) {
        const [e22, r2] = Array.isArray(s2) ? s2 : [s2, {}];
        t3.has(e22) || t3.set(e22, r2 || {});
      }
      return t3;
    }(this.options.plugins), this.filename = e20.sourceFilename;
  }
  getScopeHandler() {
    return co$1;
  }
  parse() {
    this.enterInitialScopes();
    const e20 = this.startNode(), t2 = this.startNode();
    return this.nextToken(), e20.errors = null, this.parseTopLevel(e20, t2), e20.errors = this.state.errors, e20;
  }
}
function lu(e20, t2) {
  let s2 = pu;
  return e20 != null && e20.plugins && (!function(e21) {
    if (Qo(e21, "decorators")) {
      if (Qo(e21, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const t3 = Zo(e21, "decorators", "decoratorsBeforeExport");
      if (t3 == null)
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      if (typeof t3 != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (Qo(e21, "flow") && Qo(e21, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Qo(e21, "placeholders") && Qo(e21, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Qo(e21, "pipelineOperator")) {
      const t3 = Zo(e21, "pipelineOperator", "proposal");
      if (!eu.includes(t3)) {
        const e22 = eu.map((e23) => `"${e23}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e22}.`);
      }
      const s3 = Qo(e21, "recordAndTuple") && Zo(e21, "recordAndTuple", "syntaxType") === "hash";
      if (t3 === "hack") {
        if (Qo(e21, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Qo(e21, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const t4 = Zo(e21, "pipelineOperator", "topicToken");
        if (!tu.includes(t4)) {
          const e22 = tu.map((e23) => `"${e23}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e22}.`);
        }
        if (t4 === "#" && s3)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (t3 === "smart" && s3)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (Qo(e21, "moduleAttributes")) {
      if (Qo(e21, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (Zo(e21, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (Qo(e21, "recordAndTuple") && !su.includes(Zo(e21, "recordAndTuple", "syntaxType")))
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + su.map((e22) => `'${e22}'`).join(", "));
    if (Qo(e21, "asyncDoExpressions") && !Qo(e21, "doExpressions")) {
      const e22 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e22.missingPlugins = "doExpressions", e22;
    }
  }(e20.plugins), s2 = function(e21) {
    const t3 = iu.filter((t4) => Qo(e21, t4)), s3 = t3.join("/");
    let r2 = du[s3];
    if (!r2) {
      r2 = pu;
      for (const e22 of t3)
        r2 = ru[e22](r2);
      du[s3] = r2;
    }
    return r2;
  }(e20.plugins)), new s2(e20, t2);
}
const du = {};
var Du = function(e20, t2) {
  var s2;
  if (((s2 = t2) == null ? void 0 : s2.sourceType) !== "unambiguous")
    return lu(t2, e20).parse();
  t2 = Object.assign({}, t2);
  try {
    t2.sourceType = "module";
    const s3 = lu(t2, e20), r2 = s3.parse();
    if (s3.sawUnambiguousESM)
      return r2;
    if (s3.ambiguousScriptDifferentAst)
      try {
        return t2.sourceType = "script", lu(t2, e20).parse();
      } catch (e21) {
      }
    else
      r2.program.sourceType = "script";
    return r2;
  } catch (s3) {
    try {
      return t2.sourceType = "script", lu(t2, e20).parse();
    } catch (e21) {
    }
    throw s3;
  }
}, mu = function(e20, t2) {
  const s2 = lu(t2, e20);
  return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
}, fu = bn$1, yu = Object.defineProperty({parse: Du, parseExpression: mu, tokTypes: fu}, "__esModule", {value: true});
const {isNonEmptyArray: Au} = tr$1;
function Eu(e20 = {}) {
  const {allowComments: t2 = true} = e20;
  return function(e21) {
    const {parseExpression: s2} = yu;
    let r2;
    try {
      r2 = s2(e21, {tokens: true, ranges: true});
    } catch (e22) {
      throw ni$1(e22);
    }
    if (!t2 && Au(r2.comments))
      throw Cu(r2.comments[0], "Comment");
    return xu(r2), r2;
  };
}
function Cu(e20, t2) {
  const [s2, r2] = [e20.loc.start, e20.loc.end].map(({line: e21, column: t3}) => ({line: e21, column: t3 + 1}));
  return ai$1(`${t2} is not allowed in JSON.`, {start: s2, end: r2});
}
function xu(e20) {
  switch (e20.type) {
    case "ArrayExpression":
      for (const t2 of e20.elements)
        t2 !== null && xu(t2);
      return;
    case "ObjectExpression":
      for (const t2 of e20.properties)
        xu(t2);
      return;
    case "ObjectProperty":
      if (e20.computed)
        throw Cu(e20.key, "Computed key");
      if (e20.shorthand)
        throw Cu(e20.key, "Shorthand property");
      return e20.key.type !== "Identifier" && xu(e20.key), void xu(e20.value);
    case "UnaryExpression": {
      const {operator: t2, argument: s2} = e20;
      if (t2 !== "+" && t2 !== "-")
        throw Cu(e20, `Operator '${e20.operator}'`);
      if (s2.type === "NumericLiteral" || s2.type === "Identifier" && (s2.name === "Infinity" || s2.name === "NaN"))
        return;
      throw Cu(s2, `Operator '${t2}' before '${s2.type}'`);
    }
    case "Identifier":
      if (e20.name !== "Infinity" && e20.name !== "NaN" && e20.name !== "undefined")
        throw Cu(e20, `Identifier '${e20.name}'`);
      return;
    case "TemplateLiteral":
      if (Au(e20.expressions))
        throw Cu(e20.expressions[0], "'TemplateLiteral' with expression");
      for (const t2 of e20.quasis)
        xu(t2);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw Cu(e20, `'${e20.type}'`);
  }
}
const Fu = Eu();
var gu = {json: ii$1({parse: Fu, hasPragma: () => true}), json5: ii$1(Fu), "json-stringify": ii$1({parse: Eu({allowComments: false}), astFormat: "estree-json"})};
const {getNextNonSpaceNonCommentCharacterIndexWithStartIndex: bu, getShebang: Pu} = tr$1, Tu = {sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", {decoratorsBeforeExport: false}], "importAssertions", "decimal", "classStaticBlock", "moduleBlocks", "asyncDoExpressions"], tokens: true, ranges: true}, wu = ["recordAndTuple", {syntaxType: "hash"}], Su = [["pipelineOperator", {proposal: "hack", topicToken: "%"}], ["pipelineOperator", {proposal: "minimal"}], ["pipelineOperator", {proposal: "fsharp"}]], Bu = (e20, t2 = Tu) => Object.assign(Object.assign({}, t2), {}, {plugins: [...t2.plugins, ...e20]}), Nu = /@(?:no)?flow\b/;
function Iu(e20, ...t2) {
  return (s2, r2, i2 = {}) => {
    if ((i2.parser === "babel" || i2.parser === "__babel_estree") && function(e21, t3) {
      if (t3.filepath && t3.filepath.endsWith(".js.flow"))
        return true;
      const s3 = Pu(e21);
      s3 && (e21 = e21.slice(s3.length));
      const r3 = bu(e21, 0);
      return r3 !== false && (e21 = e21.slice(0, r3)), Nu.test(e21);
    }(s2, i2))
      return i2.parser = "babel-flow", ku(s2, r2, i2);
    let a2 = t2;
    i2.__babelSourceType === "script" && (a2 = a2.map((e21) => Object.assign(Object.assign({}, e21), {}, {sourceType: "script"}))), /#[[{]/.test(s2) && (a2 = a2.map((e21) => Bu([wu], e21)));
    const n2 = /%[A-Z]/.test(s2);
    if (s2.includes("|>")) {
      const e21 = n2 ? [...Su, "v8intrinsic"] : Su;
      a2 = e21.flatMap((e22) => a2.map((t3) => Bu([e22], t3)));
    } else
      n2 && (a2 = a2.map((e21) => Bu(["v8intrinsic"], e21)));
    const {result: o2, error: u2} = Je$2(...a2.map((t3) => () => function(e21, t4, s3) {
      const r3 = (0, yu[e21])(t4, s3), i3 = r3.errors.find((e22) => !Ru.has(e22.reasonCode));
      if (i3)
        throw i3;
      return r3;
    }(e20, s2, t3)));
    if (!o2)
      throw ni$1(u2);
    return En$1(o2, Object.assign(Object.assign({}, i2), {}, {originalText: s2}));
  };
}
const vu = Iu("parse", Bu(["jsx", "flow"])), ku = Iu("parse", Bu(["jsx", ["flow", {all: true, enums: true}]])), Lu = Iu("parse", Bu(["jsx", "typescript"]), Bu(["typescript"])), Ou = Iu("parse", Bu(["jsx", "flow", "estree"])), Mu = Iu("parseExpression", Bu(["jsx"])), Ru = new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), ju = ii$1(vu), _u = ii$1(Mu);
var Uu = {parsers: Object.assign(Object.assign({babel: ju, "babel-flow": ii$1(ku), "babel-ts": ii$1(Lu)}, gu), {}, {__js_expression: _u, __vue_expression: _u, __vue_event_binding: ju, __babel_estree: ii$1(Ou)})};
var e$1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function t$1(e20) {
  var t2 = {exports: {}};
  return e20(t2, t2.exports), t2.exports;
}
var r$1 = t$1(function(e20, t2) {
  function r2(e21) {
    return t2.$0 <= e21 && e21 <= t2.$9;
  }
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  Object.defineProperty(t2, "__esModule", {value: true}), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e21) {
    return e21 >= t2.$TAB && e21 <= t2.$SPACE || e21 == t2.$NBSP;
  }, t2.isDigit = r2, t2.isAsciiLetter = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$z || e21 >= t2.$A && e21 <= t2.$Z;
  }, t2.isAsciiHexDigit = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$f || e21 >= t2.$A && e21 <= t2.$F || r2(e21);
  }, t2.isNewLine = function(e21) {
    return e21 === t2.$LF || e21 === t2.$CR;
  }, t2.isOctalDigit = function(e21) {
    return t2.$0 <= e21 && e21 <= t2.$7;
  };
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class n$1 {
  constructor(e20, t2, r2) {
    this.filePath = e20, this.name = t2, this.members = r2;
  }
  assertNoMembers() {
    if (this.members.length)
      throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
  }
}
var i$1 = n$1;
var s$1 = class {
  constructor() {
    this.cache = new Map();
  }
  get(e20, t2, r2) {
    const i2 = `"${e20}".${t2}${(r2 = r2 || []).length ? `.${r2.join(".")}` : ""}`;
    let s2 = this.cache.get(i2);
    return s2 || (s2 = new n$1(e20, t2, r2), this.cache.set(i2, s2)), s2;
  }
}, o$1 = Object.defineProperty({StaticSymbol: i$1, StaticSymbolCache: s$1}, "__esModule", {value: true});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const a$1 = /-+([a-z0-9])/g;
var u$1 = function(e20) {
  return e20.replace(a$1, (...e21) => e21[1].toUpperCase());
};
var c$1 = function(e20, t2) {
  return p$1(e20, ":", t2);
};
var l$1 = function(e20, t2) {
  return p$1(e20, ".", t2);
};
function p$1(e20, t2, r2) {
  const n2 = e20.indexOf(t2);
  return n2 == -1 ? r2 : [e20.slice(0, n2).trim(), e20.slice(n2 + 1).trim()];
}
function h$1(e20, t2, r2) {
  return Array.isArray(e20) ? t2.visitArray(e20, r2) : typeof (n2 = e20) == "object" && n2 !== null && Object.getPrototypeOf(n2) === v$1 ? t2.visitStringMap(e20, r2) : e20 == null || typeof e20 == "string" || typeof e20 == "number" || typeof e20 == "boolean" ? t2.visitPrimitive(e20, r2) : t2.visitOther(e20, r2);
  var n2;
}
var D$1 = h$1;
var f$1 = function(e20) {
  return e20 != null;
};
var d$1 = function(e20) {
  return e20 === void 0 ? null : e20;
};
var g$1 = class {
  visitArray(e20, t2) {
    return e20.map((e21) => h$1(e21, this, t2));
  }
  visitStringMap(e20, t2) {
    const r2 = {};
    return Object.keys(e20).forEach((n2) => {
      r2[n2] = h$1(e20[n2], this, t2);
    }), r2;
  }
  visitPrimitive(e20, t2) {
    return e20;
  }
  visitOther(e20, t2) {
    return e20;
  }
}, m$1 = {assertSync: (e20) => {
  if (k$1(e20))
    throw new Error("Illegal state: value cannot be a promise");
  return e20;
}, then: (e20, t2) => k$1(e20) ? e20.then(t2) : t2(e20), all: (e20) => e20.some(k$1) ? Promise.all(e20) : e20};
var E$1 = function(e20) {
  throw new Error(`Internal Error: ${e20}`);
};
var C$1 = function(e20, t2) {
  const r2 = Error(e20);
  return r2[y$1] = true, t2 && (r2[b$1] = t2), r2;
};
const y$1 = "ngSyntaxError", b$1 = "ngParseErrors";
var S$1 = function(e20) {
  return e20[y$1];
};
var T$1 = function(e20) {
  return e20[b$1] || [];
};
var _$1 = function(e20) {
  return e20.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
};
const v$1 = Object.getPrototypeOf({});
var A$1 = function(e20) {
  let t2 = "";
  for (let r2 = 0; r2 < e20.length; r2++) {
    let n2 = e20.charCodeAt(r2);
    if (n2 >= 55296 && n2 <= 56319 && e20.length > r2 + 1) {
      const t3 = e20.charCodeAt(r2 + 1);
      t3 >= 56320 && t3 <= 57343 && (r2++, n2 = (n2 - 55296 << 10) + t3 - 56320 + 65536);
    }
    n2 <= 127 ? t2 += String.fromCharCode(n2) : n2 <= 2047 ? t2 += String.fromCharCode(n2 >> 6 & 31 | 192, 63 & n2 | 128) : n2 <= 65535 ? t2 += String.fromCharCode(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128) : n2 <= 2097151 && (t2 += String.fromCharCode(n2 >> 18 & 7 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128));
  }
  return t2;
};
var F$1 = function e17(t2) {
  if (typeof t2 == "string")
    return t2;
  if (t2 instanceof Array)
    return "[" + t2.map(e17).join(", ") + "]";
  if (t2 == null)
    return "" + t2;
  if (t2.overriddenName)
    return `${t2.overriddenName}`;
  if (t2.name)
    return `${t2.name}`;
  if (!t2.toString)
    return "object";
  const r2 = t2.toString();
  if (r2 == null)
    return "" + r2;
  const n2 = r2.indexOf("\n");
  return n2 === -1 ? r2 : r2.substring(0, n2);
};
var w$1 = function(e20) {
  return typeof e20 == "function" && e20.hasOwnProperty("__forward_ref__") ? e20() : e20;
};
function k$1(e20) {
  return !!e20 && typeof e20.then == "function";
}
var N$1 = k$1;
var O$1 = class {
  constructor(e20) {
    this.full = e20;
    const t2 = e20.split(".");
    this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
  }
};
const x$1 = typeof window != "undefined" && window, I$1 = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
var P$1 = e$1 !== void 0 && e$1 || x$1 || I$1, R$1 = Object.defineProperty({dashCaseToCamelCase: u$1, splitAtColon: c$1, splitAtPeriod: l$1, visitValue: D$1, isDefined: f$1, noUndefined: d$1, ValueTransformer: g$1, SyncAsync: m$1, error: E$1, syntaxError: C$1, isSyntaxError: S$1, getParseErrors: T$1, escapeRegExp: _$1, utf8Encode: A$1, stringify: F$1, resolveForwardRef: w$1, isPromise: N$1, Version: O$1, global: P$1}, "__esModule", {value: true}), L$1 = t$1(function(e20, t2) {
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  Object.defineProperty(t2, "__esModule", {value: true});
  const r2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function n2(e21) {
    return e21.replace(/\W/g, "_");
  }
  t2.sanitizeIdentifier = n2;
  let i2 = 0;
  function s2(e21) {
    if (!e21 || !e21.reference)
      return null;
    const t3 = e21.reference;
    if (t3 instanceof o$1.StaticSymbol)
      return t3.name;
    if (t3.__anonymousType)
      return t3.__anonymousType;
    let r3 = R$1.stringify(t3);
    return r3.indexOf("(") >= 0 ? (r3 = "anonymous_" + i2++, t3.__anonymousType = r3) : r3 = n2(r3), r3;
  }
  var a2;
  t2.identifierName = s2, t2.identifierModuleUrl = function(e21) {
    const t3 = e21.reference;
    return t3 instanceof o$1.StaticSymbol ? t3.filePath : `./${R$1.stringify(t3)}`;
  }, t2.viewClassName = function(e21, t3) {
    return `View_${s2({reference: e21})}_${t3}`;
  }, t2.rendererTypeName = function(e21) {
    return `RenderType_${s2({reference: e21})}`;
  }, t2.hostViewClassName = function(e21) {
    return `HostView_${s2({reference: e21})}`;
  }, t2.componentFactoryName = function(e21) {
    return `${s2({reference: e21})}NgFactory`;
  }, function(e21) {
    e21[e21.Pipe = 0] = "Pipe", e21[e21.Directive = 1] = "Directive", e21[e21.NgModule = 2] = "NgModule", e21[e21.Injectable = 3] = "Injectable";
  }(a2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e21) {
    return e21.value != null ? n2(e21.value) : s2(e21.identifier);
  }, t2.tokenReference = function(e21) {
    return e21.identifier != null ? e21.identifier.reference : e21.value;
  };
  t2.CompileStylesheetMetadata = class {
    constructor({moduleUrl: e21, styles: t3, styleUrls: r3} = {}) {
      this.moduleUrl = e21 || null, this.styles = c2(t3), this.styleUrls = c2(r3);
    }
  };
  t2.CompileTemplateMetadata = class {
    constructor({encapsulation: e21, template: t3, templateUrl: r3, htmlAst: n3, styles: i3, styleUrls: s3, externalStylesheets: o2, animations: a3, ngContentSelectors: u3, interpolation: p3, isInline: h2, preserveWhitespaces: D2}) {
      if (this.encapsulation = e21, this.template = t3, this.templateUrl = r3, this.htmlAst = n3, this.styles = c2(i3), this.styleUrls = c2(s3), this.externalStylesheets = c2(o2), this.animations = a3 ? l2(a3) : [], this.ngContentSelectors = u3 || [], p3 && p3.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = p3, this.isInline = h2, this.preserveWhitespaces = D2;
    }
    toSummary() {
      return {ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations};
    }
  };
  class u2 {
    static create({isHost: e21, type: t3, isComponent: n3, selector: i3, exportAs: s3, changeDetection: o2, inputs: a3, outputs: c3, host: l3, providers: p3, viewProviders: h2, queries: D2, guards: f2, viewQueries: d2, entryComponents: g2, template: m2, componentViewType: E2, rendererType: C2, componentFactory: y2}) {
      const b2 = {}, S2 = {}, T2 = {};
      l3 != null && Object.keys(l3).forEach((e22) => {
        const t4 = l3[e22], n4 = e22.match(r2);
        n4 === null ? T2[e22] = t4 : n4[1] != null ? S2[n4[1]] = t4 : n4[2] != null && (b2[n4[2]] = t4);
      });
      const _2 = {};
      a3 != null && a3.forEach((e22) => {
        const t4 = R$1.splitAtColon(e22, [e22, e22]);
        _2[t4[0]] = t4[1];
      });
      const v2 = {};
      return c3 != null && c3.forEach((e22) => {
        const t4 = R$1.splitAtColon(e22, [e22, e22]);
        v2[t4[0]] = t4[1];
      }), new u2({isHost: e21, type: t3, isComponent: !!n3, selector: i3, exportAs: s3, changeDetection: o2, inputs: _2, outputs: v2, hostListeners: b2, hostProperties: S2, hostAttributes: T2, providers: p3, viewProviders: h2, queries: D2, guards: f2, viewQueries: d2, entryComponents: g2, template: m2, componentViewType: E2, rendererType: C2, componentFactory: y2});
    }
    constructor({isHost: e21, type: t3, isComponent: r3, selector: n3, exportAs: i3, changeDetection: s3, inputs: o2, outputs: a3, hostListeners: u3, hostProperties: l3, hostAttributes: p3, providers: h2, viewProviders: D2, queries: f2, guards: d2, viewQueries: g2, entryComponents: m2, template: E2, componentViewType: C2, rendererType: y2, componentFactory: b2}) {
      this.isHost = !!e21, this.type = t3, this.isComponent = r3, this.selector = n3, this.exportAs = i3, this.changeDetection = s3, this.inputs = o2, this.outputs = a3, this.hostListeners = u3, this.hostProperties = l3, this.hostAttributes = p3, this.providers = c2(h2), this.viewProviders = c2(D2), this.queries = c2(f2), this.guards = d2, this.viewQueries = c2(g2), this.entryComponents = c2(m2), this.template = E2, this.componentViewType = C2, this.rendererType = y2, this.componentFactory = b2;
    }
    toSummary() {
      return {summaryKind: a2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory};
    }
  }
  t2.CompileDirectiveMetadata = u2;
  t2.CompilePipeMetadata = class {
    constructor({type: e21, name: t3, pure: r3}) {
      this.type = e21, this.name = t3, this.pure = !!r3;
    }
    toSummary() {
      return {summaryKind: a2.Pipe, type: this.type, name: this.name, pure: this.pure};
    }
  };
  t2.CompileShallowModuleMetadata = class {
  };
  t2.CompileNgModuleMetadata = class {
    constructor({type: e21, providers: t3, declaredDirectives: r3, exportedDirectives: n3, declaredPipes: i3, exportedPipes: s3, entryComponents: o2, bootstrapComponents: a3, importedModules: u3, exportedModules: l3, schemas: p3, transitiveModule: h2, id: D2}) {
      this.type = e21 || null, this.declaredDirectives = c2(r3), this.exportedDirectives = c2(n3), this.declaredPipes = c2(i3), this.exportedPipes = c2(s3), this.providers = c2(t3), this.entryComponents = c2(o2), this.bootstrapComponents = c2(a3), this.importedModules = c2(u3), this.exportedModules = c2(l3), this.schemas = c2(p3), this.id = D2 || null, this.transitiveModule = h2 || null;
    }
    toSummary() {
      const e21 = this.transitiveModule;
      return {summaryKind: a2.NgModule, type: this.type, entryComponents: e21.entryComponents, providers: e21.providers, modules: e21.modules, exportedDirectives: e21.exportedDirectives, exportedPipes: e21.exportedPipes};
    }
  };
  function c2(e21) {
    return e21 || [];
  }
  t2.TransitiveCompileNgModuleMetadata = class {
    constructor() {
      this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(e21, t3) {
      this.providers.push({provider: e21, module: t3});
    }
    addDirective(e21) {
      this.directivesSet.has(e21.reference) || (this.directivesSet.add(e21.reference), this.directives.push(e21));
    }
    addExportedDirective(e21) {
      this.exportedDirectivesSet.has(e21.reference) || (this.exportedDirectivesSet.add(e21.reference), this.exportedDirectives.push(e21));
    }
    addPipe(e21) {
      this.pipesSet.has(e21.reference) || (this.pipesSet.add(e21.reference), this.pipes.push(e21));
    }
    addExportedPipe(e21) {
      this.exportedPipesSet.has(e21.reference) || (this.exportedPipesSet.add(e21.reference), this.exportedPipes.push(e21));
    }
    addModule(e21) {
      this.modulesSet.has(e21.reference) || (this.modulesSet.add(e21.reference), this.modules.push(e21));
    }
    addEntryComponent(e21) {
      this.entryComponentsSet.has(e21.componentType) || (this.entryComponentsSet.add(e21.componentType), this.entryComponents.push(e21));
    }
  };
  function l2(e21) {
    return e21.reduce((e22, t3) => {
      const r3 = Array.isArray(t3) ? l2(t3) : t3;
      return e22.concat(r3);
    }, []);
  }
  function p2(e21) {
    return e21.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  t2.ProviderMeta = class {
    constructor(e21, {useClass: t3, useValue: r3, useExisting: n3, useFactory: i3, deps: s3, multi: o2}) {
      this.token = e21, this.useClass = t3 || null, this.useValue = r3, this.useExisting = n3, this.useFactory = i3 || null, this.dependencies = s3 || null, this.multi = !!o2;
    }
  }, t2.flatten = l2, t2.templateSourceUrl = function(e21, t3, r3) {
    let n3;
    return n3 = r3.isInline ? t3.type.reference instanceof o$1.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${s2(e21)}/${s2(t3.type)}.html` : r3.templateUrl, t3.type.reference instanceof o$1.StaticSymbol ? n3 : p2(n3);
  }, t2.sharedStylesheetJitUrl = function(e21, t3) {
    const r3 = e21.moduleUrl.split(/\/\\/g);
    return p2(`css/${t3}${r3[r3.length - 1]}.ngstyle.js`);
  }, t2.ngModuleJitUrl = function(e21) {
    return p2(`${s2(e21.type)}/module.ngfactory.js`);
  }, t2.templateJitUrl = function(e21, t3) {
    return p2(`${s2(e21)}/${s2(t3.type)}.ngfactory.js`);
  };
}), B$1 = t$1(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", {value: true});
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  class n2 {
    constructor(e21, t3, r2, n3) {
      this.file = e21, this.offset = t3, this.line = r2, this.col = n3;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(e21) {
      const t3 = this.file.content, i3 = t3.length;
      let s3 = this.offset, o3 = this.line, a2 = this.col;
      for (; s3 > 0 && e21 < 0; ) {
        s3--, e21++;
        if (t3.charCodeAt(s3) == r$1.$LF) {
          o3--;
          const e22 = t3.substr(0, s3 - 1).lastIndexOf(String.fromCharCode(r$1.$LF));
          a2 = e22 > 0 ? s3 - e22 : s3;
        } else
          a2--;
      }
      for (; s3 < i3 && e21 > 0; ) {
        const n3 = t3.charCodeAt(s3);
        s3++, e21--, n3 == r$1.$LF ? (o3++, a2 = 0) : a2++;
      }
      return new n2(this.file, s3, o3, a2);
    }
    getContext(e21, t3) {
      const r2 = this.file.content;
      let n3 = this.offset;
      if (n3 != null) {
        n3 > r2.length - 1 && (n3 = r2.length - 1);
        let i3 = n3, s3 = 0, o3 = 0;
        for (; s3 < e21 && n3 > 0 && (n3--, s3++, r2[n3] != "\n" || ++o3 != t3); )
          ;
        for (s3 = 0, o3 = 0; s3 < e21 && i3 < r2.length - 1 && (i3++, s3++, r2[i3] != "\n" || ++o3 != t3); )
          ;
        return {before: r2.substring(n3, this.offset), after: r2.substring(this.offset, i3 + 1)};
      }
      return null;
    }
  }
  t2.ParseLocation = n2;
  class i2 {
    constructor(e21, t3) {
      this.content = e21, this.url = t3;
    }
  }
  t2.ParseSourceFile = i2;
  class s2 {
    constructor(e21, t3, r2 = null) {
      this.start = e21, this.end = t3, this.details = r2;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  }
  var o2;
  t2.ParseSourceSpan = s2, t2.EMPTY_PARSE_LOCATION = new n2(new i2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new s2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e21) {
    e21[e21.WARNING = 0] = "WARNING", e21[e21.ERROR = 1] = "ERROR";
  }(o2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
  t2.ParseError = class {
    constructor(e21, t3, r2 = o2.ERROR) {
      this.span = e21, this.msg = t3, this.level = r2;
    }
    contextualMessage() {
      const e21 = this.span.start.getContext(100, 3);
      return e21 ? `${this.msg} ("${e21.before}[${o2[this.level]} ->]${e21.after}")` : this.msg;
    }
    toString() {
      const e21 = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${e21}`;
    }
  }, t2.typeSourceSpan = function(e21, t3) {
    const r2 = L$1.identifierModuleUrl(t3), o3 = r2 != null ? `in ${e21} ${L$1.identifierName(t3)} in ${r2}` : `in ${e21} ${L$1.identifierName(t3)}`, a2 = new i2("", o3);
    return new s2(new n2(a2, -1, -1, -1), new n2(a2, -1, -1, -1));
  }, t2.r3JitTypeSourceSpan = function(e21, t3, r2) {
    const o3 = new i2("", `in ${e21} ${t3} in ${r2}`);
    return new s2(new n2(o3, -1, -1, -1), new n2(o3, -1, -1, -1));
  };
});
const $$1 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
var q$1 = function(e20) {
  const t2 = e20.match($$1);
  if (!t2)
    return {content: e20};
  const {startDelimiter: r2, language: n2, value: i2 = "", endDelimiter: s2} = t2.groups;
  let o2 = n2.trim() || "yaml";
  if (r2 === "+++" && (o2 = "toml"), o2 !== "yaml" && r2 !== s2)
    return {content: e20};
  const [a2] = t2;
  return {frontMatter: {type: "front-matter", lang: o2, value: i2, startDelimiter: r2, endDelimiter: s2, raw: a2.replace(/\n$/, "")}, content: a2.replace(/[^\n]/g, " ") + e20.slice(a2.length)};
};
var M$1 = (e20) => e20[e20.length - 1];
var j$1 = function(e20, t2) {
  const r2 = new SyntaxError(e20 + " (" + t2.start.line + ":" + t2.start.column + ")");
  return r2.loc = t2, r2;
}, U$1 = (e20) => typeof e20 == "string" ? e20.replace((({onlyFirst: e21 = false} = {}) => {
  const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(t2, e21 ? void 0 : "g");
})(), "") : e20;
const G$1 = (e20) => !Number.isNaN(e20) && (e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141));
var V$1 = G$1, H$1 = G$1;
V$1.default = H$1;
const X$1 = (e20) => {
  if (typeof e20 != "string" || e20.length === 0)
    return 0;
  if ((e20 = U$1(e20)).length === 0)
    return 0;
  e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
  let t2 = 0;
  for (let r2 = 0; r2 < e20.length; r2++) {
    const n2 = e20.codePointAt(r2);
    n2 <= 31 || n2 >= 127 && n2 <= 159 || (n2 >= 768 && n2 <= 879 || (n2 > 65535 && r2++, t2 += V$1(n2) ? 2 : 1));
  }
  return t2;
};
var z$1 = X$1, W$1 = X$1;
z$1.default = W$1;
var Y$1 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
function Q$1(e20, t2) {
  if (e20 == null)
    return {};
  var r2, n2, i2 = function(e21, t3) {
    if (e21 == null)
      return {};
    var r3, n3, i3 = {}, s3 = Object.keys(e21);
    for (n3 = 0; n3 < s3.length; n3++)
      r3 = s3[n3], t3.indexOf(r3) >= 0 || (i3[r3] = e21[r3]);
    return i3;
  }(e20, t2);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e20);
    for (n2 = 0; n2 < s2.length; n2++)
      r2 = s2[n2], t2.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, r2) && (i2[r2] = e20[r2]);
  }
  return i2;
}
var J$1, K$1, Z$1 = function(e20) {
  return e20 && e20.Math == Math && e20;
}, ee$1 = Z$1(typeof globalThis == "object" && globalThis) || Z$1(typeof window == "object" && window) || Z$1(typeof self == "object" && self) || Z$1(typeof e$1 == "object" && e$1) || function() {
  return this;
}() || Function("return this")(), te$1 = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, re$1 = !te$1(function() {
  return Object.defineProperty({}, 1, {get: function() {
    return 7;
  }})[1] != 7;
}), ne$1 = {}.propertyIsEnumerable, ie$1 = Object.getOwnPropertyDescriptor, se$1 = {f: ie$1 && !ne$1.call({1: 2}, 1) ? function(e20) {
  var t2 = ie$1(this, e20);
  return !!t2 && t2.enumerable;
} : ne$1}, oe$1 = function(e20, t2) {
  return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
}, ae$1 = {}.toString, ue$1 = function(e20) {
  return ae$1.call(e20).slice(8, -1);
}, ce$1 = "".split, le$1 = te$1(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return ue$1(e20) == "String" ? ce$1.call(e20, "") : Object(e20);
} : Object, pe$1 = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, he$1 = function(e20) {
  return le$1(pe$1(e20));
}, De$1 = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, fe$1 = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, de$1 = function(e20, t2) {
  return arguments.length < 2 ? fe$1(ee$1[e20]) : ee$1[e20] && ee$1[e20][t2];
}, ge$1 = de$1("navigator", "userAgent") || "", me$1 = ee$1.process, Ee$1 = ee$1.Deno, Ce$1 = me$1 && me$1.versions || Ee$1 && Ee$1.version, ye$1 = Ce$1 && Ce$1.v8;
ye$1 ? K$1 = (J$1 = ye$1.split("."))[0] < 4 ? 1 : J$1[0] + J$1[1] : ge$1 && (!(J$1 = ge$1.match(/Edge\/(\d+)/)) || J$1[1] >= 74) && (J$1 = ge$1.match(/Chrome\/(\d+)/)) && (K$1 = J$1[1]);
var be$1 = K$1 && +K$1, Se$1 = !!Object.getOwnPropertySymbols && !te$1(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && be$1 && be$1 < 41;
}), Te$1 = Se$1 && !Symbol.sham && typeof Symbol.iterator == "symbol", _e$1 = Te$1 ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = de$1("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, ve$1 = function(e20, t2) {
  try {
    Object.defineProperty(ee$1, e20, {value: t2, configurable: true, writable: true});
  } catch (r2) {
    ee$1[e20] = t2;
  }
  return t2;
}, Ae$1 = ee$1["__core-js_shared__"] || ve$1("__core-js_shared__", {}), Fe$1 = t$1(function(e20) {
  (e20.exports = function(e21, t2) {
    return Ae$1[e21] || (Ae$1[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
}), we$1 = function(e20) {
  return Object(pe$1(e20));
}, ke$1 = {}.hasOwnProperty, Ne$1 = Object.hasOwn || function(e20, t2) {
  return ke$1.call(we$1(e20), t2);
}, Oe$1 = 0, xe$1 = Math.random(), Ie$1 = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++Oe$1 + xe$1).toString(36);
}, Pe$1 = Fe$1("wks"), Re$1 = ee$1.Symbol, Le$1 = Te$1 ? Re$1 : Re$1 && Re$1.withoutSetter || Ie$1, Be$1 = function(e20) {
  return Ne$1(Pe$1, e20) && (Se$1 || typeof Pe$1[e20] == "string") || (Se$1 && Ne$1(Re$1, e20) ? Pe$1[e20] = Re$1[e20] : Pe$1[e20] = Le$1("Symbol." + e20)), Pe$1[e20];
}, $e$1 = Be$1("toPrimitive"), qe$1 = function(e20, t2) {
  if (!De$1(e20) || _e$1(e20))
    return e20;
  var r2, n2 = e20[$e$1];
  if (n2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e20, t2), !De$1(r2) || _e$1(r2))
      return r2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var r3, n3;
    if (t3 === "string" && typeof (r3 = e21.toString) == "function" && !De$1(n3 = r3.call(e21)))
      return n3;
    if (typeof (r3 = e21.valueOf) == "function" && !De$1(n3 = r3.call(e21)))
      return n3;
    if (t3 !== "string" && typeof (r3 = e21.toString) == "function" && !De$1(n3 = r3.call(e21)))
      return n3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, Me$1 = function(e20) {
  var t2 = qe$1(e20, "string");
  return _e$1(t2) ? t2 : String(t2);
}, je$1 = ee$1.document, Ue$1 = De$1(je$1) && De$1(je$1.createElement), Ge$1 = !re$1 && !te$1(function() {
  return Object.defineProperty((e20 = "div", Ue$1 ? je$1.createElement(e20) : {}), "a", {get: function() {
    return 7;
  }}).a != 7;
  var e20;
}), Ve$1 = Object.getOwnPropertyDescriptor, He$1 = {f: re$1 ? Ve$1 : function(e20, t2) {
  if (e20 = he$1(e20), t2 = Me$1(t2), Ge$1)
    try {
      return Ve$1(e20, t2);
    } catch (e21) {
    }
  if (Ne$1(e20, t2))
    return oe$1(!se$1.f.call(e20, t2), e20[t2]);
}}, Xe$1 = function(e20) {
  if (!De$1(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, ze$1 = Object.defineProperty, We$1 = {f: re$1 ? ze$1 : function(e20, t2, r2) {
  if (Xe$1(e20), t2 = Me$1(t2), Xe$1(r2), Ge$1)
    try {
      return ze$1(e20, t2, r2);
    } catch (e21) {
    }
  if ("get" in r2 || "set" in r2)
    throw TypeError("Accessors not supported");
  return "value" in r2 && (e20[t2] = r2.value), e20;
}}, Ye$1 = re$1 ? function(e20, t2, r2) {
  return We$1.f(e20, t2, oe$1(1, r2));
} : function(e20, t2, r2) {
  return e20[t2] = r2, e20;
}, Qe$1 = Function.toString;
typeof Ae$1.inspectSource != "function" && (Ae$1.inspectSource = function(e20) {
  return Qe$1.call(e20);
});
var Je$1, Ke$1, Ze$1, et$1, tt$1 = Ae$1.inspectSource, rt$1 = ee$1.WeakMap, nt$1 = typeof rt$1 == "function" && /native code/.test(tt$1(rt$1)), it$1 = Fe$1("keys"), st$1 = {}, ot$1 = ee$1.WeakMap;
if (nt$1 || Ae$1.state) {
  var at$1 = Ae$1.state || (Ae$1.state = new ot$1()), ut$1 = at$1.get, ct$1 = at$1.has, lt$1 = at$1.set;
  Je$1 = function(e20, t2) {
    if (ct$1.call(at$1, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, lt$1.call(at$1, e20, t2), t2;
  }, Ke$1 = function(e20) {
    return ut$1.call(at$1, e20) || {};
  }, Ze$1 = function(e20) {
    return ct$1.call(at$1, e20);
  };
} else {
  var pt$1 = it$1[et$1 = "state"] || (it$1[et$1] = Ie$1(et$1));
  st$1[pt$1] = true, Je$1 = function(e20, t2) {
    if (Ne$1(e20, pt$1))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, Ye$1(e20, pt$1, t2), t2;
  }, Ke$1 = function(e20) {
    return Ne$1(e20, pt$1) ? e20[pt$1] : {};
  }, Ze$1 = function(e20) {
    return Ne$1(e20, pt$1);
  };
}
var ht$1 = {set: Je$1, get: Ke$1, has: Ze$1, enforce: function(e20) {
  return Ze$1(e20) ? Ke$1(e20) : Je$1(e20, {});
}, getterFor: function(e20) {
  return function(t2) {
    var r2;
    if (!De$1(t2) || (r2 = Ke$1(t2)).type !== e20)
      throw TypeError("Incompatible receiver, " + e20 + " required");
    return r2;
  };
}}, Dt$1 = t$1(function(e20) {
  var t2 = ht$1.get, r2 = ht$1.enforce, n2 = String(String).split("String");
  (e20.exports = function(e21, t3, i2, s2) {
    var o2, a2 = !!s2 && !!s2.unsafe, u2 = !!s2 && !!s2.enumerable, c2 = !!s2 && !!s2.noTargetGet;
    typeof i2 == "function" && (typeof t3 != "string" || Ne$1(i2, "name") || Ye$1(i2, "name", t3), (o2 = r2(i2)).source || (o2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e21 !== ee$1 ? (a2 ? !c2 && e21[t3] && (u2 = true) : delete e21[t3], u2 ? e21[t3] = i2 : Ye$1(e21, t3, i2)) : u2 ? e21[t3] = i2 : ve$1(t3, i2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || tt$1(this);
  });
}), ft$1 = Math.ceil, dt$1 = Math.floor, gt$1 = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? dt$1 : ft$1)(e20);
}, mt$1 = Math.min, Et$1 = function(e20) {
  return e20 > 0 ? mt$1(gt$1(e20), 9007199254740991) : 0;
}, Ct$1 = Math.max, yt$1 = Math.min, bt$1 = function(e20) {
  return function(t2, r2, n2) {
    var i2, s2 = he$1(t2), o2 = Et$1(s2.length), a2 = function(e21, t3) {
      var r3 = gt$1(e21);
      return r3 < 0 ? Ct$1(r3 + t3, 0) : yt$1(r3, t3);
    }(n2, o2);
    if (e20 && r2 != r2) {
      for (; o2 > a2; )
        if ((i2 = s2[a2++]) != i2)
          return true;
    } else
      for (; o2 > a2; a2++)
        if ((e20 || a2 in s2) && s2[a2] === r2)
          return e20 || a2 || 0;
    return !e20 && -1;
  };
}, St = {includes: bt$1(true), indexOf: bt$1(false)}.indexOf, Tt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), _t = {f: Object.getOwnPropertyNames || function(e20) {
  return function(e21, t2) {
    var r2, n2 = he$1(e21), i2 = 0, s2 = [];
    for (r2 in n2)
      !Ne$1(st$1, r2) && Ne$1(n2, r2) && s2.push(r2);
    for (; t2.length > i2; )
      Ne$1(n2, r2 = t2[i2++]) && (~St(s2, r2) || s2.push(r2));
    return s2;
  }(e20, Tt);
}}, vt$1 = {f: Object.getOwnPropertySymbols}, At$1 = de$1("Reflect", "ownKeys") || function(e20) {
  var t2 = _t.f(Xe$1(e20)), r2 = vt$1.f;
  return r2 ? t2.concat(r2(e20)) : t2;
}, Ft$1 = function(e20, t2) {
  for (var r2 = At$1(t2), n2 = We$1.f, i2 = He$1.f, s2 = 0; s2 < r2.length; s2++) {
    var o2 = r2[s2];
    Ne$1(e20, o2) || n2(e20, o2, i2(t2, o2));
  }
}, wt$1 = /#|\.prototype\./, kt$1 = function(e20, t2) {
  var r2 = Ot$1[Nt(e20)];
  return r2 == It || r2 != xt$1 && (typeof t2 == "function" ? te$1(t2) : !!t2);
}, Nt = kt$1.normalize = function(e20) {
  return String(e20).replace(wt$1, ".").toLowerCase();
}, Ot$1 = kt$1.data = {}, xt$1 = kt$1.NATIVE = "N", It = kt$1.POLYFILL = "P", Pt = kt$1, Rt = He$1.f, Lt = function(e20, t2) {
  var r2, n2, i2, s2, o2, a2 = e20.target, u2 = e20.global, c2 = e20.stat;
  if (r2 = u2 ? ee$1 : c2 ? ee$1[a2] || ve$1(a2, {}) : (ee$1[a2] || {}).prototype)
    for (n2 in t2) {
      if (s2 = t2[n2], i2 = e20.noTargetGet ? (o2 = Rt(r2, n2)) && o2.value : r2[n2], !Pt(u2 ? n2 : a2 + (c2 ? "." : "#") + n2, e20.forced) && i2 !== void 0) {
        if (typeof s2 == typeof i2)
          continue;
        Ft$1(s2, i2);
      }
      (e20.sham || i2 && i2.sham) && Ye$1(s2, "sham", true), Dt$1(r2, n2, s2, e20);
    }
}, Bt = Array.isArray || function(e20) {
  return ue$1(e20) == "Array";
}, $t = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, qt = function(e20, t2, r2) {
  if ($t(e20), t2 === void 0)
    return e20;
  switch (r2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(r3) {
        return e20.call(t2, r3);
      };
    case 2:
      return function(r3, n2) {
        return e20.call(t2, r3, n2);
      };
    case 3:
      return function(r3, n2, i2) {
        return e20.call(t2, r3, n2, i2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, Mt = function(e20, t2, r2, n2, i2, s2, o2, a2) {
  for (var u2, c2 = i2, l2 = 0, p2 = !!o2 && qt(o2, a2, 3); l2 < n2; ) {
    if (l2 in r2) {
      if (u2 = p2 ? p2(r2[l2], l2, t2) : r2[l2], s2 > 0 && Bt(u2))
        c2 = Mt(e20, t2, u2, Et$1(u2.length), c2, s2 - 1) - 1;
      else {
        if (c2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[c2] = u2;
      }
      c2++;
    }
    l2++;
  }
  return c2;
}, jt = Mt, Ut = Be$1("species"), Gt = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return Bt(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !Bt(t3.prototype) ? De$1(t3) && (t3 = t3[Ut]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
Lt({target: "Array", proto: true}, {flatMap: function(e20) {
  var t2, r2 = we$1(this), n2 = Et$1(r2.length);
  return $t(e20), (t2 = Gt(r2, 0)).length = jt(t2, r2, r2, n2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
}});
var Vt, Ht, Xt = function(e20) {
  if (_e$1(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, zt = Math.floor, Wt = function(e20, t2) {
  var r2 = e20.length, n2 = zt(r2 / 2);
  return r2 < 8 ? Yt(e20, t2) : Qt(Wt(e20.slice(0, n2), t2), Wt(e20.slice(n2), t2), t2);
}, Yt = function(e20, t2) {
  for (var r2, n2, i2 = e20.length, s2 = 1; s2 < i2; ) {
    for (n2 = s2, r2 = e20[s2]; n2 && t2(e20[n2 - 1], r2) > 0; )
      e20[n2] = e20[--n2];
    n2 !== s2++ && (e20[n2] = r2);
  }
  return e20;
}, Qt = function(e20, t2, r2) {
  for (var n2 = e20.length, i2 = t2.length, s2 = 0, o2 = 0, a2 = []; s2 < n2 || o2 < i2; )
    s2 < n2 && o2 < i2 ? a2.push(r2(e20[s2], t2[o2]) <= 0 ? e20[s2++] : t2[o2++]) : a2.push(s2 < n2 ? e20[s2++] : t2[o2++]);
  return a2;
}, Jt = Wt, Kt = ge$1.match(/firefox\/(\d+)/i), Zt = !!Kt && +Kt[1], er = /MSIE|Trident/.test(ge$1), tr = ge$1.match(/AppleWebKit\/(\d+)\./), rr = !!tr && +tr[1], nr = [], ir = nr.sort, sr = te$1(function() {
  nr.sort(void 0);
}), or = te$1(function() {
  nr.sort(null);
}), ar = !!(Ht = []["sort"]) && te$1(function() {
  Ht.call(null, Vt || function() {
    throw 1;
  }, 1);
}), ur = !te$1(function() {
  if (be$1)
    return be$1 < 70;
  if (!(Zt && Zt > 3)) {
    if (er)
      return true;
    if (rr)
      return rr < 603;
    var e20, t2, r2, n2, i2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          r2 = 3;
          break;
        case 68:
        case 71:
          r2 = 4;
          break;
        default:
          r2 = 2;
      }
      for (n2 = 0; n2 < 47; n2++)
        nr.push({k: t2 + n2, v: r2});
    }
    for (nr.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), n2 = 0; n2 < nr.length; n2++)
      t2 = nr[n2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
    return i2 !== "DGBEFHACIJK";
  }
});
Lt({target: "Array", proto: true, forced: sr || !or || !ar || !ur}, {sort: function(e20) {
  e20 !== void 0 && $t(e20);
  var t2 = we$1(this);
  if (ur)
    return e20 === void 0 ? ir.call(t2) : ir.call(t2, e20);
  var r2, n2, i2 = [], s2 = Et$1(t2.length);
  for (n2 = 0; n2 < s2; n2++)
    n2 in t2 && i2.push(t2[n2]);
  for (r2 = (i2 = Jt(i2, function(e21) {
    return function(t3, r3) {
      return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, r3) || 0 : Xt(t3) > Xt(r3) ? 1 : -1;
    };
  }(e20))).length, n2 = 0; n2 < r2; )
    t2[n2] = i2[n2++];
  for (; n2 < s2; )
    delete t2[n2++];
  return t2;
}});
var cr = {}, lr = Be$1("iterator"), pr = Array.prototype, hr = {};
hr[Be$1("toStringTag")] = "z";
var Dr = String(hr) === "[object z]", fr = Be$1("toStringTag"), dr = ue$1(function() {
  return arguments;
}()) == "Arguments", gr = Dr ? ue$1 : function(e20) {
  var t2, r2, n2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (r2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), fr)) == "string" ? r2 : dr ? ue$1(t2) : (n2 = ue$1(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
}, mr = Be$1("iterator"), Er = function(e20) {
  if (e20 != null)
    return e20[mr] || e20["@@iterator"] || cr[gr(e20)];
}, Cr = function(e20, t2, r2) {
  var n2, i2;
  Xe$1(e20);
  try {
    if ((n2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw r2;
      return r2;
    }
    n2 = n2.call(e20);
  } catch (e21) {
    i2 = true, n2 = e21;
  }
  if (t2 === "throw")
    throw r2;
  if (i2)
    throw n2;
  return Xe$1(n2), r2;
}, yr = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, br = function(e20, t2, r2) {
  var n2, i2, s2, o2, a2, u2, c2, l2, p2 = r2 && r2.that, h2 = !(!r2 || !r2.AS_ENTRIES), D2 = !(!r2 || !r2.IS_ITERATOR), f2 = !(!r2 || !r2.INTERRUPTED), d2 = qt(t2, p2, 1 + h2 + f2), g2 = function(e21) {
    return n2 && Cr(n2, "normal", e21), new yr(true, e21);
  }, m2 = function(e21) {
    return h2 ? (Xe$1(e21), f2 ? d2(e21[0], e21[1], g2) : d2(e21[0], e21[1])) : f2 ? d2(e21, g2) : d2(e21);
  };
  if (D2)
    n2 = e20;
  else {
    if (typeof (i2 = Er(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((l2 = i2) !== void 0 && (cr.Array === l2 || pr[lr] === l2)) {
      for (s2 = 0, o2 = Et$1(e20.length); o2 > s2; s2++)
        if ((a2 = m2(e20[s2])) && a2 instanceof yr)
          return a2;
      return new yr(false);
    }
    n2 = function(e21, t3) {
      var r3 = arguments.length < 2 ? Er(e21) : t3;
      if (typeof r3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return Xe$1(r3.call(e21));
    }(e20, i2);
  }
  for (u2 = n2.next; !(c2 = u2.call(n2)).done; ) {
    try {
      a2 = m2(c2.value);
    } catch (e21) {
      Cr(n2, "throw", e21);
    }
    if (typeof a2 == "object" && a2 && a2 instanceof yr)
      return a2;
  }
  return new yr(false);
};
Lt({target: "Object", stat: true}, {fromEntries: function(e20) {
  var t2 = {};
  return br(e20, function(e21, r2) {
    !function(e22, t3, r3) {
      var n2 = Me$1(t3);
      n2 in e22 ? We$1.f(e22, n2, oe$1(0, r3)) : e22[n2] = r3;
    }(t2, e21, r2);
  }, {AS_ENTRIES: true}), t2;
}});
var Sr = Sr !== void 0 ? Sr : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
function Tr() {
  throw new Error("setTimeout has not been defined");
}
function _r() {
  throw new Error("clearTimeout has not been defined");
}
var vr = Tr, Ar = _r;
function Fr(e20) {
  if (vr === setTimeout)
    return setTimeout(e20, 0);
  if ((vr === Tr || !vr) && setTimeout)
    return vr = setTimeout, setTimeout(e20, 0);
  try {
    return vr(e20, 0);
  } catch (t2) {
    try {
      return vr.call(null, e20, 0);
    } catch (t3) {
      return vr.call(this, e20, 0);
    }
  }
}
typeof Sr.setTimeout == "function" && (vr = setTimeout), typeof Sr.clearTimeout == "function" && (Ar = clearTimeout);
var wr, kr = [], Nr = false, Or = -1;
function xr() {
  Nr && wr && (Nr = false, wr.length ? kr = wr.concat(kr) : Or = -1, kr.length && Ir());
}
function Ir() {
  if (!Nr) {
    var e20 = Fr(xr);
    Nr = true;
    for (var t2 = kr.length; t2; ) {
      for (wr = kr, kr = []; ++Or < t2; )
        wr && wr[Or].run();
      Or = -1, t2 = kr.length;
    }
    wr = null, Nr = false, function(e21) {
      if (Ar === clearTimeout)
        return clearTimeout(e21);
      if ((Ar === _r || !Ar) && clearTimeout)
        return Ar = clearTimeout, clearTimeout(e21);
      try {
        Ar(e21);
      } catch (t3) {
        try {
          return Ar.call(null, e21);
        } catch (t4) {
          return Ar.call(this, e21);
        }
      }
    }(e20);
  }
}
function Pr(e20, t2) {
  this.fun = e20, this.array = t2;
}
Pr.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function Rr() {
}
var Lr = Rr, Br = Rr, $r = Rr, qr = Rr, Mr = Rr, jr = Rr, Ur = Rr;
var Gr = Sr.performance || {}, Vr = Gr.now || Gr.mozNow || Gr.msNow || Gr.oNow || Gr.webkitNow || function() {
  return new Date().getTime();
};
var Hr = new Date();
var Xr = {nextTick: function(e20) {
  var t2 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r2 = 1; r2 < arguments.length; r2++)
      t2[r2 - 1] = arguments[r2];
  kr.push(new Pr(e20, t2)), kr.length !== 1 || Nr || Fr(Ir);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Lr, addListener: Br, once: $r, off: qr, removeListener: Mr, removeAllListeners: jr, emit: Ur, binding: function(e20) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e20) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e20) {
  var t2 = 1e-3 * Vr.call(Gr), r2 = Math.floor(t2), n2 = Math.floor(t2 % 1 * 1e9);
  return e20 && (r2 -= e20[0], (n2 -= e20[1]) < 0 && (r2--, n2 += 1e9)), [r2, n2];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (new Date() - Hr) / 1e3;
}};
var zr = typeof Xr == "object" && Xr.env && Xr.env.NODE_DEBUG && /\bsemver\b/i.test(Xr.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
};
var Wr = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, Yr = t$1(function(e20, t2) {
  const {MAX_SAFE_COMPONENT_LENGTH: r2} = Wr, n2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], s2 = t2.t = {};
  let o2 = 0;
  const a2 = (e21, t3, r3) => {
    const a3 = o2++;
    zr(a3, t3), s2[e21] = a3, i2[a3] = t3, n2[a3] = new RegExp(t3, r3 ? "g" : void 0);
  };
  a2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a2("MAINVERSION", `(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})`), a2("MAINVERSIONLOOSE", `(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})`), a2("PRERELEASEIDENTIFIER", `(?:${i2[s2.NUMERICIDENTIFIER]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[s2.NUMERICIDENTIFIERLOOSE]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASE", `(?:-(${i2[s2.PRERELEASEIDENTIFIER]}(?:\\.${i2[s2.PRERELEASEIDENTIFIER]})*))`), a2("PRERELEASELOOSE", `(?:-?(${i2[s2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[s2.PRERELEASEIDENTIFIERLOOSE]})*))`), a2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a2("BUILD", `(?:\\+(${i2[s2.BUILDIDENTIFIER]}(?:\\.${i2[s2.BUILDIDENTIFIER]})*))`), a2("FULLPLAIN", `v?${i2[s2.MAINVERSION]}${i2[s2.PRERELEASE]}?${i2[s2.BUILD]}?`), a2("FULL", `^${i2[s2.FULLPLAIN]}$`), a2("LOOSEPLAIN", `[v=\\s]*${i2[s2.MAINVERSIONLOOSE]}${i2[s2.PRERELEASELOOSE]}?${i2[s2.BUILD]}?`), a2("LOOSE", `^${i2[s2.LOOSEPLAIN]}$`), a2("GTLT", "((?:<|>)?=?)"), a2("XRANGEIDENTIFIERLOOSE", `${i2[s2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a2("XRANGEIDENTIFIER", `${i2[s2.NUMERICIDENTIFIER]}|x|X|\\*`), a2("XRANGEPLAIN", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:${i2[s2.PRERELEASE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:${i2[s2.PRERELEASELOOSE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAIN]}$`), a2("XRANGELOOSE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COERCE", `(^|[^\\d])(\\d{1,${r2}})(?:\\.(\\d{1,${r2}}))?(?:\\.(\\d{1,${r2}}))?(?:$|[^\\d])`), a2("COERCERTL", i2[s2.COERCE], true), a2("LONETILDE", "(?:~>?)"), a2("TILDETRIM", `(\\s*)${i2[s2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", a2("TILDE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAIN]}$`), a2("TILDELOOSE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("LONECARET", "(?:\\^)"), a2("CARETTRIM", `(\\s*)${i2[s2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", a2("CARET", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAIN]}$`), a2("CARETLOOSE", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COMPARATORLOOSE", `^${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]})$|^$`), a2("COMPARATOR", `^${i2[s2.GTLT]}\\s*(${i2[s2.FULLPLAIN]})$|^$`), a2("COMPARATORTRIM", `(\\s*)${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]}|${i2[s2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", a2("HYPHENRANGE", `^\\s*(${i2[s2.XRANGEPLAIN]})\\s+-\\s+(${i2[s2.XRANGEPLAIN]})\\s*$`), a2("HYPHENRANGELOOSE", `^\\s*(${i2[s2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[s2.XRANGEPLAINLOOSE]})\\s*$`), a2("STAR", "(<|>)?=?\\s*\\*"), a2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const Qr = ["includePrerelease", "loose", "rtl"];
var Jr = (e20) => e20 ? typeof e20 != "object" ? {loose: true} : Qr.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
const Kr = /^[0-9]+$/, Zr = (e20, t2) => {
  const r2 = Kr.test(e20), n2 = Kr.test(t2);
  return r2 && n2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : r2 && !n2 ? -1 : n2 && !r2 ? 1 : e20 < t2 ? -1 : 1;
};
var en = {compareIdentifiers: Zr, rcompareIdentifiers: (e20, t2) => Zr(t2, e20)};
const {MAX_LENGTH: tn, MAX_SAFE_INTEGER: rn} = Wr, {re: nn, t: sn} = Yr, {compareIdentifiers: on} = en;
class an {
  constructor(e20, t2) {
    if (t2 = Jr(t2), e20 instanceof an) {
      if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
        return e20;
      e20 = e20.version;
    } else if (typeof e20 != "string")
      throw new TypeError(`Invalid Version: ${e20}`);
    if (e20.length > tn)
      throw new TypeError(`version is longer than ${tn} characters`);
    zr("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
    const r2 = e20.trim().match(t2.loose ? nn[sn.LOOSE] : nn[sn.FULL]);
    if (!r2)
      throw new TypeError(`Invalid Version: ${e20}`);
    if (this.raw = e20, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > rn || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > rn || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > rn || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r2[4] ? this.prerelease = r2[4].split(".").map((e21) => {
      if (/^[0-9]+$/.test(e21)) {
        const t3 = +e21;
        if (t3 >= 0 && t3 < rn)
          return t3;
      }
      return e21;
    }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e20) {
    if (zr("SemVer.compare", this.version, this.options, e20), !(e20 instanceof an)) {
      if (typeof e20 == "string" && e20 === this.version)
        return 0;
      e20 = new an(e20, this.options);
    }
    return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
  }
  compareMain(e20) {
    return e20 instanceof an || (e20 = new an(e20, this.options)), on(this.major, e20.major) || on(this.minor, e20.minor) || on(this.patch, e20.patch);
  }
  comparePre(e20) {
    if (e20 instanceof an || (e20 = new an(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
      return -1;
    if (!this.prerelease.length && e20.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e20.prerelease.length)
      return 0;
    let t2 = 0;
    do {
      const r2 = this.prerelease[t2], n2 = e20.prerelease[t2];
      if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
        return 0;
      if (n2 === void 0)
        return 1;
      if (r2 === void 0)
        return -1;
      if (r2 !== n2)
        return on(r2, n2);
    } while (++t2);
  }
  compareBuild(e20) {
    e20 instanceof an || (e20 = new an(e20, this.options));
    let t2 = 0;
    do {
      const r2 = this.build[t2], n2 = e20.build[t2];
      if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
        return 0;
      if (n2 === void 0)
        return 1;
      if (r2 === void 0)
        return -1;
      if (r2 !== n2)
        return on(r2, n2);
    } while (++t2);
  }
  inc(e20, t2) {
    switch (e20) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let e21 = this.prerelease.length;
          for (; --e21 >= 0; )
            typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
          e21 === -1 && this.prerelease.push(0);
        }
        t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e20}`);
    }
    return this.format(), this.raw = this.version, this;
  }
}
var un = an;
var cn = (e20, t2, r2) => new un(e20, r2).compare(new un(t2, r2));
var ln = (e20, t2, r2) => cn(e20, t2, r2) < 0;
var pn = (e20, t2, r2) => cn(e20, t2, r2) >= 0, hn = t$1(function(e20, t2) {
  function r2() {
    for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
      e21[t3] = arguments[t3];
  }
  function n2() {
    return typeof WeakMap != "undefined" ? new WeakMap() : {add: r2, delete: r2, get: r2, set: r2, has: function(e21) {
      return false;
    }};
  }
  Object.defineProperty(t2, "__esModule", {value: true}), t2.outdent = void 0;
  var i2 = Object.prototype.hasOwnProperty, s2 = function(e21, t3) {
    return i2.call(e21, t3);
  };
  function o2(e21, t3) {
    for (var r3 in t3)
      s2(t3, r3) && (e21[r3] = t3[r3]);
    return e21;
  }
  var a2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function h2(e21, t3, r3) {
    var n3 = 0, i3 = e21[0].match(l2);
    i3 && (n3 = i3[1].length);
    var s3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
    t3 && (e21 = e21.slice(1));
    var o3 = r3.newline, c3 = r3.trimLeadingNewline, p3 = r3.trimTrailingNewline, h3 = typeof o3 == "string", D3 = e21.length;
    return e21.map(function(e22, t4) {
      return e22 = e22.replace(s3, "$1"), t4 === 0 && c3 && (e22 = e22.replace(a2, "")), t4 === D3 - 1 && p3 && (e22 = e22.replace(u2, "")), h3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
        return o3;
      })), e22;
    });
  }
  function D2(e21, t3) {
    for (var r3 = "", n3 = 0, i3 = e21.length; n3 < i3; n3++)
      r3 += e21[n3], n3 < i3 - 1 && (r3 += t3[n3]);
    return r3;
  }
  function f2(e21) {
    return s2(e21, "raw") && s2(e21, "length");
  }
  var d2 = function e21(t3) {
    var r3 = n2(), i3 = n2();
    return o2(function n3(s3) {
      for (var a3 = [], u3 = 1; u3 < arguments.length; u3++)
        a3[u3 - 1] = arguments[u3];
      if (f2(s3)) {
        var l3 = s3, g2 = (a3[0] === n3 || a3[0] === d2) && p2.test(l3[0]) && c2.test(l3[1]), m2 = g2 ? i3 : r3, E2 = m2.get(l3);
        if (E2 || (E2 = h2(l3, g2, t3), m2.set(l3, E2)), a3.length === 0)
          return E2[0];
        var C2 = D2(E2, g2 ? a3.slice(1) : a3);
        return C2;
      }
      return e21(o2(o2({}, t3), s3 || {}));
    }, {string: function(e22) {
      return h2([e22], false, t3)[0];
    }});
  }({trimLeadingNewline: true, trimTrailingNewline: true});
  t2.outdent = d2, t2.default = d2;
  try {
    e20.exports = d2, Object.defineProperty(d2, "__esModule", {value: true}), d2.default = d2, d2.outdent = d2;
  } catch (e21) {
  }
});
const {outdent: Dn} = hn, fn = {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: Dn`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: Dn`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e20) => typeof e20 == "string" || typeof e20 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: Dn`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Dn`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Dn`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: Dn`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
const dn = ["cliName", "cliCategory", "cliDescription"], gn = {compare: cn, lt: ln, gte: pn}, mn = "2.4.1", En = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: fn}.options;
var Cn = {getSupportInfo: function({plugins: e20 = [], showUnreleased: t2 = false, showDeprecated: r2 = false, showInternal: n2 = false} = {}) {
  const i2 = mn.split("-", 1)[0], s2 = e20.flatMap((e21) => e21.languages || []).filter(a2), o2 = ((e21, t3) => Object.entries(e21).map(([e22, r3]) => Object.assign({[t3]: e22}, r3)))(Object.assign({}, ...e20.map(({options: e21}) => e21), En), "name").filter((e21) => a2(e21) && u2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
    if (n2)
      return e21;
    return Q$1(e21, dn);
  }).map((t3) => {
    t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(a2).sort((e21, t4) => gn.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => a2(e21) && u2(e21)), t3.name === "parser" && function(e21, t4, r4) {
      const n3 = new Set(e21.choices.map((e22) => e22.value));
      for (const i3 of t4)
        if (i3.parsers) {
          for (const t5 of i3.parsers)
            if (!n3.has(t5)) {
              n3.add(t5);
              const s3 = r4.find((e22) => e22.parsers && e22.parsers[t5]);
              let o3 = i3.name;
              s3 && s3.name && (o3 += ` (plugin: ${s3.name})`), e21.choices.push({value: t5, description: o3});
            }
        }
    }(t3, s2, e20));
    const r3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
    return Object.assign(Object.assign({}, t3), {}, {pluginDefaults: r3});
  });
  return {languages: s2, options: o2};
  function a2(e21) {
    return t2 || !("since" in e21) || e21.since && gn.gte(i2, e21.since);
  }
  function u2(e21) {
    return r2 || !("deprecated" in e21) || e21.deprecated && gn.lt(i2, e21.deprecated);
  }
}};
const {getSupportInfo: yn} = Cn, bn = /[^\x20-\x7F]/;
function Sn(e20) {
  return (t2, r2, n2) => {
    const i2 = n2 && n2.backwards;
    if (r2 === false)
      return false;
    const {length: s2} = t2;
    let o2 = r2;
    for (; o2 >= 0 && o2 < s2; ) {
      const r3 = t2.charAt(o2);
      if (e20 instanceof RegExp) {
        if (!e20.test(r3))
          return o2;
      } else if (!e20.includes(r3))
        return o2;
      i2 ? o2-- : o2++;
    }
    return (o2 === -1 || o2 === s2) && o2;
  };
}
const Tn = Sn(/\s/), _n = Sn(" 	"), vn = Sn(",; 	"), An = Sn(/[^\n\r]/);
function Fn(e20, t2) {
  if (t2 === false)
    return false;
  if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
    for (let r2 = t2 + 2; r2 < e20.length; ++r2)
      if (e20.charAt(r2) === "*" && e20.charAt(r2 + 1) === "/")
        return r2 + 2;
  }
  return t2;
}
function wn(e20, t2) {
  return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? An(e20, t2) : t2);
}
function kn(e20, t2, r2) {
  const n2 = r2 && r2.backwards;
  if (t2 === false)
    return false;
  const i2 = e20.charAt(t2);
  if (n2) {
    if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
      return t2 - 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 - 1;
  } else {
    if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
      return t2 + 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
function Nn(e20, t2, r2 = {}) {
  const n2 = _n(e20, r2.backwards ? t2 - 1 : t2, r2);
  return n2 !== kn(e20, n2, r2);
}
function On(e20, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = vn(e20, n2), n2 = Fn(e20, n2), n2 = _n(e20, n2);
  return n2 = wn(e20, n2), n2 = kn(e20, n2), n2 !== false && Nn(e20, n2);
}
function xn(e20, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = _n(e20, n2), n2 = Fn(e20, n2), n2 = wn(e20, n2), n2 = kn(e20, n2);
  return n2;
}
function In(e20, t2, r2) {
  return xn(e20, r2(t2));
}
function Pn(e20, t2, r2 = 0) {
  let n2 = 0;
  for (let i2 = r2; i2 < e20.length; ++i2)
    e20[i2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
  return n2;
}
function Rn(e20, t2) {
  const r2 = e20.slice(1, -1), n2 = {quote: '"', regex: /"/g}, i2 = {quote: "'", regex: /'/g}, s2 = t2 === "'" ? i2 : n2, o2 = s2 === i2 ? n2 : i2;
  let a2 = s2.quote;
  if (r2.includes(s2.quote) || r2.includes(o2.quote)) {
    a2 = (r2.match(s2.regex) || []).length > (r2.match(o2.regex) || []).length ? o2.quote : s2.quote;
  }
  return a2;
}
function Ln(e20, t2, r2) {
  const n2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, s2) => i3 === n2 ? i3 : s2 === t2 ? "\\" + s2 : s2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
  return t2 + i2 + t2;
}
function Bn(e20, t2) {
  (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
    const t3 = e21.type || e21.kind || "(unknown type)";
    let r2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
    r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026");
    return t3 + (r2 ? " " + r2 : "");
  }(e20);
}
var $n = {inferParserByLanguage: function(e20, t2) {
  const {languages: r2} = yn({plugins: t2.plugins}), n2 = r2.find(({name: t3}) => t3.toLowerCase() === e20) || r2.find(({aliases: t3}) => Array.isArray(t3) && t3.includes(e20)) || r2.find(({extensions: t3}) => Array.isArray(t3) && t3.includes(`.${e20}`));
  return n2 && n2.parsers[0];
}, getStringWidth: function(e20) {
  return e20 ? bn.test(e20) ? z$1(e20) : e20.length : 0;
}, getMaxContinuousCount: function(e20, t2) {
  const r2 = e20.match(new RegExp(`(${Y$1(t2)})+`, "g"));
  return r2 === null ? 0 : r2.reduce((e21, r3) => Math.max(e21, r3.length / t2.length), 0);
}, getMinNotPresentContinuousCount: function(e20, t2) {
  const r2 = e20.match(new RegExp(`(${Y$1(t2)})+`, "g"));
  if (r2 === null)
    return 0;
  const n2 = new Map();
  let i2 = 0;
  for (const e21 of r2) {
    const r3 = e21.length / t2.length;
    n2.set(r3, true), r3 > i2 && (i2 = r3);
  }
  for (let e21 = 1; e21 < i2; e21++)
    if (!n2.get(e21))
      return e21;
  return i2 + 1;
}, getPenultimate: (e20) => e20[e20.length - 2], getLast: M$1, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: xn, getNextNonSpaceNonCommentCharacterIndex: In, getNextNonSpaceNonCommentCharacter: function(e20, t2, r2) {
  return e20.charAt(In(e20, t2, r2));
}, skip: Sn, skipWhitespace: Tn, skipSpaces: _n, skipToLineEnd: vn, skipEverythingButNewLine: An, skipInlineComment: Fn, skipTrailingComment: wn, skipNewline: kn, isNextLineEmptyAfterIndex: On, isNextLineEmpty: function(e20, t2, r2) {
  return On(e20, r2(t2));
}, isPreviousLineEmpty: function(e20, t2, r2) {
  let n2 = r2(t2) - 1;
  return n2 = _n(e20, n2, {backwards: true}), n2 = kn(e20, n2, {backwards: true}), n2 = _n(e20, n2, {backwards: true}), n2 !== kn(e20, n2, {backwards: true});
}, hasNewline: Nn, hasNewlineInRange: function(e20, t2, r2) {
  for (let n2 = t2; n2 < r2; ++n2)
    if (e20.charAt(n2) === "\n")
      return true;
  return false;
}, hasSpaces: function(e20, t2, r2 = {}) {
  return _n(e20, r2.backwards ? t2 - 1 : t2, r2) !== t2;
}, getAlignmentSize: Pn, getIndentSize: function(e20, t2) {
  const r2 = e20.lastIndexOf("\n");
  return r2 === -1 ? 0 : Pn(e20.slice(r2 + 1).match(/^[\t ]*/)[0], t2);
}, getPreferredQuote: Rn, printString: function(e20, t2) {
  return Ln(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Rn(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
}, printNumber: function(e20) {
  return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}, makeString: Ln, addLeadingComment: function(e20, t2) {
  t2.leading = true, t2.trailing = false, Bn(e20, t2);
}, addDanglingComment: function(e20, t2, r2) {
  t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Bn(e20, t2);
}, addTrailingComment: function(e20, t2) {
  t2.leading = false, t2.trailing = true, Bn(e20, t2);
}, isFrontMatterNode: function(e20) {
  return e20 && e20.type === "front-matter";
}, getShebang: function(e20) {
  if (!e20.startsWith("#!"))
    return "";
  const t2 = e20.indexOf("\n");
  return t2 === -1 ? e20 : e20.slice(0, t2);
}, isNonEmptyArray: function(e20) {
  return Array.isArray(e20) && e20.length > 0;
}, createGroupIdMapper: function(e20) {
  const t2 = new WeakMap();
  return function(r2) {
    return t2.has(r2) || t2.set(r2, Symbol(e20)), t2.get(r2);
  };
}}, qn = {"*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"]};
function Mn(e20) {
  return {type: "concat", parts: e20};
}
function jn(e20) {
  return {type: "indent", contents: e20};
}
function Un(e20, t2) {
  return {type: "align", contents: t2, n: e20};
}
function Gn(e20, t2 = {}) {
  return {type: "group", id: t2.id, contents: e20, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates};
}
const Vn = {type: "break-parent"}, Hn = {type: "line", hard: true}, Xn = {type: "line", hard: true, literal: true}, zn = Mn([Hn, Vn]), Wn = Mn([Xn, Vn]);
var Yn = {concat: Mn, join: function(e20, t2) {
  const r2 = [];
  for (let n2 = 0; n2 < t2.length; n2++)
    n2 !== 0 && r2.push(e20), r2.push(t2[n2]);
  return Mn(r2);
}, line: {type: "line"}, softline: {type: "line", soft: true}, hardline: zn, literalline: Wn, group: Gn, conditionalGroup: function(e20, t2) {
  return Gn(e20[0], Object.assign(Object.assign({}, t2), {}, {expandedStates: e20}));
}, fill: function(e20) {
  return {type: "fill", parts: e20};
}, lineSuffix: function(e20) {
  return {type: "line-suffix", contents: e20};
}, lineSuffixBoundary: {type: "line-suffix-boundary"}, cursor: {type: "cursor", placeholder: Symbol("cursor")}, breakParent: Vn, ifBreak: function(e20, t2, r2 = {}) {
  return {type: "if-break", breakContents: e20, flatContents: t2, groupId: r2.groupId};
}, trim: {type: "trim"}, indent: jn, indentIfBreak: function(e20, t2) {
  return {type: "indent-if-break", contents: e20, groupId: t2.groupId, negate: t2.negate};
}, align: Un, addAlignmentToDoc: function(e20, t2, r2) {
  let n2 = e20;
  if (t2 > 0) {
    for (let e21 = 0; e21 < Math.floor(t2 / r2); ++e21)
      n2 = jn(n2);
    n2 = Un(t2 % r2, n2), n2 = Un(Number.NEGATIVE_INFINITY, n2);
  }
  return n2;
}, markAsRoot: function(e20) {
  return Un({type: "root"}, e20);
}, dedentToRoot: function(e20) {
  return Un(Number.NEGATIVE_INFINITY, e20);
}, dedent: function(e20) {
  return Un(-1, e20);
}, hardlineWithoutBreakParent: Hn, literallineWithoutBreakParent: Xn, label: function(e20, t2) {
  return {type: "label", label: e20, contents: t2};
}};
var Qn = {guessEndOfLine: function(e20) {
  const t2 = e20.indexOf("\r");
  return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
}, convertEndOfLineToChars: function(e20) {
  switch (e20) {
    case "cr":
      return "\r";
    case "crlf":
      return "\r\n";
    default:
      return "\n";
  }
}, countEndOfLineChars: function(e20, t2) {
  let r2;
  if (t2 === "\n")
    r2 = /\n/g;
  else if (t2 === "\r")
    r2 = /\r/g;
  else {
    if (t2 !== "\r\n")
      throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
    r2 = /\r\n/g;
  }
  const n2 = e20.match(r2);
  return n2 ? n2.length : 0;
}, normalizeEndOfLine: function(e20) {
  return e20.replace(/\r\n?/g, "\n");
}};
const {literalline: Jn, join: Kn} = Yn, Zn = (e20) => Array.isArray(e20) || e20 && e20.type === "concat", ei = (e20) => {
  if (Array.isArray(e20))
    return e20;
  if (e20.type !== "concat" && e20.type !== "fill")
    throw new Error("Expect doc type to be `concat` or `fill`.");
  return e20.parts;
}, ti = {};
function ri(e20, t2, r2, n2) {
  const i2 = [e20];
  for (; i2.length > 0; ) {
    const e21 = i2.pop();
    if (e21 !== ti) {
      if (r2 && i2.push(e21, ti), !t2 || t2(e21) !== false)
        if (Zn(e21) || e21.type === "fill") {
          const t3 = ei(e21);
          for (let e22 = t3.length - 1; e22 >= 0; --e22)
            i2.push(t3[e22]);
        } else if (e21.type === "if-break")
          e21.flatContents && i2.push(e21.flatContents), e21.breakContents && i2.push(e21.breakContents);
        else if (e21.type === "group" && e21.expandedStates)
          if (n2)
            for (let t3 = e21.expandedStates.length - 1; t3 >= 0; --t3)
              i2.push(e21.expandedStates[t3]);
          else
            i2.push(e21.contents);
        else
          e21.contents && i2.push(e21.contents);
    } else
      r2(i2.pop());
  }
}
function ni(e20, t2) {
  const r2 = new Map();
  return n2(e20);
  function n2(e21) {
    if (r2.has(e21))
      return r2.get(e21);
    const i2 = function(e22) {
      if (Array.isArray(e22))
        return t2(e22.map(n2));
      if (e22.type === "concat" || e22.type === "fill") {
        const r3 = e22.parts.map(n2);
        return t2(Object.assign(Object.assign({}, e22), {}, {parts: r3}));
      }
      if (e22.type === "if-break") {
        const r3 = e22.breakContents && n2(e22.breakContents), i3 = e22.flatContents && n2(e22.flatContents);
        return t2(Object.assign(Object.assign({}, e22), {}, {breakContents: r3, flatContents: i3}));
      }
      if (e22.type === "group" && e22.expandedStates) {
        const r3 = e22.expandedStates.map(n2), i3 = r3[0];
        return t2(Object.assign(Object.assign({}, e22), {}, {contents: i3, expandedStates: r3}));
      }
      if (e22.contents) {
        const r3 = n2(e22.contents);
        return t2(Object.assign(Object.assign({}, e22), {}, {contents: r3}));
      }
      return t2(e22);
    }(e21);
    return r2.set(e21, i2), i2;
  }
}
function ii(e20, t2, r2) {
  let n2 = r2, i2 = false;
  return ri(e20, function(e21) {
    const r3 = t2(e21);
    if (r3 !== void 0 && (i2 = true, n2 = r3), i2)
      return false;
  }), n2;
}
function si(e20) {
  return !(e20.type !== "group" || !e20.break) || (!(e20.type !== "line" || !e20.hard) || (e20.type === "break-parent" || void 0));
}
function oi(e20) {
  if (e20.length > 0) {
    const t2 = M$1(e20);
    t2.expandedStates || t2.break || (t2.break = "propagated");
  }
  return null;
}
function ai(e20) {
  return e20.type !== "line" || e20.hard ? e20.type === "if-break" ? e20.flatContents || "" : e20 : e20.soft ? "" : " ";
}
const ui = (e20, t2) => e20 && e20.type === "line" && e20.hard && t2 && t2.type === "break-parent";
function ci(e20) {
  if (!e20)
    return e20;
  if (Zn(e20) || e20.type === "fill") {
    const t2 = ei(e20);
    for (; t2.length > 1 && ui(...t2.slice(-2)); )
      t2.length -= 2;
    if (t2.length > 0) {
      const e21 = ci(M$1(t2));
      t2[t2.length - 1] = e21;
    }
    return Array.isArray(e20) ? t2 : Object.assign(Object.assign({}, e20), {}, {parts: t2});
  }
  switch (e20.type) {
    case "align":
    case "indent":
    case "indent-if-break":
    case "group":
    case "line-suffix":
    case "label": {
      const t2 = ci(e20.contents);
      return Object.assign(Object.assign({}, e20), {}, {contents: t2});
    }
    case "if-break": {
      const t2 = ci(e20.breakContents), r2 = ci(e20.flatContents);
      return Object.assign(Object.assign({}, e20), {}, {breakContents: t2, flatContents: r2});
    }
  }
  return e20;
}
function li(e20) {
  return ni(e20, (e21) => function(e22) {
    switch (e22.type) {
      case "fill":
        if (e22.parts.length === 0 || e22.parts.every((e23) => e23 === ""))
          return "";
        break;
      case "group":
        if (!(e22.contents || e22.id || e22.break || e22.expandedStates))
          return "";
        if (e22.contents.type === "group" && e22.contents.id === e22.id && e22.contents.break === e22.break && e22.contents.expandedStates === e22.expandedStates)
          return e22.contents;
        break;
      case "align":
      case "indent":
      case "indent-if-break":
      case "line-suffix":
        if (!e22.contents)
          return "";
        break;
      case "if-break":
        if (!e22.flatContents && !e22.breakContents)
          return "";
    }
    if (!Zn(e22))
      return e22;
    const t2 = [];
    for (const r2 of ei(e22)) {
      if (!r2)
        continue;
      const [e23, ...n2] = Zn(r2) ? ei(r2) : [r2];
      typeof e23 == "string" && typeof M$1(t2) == "string" ? t2[t2.length - 1] += e23 : t2.push(e23), t2.push(...n2);
    }
    return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e22) ? t2 : Object.assign(Object.assign({}, e22), {}, {parts: t2});
  }(e21));
}
function pi(e20) {
  const t2 = [], r2 = e20.filter(Boolean);
  for (; r2.length > 0; ) {
    const e21 = r2.shift();
    e21 && (Zn(e21) ? r2.unshift(...ei(e21)) : t2.length > 0 && typeof M$1(t2) == "string" && typeof e21 == "string" ? t2[t2.length - 1] += e21 : t2.push(e21));
  }
  return t2;
}
function hi(e20, t2 = Jn) {
  return Kn(t2, e20.split("\n")).parts;
}
var Di = {isConcat: Zn, getDocParts: ei, willBreak: function(e20) {
  return ii(e20, si, false);
}, traverseDoc: ri, findInDoc: ii, mapDoc: ni, propagateBreaks: function(e20) {
  const t2 = new Set(), r2 = [];
  ri(e20, function(e21) {
    if (e21.type === "break-parent" && oi(r2), e21.type === "group") {
      if (r2.push(e21), t2.has(e21))
        return false;
      t2.add(e21);
    }
  }, function(e21) {
    if (e21.type === "group") {
      r2.pop().break && oi(r2);
    }
  }, true);
}, removeLines: function(e20) {
  return ni(e20, ai);
}, stripTrailingHardline: function(e20) {
  return ci(li(e20));
}, normalizeParts: pi, normalizeDoc: function(e20) {
  return ni(e20, (e21) => Array.isArray(e21) ? pi(e21) : e21.parts ? Object.assign(Object.assign({}, e21), {}, {parts: pi(e21.parts)}) : e21);
}, cleanDoc: li, replaceTextEndOfLine: hi, replaceEndOfLine: function(e20) {
  return ni(e20, (e21) => typeof e21 == "string" && e21.includes("\n") ? hi(e21) : e21);
}};
const {getStringWidth: fi, getLast: di} = $n, {convertEndOfLineToChars: gi} = Qn, {fill: mi, cursor: Ei, indent: Ci} = Yn, {isConcat: yi, getDocParts: bi} = Di;
let Si;
function Ti(e20, t2) {
  return vi(e20, {type: "indent"}, t2);
}
function _i(e20, t2, r2) {
  if (t2 === Number.NEGATIVE_INFINITY)
    return e20.root || {value: "", length: 0, queue: []};
  if (t2 < 0)
    return vi(e20, {type: "dedent"}, r2);
  if (!t2)
    return e20;
  if (t2.type === "root")
    return Object.assign(Object.assign({}, e20), {}, {root: e20});
  return vi(e20, {type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2}, r2);
}
function vi(e20, t2, r2) {
  const n2 = t2.type === "dedent" ? e20.queue.slice(0, -1) : [...e20.queue, t2];
  let i2 = "", s2 = 0, o2 = 0, a2 = 0;
  for (const e21 of n2)
    switch (e21.type) {
      case "indent":
        l2(), r2.useTabs ? u2(1) : c2(r2.tabWidth);
        break;
      case "stringAlign":
        l2(), i2 += e21.n, s2 += e21.n.length;
        break;
      case "numberAlign":
        o2 += 1, a2 += e21.n;
        break;
      default:
        throw new Error(`Unexpected type '${e21.type}'`);
    }
  return p2(), Object.assign(Object.assign({}, e20), {}, {value: i2, length: s2, queue: n2});
  function u2(e21) {
    i2 += "	".repeat(e21), s2 += r2.tabWidth * e21;
  }
  function c2(e21) {
    i2 += " ".repeat(e21), s2 += e21;
  }
  function l2() {
    r2.useTabs ? function() {
      o2 > 0 && u2(o2);
      h2();
    }() : p2();
  }
  function p2() {
    a2 > 0 && c2(a2), h2();
  }
  function h2() {
    o2 = 0, a2 = 0;
  }
}
function Ai(e20) {
  if (e20.length === 0)
    return 0;
  let t2 = 0;
  for (; e20.length > 0 && typeof di(e20) == "string" && /^[\t ]*$/.test(di(e20)); )
    t2 += e20.pop().length;
  if (e20.length > 0 && typeof di(e20) == "string") {
    const r2 = di(e20).replace(/[\t ]*$/, "");
    t2 += di(e20).length - r2.length, e20[e20.length - 1] = r2;
  }
  return t2;
}
function Fi(e20, t2, r2, n2, i2, s2) {
  let o2 = t2.length;
  const a2 = [e20], u2 = [];
  for (; r2 >= 0; ) {
    if (a2.length === 0) {
      if (o2 === 0)
        return true;
      a2.push(t2[o2 - 1]), o2--;
      continue;
    }
    const [e21, c2, l2] = a2.pop();
    if (typeof l2 == "string")
      u2.push(l2), r2 -= fi(l2);
    else if (yi(l2)) {
      const t3 = bi(l2);
      for (let r3 = t3.length - 1; r3 >= 0; r3--)
        a2.push([e21, c2, t3[r3]]);
    } else
      switch (l2.type) {
        case "indent":
          a2.push([Ti(e21, n2), c2, l2.contents]);
          break;
        case "align":
          a2.push([_i(e21, l2.n, n2), c2, l2.contents]);
          break;
        case "trim":
          r2 += Ai(u2);
          break;
        case "group": {
          if (s2 && l2.break)
            return false;
          const t3 = l2.break ? 1 : c2;
          a2.push([e21, t3, l2.expandedStates && t3 === 1 ? di(l2.expandedStates) : l2.contents]), l2.id && (Si[l2.id] = t3);
          break;
        }
        case "fill":
          for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
            a2.push([e21, c2, l2.parts[t3]]);
          break;
        case "if-break":
        case "indent-if-break": {
          const t3 = l2.groupId ? Si[l2.groupId] : c2;
          if (t3 === 1) {
            const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
            t4 && a2.push([e21, c2, t4]);
          }
          if (t3 === 2) {
            const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
            t4 && a2.push([e21, c2, t4]);
          }
          break;
        }
        case "line":
          switch (c2) {
            case 2:
              if (!l2.hard) {
                l2.soft || (u2.push(" "), r2 -= 1);
                break;
              }
              return true;
            case 1:
              return true;
          }
          break;
        case "line-suffix":
          i2 = true;
          break;
        case "line-suffix-boundary":
          if (i2)
            return false;
          break;
        case "label":
          a2.push([e21, c2, l2.contents]);
      }
  }
  return false;
}
var wi = {printDocToString: function(e20, t2) {
  Si = {};
  const r2 = t2.printWidth, n2 = gi(t2.endOfLine);
  let i2 = 0;
  const s2 = [[{value: "", length: 0, queue: []}, 1, e20]], o2 = [];
  let a2 = false, u2 = [];
  for (; s2.length > 0; ) {
    const [e21, c3, l2] = s2.pop();
    if (typeof l2 == "string") {
      const e22 = n2 !== "\n" ? l2.replace(/\n/g, n2) : l2;
      o2.push(e22), i2 += fi(e22);
    } else if (yi(l2)) {
      const t3 = bi(l2);
      for (let r3 = t3.length - 1; r3 >= 0; r3--)
        s2.push([e21, c3, t3[r3]]);
    } else
      switch (l2.type) {
        case "cursor":
          o2.push(Ei.placeholder);
          break;
        case "indent":
          s2.push([Ti(e21, t2), c3, l2.contents]);
          break;
        case "align":
          s2.push([_i(e21, l2.n, t2), c3, l2.contents]);
          break;
        case "trim":
          i2 -= Ai(o2);
          break;
        case "group":
          switch (c3) {
            case 2:
              if (!a2) {
                s2.push([e21, l2.break ? 1 : 2, l2.contents]);
                break;
              }
            case 1: {
              a2 = false;
              const n3 = [e21, 2, l2.contents], o3 = r2 - i2, c4 = u2.length > 0;
              if (!l2.break && Fi(n3, s2, o3, t2, c4))
                s2.push(n3);
              else if (l2.expandedStates) {
                const r3 = di(l2.expandedStates);
                if (l2.break) {
                  s2.push([e21, 1, r3]);
                  break;
                }
                for (let n4 = 1; n4 < l2.expandedStates.length + 1; n4++) {
                  if (n4 >= l2.expandedStates.length) {
                    s2.push([e21, 1, r3]);
                    break;
                  }
                  {
                    const r4 = [e21, 2, l2.expandedStates[n4]];
                    if (Fi(r4, s2, o3, t2, c4)) {
                      s2.push(r4);
                      break;
                    }
                  }
                }
              } else
                s2.push([e21, 1, l2.contents]);
              break;
            }
          }
          l2.id && (Si[l2.id] = di(s2)[1]);
          break;
        case "fill": {
          const n3 = r2 - i2, {parts: o3} = l2;
          if (o3.length === 0)
            break;
          const [a3, p2] = o3, h2 = [e21, 2, a3], D2 = [e21, 1, a3], f2 = Fi(h2, [], n3, t2, u2.length > 0, true);
          if (o3.length === 1) {
            f2 ? s2.push(h2) : s2.push(D2);
            break;
          }
          const d2 = [e21, 2, p2], g2 = [e21, 1, p2];
          if (o3.length === 2) {
            f2 ? s2.push(d2, h2) : s2.push(g2, D2);
            break;
          }
          o3.splice(0, 2);
          const m2 = [e21, c3, mi(o3)];
          Fi([e21, 2, [a3, p2, o3[0]]], [], n3, t2, u2.length > 0, true) ? s2.push(m2, d2, h2) : f2 ? s2.push(m2, g2, h2) : s2.push(m2, g2, D2);
          break;
        }
        case "if-break":
        case "indent-if-break": {
          const t3 = l2.groupId ? Si[l2.groupId] : c3;
          if (t3 === 1) {
            const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
            t4 && s2.push([e21, c3, t4]);
          }
          if (t3 === 2) {
            const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
            t4 && s2.push([e21, c3, t4]);
          }
          break;
        }
        case "line-suffix":
          u2.push([e21, c3, l2.contents]);
          break;
        case "line-suffix-boundary":
          u2.length > 0 && s2.push([e21, c3, {type: "line", hard: true}]);
          break;
        case "line":
          switch (c3) {
            case 2:
              if (!l2.hard) {
                l2.soft || (o2.push(" "), i2 += 1);
                break;
              }
              a2 = true;
            case 1:
              if (u2.length > 0) {
                s2.push([e21, c3, l2], ...u2.reverse()), u2 = [];
                break;
              }
              l2.literal ? e21.root ? (o2.push(n2, e21.root.value), i2 = e21.root.length) : (o2.push(n2), i2 = 0) : (i2 -= Ai(o2), o2.push(n2 + e21.value), i2 = e21.length);
          }
          break;
        case "label":
          s2.push([e21, c3, l2.contents]);
      }
    s2.length === 0 && u2.length > 0 && (s2.push(...u2.reverse()), u2 = []);
  }
  const c2 = o2.indexOf(Ei.placeholder);
  if (c2 !== -1) {
    const e21 = o2.indexOf(Ei.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), r3 = o2.slice(c2 + 1, e21).join("");
    return {formatted: t3 + r3 + o2.slice(e21 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: r3};
  }
  return {formatted: o2.join("")};
}};
const {isConcat: ki, getDocParts: Ni} = Di;
function Oi(e20) {
  if (!e20)
    return "";
  if (ki(e20)) {
    const t2 = [];
    for (const r2 of Ni(e20))
      if (ki(r2))
        t2.push(...Oi(r2).parts);
      else {
        const e21 = Oi(r2);
        e21 !== "" && t2.push(e21);
      }
    return {type: "concat", parts: t2};
  }
  return e20.type === "if-break" ? Object.assign(Object.assign({}, e20), {}, {breakContents: Oi(e20.breakContents), flatContents: Oi(e20.flatContents)}) : e20.type === "group" ? Object.assign(Object.assign({}, e20), {}, {contents: Oi(e20.contents), expandedStates: e20.expandedStates && e20.expandedStates.map(Oi)}) : e20.type === "fill" ? {type: "fill", parts: e20.parts.map(Oi)} : e20.contents ? Object.assign(Object.assign({}, e20), {}, {contents: Oi(e20.contents)}) : e20;
}
var xi = {builders: Yn, printer: wi, utils: Di, debug: {printDocToDebug: function(e20) {
  const t2 = Object.create(null), r2 = new Set();
  return function e21(t3, r3, i2) {
    if (typeof t3 == "string")
      return JSON.stringify(t3);
    if (ki(t3)) {
      const r4 = Ni(t3).map(e21).filter(Boolean);
      return r4.length === 1 ? r4[0] : `[${r4.join(", ")}]`;
    }
    if (t3.type === "line") {
      const e22 = Array.isArray(i2) && i2[r3 + 1] && i2[r3 + 1].type === "break-parent";
      return t3.literal ? e22 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e22 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
    }
    if (t3.type === "break-parent") {
      return Array.isArray(i2) && i2[r3 - 1] && i2[r3 - 1].type === "line" && i2[r3 - 1].hard ? void 0 : "breakParent";
    }
    if (t3.type === "trim")
      return "trim";
    if (t3.type === "indent")
      return "indent(" + e21(t3.contents) + ")";
    if (t3.type === "align")
      return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e21(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e21(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e21(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e21(t3.contents) + ")";
    if (t3.type === "if-break")
      return "ifBreak(" + e21(t3.breakContents) + (t3.flatContents ? ", " + e21(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${n2(t3.groupId)} }` : "") + ")";
    if (t3.type === "indent-if-break") {
      const r4 = [];
      t3.negate && r4.push("negate: true"), t3.groupId && r4.push(`groupId: ${n2(t3.groupId)}`);
      const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
      return `indentIfBreak(${e21(t3.contents)}${i3})`;
    }
    if (t3.type === "group") {
      const r4 = [];
      t3.break && t3.break !== "propagated" && r4.push("shouldBreak: true"), t3.id && r4.push(`id: ${n2(t3.id)}`);
      const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
      return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e21(t4)).join(",")}]${i3})` : `group(${e21(t3.contents)}${i3})`;
    }
    if (t3.type === "fill")
      return `fill([${t3.parts.map((t4) => e21(t4)).join(", ")}])`;
    if (t3.type === "line-suffix")
      return "lineSuffix(" + e21(t3.contents) + ")";
    if (t3.type === "line-suffix-boundary")
      return "lineSuffixBoundary";
    if (t3.type === "label")
      return `label(${JSON.stringify(t3.label)}, ${e21(t3.contents)})`;
    throw new Error("Unknown doc type " + t3.type);
  }(Oi(e20));
  function n2(e21) {
    if (typeof e21 != "symbol")
      return JSON.stringify(String(e21));
    if (e21 in t2)
      return t2[e21];
    const n3 = String(e21).slice(7, -1) || "symbol";
    for (let i2 = 0; ; i2++) {
      const s2 = n3 + (i2 > 0 ? ` #${i2}` : "");
      if (!r2.has(s2))
        return r2.add(s2), t2[e21] = `Symbol.for(${JSON.stringify(s2)})`;
    }
  }
}}};
const {inferParserByLanguage: Ii, isFrontMatterNode: Pi} = $n, {builders: {line: Ri, hardline: Li, join: Bi}, utils: {getDocParts: $i, replaceTextEndOfLine: qi}} = xi, {CSS_DISPLAY_TAGS: Mi, CSS_DISPLAY_DEFAULT: ji, CSS_WHITE_SPACE_TAGS: Ui, CSS_WHITE_SPACE_DEFAULT: Gi} = {CSS_DISPLAY_TAGS: {area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block"}, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: {listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap"}, CSS_WHITE_SPACE_DEFAULT: "normal"}, Vi = Yi(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), Hi = function(e20, t2) {
  const r2 = Object.create(null);
  for (const [n2, i2] of Object.entries(e20))
    r2[n2] = t2(i2, n2);
  return r2;
}(qn, Yi), Xi = new Set(["	", "\n", "\f", "\r", " "]), zi = (e20) => e20.replace(/[\t\n\f\r ]+$/, ""), Wi = (e20) => ((e21) => e21.replace(/^[\t\f\r ]*?\n/g, ""))(zi(e20));
function Yi(e20) {
  const t2 = Object.create(null);
  for (const r2 of e20)
    t2[r2] = true;
  return t2;
}
function Qi(e20) {
  return e20.type === "element" && (e20.fullName === "script" || e20.fullName === "style" || e20.fullName === "svg:style" || as(e20) && (e20.name === "script" || e20.name === "style"));
}
function Ji(e20) {
  return us(e20).startsWith("pre");
}
function Ki(e20) {
  return e20.type === "element" && e20.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e20.name) || e20.cssDisplay.startsWith("table") && e20.cssDisplay !== "table-cell");
}
function Zi(e20) {
  return ns(e20) || e20.type === "element" && e20.fullName === "br" || es(e20);
}
function es(e20) {
  return ts(e20) && rs(e20);
}
function ts(e20) {
  return e20.hasLeadingSpaces && (e20.prev ? e20.prev.sourceSpan.end.line < e20.sourceSpan.start.line : e20.parent.type === "root" || e20.parent.startSourceSpan.end.line < e20.sourceSpan.start.line);
}
function rs(e20) {
  return e20.hasTrailingSpaces && (e20.next ? e20.next.sourceSpan.start.line > e20.sourceSpan.end.line : e20.parent.type === "root" || e20.parent.endSourceSpan && e20.parent.endSourceSpan.start.line > e20.sourceSpan.end.line);
}
function ns(e20) {
  switch (e20.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(e20.name);
  }
  return false;
}
function is(e20) {
  const {type: t2, lang: r2} = e20.attrMap;
  return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || r2 === "jsx" ? "babel" : t2 === "application/x-typescript" || r2 === "ts" || r2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
}
function ss(e20) {
  return e20 === "block" || e20 === "list-item" || e20.startsWith("table");
}
function os(e20) {
  return us(e20).startsWith("pre");
}
function as(e20) {
  return e20.type === "element" && !e20.hasExplicitNamespace && !["html", "svg"].includes(e20.namespace);
}
function us(e20) {
  return e20.type === "element" && (!e20.namespace || as(e20)) && Ui[e20.name] || Gi;
}
function cs(e20, t2 = function(e21) {
  let t3 = Number.POSITIVE_INFINITY;
  for (const n2 of e21.split("\n")) {
    if (n2.length === 0)
      continue;
    if (!Xi.has(n2[0]))
      return 0;
    const e22 = (r2 = n2, r2.match(/^[\t\n\f\r ]*/)[0]).length;
    n2.length !== e22 && e22 < t3 && (t3 = e22);
  }
  var r2;
  return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
}(e20)) {
  return t2 === 0 ? e20 : e20.split("\n").map((e21) => e21.slice(t2)).join("\n");
}
const ls = new Set(["template", "style", "script"]);
function ps(e20, t2) {
  return hs(e20, t2) && !ls.has(e20.fullName);
}
function hs(e20, t2) {
  return t2.parser === "vue" && e20.type === "element" && e20.parent.type === "root" && e20.fullName.toLowerCase() !== "html";
}
function Ds(e20, t2) {
  return hs(e20, t2) && (ps(e20, t2) || e20.attrMap.lang && e20.attrMap.lang !== "html");
}
var fs = {HTML_ELEMENT_ATTRIBUTES: Hi, HTML_TAGS: Vi, htmlTrim: (e20) => ((e21) => e21.replace(/^[\t\n\f\r ]+/, ""))(zi(e20)), htmlTrimPreserveIndentation: Wi, hasHtmlWhitespace: (e20) => /[\t\n\f\r ]/.test(e20), getLeadingAndTrailingHtmlWhitespace: (e20) => {
  const [, t2, r2, n2] = e20.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
  return {leadingWhitespace: t2, trailingWhitespace: n2, text: r2};
}, canHaveInterpolation: function(e20) {
  return e20.children && !Qi(e20);
}, countChars: function(e20, t2) {
  let r2 = 0;
  for (let n2 = 0; n2 < e20.length; n2++)
    e20[n2] === t2 && r2++;
  return r2;
}, countParents: function(e20, t2) {
  let r2 = 0;
  for (let n2 = e20.stack.length - 1; n2 >= 0; n2--) {
    const i2 = e20.stack[n2];
    i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && r2++;
  }
  return r2;
}, dedentString: cs, forceBreakChildren: Ki, forceBreakContent: function(e20) {
  return Ki(e20) || e20.type === "element" && e20.children.length > 0 && (["body", "script", "style"].includes(e20.name) || e20.children.some((e21) => function(e22) {
    return e22.children && e22.children.some((e23) => e23.type !== "text");
  }(e21))) || e20.firstChild && e20.firstChild === e20.lastChild && e20.firstChild.type !== "text" && ts(e20.firstChild) && (!e20.lastChild.isTrailingSpaceSensitive || rs(e20.lastChild));
}, forceNextEmptyLine: function(e20) {
  return Pi(e20) || e20.next && e20.sourceSpan.end && e20.sourceSpan.end.line + 1 < e20.next.sourceSpan.start.line;
}, getLastDescendant: function e18(t2) {
  return t2.lastChild ? e18(t2.lastChild) : t2;
}, getNodeCssStyleDisplay: function(e20, t2) {
  if (e20.prev && e20.prev.type === "comment") {
    const t3 = e20.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (t3)
      return t3[1];
  }
  let r2 = false;
  if (e20.type === "element" && e20.namespace === "svg") {
    if (!function(e21, t3) {
      let r3 = e21;
      for (; r3; ) {
        if (t3(r3))
          return true;
        r3 = r3.parent;
      }
      return false;
    }(e20, (e21) => e21.fullName === "svg:foreignObject"))
      return e20.name === "svg" ? "inline-block" : "block";
    r2 = true;
  }
  switch (t2.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t2.parser === "vue" && e20.parent && e20.parent.type === "root" ? "block" : e20.type === "element" && (!e20.namespace || r2 || as(e20)) && Mi[e20.name] || ji;
  }
}, getNodeCssStyleWhiteSpace: us, hasPrettierIgnore: function(e20) {
  return e20.type !== "attribute" && (!!e20.parent && (typeof e20.index == "number" && e20.index !== 0 && function(e21) {
    return e21.type === "comment" && e21.value.trim() === "prettier-ignore";
  }(e20.parent.children[e20.index - 1])));
}, inferScriptParser: function(e20, t2) {
  return e20.name !== "script" || e20.attrMap.src ? e20.name === "style" ? function(e21) {
    const {lang: t3} = e21.attrMap;
    return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
  }(e20) : t2 && Ds(e20, t2) ? is(e20) || !("src" in e20.attrMap) && Ii(e20.attrMap.lang, t2) : void 0 : e20.attrMap.lang || e20.attrMap.type ? is(e20) : "babel";
}, isVueCustomBlock: ps, isVueNonHtmlBlock: Ds, isVueSlotAttribute: function(e20) {
  const t2 = e20.fullName;
  return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
}, isVueSfcBindingsAttribute: function(e20, t2) {
  const r2 = e20.parent;
  if (!hs(r2, t2))
    return false;
  const n2 = r2.fullName, i2 = e20.fullName;
  return n2 === "script" && i2 === "setup" || n2 === "style" && i2 === "vars";
}, isDanglingSpaceSensitiveNode: function(e20) {
  return !(t2 = e20.cssDisplay, ss(t2) || t2 === "inline-block" || Qi(e20));
  var t2;
}, isIndentationSensitiveNode: Ji, isLeadingSpaceSensitiveNode: function(e20, t2) {
  const r2 = function() {
    if (Pi(e20))
      return false;
    if ((e20.type === "text" || e20.type === "interpolation") && e20.prev && (e20.prev.type === "text" || e20.prev.type === "interpolation"))
      return true;
    if (!e20.parent || e20.parent.cssDisplay === "none")
      return false;
    if (os(e20.parent))
      return true;
    if (!e20.prev && (e20.parent.type === "root" || os(e20) && e20.parent || Qi(e20.parent) || ps(e20.parent, t2) || (r3 = e20.parent.cssDisplay, ss(r3) || r3 === "inline-block")))
      return false;
    var r3;
    if (e20.prev && !function(e21) {
      return !ss(e21);
    }(e20.prev.cssDisplay))
      return false;
    return true;
  }();
  return r2 && !e20.prev && e20.parent && e20.parent.tagDefinition && e20.parent.tagDefinition.ignoreFirstLf ? e20.type === "interpolation" : r2;
}, isPreLikeNode: os, isScriptLikeTag: Qi, isTextLikeNode: function(e20) {
  return e20.type === "text" || e20.type === "comment";
}, isTrailingSpaceSensitiveNode: function(e20, t2) {
  return !Pi(e20) && (!(e20.type !== "text" && e20.type !== "interpolation" || !e20.next || e20.next.type !== "text" && e20.next.type !== "interpolation") || !(!e20.parent || e20.parent.cssDisplay === "none") && (!!os(e20.parent) || !(!e20.next && (e20.parent.type === "root" || os(e20) && e20.parent || Qi(e20.parent) || ps(e20.parent, t2) || (r2 = e20.parent.cssDisplay, ss(r2) || r2 === "inline-block"))) && !(e20.next && !function(e21) {
    return !ss(e21);
  }(e20.next.cssDisplay))));
  var r2;
}, isWhitespaceSensitiveNode: function(e20) {
  return Qi(e20) || e20.type === "interpolation" || Ji(e20);
}, isUnknownNamespace: as, preferHardlineAsLeadingSpaces: function(e20) {
  return ns(e20) || e20.prev && Zi(e20.prev) || es(e20);
}, preferHardlineAsTrailingSpaces: Zi, shouldPreserveContent: function(e20, t2) {
  return !(e20.type !== "ieConditionalComment" || !e20.lastChild || e20.lastChild.isSelfClosing || e20.lastChild.endSourceSpan) || (e20.type === "ieConditionalComment" && !e20.complete || (!(!os(e20) || !e20.children.some((e21) => e21.type !== "text" && e21.type !== "interpolation")) || !(!Ds(e20, t2) || Qi(e20) || e20.type === "interpolation")));
}, unescapeQuoteEntities: function(e20) {
  return e20.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
}, getTextValueParts: function(e20, t2 = e20.value) {
  return e20.parent.isWhitespaceSensitive ? e20.parent.isIndentationSensitive ? qi(t2) : qi(cs(Wi(t2)), Li) : $i(Bi(Ri, t2.split(/[\t\n\f\r ]+/)));
}};
var ds = {hasPragma: function(e20) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e20);
}, insertPragma: function(e20) {
  return "<!-- @format -->\n\n" + e20.replace(/^\s*\n/, "");
}};
const {isNonEmptyArray: gs} = $n, ms = {attrs: true, children: true};
class Es {
  constructor(e20 = {}) {
    for (const [t2, r2] of Object.entries(e20))
      t2 in ms ? this._setNodes(t2, r2) : this[t2] = r2;
  }
  _setNodes(e20, t2) {
    t2 !== this[e20] && (this[e20] = function(e21, t3) {
      const r2 = e21.map((e22) => e22 instanceof Es ? e22.clone() : new Es(e22));
      let n2 = null, i2 = r2[0], s2 = r2[1] || null;
      for (let e22 = 0; e22 < r2.length; e22++)
        ys(i2, {index: e22, siblings: r2, prev: n2, next: s2, parent: t3}), n2 = i2, i2 = s2, s2 = r2[e22 + 2] || null;
      return r2;
    }(t2, this), e20 === "attrs" && ys(this, {attrMap: Object.fromEntries(this[e20].map((e21) => [e21.fullName, e21.value]))}));
  }
  map(e20) {
    let t2 = null;
    for (const r2 in ms) {
      const n2 = this[r2];
      if (n2) {
        const i2 = Cs(n2, (t3) => t3.map(e20));
        t2 !== n2 && (t2 || (t2 = new Es()), t2._setNodes(r2, i2));
      }
    }
    if (t2) {
      for (const e22 in this)
        e22 in ms || (t2[e22] = this[e22]);
      const {index: e21, siblings: r2, prev: n2, next: i2, parent: s2} = this;
      ys(t2, {index: e21, siblings: r2, prev: n2, next: i2, parent: s2});
    }
    return e20(t2 || this);
  }
  walk(e20) {
    for (const t2 in ms) {
      const r2 = this[t2];
      if (r2)
        for (let t3 = 0; t3 < r2.length; t3++)
          r2[t3].walk(e20);
    }
    e20(this);
  }
  clone(e20) {
    return new Es(e20 ? Object.assign(Object.assign({}, this), e20) : this);
  }
  setChildren(e20) {
    this._setNodes("children", e20);
  }
  get firstChild() {
    return gs(this.children) ? this.children[0] : null;
  }
  get lastChild() {
    return gs(this.children) ? M$1(this.children) : null;
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
}
function Cs(e20, t2) {
  const r2 = e20.map(t2);
  return r2.some((t3, r3) => t3 !== e20[r3]) ? r2 : e20;
}
function ys(e20, t2) {
  const r2 = Object.fromEntries(Object.entries(t2).map(([e21, t3]) => [e21, {value: t3, enumerable: false}]));
  Object.defineProperties(e20, r2);
}
var bs = {Node: Es};
const {ParseSourceSpan: Ss} = B$1, Ts = [{regex: /^(\[if([^\]]*?)]>)(.*?)<!\s*\[endif]$/s, parse: function(e20, t2, r2) {
  const [, n2, i2, s2] = r2, o2 = "<!--".length + n2.length, a2 = e20.sourceSpan.start.moveBy(o2), u2 = a2.moveBy(s2.length), [c2, l2] = (() => {
    try {
      return [true, t2(s2, a2).children];
    } catch {
      return [false, [{type: "text", value: s2, sourceSpan: new Ss(a2, u2)}]];
    }
  })();
  return {type: "ieConditionalComment", complete: c2, children: l2, condition: i2.trim().replace(/\s+/g, " "), sourceSpan: e20.sourceSpan, startSourceSpan: new Ss(e20.sourceSpan.start, a2), endSourceSpan: new Ss(u2, e20.sourceSpan.end)};
}}, {regex: /^\[if([^\]]*?)]><!$/, parse: function(e20, t2, r2) {
  const [, n2] = r2;
  return {type: "ieConditionalStartComment", condition: n2.trim().replace(/\s+/g, " "), sourceSpan: e20.sourceSpan};
}}, {regex: /^<!\s*\[endif]$/, parse: function(e20) {
  return {type: "ieConditionalEndComment", sourceSpan: e20.sourceSpan};
}}];
var _s = {parseIeConditionalComment: function(e20, t2) {
  if (e20.value)
    for (const {regex: r2, parse: n2} of Ts) {
      const i2 = e20.value.match(r2);
      if (i2)
        return n2(e20, t2, i2);
    }
  return null;
}};
var vs = {locStart: function(e20) {
  return e20.sourceSpan.start.offset;
}, locEnd: function(e20) {
  return e20.sourceSpan.end.offset;
}}, As = t$1(function(e20, t2) {
  function r2(e21) {
    if (e21[0] != ":")
      return [null, e21];
    const t3 = e21.indexOf(":", 1);
    if (t3 == -1)
      throw new Error(`Unsupported format "${e21}" expecting ":namespace:name"`);
    return [e21.slice(1, t3), e21.slice(t3 + 1)];
  }
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  Object.defineProperty(t2, "__esModule", {value: true}), function(e21) {
    e21[e21.RAW_TEXT = 0] = "RAW_TEXT", e21[e21.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e21[e21.PARSABLE_DATA = 2] = "PARSABLE_DATA";
  }(t2.TagContentType || (t2.TagContentType = {})), t2.splitNsName = r2, t2.isNgContainer = function(e21) {
    return r2(e21)[1] === "ng-container";
  }, t2.isNgContent = function(e21) {
    return r2(e21)[1] === "ng-content";
  }, t2.isNgTemplate = function(e21) {
    return r2(e21)[1] === "ng-template";
  }, t2.getNsPrefix = function(e21) {
    return e21 === null ? null : r2(e21)[0];
  }, t2.mergeNsAndName = function(e21, t3) {
    return e21 ? `:${e21}:${t3}` : t3;
  }, t2.NAMED_ENTITIES = {Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", GT: ">", Gt: "\u226B", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", LT: "<", Lt: "\u226A", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C"}, t2.NGSP_UNICODE = "\uE500", t2.NAMED_ENTITIES.ngsp = t2.NGSP_UNICODE;
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class Fs {
  constructor({closedByChildren: e20, implicitNamespacePrefix: t2, contentType: r2 = As.TagContentType.PARSABLE_DATA, closedByParent: n2 = false, isVoid: i2 = false, ignoreFirstLf: s2 = false} = {}) {
    this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, e20 && e20.length > 0 && e20.forEach((e21) => this.closedByChildren[e21] = true), this.isVoid = i2, this.closedByParent = n2 || i2, this.implicitNamespacePrefix = t2 || null, this.contentType = r2, this.ignoreFirstLf = s2;
  }
  isClosedByChild(e20) {
    return this.isVoid || e20.toLowerCase() in this.closedByChildren;
  }
}
var ws = Fs;
let ks, Ns;
var Os = function(e20) {
  return Ns || (ks = new Fs(), Ns = {base: new Fs({isVoid: true}), meta: new Fs({isVoid: true}), area: new Fs({isVoid: true}), embed: new Fs({isVoid: true}), link: new Fs({isVoid: true}), img: new Fs({isVoid: true}), input: new Fs({isVoid: true}), param: new Fs({isVoid: true}), hr: new Fs({isVoid: true}), br: new Fs({isVoid: true}), source: new Fs({isVoid: true}), track: new Fs({isVoid: true}), wbr: new Fs({isVoid: true}), p: new Fs({closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true}), thead: new Fs({closedByChildren: ["tbody", "tfoot"]}), tbody: new Fs({closedByChildren: ["tbody", "tfoot"], closedByParent: true}), tfoot: new Fs({closedByChildren: ["tbody"], closedByParent: true}), tr: new Fs({closedByChildren: ["tr"], closedByParent: true}), td: new Fs({closedByChildren: ["td", "th"], closedByParent: true}), th: new Fs({closedByChildren: ["td", "th"], closedByParent: true}), col: new Fs({isVoid: true}), svg: new Fs({implicitNamespacePrefix: "svg"}), math: new Fs({implicitNamespacePrefix: "math"}), li: new Fs({closedByChildren: ["li"], closedByParent: true}), dt: new Fs({closedByChildren: ["dt", "dd"]}), dd: new Fs({closedByChildren: ["dt", "dd"], closedByParent: true}), rb: new Fs({closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true}), rt: new Fs({closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true}), rtc: new Fs({closedByChildren: ["rb", "rtc", "rp"], closedByParent: true}), rp: new Fs({closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true}), optgroup: new Fs({closedByChildren: ["optgroup"], closedByParent: true}), option: new Fs({closedByChildren: ["option", "optgroup"], closedByParent: true}), pre: new Fs({ignoreFirstLf: true}), listing: new Fs({ignoreFirstLf: true}), style: new Fs({contentType: As.TagContentType.RAW_TEXT}), script: new Fs({contentType: As.TagContentType.RAW_TEXT}), title: new Fs({contentType: As.TagContentType.ESCAPABLE_RAW_TEXT}), textarea: new Fs({contentType: As.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true})}), Ns[e20] || ks;
}, xs = Object.defineProperty({HtmlTagDefinition: ws, getHtmlTagDefinition: Os}, "__esModule", {value: true});
var Is = class {
  constructor(e20, t2 = -1) {
    this.path = e20, this.position = t2;
  }
  get empty() {
    return !this.path || !this.path.length;
  }
  get head() {
    return this.path[0];
  }
  get tail() {
    return this.path[this.path.length - 1];
  }
  parentOf(e20) {
    return e20 && this.path[this.path.indexOf(e20) - 1];
  }
  childOf(e20) {
    return this.path[this.path.indexOf(e20) + 1];
  }
  first(e20) {
    for (let t2 = this.path.length - 1; t2 >= 0; t2--) {
      let r2 = this.path[t2];
      if (r2 instanceof e20)
        return r2;
    }
  }
  push(e20) {
    this.path.push(e20);
  }
  pop() {
    return this.path.pop();
  }
}, Ps = Object.defineProperty({AstPath: Is}, "__esModule", {value: true});
var Rs = class {
  constructor(e20, t2, r2) {
    this.value = e20, this.sourceSpan = t2, this.i18n = r2, this.type = "text";
  }
  visit(e20, t2) {
    return e20.visitText(this, t2);
  }
};
var Ls = class {
  constructor(e20, t2) {
    this.value = e20, this.sourceSpan = t2, this.type = "cdata";
  }
  visit(e20, t2) {
    return e20.visitCdata(this, t2);
  }
};
var Bs = class {
  constructor(e20, t2, r2, n2, i2, s2) {
    this.switchValue = e20, this.type = t2, this.cases = r2, this.sourceSpan = n2, this.switchValueSourceSpan = i2, this.i18n = s2;
  }
  visit(e20, t2) {
    return e20.visitExpansion(this, t2);
  }
};
var $s = class {
  constructor(e20, t2, r2, n2, i2) {
    this.value = e20, this.expression = t2, this.sourceSpan = r2, this.valueSourceSpan = n2, this.expSourceSpan = i2;
  }
  visit(e20, t2) {
    return e20.visitExpansionCase(this, t2);
  }
};
var qs = class {
  constructor(e20, t2, r2, n2 = null, i2 = null, s2 = null) {
    this.name = e20, this.value = t2, this.sourceSpan = r2, this.valueSpan = n2, this.nameSpan = i2, this.i18n = s2, this.type = "attribute";
  }
  visit(e20, t2) {
    return e20.visitAttribute(this, t2);
  }
};
class Ms {
  constructor(e20, t2, r2, n2, i2 = null, s2 = null, o2 = null, a2 = null) {
    this.name = e20, this.attrs = t2, this.children = r2, this.sourceSpan = n2, this.startSourceSpan = i2, this.endSourceSpan = s2, this.nameSpan = o2, this.i18n = a2, this.type = "element";
  }
  visit(e20, t2) {
    return e20.visitElement(this, t2);
  }
}
var js = Ms;
var Us = class {
  constructor(e20, t2) {
    this.value = e20, this.sourceSpan = t2, this.type = "comment";
  }
  visit(e20, t2) {
    return e20.visitComment(this, t2);
  }
};
var Gs = class {
  constructor(e20, t2) {
    this.value = e20, this.sourceSpan = t2, this.type = "docType";
  }
  visit(e20, t2) {
    return e20.visitDocType(this, t2);
  }
};
function Vs(e20, t2, r2 = null) {
  const n2 = [], i2 = e20.visit ? (t3) => e20.visit(t3, r2) || t3.visit(e20, r2) : (t3) => t3.visit(e20, r2);
  return t2.forEach((e21) => {
    const t3 = i2(e21);
    t3 && n2.push(t3);
  }), n2;
}
var Hs = Vs;
class Xs {
  constructor() {
  }
  visitElement(e20, t2) {
    this.visitChildren(t2, (t3) => {
      t3(e20.attrs), t3(e20.children);
    });
  }
  visitAttribute(e20, t2) {
  }
  visitText(e20, t2) {
  }
  visitCdata(e20, t2) {
  }
  visitComment(e20, t2) {
  }
  visitDocType(e20, t2) {
  }
  visitExpansion(e20, t2) {
    return this.visitChildren(t2, (t3) => {
      t3(e20.cases);
    });
  }
  visitExpansionCase(e20, t2) {
  }
  visitChildren(e20, t2) {
    let r2 = [], n2 = this;
    return t2(function(t3) {
      t3 && r2.push(Vs(n2, t3, e20));
    }), Array.prototype.concat.apply([], r2);
  }
}
var zs = Xs;
function Ws(e20) {
  const t2 = e20.sourceSpan.start.offset;
  let r2 = e20.sourceSpan.end.offset;
  return e20 instanceof Ms && (e20.endSourceSpan ? r2 = e20.endSourceSpan.end.offset : e20.children && e20.children.length && (r2 = Ws(e20.children[e20.children.length - 1]).end)), {start: t2, end: r2};
}
var Ys = function(e20, t2) {
  const r2 = [];
  return Vs(new class extends Xs {
    visit(e21, n2) {
      const i2 = Ws(e21);
      if (!(i2.start <= t2 && t2 < i2.end))
        return true;
      r2.push(e21);
    }
  }(), e20), new Ps.AstPath(r2, t2);
}, Qs = Object.defineProperty({Text: Rs, CDATA: Ls, Expansion: Bs, ExpansionCase: $s, Attribute: qs, Element: js, Comment: Us, DocType: Gs, visitAll: Hs, RecursiveVisitor: zs, findNode: Ys}, "__esModule", {value: true});
var Js = function(e20, t2) {
  if (t2 != null) {
    if (!Array.isArray(t2))
      throw new Error(`Expected '${e20}' to be an array of strings.`);
    for (let r2 = 0; r2 < t2.length; r2 += 1)
      if (typeof t2[r2] != "string")
        throw new Error(`Expected '${e20}' to be an array of strings.`);
  }
};
const Ks = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
var Zs = function(e20, t2) {
  if (!(t2 == null || Array.isArray(t2) && t2.length == 2))
    throw new Error(`Expected '${e20}' to be an array, [start, end].`);
  if (t2 != null) {
    const e21 = t2[0], r2 = t2[1];
    Ks.forEach((t3) => {
      if (t3.test(e21) || t3.test(r2))
        throw new Error(`['${e21}', '${r2}'] contains unusable interpolation symbol.`);
    });
  }
}, eo = Object.defineProperty({assertArrayOfStrings: Js, assertInterpolationSymbols: Zs}, "__esModule", {value: true}), to = t$1(function(e20, t2) {
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  Object.defineProperty(t2, "__esModule", {value: true});
  class r2 {
    constructor(e21, t3) {
      this.start = e21, this.end = t3;
    }
    static fromArray(e21) {
      return e21 ? (eo.assertInterpolationSymbols("interpolation", e21), new r2(e21[0], e21[1])) : t2.DEFAULT_INTERPOLATION_CONFIG;
    }
  }
  t2.InterpolationConfig = r2, t2.DEFAULT_INTERPOLATION_CONFIG = new r2("{{", "}}");
}), ro = t$1(function(e20, t2) {
  /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
  Object.defineProperty(t2, "__esModule", {value: true});
  const n2 = r$1;
  var i2;
  !function(e21) {
    e21[e21.TAG_OPEN_START = 0] = "TAG_OPEN_START", e21[e21.TAG_OPEN_END = 1] = "TAG_OPEN_END", e21[e21.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e21[e21.TAG_CLOSE = 3] = "TAG_CLOSE", e21[e21.TEXT = 4] = "TEXT", e21[e21.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", e21[e21.RAW_TEXT = 6] = "RAW_TEXT", e21[e21.COMMENT_START = 7] = "COMMENT_START", e21[e21.COMMENT_END = 8] = "COMMENT_END", e21[e21.CDATA_START = 9] = "CDATA_START", e21[e21.CDATA_END = 10] = "CDATA_END", e21[e21.ATTR_NAME = 11] = "ATTR_NAME", e21[e21.ATTR_QUOTE = 12] = "ATTR_QUOTE", e21[e21.ATTR_VALUE = 13] = "ATTR_VALUE", e21[e21.DOC_TYPE_START = 14] = "DOC_TYPE_START", e21[e21.DOC_TYPE_END = 15] = "DOC_TYPE_END", e21[e21.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e21[e21.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e21[e21.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e21[e21.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e21[e21.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e21[e21.EOF = 21] = "EOF";
  }(i2 = t2.TokenType || (t2.TokenType = {}));
  class s2 {
    constructor(e21, t3, r2) {
      this.type = e21, this.parts = t3, this.sourceSpan = r2;
    }
  }
  t2.Token = s2;
  class o2 extends B$1.ParseError {
    constructor(e21, t3, r2) {
      super(r2, e21), this.tokenType = t3;
    }
  }
  t2.TokenError = o2;
  class a2 {
    constructor(e21, t3) {
      this.tokens = e21, this.errors = t3;
    }
  }
  t2.TokenizeResult = a2, t2.tokenize = function(e21, t3, r2, n3 = {}) {
    return new h2(new B$1.ParseSourceFile(e21, t3), r2, n3).tokenize();
  };
  const u2 = /\r\n?/g;
  function c2(e21) {
    return `Unexpected character "${e21 === n2.$EOF ? "EOF" : String.fromCharCode(e21)}"`;
  }
  function l2(e21) {
    return `Unknown entity "${e21}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
  }
  class p2 {
    constructor(e21) {
      this.error = e21;
    }
  }
  class h2 {
    constructor(e21, t3, r2) {
      this._getTagContentType = t3, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = r2.tokenizeExpansionForms || false, this._interpolationConfig = r2.interpolationConfig || to.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = r2.leadingTriviaChars && r2.leadingTriviaChars.map((e22) => e22.codePointAt(0) || 0), this._canSelfClose = r2.canSelfClose || false, this._allowHtmComponentClosingTags = r2.allowHtmComponentClosingTags || false;
      const n3 = r2.range || {endPos: e21.content.length, startPos: 0, startLine: 0, startCol: 0};
      this._cursor = r2.escapedString ? new C2(e21, n3) : new E2(e21, n3);
      try {
        this._cursor.init();
      } catch (e22) {
        this.handleError(e22);
      }
    }
    _processCarriageReturns(e21) {
      return e21.replace(u2, "\n");
    }
    tokenize() {
      for (; this._cursor.peek() !== n2.$EOF; ) {
        const e21 = this._cursor.clone();
        try {
          if (this._attemptCharCode(n2.$LT))
            if (this._attemptCharCode(n2.$BANG))
              this._attemptStr("[CDATA[") ? this._consumeCdata(e21) : this._attemptStr("--") ? this._consumeComment(e21) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e21) : this._consumeBogusComment(e21);
            else if (this._attemptCharCode(n2.$SLASH))
              this._consumeTagClose(e21);
            else {
              const t3 = this._cursor.clone();
              this._attemptCharCode(n2.$QUESTION) ? (this._cursor = t3, this._consumeBogusComment(e21)) : this._consumeTagOpen(e21);
            }
          else
            this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
        } catch (e22) {
          this.handleError(e22);
        }
      }
      return this._beginToken(i2.EOF), this._endToken([]), new a2(function(e21) {
        const t3 = [];
        let r2;
        for (let n3 = 0; n3 < e21.length; n3++) {
          const s3 = e21[n3];
          r2 && r2.type == i2.TEXT && s3.type == i2.TEXT ? (r2.parts[0] += s3.parts[0], r2.sourceSpan.end = s3.sourceSpan.end) : (r2 = s3, t3.push(r2));
        }
        return t3;
      }(this.tokens), this.errors);
    }
    _tokenizeExpansionForm() {
      if (this.isExpansionFormStart())
        return this._consumeExpansionFormStart(), true;
      if (((e21 = this._cursor.peek()) === n2.$EQ || n2.isAsciiLetter(e21) || n2.isDigit(e21)) && this._isInExpansionForm())
        return this._consumeExpansionCaseStart(), true;
      var e21;
      if (this._cursor.peek() === n2.$RBRACE) {
        if (this._isInExpansionCase())
          return this._consumeExpansionCaseEnd(), true;
        if (this._isInExpansionForm())
          return this._consumeExpansionFormEnd(), true;
      }
      return false;
    }
    _beginToken(e21, t3 = this._cursor.clone()) {
      this._currentTokenStart = t3, this._currentTokenType = e21;
    }
    _endToken(e21, t3 = this._cursor.clone()) {
      if (this._currentTokenStart === null)
        throw new o2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t3));
      if (this._currentTokenType === null)
        throw new o2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
      const r2 = new s2(this._currentTokenType, e21, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
      return this.tokens.push(r2), this._currentTokenStart = null, this._currentTokenType = null, r2;
    }
    _createError(e21, t3) {
      this._isInExpansionForm() && (e21 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
      const r2 = new o2(e21, this._currentTokenType, t3);
      return this._currentTokenStart = null, this._currentTokenType = null, new p2(r2);
    }
    handleError(e21) {
      if (e21 instanceof y2 && (e21 = this._createError(e21.msg, this._cursor.getSpan(e21.cursor))), !(e21 instanceof p2))
        throw e21;
      this.errors.push(e21.error);
    }
    _attemptCharCode(e21) {
      return this._cursor.peek() === e21 && (this._cursor.advance(), true);
    }
    _attemptCharCodeCaseInsensitive(e21) {
      return t3 = this._cursor.peek(), r2 = e21, m2(t3) == m2(r2) && (this._cursor.advance(), true);
      var t3, r2;
    }
    _requireCharCode(e21) {
      const t3 = this._cursor.clone();
      if (!this._attemptCharCode(e21))
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
    }
    _attemptStr(e21) {
      const t3 = e21.length;
      if (this._cursor.charsLeft() < t3)
        return false;
      const r2 = this._cursor.clone();
      for (let n3 = 0; n3 < t3; n3++)
        if (!this._attemptCharCode(e21.charCodeAt(n3)))
          return this._cursor = r2, false;
      return true;
    }
    _attemptStrCaseInsensitive(e21) {
      for (let t3 = 0; t3 < e21.length; t3++)
        if (!this._attemptCharCodeCaseInsensitive(e21.charCodeAt(t3)))
          return false;
      return true;
    }
    _requireStr(e21) {
      const t3 = this._cursor.clone();
      if (!this._attemptStr(e21))
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
    }
    _requireStrCaseInsensitive(e21) {
      const t3 = this._cursor.clone();
      if (!this._attemptStrCaseInsensitive(e21))
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
    }
    _attemptCharCodeUntilFn(e21) {
      for (; !e21(this._cursor.peek()); )
        this._cursor.advance();
    }
    _requireCharCodeUntilFn(e21, t3) {
      const r2 = this._cursor.clone();
      this._attemptCharCodeUntilFn(e21);
      if (this._cursor.clone().diff(r2) < t3)
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(r2));
    }
    _attemptUntilChar(e21) {
      for (; this._cursor.peek() !== e21; )
        this._cursor.advance();
    }
    _readChar(e21) {
      if (e21 && this._cursor.peek() === n2.$AMPERSAND)
        return this._decodeEntity();
      {
        const e22 = String.fromCodePoint(this._cursor.peek());
        return this._cursor.advance(), e22;
      }
    }
    _decodeEntity() {
      const e21 = this._cursor.clone();
      if (this._cursor.advance(), !this._attemptCharCode(n2.$HASH)) {
        const t3 = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(g2), this._cursor.peek() != n2.$SEMICOLON)
          return this._cursor = t3, "&";
        const r2 = this._cursor.getChars(t3);
        this._cursor.advance();
        const i3 = As.NAMED_ENTITIES[r2];
        if (!i3)
          throw this._createError(l2(r2), this._cursor.getSpan(e21));
        return i3;
      }
      {
        const t3 = this._attemptCharCode(n2.$x) || this._attemptCharCode(n2.$X), r2 = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(d2), this._cursor.peek() != n2.$SEMICOLON)
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan());
        const i3 = this._cursor.getChars(r2);
        this._cursor.advance();
        try {
          const e22 = parseInt(i3, t3 ? 16 : 10);
          return String.fromCharCode(e22);
        } catch (t4) {
          throw this._createError(l2(this._cursor.getChars(e21)), this._cursor.getSpan());
        }
      }
    }
    _consumeRawText(e21, t3) {
      this._beginToken(e21 ? i2.ESCAPABLE_RAW_TEXT : i2.RAW_TEXT);
      const r2 = [];
      for (; ; ) {
        const n3 = this._cursor.clone(), i3 = t3();
        if (this._cursor = n3, i3)
          break;
        r2.push(this._readChar(e21));
      }
      return this._endToken([this._processCarriageReturns(r2.join(""))]);
    }
    _consumeComment(e21) {
      this._beginToken(i2.COMMENT_START, e21), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(i2.COMMENT_END), this._requireStr("-->"), this._endToken([]);
    }
    _consumeBogusComment(e21) {
      this._beginToken(i2.COMMENT_START, e21), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.COMMENT_END), this._cursor.advance(), this._endToken([]);
    }
    _consumeCdata(e21) {
      this._beginToken(i2.CDATA_START, e21), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(i2.CDATA_END), this._requireStr("]]>"), this._endToken([]);
    }
    _consumeDocType(e21) {
      this._beginToken(i2.DOC_TYPE_START, e21), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
    }
    _consumePrefixAndName() {
      const e21 = this._cursor.clone();
      let t3 = "";
      for (; this._cursor.peek() !== n2.$COLON && !(((r2 = this._cursor.peek()) < n2.$a || n2.$z < r2) && (r2 < n2.$A || n2.$Z < r2) && (r2 < n2.$0 || r2 > n2.$9)); )
        this._cursor.advance();
      var r2;
      let i3;
      this._cursor.peek() === n2.$COLON ? (t3 = this._cursor.getChars(e21), this._cursor.advance(), i3 = this._cursor.clone()) : i3 = e21, this._requireCharCodeUntilFn(f2, t3 === "" ? 0 : 1);
      return [t3, this._cursor.getChars(i3)];
    }
    _consumeTagOpen(e21) {
      let t3, r2, s3, o3 = this.tokens.length;
      const a3 = this._cursor.clone(), u3 = [];
      try {
        if (!n2.isAsciiLetter(this._cursor.peek()))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(e21));
        for (s3 = this._consumeTagOpenStart(e21), r2 = s3.parts[0], t3 = s3.parts[1], this._attemptCharCodeUntilFn(D2); this._cursor.peek() !== n2.$SLASH && this._cursor.peek() !== n2.$GT; ) {
          const [e22, t4] = this._consumeAttributeName();
          if (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$EQ)) {
            this._attemptCharCodeUntilFn(D2);
            const r3 = this._consumeAttributeValue();
            u3.push({prefix: e22, name: t4, value: r3});
          } else
            u3.push({prefix: e22, name: t4});
          this._attemptCharCodeUntilFn(D2);
        }
        this._consumeTagOpenEnd();
      } catch (t4) {
        if (t4 instanceof p2)
          return this._cursor = a3, s3 && (this.tokens.length = o3), this._beginToken(i2.TEXT, e21), void this._endToken(["<"]);
        throw t4;
      }
      if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === i2.TAG_OPEN_END_VOID)
        return;
      const l3 = this._getTagContentType(t3, r2, this._fullNameStack.length > 0, u3);
      this._handleFullNameStackForTagOpen(r2, t3), l3 === As.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(r2, t3, false) : l3 === As.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r2, t3, true);
    }
    _consumeRawTextWithTagClose(e21, t3, r2) {
      this._consumeRawText(r2, () => !!this._attemptCharCode(n2.$LT) && (!!this._attemptCharCode(n2.$SLASH) && (this._attemptCharCodeUntilFn(D2), !!this._attemptStrCaseInsensitive(e21 ? `${e21}:${t3}` : t3) && (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$GT))))), this._beginToken(i2.TAG_CLOSE), this._requireCharCodeUntilFn((e22) => e22 === n2.$GT, 3), this._cursor.advance(), this._endToken([e21, t3]), this._handleFullNameStackForTagClose(e21, t3);
    }
    _consumeTagOpenStart(e21) {
      this._beginToken(i2.TAG_OPEN_START, e21);
      const t3 = this._consumePrefixAndName();
      return this._endToken(t3);
    }
    _consumeAttributeName() {
      const e21 = this._cursor.peek();
      if (e21 === n2.$SQ || e21 === n2.$DQ)
        throw this._createError(c2(e21), this._cursor.getSpan());
      this._beginToken(i2.ATTR_NAME);
      const t3 = this._consumePrefixAndName();
      return this._endToken(t3), t3;
    }
    _consumeAttributeValue() {
      let e21;
      if (this._cursor.peek() === n2.$SQ || this._cursor.peek() === n2.$DQ) {
        this._beginToken(i2.ATTR_QUOTE);
        const t3 = this._cursor.peek();
        this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]), this._beginToken(i2.ATTR_VALUE);
        const r2 = [];
        for (; this._cursor.peek() !== t3; )
          r2.push(this._readChar(true));
        e21 = this._processCarriageReturns(r2.join("")), this._endToken([e21]), this._beginToken(i2.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]);
      } else {
        this._beginToken(i2.ATTR_VALUE);
        const t3 = this._cursor.clone();
        this._requireCharCodeUntilFn(f2, 1), e21 = this._processCarriageReturns(this._cursor.getChars(t3)), this._endToken([e21]);
      }
      return e21;
    }
    _consumeTagOpenEnd() {
      const e21 = this._attemptCharCode(n2.$SLASH) ? i2.TAG_OPEN_END_VOID : i2.TAG_OPEN_END;
      this._beginToken(e21), this._requireCharCode(n2.$GT), this._endToken([]);
    }
    _consumeTagClose(e21) {
      if (this._beginToken(i2.TAG_CLOSE, e21), this._attemptCharCodeUntilFn(D2), this._allowHtmComponentClosingTags && this._attemptCharCode(n2.$SLASH))
        this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([]);
      else {
        const [e22, t3] = this._consumePrefixAndName();
        this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([e22, t3]), this._handleFullNameStackForTagClose(e22, t3);
      }
    }
    _consumeExpansionFormStart() {
      this._beginToken(i2.EXPANSION_FORM_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._expansionCaseStack.push(i2.EXPANSION_FORM_START), this._beginToken(i2.RAW_TEXT);
      const e21 = this._readUntil(n2.$COMMA);
      this._endToken([e21]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.RAW_TEXT);
      const t3 = this._readUntil(n2.$COMMA);
      this._endToken([t3]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2);
    }
    _consumeExpansionCaseStart() {
      this._beginToken(i2.EXPANSION_CASE_VALUE);
      const e21 = this._readUntil(n2.$LBRACE).trim();
      this._endToken([e21]), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.EXPANSION_CASE_EXP_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.push(i2.EXPANSION_CASE_EXP_START);
    }
    _consumeExpansionCaseEnd() {
      this._beginToken(i2.EXPANSION_CASE_EXP_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.pop();
    }
    _consumeExpansionFormEnd() {
      this._beginToken(i2.EXPANSION_FORM_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
    }
    _consumeText() {
      const e21 = this._cursor.clone();
      this._beginToken(i2.TEXT, e21);
      const t3 = [];
      do {
        this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t3.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t3.push(this._interpolationConfig.end), this._inInterpolation = false) : t3.push(this._readChar(true));
      } while (!this._isTextEnd());
      this._endToken([this._processCarriageReturns(t3.join(""))]);
    }
    _isTextEnd() {
      if (this._cursor.peek() === n2.$LT || this._cursor.peek() === n2.$EOF)
        return true;
      if (this._tokenizeIcu && !this._inInterpolation) {
        if (this.isExpansionFormStart())
          return true;
        if (this._cursor.peek() === n2.$RBRACE && this._isInExpansionCase())
          return true;
      }
      return false;
    }
    _readUntil(e21) {
      const t3 = this._cursor.clone();
      return this._attemptUntilChar(e21), this._cursor.getChars(t3);
    }
    _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_CASE_EXP_START;
    }
    _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_FORM_START;
    }
    isExpansionFormStart() {
      if (this._cursor.peek() !== n2.$LBRACE)
        return false;
      if (this._interpolationConfig) {
        const e21 = this._cursor.clone(), t3 = this._attemptStr(this._interpolationConfig.start);
        return this._cursor = e21, !t3;
      }
      return true;
    }
    _handleFullNameStackForTagOpen(e21, t3) {
      const r2 = As.mergeNsAndName(e21, t3);
      this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] !== r2 || this._fullNameStack.push(r2);
    }
    _handleFullNameStackForTagClose(e21, t3) {
      const r2 = As.mergeNsAndName(e21, t3);
      this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === r2 && this._fullNameStack.pop();
    }
  }
  function D2(e21) {
    return !n2.isWhitespace(e21) || e21 === n2.$EOF;
  }
  function f2(e21) {
    return n2.isWhitespace(e21) || e21 === n2.$GT || e21 === n2.$SLASH || e21 === n2.$SQ || e21 === n2.$DQ || e21 === n2.$EQ;
  }
  function d2(e21) {
    return e21 == n2.$SEMICOLON || e21 == n2.$EOF || !n2.isAsciiHexDigit(e21);
  }
  function g2(e21) {
    return e21 == n2.$SEMICOLON || e21 == n2.$EOF || !n2.isAsciiLetter(e21);
  }
  function m2(e21) {
    return e21 >= n2.$a && e21 <= n2.$z ? e21 - n2.$a + n2.$A : e21;
  }
  class E2 {
    constructor(e21, t3) {
      if (e21 instanceof E2)
        this.file = e21.file, this.input = e21.input, this.end = e21.end, this.state = Object.assign({}, e21.state);
      else {
        if (!t3)
          throw new Error("Programming error: the range argument must be provided with a file argument.");
        this.file = e21, this.input = e21.content, this.end = t3.endPos, this.state = {peek: -1, offset: t3.startPos, line: t3.startLine, column: t3.startCol};
      }
    }
    clone() {
      return new E2(this);
    }
    peek() {
      return this.state.peek;
    }
    charsLeft() {
      return this.end - this.state.offset;
    }
    diff(e21) {
      return this.state.offset - e21.state.offset;
    }
    advance() {
      this.advanceState(this.state);
    }
    init() {
      this.updatePeek(this.state);
    }
    getSpan(e21, t3) {
      if (e21 = e21 || this, t3)
        for (e21 = e21.clone(); this.diff(e21) > 0 && t3.indexOf(e21.peek()) !== -1; )
          e21.advance();
      return new B$1.ParseSourceSpan(new B$1.ParseLocation(e21.file, e21.state.offset, e21.state.line, e21.state.column), new B$1.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
    }
    getChars(e21) {
      return this.input.substring(e21.state.offset, this.state.offset);
    }
    charAt(e21) {
      return this.input.charCodeAt(e21);
    }
    advanceState(e21) {
      if (e21.offset >= this.end)
        throw this.state = e21, new y2('Unexpected character "EOF"', this);
      const t3 = this.charAt(e21.offset);
      t3 === n2.$LF ? (e21.line++, e21.column = 0) : n2.isNewLine(t3) || e21.column++, e21.offset++, this.updatePeek(e21);
    }
    updatePeek(e21) {
      e21.peek = e21.offset >= this.end ? n2.$EOF : this.charAt(e21.offset);
    }
  }
  class C2 extends E2 {
    constructor(e21, t3) {
      e21 instanceof C2 ? (super(e21), this.internalState = Object.assign({}, e21.internalState)) : (super(e21, t3), this.internalState = this.state);
    }
    advance() {
      this.state = this.internalState, super.advance(), this.processEscapeSequence();
    }
    init() {
      super.init(), this.processEscapeSequence();
    }
    clone() {
      return new C2(this);
    }
    getChars(e21) {
      const t3 = e21.clone();
      let r2 = "";
      for (; t3.internalState.offset < this.internalState.offset; )
        r2 += String.fromCodePoint(t3.peek()), t3.advance();
      return r2;
    }
    processEscapeSequence() {
      const e21 = () => this.internalState.peek;
      if (e21() === n2.$BACKSLASH)
        if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), e21() === n2.$n)
          this.state.peek = n2.$LF;
        else if (e21() === n2.$r)
          this.state.peek = n2.$CR;
        else if (e21() === n2.$v)
          this.state.peek = n2.$VTAB;
        else if (e21() === n2.$t)
          this.state.peek = n2.$TAB;
        else if (e21() === n2.$b)
          this.state.peek = n2.$BSPACE;
        else if (e21() === n2.$f)
          this.state.peek = n2.$FF;
        else if (e21() === n2.$u)
          if (this.advanceState(this.internalState), e21() === n2.$LBRACE) {
            this.advanceState(this.internalState);
            const t3 = this.clone();
            let r2 = 0;
            for (; e21() !== n2.$RBRACE; )
              this.advanceState(this.internalState), r2++;
            this.state.peek = this.decodeHexDigits(t3, r2);
          } else {
            const e22 = this.clone();
            this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e22, 4);
          }
        else if (e21() === n2.$x) {
          this.advanceState(this.internalState);
          const e22 = this.clone();
          this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e22, 2);
        } else if (n2.isOctalDigit(e21())) {
          let t3 = "", r2 = 0, i3 = this.clone();
          for (; n2.isOctalDigit(e21()) && r2 < 3; )
            i3 = this.clone(), t3 += String.fromCodePoint(e21()), this.advanceState(this.internalState), r2++;
          this.state.peek = parseInt(t3, 8), this.internalState = i3.internalState;
        } else
          n2.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
    }
    decodeHexDigits(e21, t3) {
      const r2 = this.input.substr(e21.internalState.offset, t3), n3 = parseInt(r2, 16);
      if (isNaN(n3))
        throw e21.state = e21.internalState, new y2("Invalid hexadecimal escape sequence", e21);
      return n3;
    }
  }
  class y2 {
    constructor(e21, t3) {
      this.msg = e21, this.cursor = t3;
    }
  }
  t2.CursorError = y2;
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class no extends B$1.ParseError {
  constructor(e20, t2, r2) {
    super(t2, r2), this.elementName = e20;
  }
  static create(e20, t2, r2) {
    return new no(e20, t2, r2);
  }
}
var io = no;
class so {
  constructor(e20, t2) {
    this.rootNodes = e20, this.errors = t2;
  }
}
var oo = so;
var ao = class {
  constructor(e20) {
    this.getTagDefinition = e20;
  }
  parse(e20, t2, r2, n2 = false, i2) {
    const s2 = (e21) => (t3, ...r3) => e21(t3.toLowerCase(), ...r3), o2 = n2 ? this.getTagDefinition : s2(this.getTagDefinition), a2 = (e21) => o2(e21).contentType, u2 = n2 ? i2 : s2(i2), c2 = i2 ? (e21, t3, r3, n3) => {
      const i3 = u2(e21, t3, r3, n3);
      return i3 !== void 0 ? i3 : a2(e21);
    } : a2, l2 = ro.tokenize(e20, t2, c2, r2), p2 = r2 && r2.canSelfClose || false, h2 = r2 && r2.allowHtmComponentClosingTags || false, D2 = new uo(l2.tokens, o2, p2, h2, n2).build();
    return new so(D2.rootNodes, l2.errors.concat(D2.errors));
  }
};
class uo {
  constructor(e20, t2, r2, n2, i2) {
    this.tokens = e20, this.getTagDefinition = t2, this.canSelfClose = r2, this.allowHtmComponentClosingTags = n2, this.isTagNameCaseSensitive = i2, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
  }
  build() {
    for (; this._peek.type !== ro.TokenType.EOF; )
      this._peek.type === ro.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === ro.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === ro.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === ro.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === ro.TokenType.TEXT || this._peek.type === ro.TokenType.RAW_TEXT || this._peek.type === ro.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === ro.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === ro.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
    return new so(this._rootNodes, this._errors);
  }
  _advance() {
    const e20 = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e20;
  }
  _advanceIf(e20) {
    return this._peek.type === e20 ? this._advance() : null;
  }
  _consumeCdata(e20) {
    const t2 = this._advance(), r2 = this._getText(t2), n2 = this._advanceIf(ro.TokenType.CDATA_END);
    this._addToParent(new Qs.CDATA(r2, new B$1.ParseSourceSpan(e20.sourceSpan.start, (n2 || t2).sourceSpan.end)));
  }
  _consumeComment(e20) {
    const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.COMMENT_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, (r2 || t2 || e20).sourceSpan.end);
    this._addToParent(new Qs.Comment(n2, i2));
  }
  _consumeDocType(e20) {
    const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.DOC_TYPE_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, (r2 || t2 || e20).sourceSpan.end);
    this._addToParent(new Qs.DocType(n2, i2));
  }
  _consumeExpansion(e20) {
    const t2 = this._advance(), r2 = this._advance(), n2 = [];
    for (; this._peek.type === ro.TokenType.EXPANSION_CASE_VALUE; ) {
      const e21 = this._parseExpansionCase();
      if (!e21)
        return;
      n2.push(e21);
    }
    if (this._peek.type !== ro.TokenType.EXPANSION_FORM_END)
      return void this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
    const i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, this._peek.sourceSpan.end);
    this._addToParent(new Qs.Expansion(t2.parts[0], r2.parts[0], n2, i2, t2.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    const e20 = this._advance();
    if (this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START)
      return this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    const t2 = this._advance(), r2 = this._collectExpansionExpTokens(t2);
    if (!r2)
      return null;
    const n2 = this._advance();
    r2.push(new ro.Token(ro.TokenType.EOF, [], n2.sourceSpan));
    const i2 = new uo(r2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
    if (i2.errors.length > 0)
      return this._errors = this._errors.concat(i2.errors), null;
    const s2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, n2.sourceSpan.end), o2 = new B$1.ParseSourceSpan(t2.sourceSpan.start, n2.sourceSpan.end);
    return new Qs.ExpansionCase(e20.parts[0], i2.rootNodes, s2, e20.sourceSpan, o2);
  }
  _collectExpansionExpTokens(e20) {
    const t2 = [], r2 = [ro.TokenType.EXPANSION_CASE_EXP_START];
    for (; ; ) {
      if (this._peek.type !== ro.TokenType.EXPANSION_FORM_START && this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START || r2.push(this._peek.type), this._peek.type === ro.TokenType.EXPANSION_CASE_EXP_END) {
        if (!co(r2, ro.TokenType.EXPANSION_CASE_EXP_START))
          return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (r2.pop(), r2.length == 0)
          return t2;
      }
      if (this._peek.type === ro.TokenType.EXPANSION_FORM_END) {
        if (!co(r2, ro.TokenType.EXPANSION_FORM_START))
          return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        r2.pop();
      }
      if (this._peek.type === ro.TokenType.EOF)
        return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      t2.push(this._advance());
    }
  }
  _getText(e20) {
    let t2 = e20.parts[0];
    if (t2.length > 0 && t2[0] == "\n") {
      const e21 = this._getParentElement();
      e21 != null && e21.children.length == 0 && this.getTagDefinition(e21.name).ignoreFirstLf && (t2 = t2.substring(1));
    }
    return t2;
  }
  _consumeText(e20) {
    const t2 = this._getText(e20);
    t2.length > 0 && this._addToParent(new Qs.Text(t2, e20.sourceSpan));
  }
  _closeVoidElement() {
    const e20 = this._getParentElement();
    e20 && this.getTagDefinition(e20.name).isVoid && this._elementStack.pop();
  }
  _consumeStartTag(e20) {
    const t2 = e20.parts[0], r2 = e20.parts[1], n2 = [];
    for (; this._peek.type === ro.TokenType.ATTR_NAME; )
      n2.push(this._consumeAttr(this._advance()));
    const i2 = this._getElementFullName(t2, r2, this._getParentElement());
    let s2 = false;
    if (this._peek.type === ro.TokenType.TAG_OPEN_END_VOID) {
      this._advance(), s2 = true;
      const t3 = this.getTagDefinition(i2);
      this.canSelfClose || t3.canSelfClose || As.getNsPrefix(i2) !== null || t3.isVoid || this._errors.push(no.create(i2, e20.sourceSpan, `Only void and foreign elements can be self closed "${e20.parts[1]}"`));
    } else
      this._peek.type === ro.TokenType.TAG_OPEN_END && (this._advance(), s2 = false);
    const o2 = this._peek.sourceSpan.start, a2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, o2), u2 = new B$1.ParseSourceSpan(e20.sourceSpan.start.moveBy(1), e20.sourceSpan.end), c2 = new Qs.Element(i2, n2, [], a2, a2, void 0, u2);
    this._pushElement(c2), s2 && (this._popElement(i2), c2.endSourceSpan = a2);
  }
  _pushElement(e20) {
    const t2 = this._getParentElement();
    t2 && this.getTagDefinition(t2.name).isClosedByChild(e20.name) && this._elementStack.pop(), this._addToParent(e20), this._elementStack.push(e20);
  }
  _consumeEndTag(e20) {
    const t2 = this.allowHtmComponentClosingTags && e20.parts.length === 0 ? null : this._getElementFullName(e20.parts[0], e20.parts[1], this._getParentElement());
    if (this._getParentElement() && (this._getParentElement().endSourceSpan = e20.sourceSpan), t2 && this.getTagDefinition(t2).isVoid)
      this._errors.push(no.create(t2, e20.sourceSpan, `Void elements do not have end tags "${e20.parts[1]}"`));
    else if (!this._popElement(t2)) {
      const r2 = `Unexpected closing tag "${t2}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this._errors.push(no.create(t2, e20.sourceSpan, r2));
    }
  }
  _popElement(e20) {
    for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
      const r2 = this._elementStack[t2];
      if (!e20 || (As.getNsPrefix(r2.name) ? r2.name == e20 : r2.name.toLowerCase() == e20.toLowerCase()))
        return this._elementStack.splice(t2, this._elementStack.length - t2), true;
      if (!this.getTagDefinition(r2.name).closedByParent)
        return false;
    }
    return false;
  }
  _consumeAttr(e20) {
    const t2 = As.mergeNsAndName(e20.parts[0], e20.parts[1]);
    let r2, n2, i2 = e20.sourceSpan.end, s2 = "";
    if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
      n2 = this._advance().sourceSpan.start;
    }
    if (this._peek.type === ro.TokenType.ATTR_VALUE) {
      const e21 = this._advance();
      s2 = e21.parts[0], i2 = e21.sourceSpan.end, r2 = e21.sourceSpan;
    }
    if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
      i2 = this._advance().sourceSpan.end, r2 = new B$1.ParseSourceSpan(n2, i2);
    }
    return new Qs.Attribute(t2, s2, new B$1.ParseSourceSpan(e20.sourceSpan.start, i2), r2, e20.sourceSpan);
  }
  _getParentElement() {
    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
  }
  _getParentElementSkippingContainers() {
    let e20 = null;
    for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
      if (!As.isNgContainer(this._elementStack[t2].name))
        return {parent: this._elementStack[t2], container: e20};
      e20 = this._elementStack[t2];
    }
    return {parent: null, container: e20};
  }
  _addToParent(e20) {
    const t2 = this._getParentElement();
    t2 != null ? t2.children.push(e20) : this._rootNodes.push(e20);
  }
  _insertBeforeContainer(e20, t2, r2) {
    if (t2) {
      if (e20) {
        const n2 = e20.children.indexOf(t2);
        e20.children[n2] = r2;
      } else
        this._rootNodes.push(r2);
      r2.children.push(t2), this._elementStack.splice(this._elementStack.indexOf(t2), 0, r2);
    } else
      this._addToParent(r2), this._elementStack.push(r2);
  }
  _getElementFullName(e20, t2, r2) {
    return e20 === "" && (e20 = this.getTagDefinition(t2).implicitNamespacePrefix || "") === "" && r2 != null && (e20 = As.getNsPrefix(r2.name)), As.mergeNsAndName(e20, t2);
  }
}
function co(e20, t2) {
  return e20.length > 0 && e20[e20.length - 1] === t2;
}
var lo = Object.defineProperty({TreeError: io, ParseTreeResult: oo, Parser: ao}, "__esModule", {value: true}), po = lo, ho = po.ParseTreeResult, Do = po.TreeError;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class fo extends lo.Parser {
  constructor() {
    super(xs.getHtmlTagDefinition);
  }
  parse(e20, t2, r2, n2 = false, i2) {
    return super.parse(e20, t2, r2, n2, i2);
  }
}
var go = fo, mo = Object.defineProperty({ParseTreeResult: ho, TreeError: Do, HtmlParser: go}, "__esModule", {value: true}), Eo = As.TagContentType;
let Co = null;
var yo = function(e20, t2 = {}) {
  const {canSelfClose: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: i2 = false, getTagContentType: s2} = t2;
  return (Co || (Co = new mo.HtmlParser()), Co).parse(e20, "angular-html-parser", {tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: r2, allowHtmComponentClosingTags: n2}, i2, s2);
}, bo = Object.defineProperty({TagContentType: Eo, parse: yo}, "__esModule", {value: true});
const {ParseSourceSpan: So, ParseLocation: To, ParseSourceFile: _o} = B$1, {inferParserByLanguage: vo} = $n, {HTML_ELEMENT_ATTRIBUTES: Ao, HTML_TAGS: Fo, isUnknownNamespace: wo} = fs, {hasPragma: ko} = ds, {Node: No} = bs, {parseIeConditionalComment: Oo} = _s, {locStart: xo, locEnd: Io} = vs;
function Po(e20, {recognizeSelfClosing: t2, normalizeTagName: r2, normalizeAttributeName: n2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2, getTagContentType: o2}, a2) {
  const u2 = bo, {RecursiveVisitor: c2, visitAll: l2} = Qs, {ParseSourceSpan: p2} = B$1, {getHtmlTagDefinition: h2} = xs;
  let {rootNodes: D2, errors: f2} = u2.parse(e20, {canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2, getTagContentType: o2});
  if (a2.parser === "vue") {
    if (D2.some((e21) => e21.type === "docType" && e21.value === "html" || e21.type === "element" && e21.name.toLowerCase() === "html")) {
      t2 = true, r2 = true, n2 = true, i2 = true, s2 = false;
      const o3 = u2.parse(e20, {canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2});
      D2 = o3.rootNodes, f2 = o3.errors;
    } else {
      const r3 = (e21) => {
        if (!e21)
          return false;
        if (e21.type !== "element" || e21.name !== "template")
          return false;
        const t3 = e21.attrs.find((e22) => e22.name === "lang"), r4 = t3 && t3.value;
        return !r4 || vo(r4, a2) === "html";
      };
      if (D2.some(r3)) {
        let n3;
        const o3 = () => u2.parse(e20, {canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2}), a3 = () => n3 || (n3 = o3()), c3 = (e21) => a3().rootNodes.find(({startSourceSpan: t3}) => t3 && t3.start.offset === e21.startSourceSpan.start.offset);
        for (let e21 = 0; e21 < D2.length; e21++) {
          const t3 = D2[e21], {endSourceSpan: n4, startSourceSpan: i3} = t3;
          if (n4 === null) {
            f2 = a3().errors, D2[e21] = c3(t3) || t3;
          } else if (r3(t3)) {
            const r4 = a3(), s3 = i3.end.offset, o4 = n4.start.offset;
            for (const e22 of r4.errors) {
              const {offset: t4} = e22.span.start;
              if (s3 < t4 && t4 < o4) {
                f2 = [e22];
                break;
              }
            }
            D2[e21] = c3(t3) || t3;
          }
        }
      }
    }
  }
  if (f2.length > 0) {
    const {msg: e21, span: {start: t3, end: r3}} = f2[0];
    throw j$1(e21, {start: {line: t3.line + 1, column: t3.col + 1}, end: {line: r3.line + 1, column: r3.col + 1}});
  }
  const d2 = (e21) => {
    const t3 = e21.name.startsWith(":") ? e21.name.slice(1).split(":")[0] : null, r3 = e21.nameSpan.toString(), n3 = t3 !== null && r3.startsWith(`${t3}:`), i3 = n3 ? r3.slice(t3.length + 1) : r3;
    e21.name = i3, e21.namespace = t3, e21.hasExplicitNamespace = n3;
  }, g2 = (e21, t3) => {
    const r3 = e21.toLowerCase();
    return t3(r3) ? r3 : e21;
  };
  return l2(new class extends c2 {
    visit(e21) {
      ((e22) => {
        if (e22.type === "element") {
          d2(e22);
          for (const t3 of e22.attrs)
            d2(t3), t3.valueSpan ? (t3.value = t3.valueSpan.toString(), /["']/.test(t3.value[0]) && (t3.value = t3.value.slice(1, -1))) : t3.value = null;
        } else
          e22.type === "comment" ? e22.value = e22.sourceSpan.toString().slice("<!--".length, -"-->".length) : e22.type === "text" && (e22.value = e22.sourceSpan.toString());
      })(e21), ((e22) => {
        if (e22.type === "element") {
          const t3 = h2(s2 ? e22.name : e22.name.toLowerCase());
          !e22.namespace || e22.namespace === t3.implicitNamespacePrefix || wo(e22) ? e22.tagDefinition = t3 : e22.tagDefinition = h2("");
        }
      })(e21), ((e22) => {
        if (e22.type === "element" && (!r2 || e22.namespace && e22.namespace !== e22.tagDefinition.implicitNamespacePrefix && !wo(e22) || (e22.name = g2(e22.name, (e23) => e23 in Fo)), n2)) {
          const t3 = Ao[e22.name] || Object.create(null);
          for (const r3 of e22.attrs)
            r3.namespace || (r3.name = g2(r3.name, (r4) => e22.name in Ao && (r4 in Ao["*"] || r4 in t3)));
        }
      })(e21), ((e22) => {
        e22.sourceSpan && e22.endSourceSpan && (e22.sourceSpan = new p2(e22.sourceSpan.start, e22.endSourceSpan.end));
      })(e21);
    }
  }(), D2), D2;
}
function Ro(e20, t2, r2, n2 = true) {
  const {frontMatter: i2, content: s2} = n2 ? q$1(e20) : {frontMatter: null, content: e20}, o2 = new _o(e20, t2.filepath), a2 = new To(o2, 0, 0, 0), u2 = a2.moveBy(e20.length), c2 = {type: "root", sourceSpan: new So(a2, u2), children: Po(s2, r2, t2)};
  if (i2) {
    const e21 = new To(o2, 0, 0, 0), t3 = e21.moveBy(i2.raw.length);
    i2.sourceSpan = new So(e21, t3), c2.children.unshift(i2);
  }
  const l2 = new No(c2), p2 = (n3, i3) => {
    const {offset: s3} = i3, o3 = Ro(e20.slice(0, s3).replace(/[^\n\r]/g, " ") + n3, t2, r2, false);
    o3.sourceSpan = new So(i3, M$1(o3.children).sourceSpan.end);
    const a3 = o3.children[0];
    return a3.length === s3 ? o3.children.shift() : (a3.sourceSpan = new So(a3.sourceSpan.start.moveBy(s3), a3.sourceSpan.end), a3.value = a3.value.slice(s3)), o3;
  };
  return l2.map((e21) => {
    if (e21.type === "comment") {
      const t3 = Oo(e21, p2);
      if (t3)
        return t3;
    }
    return e21;
  });
}
function Lo({recognizeSelfClosing: e20 = false, normalizeTagName: t2 = false, normalizeAttributeName: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: i2 = false, getTagContentType: s2} = {}) {
  return {parse: (o2, a2, u2) => Ro(o2, u2, {recognizeSelfClosing: e20, normalizeTagName: t2, normalizeAttributeName: r2, allowHtmComponentClosingTags: n2, isTagNameCaseSensitive: i2, getTagContentType: s2}), hasPragma: ko, astFormat: "html", locStart: xo, locEnd: Io};
}
var Bo = {parsers: {html: Lo({recognizeSelfClosing: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true}), angular: Lo(), vue: Lo({recognizeSelfClosing: true, isTagNameCaseSensitive: true, getTagContentType: (e20, t2, r2, n2) => {
  if (e20.toLowerCase() !== "html" && !r2 && (e20 !== "template" || n2.some(({name: e21, value: t3}) => e21 === "lang" && t3 !== "html")))
    return bo.TagContentType.RAW_TEXT;
}}), lwc: Lo()}};
var e19 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function t(e20) {
  return e20 && e20.__esModule && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
}
function r(e20) {
  var t2 = {exports: {}};
  return e20(t2, t2.exports), t2.exports;
}
var n, o, i = function(e20) {
  return e20 && e20.Math == Math && e20;
}, s = i(typeof globalThis == "object" && globalThis) || i(typeof window == "object" && window) || i(typeof self == "object" && self) || i(typeof e19 == "object" && e19) || function() {
  return this;
}() || Function("return this")(), u = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, a = !u(function() {
  return Object.defineProperty({}, 1, {get: function() {
    return 7;
  }})[1] != 7;
}), c = {}.propertyIsEnumerable, l = Object.getOwnPropertyDescriptor, f = {f: l && !c.call({1: 2}, 1) ? function(e20) {
  var t2 = l(this, e20);
  return !!t2 && t2.enumerable;
} : c}, p = function(e20, t2) {
  return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
}, h = {}.toString, d = function(e20) {
  return h.call(e20).slice(8, -1);
}, D = "".split, g = u(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return d(e20) == "String" ? D.call(e20, "") : Object(e20);
} : Object, m = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, v = function(e20) {
  return g(m(e20));
}, y = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, w = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, b = function(e20, t2) {
  return arguments.length < 2 ? w(s[e20]) : s[e20] && s[e20][t2];
}, C = b("navigator", "userAgent") || "", E = s.process, F = s.Deno, x = E && E.versions || F && F.version, A = x && x.v8;
A ? o = (n = A.split("."))[0] < 4 ? 1 : n[0] + n[1] : C && (!(n = C.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = C.match(/Chrome\/(\d+)/)) && (o = n[1]);
var k = o && +o, O = !!Object.getOwnPropertySymbols && !u(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && k && k < 41;
}), _ = O && !Symbol.sham && typeof Symbol.iterator == "symbol", S = _ ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = b("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, T = function(e20, t2) {
  try {
    Object.defineProperty(s, e20, {value: t2, configurable: true, writable: true});
  } catch (r2) {
    s[e20] = t2;
  }
  return t2;
}, I = s["__core-js_shared__"] || T("__core-js_shared__", {}), N = r(function(e20) {
  (e20.exports = function(e21, t2) {
    return I[e21] || (I[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
}), M = function(e20) {
  return Object(m(e20));
}, R = {}.hasOwnProperty, j = Object.hasOwn || function(e20, t2) {
  return R.call(M(e20), t2);
}, L = 0, B = Math.random(), P = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++L + B).toString(36);
}, $ = N("wks"), U = s.Symbol, G = _ ? U : U && U.withoutSetter || P, W = function(e20) {
  return j($, e20) && (O || typeof $[e20] == "string") || (O && j(U, e20) ? $[e20] = U[e20] : $[e20] = G("Symbol." + e20)), $[e20];
}, z = W("toPrimitive"), V = function(e20, t2) {
  if (!y(e20) || S(e20))
    return e20;
  var r2, n2 = e20[z];
  if (n2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e20, t2), !y(r2) || S(r2))
      return r2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var r3, n3;
    if (t3 === "string" && typeof (r3 = e21.toString) == "function" && !y(n3 = r3.call(e21)))
      return n3;
    if (typeof (r3 = e21.valueOf) == "function" && !y(n3 = r3.call(e21)))
      return n3;
    if (t3 !== "string" && typeof (r3 = e21.toString) == "function" && !y(n3 = r3.call(e21)))
      return n3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, q = function(e20) {
  var t2 = V(e20, "string");
  return S(t2) ? t2 : String(t2);
}, X = s.document, J = y(X) && y(X.createElement), H = !a && !u(function() {
  return Object.defineProperty((e20 = "div", J ? X.createElement(e20) : {}), "a", {get: function() {
    return 7;
  }}).a != 7;
  var e20;
}), Y = Object.getOwnPropertyDescriptor, K = {f: a ? Y : function(e20, t2) {
  if (e20 = v(e20), t2 = q(t2), H)
    try {
      return Y(e20, t2);
    } catch (e21) {
    }
  if (j(e20, t2))
    return p(!f.f.call(e20, t2), e20[t2]);
}}, Z = function(e20) {
  if (!y(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, Q = Object.defineProperty, ee = {f: a ? Q : function(e20, t2, r2) {
  if (Z(e20), t2 = q(t2), Z(r2), H)
    try {
      return Q(e20, t2, r2);
    } catch (e21) {
    }
  if ("get" in r2 || "set" in r2)
    throw TypeError("Accessors not supported");
  return "value" in r2 && (e20[t2] = r2.value), e20;
}}, te = a ? function(e20, t2, r2) {
  return ee.f(e20, t2, p(1, r2));
} : function(e20, t2, r2) {
  return e20[t2] = r2, e20;
}, re = Function.toString;
typeof I.inspectSource != "function" && (I.inspectSource = function(e20) {
  return re.call(e20);
});
var ne, oe, ie, se, ue = I.inspectSource, ae = s.WeakMap, ce = typeof ae == "function" && /native code/.test(ue(ae)), le = N("keys"), fe = {}, pe = s.WeakMap;
if (ce || I.state) {
  var he = I.state || (I.state = new pe()), de = he.get, De = he.has, ge = he.set;
  ne = function(e20, t2) {
    if (De.call(he, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, ge.call(he, e20, t2), t2;
  }, oe = function(e20) {
    return de.call(he, e20) || {};
  }, ie = function(e20) {
    return De.call(he, e20);
  };
} else {
  var me = le[se = "state"] || (le[se] = P(se));
  fe[me] = true, ne = function(e20, t2) {
    if (j(e20, me))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, te(e20, me, t2), t2;
  }, oe = function(e20) {
    return j(e20, me) ? e20[me] : {};
  }, ie = function(e20) {
    return j(e20, me);
  };
}
var ve, ye, we = {set: ne, get: oe, has: ie, enforce: function(e20) {
  return ie(e20) ? oe(e20) : ne(e20, {});
}, getterFor: function(e20) {
  return function(t2) {
    var r2;
    if (!y(t2) || (r2 = oe(t2)).type !== e20)
      throw TypeError("Incompatible receiver, " + e20 + " required");
    return r2;
  };
}}, be = r(function(e20) {
  var t2 = we.get, r2 = we.enforce, n2 = String(String).split("String");
  (e20.exports = function(e21, t3, o2, i2) {
    var u2, a2 = !!i2 && !!i2.unsafe, c2 = !!i2 && !!i2.enumerable, l2 = !!i2 && !!i2.noTargetGet;
    typeof o2 == "function" && (typeof t3 != "string" || j(o2, "name") || te(o2, "name", t3), (u2 = r2(o2)).source || (u2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e21 !== s ? (a2 ? !l2 && e21[t3] && (c2 = true) : delete e21[t3], c2 ? e21[t3] = o2 : te(e21, t3, o2)) : c2 ? e21[t3] = o2 : T(t3, o2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || ue(this);
  });
}), Ce = Math.ceil, Ee = Math.floor, Fe = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? Ee : Ce)(e20);
}, xe = Math.min, Ae = function(e20) {
  return e20 > 0 ? xe(Fe(e20), 9007199254740991) : 0;
}, ke = Math.max, Oe = Math.min, _e = function(e20) {
  return function(t2, r2, n2) {
    var o2, i2 = v(t2), s2 = Ae(i2.length), u2 = function(e21, t3) {
      var r3 = Fe(e21);
      return r3 < 0 ? ke(r3 + t3, 0) : Oe(r3, t3);
    }(n2, s2);
    if (e20 && r2 != r2) {
      for (; s2 > u2; )
        if ((o2 = i2[u2++]) != o2)
          return true;
    } else
      for (; s2 > u2; u2++)
        if ((e20 || u2 in i2) && i2[u2] === r2)
          return e20 || u2 || 0;
    return !e20 && -1;
  };
}, Se = {includes: _e(true), indexOf: _e(false)}.indexOf, Te = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ie = {f: Object.getOwnPropertyNames || function(e20) {
  return function(e21, t2) {
    var r2, n2 = v(e21), o2 = 0, i2 = [];
    for (r2 in n2)
      !j(fe, r2) && j(n2, r2) && i2.push(r2);
    for (; t2.length > o2; )
      j(n2, r2 = t2[o2++]) && (~Se(i2, r2) || i2.push(r2));
    return i2;
  }(e20, Te);
}}, Ne = {f: Object.getOwnPropertySymbols}, Me = b("Reflect", "ownKeys") || function(e20) {
  var t2 = Ie.f(Z(e20)), r2 = Ne.f;
  return r2 ? t2.concat(r2(e20)) : t2;
}, Re = function(e20, t2) {
  for (var r2 = Me(t2), n2 = ee.f, o2 = K.f, i2 = 0; i2 < r2.length; i2++) {
    var s2 = r2[i2];
    j(e20, s2) || n2(e20, s2, o2(t2, s2));
  }
}, je = /#|\.prototype\./, Le = function(e20, t2) {
  var r2 = Pe[Be(e20)];
  return r2 == Ue || r2 != $e && (typeof t2 == "function" ? u(t2) : !!t2);
}, Be = Le.normalize = function(e20) {
  return String(e20).replace(je, ".").toLowerCase();
}, Pe = Le.data = {}, $e = Le.NATIVE = "N", Ue = Le.POLYFILL = "P", Ge = Le, We = K.f, ze = function(e20, t2) {
  var r2, n2, o2, i2, u2, a2 = e20.target, c2 = e20.global, l2 = e20.stat;
  if (r2 = c2 ? s : l2 ? s[a2] || T(a2, {}) : (s[a2] || {}).prototype)
    for (n2 in t2) {
      if (i2 = t2[n2], o2 = e20.noTargetGet ? (u2 = We(r2, n2)) && u2.value : r2[n2], !Ge(c2 ? n2 : a2 + (l2 ? "." : "#") + n2, e20.forced) && o2 !== void 0) {
        if (typeof i2 == typeof o2)
          continue;
        Re(i2, o2);
      }
      (e20.sham || o2 && o2.sham) && te(i2, "sham", true), be(r2, n2, i2, e20);
    }
}, Ve = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, qe = function(e20) {
  if (S(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, Xe = Math.floor, Je = function(e20, t2) {
  var r2 = e20.length, n2 = Xe(r2 / 2);
  return r2 < 8 ? He(e20, t2) : Ye(Je(e20.slice(0, n2), t2), Je(e20.slice(n2), t2), t2);
}, He = function(e20, t2) {
  for (var r2, n2, o2 = e20.length, i2 = 1; i2 < o2; ) {
    for (n2 = i2, r2 = e20[i2]; n2 && t2(e20[n2 - 1], r2) > 0; )
      e20[n2] = e20[--n2];
    n2 !== i2++ && (e20[n2] = r2);
  }
  return e20;
}, Ye = function(e20, t2, r2) {
  for (var n2 = e20.length, o2 = t2.length, i2 = 0, s2 = 0, u2 = []; i2 < n2 || s2 < o2; )
    i2 < n2 && s2 < o2 ? u2.push(r2(e20[i2], t2[s2]) <= 0 ? e20[i2++] : t2[s2++]) : u2.push(i2 < n2 ? e20[i2++] : t2[s2++]);
  return u2;
}, Ke = Je, Ze = C.match(/firefox\/(\d+)/i), Qe = !!Ze && +Ze[1], et = /MSIE|Trident/.test(C), tt = C.match(/AppleWebKit\/(\d+)\./), rt = !!tt && +tt[1], nt = [], ot = nt.sort, it = u(function() {
  nt.sort(void 0);
}), st = u(function() {
  nt.sort(null);
}), ut = !!(ye = []["sort"]) && u(function() {
  ye.call(null, ve || function() {
    throw 1;
  }, 1);
}), at = !u(function() {
  if (k)
    return k < 70;
  if (!(Qe && Qe > 3)) {
    if (et)
      return true;
    if (rt)
      return rt < 603;
    var e20, t2, r2, n2, o2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          r2 = 3;
          break;
        case 68:
        case 71:
          r2 = 4;
          break;
        default:
          r2 = 2;
      }
      for (n2 = 0; n2 < 47; n2++)
        nt.push({k: t2 + n2, v: r2});
    }
    for (nt.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), n2 = 0; n2 < nt.length; n2++)
      t2 = nt[n2].k.charAt(0), o2.charAt(o2.length - 1) !== t2 && (o2 += t2);
    return o2 !== "DGBEFHACIJK";
  }
});
ze({target: "Array", proto: true, forced: it || !st || !ut || !at}, {sort: function(e20) {
  e20 !== void 0 && Ve(e20);
  var t2 = M(this);
  if (at)
    return e20 === void 0 ? ot.call(t2) : ot.call(t2, e20);
  var r2, n2, o2 = [], i2 = Ae(t2.length);
  for (n2 = 0; n2 < i2; n2++)
    n2 in t2 && o2.push(t2[n2]);
  for (r2 = (o2 = Ke(o2, function(e21) {
    return function(t3, r3) {
      return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, r3) || 0 : qe(t3) > qe(r3) ? 1 : -1;
    };
  }(e20))).length, n2 = 0; n2 < r2; )
    t2[n2] = o2[n2++];
  for (; n2 < i2; )
    delete t2[n2++];
  return t2;
}});
var ct = Array.isArray || function(e20) {
  return d(e20) == "Array";
}, lt = function(e20, t2, r2) {
  if (Ve(e20), t2 === void 0)
    return e20;
  switch (r2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(r3) {
        return e20.call(t2, r3);
      };
    case 2:
      return function(r3, n2) {
        return e20.call(t2, r3, n2);
      };
    case 3:
      return function(r3, n2, o2) {
        return e20.call(t2, r3, n2, o2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, ft = function(e20, t2, r2, n2, o2, i2, s2, u2) {
  for (var a2, c2 = o2, l2 = 0, f2 = !!s2 && lt(s2, u2, 3); l2 < n2; ) {
    if (l2 in r2) {
      if (a2 = f2 ? f2(r2[l2], l2, t2) : r2[l2], i2 > 0 && ct(a2))
        c2 = ft(e20, t2, a2, Ae(a2.length), c2, i2 - 1) - 1;
      else {
        if (c2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[c2] = a2;
      }
      c2++;
    }
    l2++;
  }
  return c2;
}, pt = ft, ht = W("species"), dt = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return ct(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !ct(t3.prototype) ? y(t3) && (t3 = t3[ht]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
ze({target: "Array", proto: true}, {flatMap: function(e20) {
  var t2, r2 = M(this), n2 = Ae(r2.length);
  return Ve(e20), (t2 = dt(r2, 0)).length = pt(t2, r2, r2, n2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
}});
var Dt = {}, gt = W("iterator"), mt = Array.prototype, vt = {};
vt[W("toStringTag")] = "z";
var yt = String(vt) === "[object z]", wt = W("toStringTag"), bt = d(function() {
  return arguments;
}()) == "Arguments", Ct = yt ? d : function(e20) {
  var t2, r2, n2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (r2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), wt)) == "string" ? r2 : bt ? d(t2) : (n2 = d(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
}, Et = W("iterator"), Ft = function(e20) {
  if (e20 != null)
    return e20[Et] || e20["@@iterator"] || Dt[Ct(e20)];
}, xt = function(e20, t2, r2) {
  var n2, o2;
  Z(e20);
  try {
    if ((n2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw r2;
      return r2;
    }
    n2 = n2.call(e20);
  } catch (e21) {
    o2 = true, n2 = e21;
  }
  if (t2 === "throw")
    throw r2;
  if (o2)
    throw n2;
  return Z(n2), r2;
}, At = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, kt = function(e20, t2, r2) {
  var n2, o2, i2, s2, u2, a2, c2, l2, f2 = r2 && r2.that, p2 = !(!r2 || !r2.AS_ENTRIES), h2 = !(!r2 || !r2.IS_ITERATOR), d2 = !(!r2 || !r2.INTERRUPTED), D2 = lt(t2, f2, 1 + p2 + d2), g2 = function(e21) {
    return n2 && xt(n2, "normal", e21), new At(true, e21);
  }, m2 = function(e21) {
    return p2 ? (Z(e21), d2 ? D2(e21[0], e21[1], g2) : D2(e21[0], e21[1])) : d2 ? D2(e21, g2) : D2(e21);
  };
  if (h2)
    n2 = e20;
  else {
    if (typeof (o2 = Ft(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((l2 = o2) !== void 0 && (Dt.Array === l2 || mt[gt] === l2)) {
      for (i2 = 0, s2 = Ae(e20.length); s2 > i2; i2++)
        if ((u2 = m2(e20[i2])) && u2 instanceof At)
          return u2;
      return new At(false);
    }
    n2 = function(e21, t3) {
      var r3 = arguments.length < 2 ? Ft(e21) : t3;
      if (typeof r3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return Z(r3.call(e21));
    }(e20, o2);
  }
  for (a2 = n2.next; !(c2 = a2.call(n2)).done; ) {
    try {
      u2 = m2(c2.value);
    } catch (e21) {
      xt(n2, "throw", e21);
    }
    if (typeof u2 == "object" && u2 && u2 instanceof At)
      return u2;
  }
  return new At(false);
};
ze({target: "Object", stat: true}, {fromEntries: function(e20) {
  var t2 = {};
  return kt(e20, function(e21, r2) {
    !function(e22, t3, r3) {
      var n2 = q(t3);
      n2 in e22 ? ee.f(e22, n2, p(0, r3)) : e22[n2] = r3;
    }(t2, e21, r2);
  }, {AS_ENTRIES: true}), t2;
}});
var Ot = t(r(function(e20, t2) {
  new Function("return this")(), e20.exports = (() => {
    var e21 = {2426: (e22) => {
      e22.exports = ({onlyFirst: e23 = false} = {}) => {
        const t4 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(t4, e23 ? void 0 : "g");
      };
    }, 118: (e22) => {
      e22.exports = function(e23) {
        if (typeof e23 != "function")
          throw TypeError(String(e23) + " is not a function");
        return e23;
      };
    }, 6956: (e22, t4, r3) => {
      var n2 = r3(2521);
      e22.exports = function(e23) {
        if (!n2(e23))
          throw TypeError(String(e23) + " is not an object");
        return e23;
      };
    }, 9729: (e22, t4, r3) => {
      var n2 = r3(9969), o2 = r3(8331), i2 = r3(1588), s2 = function(e23) {
        return function(t5, r4, s3) {
          var u2, a2 = n2(t5), c2 = o2(a2.length), l2 = i2(s3, c2);
          if (e23 && r4 != r4) {
            for (; c2 > l2; )
              if ((u2 = a2[l2++]) != u2)
                return true;
          } else
            for (; c2 > l2; l2++)
              if ((e23 || l2 in a2) && a2[l2] === r4)
                return e23 || l2 || 0;
          return !e23 && -1;
        };
      };
      e22.exports = {includes: s2(true), indexOf: s2(false)};
    }, 9719: (e22, t4, r3) => {
      var n2 = r3(2763);
      e22.exports = function(e23, t5) {
        var r4 = [][e23];
        return !!r4 && n2(function() {
          r4.call(null, t5 || function() {
            throw 1;
          }, 1);
        });
      };
    }, 3407: (e22) => {
      var t4 = Math.floor, r3 = function(e23, i2) {
        var s2 = e23.length, u2 = t4(s2 / 2);
        return s2 < 8 ? n2(e23, i2) : o2(r3(e23.slice(0, u2), i2), r3(e23.slice(u2), i2), i2);
      }, n2 = function(e23, t5) {
        for (var r4, n3, o3 = e23.length, i2 = 1; i2 < o3; ) {
          for (n3 = i2, r4 = e23[i2]; n3 && t5(e23[n3 - 1], r4) > 0; )
            e23[n3] = e23[--n3];
          n3 !== i2++ && (e23[n3] = r4);
        }
        return e23;
      }, o2 = function(e23, t5, r4) {
        for (var n3 = e23.length, o3 = t5.length, i2 = 0, s2 = 0, u2 = []; i2 < n3 || s2 < o3; )
          i2 < n3 && s2 < o3 ? u2.push(r4(e23[i2], t5[s2]) <= 0 ? e23[i2++] : t5[s2++]) : u2.push(i2 < n3 ? e23[i2++] : t5[s2++]);
        return u2;
      };
      e22.exports = r3;
    }, 2021: (e22, t4, r3) => {
      var n2 = r3(2521), o2 = r3(3964), i2 = r3(1386)("species");
      e22.exports = function(e23) {
        var t5;
        return o2(e23) && (typeof (t5 = e23.constructor) != "function" || t5 !== Array && !o2(t5.prototype) ? n2(t5) && (t5 = t5[i2]) === null && (t5 = void 0) : t5 = void 0), t5 === void 0 ? Array : t5;
      };
    }, 8347: (e22, t4, r3) => {
      var n2 = r3(2021);
      e22.exports = function(e23, t5) {
        return new (n2(e23))(t5 === 0 ? 0 : t5);
      };
    }, 2849: (e22) => {
      var t4 = {}.toString;
      e22.exports = function(e23) {
        return t4.call(e23).slice(8, -1);
      };
    }, 9538: (e22, t4, r3) => {
      var n2 = r3(6395), o2 = r3(2849), i2 = r3(1386)("toStringTag"), s2 = o2(function() {
        return arguments;
      }()) == "Arguments";
      e22.exports = n2 ? o2 : function(e23) {
        var t5, r4, n3;
        return e23 === void 0 ? "Undefined" : e23 === null ? "Null" : typeof (r4 = function(e24, t6) {
          try {
            return e24[t6];
          } catch (e25) {
          }
        }(t5 = Object(e23), i2)) == "string" ? r4 : s2 ? o2(t5) : (n3 = o2(t5)) == "Object" && typeof t5.callee == "function" ? "Arguments" : n3;
      };
    }, 4488: (e22, t4, r3) => {
      var n2 = r3(2766), o2 = r3(9593), i2 = r3(8769), s2 = r3(7455);
      e22.exports = function(e23, t5) {
        for (var r4 = o2(t5), u2 = s2.f, a2 = i2.f, c2 = 0; c2 < r4.length; c2++) {
          var l2 = r4[c2];
          n2(e23, l2) || u2(e23, l2, a2(t5, l2));
        }
      };
    }, 1471: (e22, t4, r3) => {
      var n2 = r3(7703), o2 = r3(7455), i2 = r3(5938);
      e22.exports = n2 ? function(e23, t5, r4) {
        return o2.f(e23, t5, i2(1, r4));
      } : function(e23, t5, r4) {
        return e23[t5] = r4, e23;
      };
    }, 5938: (e22) => {
      e22.exports = function(e23, t4) {
        return {enumerable: !(1 & e23), configurable: !(2 & e23), writable: !(4 & e23), value: t4};
      };
    }, 2385: (e22, t4, r3) => {
      var n2 = r3(5224), o2 = r3(7455), i2 = r3(5938);
      e22.exports = function(e23, t5, r4) {
        var s2 = n2(t5);
        s2 in e23 ? o2.f(e23, s2, i2(0, r4)) : e23[s2] = r4;
      };
    }, 7703: (e22, t4, r3) => {
      var n2 = r3(2763);
      e22.exports = !n2(function() {
        return Object.defineProperty({}, 1, {get: function() {
          return 7;
        }})[1] != 7;
      });
    }, 6004: (e22, t4, r3) => {
      var n2 = r3(6121), o2 = r3(2521), i2 = n2.document, s2 = o2(i2) && o2(i2.createElement);
      e22.exports = function(e23) {
        return s2 ? i2.createElement(e23) : {};
      };
    }, 5249: (e22, t4, r3) => {
      var n2 = r3(8635).match(/firefox\/(\d+)/i);
      e22.exports = !!n2 && +n2[1];
    }, 2049: (e22, t4, r3) => {
      var n2 = r3(8635);
      e22.exports = /MSIE|Trident/.test(n2);
    }, 8635: (e22, t4, r3) => {
      var n2 = r3(7642);
      e22.exports = n2("navigator", "userAgent") || "";
    }, 6962: (e22, t4, r3) => {
      var n2, o2, i2 = r3(6121), s2 = r3(8635), u2 = i2.process, a2 = i2.Deno, c2 = u2 && u2.versions || a2 && a2.version, l2 = c2 && c2.v8;
      l2 ? o2 = (n2 = l2.split("."))[0] < 4 ? 1 : n2[0] + n2[1] : s2 && (!(n2 = s2.match(/Edge\/(\d+)/)) || n2[1] >= 74) && (n2 = s2.match(/Chrome\/(\d+)/)) && (o2 = n2[1]), e22.exports = o2 && +o2;
    }, 8998: (e22, t4, r3) => {
      var n2 = r3(8635).match(/AppleWebKit\/(\d+)\./);
      e22.exports = !!n2 && +n2[1];
    }, 4731: (e22) => {
      e22.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    }, 7309: (e22, t4, r3) => {
      var n2 = r3(6121), o2 = r3(8769).f, i2 = r3(1471), s2 = r3(2327), u2 = r3(6565), a2 = r3(4488), c2 = r3(676);
      e22.exports = function(e23, t5) {
        var r4, l2, f2, p2, h2, d2 = e23.target, D2 = e23.global, g2 = e23.stat;
        if (r4 = D2 ? n2 : g2 ? n2[d2] || u2(d2, {}) : (n2[d2] || {}).prototype)
          for (l2 in t5) {
            if (p2 = t5[l2], f2 = e23.noTargetGet ? (h2 = o2(r4, l2)) && h2.value : r4[l2], !c2(D2 ? l2 : d2 + (g2 ? "." : "#") + l2, e23.forced) && f2 !== void 0) {
              if (typeof p2 == typeof f2)
                continue;
              a2(p2, f2);
            }
            (e23.sham || f2 && f2.sham) && i2(p2, "sham", true), s2(r4, l2, p2, e23);
          }
      };
    }, 2763: (e22) => {
      e22.exports = function(e23) {
        try {
          return !!e23();
        } catch (e24) {
          return true;
        }
      };
    }, 5538: (e22, t4, r3) => {
      var n2 = r3(3964), o2 = r3(8331), i2 = r3(3322), s2 = function(e23, t5, r4, u2, a2, c2, l2, f2) {
        for (var p2, h2 = a2, d2 = 0, D2 = !!l2 && i2(l2, f2, 3); d2 < u2; ) {
          if (d2 in r4) {
            if (p2 = D2 ? D2(r4[d2], d2, t5) : r4[d2], c2 > 0 && n2(p2))
              h2 = s2(e23, t5, p2, o2(p2.length), h2, c2 - 1) - 1;
            else {
              if (h2 >= 9007199254740991)
                throw TypeError("Exceed the acceptable array length");
              e23[h2] = p2;
            }
            h2++;
          }
          d2++;
        }
        return h2;
      };
      e22.exports = s2;
    }, 3322: (e22, t4, r3) => {
      var n2 = r3(118);
      e22.exports = function(e23, t5, r4) {
        if (n2(e23), t5 === void 0)
          return e23;
        switch (r4) {
          case 0:
            return function() {
              return e23.call(t5);
            };
          case 1:
            return function(r5) {
              return e23.call(t5, r5);
            };
          case 2:
            return function(r5, n3) {
              return e23.call(t5, r5, n3);
            };
          case 3:
            return function(r5, n3, o2) {
              return e23.call(t5, r5, n3, o2);
            };
        }
        return function() {
          return e23.apply(t5, arguments);
        };
      };
    }, 7642: (e22, t4, r3) => {
      var n2 = r3(6121), o2 = function(e23) {
        return typeof e23 == "function" ? e23 : void 0;
      };
      e22.exports = function(e23, t5) {
        return arguments.length < 2 ? o2(n2[e23]) : n2[e23] && n2[e23][t5];
      };
    }, 5111: (e22, t4, r3) => {
      var n2 = r3(9538), o2 = r3(3403), i2 = r3(1386)("iterator");
      e22.exports = function(e23) {
        if (e23 != null)
          return e23[i2] || e23["@@iterator"] || o2[n2(e23)];
      };
    }, 8977: (e22, t4, r3) => {
      var n2 = r3(6956), o2 = r3(5111);
      e22.exports = function(e23, t5) {
        var r4 = arguments.length < 2 ? o2(e23) : t5;
        if (typeof r4 != "function")
          throw TypeError(String(e23) + " is not iterable");
        return n2(r4.call(e23));
      };
    }, 6121: (e22, t4, r3) => {
      var n2 = function(e23) {
        return e23 && e23.Math == Math && e23;
      };
      e22.exports = n2(typeof globalThis == "object" && globalThis) || n2(typeof window == "object" && window) || n2(typeof self == "object" && self) || n2(typeof r3.g == "object" && r3.g) || function() {
        return this;
      }() || Function("return this")();
    }, 2766: (e22, t4, r3) => {
      var n2 = r3(4766), o2 = {}.hasOwnProperty;
      e22.exports = Object.hasOwn || function(e23, t5) {
        return o2.call(n2(e23), t5);
      };
    }, 2048: (e22) => {
      e22.exports = {};
    }, 7226: (e22, t4, r3) => {
      var n2 = r3(7703), o2 = r3(2763), i2 = r3(6004);
      e22.exports = !n2 && !o2(function() {
        return Object.defineProperty(i2("div"), "a", {get: function() {
          return 7;
        }}).a != 7;
      });
    }, 3169: (e22, t4, r3) => {
      var n2 = r3(2763), o2 = r3(2849), i2 = "".split;
      e22.exports = n2(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(e23) {
        return o2(e23) == "String" ? i2.call(e23, "") : Object(e23);
      } : Object;
    }, 9835: (e22, t4, r3) => {
      var n2 = r3(4682), o2 = Function.toString;
      typeof n2.inspectSource != "function" && (n2.inspectSource = function(e23) {
        return o2.call(e23);
      }), e22.exports = n2.inspectSource;
    }, 2995: (e22, t4, r3) => {
      var n2, o2, i2, s2 = r3(5546), u2 = r3(6121), a2 = r3(2521), c2 = r3(1471), l2 = r3(2766), f2 = r3(4682), p2 = r3(2562), h2 = r3(2048), d2 = "Object already initialized", D2 = u2.WeakMap;
      if (s2 || f2.state) {
        var g2 = f2.state || (f2.state = new D2()), m2 = g2.get, v2 = g2.has, y2 = g2.set;
        n2 = function(e23, t5) {
          if (v2.call(g2, e23))
            throw new TypeError(d2);
          return t5.facade = e23, y2.call(g2, e23, t5), t5;
        }, o2 = function(e23) {
          return m2.call(g2, e23) || {};
        }, i2 = function(e23) {
          return v2.call(g2, e23);
        };
      } else {
        var w2 = p2("state");
        h2[w2] = true, n2 = function(e23, t5) {
          if (l2(e23, w2))
            throw new TypeError(d2);
          return t5.facade = e23, c2(e23, w2, t5), t5;
        }, o2 = function(e23) {
          return l2(e23, w2) ? e23[w2] : {};
        }, i2 = function(e23) {
          return l2(e23, w2);
        };
      }
      e22.exports = {set: n2, get: o2, has: i2, enforce: function(e23) {
        return i2(e23) ? o2(e23) : n2(e23, {});
      }, getterFor: function(e23) {
        return function(t5) {
          var r4;
          if (!a2(t5) || (r4 = o2(t5)).type !== e23)
            throw TypeError("Incompatible receiver, " + e23 + " required");
          return r4;
        };
      }};
    }, 9439: (e22, t4, r3) => {
      var n2 = r3(1386), o2 = r3(3403), i2 = n2("iterator"), s2 = Array.prototype;
      e22.exports = function(e23) {
        return e23 !== void 0 && (o2.Array === e23 || s2[i2] === e23);
      };
    }, 3964: (e22, t4, r3) => {
      var n2 = r3(2849);
      e22.exports = Array.isArray || function(e23) {
        return n2(e23) == "Array";
      };
    }, 676: (e22, t4, r3) => {
      var n2 = r3(2763), o2 = /#|\.prototype\./, i2 = function(e23, t5) {
        var r4 = u2[s2(e23)];
        return r4 == c2 || r4 != a2 && (typeof t5 == "function" ? n2(t5) : !!t5);
      }, s2 = i2.normalize = function(e23) {
        return String(e23).replace(o2, ".").toLowerCase();
      }, u2 = i2.data = {}, a2 = i2.NATIVE = "N", c2 = i2.POLYFILL = "P";
      e22.exports = i2;
    }, 2521: (e22) => {
      e22.exports = function(e23) {
        return typeof e23 == "object" ? e23 !== null : typeof e23 == "function";
      };
    }, 8451: (e22) => {
      e22.exports = false;
    }, 5057: (e22, t4, r3) => {
      var n2 = r3(7642), o2 = r3(2020);
      e22.exports = o2 ? function(e23) {
        return typeof e23 == "symbol";
      } : function(e23) {
        var t5 = n2("Symbol");
        return typeof t5 == "function" && Object(e23) instanceof t5;
      };
    }, 4572: (e22, t4, r3) => {
      var n2 = r3(6956), o2 = r3(9439), i2 = r3(8331), s2 = r3(3322), u2 = r3(8977), a2 = r3(5111), c2 = r3(4556), l2 = function(e23, t5) {
        this.stopped = e23, this.result = t5;
      };
      e22.exports = function(e23, t5, r4) {
        var f2, p2, h2, d2, D2, g2, m2, v2 = r4 && r4.that, y2 = !(!r4 || !r4.AS_ENTRIES), w2 = !(!r4 || !r4.IS_ITERATOR), b2 = !(!r4 || !r4.INTERRUPTED), C2 = s2(t5, v2, 1 + y2 + b2), E2 = function(e24) {
          return f2 && c2(f2, "normal", e24), new l2(true, e24);
        }, F2 = function(e24) {
          return y2 ? (n2(e24), b2 ? C2(e24[0], e24[1], E2) : C2(e24[0], e24[1])) : b2 ? C2(e24, E2) : C2(e24);
        };
        if (w2)
          f2 = e23;
        else {
          if (typeof (p2 = a2(e23)) != "function")
            throw TypeError("Target is not iterable");
          if (o2(p2)) {
            for (h2 = 0, d2 = i2(e23.length); d2 > h2; h2++)
              if ((D2 = F2(e23[h2])) && D2 instanceof l2)
                return D2;
            return new l2(false);
          }
          f2 = u2(e23, p2);
        }
        for (g2 = f2.next; !(m2 = g2.call(f2)).done; ) {
          try {
            D2 = F2(m2.value);
          } catch (e24) {
            c2(f2, "throw", e24);
          }
          if (typeof D2 == "object" && D2 && D2 instanceof l2)
            return D2;
        }
        return new l2(false);
      };
    }, 4556: (e22, t4, r3) => {
      var n2 = r3(6956);
      e22.exports = function(e23, t5, r4) {
        var o2, i2;
        n2(e23);
        try {
          if ((o2 = e23.return) === void 0) {
            if (t5 === "throw")
              throw r4;
            return r4;
          }
          o2 = o2.call(e23);
        } catch (e24) {
          i2 = true, o2 = e24;
        }
        if (t5 === "throw")
          throw r4;
        if (i2)
          throw o2;
        return n2(o2), r4;
      };
    }, 3403: (e22) => {
      e22.exports = {};
    }, 4020: (e22, t4, r3) => {
      var n2 = r3(6962), o2 = r3(2763);
      e22.exports = !!Object.getOwnPropertySymbols && !o2(function() {
        var e23 = Symbol();
        return !String(e23) || !(Object(e23) instanceof Symbol) || !Symbol.sham && n2 && n2 < 41;
      });
    }, 5546: (e22, t4, r3) => {
      var n2 = r3(6121), o2 = r3(9835), i2 = n2.WeakMap;
      e22.exports = typeof i2 == "function" && /native code/.test(o2(i2));
    }, 7455: (e22, t4, r3) => {
      var n2 = r3(7703), o2 = r3(7226), i2 = r3(6956), s2 = r3(5224), u2 = Object.defineProperty;
      t4.f = n2 ? u2 : function(e23, t5, r4) {
        if (i2(e23), t5 = s2(t5), i2(r4), o2)
          try {
            return u2(e23, t5, r4);
          } catch (e24) {
          }
        if ("get" in r4 || "set" in r4)
          throw TypeError("Accessors not supported");
        return "value" in r4 && (e23[t5] = r4.value), e23;
      };
    }, 8769: (e22, t4, r3) => {
      var n2 = r3(7703), o2 = r3(7751), i2 = r3(5938), s2 = r3(9969), u2 = r3(5224), a2 = r3(2766), c2 = r3(7226), l2 = Object.getOwnPropertyDescriptor;
      t4.f = n2 ? l2 : function(e23, t5) {
        if (e23 = s2(e23), t5 = u2(t5), c2)
          try {
            return l2(e23, t5);
          } catch (e24) {
          }
        if (a2(e23, t5))
          return i2(!o2.f.call(e23, t5), e23[t5]);
      };
    }, 2042: (e22, t4, r3) => {
      var n2 = r3(3224), o2 = r3(4731).concat("length", "prototype");
      t4.f = Object.getOwnPropertyNames || function(e23) {
        return n2(e23, o2);
      };
    }, 2719: (e22, t4) => {
      t4.f = Object.getOwnPropertySymbols;
    }, 3224: (e22, t4, r3) => {
      var n2 = r3(2766), o2 = r3(9969), i2 = r3(9729).indexOf, s2 = r3(2048);
      e22.exports = function(e23, t5) {
        var r4, u2 = o2(e23), a2 = 0, c2 = [];
        for (r4 in u2)
          !n2(s2, r4) && n2(u2, r4) && c2.push(r4);
        for (; t5.length > a2; )
          n2(u2, r4 = t5[a2++]) && (~i2(c2, r4) || c2.push(r4));
        return c2;
      };
    }, 7751: (e22, t4) => {
      var r3 = {}.propertyIsEnumerable, n2 = Object.getOwnPropertyDescriptor, o2 = n2 && !r3.call({1: 2}, 1);
      t4.f = o2 ? function(e23) {
        var t5 = n2(this, e23);
        return !!t5 && t5.enumerable;
      } : r3;
    }, 1047: (e22, t4, r3) => {
      var n2 = r3(2521);
      e22.exports = function(e23, t5) {
        var r4, o2;
        if (t5 === "string" && typeof (r4 = e23.toString) == "function" && !n2(o2 = r4.call(e23)))
          return o2;
        if (typeof (r4 = e23.valueOf) == "function" && !n2(o2 = r4.call(e23)))
          return o2;
        if (t5 !== "string" && typeof (r4 = e23.toString) == "function" && !n2(o2 = r4.call(e23)))
          return o2;
        throw TypeError("Can't convert object to primitive value");
      };
    }, 9593: (e22, t4, r3) => {
      var n2 = r3(7642), o2 = r3(2042), i2 = r3(2719), s2 = r3(6956);
      e22.exports = n2("Reflect", "ownKeys") || function(e23) {
        var t5 = o2.f(s2(e23)), r4 = i2.f;
        return r4 ? t5.concat(r4(e23)) : t5;
      };
    }, 2327: (e22, t4, r3) => {
      var n2 = r3(6121), o2 = r3(1471), i2 = r3(2766), s2 = r3(6565), u2 = r3(9835), a2 = r3(2995), c2 = a2.get, l2 = a2.enforce, f2 = String(String).split("String");
      (e22.exports = function(e23, t5, r4, u3) {
        var a3, c3 = !!u3 && !!u3.unsafe, p2 = !!u3 && !!u3.enumerable, h2 = !!u3 && !!u3.noTargetGet;
        typeof r4 == "function" && (typeof t5 != "string" || i2(r4, "name") || o2(r4, "name", t5), (a3 = l2(r4)).source || (a3.source = f2.join(typeof t5 == "string" ? t5 : ""))), e23 !== n2 ? (c3 ? !h2 && e23[t5] && (p2 = true) : delete e23[t5], p2 ? e23[t5] = r4 : o2(e23, t5, r4)) : p2 ? e23[t5] = r4 : s2(t5, r4);
      })(Function.prototype, "toString", function() {
        return typeof this == "function" && c2(this).source || u2(this);
      });
    }, 7263: (e22) => {
      e22.exports = function(e23) {
        if (e23 == null)
          throw TypeError("Can't call method on " + e23);
        return e23;
      };
    }, 6565: (e22, t4, r3) => {
      var n2 = r3(6121);
      e22.exports = function(e23, t5) {
        try {
          Object.defineProperty(n2, e23, {value: t5, configurable: true, writable: true});
        } catch (r4) {
          n2[e23] = t5;
        }
        return t5;
      };
    }, 2562: (e22, t4, r3) => {
      var n2 = r3(896), o2 = r3(1735), i2 = n2("keys");
      e22.exports = function(e23) {
        return i2[e23] || (i2[e23] = o2(e23));
      };
    }, 4682: (e22, t4, r3) => {
      var n2 = r3(6121), o2 = r3(6565), i2 = "__core-js_shared__", s2 = n2[i2] || o2(i2, {});
      e22.exports = s2;
    }, 896: (e22, t4, r3) => {
      var n2 = r3(8451), o2 = r3(4682);
      (e22.exports = function(e23, t5) {
        return o2[e23] || (o2[e23] = t5 !== void 0 ? t5 : {});
      })("versions", []).push({version: "3.17.3", mode: n2 ? "pure" : "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
    }, 1588: (e22, t4, r3) => {
      var n2 = r3(5623), o2 = Math.max, i2 = Math.min;
      e22.exports = function(e23, t5) {
        var r4 = n2(e23);
        return r4 < 0 ? o2(r4 + t5, 0) : i2(r4, t5);
      };
    }, 9969: (e22, t4, r3) => {
      var n2 = r3(3169), o2 = r3(7263);
      e22.exports = function(e23) {
        return n2(o2(e23));
      };
    }, 5623: (e22) => {
      var t4 = Math.ceil, r3 = Math.floor;
      e22.exports = function(e23) {
        return isNaN(e23 = +e23) ? 0 : (e23 > 0 ? r3 : t4)(e23);
      };
    }, 8331: (e22, t4, r3) => {
      var n2 = r3(5623), o2 = Math.min;
      e22.exports = function(e23) {
        return e23 > 0 ? o2(n2(e23), 9007199254740991) : 0;
      };
    }, 4766: (e22, t4, r3) => {
      var n2 = r3(7263);
      e22.exports = function(e23) {
        return Object(n2(e23));
      };
    }, 687: (e22, t4, r3) => {
      var n2 = r3(2521), o2 = r3(5057), i2 = r3(1047), s2 = r3(1386)("toPrimitive");
      e22.exports = function(e23, t5) {
        if (!n2(e23) || o2(e23))
          return e23;
        var r4, u2 = e23[s2];
        if (u2 !== void 0) {
          if (t5 === void 0 && (t5 = "default"), r4 = u2.call(e23, t5), !n2(r4) || o2(r4))
            return r4;
          throw TypeError("Can't convert object to primitive value");
        }
        return t5 === void 0 && (t5 = "number"), i2(e23, t5);
      };
    }, 5224: (e22, t4, r3) => {
      var n2 = r3(687), o2 = r3(5057);
      e22.exports = function(e23) {
        var t5 = n2(e23, "string");
        return o2(t5) ? t5 : String(t5);
      };
    }, 6395: (e22, t4, r3) => {
      var n2 = {};
      n2[r3(1386)("toStringTag")] = "z", e22.exports = String(n2) === "[object z]";
    }, 3710: (e22, t4, r3) => {
      var n2 = r3(5057);
      e22.exports = function(e23) {
        if (n2(e23))
          throw TypeError("Cannot convert a Symbol value to a string");
        return String(e23);
      };
    }, 1735: (e22) => {
      var t4 = 0, r3 = Math.random();
      e22.exports = function(e23) {
        return "Symbol(" + String(e23 === void 0 ? "" : e23) + ")_" + (++t4 + r3).toString(36);
      };
    }, 2020: (e22, t4, r3) => {
      var n2 = r3(4020);
      e22.exports = n2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }, 1386: (e22, t4, r3) => {
      var n2 = r3(6121), o2 = r3(896), i2 = r3(2766), s2 = r3(1735), u2 = r3(4020), a2 = r3(2020), c2 = o2("wks"), l2 = n2.Symbol, f2 = a2 ? l2 : l2 && l2.withoutSetter || s2;
      e22.exports = function(e23) {
        return i2(c2, e23) && (u2 || typeof c2[e23] == "string") || (u2 && i2(l2, e23) ? c2[e23] = l2[e23] : c2[e23] = f2("Symbol." + e23)), c2[e23];
      };
    }, 4304: (e22, t4, r3) => {
      var n2 = r3(7309), o2 = r3(5538), i2 = r3(4766), s2 = r3(8331), u2 = r3(118), a2 = r3(8347);
      n2({target: "Array", proto: true}, {flatMap: function(e23) {
        var t5, r4 = i2(this), n3 = s2(r4.length);
        return u2(e23), (t5 = a2(r4, 0)).length = o2(t5, r4, r4, n3, 0, 1, e23, arguments.length > 1 ? arguments[1] : void 0), t5;
      }});
    }, 4070: (e22, t4, r3) => {
      var n2 = r3(7309), o2 = r3(118), i2 = r3(4766), s2 = r3(8331), u2 = r3(3710), a2 = r3(2763), c2 = r3(3407), l2 = r3(9719), f2 = r3(5249), p2 = r3(2049), h2 = r3(6962), d2 = r3(8998), D2 = [], g2 = D2.sort, m2 = a2(function() {
        D2.sort(void 0);
      }), v2 = a2(function() {
        D2.sort(null);
      }), y2 = l2("sort"), w2 = !a2(function() {
        if (h2)
          return h2 < 70;
        if (!(f2 && f2 > 3)) {
          if (p2)
            return true;
          if (d2)
            return d2 < 603;
          var e23, t5, r4, n3, o3 = "";
          for (e23 = 65; e23 < 76; e23++) {
            switch (t5 = String.fromCharCode(e23), e23) {
              case 66:
              case 69:
              case 70:
              case 72:
                r4 = 3;
                break;
              case 68:
              case 71:
                r4 = 4;
                break;
              default:
                r4 = 2;
            }
            for (n3 = 0; n3 < 47; n3++)
              D2.push({k: t5 + n3, v: r4});
          }
          for (D2.sort(function(e24, t6) {
            return t6.v - e24.v;
          }), n3 = 0; n3 < D2.length; n3++)
            t5 = D2[n3].k.charAt(0), o3.charAt(o3.length - 1) !== t5 && (o3 += t5);
          return o3 !== "DGBEFHACIJK";
        }
      });
      n2({target: "Array", proto: true, forced: m2 || !v2 || !y2 || !w2}, {sort: function(e23) {
        e23 !== void 0 && o2(e23);
        var t5 = i2(this);
        if (w2)
          return e23 === void 0 ? g2.call(t5) : g2.call(t5, e23);
        var r4, n3, a3 = [], l3 = s2(t5.length);
        for (n3 = 0; n3 < l3; n3++)
          n3 in t5 && a3.push(t5[n3]);
        for (r4 = (a3 = c2(a3, function(e24) {
          return function(t6, r5) {
            return r5 === void 0 ? -1 : t6 === void 0 ? 1 : e24 !== void 0 ? +e24(t6, r5) || 0 : u2(t6) > u2(r5) ? 1 : -1;
          };
        }(e23))).length, n3 = 0; n3 < r4; )
          t5[n3] = a3[n3++];
        for (; n3 < l3; )
          delete t5[n3++];
        return t5;
      }});
    }, 2612: (e22, t4, r3) => {
      var n2 = r3(7309), o2 = r3(4572), i2 = r3(2385);
      n2({target: "Object", stat: true}, {fromEntries: function(e23) {
        var t5 = {};
        return o2(e23, function(e24, r4) {
          i2(t5, e24, r4);
        }, {AS_ENTRIES: true}), t5;
      }});
    }, 3584: (e22) => {
      const t4 = (e23) => {
        if (typeof e23 != "string")
          throw new TypeError("Expected a string");
        const t5 = e23.match(/(?:\r?\n)/g) || [];
        if (t5.length === 0)
          return;
        const r3 = t5.filter((e24) => e24 === "\r\n").length;
        return r3 > t5.length - r3 ? "\r\n" : "\n";
      };
      e22.exports = t4, e22.exports.graceful = (e23) => typeof e23 == "string" && t4(e23) || "\n";
    }, 541: (e22) => {
      e22.exports = function() {
        return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
      };
    }, 2240: (e22) => {
      e22.exports = (e23) => {
        if (typeof e23 != "string")
          throw new TypeError("Expected a string");
        return e23.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      };
    }, 8051: (e22) => {
      e22.exports = function(e23, t4) {
        return (t4 = typeof t4 == "number" ? t4 : 1 / 0) ? function e24(r3, n2) {
          return r3.reduce(function(r4, o2) {
            return Array.isArray(o2) && n2 < t4 ? r4.concat(e24(o2, n2 + 1)) : r4.concat(o2);
          }, []);
        }(e23, 1) : Array.isArray(e23) ? e23.map(function(e24) {
          return e24;
        }) : e23;
      };
    }, 7886: (e22) => {
      e22.exports = function(e23, t4) {
        for (var r3 = -1, n2 = []; (r3 = e23.indexOf(t4, r3 + 1)) !== -1; )
          n2.push(r3);
        return n2;
      };
    }, 8528: (e22) => {
      const t4 = (e23) => !Number.isNaN(e23) && e23 >= 4352 && (e23 <= 4447 || e23 === 9001 || e23 === 9002 || 11904 <= e23 && e23 <= 12871 && e23 !== 12351 || 12880 <= e23 && e23 <= 19903 || 19968 <= e23 && e23 <= 42182 || 43360 <= e23 && e23 <= 43388 || 44032 <= e23 && e23 <= 55203 || 63744 <= e23 && e23 <= 64255 || 65040 <= e23 && e23 <= 65049 || 65072 <= e23 && e23 <= 65131 || 65281 <= e23 && e23 <= 65376 || 65504 <= e23 && e23 <= 65510 || 110592 <= e23 && e23 <= 110593 || 127488 <= e23 && e23 <= 127569 || 131072 <= e23 && e23 <= 262141);
      e22.exports = t4, e22.exports.default = t4;
    }, 9234: (e22, t4, r3) => {
      function n2() {
        const e23 = r3(4372);
        return n2 = function() {
          return e23;
        }, e23;
      }
      function o2() {
        const e23 = (t5 = r3(3584)) && t5.__esModule ? t5 : {default: t5};
        var t5;
        return o2 = function() {
          return e23;
        }, e23;
      }
      Object.defineProperty(t4, "__esModule", {value: true}), t4.extract = function(e23) {
        const t5 = e23.match(u2);
        return t5 ? t5[0].trimLeft() : "";
      }, t4.strip = function(e23) {
        const t5 = e23.match(u2);
        return t5 && t5[0] ? e23.substring(t5[0].length) : e23;
      }, t4.parse = function(e23) {
        return d2(e23).pragmas;
      }, t4.parseWithComments = d2, t4.print = function({comments: e23 = "", pragmas: t5 = {}}) {
        const r4 = (0, o2().default)(e23) || n2().EOL, i3 = " *", s3 = Object.keys(t5), u3 = s3.map((e24) => D2(e24, t5[e24])).reduce((e24, t6) => e24.concat(t6), []).map((e24) => " * " + e24 + r4).join("");
        if (!e23) {
          if (s3.length === 0)
            return "";
          if (s3.length === 1 && !Array.isArray(t5[s3[0]])) {
            const e24 = t5[s3[0]];
            return `/** ${D2(s3[0], e24)[0]} */`;
          }
        }
        const a3 = e23.split(r4).map((e24) => ` * ${e24}`).join(r4) + r4;
        return "/**" + r4 + (e23 ? a3 : "") + (e23 && s3.length ? i3 + r4 : "") + u3 + " */";
      };
      const i2 = /\*\/$/, s2 = /^\/\*\*/, u2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a2 = /(^|\s+)\/\/([^\r\n]*)/g, c2 = /^(\r?\n)+/, l2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, f2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p2 = /(\r?\n|^) *\* ?/g, h2 = [];
      function d2(e23) {
        const t5 = (0, o2().default)(e23) || n2().EOL;
        e23 = e23.replace(s2, "").replace(i2, "").replace(p2, "$1");
        let r4 = "";
        for (; r4 !== e23; )
          r4 = e23, e23 = e23.replace(l2, `${t5}$1 $2${t5}`);
        e23 = e23.replace(c2, "").trimRight();
        const u3 = Object.create(null), d3 = e23.replace(f2, "").replace(c2, "").trimRight();
        let D3;
        for (; D3 = f2.exec(e23); ) {
          const e24 = D3[2].replace(a2, "");
          typeof u3[D3[1]] == "string" || Array.isArray(u3[D3[1]]) ? u3[D3[1]] = h2.concat(u3[D3[1]], e24) : u3[D3[1]] = e24;
        }
        return {comments: d3, pragmas: u3};
      }
      function D2(e23, t5) {
        return h2.concat(t5).map((t6) => `@${e23} ${t6}`.trim());
      }
    }, 5311: (e22, t4, r3) => {
      function n2() {
        for (var e23 = [], t5 = 0; t5 < arguments.length; t5++)
          e23[t5] = arguments[t5];
      }
      function o2() {
        return typeof WeakMap != "undefined" ? new WeakMap() : {add: n2, delete: n2, get: n2, set: n2, has: function(e23) {
          return false;
        }};
      }
      r3.r(t4), r3.d(t4, {default: () => m2, outdent: () => g2}), e22 = r3.hmd(e22);
      var i2 = Object.prototype.hasOwnProperty, s2 = function(e23, t5) {
        return i2.call(e23, t5);
      };
      function u2(e23, t5) {
        for (var r4 in t5)
          s2(t5, r4) && (e23[r4] = t5[r4]);
        return e23;
      }
      var a2 = /^[ \t]*(?:\r\n|\r|\n)/, c2 = /(?:\r\n|\r|\n)[ \t]*$/, l2 = /^(?:[\r\n]|$)/, f2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
      function h2(e23, t5, r4) {
        var n3 = 0, o3 = e23[0].match(f2);
        o3 && (n3 = o3[1].length);
        var i3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
        t5 && (e23 = e23.slice(1));
        var s3 = r4.newline, u3 = r4.trimLeadingNewline, l3 = r4.trimTrailingNewline, p3 = typeof s3 == "string", h3 = e23.length;
        return e23.map(function(e24, t6) {
          return e24 = e24.replace(i3, "$1"), t6 === 0 && u3 && (e24 = e24.replace(a2, "")), t6 === h3 - 1 && l3 && (e24 = e24.replace(c2, "")), p3 && (e24 = e24.replace(/\r\n|\n|\r/g, function(e25) {
            return s3;
          })), e24;
        });
      }
      function d2(e23, t5) {
        for (var r4 = "", n3 = 0, o3 = e23.length; n3 < o3; n3++)
          r4 += e23[n3], n3 < o3 - 1 && (r4 += t5[n3]);
        return r4;
      }
      function D2(e23) {
        return s2(e23, "raw") && s2(e23, "length");
      }
      var g2 = function e23(t5) {
        var r4 = o2(), n3 = o2();
        return u2(function o3(i3) {
          for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
            s3[a3 - 1] = arguments[a3];
          if (D2(i3)) {
            var c3 = i3, f3 = (s3[0] === o3 || s3[0] === g2) && p2.test(c3[0]) && l2.test(c3[1]), m3 = f3 ? n3 : r4, v2 = m3.get(c3);
            return v2 || (v2 = h2(c3, f3, t5), m3.set(c3, v2)), s3.length === 0 ? v2[0] : d2(v2, f3 ? s3.slice(1) : s3);
          }
          return e23(u2(u2({}, t5), i3 || {}));
        }, {string: function(e24) {
          return h2([e24], false, t5)[0];
        }});
      }({trimLeadingNewline: true, trimTrailingNewline: true});
      const m2 = g2;
      try {
        e22.exports = g2, Object.defineProperty(g2, "__esModule", {value: true}), g2.default = g2, g2.outdent = g2;
      } catch (e23) {
      }
    }, 5724: (e22) => {
      function t4(e23) {
        if (typeof e23 != "string")
          throw new TypeError("Path must be a string. Received " + JSON.stringify(e23));
      }
      function r3(e23, t5) {
        for (var r4, n3 = "", o2 = 0, i2 = -1, s2 = 0, u2 = 0; u2 <= e23.length; ++u2) {
          if (u2 < e23.length)
            r4 = e23.charCodeAt(u2);
          else {
            if (r4 === 47)
              break;
            r4 = 47;
          }
          if (r4 === 47) {
            if (i2 === u2 - 1 || s2 === 1)
              ;
            else if (i2 !== u2 - 1 && s2 === 2) {
              if (n3.length < 2 || o2 !== 2 || n3.charCodeAt(n3.length - 1) !== 46 || n3.charCodeAt(n3.length - 2) !== 46) {
                if (n3.length > 2) {
                  var a2 = n3.lastIndexOf("/");
                  if (a2 !== n3.length - 1) {
                    a2 === -1 ? (n3 = "", o2 = 0) : o2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), i2 = u2, s2 = 0;
                    continue;
                  }
                } else if (n3.length === 2 || n3.length === 1) {
                  n3 = "", o2 = 0, i2 = u2, s2 = 0;
                  continue;
                }
              }
              t5 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o2 = 2);
            } else
              n3.length > 0 ? n3 += "/" + e23.slice(i2 + 1, u2) : n3 = e23.slice(i2 + 1, u2), o2 = u2 - i2 - 1;
            i2 = u2, s2 = 0;
          } else
            r4 === 46 && s2 !== -1 ? ++s2 : s2 = -1;
        }
        return n3;
      }
      var n2 = {resolve: function() {
        for (var e23, n3 = "", o2 = false, i2 = arguments.length - 1; i2 >= -1 && !o2; i2--) {
          var s2;
          i2 >= 0 ? s2 = arguments[i2] : (e23 === void 0 && (e23 = process.cwd()), s2 = e23), t4(s2), s2.length !== 0 && (n3 = s2 + "/" + n3, o2 = s2.charCodeAt(0) === 47);
        }
        return n3 = r3(n3, !o2), o2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
      }, normalize: function(e23) {
        if (t4(e23), e23.length === 0)
          return ".";
        var n3 = e23.charCodeAt(0) === 47, o2 = e23.charCodeAt(e23.length - 1) === 47;
        return (e23 = r3(e23, !n3)).length !== 0 || n3 || (e23 = "."), e23.length > 0 && o2 && (e23 += "/"), n3 ? "/" + e23 : e23;
      }, isAbsolute: function(e23) {
        return t4(e23), e23.length > 0 && e23.charCodeAt(0) === 47;
      }, join: function() {
        if (arguments.length === 0)
          return ".";
        for (var e23, r4 = 0; r4 < arguments.length; ++r4) {
          var o2 = arguments[r4];
          t4(o2), o2.length > 0 && (e23 === void 0 ? e23 = o2 : e23 += "/" + o2);
        }
        return e23 === void 0 ? "." : n2.normalize(e23);
      }, relative: function(e23, r4) {
        if (t4(e23), t4(r4), e23 === r4)
          return "";
        if ((e23 = n2.resolve(e23)) === (r4 = n2.resolve(r4)))
          return "";
        for (var o2 = 1; o2 < e23.length && e23.charCodeAt(o2) === 47; ++o2)
          ;
        for (var i2 = e23.length, s2 = i2 - o2, u2 = 1; u2 < r4.length && r4.charCodeAt(u2) === 47; ++u2)
          ;
        for (var a2 = r4.length - u2, c2 = s2 < a2 ? s2 : a2, l2 = -1, f2 = 0; f2 <= c2; ++f2) {
          if (f2 === c2) {
            if (a2 > c2) {
              if (r4.charCodeAt(u2 + f2) === 47)
                return r4.slice(u2 + f2 + 1);
              if (f2 === 0)
                return r4.slice(u2 + f2);
            } else
              s2 > c2 && (e23.charCodeAt(o2 + f2) === 47 ? l2 = f2 : f2 === 0 && (l2 = 0));
            break;
          }
          var p2 = e23.charCodeAt(o2 + f2);
          if (p2 !== r4.charCodeAt(u2 + f2))
            break;
          p2 === 47 && (l2 = f2);
        }
        var h2 = "";
        for (f2 = o2 + l2 + 1; f2 <= i2; ++f2)
          f2 !== i2 && e23.charCodeAt(f2) !== 47 || (h2.length === 0 ? h2 += ".." : h2 += "/..");
        return h2.length > 0 ? h2 + r4.slice(u2 + l2) : (u2 += l2, r4.charCodeAt(u2) === 47 && ++u2, r4.slice(u2));
      }, _makeLong: function(e23) {
        return e23;
      }, dirname: function(e23) {
        if (t4(e23), e23.length === 0)
          return ".";
        for (var r4 = e23.charCodeAt(0), n3 = r4 === 47, o2 = -1, i2 = true, s2 = e23.length - 1; s2 >= 1; --s2)
          if ((r4 = e23.charCodeAt(s2)) === 47) {
            if (!i2) {
              o2 = s2;
              break;
            }
          } else
            i2 = false;
        return o2 === -1 ? n3 ? "/" : "." : n3 && o2 === 1 ? "//" : e23.slice(0, o2);
      }, basename: function(e23, r4) {
        if (r4 !== void 0 && typeof r4 != "string")
          throw new TypeError('"ext" argument must be a string');
        t4(e23);
        var n3, o2 = 0, i2 = -1, s2 = true;
        if (r4 !== void 0 && r4.length > 0 && r4.length <= e23.length) {
          if (r4.length === e23.length && r4 === e23)
            return "";
          var u2 = r4.length - 1, a2 = -1;
          for (n3 = e23.length - 1; n3 >= 0; --n3) {
            var c2 = e23.charCodeAt(n3);
            if (c2 === 47) {
              if (!s2) {
                o2 = n3 + 1;
                break;
              }
            } else
              a2 === -1 && (s2 = false, a2 = n3 + 1), u2 >= 0 && (c2 === r4.charCodeAt(u2) ? --u2 == -1 && (i2 = n3) : (u2 = -1, i2 = a2));
          }
          return o2 === i2 ? i2 = a2 : i2 === -1 && (i2 = e23.length), e23.slice(o2, i2);
        }
        for (n3 = e23.length - 1; n3 >= 0; --n3)
          if (e23.charCodeAt(n3) === 47) {
            if (!s2) {
              o2 = n3 + 1;
              break;
            }
          } else
            i2 === -1 && (s2 = false, i2 = n3 + 1);
        return i2 === -1 ? "" : e23.slice(o2, i2);
      }, extname: function(e23) {
        t4(e23);
        for (var r4 = -1, n3 = 0, o2 = -1, i2 = true, s2 = 0, u2 = e23.length - 1; u2 >= 0; --u2) {
          var a2 = e23.charCodeAt(u2);
          if (a2 !== 47)
            o2 === -1 && (i2 = false, o2 = u2 + 1), a2 === 46 ? r4 === -1 ? r4 = u2 : s2 !== 1 && (s2 = 1) : r4 !== -1 && (s2 = -1);
          else if (!i2) {
            n3 = u2 + 1;
            break;
          }
        }
        return r4 === -1 || o2 === -1 || s2 === 0 || s2 === 1 && r4 === o2 - 1 && r4 === n3 + 1 ? "" : e23.slice(r4, o2);
      }, format: function(e23) {
        if (e23 === null || typeof e23 != "object")
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e23);
        return function(e24, t5) {
          var r4 = t5.dir || t5.root, n3 = t5.base || (t5.name || "") + (t5.ext || "");
          return r4 ? r4 === t5.root ? r4 + n3 : r4 + e24 + n3 : n3;
        }("/", e23);
      }, parse: function(e23) {
        t4(e23);
        var r4 = {root: "", dir: "", base: "", ext: "", name: ""};
        if (e23.length === 0)
          return r4;
        var n3, o2 = e23.charCodeAt(0), i2 = o2 === 47;
        i2 ? (r4.root = "/", n3 = 1) : n3 = 0;
        for (var s2 = -1, u2 = 0, a2 = -1, c2 = true, l2 = e23.length - 1, f2 = 0; l2 >= n3; --l2)
          if ((o2 = e23.charCodeAt(l2)) !== 47)
            a2 === -1 && (c2 = false, a2 = l2 + 1), o2 === 46 ? s2 === -1 ? s2 = l2 : f2 !== 1 && (f2 = 1) : s2 !== -1 && (f2 = -1);
          else if (!c2) {
            u2 = l2 + 1;
            break;
          }
        return s2 === -1 || a2 === -1 || f2 === 0 || f2 === 1 && s2 === a2 - 1 && s2 === u2 + 1 ? a2 !== -1 && (r4.base = r4.name = u2 === 0 && i2 ? e23.slice(1, a2) : e23.slice(u2, a2)) : (u2 === 0 && i2 ? (r4.name = e23.slice(1, s2), r4.base = e23.slice(1, a2)) : (r4.name = e23.slice(u2, s2), r4.base = e23.slice(u2, a2)), r4.ext = e23.slice(s2, a2)), u2 > 0 ? r4.dir = e23.slice(0, u2 - 1) : i2 && (r4.dir = "/"), r4;
      }, sep: "/", delimiter: ":", win32: null, posix: null};
      n2.posix = n2, e22.exports = n2;
    }, 8681: (e22, t4, r3) => {
      const n2 = r3(3102), o2 = r3(7116), {isInlineComment: i2} = r3(1101), {interpolation: s2} = r3(3295), {isMixinToken: u2} = r3(5953), a2 = r3(1330), c2 = r3(5255), l2 = /(!\s*important)$/i;
      e22.exports = class extends o2 {
        constructor(...e23) {
          super(...e23), this.lastNode = null;
        }
        atrule(e23) {
          s2.bind(this)(e23) || (super.atrule(e23), a2(this.lastNode), c2(this.lastNode));
        }
        decl(...e23) {
          super.decl(...e23), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
        }
        each(e23) {
          e23[0][1] = ` ${e23[0][1]}`;
          const t5 = e23.findIndex((e24) => e24[0] === "("), r4 = e23.reverse().find((e24) => e24[0] === ")"), n3 = e23.reverse().indexOf(r4), o3 = e23.splice(t5, n3).map((e24) => e24[1]).join("");
          for (const t6 of e23.reverse())
            this.tokenizer.back(t6);
          this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = o3;
        }
        init(e23, t5, r4) {
          super.init(e23, t5, r4), this.lastNode = e23;
        }
        inlineComment(e23) {
          const t5 = new n2(), r4 = e23[1].slice(2);
          if (this.init(t5, e23[2], e23[3]), t5.source.end = {line: e23[4], column: e23[5]}, t5.inline = true, t5.raws.begin = "//", /^\s*$/.test(r4))
            t5.text = "", t5.raws.left = r4, t5.raws.right = "";
          else {
            const e24 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
            [, t5.raws.left, t5.text, t5.raws.right] = e24;
          }
        }
        mixin(e23) {
          const [t5] = e23, r4 = t5[1].slice(0, 1), n3 = e23.findIndex((e24) => e24[0] === "brackets"), o3 = e23.findIndex((e24) => e24[0] === "(");
          let i3 = "";
          if ((n3 < 0 || n3 > 3) && o3 > 0) {
            const t6 = e23.reduce((e24, t7, r6) => t7[0] === ")" ? r6 : e24), r5 = e23.slice(o3, t6 + o3).map((e24) => e24[1]).join(""), [n4] = e23.slice(o3), i4 = [n4[2], n4[3]], [s4] = e23.slice(t6, t6 + 1), u4 = [s4[2], s4[3]], a3 = ["brackets", r5].concat(i4, u4), c3 = e23.slice(0, o3), l3 = e23.slice(t6 + 1);
            (e23 = c3).push(a3), e23 = e23.concat(l3);
          }
          const s3 = [];
          for (const t6 of e23)
            if ((t6[1] === "!" || s3.length) && s3.push(t6), t6[1] === "important")
              break;
          if (s3.length) {
            const [t6] = s3, r5 = e23.indexOf(t6), n4 = s3[s3.length - 1], o4 = [t6[2], t6[3]], i4 = [n4[4], n4[5]], u4 = ["word", s3.map((e24) => e24[1]).join("")].concat(o4, i4);
            e23.splice(r5, s3.length, u4);
          }
          const u3 = e23.findIndex((e24) => l2.test(e24[1]));
          u3 > 0 && ([, i3] = e23[u3], e23.splice(u3, 1));
          for (const t6 of e23.reverse())
            this.tokenizer.back(t6);
          this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = r4, i3 && (this.lastNode.important = true, this.lastNode.raws.important = i3);
        }
        other(e23) {
          i2.bind(this)(e23) || super.other(e23);
        }
        rule(e23) {
          const t5 = e23[e23.length - 1], r4 = e23[e23.length - 2];
          if (r4[0] === "at-word" && t5[0] === "{" && (this.tokenizer.back(t5), s2.bind(this)(r4))) {
            const t6 = this.tokenizer.nextToken();
            e23 = e23.slice(0, e23.length - 2).concat([t6]);
            for (const t7 of e23.reverse())
              this.tokenizer.back(t7);
          } else
            super.rule(e23), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
        }
        unknownWord(e23) {
          const [t5] = e23;
          e23[0][1] !== "each" || e23[1][0] !== "(" ? u2(t5) ? this.mixin(e23) : super.unknownWord(e23) : this.each(e23);
        }
      };
    }, 3406: (e22, t4, r3) => {
      const n2 = r3(5701);
      e22.exports = class extends n2 {
        atrule(e23, t5) {
          if (!e23.mixin && !e23.variable && !e23.function)
            return void super.atrule(e23, t5);
          let r4 = `${e23.function ? "" : e23.raws.identifier || "@"}${e23.name}`, n3 = e23.params ? this.rawValue(e23, "params") : "";
          const o2 = e23.raws.important || "";
          if (e23.variable && (n3 = e23.value), e23.raws.afterName !== void 0 ? r4 += e23.raws.afterName : n3 && (r4 += " "), e23.nodes)
            this.block(e23, r4 + n3 + o2);
          else {
            const i2 = (e23.raws.between || "") + o2 + (t5 ? ";" : "");
            this.builder(r4 + n3 + i2, e23);
          }
        }
        comment(e23) {
          if (e23.inline) {
            const t5 = this.raw(e23, "left", "commentLeft"), r4 = this.raw(e23, "right", "commentRight");
            this.builder(`//${t5}${e23.text}${r4}`, e23);
          } else
            super.comment(e23);
        }
      };
    }, 7371: (e22, t4, r3) => {
      const n2 = r3(2993), o2 = r3(8681), i2 = r3(3406);
      e22.exports = {parse(e23, t5) {
        const r4 = new n2(e23, t5), i3 = new o2(r4);
        return i3.parse(), i3.root;
      }, stringify(e23, t5) {
        new i2(t5).stringify(e23);
      }, nodeToString(t5) {
        let r4 = "";
        return e22.exports.stringify(t5, (e23) => {
          r4 += e23;
        }), r4;
      }};
    }, 1330: (e22, t4, r3) => {
      const n2 = r3(1157), o2 = /^url\((.+)\)/;
      e22.exports = (e23) => {
        const {name: t5, params: r4 = ""} = e23;
        if (t5 === "import" && r4.length) {
          e23.import = true;
          const t6 = n2({css: r4});
          for (e23.filename = r4.replace(o2, "$1"); !t6.endOfFile(); ) {
            const [n3, o3] = t6.nextToken();
            if (n3 === "word" && o3 === "url")
              return;
            if (n3 === "brackets") {
              e23.options = o3, e23.filename = r4.replace(o3, "").trim();
              break;
            }
          }
        }
      };
    }, 1101: (e22, t4, r3) => {
      const n2 = r3(1157), o2 = r3(2993);
      e22.exports = {isInlineComment(t5) {
        if (t5[0] === "word" && t5[1].slice(0, 2) === "//") {
          const e23 = t5, r4 = [];
          let i2;
          for (; t5; ) {
            if (/\r?\n/.test(t5[1])) {
              if (/['"].*\r?\n/.test(t5[1])) {
                r4.push(t5[1].substring(0, t5[1].indexOf("\n")));
                let e24 = t5[1].substring(t5[1].indexOf("\n"));
                e24 += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new o2(e24), this.tokenizer = n2(this.input);
              } else
                this.tokenizer.back(t5);
              break;
            }
            r4.push(t5[1]), i2 = t5, t5 = this.tokenizer.nextToken({ignoreUnclosed: true});
          }
          const s2 = ["comment", r4.join(""), e23[2], e23[3], i2[2], i2[3]];
          return this.inlineComment(s2), true;
        }
        if (t5[1] === "/") {
          const r4 = this.tokenizer.nextToken({ignoreUnclosed: true});
          if (r4[0] === "comment" && /^\/\*/.test(r4[1]))
            return r4[0] = "word", r4[1] = r4[1].slice(1), t5[1] = "//", this.tokenizer.back(r4), e22.exports.isInlineComment.bind(this)(t5);
        }
        return false;
      }};
    }, 3295: (e22) => {
      e22.exports = {interpolation(e23) {
        let t4 = e23;
        const r3 = [e23], n2 = ["word", "{", "}"];
        if (e23 = this.tokenizer.nextToken(), t4[1].length > 1 || e23[0] !== "{")
          return this.tokenizer.back(e23), false;
        for (; e23 && n2.includes(e23[0]); )
          r3.push(e23), e23 = this.tokenizer.nextToken();
        const o2 = r3.map((e24) => e24[1]);
        [t4] = r3;
        const i2 = r3.pop(), s2 = [t4[2], t4[3]], u2 = [i2[4] || i2[2], i2[5] || i2[3]], a2 = ["word", o2.join("")].concat(s2, u2);
        return this.tokenizer.back(e23), this.tokenizer.back(a2), true;
      }};
    }, 5953: (e22) => {
      const t4 = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, r3 = /\.[0-9]/;
      e22.exports = {isMixinToken: (e23) => {
        const [, n2] = e23, [o2] = n2;
        return (o2 === "." || o2 === "#") && t4.test(n2) === false && r3.test(n2) === false;
      }};
    }, 5255: (e22) => {
      const t4 = /:$/, r3 = /^:(\s+)?/;
      e22.exports = (e23) => {
        const {name: n2, params: o2 = ""} = e23;
        if (e23.name.slice(-1) === ":") {
          if (t4.test(n2)) {
            const [r4] = n2.match(t4);
            e23.name = n2.replace(r4, ""), e23.raws.afterName = r4 + (e23.raws.afterName || ""), e23.variable = true, e23.value = e23.params;
          }
          if (r3.test(o2)) {
            const [t5] = o2.match(r3);
            e23.value = o2.replace(t5, ""), e23.raws.afterName = (e23.raws.afterName || "") + t5, e23.variable = true;
          }
        }
      };
    }, 8322: (e22, t4, r3) => {
      t4.Z = function(e23) {
        return new o2.default({nodes: (0, i2.parseMediaList)(e23), type: "media-query-list", value: e23.trim()});
      };
      var n2, o2 = (n2 = r3(9066)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(7625);
    }, 9066: (e22, t4, r3) => {
      Object.defineProperty(t4, "__esModule", {value: true});
      var n2, o2 = (n2 = r3(7680)) && n2.__esModule ? n2 : {default: n2};
      function i2(e23) {
        var t5 = this;
        this.constructor(e23), this.nodes = e23.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(e24) {
          e24.parent = t5;
        });
      }
      i2.prototype = Object.create(o2.default.prototype), i2.constructor = o2.default, i2.prototype.walk = function(e23, t5) {
        for (var r4 = typeof e23 == "string" || e23 instanceof RegExp, n3 = r4 ? t5 : e23, o3 = typeof e23 == "string" ? new RegExp(e23) : e23, i3 = 0; i3 < this.nodes.length; i3++) {
          var s2 = this.nodes[i3];
          if ((!r4 || o3.test(s2.type)) && n3 && n3(s2, i3, this.nodes) === false)
            return false;
          if (s2.nodes && s2.walk(e23, t5) === false)
            return false;
        }
        return true;
      }, i2.prototype.each = function() {
        for (var e23 = arguments.length <= 0 || arguments[0] === void 0 ? function() {
        } : arguments[0], t5 = 0; t5 < this.nodes.length; t5++)
          if (e23(this.nodes[t5], t5, this.nodes) === false)
            return false;
        return true;
      }, t4.default = i2;
    }, 7680: (e22, t4) => {
      Object.defineProperty(t4, "__esModule", {value: true}), t4.default = function(e23) {
        this.after = e23.after, this.before = e23.before, this.type = e23.type, this.value = e23.value, this.sourceIndex = e23.sourceIndex;
      };
    }, 7625: (e22, t4, r3) => {
      Object.defineProperty(t4, "__esModule", {value: true}), t4.parseMediaFeature = s2, t4.parseMediaQuery = u2, t4.parseMediaList = function(e23) {
        var t5 = [], r4 = 0, i3 = 0, s3 = /^(\s*)url\s*\(/.exec(e23);
        if (s3 !== null) {
          for (var a2 = s3[0].length, c2 = 1; c2 > 0; ) {
            var l2 = e23[a2];
            l2 === "(" && c2++, l2 === ")" && c2--, a2++;
          }
          t5.unshift(new n2.default({type: "url", value: e23.substring(0, a2).trim(), sourceIndex: s3[1].length, before: s3[1], after: /^(\s*)/.exec(e23.substring(a2))[1]})), r4 = a2;
        }
        for (var f2 = r4; f2 < e23.length; f2++) {
          var p2 = e23[f2];
          if (p2 === "(" && i3++, p2 === ")" && i3--, i3 === 0 && p2 === ",") {
            var h2 = e23.substring(r4, f2), d2 = /^(\s*)/.exec(h2)[1];
            t5.push(new o2.default({type: "media-query", value: h2.trim(), sourceIndex: r4 + d2.length, nodes: u2(h2, r4), before: d2, after: /(\s*)$/.exec(h2)[1]})), r4 = f2 + 1;
          }
        }
        var D2 = e23.substring(r4), g2 = /^(\s*)/.exec(D2)[1];
        return t5.push(new o2.default({type: "media-query", value: D2.trim(), sourceIndex: r4 + g2.length, nodes: u2(D2, r4), before: g2, after: /(\s*)$/.exec(D2)[1]})), t5;
      };
      var n2 = i2(r3(7680)), o2 = i2(r3(9066));
      function i2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function s2(e23) {
        var t5 = [{mode: "normal", character: null}], r4 = [], n3 = 0, o3 = "", i3 = null, s3 = null, u3 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], a2 = e23;
        e23[0] === "(" && e23[e23.length - 1] === ")" && (a2 = e23.substring(1, e23.length - 1), u3++);
        for (var c2 = 0; c2 < a2.length; c2++) {
          var l2 = a2[c2];
          if (l2 !== "'" && l2 !== '"' || (t5[n3].isCalculationEnabled === true ? (t5.push({mode: "string", isCalculationEnabled: false, character: l2}), n3++) : t5[n3].mode === "string" && t5[n3].character === l2 && a2[c2 - 1] !== "\\" && (t5.pop(), n3--)), l2 === "{" ? (t5.push({mode: "interpolation", isCalculationEnabled: true}), n3++) : l2 === "}" && (t5.pop(), n3--), t5[n3].mode === "normal" && l2 === ":") {
            var f2 = a2.substring(c2 + 1);
            (s3 = {type: "value", before: /^(\s*)/.exec(f2)[1], after: /(\s*)$/.exec(f2)[1], value: f2.trim()}).sourceIndex = s3.before.length + c2 + 1 + u3, i3 = {type: "colon", sourceIndex: c2 + u3, after: s3.before, value: ":"};
            break;
          }
          o3 += l2;
        }
        return (o3 = {type: "media-feature", before: /^(\s*)/.exec(o3)[1], after: /(\s*)$/.exec(o3)[1], value: o3.trim()}).sourceIndex = o3.before.length + u3, r4.push(o3), i3 !== null && (i3.before = o3.after, r4.push(i3)), s3 !== null && r4.push(s3), r4;
      }
      function u2(e23) {
        var t5 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r4 = [], i3 = 0, u3 = false, a2 = void 0;
        a2 = {before: "", after: "", value: ""};
        for (var c2 = 0; c2 < e23.length; c2++) {
          var l2 = e23[c2];
          u3 ? (a2.value += l2, l2 !== "{" && l2 !== "(" || i3++, l2 !== ")" && l2 !== "}" || i3--) : l2.search(/\s/) !== -1 ? a2.before += l2 : (l2 === "(" && (a2.type = "media-feature-expression", i3++), a2.value = l2, a2.sourceIndex = t5 + c2, u3 = true), !u3 || i3 !== 0 || l2 !== ")" && c2 !== e23.length - 1 && e23[c2 + 1].search(/\s/) === -1 || (["not", "only", "and"].indexOf(a2.value) !== -1 && (a2.type = "keyword"), a2.type === "media-feature-expression" && (a2.nodes = s2(a2.value, a2.sourceIndex)), r4.push(Array.isArray(a2.nodes) ? new o2.default(a2) : new n2.default(a2)), a2 = {before: "", after: "", value: ""}, u3 = false);
        }
        for (var f2 = 0; f2 < r4.length; f2++)
          if (a2 = r4[f2], f2 > 0 && (r4[f2 - 1].after = a2.before), a2.type === void 0) {
            if (f2 > 0) {
              if (r4[f2 - 1].type === "media-feature-expression") {
                a2.type = "keyword";
                continue;
              }
              if (r4[f2 - 1].value === "not" || r4[f2 - 1].value === "only") {
                a2.type = "media-type";
                continue;
              }
              if (r4[f2 - 1].value === "and") {
                a2.type = "media-feature-expression";
                continue;
              }
              r4[f2 - 1].type === "media-type" && (r4[f2 + 1] ? a2.type = r4[f2 + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : a2.type = "media-feature-expression");
            }
            if (f2 === 0) {
              if (!r4[f2 + 1]) {
                a2.type = "media-type";
                continue;
              }
              if (r4[f2 + 1] && (r4[f2 + 1].type === "media-feature-expression" || r4[f2 + 1].type === "keyword")) {
                a2.type = "media-type";
                continue;
              }
              if (r4[f2 + 2]) {
                if (r4[f2 + 2].type === "media-feature-expression") {
                  a2.type = "media-type", r4[f2 + 1].type = "keyword";
                  continue;
                }
                if (r4[f2 + 2].type === "keyword") {
                  a2.type = "keyword", r4[f2 + 1].type = "media-type";
                  continue;
                }
              }
              if (r4[f2 + 3] && r4[f2 + 3].type === "media-feature-expression") {
                a2.type = "keyword", r4[f2 + 1].type = "media-type", r4[f2 + 2].type = "keyword";
                continue;
              }
            }
          }
        return r4;
      }
    }, 5822: (e22, t4, r3) => {
      var n2 = function(e23) {
        var t5, r4;
        function n3(t6) {
          var r5;
          return (r5 = e23.call(this, t6) || this).type = "decl", r5.isNested = true, r5.nodes || (r5.nodes = []), r5;
        }
        return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
      }(r3(1204));
      e22.exports = n2;
    }, 1945: (e22, t4, r3) => {
      var n2 = r3(2993), o2 = r3(1713);
      e22.exports = function(e23, t5) {
        var r4 = new n2(e23, t5), i2 = new o2(r4);
        return i2.parse(), i2.root;
      };
    }, 1713: (e22, t4, r3) => {
      var n2 = r3(3102), o2 = r3(7116), i2 = r3(5822), s2 = r3(6256), u2 = function(e23) {
        var t5, r4;
        function o3() {
          return e23.apply(this, arguments) || this;
        }
        r4 = e23, (t5 = o3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
        var u3 = o3.prototype;
        return u3.createTokenizer = function() {
          this.tokenizer = s2(this.input);
        }, u3.rule = function(t6) {
          var r5 = false, n3 = 0, o4 = "", s3 = t6, u4 = Array.isArray(s3), a2 = 0;
          for (s3 = u4 ? s3 : s3[Symbol.iterator](); ; ) {
            var c2;
            if (u4) {
              if (a2 >= s3.length)
                break;
              c2 = s3[a2++];
            } else {
              if ((a2 = s3.next()).done)
                break;
              c2 = a2.value;
            }
            var l2 = c2;
            if (r5)
              l2[0] !== "comment" && l2[0] !== "{" && (o4 += l2[1]);
            else {
              if (l2[0] === "space" && l2[1].indexOf("\n") !== -1)
                break;
              l2[0] === "(" ? n3 += 1 : l2[0] === ")" ? n3 -= 1 : n3 === 0 && l2[0] === ":" && (r5 = true);
            }
          }
          if (!r5 || o4.trim() === "" || /^[a-zA-Z-:#]/.test(o4))
            e23.prototype.rule.call(this, t6);
          else {
            t6.pop();
            var f2 = new i2();
            this.init(f2);
            var p2, h2 = t6[t6.length - 1];
            for (h2[4] ? f2.source.end = {line: h2[4], column: h2[5]} : f2.source.end = {line: h2[2], column: h2[3]}; t6[0][0] !== "word"; )
              f2.raws.before += t6.shift()[1];
            for (f2.source.start = {line: t6[0][2], column: t6[0][3]}, f2.prop = ""; t6.length; ) {
              var d2 = t6[0][0];
              if (d2 === ":" || d2 === "space" || d2 === "comment")
                break;
              f2.prop += t6.shift()[1];
            }
            for (f2.raws.between = ""; t6.length; ) {
              if ((p2 = t6.shift())[0] === ":") {
                f2.raws.between += p2[1];
                break;
              }
              f2.raws.between += p2[1];
            }
            f2.prop[0] !== "_" && f2.prop[0] !== "*" || (f2.raws.before += f2.prop[0], f2.prop = f2.prop.slice(1)), f2.raws.between += this.spacesAndCommentsFromStart(t6), this.precheckMissedSemicolon(t6);
            for (var D2 = t6.length - 1; D2 > 0; D2--) {
              if ((p2 = t6[D2])[1] === "!important") {
                f2.important = true;
                var g2 = this.stringFrom(t6, D2);
                (g2 = this.spacesFromEnd(t6) + g2) !== " !important" && (f2.raws.important = g2);
                break;
              }
              if (p2[1] === "important") {
                for (var m2 = t6.slice(0), v2 = "", y2 = D2; y2 > 0; y2--) {
                  var w2 = m2[y2][0];
                  if (v2.trim().indexOf("!") === 0 && w2 !== "space")
                    break;
                  v2 = m2.pop()[1] + v2;
                }
                v2.trim().indexOf("!") === 0 && (f2.important = true, f2.raws.important = v2, t6 = m2);
              }
              if (p2[0] !== "space" && p2[0] !== "comment")
                break;
            }
            this.raw(f2, "value", t6), f2.value.indexOf(":") !== -1 && this.checkMissedSemicolon(t6), this.current = f2;
          }
        }, u3.comment = function(t6) {
          if (t6[6] === "inline") {
            var r5 = new n2();
            this.init(r5, t6[2], t6[3]), r5.raws.inline = true, r5.source.end = {line: t6[4], column: t6[5]};
            var o4 = t6[1].slice(2);
            if (/^\s*$/.test(o4))
              r5.text = "", r5.raws.left = o4, r5.raws.right = "";
            else {
              var i3 = o4.match(/^(\s*)([^]*[^\s])(\s*)$/), s3 = i3[2].replace(/(\*\/|\/\*)/g, "*//*");
              r5.text = s3, r5.raws.left = i3[1], r5.raws.right = i3[3], r5.raws.text = i3[2];
            }
          } else
            e23.prototype.comment.call(this, t6);
        }, u3.raw = function(t6, r5, n3) {
          if (e23.prototype.raw.call(this, t6, r5, n3), t6.raws[r5]) {
            var o4 = t6.raws[r5].raw;
            t6.raws[r5].raw = n3.reduce(function(e24, t7) {
              return t7[0] === "comment" && t7[6] === "inline" ? e24 + "/*" + t7[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*") + "*/" : e24 + t7[1];
            }, ""), o4 !== t6.raws[r5].raw && (t6.raws[r5].scss = o4);
          }
        }, o3;
      }(o2);
      e22.exports = u2;
    }, 9235: (e22, t4, r3) => {
      var n2 = function(e23) {
        var t5, r4;
        function n3() {
          return e23.apply(this, arguments) || this;
        }
        r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
        var o2 = n3.prototype;
        return o2.comment = function(e24) {
          var t6 = this.raw(e24, "left", "commentLeft"), r5 = this.raw(e24, "right", "commentRight");
          if (e24.raws.inline) {
            var n4 = e24.raws.text || e24.text;
            this.builder("//" + t6 + n4 + r5, e24);
          } else
            this.builder("/*" + t6 + e24.text + r5 + "*/", e24);
        }, o2.decl = function(t6, r5) {
          if (t6.isNested) {
            var n4, o3 = this.raw(t6, "between", "colon"), i2 = t6.prop + o3 + this.rawValue(t6, "value");
            t6.important && (i2 += t6.raws.important || " !important"), this.builder(i2 + "{", t6, "start"), t6.nodes && t6.nodes.length ? (this.body(t6), n4 = this.raw(t6, "after")) : n4 = this.raw(t6, "after", "emptyBody"), n4 && this.builder(n4), this.builder("}", t6, "end");
          } else
            e23.prototype.decl.call(this, t6, r5);
        }, o2.rawValue = function(e24, t6) {
          var r5 = e24[t6], n4 = e24.raws[t6];
          return n4 && n4.value === r5 ? n4.scss ? n4.scss : n4.raw : r5;
        }, n3;
      }(r3(5701));
      e22.exports = n2;
    }, 4933: (e22, t4, r3) => {
      var n2 = r3(9235);
      e22.exports = function(e23, t5) {
        new n2(t5).stringify(e23);
      };
    }, 304: (e22, t4, r3) => {
      var n2 = r3(4933), o2 = r3(1945);
      e22.exports = {parse: o2, stringify: n2};
    }, 6256: (e22) => {
      var t4 = "'".charCodeAt(0), r3 = '"'.charCodeAt(0), n2 = "\\".charCodeAt(0), o2 = "/".charCodeAt(0), i2 = "\n".charCodeAt(0), s2 = " ".charCodeAt(0), u2 = "\f".charCodeAt(0), a2 = "	".charCodeAt(0), c2 = "\r".charCodeAt(0), l2 = "[".charCodeAt(0), f2 = "]".charCodeAt(0), p2 = "(".charCodeAt(0), h2 = ")".charCodeAt(0), d2 = "{".charCodeAt(0), D2 = "}".charCodeAt(0), g2 = ";".charCodeAt(0), m2 = "*".charCodeAt(0), v2 = ":".charCodeAt(0), y2 = "@".charCodeAt(0), w2 = ",".charCodeAt(0), b2 = "#".charCodeAt(0), C2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, E2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, F2 = /.[\\/("'\n]/, x2 = /[a-f0-9]/i, A2 = /[\r\f\n]/g;
      e22.exports = function(e23, k2) {
        k2 === void 0 && (k2 = {});
        var O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2, $2, U2, G2 = e23.css.valueOf(), W2 = k2.ignoreErrors, z2 = G2.length, V2 = -1, q2 = 1, X2 = 0, J2 = [], H2 = [];
        function Y2(t5) {
          throw e23.error("Unclosed " + t5, q2, X2 - V2);
        }
        function K2() {
          for (var e24 = 1, o3 = false, i3 = false; e24 > 0; )
            _2 += 1, G2.length <= _2 && Y2("interpolation"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), o3 ? i3 || O2 !== o3 ? O2 === n2 ? i3 = !L2 : i3 && (i3 = false) : (o3 = false, i3 = false) : O2 === t4 || O2 === r3 ? o3 = O2 : O2 === D2 ? e24 -= 1 : O2 === b2 && P2 === d2 && (e24 += 1);
        }
        return {back: function(e24) {
          H2.push(e24);
        }, nextToken: function() {
          if (H2.length)
            return H2.pop();
          if (!(X2 >= z2)) {
            switch (((O2 = G2.charCodeAt(X2)) === i2 || O2 === u2 || O2 === c2 && G2.charCodeAt(X2 + 1) !== i2) && (V2 = X2, q2 += 1), O2) {
              case i2:
              case s2:
              case a2:
              case c2:
              case u2:
                _2 = X2;
                do {
                  _2 += 1, (O2 = G2.charCodeAt(_2)) === i2 && (V2 = _2, q2 += 1);
                } while (O2 === s2 || O2 === i2 || O2 === a2 || O2 === c2 || O2 === u2);
                $2 = ["space", G2.slice(X2, _2)], X2 = _2 - 1;
                break;
              case l2:
                $2 = ["[", "[", q2, X2 - V2];
                break;
              case f2:
                $2 = ["]", "]", q2, X2 - V2];
                break;
              case d2:
                $2 = ["{", "{", q2, X2 - V2];
                break;
              case D2:
                $2 = ["}", "}", q2, X2 - V2];
                break;
              case w2:
                $2 = ["word", ",", q2, X2 - V2, q2, X2 - V2 + 1];
                break;
              case v2:
                $2 = [":", ":", q2, X2 - V2];
                break;
              case g2:
                $2 = [";", ";", q2, X2 - V2];
                break;
              case p2:
                if (B2 = J2.length ? J2.pop()[1] : "", P2 = G2.charCodeAt(X2 + 1), B2 === "url" && P2 !== t4 && P2 !== r3) {
                  for (U2 = 1, L2 = false, _2 = X2 + 1; _2 <= G2.length - 1; ) {
                    if ((P2 = G2.charCodeAt(_2)) === n2)
                      L2 = !L2;
                    else if (P2 === p2)
                      U2 += 1;
                    else if (P2 === h2 && (U2 -= 1) == 0)
                      break;
                    _2 += 1;
                  }
                  N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["brackets", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2;
                } else
                  _2 = G2.indexOf(")", X2 + 1), N2 = G2.slice(X2, _2 + 1), _2 === -1 || F2.test(N2) ? $2 = ["(", "(", q2, X2 - V2] : ($2 = ["brackets", N2, q2, X2 - V2, q2, _2 - V2], X2 = _2);
                break;
              case h2:
                $2 = [")", ")", q2, X2 - V2];
                break;
              case t4:
              case r3:
                for (S2 = O2, _2 = X2, L2 = false; _2 < z2 && (++_2 === z2 && Y2("string"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), L2 || O2 !== S2); )
                  O2 === n2 ? L2 = !L2 : L2 ? L2 = false : O2 === b2 && P2 === d2 && K2();
                N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["string", G2.slice(X2, _2 + 1), q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2;
                break;
              case y2:
                C2.lastIndex = X2 + 1, C2.test(G2), _2 = C2.lastIndex === 0 ? G2.length - 1 : C2.lastIndex - 2, $2 = ["at-word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], X2 = _2;
                break;
              case n2:
                for (_2 = X2, M2 = true; G2.charCodeAt(_2 + 1) === n2; )
                  _2 += 1, M2 = !M2;
                if (O2 = G2.charCodeAt(_2 + 1), M2 && O2 !== o2 && O2 !== s2 && O2 !== i2 && O2 !== a2 && O2 !== c2 && O2 !== u2 && (_2 += 1, x2.test(G2.charAt(_2)))) {
                  for (; x2.test(G2.charAt(_2 + 1)); )
                    _2 += 1;
                  G2.charCodeAt(_2 + 1) === s2 && (_2 += 1);
                }
                $2 = ["word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], X2 = _2;
                break;
              default:
                P2 = G2.charCodeAt(X2 + 1), O2 === b2 && P2 === d2 ? (_2 = X2, K2(), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["word", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === m2 ? ((_2 = G2.indexOf("*/", X2 + 2) + 1) === 0 && (W2 ? _2 = G2.length : Y2("comment")), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["comment", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === o2 ? (A2.lastIndex = X2 + 1, A2.test(G2), _2 = A2.lastIndex === 0 ? G2.length - 1 : A2.lastIndex - 2, N2 = G2.slice(X2, _2 + 1), $2 = ["comment", N2, q2, X2 - V2, q2, _2 - V2, "inline"], X2 = _2) : (E2.lastIndex = X2 + 1, E2.test(G2), _2 = E2.lastIndex === 0 ? G2.length - 1 : E2.lastIndex - 2, $2 = ["word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], J2.push($2), X2 = _2);
            }
            return X2++, $2;
          }
        }, endOfFile: function() {
          return H2.length === 0 && X2 >= z2;
        }};
      };
    }, 1264: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2 = m2(r3(2566)), o2 = m2(r3(616)), i2 = m2(r3(7835)), s2 = m2(r3(478)), u2 = m2(r3(4907)), a2 = m2(r3(8420)), c2 = m2(r3(7523)), l2 = m2(r3(4316)), f2 = m2(r3(6909)), p2 = m2(r3(6279)), h2 = m2(r3(439)), d2 = m2(r3(9956)), D2 = m2(r3(70)), g2 = function(e23) {
        if (e23 && e23.__esModule)
          return e23;
        var t5 = {};
        if (e23 != null)
          for (var r4 in e23)
            Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
        return t5.default = e23, t5;
      }(r3(8790));
      function m2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      var v2 = function(e23) {
        return new n2.default(e23);
      };
      v2.attribute = function(e23) {
        return new o2.default(e23);
      }, v2.className = function(e23) {
        return new i2.default(e23);
      }, v2.combinator = function(e23) {
        return new s2.default(e23);
      }, v2.comment = function(e23) {
        return new u2.default(e23);
      }, v2.id = function(e23) {
        return new a2.default(e23);
      }, v2.nesting = function(e23) {
        return new c2.default(e23);
      }, v2.pseudo = function(e23) {
        return new l2.default(e23);
      }, v2.root = function(e23) {
        return new f2.default(e23);
      }, v2.selector = function(e23) {
        return new p2.default(e23);
      }, v2.string = function(e23) {
        return new h2.default(e23);
      }, v2.tag = function(e23) {
        return new d2.default(e23);
      }, v2.universal = function(e23) {
        return new D2.default(e23);
      }, Object.keys(g2).forEach(function(e23) {
        e23 !== "__esModule" && (v2[e23] = g2[e23]);
      }), t4.default = v2, e22.exports = t4.default;
    }, 5269: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2 = function() {
        function e23(e24, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
          }
        }
        return function(t5, r4, n3) {
          return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
        };
      }(), o2 = C2(r3(8051)), i2 = C2(r3(7886)), s2 = C2(r3(3210)), u2 = C2(r3(6909)), a2 = C2(r3(6279)), c2 = C2(r3(7835)), l2 = C2(r3(4907)), f2 = C2(r3(8420)), p2 = C2(r3(9956)), h2 = C2(r3(439)), d2 = C2(r3(4316)), D2 = C2(r3(616)), g2 = C2(r3(70)), m2 = C2(r3(478)), v2 = C2(r3(7523)), y2 = C2(r3(9788)), w2 = C2(r3(6554)), b2 = function(e23) {
        if (e23 && e23.__esModule)
          return e23;
        var t5 = {};
        if (e23 != null)
          for (var r4 in e23)
            Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
        return t5.default = e23, t5;
      }(r3(8790));
      function C2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      var E2 = function() {
        function e23(t5) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, e23), this.input = t5, this.lossy = t5.options.lossless === false, this.position = 0, this.root = new u2.default();
          var r4 = new a2.default();
          return this.root.append(r4), this.current = r4, this.lossy ? this.tokens = (0, w2.default)({safe: t5.safe, css: t5.css.trim()}) : this.tokens = (0, w2.default)(t5), this.loop();
        }
        return e23.prototype.attribute = function() {
          var e24 = "", t5 = void 0, r4 = this.currToken;
          for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
            e24 += this.tokens[this.position][1], this.position++;
          this.position !== this.tokens.length || ~e24.indexOf("]") || this.error("Expected a closing square bracket.");
          var n3 = e24.split(/((?:[*~^$|]?=))([^]*)/), o3 = n3[0].split(/(\|)/g), i3 = {operator: n3[1], value: n3[2], source: {start: {line: r4[2], column: r4[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: r4[4]};
          if (o3.length > 1 ? (o3[0] === "" && (o3[0] = true), i3.attribute = this.parseValue(o3[2]), i3.namespace = this.parseNamespace(o3[0])) : i3.attribute = this.parseValue(n3[0]), t5 = new D2.default(i3), n3[2]) {
            var s3 = n3[2].split(/(\s+i\s*?)$/), u3 = s3[0].trim();
            t5.value = this.lossy ? u3 : s3[0], s3[1] && (t5.insensitive = true, this.lossy || (t5.raws.insensitive = s3[1])), t5.quoted = u3[0] === "'" || u3[0] === '"', t5.raws.unquoted = t5.quoted ? u3.slice(1, -1) : u3;
          }
          this.newNode(t5), this.position++;
        }, e23.prototype.combinator = function() {
          if (this.currToken[1] === "|")
            return this.namespace();
          for (var e24 = new m2.default({value: "", source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]}); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
            this.nextToken && this.nextToken[0] === "combinator" ? (e24.spaces.before = this.parseSpace(this.currToken[1]), e24.source.start.line = this.nextToken[2], e24.source.start.column = this.nextToken[3], e24.source.end.column = this.nextToken[3], e24.source.end.line = this.nextToken[2], e24.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? e24.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? e24.value = this.currToken[1] : this.currToken[0] === "space" && (e24.value = this.parseSpace(this.currToken[1], " ")), this.position++;
          return this.newNode(e24);
        }, e23.prototype.comma = function() {
          if (this.position === this.tokens.length - 1)
            return this.root.trailingComma = true, void this.position++;
          var e24 = new a2.default();
          this.current.parent.append(e24), this.current = e24, this.position++;
        }, e23.prototype.comment = function() {
          var e24 = new l2.default({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[4], column: this.currToken[5]}}, sourceIndex: this.currToken[6]});
          this.newNode(e24), this.position++;
        }, e23.prototype.error = function(e24) {
          throw new this.input.error(e24);
        }, e23.prototype.missingBackslash = function() {
          return this.error("Expected a backslash preceding the semicolon.");
        }, e23.prototype.missingParenthesis = function() {
          return this.error("Expected opening parenthesis.");
        }, e23.prototype.missingSquareBracket = function() {
          return this.error("Expected opening square bracket.");
        }, e23.prototype.namespace = function() {
          var e24 = this.prevToken && this.prevToken[1] || true;
          return this.nextToken[0] === "word" ? (this.position++, this.word(e24)) : this.nextToken[0] === "*" ? (this.position++, this.universal(e24)) : void 0;
        }, e23.prototype.nesting = function() {
          this.newNode(new v2.default({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]})), this.position++;
        }, e23.prototype.parentheses = function() {
          var e24 = this.current.last;
          if (e24 && e24.type === b2.PSEUDO) {
            var t5 = new a2.default(), r4 = this.current;
            e24.append(t5), this.current = t5;
            var n3 = 1;
            for (this.position++; this.position < this.tokens.length && n3; )
              this.currToken[0] === "(" && n3++, this.currToken[0] === ")" && n3--, n3 ? this.parse() : (t5.parent.source.end.line = this.currToken[2], t5.parent.source.end.column = this.currToken[3], this.position++);
            n3 && this.error("Expected closing parenthesis."), this.current = r4;
          } else {
            var o3 = 1;
            for (this.position++, e24.value += "("; this.position < this.tokens.length && o3; )
              this.currToken[0] === "(" && o3++, this.currToken[0] === ")" && o3--, e24.value += this.parseParenthesisToken(this.currToken), this.position++;
            o3 && this.error("Expected closing parenthesis.");
          }
        }, e23.prototype.pseudo = function() {
          for (var e24 = this, t5 = "", r4 = this.currToken; this.currToken && this.currToken[0] === ":"; )
            t5 += this.currToken[1], this.position++;
          if (!this.currToken)
            return this.error("Expected pseudo-class or pseudo-element");
          if (this.currToken[0] === "word") {
            var n3 = void 0;
            this.splitWord(false, function(o3, i3) {
              t5 += o3, n3 = new d2.default({value: t5, source: {start: {line: r4[2], column: r4[3]}, end: {line: e24.currToken[4], column: e24.currToken[5]}}, sourceIndex: r4[4]}), e24.newNode(n3), i3 > 1 && e24.nextToken && e24.nextToken[0] === "(" && e24.error("Misplaced parenthesis.");
            });
          } else
            this.error('Unexpected "' + this.currToken[0] + '" found.');
        }, e23.prototype.space = function() {
          var e24 = this.currToken;
          this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(e24[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(e24[1]), this.position++) : this.combinator();
        }, e23.prototype.string = function() {
          var e24 = this.currToken;
          this.newNode(new h2.default({value: this.currToken[1], source: {start: {line: e24[2], column: e24[3]}, end: {line: e24[4], column: e24[5]}}, sourceIndex: e24[6]})), this.position++;
        }, e23.prototype.universal = function(e24) {
          var t5 = this.nextToken;
          if (t5 && t5[1] === "|")
            return this.position++, this.namespace();
          this.newNode(new g2.default({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]}), e24), this.position++;
        }, e23.prototype.splitWord = function(e24, t5) {
          for (var r4 = this, n3 = this.nextToken, u3 = this.currToken[1]; n3 && n3[0] === "word"; ) {
            this.position++;
            var a3 = this.currToken[1];
            if (u3 += a3, a3.lastIndexOf("\\") === a3.length - 1) {
              var l3 = this.nextToken;
              l3 && l3[0] === "space" && (u3 += this.parseSpace(l3[1], " "), this.position++);
            }
            n3 = this.nextToken;
          }
          var h3 = (0, i2.default)(u3, "."), d3 = (0, i2.default)(u3, "#"), D3 = (0, i2.default)(u3, "#{");
          D3.length && (d3 = d3.filter(function(e25) {
            return !~D3.indexOf(e25);
          }));
          var g3 = (0, y2.default)((0, s2.default)((0, o2.default)([[0], h3, d3])));
          g3.forEach(function(n4, o3) {
            var i3 = g3[o3 + 1] || u3.length, s3 = u3.slice(n4, i3);
            if (o3 === 0 && t5)
              return t5.call(r4, s3, g3.length);
            var a4 = void 0;
            a4 = ~h3.indexOf(n4) ? new c2.default({value: s3.slice(1), source: {start: {line: r4.currToken[2], column: r4.currToken[3] + n4}, end: {line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1)}}, sourceIndex: r4.currToken[6] + g3[o3]}) : ~d3.indexOf(n4) ? new f2.default({value: s3.slice(1), source: {start: {line: r4.currToken[2], column: r4.currToken[3] + n4}, end: {line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1)}}, sourceIndex: r4.currToken[6] + g3[o3]}) : new p2.default({value: s3, source: {start: {line: r4.currToken[2], column: r4.currToken[3] + n4}, end: {line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1)}}, sourceIndex: r4.currToken[6] + g3[o3]}), r4.newNode(a4, e24);
          }), this.position++;
        }, e23.prototype.word = function(e24) {
          var t5 = this.nextToken;
          return t5 && t5[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(e24);
        }, e23.prototype.loop = function() {
          for (; this.position < this.tokens.length; )
            this.parse(true);
          return this.root;
        }, e23.prototype.parse = function(e24) {
          switch (this.currToken[0]) {
            case "space":
              this.space();
              break;
            case "comment":
              this.comment();
              break;
            case "(":
              this.parentheses();
              break;
            case ")":
              e24 && this.missingParenthesis();
              break;
            case "[":
              this.attribute();
              break;
            case "]":
              this.missingSquareBracket();
              break;
            case "at-word":
            case "word":
              this.word();
              break;
            case ":":
              this.pseudo();
              break;
            case ";":
              this.missingBackslash();
              break;
            case ",":
              this.comma();
              break;
            case "*":
              this.universal();
              break;
            case "&":
              this.nesting();
              break;
            case "combinator":
              this.combinator();
              break;
            case "string":
              this.string();
          }
        }, e23.prototype.parseNamespace = function(e24) {
          if (this.lossy && typeof e24 == "string") {
            var t5 = e24.trim();
            return !t5.length || t5;
          }
          return e24;
        }, e23.prototype.parseSpace = function(e24, t5) {
          return this.lossy ? t5 || "" : e24;
        }, e23.prototype.parseValue = function(e24) {
          return this.lossy && e24 && typeof e24 == "string" ? e24.trim() : e24;
        }, e23.prototype.parseParenthesisToken = function(e24) {
          return this.lossy ? e24[0] === "space" ? this.parseSpace(e24[1], " ") : this.parseValue(e24[1]) : e24[1];
        }, e23.prototype.newNode = function(e24, t5) {
          return t5 && (e24.namespace = this.parseNamespace(t5)), this.spaces && (e24.spaces.before = this.spaces, this.spaces = ""), this.current.append(e24);
        }, n2(e23, [{key: "currToken", get: function() {
          return this.tokens[this.position];
        }}, {key: "nextToken", get: function() {
          return this.tokens[this.position + 1];
        }}, {key: "prevToken", get: function() {
          return this.tokens[this.position - 1];
        }}]), e23;
      }();
      t4.default = E2, e22.exports = t4.default;
    }, 2566: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = function() {
        function e23(e24, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
          }
        }
        return function(t5, r4, n3) {
          return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
        };
      }(), i2 = (n2 = r3(5269)) && n2.__esModule ? n2 : {default: n2}, s2 = function() {
        function e23(t5) {
          return function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, e23), this.func = t5 || function() {
          }, this;
        }
        return e23.prototype.process = function(e24) {
          var t5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r4 = new i2.default({css: e24, error: function(e25) {
            throw new Error(e25);
          }, options: t5});
          return this.res = r4, this.func(r4), this;
        }, o2(e23, [{key: "result", get: function() {
          return String(this.res);
        }}]), e23;
      }();
      t4.default = s2, e22.exports = t4.default;
    }, 616: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.ATTRIBUTE, n3.raws = {}, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5.prototype.toString = function() {
          var e24 = [this.spaces.before, "[", this.ns, this.attribute];
          return this.operator && e24.push(this.operator), this.value && e24.push(this.value), this.raws.insensitive ? e24.push(this.raws.insensitive) : this.insensitive && e24.push(" i"), e24.push("]"), e24.concat(this.spaces.after).join("");
        }, t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 7835: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.CLASS, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5.prototype.toString = function() {
          return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
        }, t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 478: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.COMBINATOR, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 4907: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.COMMENT, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 7144: (e22, t4, r3) => {
      r3(4070), t4.__esModule = true;
      var n2, o2 = function() {
        function e23(e24, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
          }
        }
        return function(t5, r4, n3) {
          return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
        };
      }(), i2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, s2 = function(e23) {
        if (e23 && e23.__esModule)
          return e23;
        var t5 = {};
        if (e23 != null)
          for (var r4 in e23)
            Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
        return t5.default = e23, t5;
      }(r3(8790)), u2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.nodes || (n3.nodes = []), n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5.prototype.append = function(e24) {
          return e24.parent = this, this.nodes.push(e24), this;
        }, t5.prototype.prepend = function(e24) {
          return e24.parent = this, this.nodes.unshift(e24), this;
        }, t5.prototype.at = function(e24) {
          return this.nodes[e24];
        }, t5.prototype.index = function(e24) {
          return typeof e24 == "number" ? e24 : this.nodes.indexOf(e24);
        }, t5.prototype.removeChild = function(e24) {
          e24 = this.index(e24), this.at(e24).parent = void 0, this.nodes.splice(e24, 1);
          var t6 = void 0;
          for (var r4 in this.indexes)
            (t6 = this.indexes[r4]) >= e24 && (this.indexes[r4] = t6 - 1);
          return this;
        }, t5.prototype.removeAll = function() {
          var e24 = this.nodes, t6 = Array.isArray(e24), r4 = 0;
          for (e24 = t6 ? e24 : e24[Symbol.iterator](); ; ) {
            var n3;
            if (t6) {
              if (r4 >= e24.length)
                break;
              n3 = e24[r4++];
            } else {
              if ((r4 = e24.next()).done)
                break;
              n3 = r4.value;
            }
            n3.parent = void 0;
          }
          return this.nodes = [], this;
        }, t5.prototype.empty = function() {
          return this.removeAll();
        }, t5.prototype.insertAfter = function(e24, t6) {
          var r4 = this.index(e24);
          this.nodes.splice(r4 + 1, 0, t6);
          var n3 = void 0;
          for (var o3 in this.indexes)
            r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
          return this;
        }, t5.prototype.insertBefore = function(e24, t6) {
          var r4 = this.index(e24);
          this.nodes.splice(r4, 0, t6);
          var n3 = void 0;
          for (var o3 in this.indexes)
            r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
          return this;
        }, t5.prototype.each = function(e24) {
          this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
          var t6 = this.lastEach;
          if (this.indexes[t6] = 0, this.length) {
            for (var r4 = void 0, n3 = void 0; this.indexes[t6] < this.length && (r4 = this.indexes[t6], (n3 = e24(this.at(r4), r4)) !== false); )
              this.indexes[t6] += 1;
            return delete this.indexes[t6], n3 !== false && void 0;
          }
        }, t5.prototype.walk = function(e24) {
          return this.each(function(t6, r4) {
            var n3 = e24(t6, r4);
            if (n3 !== false && t6.length && (n3 = t6.walk(e24)), n3 === false)
              return false;
          });
        }, t5.prototype.walkAttributes = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.ATTRIBUTE)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkClasses = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.CLASS)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkCombinators = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.COMBINATOR)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkComments = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.COMMENT)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkIds = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.ID)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkNesting = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.NESTING)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkPseudos = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.PSEUDO)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkTags = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.TAG)
              return e24.call(t6, r4);
          });
        }, t5.prototype.walkUniversals = function(e24) {
          var t6 = this;
          return this.walk(function(r4) {
            if (r4.type === s2.UNIVERSAL)
              return e24.call(t6, r4);
          });
        }, t5.prototype.split = function(e24) {
          var t6 = this, r4 = [];
          return this.reduce(function(n3, o3, i3) {
            var s3 = e24.call(t6, o3);
            return r4.push(o3), s3 ? (n3.push(r4), r4 = []) : i3 === t6.length - 1 && n3.push(r4), n3;
          }, []);
        }, t5.prototype.map = function(e24) {
          return this.nodes.map(e24);
        }, t5.prototype.reduce = function(e24, t6) {
          return this.nodes.reduce(e24, t6);
        }, t5.prototype.every = function(e24) {
          return this.nodes.every(e24);
        }, t5.prototype.some = function(e24) {
          return this.nodes.some(e24);
        }, t5.prototype.filter = function(e24) {
          return this.nodes.filter(e24);
        }, t5.prototype.sort = function(e24) {
          return this.nodes.sort(e24);
        }, t5.prototype.toString = function() {
          return this.map(String).join("");
        }, o2(t5, [{key: "first", get: function() {
          return this.at(0);
        }}, {key: "last", get: function() {
          return this.at(this.length - 1);
        }}, {key: "length", get: function() {
          return this.nodes.length;
        }}]), t5;
      }(i2.default);
      t4.default = u2, e22.exports = t4.default;
    }, 8420: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.ID, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5.prototype.toString = function() {
          return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
        }, t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 4379: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = function() {
        function e23(e24, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
          }
        }
        return function(t5, r4, n3) {
          return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
        };
      }();
      function i2(e23, t5) {
        if (!(e23 instanceof t5))
          throw new TypeError("Cannot call a class as a function");
      }
      function s2(e23, t5) {
        if (!e23)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t5 || typeof t5 != "object" && typeof t5 != "function" ? e23 : t5;
      }
      var u2 = function(e23) {
        function t5() {
          return i2(this, t5), s2(this, e23.apply(this, arguments));
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5.prototype.toString = function() {
          return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
        }, o2(t5, [{key: "ns", get: function() {
          var e24 = this.namespace;
          return e24 ? (typeof e24 == "string" ? e24 : "") + "|" : "";
        }}]), t5;
      }(((n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}).default);
      t4.default = u2, e22.exports = t4.default;
    }, 7523: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.NESTING, n3.value = "&", n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 8871: (e22, t4) => {
      t4.__esModule = true;
      var r3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e23) {
        return typeof e23;
      } : function(e23) {
        return e23 && typeof Symbol == "function" && e23.constructor === Symbol && e23 !== Symbol.prototype ? "symbol" : typeof e23;
      };
      function n2(e23, t5) {
        if (!(e23 instanceof t5))
          throw new TypeError("Cannot call a class as a function");
      }
      var o2 = function e23(t5, n3) {
        if ((t5 === void 0 ? "undefined" : r3(t5)) !== "object")
          return t5;
        var o3 = new t5.constructor();
        for (var i3 in t5)
          if (t5.hasOwnProperty(i3)) {
            var s2 = t5[i3], u2 = s2 === void 0 ? "undefined" : r3(s2);
            i3 === "parent" && u2 === "object" ? n3 && (o3[i3] = n3) : o3[i3] = s2 instanceof Array ? s2.map(function(t6) {
              return e23(t6, o3);
            }) : e23(s2, o3);
          }
        return o3;
      }, i2 = function() {
        function e23() {
          var t5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          for (var r4 in n2(this, e23), t5)
            this[r4] = t5[r4];
          var o3 = t5.spaces, i3 = (o3 = o3 === void 0 ? {} : o3).before, s2 = i3 === void 0 ? "" : i3, u2 = o3.after, a2 = u2 === void 0 ? "" : u2;
          this.spaces = {before: s2, after: a2};
        }
        return e23.prototype.remove = function() {
          return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }, e23.prototype.replaceWith = function() {
          if (this.parent) {
            for (var e24 in arguments)
              this.parent.insertBefore(this, arguments[e24]);
            this.remove();
          }
          return this;
        }, e23.prototype.next = function() {
          return this.parent.at(this.parent.index(this) + 1);
        }, e23.prototype.prev = function() {
          return this.parent.at(this.parent.index(this) - 1);
        }, e23.prototype.clone = function() {
          var e24 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t5 = o2(this);
          for (var r4 in e24)
            t5[r4] = e24[r4];
          return t5;
        }, e23.prototype.toString = function() {
          return [this.spaces.before, String(this.value), this.spaces.after].join("");
        }, e23;
      }();
      t4.default = i2, e22.exports = t4.default;
    }, 4316: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.PSEUDO, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5.prototype.toString = function() {
          var e24 = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.spaces.before, String(this.value), e24, this.spaces.after].join("");
        }, t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 6909: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.ROOT, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5.prototype.toString = function() {
          var e24 = this.reduce(function(e25, t6) {
            var r4 = String(t6);
            return r4 ? e25 + r4 + "," : "";
          }, "").slice(0, -1);
          return this.trailingComma ? e24 + "," : e24;
        }, t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 6279: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.SELECTOR, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 439: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.STRING, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 9956: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.TAG, n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 8790: (e22, t4) => {
      t4.__esModule = true, t4.TAG = "tag", t4.STRING = "string", t4.SELECTOR = "selector", t4.ROOT = "root", t4.PSEUDO = "pseudo", t4.NESTING = "nesting", t4.ID = "id", t4.COMMENT = "comment", t4.COMBINATOR = "combinator", t4.CLASS = "class", t4.ATTRIBUTE = "attribute", t4.UNIVERSAL = "universal";
    }, 70: (e22, t4, r3) => {
      t4.__esModule = true;
      var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
        function t5(r4) {
          !function(e24, t6) {
            if (!(e24 instanceof t6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t5);
          var n3 = function(e24, t6) {
            if (!e24)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
          }(this, e23.call(this, r4));
          return n3.type = i2.UNIVERSAL, n3.value = "*", n3;
        }
        return function(e24, t6) {
          if (typeof t6 != "function" && t6 !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
          e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
        }(t5, e23), t5;
      }(o2.default);
      t4.default = s2, e22.exports = t4.default;
    }, 9788: (e22, t4, r3) => {
      r3(4070), t4.__esModule = true, t4.default = function(e23) {
        return e23.sort(function(e24, t5) {
          return e24 - t5;
        });
      }, e22.exports = t4.default;
    }, 6554: (e22, t4) => {
      t4.__esModule = true, t4.default = function(e23) {
        for (var t5 = [], o2 = e23.css.valueOf(), i2 = void 0, s2 = void 0, u2 = void 0, a2 = void 0, c2 = void 0, l2 = void 0, f2 = void 0, p2 = void 0, h2 = void 0, d2 = void 0, D2 = void 0, g2 = o2.length, m2 = -1, v2 = 1, y2 = 0, w2 = function(t6, r4) {
          if (!e23.safe)
            throw e23.error("Unclosed " + t6, v2, y2 - m2, y2);
          s2 = (o2 += r4).length - 1;
        }; y2 < g2; ) {
          switch ((i2 = o2.charCodeAt(y2)) === 10 && (m2 = y2, v2 += 1), i2) {
            case 10:
            case 32:
            case 9:
            case 13:
            case 12:
              s2 = y2;
              do {
                s2 += 1, (i2 = o2.charCodeAt(s2)) === 10 && (m2 = s2, v2 += 1);
              } while (i2 === 32 || i2 === 10 || i2 === 9 || i2 === 13 || i2 === 12);
              t5.push(["space", o2.slice(y2, s2), v2, y2 - m2, y2]), y2 = s2 - 1;
              break;
            case 43:
            case 62:
            case 126:
            case 124:
              s2 = y2;
              do {
                s2 += 1, i2 = o2.charCodeAt(s2);
              } while (i2 === 43 || i2 === 62 || i2 === 126 || i2 === 124);
              t5.push(["combinator", o2.slice(y2, s2), v2, y2 - m2, y2]), y2 = s2 - 1;
              break;
            case 42:
              t5.push(["*", "*", v2, y2 - m2, y2]);
              break;
            case 38:
              t5.push(["&", "&", v2, y2 - m2, y2]);
              break;
            case 44:
              t5.push([",", ",", v2, y2 - m2, y2]);
              break;
            case 91:
              t5.push(["[", "[", v2, y2 - m2, y2]);
              break;
            case 93:
              t5.push(["]", "]", v2, y2 - m2, y2]);
              break;
            case 58:
              t5.push([":", ":", v2, y2 - m2, y2]);
              break;
            case 59:
              t5.push([";", ";", v2, y2 - m2, y2]);
              break;
            case 40:
              t5.push(["(", "(", v2, y2 - m2, y2]);
              break;
            case 41:
              t5.push([")", ")", v2, y2 - m2, y2]);
              break;
            case 39:
            case 34:
              u2 = i2 === 39 ? "'" : '"', s2 = y2;
              do {
                for (d2 = false, (s2 = o2.indexOf(u2, s2 + 1)) === -1 && w2("quote", u2), D2 = s2; o2.charCodeAt(D2 - 1) === 92; )
                  D2 -= 1, d2 = !d2;
              } while (d2);
              t5.push(["string", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
              break;
            case 64:
              r3.lastIndex = y2 + 1, r3.test(o2), s2 = r3.lastIndex === 0 ? o2.length - 1 : r3.lastIndex - 2, t5.push(["at-word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
              break;
            case 92:
              for (s2 = y2, f2 = true; o2.charCodeAt(s2 + 1) === 92; )
                s2 += 1, f2 = !f2;
              i2 = o2.charCodeAt(s2 + 1), f2 && i2 !== 47 && i2 !== 32 && i2 !== 10 && i2 !== 9 && i2 !== 13 && i2 !== 12 && (s2 += 1), t5.push(["word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
              break;
            default:
              i2 === 47 && o2.charCodeAt(y2 + 1) === 42 ? ((s2 = o2.indexOf("*/", y2 + 2) + 1) === 0 && w2("comment", "*/"), (c2 = (a2 = (l2 = o2.slice(y2, s2 + 1)).split("\n")).length - 1) > 0 ? (p2 = v2 + c2, h2 = s2 - a2[c2].length) : (p2 = v2, h2 = m2), t5.push(["comment", l2, v2, y2 - m2, p2, s2 - h2, y2]), m2 = h2, v2 = p2, y2 = s2) : (n2.lastIndex = y2 + 1, n2.test(o2), s2 = n2.lastIndex === 0 ? o2.length - 1 : n2.lastIndex - 2, t5.push(["word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2);
          }
          y2++;
        }
        return t5;
      };
      var r3 = /[ \n\t\r\{\(\)'"\\;/]/g, n2 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
      e22.exports = t4.default;
    }, 5294: (e22, t4, r3) => {
      const n2 = r3(4196);
      class o2 extends n2 {
        constructor(e23) {
          super(e23), this.type = "atword";
        }
        toString() {
          return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
        }
      }
      n2.registerWalker(o2), e22.exports = o2;
    }, 8709: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "colon";
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 3627: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "comma";
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 4384: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "comment", this.inline = Object(e23).inline || false;
        }
        toString() {
          return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 4196: (e22, t4, r3) => {
      const n2 = r3(1466);
      class o2 extends n2 {
        constructor(e23) {
          super(e23), this.nodes || (this.nodes = []);
        }
        push(e23) {
          return e23.parent = this, this.nodes.push(e23), this;
        }
        each(e23) {
          this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
          let t5, r4, n3 = this.lastEach;
          if (this.indexes[n3] = 0, this.nodes) {
            for (; this.indexes[n3] < this.nodes.length && (t5 = this.indexes[n3], r4 = e23(this.nodes[t5], t5), r4 !== false); )
              this.indexes[n3] += 1;
            return delete this.indexes[n3], r4;
          }
        }
        walk(e23) {
          return this.each((t5, r4) => {
            let n3 = e23(t5, r4);
            return n3 !== false && t5.walk && (n3 = t5.walk(e23)), n3;
          });
        }
        walkType(e23, t5) {
          if (!e23 || !t5)
            throw new Error("Parameters {type} and {callback} are required.");
          const r4 = typeof e23 == "function";
          return this.walk((n3, o3) => {
            if (r4 && n3 instanceof e23 || !r4 && n3.type === e23)
              return t5.call(this, n3, o3);
          });
        }
        append(e23) {
          return e23.parent = this, this.nodes.push(e23), this;
        }
        prepend(e23) {
          return e23.parent = this, this.nodes.unshift(e23), this;
        }
        cleanRaws(e23) {
          if (super.cleanRaws(e23), this.nodes)
            for (let t5 of this.nodes)
              t5.cleanRaws(e23);
        }
        insertAfter(e23, t5) {
          let r4, n3 = this.index(e23);
          this.nodes.splice(n3 + 1, 0, t5);
          for (let e24 in this.indexes)
            r4 = this.indexes[e24], n3 <= r4 && (this.indexes[e24] = r4 + this.nodes.length);
          return this;
        }
        insertBefore(e23, t5) {
          let r4, n3 = this.index(e23);
          this.nodes.splice(n3, 0, t5);
          for (let e24 in this.indexes)
            r4 = this.indexes[e24], n3 <= r4 && (this.indexes[e24] = r4 + this.nodes.length);
          return this;
        }
        removeChild(e23) {
          let t5;
          e23 = this.index(e23), this.nodes[e23].parent = void 0, this.nodes.splice(e23, 1);
          for (let r4 in this.indexes)
            t5 = this.indexes[r4], t5 >= e23 && (this.indexes[r4] = t5 - 1);
          return this;
        }
        removeAll() {
          for (let e23 of this.nodes)
            e23.parent = void 0;
          return this.nodes = [], this;
        }
        every(e23) {
          return this.nodes.every(e23);
        }
        some(e23) {
          return this.nodes.some(e23);
        }
        index(e23) {
          return typeof e23 == "number" ? e23 : this.nodes.indexOf(e23);
        }
        get first() {
          if (this.nodes)
            return this.nodes[0];
        }
        get last() {
          if (this.nodes)
            return this.nodes[this.nodes.length - 1];
        }
        toString() {
          let e23 = this.nodes.map(String).join("");
          return this.value && (e23 = this.value + e23), this.raws.before && (e23 = this.raws.before + e23), this.raws.after && (e23 += this.raws.after), e23;
        }
      }
      o2.registerWalker = (e23) => {
        let t5 = "walk" + e23.name;
        t5.lastIndexOf("s") !== t5.length - 1 && (t5 += "s"), o2.prototype[t5] || (o2.prototype[t5] = function(t6) {
          return this.walkType(e23, t6);
        });
      }, e22.exports = o2;
    }, 9645: (e22) => {
      class t4 extends Error {
        constructor(e23) {
          super(e23), this.name = this.constructor.name, this.message = e23 || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e23).stack;
        }
      }
      e22.exports = t4;
    }, 5128: (e22) => {
      class t4 extends Error {
        constructor(e23) {
          super(e23), this.name = this.constructor.name, this.message = e23 || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e23).stack;
        }
      }
      e22.exports = t4;
    }, 4320: (e22, t4, r3) => {
      const n2 = r3(4196);
      class o2 extends n2 {
        constructor(e23) {
          super(e23), this.type = "func", this.unbalanced = -1;
        }
      }
      n2.registerWalker(o2), e22.exports = o2;
    }, 9962: (e22, t4, r3) => {
      const n2 = r3(3784), o2 = r3(5294), i2 = r3(8709), s2 = r3(3627), u2 = r3(4384), a2 = r3(4320), c2 = r3(3074), l2 = r3(7214), f2 = r3(1238), p2 = r3(9672), h2 = r3(1369), d2 = r3(2057), D2 = r3(6593);
      let g2 = function(e23, t5) {
        return new n2(e23, t5);
      };
      g2.atword = function(e23) {
        return new o2(e23);
      }, g2.colon = function(e23) {
        return new i2(Object.assign({value: ":"}, e23));
      }, g2.comma = function(e23) {
        return new s2(Object.assign({value: ","}, e23));
      }, g2.comment = function(e23) {
        return new u2(e23);
      }, g2.func = function(e23) {
        return new a2(e23);
      }, g2.number = function(e23) {
        return new c2(e23);
      }, g2.operator = function(e23) {
        return new l2(e23);
      }, g2.paren = function(e23) {
        return new f2(Object.assign({value: "("}, e23));
      }, g2.string = function(e23) {
        return new p2(Object.assign({quote: "'"}, e23));
      }, g2.value = function(e23) {
        return new d2(e23);
      }, g2.word = function(e23) {
        return new D2(e23);
      }, g2.unicodeRange = function(e23) {
        return new h2(e23);
      }, e22.exports = g2;
    }, 1466: (e22) => {
      let t4 = function(e23, r3) {
        let n2 = new e23.constructor();
        for (let o2 in e23) {
          if (!e23.hasOwnProperty(o2))
            continue;
          let i2 = e23[o2], s2 = typeof i2;
          o2 === "parent" && s2 === "object" ? r3 && (n2[o2] = r3) : o2 === "source" ? n2[o2] = i2 : i2 instanceof Array ? n2[o2] = i2.map((e24) => t4(e24, n2)) : o2 !== "before" && o2 !== "after" && o2 !== "between" && o2 !== "semicolon" && (s2 === "object" && i2 !== null && (i2 = t4(i2)), n2[o2] = i2);
        }
        return n2;
      };
      e22.exports = class {
        constructor(e23) {
          e23 = e23 || {}, this.raws = {before: "", after: ""};
          for (let t5 in e23)
            this[t5] = e23[t5];
        }
        remove() {
          return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }
        toString() {
          return [this.raws.before, String(this.value), this.raws.after].join("");
        }
        clone(e23) {
          e23 = e23 || {};
          let r3 = t4(this);
          for (let t5 in e23)
            r3[t5] = e23[t5];
          return r3;
        }
        cloneBefore(e23) {
          e23 = e23 || {};
          let t5 = this.clone(e23);
          return this.parent.insertBefore(this, t5), t5;
        }
        cloneAfter(e23) {
          e23 = e23 || {};
          let t5 = this.clone(e23);
          return this.parent.insertAfter(this, t5), t5;
        }
        replaceWith() {
          let e23 = Array.prototype.slice.call(arguments);
          if (this.parent) {
            for (let t5 of e23)
              this.parent.insertBefore(this, t5);
            this.remove();
          }
          return this;
        }
        moveTo(e23) {
          return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.append(this), this;
        }
        moveBefore(e23) {
          return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.parent.insertBefore(e23, this), this;
        }
        moveAfter(e23) {
          return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.parent.insertAfter(e23, this), this;
        }
        next() {
          let e23 = this.parent.index(this);
          return this.parent.nodes[e23 + 1];
        }
        prev() {
          let e23 = this.parent.index(this);
          return this.parent.nodes[e23 - 1];
        }
        toJSON() {
          let e23 = {};
          for (let t5 in this) {
            if (!this.hasOwnProperty(t5))
              continue;
            if (t5 === "parent")
              continue;
            let r3 = this[t5];
            r3 instanceof Array ? e23[t5] = r3.map((e24) => typeof e24 == "object" && e24.toJSON ? e24.toJSON() : e24) : typeof r3 == "object" && r3.toJSON ? e23[t5] = r3.toJSON() : e23[t5] = r3;
          }
          return e23;
        }
        root() {
          let e23 = this;
          for (; e23.parent; )
            e23 = e23.parent;
          return e23;
        }
        cleanRaws(e23) {
          delete this.raws.before, delete this.raws.after, e23 || delete this.raws.between;
        }
        positionInside(e23) {
          let t5 = this.toString(), r3 = this.source.start.column, n2 = this.source.start.line;
          for (let o2 = 0; o2 < e23; o2++)
            t5[o2] === "\n" ? (r3 = 1, n2 += 1) : r3 += 1;
          return {line: n2, column: r3};
        }
        positionBy(e23) {
          let t5 = this.source.start;
          if (Object(e23).index)
            t5 = this.positionInside(e23.index);
          else if (Object(e23).word) {
            let r3 = this.toString().indexOf(e23.word);
            r3 !== -1 && (t5 = this.positionInside(r3));
          }
          return t5;
        }
      };
    }, 3074: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "number", this.unit = Object(e23).unit || "";
        }
        toString() {
          return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 7214: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "operator";
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 1238: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "paren", this.parenType = "";
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 3784: (e22, t4, r3) => {
      r3(4070);
      const n2 = r3(4343), o2 = r3(2057), i2 = r3(5294), s2 = r3(8709), u2 = r3(3627), a2 = r3(4384), c2 = r3(4320), l2 = r3(3074), f2 = r3(7214), p2 = r3(1238), h2 = r3(9672), d2 = r3(6593), D2 = r3(1369), g2 = r3(2481), m2 = r3(8051), v2 = r3(7886), y2 = r3(3210), w2 = r3(9645);
      e22.exports = class {
        constructor(e23, t5) {
          this.cache = [], this.input = e23, this.options = Object.assign({}, {loose: false}, t5), this.position = 0, this.unbalanced = 0, this.root = new n2();
          let r4 = new o2();
          this.root.append(r4), this.current = r4, this.tokens = g2(e23, this.options);
        }
        parse() {
          return this.loop();
        }
        colon() {
          let e23 = this.currToken;
          this.newNode(new s2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++;
        }
        comma() {
          let e23 = this.currToken;
          this.newNode(new u2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++;
        }
        comment() {
          let e23, t5 = false, r4 = this.currToken[1].replace(/\/\*|\*\//g, "");
          this.options.loose && r4.startsWith("//") && (r4 = r4.substring(2), t5 = true), e23 = new a2({value: r4, inline: t5, source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[4], column: this.currToken[5]}}, sourceIndex: this.currToken[6]}), this.newNode(e23), this.position++;
        }
        error(e23, t5) {
          throw new w2(e23 + ` at line: ${t5[2]}, column ${t5[3]}`);
        }
        loop() {
          for (; this.position < this.tokens.length; )
            this.parseTokens();
          return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
        }
        operator() {
          let e23, t5 = this.currToken[1];
          if (t5 === "+" || t5 === "-") {
            if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? (this.prevToken[0] !== "space" && this.prevToken[0] !== "(" || this.nextToken[0] !== "space" && this.nextToken[0] !== "word" || this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(") && this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "operator" && this.prevToken[0] !== "operator" || this.error("Syntax Error", this.currToken)), this.options.loose) {
              if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
                return this.word();
            } else if (this.nextToken[0] === "word")
              return this.word();
          }
          return e23 = new f2({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]}), this.position++, this.newNode(e23);
        }
        parseTokens() {
          switch (this.currToken[0]) {
            case "space":
              this.space();
              break;
            case "colon":
              this.colon();
              break;
            case "comma":
              this.comma();
              break;
            case "comment":
              this.comment();
              break;
            case "(":
              this.parenOpen();
              break;
            case ")":
              this.parenClose();
              break;
            case "atword":
            case "word":
              this.word();
              break;
            case "operator":
              this.operator();
              break;
            case "string":
              this.string();
              break;
            case "unicoderange":
              this.unicodeRange();
              break;
            default:
              this.word();
          }
        }
        parenOpen() {
          let e23, t5 = 1, r4 = this.position + 1, n3 = this.currToken;
          for (; r4 < this.tokens.length && t5; ) {
            let e24 = this.tokens[r4];
            e24[0] === "(" && t5++, e24[0] === ")" && t5--, r4++;
          }
          if (t5 && this.error("Expected closing parenthesis", n3), e23 = this.current.last, e23 && e23.type === "func" && e23.unbalanced < 0 && (e23.unbalanced = 0, this.current = e23), this.current.unbalanced++, this.newNode(new p2({value: n3[1], source: {start: {line: n3[2], column: n3[3]}, end: {line: n3[4], column: n3[5]}}, sourceIndex: n3[6]})), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
            let e24 = this.nextToken, t6 = this.currToken[1], r5 = {line: this.currToken[2], column: this.currToken[3]};
            for (; e24 && e24[0] !== ")" && this.current.unbalanced; )
              this.position++, t6 += this.currToken[1], e24 = this.nextToken;
            this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d2({value: t6, source: {start: r5, end: {line: this.currToken[4], column: this.currToken[5]}}, sourceIndex: this.currToken[6]})));
          }
        }
        parenClose() {
          let e23 = this.currToken;
          this.newNode(new p2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++, this.position >= this.tokens.length - 1 && !this.current.unbalanced || (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e23), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
        }
        space() {
          let e23 = this.currToken;
          this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += e23[1], this.position++) : (this.spaces = e23[1], this.position++);
        }
        unicodeRange() {
          let e23 = this.currToken;
          this.newNode(new D2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++;
        }
        splitWord() {
          let e23, t5, r4 = this.nextToken, n3 = this.currToken[1], o3 = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
          if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(n3))
            for (; r4 && r4[0] === "word"; ) {
              this.position++;
              let e24 = this.currToken[1];
              n3 += e24, r4 = this.nextToken;
            }
          var s3;
          e23 = v2(n3, "@"), s3 = y2(m2([[0], e23])), t5 = s3.sort((e24, t6) => e24 - t6), t5.forEach((s4, u3) => {
            let a3, f3 = t5[u3 + 1] || n3.length, p3 = n3.slice(s4, f3);
            if (~e23.indexOf(s4))
              a3 = new i2({value: p3.slice(1), source: {start: {line: this.currToken[2], column: this.currToken[3] + s4}, end: {line: this.currToken[4], column: this.currToken[3] + (f3 - 1)}}, sourceIndex: this.currToken[6] + t5[u3]});
            else if (o3.test(this.currToken[1])) {
              let e24 = p3.replace(o3, "");
              a3 = new l2({value: p3.replace(e24, ""), source: {start: {line: this.currToken[2], column: this.currToken[3] + s4}, end: {line: this.currToken[4], column: this.currToken[3] + (f3 - 1)}}, sourceIndex: this.currToken[6] + t5[u3], unit: e24});
            } else
              a3 = new (r4 && r4[0] === "(" ? c2 : d2)({value: p3, source: {start: {line: this.currToken[2], column: this.currToken[3] + s4}, end: {line: this.currToken[4], column: this.currToken[3] + (f3 - 1)}}, sourceIndex: this.currToken[6] + t5[u3]}), a3.constructor.name === "Word" ? (a3.isHex = /^#(.+)/.test(p3), a3.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(p3)) : this.cache.push(this.current);
            this.newNode(a3);
          }), this.position++;
        }
        string() {
          let e23, t5 = this.currToken, r4 = this.currToken[1], n3 = /^(\"|\')/, o3 = n3.test(r4), i3 = "";
          o3 && (i3 = r4.match(n3)[0], r4 = r4.slice(1, r4.length - 1)), e23 = new h2({value: r4, source: {start: {line: t5[2], column: t5[3]}, end: {line: t5[4], column: t5[5]}}, sourceIndex: t5[6], quoted: o3}), e23.raws.quote = i3, this.newNode(e23), this.position++;
        }
        word() {
          return this.splitWord();
        }
        newNode(e23) {
          return this.spaces && (e23.raws.before += this.spaces, this.spaces = ""), this.current.append(e23);
        }
        get currToken() {
          return this.tokens[this.position];
        }
        get nextToken() {
          return this.tokens[this.position + 1];
        }
        get prevToken() {
          return this.tokens[this.position - 1];
        }
      };
    }, 4343: (e22, t4, r3) => {
      const n2 = r3(4196);
      e22.exports = class extends n2 {
        constructor(e23) {
          super(e23), this.type = "root";
        }
      };
    }, 9672: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "string";
        }
        toString() {
          let e23 = this.quoted ? this.raws.quote : "";
          return [this.raws.before, e23, this.value + "", e23, this.raws.after].join("");
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 2481: (e22, t4, r3) => {
      const n2 = "{".charCodeAt(0), o2 = "}".charCodeAt(0), i2 = "(".charCodeAt(0), s2 = ")".charCodeAt(0), u2 = "'".charCodeAt(0), a2 = '"'.charCodeAt(0), c2 = "\\".charCodeAt(0), l2 = "/".charCodeAt(0), f2 = ".".charCodeAt(0), p2 = ",".charCodeAt(0), h2 = ":".charCodeAt(0), d2 = "*".charCodeAt(0), D2 = "-".charCodeAt(0), g2 = "+".charCodeAt(0), m2 = "#".charCodeAt(0), v2 = "\n".charCodeAt(0), y2 = " ".charCodeAt(0), w2 = "\f".charCodeAt(0), b2 = "	".charCodeAt(0), C2 = "\r".charCodeAt(0), E2 = "@".charCodeAt(0), F2 = "e".charCodeAt(0), x2 = "E".charCodeAt(0), A2 = "0".charCodeAt(0), k2 = "9".charCodeAt(0), O2 = "u".charCodeAt(0), _2 = "U".charCodeAt(0), S2 = /[ \n\t\r\{\(\)'"\\;,/]/g, T2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, I2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, N2 = /^[a-z0-9]/i, M2 = /^[a-f0-9?\-]/i, R2 = r3(8472), j2 = r3(5128);
      e22.exports = function(e23, t5) {
        t5 = t5 || {};
        let r4, L2, B2, P2, $2, U2, G2, W2, z2, V2, q2, X2 = [], J2 = e23.valueOf(), H2 = J2.length, Y2 = -1, K2 = 1, Z2 = 0, Q2 = 0, ee2 = null;
        function te2(e24) {
          let t6 = R2.format("Unclosed %s at line: %d, column: %d, token: %d", e24, K2, Z2 - Y2, Z2);
          throw new j2(t6);
        }
        for (; Z2 < H2; ) {
          switch (r4 = J2.charCodeAt(Z2), r4 === v2 && (Y2 = Z2, K2 += 1), r4) {
            case v2:
            case y2:
            case b2:
            case C2:
            case w2:
              L2 = Z2;
              do {
                L2 += 1, r4 = J2.charCodeAt(L2), r4 === v2 && (Y2 = L2, K2 += 1);
              } while (r4 === y2 || r4 === v2 || r4 === b2 || r4 === C2 || r4 === w2);
              X2.push(["space", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
              break;
            case h2:
              L2 = Z2 + 1, X2.push(["colon", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
              break;
            case p2:
              L2 = Z2 + 1, X2.push(["comma", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
              break;
            case n2:
              X2.push(["{", "{", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
              break;
            case o2:
              X2.push(["}", "}", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
              break;
            case i2:
              Q2++, ee2 = !ee2 && Q2 === 1 && X2.length > 0 && X2[X2.length - 1][0] === "word" && X2[X2.length - 1][1] === "url", X2.push(["(", "(", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
              break;
            case s2:
              Q2--, ee2 = ee2 && Q2 > 0, X2.push([")", ")", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
              break;
            case u2:
            case a2:
              B2 = r4 === u2 ? "'" : '"', L2 = Z2;
              do {
                for (z2 = false, L2 = J2.indexOf(B2, L2 + 1), L2 === -1 && te2("quote"), V2 = L2; J2.charCodeAt(V2 - 1) === c2; )
                  V2 -= 1, z2 = !z2;
              } while (z2);
              X2.push(["string", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
              break;
            case E2:
              S2.lastIndex = Z2 + 1, S2.test(J2), L2 = S2.lastIndex === 0 ? J2.length - 1 : S2.lastIndex - 2, X2.push(["atword", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
              break;
            case c2:
              L2 = Z2, r4 = J2.charCodeAt(L2 + 1), X2.push(["word", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
              break;
            case g2:
            case D2:
            case d2:
              if (L2 = Z2 + 1, q2 = J2.slice(Z2 + 1, L2 + 1), J2.slice(Z2 - 1, Z2), r4 === D2 && q2.charCodeAt(0) === D2) {
                L2++, X2.push(["word", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              }
              X2.push(["operator", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
              break;
            default:
              if (r4 === l2 && (J2.charCodeAt(Z2 + 1) === d2 || t5.loose && !ee2 && J2.charCodeAt(Z2 + 1) === l2)) {
                if (J2.charCodeAt(Z2 + 1) === d2)
                  L2 = J2.indexOf("*/", Z2 + 2) + 1, L2 === 0 && te2("comment");
                else {
                  const e24 = J2.indexOf("\n", Z2 + 2);
                  L2 = e24 !== -1 ? e24 - 1 : H2;
                }
                U2 = J2.slice(Z2, L2 + 1), P2 = U2.split("\n"), $2 = P2.length - 1, $2 > 0 ? (G2 = K2 + $2, W2 = L2 - P2[$2].length) : (G2 = K2, W2 = Y2), X2.push(["comment", U2, K2, Z2 - Y2, G2, L2 - W2, Z2]), Y2 = W2, K2 = G2, Z2 = L2;
              } else if (r4 !== m2 || N2.test(J2.slice(Z2 + 1, Z2 + 2)))
                if (r4 !== O2 && r4 !== _2 || J2.charCodeAt(Z2 + 1) !== g2)
                  if (r4 === l2)
                    L2 = Z2 + 1, X2.push(["operator", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                  else {
                    let e24 = T2;
                    if (r4 >= A2 && r4 <= k2 && (e24 = I2), e24.lastIndex = Z2 + 1, e24.test(J2), L2 = e24.lastIndex === 0 ? J2.length - 1 : e24.lastIndex - 2, e24 === I2 || r4 === f2) {
                      let e25 = J2.charCodeAt(L2), t6 = J2.charCodeAt(L2 + 1), r5 = J2.charCodeAt(L2 + 2);
                      (e25 === F2 || e25 === x2) && (t6 === D2 || t6 === g2) && r5 >= A2 && r5 <= k2 && (I2.lastIndex = L2 + 2, I2.test(J2), L2 = I2.lastIndex === 0 ? J2.length - 1 : I2.lastIndex - 2);
                    }
                    X2.push(["word", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                  }
                else {
                  L2 = Z2 + 2;
                  do {
                    L2 += 1, r4 = J2.charCodeAt(L2);
                  } while (L2 < H2 && M2.test(J2.slice(L2, L2 + 1)));
                  X2.push(["unicoderange", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                }
              else
                L2 = Z2 + 1, X2.push(["#", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
          }
          Z2++;
        }
        return X2;
      };
    }, 1369: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "unicode-range";
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 2057: (e22, t4, r3) => {
      const n2 = r3(4196);
      e22.exports = class extends n2 {
        constructor(e23) {
          super(e23), this.type = "value", this.unbalanced = 0;
        }
      };
    }, 6593: (e22, t4, r3) => {
      const n2 = r3(4196), o2 = r3(1466);
      class i2 extends o2 {
        constructor(e23) {
          super(e23), this.type = "word";
        }
      }
      n2.registerWalker(i2), e22.exports = i2;
    }, 8940: (e22, t4, r3) => {
      var n2;
      t4.__esModule = true, t4.default = void 0;
      var o2 = function(e23) {
        var t5, r4;
        function n3(t6) {
          var r5;
          return (r5 = e23.call(this, t6) || this).type = "atrule", r5;
        }
        r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
        var o3 = n3.prototype;
        return o3.append = function() {
          var t6;
          this.nodes || (this.nodes = []);
          for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
            n4[o4] = arguments[o4];
          return (t6 = e23.prototype.append).call.apply(t6, [this].concat(n4));
        }, o3.prepend = function() {
          var t6;
          this.nodes || (this.nodes = []);
          for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
            n4[o4] = arguments[o4];
          return (t6 = e23.prototype.prepend).call.apply(t6, [this].concat(n4));
        }, n3;
      }(((n2 = r3(1204)) && n2.__esModule ? n2 : {default: n2}).default);
      t4.default = o2, e22.exports = t4.default;
    }, 3102: (e22, t4, r3) => {
      var n2;
      t4.__esModule = true, t4.default = void 0;
      var o2 = function(e23) {
        var t5, r4;
        function n3(t6) {
          var r5;
          return (r5 = e23.call(this, t6) || this).type = "comment", r5;
        }
        return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
      }(((n2 = r3(1714)) && n2.__esModule ? n2 : {default: n2}).default);
      t4.default = o2, e22.exports = t4.default;
    }, 1204: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = i2(r3(6417)), o2 = i2(r3(3102));
      function i2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function s2(e23, t5) {
        var r4;
        if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
          if (Array.isArray(e23) || (r4 = function(e24, t6) {
            if (e24) {
              if (typeof e24 == "string")
                return u2(e24, t6);
              var r5 = Object.prototype.toString.call(e24).slice(8, -1);
              return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e24, t6) : void 0;
            }
          }(e23)) || t5 && e23 && typeof e23.length == "number") {
            r4 && (e23 = r4);
            var n3 = 0;
            return function() {
              return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (r4 = e23[Symbol.iterator]()).next.bind(r4);
      }
      function u2(e23, t5) {
        (t5 == null || t5 > e23.length) && (t5 = e23.length);
        for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
          n3[r4] = e23[r4];
        return n3;
      }
      function a2(e23, t5) {
        for (var r4 = 0; r4 < t5.length; r4++) {
          var n3 = t5[r4];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
        }
      }
      function c2(e23) {
        return e23.map(function(e24) {
          return e24.nodes && (e24.nodes = c2(e24.nodes)), delete e24.source, e24;
        });
      }
      var l2 = function(e23) {
        var t5, i3;
        function u3() {
          return e23.apply(this, arguments) || this;
        }
        i3 = e23, (t5 = u3).prototype = Object.create(i3.prototype), t5.prototype.constructor = t5, t5.__proto__ = i3;
        var l3, f2 = u3.prototype;
        return f2.push = function(e24) {
          return e24.parent = this, this.nodes.push(e24), this;
        }, f2.each = function(e24) {
          this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
          var t6 = this.lastEach;
          if (this.indexes[t6] = 0, this.nodes) {
            for (var r4, n3; this.indexes[t6] < this.nodes.length && (r4 = this.indexes[t6], (n3 = e24(this.nodes[r4], r4)) !== false); )
              this.indexes[t6] += 1;
            return delete this.indexes[t6], n3;
          }
        }, f2.walk = function(e24) {
          return this.each(function(t6, r4) {
            var n3;
            try {
              n3 = e24(t6, r4);
            } catch (e25) {
              if (e25.postcssNode = t6, e25.stack && t6.source && /\n\s{4}at /.test(e25.stack)) {
                var o3 = t6.source;
                e25.stack = e25.stack.replace(/\n\s{4}at /, "$&" + o3.input.from + ":" + o3.start.line + ":" + o3.start.column + "$&");
              }
              throw e25;
            }
            return n3 !== false && t6.walk && (n3 = t6.walk(e24)), n3;
          });
        }, f2.walkDecls = function(e24, t6) {
          return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
            if (r4.type === "decl" && e24.test(r4.prop))
              return t6(r4, n3);
          }) : this.walk(function(r4, n3) {
            if (r4.type === "decl" && r4.prop === e24)
              return t6(r4, n3);
          }) : (t6 = e24, this.walk(function(e25, r4) {
            if (e25.type === "decl")
              return t6(e25, r4);
          }));
        }, f2.walkRules = function(e24, t6) {
          return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
            if (r4.type === "rule" && e24.test(r4.selector))
              return t6(r4, n3);
          }) : this.walk(function(r4, n3) {
            if (r4.type === "rule" && r4.selector === e24)
              return t6(r4, n3);
          }) : (t6 = e24, this.walk(function(e25, r4) {
            if (e25.type === "rule")
              return t6(e25, r4);
          }));
        }, f2.walkAtRules = function(e24, t6) {
          return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
            if (r4.type === "atrule" && e24.test(r4.name))
              return t6(r4, n3);
          }) : this.walk(function(r4, n3) {
            if (r4.type === "atrule" && r4.name === e24)
              return t6(r4, n3);
          }) : (t6 = e24, this.walk(function(e25, r4) {
            if (e25.type === "atrule")
              return t6(e25, r4);
          }));
        }, f2.walkComments = function(e24) {
          return this.walk(function(t6, r4) {
            if (t6.type === "comment")
              return e24(t6, r4);
          });
        }, f2.append = function() {
          for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
            t6[r4] = arguments[r4];
          for (var n3 = 0, o3 = t6; n3 < o3.length; n3++)
            for (var i4, u4 = o3[n3], a3 = s2(this.normalize(u4, this.last)); !(i4 = a3()).done; ) {
              var c3 = i4.value;
              this.nodes.push(c3);
            }
          return this;
        }, f2.prepend = function() {
          for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
            t6[r4] = arguments[r4];
          for (var n3, o3 = s2(t6 = t6.reverse()); !(n3 = o3()).done; ) {
            for (var i4, u4 = n3.value, a3 = this.normalize(u4, this.first, "prepend").reverse(), c3 = s2(a3); !(i4 = c3()).done; ) {
              var l4 = i4.value;
              this.nodes.unshift(l4);
            }
            for (var f3 in this.indexes)
              this.indexes[f3] = this.indexes[f3] + a3.length;
          }
          return this;
        }, f2.cleanRaws = function(t6) {
          if (e23.prototype.cleanRaws.call(this, t6), this.nodes)
            for (var r4, n3 = s2(this.nodes); !(r4 = n3()).done; )
              r4.value.cleanRaws(t6);
        }, f2.insertBefore = function(e24, t6) {
          for (var r4, n3, o3 = (e24 = this.index(e24)) === 0 && "prepend", i4 = this.normalize(t6, this.nodes[e24], o3).reverse(), u4 = s2(i4); !(r4 = u4()).done; ) {
            var a3 = r4.value;
            this.nodes.splice(e24, 0, a3);
          }
          for (var c3 in this.indexes)
            e24 <= (n3 = this.indexes[c3]) && (this.indexes[c3] = n3 + i4.length);
          return this;
        }, f2.insertAfter = function(e24, t6) {
          e24 = this.index(e24);
          for (var r4, n3, o3 = this.normalize(t6, this.nodes[e24]).reverse(), i4 = s2(o3); !(r4 = i4()).done; ) {
            var u4 = r4.value;
            this.nodes.splice(e24 + 1, 0, u4);
          }
          for (var a3 in this.indexes)
            e24 < (n3 = this.indexes[a3]) && (this.indexes[a3] = n3 + o3.length);
          return this;
        }, f2.removeChild = function(e24) {
          var t6;
          for (var r4 in e24 = this.index(e24), this.nodes[e24].parent = void 0, this.nodes.splice(e24, 1), this.indexes)
            (t6 = this.indexes[r4]) >= e24 && (this.indexes[r4] = t6 - 1);
          return this;
        }, f2.removeAll = function() {
          for (var e24, t6 = s2(this.nodes); !(e24 = t6()).done; )
            e24.value.parent = void 0;
          return this.nodes = [], this;
        }, f2.replaceValues = function(e24, t6, r4) {
          return r4 || (r4 = t6, t6 = {}), this.walkDecls(function(n3) {
            t6.props && t6.props.indexOf(n3.prop) === -1 || t6.fast && n3.value.indexOf(t6.fast) === -1 || (n3.value = n3.value.replace(e24, r4));
          }), this;
        }, f2.every = function(e24) {
          return this.nodes.every(e24);
        }, f2.some = function(e24) {
          return this.nodes.some(e24);
        }, f2.index = function(e24) {
          return typeof e24 == "number" ? e24 : this.nodes.indexOf(e24);
        }, f2.normalize = function(e24, t6) {
          var i4 = this;
          if (typeof e24 == "string")
            e24 = c2(r3(7057)(e24).nodes);
          else if (Array.isArray(e24))
            for (var u4, a3 = s2(e24 = e24.slice(0)); !(u4 = a3()).done; ) {
              var l4 = u4.value;
              l4.parent && l4.parent.removeChild(l4, "ignore");
            }
          else if (e24.type === "root")
            for (var f3, p2 = s2(e24 = e24.nodes.slice(0)); !(f3 = p2()).done; ) {
              var h2 = f3.value;
              h2.parent && h2.parent.removeChild(h2, "ignore");
            }
          else if (e24.type)
            e24 = [e24];
          else if (e24.prop) {
            if (e24.value === void 0)
              throw new Error("Value field is missed in node creation");
            typeof e24.value != "string" && (e24.value = String(e24.value)), e24 = [new n2.default(e24)];
          } else if (e24.selector)
            e24 = [new (r3(6621))(e24)];
          else if (e24.name)
            e24 = [new (r3(8940))(e24)];
          else {
            if (!e24.text)
              throw new Error("Unknown node type in node creation");
            e24 = [new o2.default(e24)];
          }
          return e24.map(function(e25) {
            return e25.parent && e25.parent.removeChild(e25), e25.raws.before === void 0 && t6 && t6.raws.before !== void 0 && (e25.raws.before = t6.raws.before.replace(/[^\s]/g, "")), e25.parent = i4, e25;
          });
        }, (l3 = [{key: "first", get: function() {
          if (this.nodes)
            return this.nodes[0];
        }}, {key: "last", get: function() {
          if (this.nodes)
            return this.nodes[this.nodes.length - 1];
        }}]) && a2(u3.prototype, l3), u3;
      }(i2(r3(1714)).default);
      t4.default = l2, e22.exports = t4.default;
    }, 1667: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = s2(r3(6083)), o2 = s2(r3(3248)), i2 = s2(r3(2868));
      function s2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function u2(e23) {
        var t5 = typeof Map == "function" ? new Map() : void 0;
        return (u2 = function(e24) {
          if (e24 === null || (r4 = e24, Function.toString.call(r4).indexOf("[native code]") === -1))
            return e24;
          var r4;
          if (typeof e24 != "function")
            throw new TypeError("Super expression must either be null or a function");
          if (t5 !== void 0) {
            if (t5.has(e24))
              return t5.get(e24);
            t5.set(e24, n3);
          }
          function n3() {
            return a2(e24, arguments, f2(this).constructor);
          }
          return n3.prototype = Object.create(e24.prototype, {constructor: {value: n3, enumerable: false, writable: true, configurable: true}}), l2(n3, e24);
        })(e23);
      }
      function a2(e23, t5, r4) {
        return (a2 = c2() ? Reflect.construct : function(e24, t6, r5) {
          var n3 = [null];
          n3.push.apply(n3, t6);
          var o3 = new (Function.bind.apply(e24, n3))();
          return r5 && l2(o3, r5.prototype), o3;
        }).apply(null, arguments);
      }
      function c2() {
        if (typeof Reflect == "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy == "function")
          return true;
        try {
          return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          })), true;
        } catch (e23) {
          return false;
        }
      }
      function l2(e23, t5) {
        return (l2 = Object.setPrototypeOf || function(e24, t6) {
          return e24.__proto__ = t6, e24;
        })(e23, t5);
      }
      function f2(e23) {
        return (f2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e24) {
          return e24.__proto__ || Object.getPrototypeOf(e24);
        })(e23);
      }
      var p2 = function(e23) {
        var t5, r4;
        function s3(t6, r5, n3, o3, i3, u4) {
          var a3;
          return (a3 = e23.call(this, t6) || this).name = "CssSyntaxError", a3.reason = t6, i3 && (a3.file = i3), o3 && (a3.source = o3), u4 && (a3.plugin = u4), r5 !== void 0 && n3 !== void 0 && (a3.line = r5, a3.column = n3), a3.setMessage(), Error.captureStackTrace && Error.captureStackTrace(function(e24) {
            if (e24 === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e24;
          }(a3), s3), a3;
        }
        r4 = e23, (t5 = s3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
        var u3 = s3.prototype;
        return u3.setMessage = function() {
          this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", this.line !== void 0 && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
        }, u3.showSourceCode = function(e24) {
          var t6 = this;
          if (!this.source)
            return "";
          var r5 = this.source;
          i2.default && (e24 === void 0 && (e24 = n2.default.stdout), e24 && (r5 = (0, i2.default)(r5)));
          var s4 = r5.split(/\r?\n/), u4 = Math.max(this.line - 3, 0), a3 = Math.min(this.line + 2, s4.length), c3 = String(a3).length;
          function l3(t7) {
            return e24 && o2.default.red ? o2.default.red.bold(t7) : t7;
          }
          function f3(t7) {
            return e24 && o2.default.gray ? o2.default.gray(t7) : t7;
          }
          return s4.slice(u4, a3).map(function(e25, r6) {
            var n3 = u4 + 1 + r6, o3 = " " + (" " + n3).slice(-c3) + " | ";
            if (n3 === t6.line) {
              var i3 = f3(o3.replace(/\d/g, " ")) + e25.slice(0, t6.column - 1).replace(/[^\t]/g, " ");
              return l3(">") + f3(o3) + e25 + "\n " + i3 + l3("^");
            }
            return " " + f3(o3) + e25;
          }).join("\n");
        }, u3.toString = function() {
          var e24 = this.showSourceCode();
          return e24 && (e24 = "\n\n" + e24 + "\n"), this.name + ": " + this.message + e24;
        }, s3;
      }(u2(Error));
      t4.default = p2, e22.exports = t4.default;
    }, 6417: (e22, t4, r3) => {
      var n2;
      t4.__esModule = true, t4.default = void 0;
      var o2 = function(e23) {
        var t5, r4;
        function n3(t6) {
          var r5;
          return (r5 = e23.call(this, t6) || this).type = "decl", r5;
        }
        return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
      }(((n2 = r3(1714)) && n2.__esModule ? n2 : {default: n2}).default);
      t4.default = o2, e22.exports = t4.default;
    }, 2993: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = s2(r3(3974)), o2 = s2(r3(1667)), i2 = s2(r3(3353));
      function s2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function u2(e23, t5) {
        for (var r4 = 0; r4 < t5.length; r4++) {
          var n3 = t5[r4];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
        }
      }
      var a2 = 0, c2 = function() {
        function e23(e24, t6) {
          if (t6 === void 0 && (t6 = {}), e24 == null || typeof e24 == "object" && !e24.toString)
            throw new Error("PostCSS received " + e24 + " instead of CSS string");
          this.css = e24.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, t6.from && (/^\w+:\/\//.test(t6.from) || n2.default.isAbsolute(t6.from) ? this.file = t6.from : this.file = n2.default.resolve(t6.from));
          var r5 = new i2.default(this.css, t6);
          if (r5.text) {
            this.map = r5;
            var o3 = r5.consumer().file;
            !this.file && o3 && (this.file = this.mapResolve(o3));
          }
          this.file || (a2 += 1, this.id = "<input css " + a2 + ">"), this.map && (this.map.file = this.from);
        }
        var t5, r4 = e23.prototype;
        return r4.error = function(e24, t6, r5, n3) {
          var i3;
          n3 === void 0 && (n3 = {});
          var s3 = this.origin(t6, r5);
          return (i3 = s3 ? new o2.default(e24, s3.line, s3.column, s3.source, s3.file, n3.plugin) : new o2.default(e24, t6, r5, this.css, this.file, n3.plugin)).input = {line: t6, column: r5, source: this.css}, this.file && (i3.input.file = this.file), i3;
        }, r4.origin = function(e24, t6) {
          if (!this.map)
            return false;
          var r5 = this.map.consumer(), n3 = r5.originalPositionFor({line: e24, column: t6});
          if (!n3.source)
            return false;
          var o3 = {file: this.mapResolve(n3.source), line: n3.line, column: n3.column}, i3 = r5.sourceContentFor(n3.source);
          return i3 && (o3.source = i3), o3;
        }, r4.mapResolve = function(e24) {
          return /^\w+:\/\//.test(e24) ? e24 : n2.default.resolve(this.map.consumer().sourceRoot || ".", e24);
        }, (t5 = [{key: "from", get: function() {
          return this.file || this.id;
        }}]) && u2(e23.prototype, t5), e23;
      }();
      t4.default = c2, e22.exports = t4.default;
    }, 6992: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = u2(r3(8991)), o2 = u2(r3(6157)), i2 = (u2(r3(6574)), u2(r3(6865))), s2 = u2(r3(7057));
      function u2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function a2(e23, t5) {
        var r4;
        if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
          if (Array.isArray(e23) || (r4 = function(e24, t6) {
            if (e24) {
              if (typeof e24 == "string")
                return c2(e24, t6);
              var r5 = Object.prototype.toString.call(e24).slice(8, -1);
              return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? c2(e24, t6) : void 0;
            }
          }(e23)) || t5 && e23 && typeof e23.length == "number") {
            r4 && (e23 = r4);
            var n3 = 0;
            return function() {
              return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (r4 = e23[Symbol.iterator]()).next.bind(r4);
      }
      function c2(e23, t5) {
        (t5 == null || t5 > e23.length) && (t5 = e23.length);
        for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
          n3[r4] = e23[r4];
        return n3;
      }
      function l2(e23, t5) {
        for (var r4 = 0; r4 < t5.length; r4++) {
          var n3 = t5[r4];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
        }
      }
      function f2(e23) {
        return typeof e23 == "object" && typeof e23.then == "function";
      }
      var p2 = function() {
        function e23(t6, r5, n3) {
          var o3;
          if (this.stringified = false, this.processed = false, typeof r5 == "object" && r5 !== null && r5.type === "root")
            o3 = r5;
          else if (r5 instanceof e23 || r5 instanceof i2.default)
            o3 = r5.root, r5.map && (n3.map === void 0 && (n3.map = {}), n3.map.inline || (n3.map.inline = false), n3.map.prev = r5.map);
          else {
            var u3 = s2.default;
            n3.syntax && (u3 = n3.syntax.parse), n3.parser && (u3 = n3.parser), u3.parse && (u3 = u3.parse);
            try {
              o3 = u3(r5, n3);
            } catch (t7) {
              this.error = t7;
            }
          }
          this.result = new i2.default(t6, o3, n3);
        }
        var t5, r4 = e23.prototype;
        return r4.warnings = function() {
          return this.sync().warnings();
        }, r4.toString = function() {
          return this.css;
        }, r4.then = function(e24, t6) {
          return this.async().then(e24, t6);
        }, r4.catch = function(e24) {
          return this.async().catch(e24);
        }, r4.finally = function(e24) {
          return this.async().then(e24, e24);
        }, r4.handleError = function(e24, t6) {
          try {
            this.error = e24, e24.name !== "CssSyntaxError" || e24.plugin ? t6.postcssVersion : (e24.plugin = t6.postcssPlugin, e24.setMessage());
          } catch (e25) {
            console && console.error && console.error(e25);
          }
        }, r4.asyncTick = function(e24, t6) {
          var r5 = this;
          if (this.plugin >= this.processor.plugins.length)
            return this.processed = true, e24();
          try {
            var n3 = this.processor.plugins[this.plugin], o3 = this.run(n3);
            this.plugin += 1, f2(o3) ? o3.then(function() {
              r5.asyncTick(e24, t6);
            }).catch(function(e25) {
              r5.handleError(e25, n3), r5.processed = true, t6(e25);
            }) : this.asyncTick(e24, t6);
          } catch (e25) {
            this.processed = true, t6(e25);
          }
        }, r4.async = function() {
          var e24 = this;
          return this.processed ? new Promise(function(t6, r5) {
            e24.error ? r5(e24.error) : t6(e24.stringify());
          }) : (this.processing || (this.processing = new Promise(function(t6, r5) {
            if (e24.error)
              return r5(e24.error);
            e24.plugin = 0, e24.asyncTick(t6, r5);
          }).then(function() {
            return e24.processed = true, e24.stringify();
          })), this.processing);
        }, r4.sync = function() {
          if (this.processed)
            return this.result;
          if (this.processed = true, this.processing)
            throw new Error("Use process(css).then(cb) to work with async plugins");
          if (this.error)
            throw this.error;
          for (var e24, t6 = a2(this.result.processor.plugins); !(e24 = t6()).done; ) {
            var r5 = e24.value;
            if (f2(this.run(r5)))
              throw new Error("Use process(css).then(cb) to work with async plugins");
          }
          return this.result;
        }, r4.run = function(e24) {
          this.result.lastPlugin = e24;
          try {
            return e24(this.result.root, this.result);
          } catch (t6) {
            throw this.handleError(t6, e24), t6;
          }
        }, r4.stringify = function() {
          if (this.stringified)
            return this.result;
          this.stringified = true, this.sync();
          var e24 = this.result.opts, t6 = o2.default;
          e24.syntax && (t6 = e24.syntax.stringify), e24.stringifier && (t6 = e24.stringifier), t6.stringify && (t6 = t6.stringify);
          var r5 = new n2.default(t6, this.result.root, this.result.opts).generate();
          return this.result.css = r5[0], this.result.map = r5[1], this.result;
        }, (t5 = [{key: "processor", get: function() {
          return this.result.processor;
        }}, {key: "opts", get: function() {
          return this.result.opts;
        }}, {key: "css", get: function() {
          return this.stringify().css;
        }}, {key: "content", get: function() {
          return this.stringify().content;
        }}, {key: "map", get: function() {
          return this.stringify().map;
        }}, {key: "root", get: function() {
          return this.sync().root;
        }}, {key: "messages", get: function() {
          return this.sync().messages;
        }}]) && l2(e23.prototype, t5), e23;
      }();
      t4.default = p2, e22.exports = t4.default;
    }, 6136: (e22, t4) => {
      t4.__esModule = true, t4.default = void 0;
      var r3 = {split: function(e23, t5, r4) {
        for (var n3 = [], o2 = "", i2 = false, s2 = 0, u2 = false, a2 = false, c2 = 0; c2 < e23.length; c2++) {
          var l2 = e23[c2];
          u2 ? a2 ? a2 = false : l2 === "\\" ? a2 = true : l2 === u2 && (u2 = false) : l2 === '"' || l2 === "'" ? u2 = l2 : l2 === "(" ? s2 += 1 : l2 === ")" ? s2 > 0 && (s2 -= 1) : s2 === 0 && t5.indexOf(l2) !== -1 && (i2 = true), i2 ? (o2 !== "" && n3.push(o2.trim()), o2 = "", i2 = false) : o2 += l2;
        }
        return (r4 || o2 !== "") && n3.push(o2.trim()), n3;
      }, space: function(e23) {
        return r3.split(e23, [" ", "\n", "	"]);
      }, comma: function(e23) {
        return r3.split(e23, [","], true);
      }}, n2 = r3;
      t4.default = n2, e22.exports = t4.default;
    }, 8991: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = i2(r3(2447)), o2 = i2(r3(3974));
      function i2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function s2(e23, t5) {
        var r4;
        if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
          if (Array.isArray(e23) || (r4 = function(e24, t6) {
            if (e24) {
              if (typeof e24 == "string")
                return u2(e24, t6);
              var r5 = Object.prototype.toString.call(e24).slice(8, -1);
              return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e24, t6) : void 0;
            }
          }(e23)) || t5 && e23 && typeof e23.length == "number") {
            r4 && (e23 = r4);
            var n3 = 0;
            return function() {
              return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (r4 = e23[Symbol.iterator]()).next.bind(r4);
      }
      function u2(e23, t5) {
        (t5 == null || t5 > e23.length) && (t5 = e23.length);
        for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
          n3[r4] = e23[r4];
        return n3;
      }
      var a2 = function() {
        function e23(e24, t6, r4) {
          this.stringify = e24, this.mapOpts = r4.map || {}, this.root = t6, this.opts = r4;
        }
        var t5 = e23.prototype;
        return t5.isMap = function() {
          return this.opts.map !== void 0 ? !!this.opts.map : this.previous().length > 0;
        }, t5.previous = function() {
          var e24 = this;
          return this.previousMaps || (this.previousMaps = [], this.root.walk(function(t6) {
            if (t6.source && t6.source.input.map) {
              var r4 = t6.source.input.map;
              e24.previousMaps.indexOf(r4) === -1 && e24.previousMaps.push(r4);
            }
          })), this.previousMaps;
        }, t5.isInline = function() {
          if (this.mapOpts.inline !== void 0)
            return this.mapOpts.inline;
          var e24 = this.mapOpts.annotation;
          return (e24 === void 0 || e24 === true) && (!this.previous().length || this.previous().some(function(e25) {
            return e25.inline;
          }));
        }, t5.isSourcesContent = function() {
          return this.mapOpts.sourcesContent !== void 0 ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some(function(e24) {
            return e24.withContent();
          });
        }, t5.clearAnnotation = function() {
          if (this.mapOpts.annotation !== false)
            for (var e24, t6 = this.root.nodes.length - 1; t6 >= 0; t6--)
              (e24 = this.root.nodes[t6]).type === "comment" && e24.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t6);
        }, t5.setSourcesContent = function() {
          var e24 = this, t6 = {};
          this.root.walk(function(r4) {
            if (r4.source) {
              var n3 = r4.source.input.from;
              if (n3 && !t6[n3]) {
                t6[n3] = true;
                var o3 = e24.relative(n3);
                e24.map.setSourceContent(o3, r4.source.input.css);
              }
            }
          });
        }, t5.applyPrevMaps = function() {
          for (var e24, t6 = s2(this.previous()); !(e24 = t6()).done; ) {
            var r4 = e24.value, i3 = this.relative(r4.file), u3 = r4.root || o2.default.dirname(r4.file), a3 = void 0;
            this.mapOpts.sourcesContent === false ? (a3 = new n2.default.SourceMapConsumer(r4.text)).sourcesContent && (a3.sourcesContent = a3.sourcesContent.map(function() {
              return null;
            })) : a3 = r4.consumer(), this.map.applySourceMap(a3, i3, this.relative(u3));
          }
        }, t5.isAnnotation = function() {
          return !!this.isInline() || (this.mapOpts.annotation !== void 0 ? this.mapOpts.annotation : !this.previous().length || this.previous().some(function(e24) {
            return e24.annotation;
          }));
        }, t5.toBase64 = function(e24) {
          return Buffer ? Buffer.from(e24).toString("base64") : window.btoa(unescape(encodeURIComponent(e24)));
        }, t5.addAnnotation = function() {
          var e24;
          e24 = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? this.mapOpts.annotation : this.outputFile() + ".map";
          var t6 = "\n";
          this.css.indexOf("\r\n") !== -1 && (t6 = "\r\n"), this.css += t6 + "/*# sourceMappingURL=" + e24 + " */";
        }, t5.outputFile = function() {
          return this.opts.to ? this.relative(this.opts.to) : this.opts.from ? this.relative(this.opts.from) : "to.css";
        }, t5.generateMap = function() {
          return this.generateString(), this.isSourcesContent() && this.setSourcesContent(), this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
        }, t5.relative = function(e24) {
          if (e24.indexOf("<") === 0)
            return e24;
          if (/^\w+:\/\//.test(e24))
            return e24;
          var t6 = this.opts.to ? o2.default.dirname(this.opts.to) : ".";
          return typeof this.mapOpts.annotation == "string" && (t6 = o2.default.dirname(o2.default.resolve(t6, this.mapOpts.annotation))), e24 = o2.default.relative(t6, e24), o2.default.sep === "\\" ? e24.replace(/\\/g, "/") : e24;
        }, t5.sourcePath = function(e24) {
          return this.mapOpts.from ? this.mapOpts.from : this.relative(e24.source.input.from);
        }, t5.generateString = function() {
          var e24 = this;
          this.css = "", this.map = new n2.default.SourceMapGenerator({file: this.outputFile()});
          var t6, r4, o3 = 1, i3 = 1;
          this.stringify(this.root, function(n3, s3, u3) {
            if (e24.css += n3, s3 && u3 !== "end" && (s3.source && s3.source.start ? e24.map.addMapping({source: e24.sourcePath(s3), generated: {line: o3, column: i3 - 1}, original: {line: s3.source.start.line, column: s3.source.start.column - 1}}) : e24.map.addMapping({source: "<no source>", original: {line: 1, column: 0}, generated: {line: o3, column: i3 - 1}})), (t6 = n3.match(/\n/g)) ? (o3 += t6.length, r4 = n3.lastIndexOf("\n"), i3 = n3.length - r4) : i3 += n3.length, s3 && u3 !== "start") {
              var a3 = s3.parent || {raws: {}};
              (s3.type !== "decl" || s3 !== a3.last || a3.raws.semicolon) && (s3.source && s3.source.end ? e24.map.addMapping({source: e24.sourcePath(s3), generated: {line: o3, column: i3 - 2}, original: {line: s3.source.end.line, column: s3.source.end.column - 1}}) : e24.map.addMapping({source: "<no source>", original: {line: 1, column: 0}, generated: {line: o3, column: i3 - 1}}));
            }
          });
        }, t5.generate = function() {
          if (this.clearAnnotation(), this.isMap())
            return this.generateMap();
          var e24 = "";
          return this.stringify(this.root, function(t6) {
            e24 += t6;
          }), [e24];
        }, e23;
      }();
      t4.default = a2, e22.exports = t4.default;
    }, 1714: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = s2(r3(1667)), o2 = s2(r3(5701)), i2 = s2(r3(6157));
      function s2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function u2(e23, t5) {
        var r4 = new e23.constructor();
        for (var n3 in e23)
          if (e23.hasOwnProperty(n3)) {
            var o3 = e23[n3], i3 = typeof o3;
            n3 === "parent" && i3 === "object" ? t5 && (r4[n3] = t5) : n3 === "source" ? r4[n3] = o3 : o3 instanceof Array ? r4[n3] = o3.map(function(e24) {
              return u2(e24, r4);
            }) : (i3 === "object" && o3 !== null && (o3 = u2(o3)), r4[n3] = o3);
          }
        return r4;
      }
      var a2 = function() {
        function e23(e24) {
          for (var t6 in e24 === void 0 && (e24 = {}), this.raws = {}, e24)
            this[t6] = e24[t6];
        }
        var t5 = e23.prototype;
        return t5.error = function(e24, t6) {
          if (t6 === void 0 && (t6 = {}), this.source) {
            var r4 = this.positionBy(t6);
            return this.source.input.error(e24, r4.line, r4.column, t6);
          }
          return new n2.default(e24);
        }, t5.warn = function(e24, t6, r4) {
          var n3 = {node: this};
          for (var o3 in r4)
            n3[o3] = r4[o3];
          return e24.warn(t6, n3);
        }, t5.remove = function() {
          return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }, t5.toString = function(e24) {
          e24 === void 0 && (e24 = i2.default), e24.stringify && (e24 = e24.stringify);
          var t6 = "";
          return e24(this, function(e25) {
            t6 += e25;
          }), t6;
        }, t5.clone = function(e24) {
          e24 === void 0 && (e24 = {});
          var t6 = u2(this);
          for (var r4 in e24)
            t6[r4] = e24[r4];
          return t6;
        }, t5.cloneBefore = function(e24) {
          e24 === void 0 && (e24 = {});
          var t6 = this.clone(e24);
          return this.parent.insertBefore(this, t6), t6;
        }, t5.cloneAfter = function(e24) {
          e24 === void 0 && (e24 = {});
          var t6 = this.clone(e24);
          return this.parent.insertAfter(this, t6), t6;
        }, t5.replaceWith = function() {
          if (this.parent) {
            for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
              t6[r4] = arguments[r4];
            for (var n3 = 0, o3 = t6; n3 < o3.length; n3++) {
              var i3 = o3[n3];
              this.parent.insertBefore(this, i3);
            }
            this.remove();
          }
          return this;
        }, t5.next = function() {
          if (this.parent) {
            var e24 = this.parent.index(this);
            return this.parent.nodes[e24 + 1];
          }
        }, t5.prev = function() {
          if (this.parent) {
            var e24 = this.parent.index(this);
            return this.parent.nodes[e24 - 1];
          }
        }, t5.before = function(e24) {
          return this.parent.insertBefore(this, e24), this;
        }, t5.after = function(e24) {
          return this.parent.insertAfter(this, e24), this;
        }, t5.toJSON = function() {
          var e24 = {};
          for (var t6 in this)
            if (this.hasOwnProperty(t6) && t6 !== "parent") {
              var r4 = this[t6];
              r4 instanceof Array ? e24[t6] = r4.map(function(e25) {
                return typeof e25 == "object" && e25.toJSON ? e25.toJSON() : e25;
              }) : typeof r4 == "object" && r4.toJSON ? e24[t6] = r4.toJSON() : e24[t6] = r4;
            }
          return e24;
        }, t5.raw = function(e24, t6) {
          return new o2.default().raw(this, e24, t6);
        }, t5.root = function() {
          for (var e24 = this; e24.parent; )
            e24 = e24.parent;
          return e24;
        }, t5.cleanRaws = function(e24) {
          delete this.raws.before, delete this.raws.after, e24 || delete this.raws.between;
        }, t5.positionInside = function(e24) {
          for (var t6 = this.toString(), r4 = this.source.start.column, n3 = this.source.start.line, o3 = 0; o3 < e24; o3++)
            t6[o3] === "\n" ? (r4 = 1, n3 += 1) : r4 += 1;
          return {line: n3, column: r4};
        }, t5.positionBy = function(e24) {
          var t6 = this.source.start;
          if (e24.index)
            t6 = this.positionInside(e24.index);
          else if (e24.word) {
            var r4 = this.toString().indexOf(e24.word);
            r4 !== -1 && (t6 = this.positionInside(r4));
          }
          return t6;
        }, e23;
      }();
      t4.default = a2, e22.exports = t4.default;
    }, 7057: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = i2(r3(7116)), o2 = i2(r3(2993));
      function i2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      var s2 = function(e23, t5) {
        var r4 = new o2.default(e23, t5), i3 = new n2.default(r4);
        try {
          i3.parse();
        } catch (e24) {
          throw e24;
        }
        return i3.root;
      };
      t4.default = s2, e22.exports = t4.default;
    }, 7116: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = c2(r3(6417)), o2 = c2(r3(1157)), i2 = c2(r3(3102)), s2 = c2(r3(8940)), u2 = c2(r3(7563)), a2 = c2(r3(6621));
      function c2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      var l2 = function() {
        function e23(e24) {
          this.input = e24, this.root = new u2.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = {input: e24, start: {line: 1, column: 1}};
        }
        var t5 = e23.prototype;
        return t5.createTokenizer = function() {
          this.tokenizer = (0, o2.default)(this.input);
        }, t5.parse = function() {
          for (var e24; !this.tokenizer.endOfFile(); )
            switch ((e24 = this.tokenizer.nextToken())[0]) {
              case "space":
                this.spaces += e24[1];
                break;
              case ";":
                this.freeSemicolon(e24);
                break;
              case "}":
                this.end(e24);
                break;
              case "comment":
                this.comment(e24);
                break;
              case "at-word":
                this.atrule(e24);
                break;
              case "{":
                this.emptyRule(e24);
                break;
              default:
                this.other(e24);
            }
          this.endFile();
        }, t5.comment = function(e24) {
          var t6 = new i2.default();
          this.init(t6, e24[2], e24[3]), t6.source.end = {line: e24[4], column: e24[5]};
          var r4 = e24[1].slice(2, -2);
          if (/^\s*$/.test(r4))
            t6.text = "", t6.raws.left = r4, t6.raws.right = "";
          else {
            var n3 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
            t6.text = n3[2], t6.raws.left = n3[1], t6.raws.right = n3[3];
          }
        }, t5.emptyRule = function(e24) {
          var t6 = new a2.default();
          this.init(t6, e24[2], e24[3]), t6.selector = "", t6.raws.between = "", this.current = t6;
        }, t5.other = function(e24) {
          for (var t6 = false, r4 = null, n3 = false, o3 = null, i3 = [], s3 = [], u3 = e24; u3; ) {
            if (r4 = u3[0], s3.push(u3), r4 === "(" || r4 === "[")
              o3 || (o3 = u3), i3.push(r4 === "(" ? ")" : "]");
            else if (i3.length === 0) {
              if (r4 === ";") {
                if (n3)
                  return void this.decl(s3);
                break;
              }
              if (r4 === "{")
                return void this.rule(s3);
              if (r4 === "}") {
                this.tokenizer.back(s3.pop()), t6 = true;
                break;
              }
              r4 === ":" && (n3 = true);
            } else
              r4 === i3[i3.length - 1] && (i3.pop(), i3.length === 0 && (o3 = null));
            u3 = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile() && (t6 = true), i3.length > 0 && this.unclosedBracket(o3), t6 && n3) {
            for (; s3.length && ((u3 = s3[s3.length - 1][0]) === "space" || u3 === "comment"); )
              this.tokenizer.back(s3.pop());
            this.decl(s3);
          } else
            this.unknownWord(s3);
        }, t5.rule = function(e24) {
          e24.pop();
          var t6 = new a2.default();
          this.init(t6, e24[0][2], e24[0][3]), t6.raws.between = this.spacesAndCommentsFromEnd(e24), this.raw(t6, "selector", e24), this.current = t6;
        }, t5.decl = function(e24) {
          var t6 = new n2.default();
          this.init(t6);
          var r4, o3 = e24[e24.length - 1];
          for (o3[0] === ";" && (this.semicolon = true, e24.pop()), o3[4] ? t6.source.end = {line: o3[4], column: o3[5]} : t6.source.end = {line: o3[2], column: o3[3]}; e24[0][0] !== "word"; )
            e24.length === 1 && this.unknownWord(e24), t6.raws.before += e24.shift()[1];
          for (t6.source.start = {line: e24[0][2], column: e24[0][3]}, t6.prop = ""; e24.length; ) {
            var i3 = e24[0][0];
            if (i3 === ":" || i3 === "space" || i3 === "comment")
              break;
            t6.prop += e24.shift()[1];
          }
          for (t6.raws.between = ""; e24.length; ) {
            if ((r4 = e24.shift())[0] === ":") {
              t6.raws.between += r4[1];
              break;
            }
            r4[0] === "word" && /\w/.test(r4[1]) && this.unknownWord([r4]), t6.raws.between += r4[1];
          }
          t6.prop[0] !== "_" && t6.prop[0] !== "*" || (t6.raws.before += t6.prop[0], t6.prop = t6.prop.slice(1)), t6.raws.between += this.spacesAndCommentsFromStart(e24), this.precheckMissedSemicolon(e24);
          for (var s3 = e24.length - 1; s3 > 0; s3--) {
            if ((r4 = e24[s3])[1].toLowerCase() === "!important") {
              t6.important = true;
              var u3 = this.stringFrom(e24, s3);
              (u3 = this.spacesFromEnd(e24) + u3) !== " !important" && (t6.raws.important = u3);
              break;
            }
            if (r4[1].toLowerCase() === "important") {
              for (var a3 = e24.slice(0), c3 = "", l3 = s3; l3 > 0; l3--) {
                var f2 = a3[l3][0];
                if (c3.trim().indexOf("!") === 0 && f2 !== "space")
                  break;
                c3 = a3.pop()[1] + c3;
              }
              c3.trim().indexOf("!") === 0 && (t6.important = true, t6.raws.important = c3, e24 = a3);
            }
            if (r4[0] !== "space" && r4[0] !== "comment")
              break;
          }
          this.raw(t6, "value", e24), t6.value.indexOf(":") !== -1 && this.checkMissedSemicolon(e24);
        }, t5.atrule = function(e24) {
          var t6, r4, n3 = new s2.default();
          n3.name = e24[1].slice(1), n3.name === "" && this.unnamedAtrule(n3, e24), this.init(n3, e24[2], e24[3]);
          for (var o3 = false, i3 = false, u3 = []; !this.tokenizer.endOfFile(); ) {
            if ((e24 = this.tokenizer.nextToken())[0] === ";") {
              n3.source.end = {line: e24[2], column: e24[3]}, this.semicolon = true;
              break;
            }
            if (e24[0] === "{") {
              i3 = true;
              break;
            }
            if (e24[0] === "}") {
              if (u3.length > 0) {
                for (t6 = u3[r4 = u3.length - 1]; t6 && t6[0] === "space"; )
                  t6 = u3[--r4];
                t6 && (n3.source.end = {line: t6[4], column: t6[5]});
              }
              this.end(e24);
              break;
            }
            if (u3.push(e24), this.tokenizer.endOfFile()) {
              o3 = true;
              break;
            }
          }
          n3.raws.between = this.spacesAndCommentsFromEnd(u3), u3.length ? (n3.raws.afterName = this.spacesAndCommentsFromStart(u3), this.raw(n3, "params", u3), o3 && (e24 = u3[u3.length - 1], n3.source.end = {line: e24[4], column: e24[5]}, this.spaces = n3.raws.between, n3.raws.between = "")) : (n3.raws.afterName = "", n3.params = ""), i3 && (n3.nodes = [], this.current = n3);
        }, t5.end = function(e24) {
          this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = {line: e24[2], column: e24[3]}, this.current = this.current.parent) : this.unexpectedClose(e24);
        }, t5.endFile = function() {
          this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        }, t5.freeSemicolon = function(e24) {
          if (this.spaces += e24[1], this.current.nodes) {
            var t6 = this.current.nodes[this.current.nodes.length - 1];
            t6 && t6.type === "rule" && !t6.raws.ownSemicolon && (t6.raws.ownSemicolon = this.spaces, this.spaces = "");
          }
        }, t5.init = function(e24, t6, r4) {
          this.current.push(e24), e24.source = {start: {line: t6, column: r4}, input: this.input}, e24.raws.before = this.spaces, this.spaces = "", e24.type !== "comment" && (this.semicolon = false);
        }, t5.raw = function(e24, t6, r4) {
          for (var n3, o3, i3, s3, u3 = r4.length, a3 = "", c3 = true, l3 = /^([.|#])?([\w])+/i, f2 = 0; f2 < u3; f2 += 1)
            (o3 = (n3 = r4[f2])[0]) !== "comment" || e24.type !== "rule" ? o3 === "comment" || o3 === "space" && f2 === u3 - 1 ? c3 = false : a3 += n3[1] : (s3 = r4[f2 - 1], i3 = r4[f2 + 1], s3[0] !== "space" && i3[0] !== "space" && l3.test(s3[1]) && l3.test(i3[1]) ? a3 += n3[1] : c3 = false);
          if (!c3) {
            var p2 = r4.reduce(function(e25, t7) {
              return e25 + t7[1];
            }, "");
            e24.raws[t6] = {value: a3, raw: p2};
          }
          e24[t6] = a3;
        }, t5.spacesAndCommentsFromEnd = function(e24) {
          for (var t6, r4 = ""; e24.length && ((t6 = e24[e24.length - 1][0]) === "space" || t6 === "comment"); )
            r4 = e24.pop()[1] + r4;
          return r4;
        }, t5.spacesAndCommentsFromStart = function(e24) {
          for (var t6, r4 = ""; e24.length && ((t6 = e24[0][0]) === "space" || t6 === "comment"); )
            r4 += e24.shift()[1];
          return r4;
        }, t5.spacesFromEnd = function(e24) {
          for (var t6 = ""; e24.length && e24[e24.length - 1][0] === "space"; )
            t6 = e24.pop()[1] + t6;
          return t6;
        }, t5.stringFrom = function(e24, t6) {
          for (var r4 = "", n3 = t6; n3 < e24.length; n3++)
            r4 += e24[n3][1];
          return e24.splice(t6, e24.length - t6), r4;
        }, t5.colon = function(e24) {
          for (var t6, r4, n3, o3 = 0, i3 = 0; i3 < e24.length; i3++) {
            if ((r4 = (t6 = e24[i3])[0]) === "(" && (o3 += 1), r4 === ")" && (o3 -= 1), o3 === 0 && r4 === ":") {
              if (n3) {
                if (n3[0] === "word" && n3[1] === "progid")
                  continue;
                return i3;
              }
              this.doubleColon(t6);
            }
            n3 = t6;
          }
          return false;
        }, t5.unclosedBracket = function(e24) {
          throw this.input.error("Unclosed bracket", e24[2], e24[3]);
        }, t5.unknownWord = function(e24) {
          throw this.input.error("Unknown word", e24[0][2], e24[0][3]);
        }, t5.unexpectedClose = function(e24) {
          throw this.input.error("Unexpected }", e24[2], e24[3]);
        }, t5.unclosedBlock = function() {
          var e24 = this.current.source.start;
          throw this.input.error("Unclosed block", e24.line, e24.column);
        }, t5.doubleColon = function(e24) {
          throw this.input.error("Double colon", e24[2], e24[3]);
        }, t5.unnamedAtrule = function(e24, t6) {
          throw this.input.error("At-rule without name", t6[2], t6[3]);
        }, t5.precheckMissedSemicolon = function() {
        }, t5.checkMissedSemicolon = function(e24) {
          var t6 = this.colon(e24);
          if (t6 !== false) {
            for (var r4, n3 = 0, o3 = t6 - 1; o3 >= 0 && ((r4 = e24[o3])[0] === "space" || (n3 += 1) !== 2); o3--)
              ;
            throw this.input.error("Missed semicolon", r4[2], r4[3]);
          }
        }, e23;
      }();
      t4.default = l2, e22.exports = t4.default;
    }, 3353: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = s2(r3(2447)), o2 = s2(r3(3974)), i2 = s2(r3(4940));
      function s2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      var u2 = function() {
        function e23(e24, t6) {
          this.loadAnnotation(e24), this.inline = this.startWith(this.annotation, "data:");
          var r4 = t6.map ? t6.map.prev : void 0, n3 = this.loadMap(t6.from, r4);
          n3 && (this.text = n3);
        }
        var t5 = e23.prototype;
        return t5.consumer = function() {
          return this.consumerCache || (this.consumerCache = new n2.default.SourceMapConsumer(this.text)), this.consumerCache;
        }, t5.withContent = function() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }, t5.startWith = function(e24, t6) {
          return !!e24 && e24.substr(0, t6.length) === t6;
        }, t5.getAnnotationURL = function(e24) {
          return e24.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
        }, t5.loadAnnotation = function(e24) {
          var t6 = e24.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
          if (t6 && t6.length > 0) {
            var r4 = t6[t6.length - 1];
            r4 && (this.annotation = this.getAnnotationURL(r4));
          }
        }, t5.decodeInline = function(e24) {
          var t6, r4 = "data:application/json,";
          if (this.startWith(e24, r4))
            return decodeURIComponent(e24.substr(r4.length));
          if (/^data:application\/json;charset=utf-?8;base64,/.test(e24) || /^data:application\/json;base64,/.test(e24))
            return t6 = e24.substr(RegExp.lastMatch.length), Buffer ? Buffer.from(t6, "base64").toString() : window.atob(t6);
          var n3 = e24.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + n3);
        }, t5.loadMap = function(e24, t6) {
          if (t6 === false)
            return false;
          if (t6) {
            if (typeof t6 == "string")
              return t6;
            if (typeof t6 == "function") {
              var r4 = t6(e24);
              if (r4 && i2.default.existsSync && i2.default.existsSync(r4))
                return i2.default.readFileSync(r4, "utf-8").toString().trim();
              throw new Error("Unable to load previous source map: " + r4.toString());
            }
            if (t6 instanceof n2.default.SourceMapConsumer)
              return n2.default.SourceMapGenerator.fromSourceMap(t6).toString();
            if (t6 instanceof n2.default.SourceMapGenerator)
              return t6.toString();
            if (this.isMap(t6))
              return JSON.stringify(t6);
            throw new Error("Unsupported previous source map format: " + t6.toString());
          }
          if (this.inline)
            return this.decodeInline(this.annotation);
          if (this.annotation) {
            var s3 = this.annotation;
            return e24 && (s3 = o2.default.join(o2.default.dirname(e24), s3)), this.root = o2.default.dirname(s3), !(!i2.default.existsSync || !i2.default.existsSync(s3)) && i2.default.readFileSync(s3, "utf-8").toString().trim();
          }
        }, t5.isMap = function(e24) {
          return typeof e24 == "object" && (typeof e24.mappings == "string" || typeof e24._mappings == "string");
        }, e23;
      }();
      t4.default = u2, e22.exports = t4.default;
    }, 9429: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2, o2 = (n2 = r3(6992)) && n2.__esModule ? n2 : {default: n2};
      function i2(e23, t5) {
        var r4;
        if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
          if (Array.isArray(e23) || (r4 = function(e24, t6) {
            if (e24) {
              if (typeof e24 == "string")
                return s2(e24, t6);
              var r5 = Object.prototype.toString.call(e24).slice(8, -1);
              return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? s2(e24, t6) : void 0;
            }
          }(e23)) || t5 && e23 && typeof e23.length == "number") {
            r4 && (e23 = r4);
            var n3 = 0;
            return function() {
              return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (r4 = e23[Symbol.iterator]()).next.bind(r4);
      }
      function s2(e23, t5) {
        (t5 == null || t5 > e23.length) && (t5 = e23.length);
        for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
          n3[r4] = e23[r4];
        return n3;
      }
      var u2 = function() {
        function e23(e24) {
          e24 === void 0 && (e24 = []), this.version = "7.0.36", this.plugins = this.normalize(e24);
        }
        var t5 = e23.prototype;
        return t5.use = function(e24) {
          return this.plugins = this.plugins.concat(this.normalize([e24])), this;
        }, t5.process = function(e24) {
          function t6(t7) {
            return e24.apply(this, arguments);
          }
          return t6.toString = function() {
            return e24.toString();
          }, t6;
        }(function(e24, t6) {
          return t6 === void 0 && (t6 = {}), this.plugins.length === 0 && (t6.parser, t6.stringifier), new o2.default(this, e24, t6);
        }), t5.normalize = function(e24) {
          for (var t6, r4 = [], n3 = i2(e24); !(t6 = n3()).done; ) {
            var o3 = t6.value;
            if (o3.postcss === true) {
              var s3 = o3();
              throw new Error("PostCSS plugin " + s3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users");
            }
            if (o3.postcss && (o3 = o3.postcss), typeof o3 == "object" && Array.isArray(o3.plugins))
              r4 = r4.concat(o3.plugins);
            else if (typeof o3 == "function")
              r4.push(o3);
            else if (typeof o3 != "object" || !o3.parse && !o3.stringify)
              throw typeof o3 == "object" && o3.postcssPlugin ? new Error("PostCSS plugin " + o3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users") : new Error(o3 + " is not a PostCSS plugin");
          }
          return r4;
        }, e23;
      }();
      t4.default = u2, e22.exports = t4.default;
    }, 6865: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2, o2 = (n2 = r3(1662)) && n2.__esModule ? n2 : {default: n2};
      function i2(e23, t5) {
        for (var r4 = 0; r4 < t5.length; r4++) {
          var n3 = t5[r4];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
        }
      }
      var s2 = function() {
        function e23(e24, t6, r5) {
          this.processor = e24, this.messages = [], this.root = t6, this.opts = r5, this.css = void 0, this.map = void 0;
        }
        var t5, r4 = e23.prototype;
        return r4.toString = function() {
          return this.css;
        }, r4.warn = function(e24, t6) {
          t6 === void 0 && (t6 = {}), t6.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t6.plugin = this.lastPlugin.postcssPlugin);
          var r5 = new o2.default(e24, t6);
          return this.messages.push(r5), r5;
        }, r4.warnings = function() {
          return this.messages.filter(function(e24) {
            return e24.type === "warning";
          });
        }, (t5 = [{key: "content", get: function() {
          return this.css;
        }}]) && i2(e23.prototype, t5), e23;
      }();
      t4.default = s2, e22.exports = t4.default;
    }, 7563: (e22, t4, r3) => {
      var n2;
      function o2(e23, t5) {
        var r4;
        if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
          if (Array.isArray(e23) || (r4 = function(e24, t6) {
            if (e24) {
              if (typeof e24 == "string")
                return i2(e24, t6);
              var r5 = Object.prototype.toString.call(e24).slice(8, -1);
              return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? i2(e24, t6) : void 0;
            }
          }(e23)) || t5 && e23 && typeof e23.length == "number") {
            r4 && (e23 = r4);
            var n3 = 0;
            return function() {
              return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (r4 = e23[Symbol.iterator]()).next.bind(r4);
      }
      function i2(e23, t5) {
        (t5 == null || t5 > e23.length) && (t5 = e23.length);
        for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
          n3[r4] = e23[r4];
        return n3;
      }
      t4.__esModule = true, t4.default = void 0;
      var s2 = function(e23) {
        var t5, n3;
        function i3(t6) {
          var r4;
          return (r4 = e23.call(this, t6) || this).type = "root", r4.nodes || (r4.nodes = []), r4;
        }
        n3 = e23, (t5 = i3).prototype = Object.create(n3.prototype), t5.prototype.constructor = t5, t5.__proto__ = n3;
        var s3 = i3.prototype;
        return s3.removeChild = function(t6, r4) {
          var n4 = this.index(t6);
          return !r4 && n4 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n4].raws.before), e23.prototype.removeChild.call(this, t6);
        }, s3.normalize = function(t6, r4, n4) {
          var i4 = e23.prototype.normalize.call(this, t6);
          if (r4) {
            if (n4 === "prepend")
              this.nodes.length > 1 ? r4.raws.before = this.nodes[1].raws.before : delete r4.raws.before;
            else if (this.first !== r4)
              for (var s4, u2 = o2(i4); !(s4 = u2()).done; )
                s4.value.raws.before = r4.raws.before;
          }
          return i4;
        }, s3.toResult = function(e24) {
          return e24 === void 0 && (e24 = {}), new (r3(6992))(new (r3(9429))(), this, e24).stringify();
        }, i3;
      }(((n2 = r3(1204)) && n2.__esModule ? n2 : {default: n2}).default);
      t4.default = s2, e22.exports = t4.default;
    }, 6621: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2 = i2(r3(1204)), o2 = i2(r3(6136));
      function i2(e23) {
        return e23 && e23.__esModule ? e23 : {default: e23};
      }
      function s2(e23, t5) {
        for (var r4 = 0; r4 < t5.length; r4++) {
          var n3 = t5[r4];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
        }
      }
      var u2 = function(e23) {
        var t5, r4, n3;
        function i3(t6) {
          var r5;
          return (r5 = e23.call(this, t6) || this).type = "rule", r5.nodes || (r5.nodes = []), r5;
        }
        return r4 = e23, (t5 = i3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, (n3 = [{key: "selectors", get: function() {
          return o2.default.comma(this.selector);
        }, set: function(e24) {
          var t6 = this.selector ? this.selector.match(/,\s*/) : null, r5 = t6 ? t6[0] : "," + this.raw("between", "beforeOpen");
          this.selector = e24.join(r5);
        }}]) && s2(i3.prototype, n3), i3;
      }(n2.default);
      t4.default = u2, e22.exports = t4.default;
    }, 5701: (e22, t4) => {
      t4.__esModule = true, t4.default = void 0;
      var r3 = {colon: ": ", indent: "    ", beforeDecl: "\n", beforeRule: "\n", beforeOpen: " ", beforeClose: "\n", beforeComment: "\n", after: "\n", emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false}, n2 = function() {
        function e23(e24) {
          this.builder = e24;
        }
        var t5 = e23.prototype;
        return t5.stringify = function(e24, t6) {
          this[e24.type](e24, t6);
        }, t5.root = function(e24) {
          this.body(e24), e24.raws.after && this.builder(e24.raws.after);
        }, t5.comment = function(e24) {
          var t6 = this.raw(e24, "left", "commentLeft"), r4 = this.raw(e24, "right", "commentRight");
          this.builder("/*" + t6 + e24.text + r4 + "*/", e24);
        }, t5.decl = function(e24, t6) {
          var r4 = this.raw(e24, "between", "colon"), n3 = e24.prop + r4 + this.rawValue(e24, "value");
          e24.important && (n3 += e24.raws.important || " !important"), t6 && (n3 += ";"), this.builder(n3, e24);
        }, t5.rule = function(e24) {
          this.block(e24, this.rawValue(e24, "selector")), e24.raws.ownSemicolon && this.builder(e24.raws.ownSemicolon, e24, "end");
        }, t5.atrule = function(e24, t6) {
          var r4 = "@" + e24.name, n3 = e24.params ? this.rawValue(e24, "params") : "";
          if (e24.raws.afterName !== void 0 ? r4 += e24.raws.afterName : n3 && (r4 += " "), e24.nodes)
            this.block(e24, r4 + n3);
          else {
            var o2 = (e24.raws.between || "") + (t6 ? ";" : "");
            this.builder(r4 + n3 + o2, e24);
          }
        }, t5.body = function(e24) {
          for (var t6 = e24.nodes.length - 1; t6 > 0 && e24.nodes[t6].type === "comment"; )
            t6 -= 1;
          for (var r4 = this.raw(e24, "semicolon"), n3 = 0; n3 < e24.nodes.length; n3++) {
            var o2 = e24.nodes[n3], i2 = this.raw(o2, "before");
            i2 && this.builder(i2), this.stringify(o2, t6 !== n3 || r4);
          }
        }, t5.block = function(e24, t6) {
          var r4, n3 = this.raw(e24, "between", "beforeOpen");
          this.builder(t6 + n3 + "{", e24, "start"), e24.nodes && e24.nodes.length ? (this.body(e24), r4 = this.raw(e24, "after")) : r4 = this.raw(e24, "after", "emptyBody"), r4 && this.builder(r4), this.builder("}", e24, "end");
        }, t5.raw = function(e24, t6, n3) {
          var o2;
          if (n3 || (n3 = t6), t6 && (o2 = e24.raws[t6]) !== void 0)
            return o2;
          var i2 = e24.parent;
          if (n3 === "before" && (!i2 || i2.type === "root" && i2.first === e24))
            return "";
          if (!i2)
            return r3[n3];
          var s2 = e24.root();
          if (s2.rawCache || (s2.rawCache = {}), s2.rawCache[n3] !== void 0)
            return s2.rawCache[n3];
          if (n3 === "before" || n3 === "after")
            return this.beforeAfter(e24, n3);
          var u2, a2 = "raw" + ((u2 = n3)[0].toUpperCase() + u2.slice(1));
          return this[a2] ? o2 = this[a2](s2, e24) : s2.walk(function(e25) {
            if ((o2 = e25.raws[t6]) !== void 0)
              return false;
          }), o2 === void 0 && (o2 = r3[n3]), s2.rawCache[n3] = o2, o2;
        }, t5.rawSemicolon = function(e24) {
          var t6;
          return e24.walk(function(e25) {
            if (e25.nodes && e25.nodes.length && e25.last.type === "decl" && (t6 = e25.raws.semicolon) !== void 0)
              return false;
          }), t6;
        }, t5.rawEmptyBody = function(e24) {
          var t6;
          return e24.walk(function(e25) {
            if (e25.nodes && e25.nodes.length === 0 && (t6 = e25.raws.after) !== void 0)
              return false;
          }), t6;
        }, t5.rawIndent = function(e24) {
          return e24.raws.indent ? e24.raws.indent : (e24.walk(function(r4) {
            var n3 = r4.parent;
            if (n3 && n3 !== e24 && n3.parent && n3.parent === e24 && r4.raws.before !== void 0) {
              var o2 = r4.raws.before.split("\n");
              return t6 = (t6 = o2[o2.length - 1]).replace(/[^\s]/g, ""), false;
            }
          }), t6);
          var t6;
        }, t5.rawBeforeComment = function(e24, t6) {
          var r4;
          return e24.walkComments(function(e25) {
            if (e25.raws.before !== void 0)
              return (r4 = e25.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
          }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeDecl") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
        }, t5.rawBeforeDecl = function(e24, t6) {
          var r4;
          return e24.walkDecls(function(e25) {
            if (e25.raws.before !== void 0)
              return (r4 = e25.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
          }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeRule") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
        }, t5.rawBeforeRule = function(e24) {
          var t6;
          return e24.walk(function(r4) {
            if (r4.nodes && (r4.parent !== e24 || e24.first !== r4) && r4.raws.before !== void 0)
              return (t6 = r4.raws.before).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
          }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
        }, t5.rawBeforeClose = function(e24) {
          var t6;
          return e24.walk(function(e25) {
            if (e25.nodes && e25.nodes.length > 0 && e25.raws.after !== void 0)
              return (t6 = e25.raws.after).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
          }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
        }, t5.rawBeforeOpen = function(e24) {
          var t6;
          return e24.walk(function(e25) {
            if (e25.type !== "decl" && (t6 = e25.raws.between) !== void 0)
              return false;
          }), t6;
        }, t5.rawColon = function(e24) {
          var t6;
          return e24.walkDecls(function(e25) {
            if (e25.raws.between !== void 0)
              return t6 = e25.raws.between.replace(/[^\s:]/g, ""), false;
          }), t6;
        }, t5.beforeAfter = function(e24, t6) {
          var r4;
          r4 = e24.type === "decl" ? this.raw(e24, null, "beforeDecl") : e24.type === "comment" ? this.raw(e24, null, "beforeComment") : t6 === "before" ? this.raw(e24, null, "beforeRule") : this.raw(e24, null, "beforeClose");
          for (var n3 = e24.parent, o2 = 0; n3 && n3.type !== "root"; )
            o2 += 1, n3 = n3.parent;
          if (r4.indexOf("\n") !== -1) {
            var i2 = this.raw(e24, null, "indent");
            if (i2.length)
              for (var s2 = 0; s2 < o2; s2++)
                r4 += i2;
          }
          return r4;
        }, t5.rawValue = function(e24, t6) {
          var r4 = e24[t6], n3 = e24.raws[t6];
          return n3 && n3.value === r4 ? n3.raw : r4;
        }, e23;
      }();
      t4.default = n2, e22.exports = t4.default;
    }, 6157: (e22, t4, r3) => {
      t4.__esModule = true, t4.default = void 0;
      var n2, o2 = (n2 = r3(5701)) && n2.__esModule ? n2 : {default: n2}, i2 = function(e23, t5) {
        new o2.default(t5).stringify(e23);
      };
      t4.default = i2, e22.exports = t4.default;
    }, 1157: (e22, t4) => {
      t4.__esModule = true, t4.default = function(e23, t5) {
        t5 === void 0 && (t5 = {});
        var x2, A2, k2, O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2 = e23.css.valueOf(), $2 = t5.ignoreErrors, U2 = P2.length, G2 = -1, W2 = 1, z2 = 0, V2 = [], q2 = [];
        function X2(t6) {
          throw e23.error("Unclosed " + t6, W2, z2 - G2);
        }
        return {back: function(e24) {
          q2.push(e24);
        }, nextToken: function(e24) {
          if (q2.length)
            return q2.pop();
          if (!(z2 >= U2)) {
            var t6 = !!e24 && e24.ignoreUnclosed;
            switch (((x2 = P2.charCodeAt(z2)) === s2 || x2 === a2 || x2 === l2 && P2.charCodeAt(z2 + 1) !== s2) && (G2 = z2, W2 += 1), x2) {
              case s2:
              case u2:
              case c2:
              case l2:
              case a2:
                A2 = z2;
                do {
                  A2 += 1, (x2 = P2.charCodeAt(A2)) === s2 && (G2 = A2, W2 += 1);
                } while (x2 === u2 || x2 === s2 || x2 === c2 || x2 === l2 || x2 === a2);
                B2 = ["space", P2.slice(z2, A2)], z2 = A2 - 1;
                break;
              case f2:
              case p2:
              case D2:
              case g2:
              case y2:
              case m2:
              case d2:
                var J2 = String.fromCharCode(x2);
                B2 = [J2, J2, W2, z2 - G2];
                break;
              case h2:
                if (j2 = V2.length ? V2.pop()[1] : "", L2 = P2.charCodeAt(z2 + 1), j2 === "url" && L2 !== r3 && L2 !== n2 && L2 !== u2 && L2 !== s2 && L2 !== c2 && L2 !== a2 && L2 !== l2) {
                  A2 = z2;
                  do {
                    if (M2 = false, (A2 = P2.indexOf(")", A2 + 1)) === -1) {
                      if ($2 || t6) {
                        A2 = z2;
                        break;
                      }
                      X2("bracket");
                    }
                    for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                      R2 -= 1, M2 = !M2;
                  } while (M2);
                  B2 = ["brackets", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                } else
                  A2 = P2.indexOf(")", z2 + 1), S2 = P2.slice(z2, A2 + 1), A2 === -1 || E2.test(S2) ? B2 = ["(", "(", W2, z2 - G2] : (B2 = ["brackets", S2, W2, z2 - G2, W2, A2 - G2], z2 = A2);
                break;
              case r3:
              case n2:
                k2 = x2 === r3 ? "'" : '"', A2 = z2;
                do {
                  if (M2 = false, (A2 = P2.indexOf(k2, A2 + 1)) === -1) {
                    if ($2 || t6) {
                      A2 = z2 + 1;
                      break;
                    }
                    X2("string");
                  }
                  for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                    R2 -= 1, M2 = !M2;
                } while (M2);
                S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = ["string", P2.slice(z2, A2 + 1), W2, z2 - G2, I2, A2 - N2], G2 = N2, W2 = I2, z2 = A2;
                break;
              case w2:
                b2.lastIndex = z2 + 1, b2.test(P2), A2 = b2.lastIndex === 0 ? P2.length - 1 : b2.lastIndex - 2, B2 = ["at-word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                break;
              case o2:
                for (A2 = z2, T2 = true; P2.charCodeAt(A2 + 1) === o2; )
                  A2 += 1, T2 = !T2;
                if (x2 = P2.charCodeAt(A2 + 1), T2 && x2 !== i2 && x2 !== u2 && x2 !== s2 && x2 !== c2 && x2 !== l2 && x2 !== a2 && (A2 += 1, F2.test(P2.charAt(A2)))) {
                  for (; F2.test(P2.charAt(A2 + 1)); )
                    A2 += 1;
                  P2.charCodeAt(A2 + 1) === u2 && (A2 += 1);
                }
                B2 = ["word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                break;
              default:
                x2 === i2 && P2.charCodeAt(z2 + 1) === v2 ? ((A2 = P2.indexOf("*/", z2 + 2) + 1) === 0 && ($2 || t6 ? A2 = P2.length : X2("comment")), S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = ["comment", S2, W2, z2 - G2, I2, A2 - N2], G2 = N2, W2 = I2, z2 = A2) : (C2.lastIndex = z2 + 1, C2.test(P2), A2 = C2.lastIndex === 0 ? P2.length - 1 : C2.lastIndex - 2, B2 = ["word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], V2.push(B2), z2 = A2);
            }
            return z2++, B2;
          }
        }, endOfFile: function() {
          return q2.length === 0 && z2 >= U2;
        }, position: function() {
          return z2;
        }};
      };
      var r3 = "'".charCodeAt(0), n2 = '"'.charCodeAt(0), o2 = "\\".charCodeAt(0), i2 = "/".charCodeAt(0), s2 = "\n".charCodeAt(0), u2 = " ".charCodeAt(0), a2 = "\f".charCodeAt(0), c2 = "	".charCodeAt(0), l2 = "\r".charCodeAt(0), f2 = "[".charCodeAt(0), p2 = "]".charCodeAt(0), h2 = "(".charCodeAt(0), d2 = ")".charCodeAt(0), D2 = "{".charCodeAt(0), g2 = "}".charCodeAt(0), m2 = ";".charCodeAt(0), v2 = "*".charCodeAt(0), y2 = ":".charCodeAt(0), w2 = "@".charCodeAt(0), b2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, C2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, E2 = /.[\\/("'\n]/, F2 = /[a-f0-9]/i;
      e22.exports = t4.default;
    }, 6574: (e22, t4) => {
      t4.__esModule = true, t4.default = function(e23) {
        r3[e23] || (r3[e23] = true, typeof console != "undefined" && console.warn && console.warn(e23));
      };
      var r3 = {};
      e22.exports = t4.default;
    }, 1662: (e22, t4) => {
      t4.__esModule = true, t4.default = void 0;
      var r3 = function() {
        function e23(e24, t5) {
          if (t5 === void 0 && (t5 = {}), this.type = "warning", this.text = e24, t5.node && t5.node.source) {
            var r4 = t5.node.positionBy(t5);
            this.line = r4.line, this.column = r4.column;
          }
          for (var n2 in t5)
            this[n2] = t5[n2];
        }
        return e23.prototype.toString = function() {
          return this.node ? this.node.error(this.text, {plugin: this.plugin, index: this.index, word: this.word}).message : this.plugin ? this.plugin + ": " + this.text : this.text;
        }, e23;
      }();
      t4.default = r3, e22.exports = t4.default;
    }, 6210: (e22, t4, r3) => {
      const n2 = r3(895), {MAX_LENGTH: o2, MAX_SAFE_INTEGER: i2} = r3(8523), {re: s2, t: u2} = r3(3443), a2 = r3(8077), {compareIdentifiers: c2} = r3(8337);
      class l2 {
        constructor(e23, t5) {
          if (t5 = a2(t5), e23 instanceof l2) {
            if (e23.loose === !!t5.loose && e23.includePrerelease === !!t5.includePrerelease)
              return e23;
            e23 = e23.version;
          } else if (typeof e23 != "string")
            throw new TypeError(`Invalid Version: ${e23}`);
          if (e23.length > o2)
            throw new TypeError(`version is longer than ${o2} characters`);
          n2("SemVer", e23, t5), this.options = t5, this.loose = !!t5.loose, this.includePrerelease = !!t5.includePrerelease;
          const r4 = e23.trim().match(t5.loose ? s2[u2.LOOSE] : s2[u2.FULL]);
          if (!r4)
            throw new TypeError(`Invalid Version: ${e23}`);
          if (this.raw = e23, this.major = +r4[1], this.minor = +r4[2], this.patch = +r4[3], this.major > i2 || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > i2 || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > i2 || this.patch < 0)
            throw new TypeError("Invalid patch version");
          r4[4] ? this.prerelease = r4[4].split(".").map((e24) => {
            if (/^[0-9]+$/.test(e24)) {
              const t6 = +e24;
              if (t6 >= 0 && t6 < i2)
                return t6;
            }
            return e24;
          }) : this.prerelease = [], this.build = r4[5] ? r4[5].split(".") : [], this.format();
        }
        format() {
          return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
        }
        toString() {
          return this.version;
        }
        compare(e23) {
          if (n2("SemVer.compare", this.version, this.options, e23), !(e23 instanceof l2)) {
            if (typeof e23 == "string" && e23 === this.version)
              return 0;
            e23 = new l2(e23, this.options);
          }
          return e23.version === this.version ? 0 : this.compareMain(e23) || this.comparePre(e23);
        }
        compareMain(e23) {
          return e23 instanceof l2 || (e23 = new l2(e23, this.options)), c2(this.major, e23.major) || c2(this.minor, e23.minor) || c2(this.patch, e23.patch);
        }
        comparePre(e23) {
          if (e23 instanceof l2 || (e23 = new l2(e23, this.options)), this.prerelease.length && !e23.prerelease.length)
            return -1;
          if (!this.prerelease.length && e23.prerelease.length)
            return 1;
          if (!this.prerelease.length && !e23.prerelease.length)
            return 0;
          let t5 = 0;
          do {
            const r4 = this.prerelease[t5], o3 = e23.prerelease[t5];
            if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
              return 0;
            if (o3 === void 0)
              return 1;
            if (r4 === void 0)
              return -1;
            if (r4 !== o3)
              return c2(r4, o3);
          } while (++t5);
        }
        compareBuild(e23) {
          e23 instanceof l2 || (e23 = new l2(e23, this.options));
          let t5 = 0;
          do {
            const r4 = this.build[t5], o3 = e23.build[t5];
            if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
              return 0;
            if (o3 === void 0)
              return 1;
            if (r4 === void 0)
              return -1;
            if (r4 !== o3)
              return c2(r4, o3);
          } while (++t5);
        }
        inc(e23, t5) {
          switch (e23) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t5);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t5);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", t5), this.inc("pre", t5);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", t5), this.inc("pre", t5);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0)
                this.prerelease = [0];
              else {
                let e24 = this.prerelease.length;
                for (; --e24 >= 0; )
                  typeof this.prerelease[e24] == "number" && (this.prerelease[e24]++, e24 = -2);
                e24 === -1 && this.prerelease.push(0);
              }
              t5 && (this.prerelease[0] === t5 ? isNaN(this.prerelease[1]) && (this.prerelease = [t5, 0]) : this.prerelease = [t5, 0]);
              break;
            default:
              throw new Error(`invalid increment argument: ${e23}`);
          }
          return this.format(), this.raw = this.version, this;
        }
      }
      e22.exports = l2;
    }, 2828: (e22, t4, r3) => {
      const n2 = r3(6210);
      e22.exports = (e23, t5, r4) => new n2(e23, r4).compare(new n2(t5, r4));
    }, 9195: (e22, t4, r3) => {
      const n2 = r3(2828);
      e22.exports = (e23, t5, r4) => n2(e23, t5, r4) >= 0;
    }, 3725: (e22, t4, r3) => {
      const n2 = r3(2828);
      e22.exports = (e23, t5, r4) => n2(e23, t5, r4) < 0;
    }, 8523: (e22) => {
      const t4 = Number.MAX_SAFE_INTEGER || 9007199254740991;
      e22.exports = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: t4, MAX_SAFE_COMPONENT_LENGTH: 16};
    }, 895: (e22) => {
      const t4 = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...e23) => console.error("SEMVER", ...e23) : () => {
      };
      e22.exports = t4;
    }, 8337: (e22) => {
      const t4 = /^[0-9]+$/, r3 = (e23, r4) => {
        const n2 = t4.test(e23), o2 = t4.test(r4);
        return n2 && o2 && (e23 = +e23, r4 = +r4), e23 === r4 ? 0 : n2 && !o2 ? -1 : o2 && !n2 ? 1 : e23 < r4 ? -1 : 1;
      };
      e22.exports = {compareIdentifiers: r3, rcompareIdentifiers: (e23, t5) => r3(t5, e23)};
    }, 8077: (e22) => {
      const t4 = ["includePrerelease", "loose", "rtl"];
      e22.exports = (e23) => e23 ? typeof e23 != "object" ? {loose: true} : t4.filter((t5) => e23[t5]).reduce((e24, t5) => (e24[t5] = true, e24), {}) : {};
    }, 3443: (e22, t4, r3) => {
      const {MAX_SAFE_COMPONENT_LENGTH: n2} = r3(8523), o2 = r3(895), i2 = (t4 = e22.exports = {}).re = [], s2 = t4.src = [], u2 = t4.t = {};
      let a2 = 0;
      const c2 = (e23, t5, r4) => {
        const n3 = a2++;
        o2(n3, t5), u2[e23] = n3, s2[n3] = t5, i2[n3] = new RegExp(t5, r4 ? "g" : void 0);
      };
      c2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c2("MAINVERSION", `(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})`), c2("MAINVERSIONLOOSE", `(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})`), c2("PRERELEASEIDENTIFIER", `(?:${s2[u2.NUMERICIDENTIFIER]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASEIDENTIFIERLOOSE", `(?:${s2[u2.NUMERICIDENTIFIERLOOSE]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASE", `(?:-(${s2[u2.PRERELEASEIDENTIFIER]}(?:\\.${s2[u2.PRERELEASEIDENTIFIER]})*))`), c2("PRERELEASELOOSE", `(?:-?(${s2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), c2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c2("BUILD", `(?:\\+(${s2[u2.BUILDIDENTIFIER]}(?:\\.${s2[u2.BUILDIDENTIFIER]})*))`), c2("FULLPLAIN", `v?${s2[u2.MAINVERSION]}${s2[u2.PRERELEASE]}?${s2[u2.BUILD]}?`), c2("FULL", `^${s2[u2.FULLPLAIN]}$`), c2("LOOSEPLAIN", `[v=\\s]*${s2[u2.MAINVERSIONLOOSE]}${s2[u2.PRERELEASELOOSE]}?${s2[u2.BUILD]}?`), c2("LOOSE", `^${s2[u2.LOOSEPLAIN]}$`), c2("GTLT", "((?:<|>)?=?)"), c2("XRANGEIDENTIFIERLOOSE", `${s2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), c2("XRANGEIDENTIFIER", `${s2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), c2("XRANGEPLAIN", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:${s2[u2.PRERELEASE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGEPLAINLOOSE", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:${s2[u2.PRERELEASELOOSE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAIN]}$`), c2("XRANGELOOSE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), c2("COERCERTL", s2[u2.COERCE], true), c2("LONETILDE", "(?:~>?)"), c2("TILDETRIM", `(\\s*)${s2[u2.LONETILDE]}\\s+`, true), t4.tildeTrimReplace = "$1~", c2("TILDE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAIN]}$`), c2("TILDELOOSE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("LONECARET", "(?:\\^)"), c2("CARETTRIM", `(\\s*)${s2[u2.LONECARET]}\\s+`, true), t4.caretTrimReplace = "$1^", c2("CARET", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAIN]}$`), c2("CARETLOOSE", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COMPARATORLOOSE", `^${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]})$|^$`), c2("COMPARATOR", `^${s2[u2.GTLT]}\\s*(${s2[u2.FULLPLAIN]})$|^$`), c2("COMPARATORTRIM", `(\\s*)${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]}|${s2[u2.XRANGEPLAIN]})`, true), t4.comparatorTrimReplace = "$1$2$3", c2("HYPHENRANGE", `^\\s*(${s2[u2.XRANGEPLAIN]})\\s+-\\s+(${s2[u2.XRANGEPLAIN]})\\s*$`), c2("HYPHENRANGELOOSE", `^\\s*(${s2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${s2[u2.XRANGEPLAINLOOSE]})\\s*$`), c2("STAR", "(<|>)?=?\\s*\\*"), c2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    }, 6715: (e22, t4, r3) => {
      var n2 = r3(7837), o2 = Object.prototype.hasOwnProperty, i2 = typeof Map != "undefined";
      function s2() {
        this._array = [], this._set = i2 ? new Map() : Object.create(null);
      }
      s2.fromArray = function(e23, t5) {
        for (var r4 = new s2(), n3 = 0, o3 = e23.length; n3 < o3; n3++)
          r4.add(e23[n3], t5);
        return r4;
      }, s2.prototype.size = function() {
        return i2 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      }, s2.prototype.add = function(e23, t5) {
        var r4 = i2 ? e23 : n2.toSetString(e23), s3 = i2 ? this.has(e23) : o2.call(this._set, r4), u2 = this._array.length;
        s3 && !t5 || this._array.push(e23), s3 || (i2 ? this._set.set(e23, u2) : this._set[r4] = u2);
      }, s2.prototype.has = function(e23) {
        if (i2)
          return this._set.has(e23);
        var t5 = n2.toSetString(e23);
        return o2.call(this._set, t5);
      }, s2.prototype.indexOf = function(e23) {
        if (i2) {
          var t5 = this._set.get(e23);
          if (t5 >= 0)
            return t5;
        } else {
          var r4 = n2.toSetString(e23);
          if (o2.call(this._set, r4))
            return this._set[r4];
        }
        throw new Error('"' + e23 + '" is not in the set.');
      }, s2.prototype.at = function(e23) {
        if (e23 >= 0 && e23 < this._array.length)
          return this._array[e23];
        throw new Error("No element indexed by " + e23);
      }, s2.prototype.toArray = function() {
        return this._array.slice();
      }, t4.I = s2;
    }, 4886: (e22, t4, r3) => {
      var n2 = r3(4122);
      t4.encode = function(e23) {
        var t5, r4 = "", o2 = function(e24) {
          return e24 < 0 ? 1 + (-e24 << 1) : 0 + (e24 << 1);
        }(e23);
        do {
          t5 = 31 & o2, (o2 >>>= 5) > 0 && (t5 |= 32), r4 += n2.encode(t5);
        } while (o2 > 0);
        return r4;
      }, t4.decode = function(e23, t5, r4) {
        var o2, i2, s2, u2, a2 = e23.length, c2 = 0, l2 = 0;
        do {
          if (t5 >= a2)
            throw new Error("Expected more digits in base 64 VLQ value.");
          if ((i2 = n2.decode(e23.charCodeAt(t5++))) === -1)
            throw new Error("Invalid base64 digit: " + e23.charAt(t5 - 1));
          o2 = !!(32 & i2), c2 += (i2 &= 31) << l2, l2 += 5;
        } while (o2);
        r4.value = (u2 = (s2 = c2) >> 1, (1 & s2) == 1 ? -u2 : u2), r4.rest = t5;
      };
    }, 4122: (e22, t4) => {
      var r3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      t4.encode = function(e23) {
        if (0 <= e23 && e23 < r3.length)
          return r3[e23];
        throw new TypeError("Must be between 0 and 63: " + e23);
      }, t4.decode = function(e23) {
        return 65 <= e23 && e23 <= 90 ? e23 - 65 : 97 <= e23 && e23 <= 122 ? e23 - 97 + 26 : 48 <= e23 && e23 <= 57 ? e23 - 48 + 52 : e23 == 43 ? 62 : e23 == 47 ? 63 : -1;
      };
    }, 8593: (e22, t4) => {
      function r3(e23, n2, o2, i2, s2, u2) {
        var a2 = Math.floor((n2 - e23) / 2) + e23, c2 = s2(o2, i2[a2], true);
        return c2 === 0 ? a2 : c2 > 0 ? n2 - a2 > 1 ? r3(a2, n2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? n2 < i2.length ? n2 : -1 : a2 : a2 - e23 > 1 ? r3(e23, a2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? a2 : e23 < 0 ? -1 : e23;
      }
      t4.GREATEST_LOWER_BOUND = 1, t4.LEAST_UPPER_BOUND = 2, t4.search = function(e23, n2, o2, i2) {
        if (n2.length === 0)
          return -1;
        var s2 = r3(-1, n2.length, e23, n2, o2, i2 || t4.GREATEST_LOWER_BOUND);
        if (s2 < 0)
          return -1;
        for (; s2 - 1 >= 0 && o2(n2[s2], n2[s2 - 1], true) === 0; )
          --s2;
        return s2;
      };
    }, 1028: (e22, t4, r3) => {
      r3(4070);
      var n2 = r3(7837);
      function o2() {
        this._array = [], this._sorted = true, this._last = {generatedLine: -1, generatedColumn: 0};
      }
      o2.prototype.unsortedForEach = function(e23, t5) {
        this._array.forEach(e23, t5);
      }, o2.prototype.add = function(e23) {
        var t5, r4, o3, i2, s2, u2;
        r4 = e23, o3 = (t5 = this._last).generatedLine, i2 = r4.generatedLine, s2 = t5.generatedColumn, u2 = r4.generatedColumn, i2 > o3 || i2 == o3 && u2 >= s2 || n2.compareByGeneratedPositionsInflated(t5, r4) <= 0 ? (this._last = e23, this._array.push(e23)) : (this._sorted = false, this._array.push(e23));
      }, o2.prototype.toArray = function() {
        return this._sorted || (this._array.sort(n2.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
      }, t4.H = o2;
    }, 6711: (e22, t4) => {
      function r3(e23, t5, r4) {
        var n3 = e23[t5];
        e23[t5] = e23[r4], e23[r4] = n3;
      }
      function n2(e23, t5, o2, i2) {
        if (o2 < i2) {
          var s2 = o2 - 1;
          r3(e23, (l2 = o2, f2 = i2, Math.round(l2 + Math.random() * (f2 - l2))), i2);
          for (var u2 = e23[i2], a2 = o2; a2 < i2; a2++)
            t5(e23[a2], u2) <= 0 && r3(e23, s2 += 1, a2);
          r3(e23, s2 + 1, a2);
          var c2 = s2 + 1;
          n2(e23, t5, o2, c2 - 1), n2(e23, t5, c2 + 1, i2);
        }
        var l2, f2;
      }
      t4.U = function(e23, t5) {
        n2(e23, t5, 0, e23.length - 1);
      };
    }, 8985: (e22, t4, r3) => {
      var n2 = r3(7837), o2 = r3(8593), i2 = r3(6715).I, s2 = r3(4886), u2 = r3(6711).U;
      function a2(e23, t5) {
        var r4 = e23;
        return typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23)), r4.sections != null ? new f2(r4, t5) : new c2(r4, t5);
      }
      function c2(e23, t5) {
        var r4 = e23;
        typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23));
        var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sources"), u3 = n2.getArg(r4, "names", []), a3 = n2.getArg(r4, "sourceRoot", null), c3 = n2.getArg(r4, "sourcesContent", null), l3 = n2.getArg(r4, "mappings"), f3 = n2.getArg(r4, "file", null);
        if (o3 != this._version)
          throw new Error("Unsupported version: " + o3);
        a3 && (a3 = n2.normalize(a3)), s3 = s3.map(String).map(n2.normalize).map(function(e24) {
          return a3 && n2.isAbsolute(a3) && n2.isAbsolute(e24) ? n2.relative(a3, e24) : e24;
        }), this._names = i2.fromArray(u3.map(String), true), this._sources = i2.fromArray(s3, true), this._absoluteSources = this._sources.toArray().map(function(e24) {
          return n2.computeSourceURL(a3, e24, t5);
        }), this.sourceRoot = a3, this.sourcesContent = c3, this._mappings = l3, this._sourceMapURL = t5, this.file = f3;
      }
      function l2() {
        this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
      }
      function f2(e23, t5) {
        var r4 = e23;
        typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23));
        var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sections");
        if (o3 != this._version)
          throw new Error("Unsupported version: " + o3);
        this._sources = new i2(), this._names = new i2();
        var u3 = {line: -1, column: 0};
        this._sections = s3.map(function(e24) {
          if (e24.url)
            throw new Error("Support for url field in sections not implemented.");
          var r5 = n2.getArg(e24, "offset"), o4 = n2.getArg(r5, "line"), i3 = n2.getArg(r5, "column");
          if (o4 < u3.line || o4 === u3.line && i3 < u3.column)
            throw new Error("Section offsets must be ordered and non-overlapping.");
          return u3 = r5, {generatedOffset: {generatedLine: o4 + 1, generatedColumn: i3 + 1}, consumer: new a2(n2.getArg(e24, "map"), t5)};
        });
      }
      a2.fromSourceMap = function(e23, t5) {
        return c2.fromSourceMap(e23, t5);
      }, a2.prototype._version = 3, a2.prototype.__generatedMappings = null, Object.defineProperty(a2.prototype, "_generatedMappings", {configurable: true, enumerable: true, get: function() {
        return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
      }}), a2.prototype.__originalMappings = null, Object.defineProperty(a2.prototype, "_originalMappings", {configurable: true, enumerable: true, get: function() {
        return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
      }}), a2.prototype._charIsMappingSeparator = function(e23, t5) {
        var r4 = e23.charAt(t5);
        return r4 === ";" || r4 === ",";
      }, a2.prototype._parseMappings = function(e23, t5) {
        throw new Error("Subclasses must implement _parseMappings");
      }, a2.GENERATED_ORDER = 1, a2.ORIGINAL_ORDER = 2, a2.GREATEST_LOWER_BOUND = 1, a2.LEAST_UPPER_BOUND = 2, a2.prototype.eachMapping = function(e23, t5, r4) {
        var o3, i3 = t5 || null;
        switch (r4 || a2.GENERATED_ORDER) {
          case a2.GENERATED_ORDER:
            o3 = this._generatedMappings;
            break;
          case a2.ORIGINAL_ORDER:
            o3 = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var s3 = this.sourceRoot;
        o3.map(function(e24) {
          var t6 = e24.source === null ? null : this._sources.at(e24.source);
          return {source: t6 = n2.computeSourceURL(s3, t6, this._sourceMapURL), generatedLine: e24.generatedLine, generatedColumn: e24.generatedColumn, originalLine: e24.originalLine, originalColumn: e24.originalColumn, name: e24.name === null ? null : this._names.at(e24.name)};
        }, this).forEach(e23, i3);
      }, a2.prototype.allGeneratedPositionsFor = function(e23) {
        var t5 = n2.getArg(e23, "line"), r4 = {source: n2.getArg(e23, "source"), originalLine: t5, originalColumn: n2.getArg(e23, "column", 0)};
        if (r4.source = this._findSourceIndex(r4.source), r4.source < 0)
          return [];
        var i3 = [], s3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, o2.LEAST_UPPER_BOUND);
        if (s3 >= 0) {
          var u3 = this._originalMappings[s3];
          if (e23.column === void 0)
            for (var a3 = u3.originalLine; u3 && u3.originalLine === a3; )
              i3.push({line: n2.getArg(u3, "generatedLine", null), column: n2.getArg(u3, "generatedColumn", null), lastColumn: n2.getArg(u3, "lastGeneratedColumn", null)}), u3 = this._originalMappings[++s3];
          else
            for (var c3 = u3.originalColumn; u3 && u3.originalLine === t5 && u3.originalColumn == c3; )
              i3.push({line: n2.getArg(u3, "generatedLine", null), column: n2.getArg(u3, "generatedColumn", null), lastColumn: n2.getArg(u3, "lastGeneratedColumn", null)}), u3 = this._originalMappings[++s3];
        }
        return i3;
      }, t4.SourceMapConsumer = a2, c2.prototype = Object.create(a2.prototype), c2.prototype.consumer = a2, c2.prototype._findSourceIndex = function(e23) {
        var t5, r4 = e23;
        if (this.sourceRoot != null && (r4 = n2.relative(this.sourceRoot, r4)), this._sources.has(r4))
          return this._sources.indexOf(r4);
        for (t5 = 0; t5 < this._absoluteSources.length; ++t5)
          if (this._absoluteSources[t5] == e23)
            return t5;
        return -1;
      }, c2.fromSourceMap = function(e23, t5) {
        var r4 = Object.create(c2.prototype), o3 = r4._names = i2.fromArray(e23._names.toArray(), true), s3 = r4._sources = i2.fromArray(e23._sources.toArray(), true);
        r4.sourceRoot = e23._sourceRoot, r4.sourcesContent = e23._generateSourcesContent(r4._sources.toArray(), r4.sourceRoot), r4.file = e23._file, r4._sourceMapURL = t5, r4._absoluteSources = r4._sources.toArray().map(function(e24) {
          return n2.computeSourceURL(r4.sourceRoot, e24, t5);
        });
        for (var a3 = e23._mappings.toArray().slice(), f3 = r4.__generatedMappings = [], p2 = r4.__originalMappings = [], h2 = 0, d2 = a3.length; h2 < d2; h2++) {
          var D2 = a3[h2], g2 = new l2();
          g2.generatedLine = D2.generatedLine, g2.generatedColumn = D2.generatedColumn, D2.source && (g2.source = s3.indexOf(D2.source), g2.originalLine = D2.originalLine, g2.originalColumn = D2.originalColumn, D2.name && (g2.name = o3.indexOf(D2.name)), p2.push(g2)), f3.push(g2);
        }
        return u2(r4.__originalMappings, n2.compareByOriginalPositions), r4;
      }, c2.prototype._version = 3, Object.defineProperty(c2.prototype, "sources", {get: function() {
        return this._absoluteSources.slice();
      }}), c2.prototype._parseMappings = function(e23, t5) {
        for (var r4, o3, i3, a3, c3, f3 = 1, p2 = 0, h2 = 0, d2 = 0, D2 = 0, g2 = 0, m2 = e23.length, v2 = 0, y2 = {}, w2 = {}, b2 = [], C2 = []; v2 < m2; )
          if (e23.charAt(v2) === ";")
            f3++, v2++, p2 = 0;
          else if (e23.charAt(v2) === ",")
            v2++;
          else {
            for ((r4 = new l2()).generatedLine = f3, a3 = v2; a3 < m2 && !this._charIsMappingSeparator(e23, a3); a3++)
              ;
            if (i3 = y2[o3 = e23.slice(v2, a3)])
              v2 += o3.length;
            else {
              for (i3 = []; v2 < a3; )
                s2.decode(e23, v2, w2), c3 = w2.value, v2 = w2.rest, i3.push(c3);
              if (i3.length === 2)
                throw new Error("Found a source, but no line and column");
              if (i3.length === 3)
                throw new Error("Found a source and line, but no column");
              y2[o3] = i3;
            }
            r4.generatedColumn = p2 + i3[0], p2 = r4.generatedColumn, i3.length > 1 && (r4.source = D2 + i3[1], D2 += i3[1], r4.originalLine = h2 + i3[2], h2 = r4.originalLine, r4.originalLine += 1, r4.originalColumn = d2 + i3[3], d2 = r4.originalColumn, i3.length > 4 && (r4.name = g2 + i3[4], g2 += i3[4])), C2.push(r4), typeof r4.originalLine == "number" && b2.push(r4);
          }
        u2(C2, n2.compareByGeneratedPositionsDeflated), this.__generatedMappings = C2, u2(b2, n2.compareByOriginalPositions), this.__originalMappings = b2;
      }, c2.prototype._findMapping = function(e23, t5, r4, n3, i3, s3) {
        if (e23[r4] <= 0)
          throw new TypeError("Line must be greater than or equal to 1, got " + e23[r4]);
        if (e23[n3] < 0)
          throw new TypeError("Column must be greater than or equal to 0, got " + e23[n3]);
        return o2.search(e23, t5, i3, s3);
      }, c2.prototype.computeColumnSpans = function() {
        for (var e23 = 0; e23 < this._generatedMappings.length; ++e23) {
          var t5 = this._generatedMappings[e23];
          if (e23 + 1 < this._generatedMappings.length) {
            var r4 = this._generatedMappings[e23 + 1];
            if (t5.generatedLine === r4.generatedLine) {
              t5.lastGeneratedColumn = r4.generatedColumn - 1;
              continue;
            }
          }
          t5.lastGeneratedColumn = 1 / 0;
        }
      }, c2.prototype.originalPositionFor = function(e23) {
        var t5 = {generatedLine: n2.getArg(e23, "line"), generatedColumn: n2.getArg(e23, "column")}, r4 = this._findMapping(t5, this._generatedMappings, "generatedLine", "generatedColumn", n2.compareByGeneratedPositionsDeflated, n2.getArg(e23, "bias", a2.GREATEST_LOWER_BOUND));
        if (r4 >= 0) {
          var o3 = this._generatedMappings[r4];
          if (o3.generatedLine === t5.generatedLine) {
            var i3 = n2.getArg(o3, "source", null);
            i3 !== null && (i3 = this._sources.at(i3), i3 = n2.computeSourceURL(this.sourceRoot, i3, this._sourceMapURL));
            var s3 = n2.getArg(o3, "name", null);
            return s3 !== null && (s3 = this._names.at(s3)), {source: i3, line: n2.getArg(o3, "originalLine", null), column: n2.getArg(o3, "originalColumn", null), name: s3};
          }
        }
        return {source: null, line: null, column: null, name: null};
      }, c2.prototype.hasContentsOfAllSources = function() {
        return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e23) {
          return e23 == null;
        });
      }, c2.prototype.sourceContentFor = function(e23, t5) {
        if (!this.sourcesContent)
          return null;
        var r4 = this._findSourceIndex(e23);
        if (r4 >= 0)
          return this.sourcesContent[r4];
        var o3, i3 = e23;
        if (this.sourceRoot != null && (i3 = n2.relative(this.sourceRoot, i3)), this.sourceRoot != null && (o3 = n2.urlParse(this.sourceRoot))) {
          var s3 = i3.replace(/^file:\/\//, "");
          if (o3.scheme == "file" && this._sources.has(s3))
            return this.sourcesContent[this._sources.indexOf(s3)];
          if ((!o3.path || o3.path == "/") && this._sources.has("/" + i3))
            return this.sourcesContent[this._sources.indexOf("/" + i3)];
        }
        if (t5)
          return null;
        throw new Error('"' + i3 + '" is not in the SourceMap.');
      }, c2.prototype.generatedPositionFor = function(e23) {
        var t5 = n2.getArg(e23, "source");
        if ((t5 = this._findSourceIndex(t5)) < 0)
          return {line: null, column: null, lastColumn: null};
        var r4 = {source: t5, originalLine: n2.getArg(e23, "line"), originalColumn: n2.getArg(e23, "column")}, o3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, n2.getArg(e23, "bias", a2.GREATEST_LOWER_BOUND));
        if (o3 >= 0) {
          var i3 = this._originalMappings[o3];
          if (i3.source === r4.source)
            return {line: n2.getArg(i3, "generatedLine", null), column: n2.getArg(i3, "generatedColumn", null), lastColumn: n2.getArg(i3, "lastGeneratedColumn", null)};
        }
        return {line: null, column: null, lastColumn: null};
      }, f2.prototype = Object.create(a2.prototype), f2.prototype.constructor = a2, f2.prototype._version = 3, Object.defineProperty(f2.prototype, "sources", {get: function() {
        for (var e23 = [], t5 = 0; t5 < this._sections.length; t5++)
          for (var r4 = 0; r4 < this._sections[t5].consumer.sources.length; r4++)
            e23.push(this._sections[t5].consumer.sources[r4]);
        return e23;
      }}), f2.prototype.originalPositionFor = function(e23) {
        var t5 = {generatedLine: n2.getArg(e23, "line"), generatedColumn: n2.getArg(e23, "column")}, r4 = o2.search(t5, this._sections, function(e24, t6) {
          return e24.generatedLine - t6.generatedOffset.generatedLine || e24.generatedColumn - t6.generatedOffset.generatedColumn;
        }), i3 = this._sections[r4];
        return i3 ? i3.consumer.originalPositionFor({line: t5.generatedLine - (i3.generatedOffset.generatedLine - 1), column: t5.generatedColumn - (i3.generatedOffset.generatedLine === t5.generatedLine ? i3.generatedOffset.generatedColumn - 1 : 0), bias: e23.bias}) : {source: null, line: null, column: null, name: null};
      }, f2.prototype.hasContentsOfAllSources = function() {
        return this._sections.every(function(e23) {
          return e23.consumer.hasContentsOfAllSources();
        });
      }, f2.prototype.sourceContentFor = function(e23, t5) {
        for (var r4 = 0; r4 < this._sections.length; r4++) {
          var n3 = this._sections[r4].consumer.sourceContentFor(e23, true);
          if (n3)
            return n3;
        }
        if (t5)
          return null;
        throw new Error('"' + e23 + '" is not in the SourceMap.');
      }, f2.prototype.generatedPositionFor = function(e23) {
        for (var t5 = 0; t5 < this._sections.length; t5++) {
          var r4 = this._sections[t5];
          if (r4.consumer._findSourceIndex(n2.getArg(e23, "source")) !== -1) {
            var o3 = r4.consumer.generatedPositionFor(e23);
            if (o3)
              return {line: o3.line + (r4.generatedOffset.generatedLine - 1), column: o3.column + (r4.generatedOffset.generatedLine === o3.line ? r4.generatedOffset.generatedColumn - 1 : 0)};
          }
        }
        return {line: null, column: null};
      }, f2.prototype._parseMappings = function(e23, t5) {
        this.__generatedMappings = [], this.__originalMappings = [];
        for (var r4 = 0; r4 < this._sections.length; r4++)
          for (var o3 = this._sections[r4], i3 = o3.consumer._generatedMappings, s3 = 0; s3 < i3.length; s3++) {
            var a3 = i3[s3], c3 = o3.consumer._sources.at(a3.source);
            c3 = n2.computeSourceURL(o3.consumer.sourceRoot, c3, this._sourceMapURL), this._sources.add(c3), c3 = this._sources.indexOf(c3);
            var l3 = null;
            a3.name && (l3 = o3.consumer._names.at(a3.name), this._names.add(l3), l3 = this._names.indexOf(l3));
            var f3 = {source: c3, generatedLine: a3.generatedLine + (o3.generatedOffset.generatedLine - 1), generatedColumn: a3.generatedColumn + (o3.generatedOffset.generatedLine === a3.generatedLine ? o3.generatedOffset.generatedColumn - 1 : 0), originalLine: a3.originalLine, originalColumn: a3.originalColumn, name: l3};
            this.__generatedMappings.push(f3), typeof f3.originalLine == "number" && this.__originalMappings.push(f3);
          }
        u2(this.__generatedMappings, n2.compareByGeneratedPositionsDeflated), u2(this.__originalMappings, n2.compareByOriginalPositions);
      };
    }, 2400: (e22, t4, r3) => {
      var n2 = r3(4886), o2 = r3(7837), i2 = r3(6715).I, s2 = r3(1028).H;
      function u2(e23) {
        e23 || (e23 = {}), this._file = o2.getArg(e23, "file", null), this._sourceRoot = o2.getArg(e23, "sourceRoot", null), this._skipValidation = o2.getArg(e23, "skipValidation", false), this._sources = new i2(), this._names = new i2(), this._mappings = new s2(), this._sourcesContents = null;
      }
      u2.prototype._version = 3, u2.fromSourceMap = function(e23) {
        var t5 = e23.sourceRoot, r4 = new u2({file: e23.file, sourceRoot: t5});
        return e23.eachMapping(function(e24) {
          var n3 = {generated: {line: e24.generatedLine, column: e24.generatedColumn}};
          e24.source != null && (n3.source = e24.source, t5 != null && (n3.source = o2.relative(t5, n3.source)), n3.original = {line: e24.originalLine, column: e24.originalColumn}, e24.name != null && (n3.name = e24.name)), r4.addMapping(n3);
        }), e23.sources.forEach(function(n3) {
          var i3 = n3;
          t5 !== null && (i3 = o2.relative(t5, n3)), r4._sources.has(i3) || r4._sources.add(i3);
          var s3 = e23.sourceContentFor(n3);
          s3 != null && r4.setSourceContent(n3, s3);
        }), r4;
      }, u2.prototype.addMapping = function(e23) {
        var t5 = o2.getArg(e23, "generated"), r4 = o2.getArg(e23, "original", null), n3 = o2.getArg(e23, "source", null), i3 = o2.getArg(e23, "name", null);
        this._skipValidation || this._validateMapping(t5, r4, n3, i3), n3 != null && (n3 = String(n3), this._sources.has(n3) || this._sources.add(n3)), i3 != null && (i3 = String(i3), this._names.has(i3) || this._names.add(i3)), this._mappings.add({generatedLine: t5.line, generatedColumn: t5.column, originalLine: r4 != null && r4.line, originalColumn: r4 != null && r4.column, source: n3, name: i3});
      }, u2.prototype.setSourceContent = function(e23, t5) {
        var r4 = e23;
        this._sourceRoot != null && (r4 = o2.relative(this._sourceRoot, r4)), t5 != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o2.toSetString(r4)] = t5) : this._sourcesContents && (delete this._sourcesContents[o2.toSetString(r4)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
      }, u2.prototype.applySourceMap = function(e23, t5, r4) {
        var n3 = t5;
        if (t5 == null) {
          if (e23.file == null)
            throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
          n3 = e23.file;
        }
        var s3 = this._sourceRoot;
        s3 != null && (n3 = o2.relative(s3, n3));
        var u3 = new i2(), a2 = new i2();
        this._mappings.unsortedForEach(function(t6) {
          if (t6.source === n3 && t6.originalLine != null) {
            var i3 = e23.originalPositionFor({line: t6.originalLine, column: t6.originalColumn});
            i3.source != null && (t6.source = i3.source, r4 != null && (t6.source = o2.join(r4, t6.source)), s3 != null && (t6.source = o2.relative(s3, t6.source)), t6.originalLine = i3.line, t6.originalColumn = i3.column, i3.name != null && (t6.name = i3.name));
          }
          var c2 = t6.source;
          c2 == null || u3.has(c2) || u3.add(c2);
          var l2 = t6.name;
          l2 == null || a2.has(l2) || a2.add(l2);
        }, this), this._sources = u3, this._names = a2, e23.sources.forEach(function(t6) {
          var n4 = e23.sourceContentFor(t6);
          n4 != null && (r4 != null && (t6 = o2.join(r4, t6)), s3 != null && (t6 = o2.relative(s3, t6)), this.setSourceContent(t6, n4));
        }, this);
      }, u2.prototype._validateMapping = function(e23, t5, r4, n3) {
        if (t5 && typeof t5.line != "number" && typeof t5.column != "number")
          throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
        if ((!(e23 && "line" in e23 && "column" in e23 && e23.line > 0 && e23.column >= 0) || t5 || r4 || n3) && !(e23 && "line" in e23 && "column" in e23 && t5 && "line" in t5 && "column" in t5 && e23.line > 0 && e23.column >= 0 && t5.line > 0 && t5.column >= 0 && r4))
          throw new Error("Invalid mapping: " + JSON.stringify({generated: e23, source: r4, original: t5, name: n3}));
      }, u2.prototype._serializeMappings = function() {
        for (var e23, t5, r4, i3, s3 = 0, u3 = 1, a2 = 0, c2 = 0, l2 = 0, f2 = 0, p2 = "", h2 = this._mappings.toArray(), d2 = 0, D2 = h2.length; d2 < D2; d2++) {
          if (e23 = "", (t5 = h2[d2]).generatedLine !== u3)
            for (s3 = 0; t5.generatedLine !== u3; )
              e23 += ";", u3++;
          else if (d2 > 0) {
            if (!o2.compareByGeneratedPositionsInflated(t5, h2[d2 - 1]))
              continue;
            e23 += ",";
          }
          e23 += n2.encode(t5.generatedColumn - s3), s3 = t5.generatedColumn, t5.source != null && (i3 = this._sources.indexOf(t5.source), e23 += n2.encode(i3 - f2), f2 = i3, e23 += n2.encode(t5.originalLine - 1 - c2), c2 = t5.originalLine - 1, e23 += n2.encode(t5.originalColumn - a2), a2 = t5.originalColumn, t5.name != null && (r4 = this._names.indexOf(t5.name), e23 += n2.encode(r4 - l2), l2 = r4)), p2 += e23;
        }
        return p2;
      }, u2.prototype._generateSourcesContent = function(e23, t5) {
        return e23.map(function(e24) {
          if (!this._sourcesContents)
            return null;
          t5 != null && (e24 = o2.relative(t5, e24));
          var r4 = o2.toSetString(e24);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, r4) ? this._sourcesContents[r4] : null;
        }, this);
      }, u2.prototype.toJSON = function() {
        var e23 = {version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings()};
        return this._file != null && (e23.file = this._file), this._sourceRoot != null && (e23.sourceRoot = this._sourceRoot), this._sourcesContents && (e23.sourcesContent = this._generateSourcesContent(e23.sources, e23.sourceRoot)), e23;
      }, u2.prototype.toString = function() {
        return JSON.stringify(this.toJSON());
      }, t4.SourceMapGenerator = u2;
    }, 6270: (e22, t4, r3) => {
      var n2 = r3(2400).SourceMapGenerator, o2 = r3(7837), i2 = /(\r?\n)/, s2 = "$$$isSourceNode$$$";
      function u2(e23, t5, r4, n3, o3) {
        this.children = [], this.sourceContents = {}, this.line = e23 == null ? null : e23, this.column = t5 == null ? null : t5, this.source = r4 == null ? null : r4, this.name = o3 == null ? null : o3, this[s2] = true, n3 != null && this.add(n3);
      }
      u2.fromStringWithSourceMap = function(e23, t5, r4) {
        var n3 = new u2(), s3 = e23.split(i2), a2 = 0, c2 = function() {
          return e24() + (e24() || "");
          function e24() {
            return a2 < s3.length ? s3[a2++] : void 0;
          }
        }, l2 = 1, f2 = 0, p2 = null;
        return t5.eachMapping(function(e24) {
          if (p2 !== null) {
            if (!(l2 < e24.generatedLine)) {
              var t6 = (r5 = s3[a2] || "").substr(0, e24.generatedColumn - f2);
              return s3[a2] = r5.substr(e24.generatedColumn - f2), f2 = e24.generatedColumn, h2(p2, t6), void (p2 = e24);
            }
            h2(p2, c2()), l2++, f2 = 0;
          }
          for (; l2 < e24.generatedLine; )
            n3.add(c2()), l2++;
          if (f2 < e24.generatedColumn) {
            var r5 = s3[a2] || "";
            n3.add(r5.substr(0, e24.generatedColumn)), s3[a2] = r5.substr(e24.generatedColumn), f2 = e24.generatedColumn;
          }
          p2 = e24;
        }, this), a2 < s3.length && (p2 && h2(p2, c2()), n3.add(s3.splice(a2).join(""))), t5.sources.forEach(function(e24) {
          var i3 = t5.sourceContentFor(e24);
          i3 != null && (r4 != null && (e24 = o2.join(r4, e24)), n3.setSourceContent(e24, i3));
        }), n3;
        function h2(e24, t6) {
          if (e24 === null || e24.source === void 0)
            n3.add(t6);
          else {
            var i3 = r4 ? o2.join(r4, e24.source) : e24.source;
            n3.add(new u2(e24.originalLine, e24.originalColumn, i3, t6, e24.name));
          }
        }
      }, u2.prototype.add = function(e23) {
        if (Array.isArray(e23))
          e23.forEach(function(e24) {
            this.add(e24);
          }, this);
        else {
          if (!e23[s2] && typeof e23 != "string")
            throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e23);
          e23 && this.children.push(e23);
        }
        return this;
      }, u2.prototype.prepend = function(e23) {
        if (Array.isArray(e23))
          for (var t5 = e23.length - 1; t5 >= 0; t5--)
            this.prepend(e23[t5]);
        else {
          if (!e23[s2] && typeof e23 != "string")
            throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e23);
          this.children.unshift(e23);
        }
        return this;
      }, u2.prototype.walk = function(e23) {
        for (var t5, r4 = 0, n3 = this.children.length; r4 < n3; r4++)
          (t5 = this.children[r4])[s2] ? t5.walk(e23) : t5 !== "" && e23(t5, {source: this.source, line: this.line, column: this.column, name: this.name});
      }, u2.prototype.join = function(e23) {
        var t5, r4, n3 = this.children.length;
        if (n3 > 0) {
          for (t5 = [], r4 = 0; r4 < n3 - 1; r4++)
            t5.push(this.children[r4]), t5.push(e23);
          t5.push(this.children[r4]), this.children = t5;
        }
        return this;
      }, u2.prototype.replaceRight = function(e23, t5) {
        var r4 = this.children[this.children.length - 1];
        return r4[s2] ? r4.replaceRight(e23, t5) : typeof r4 == "string" ? this.children[this.children.length - 1] = r4.replace(e23, t5) : this.children.push("".replace(e23, t5)), this;
      }, u2.prototype.setSourceContent = function(e23, t5) {
        this.sourceContents[o2.toSetString(e23)] = t5;
      }, u2.prototype.walkSourceContents = function(e23) {
        for (var t5 = 0, r4 = this.children.length; t5 < r4; t5++)
          this.children[t5][s2] && this.children[t5].walkSourceContents(e23);
        var n3 = Object.keys(this.sourceContents);
        for (t5 = 0, r4 = n3.length; t5 < r4; t5++)
          e23(o2.fromSetString(n3[t5]), this.sourceContents[n3[t5]]);
      }, u2.prototype.toString = function() {
        var e23 = "";
        return this.walk(function(t5) {
          e23 += t5;
        }), e23;
      }, u2.prototype.toStringWithSourceMap = function(e23) {
        var t5 = {code: "", line: 1, column: 0}, r4 = new n2(e23), o3 = false, i3 = null, s3 = null, u3 = null, a2 = null;
        return this.walk(function(e24, n3) {
          t5.code += e24, n3.source !== null && n3.line !== null && n3.column !== null ? (i3 === n3.source && s3 === n3.line && u3 === n3.column && a2 === n3.name || r4.addMapping({source: n3.source, original: {line: n3.line, column: n3.column}, generated: {line: t5.line, column: t5.column}, name: n3.name}), i3 = n3.source, s3 = n3.line, u3 = n3.column, a2 = n3.name, o3 = true) : o3 && (r4.addMapping({generated: {line: t5.line, column: t5.column}}), i3 = null, o3 = false);
          for (var c2 = 0, l2 = e24.length; c2 < l2; c2++)
            e24.charCodeAt(c2) === 10 ? (t5.line++, t5.column = 0, c2 + 1 === l2 ? (i3 = null, o3 = false) : o3 && r4.addMapping({source: n3.source, original: {line: n3.line, column: n3.column}, generated: {line: t5.line, column: t5.column}, name: n3.name})) : t5.column++;
        }), this.walkSourceContents(function(e24, t6) {
          r4.setSourceContent(e24, t6);
        }), {code: t5.code, map: r4};
      }, t4.SourceNode = u2;
    }, 7837: (e22, t4) => {
      t4.getArg = function(e23, t5, r4) {
        if (t5 in e23)
          return e23[t5];
        if (arguments.length === 3)
          return r4;
        throw new Error('"' + t5 + '" is a required argument.');
      };
      var r3 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, n2 = /^data:.+\,.+$/;
      function o2(e23) {
        var t5 = e23.match(r3);
        return t5 ? {scheme: t5[1], auth: t5[2], host: t5[3], port: t5[4], path: t5[5]} : null;
      }
      function i2(e23) {
        var t5 = "";
        return e23.scheme && (t5 += e23.scheme + ":"), t5 += "//", e23.auth && (t5 += e23.auth + "@"), e23.host && (t5 += e23.host), e23.port && (t5 += ":" + e23.port), e23.path && (t5 += e23.path), t5;
      }
      function s2(e23) {
        var r4 = e23, n3 = o2(e23);
        if (n3) {
          if (!n3.path)
            return e23;
          r4 = n3.path;
        }
        for (var s3, u3 = t4.isAbsolute(r4), a3 = r4.split(/\/+/), c3 = 0, l3 = a3.length - 1; l3 >= 0; l3--)
          (s3 = a3[l3]) === "." ? a3.splice(l3, 1) : s3 === ".." ? c3++ : c3 > 0 && (s3 === "" ? (a3.splice(l3 + 1, c3), c3 = 0) : (a3.splice(l3, 2), c3--));
        return (r4 = a3.join("/")) === "" && (r4 = u3 ? "/" : "."), n3 ? (n3.path = r4, i2(n3)) : r4;
      }
      function u2(e23, t5) {
        e23 === "" && (e23 = "."), t5 === "" && (t5 = ".");
        var r4 = o2(t5), u3 = o2(e23);
        if (u3 && (e23 = u3.path || "/"), r4 && !r4.scheme)
          return u3 && (r4.scheme = u3.scheme), i2(r4);
        if (r4 || t5.match(n2))
          return t5;
        if (u3 && !u3.host && !u3.path)
          return u3.host = t5, i2(u3);
        var a3 = t5.charAt(0) === "/" ? t5 : s2(e23.replace(/\/+$/, "") + "/" + t5);
        return u3 ? (u3.path = a3, i2(u3)) : a3;
      }
      t4.urlParse = o2, t4.urlGenerate = i2, t4.normalize = s2, t4.join = u2, t4.isAbsolute = function(e23) {
        return e23.charAt(0) === "/" || r3.test(e23);
      }, t4.relative = function(e23, t5) {
        e23 === "" && (e23 = "."), e23 = e23.replace(/\/$/, "");
        for (var r4 = 0; t5.indexOf(e23 + "/") !== 0; ) {
          var n3 = e23.lastIndexOf("/");
          if (n3 < 0)
            return t5;
          if ((e23 = e23.slice(0, n3)).match(/^([^\/]+:\/)?\/*$/))
            return t5;
          ++r4;
        }
        return Array(r4 + 1).join("../") + t5.substr(e23.length + 1);
      };
      var a2 = !("__proto__" in Object.create(null));
      function c2(e23) {
        return e23;
      }
      function l2(e23) {
        if (!e23)
          return false;
        var t5 = e23.length;
        if (t5 < 9)
          return false;
        if (e23.charCodeAt(t5 - 1) !== 95 || e23.charCodeAt(t5 - 2) !== 95 || e23.charCodeAt(t5 - 3) !== 111 || e23.charCodeAt(t5 - 4) !== 116 || e23.charCodeAt(t5 - 5) !== 111 || e23.charCodeAt(t5 - 6) !== 114 || e23.charCodeAt(t5 - 7) !== 112 || e23.charCodeAt(t5 - 8) !== 95 || e23.charCodeAt(t5 - 9) !== 95)
          return false;
        for (var r4 = t5 - 10; r4 >= 0; r4--)
          if (e23.charCodeAt(r4) !== 36)
            return false;
        return true;
      }
      function f2(e23, t5) {
        return e23 === t5 ? 0 : e23 === null ? 1 : t5 === null ? -1 : e23 > t5 ? 1 : -1;
      }
      t4.toSetString = a2 ? c2 : function(e23) {
        return l2(e23) ? "$" + e23 : e23;
      }, t4.fromSetString = a2 ? c2 : function(e23) {
        return l2(e23) ? e23.slice(1) : e23;
      }, t4.compareByOriginalPositions = function(e23, t5, r4) {
        var n3 = f2(e23.source, t5.source);
        return n3 !== 0 || (n3 = e23.originalLine - t5.originalLine) != 0 || (n3 = e23.originalColumn - t5.originalColumn) != 0 || r4 || (n3 = e23.generatedColumn - t5.generatedColumn) != 0 || (n3 = e23.generatedLine - t5.generatedLine) != 0 ? n3 : f2(e23.name, t5.name);
      }, t4.compareByGeneratedPositionsDeflated = function(e23, t5, r4) {
        var n3 = e23.generatedLine - t5.generatedLine;
        return n3 !== 0 || (n3 = e23.generatedColumn - t5.generatedColumn) != 0 || r4 || (n3 = f2(e23.source, t5.source)) !== 0 || (n3 = e23.originalLine - t5.originalLine) != 0 || (n3 = e23.originalColumn - t5.originalColumn) != 0 ? n3 : f2(e23.name, t5.name);
      }, t4.compareByGeneratedPositionsInflated = function(e23, t5) {
        var r4 = e23.generatedLine - t5.generatedLine;
        return r4 !== 0 || (r4 = e23.generatedColumn - t5.generatedColumn) != 0 || (r4 = f2(e23.source, t5.source)) !== 0 || (r4 = e23.originalLine - t5.originalLine) != 0 || (r4 = e23.originalColumn - t5.originalColumn) != 0 ? r4 : f2(e23.name, t5.name);
      }, t4.parseSourceMapInput = function(e23) {
        return JSON.parse(e23.replace(/^\)]}'[^\n]*\n/, ""));
      }, t4.computeSourceURL = function(e23, t5, r4) {
        if (t5 = t5 || "", e23 && (e23[e23.length - 1] !== "/" && t5[0] !== "/" && (e23 += "/"), t5 = e23 + t5), r4) {
          var n3 = o2(r4);
          if (!n3)
            throw new Error("sourceMapURL could not be parsed");
          if (n3.path) {
            var a3 = n3.path.lastIndexOf("/");
            a3 >= 0 && (n3.path = n3.path.substring(0, a3 + 1));
          }
          t5 = u2(i2(n3), t5);
        }
        return s2(t5);
      };
    }, 2447: (e22, t4, r3) => {
      t4.SourceMapGenerator = r3(2400).SourceMapGenerator, t4.SourceMapConsumer = r3(8985).SourceMapConsumer, t4.SourceNode = r3(6270).SourceNode;
    }, 6549: (e22, t4, r3) => {
      const n2 = r3(9992), o2 = r3(8528), i2 = r3(541), s2 = (e23) => {
        if (typeof e23 != "string" || e23.length === 0)
          return 0;
        if ((e23 = n2(e23)).length === 0)
          return 0;
        e23 = e23.replace(i2(), "  ");
        let t5 = 0;
        for (let r4 = 0; r4 < e23.length; r4++) {
          const n3 = e23.codePointAt(r4);
          n3 <= 31 || n3 >= 127 && n3 <= 159 || n3 >= 768 && n3 <= 879 || (n3 > 65535 && r4++, t5 += o2(n3) ? 2 : 1);
        }
        return t5;
      };
      e22.exports = s2, e22.exports.default = s2;
    }, 9992: (e22, t4, r3) => {
      const n2 = r3(2426);
      e22.exports = (e23) => typeof e23 == "string" ? e23.replace(n2(), "") : e23;
    }, 3210: (e22, t4, r3) => {
      r3(4070), e22.exports = function(e23, t5, r4) {
        return e23.length === 0 ? e23 : t5 ? (r4 || e23.sort(t5), function(e24, t6) {
          for (var r5 = 1, n2 = e24.length, o2 = e24[0], i2 = e24[0], s2 = 1; s2 < n2; ++s2)
            if (i2 = o2, t6(o2 = e24[s2], i2)) {
              if (s2 === r5) {
                r5++;
                continue;
              }
              e24[r5++] = o2;
            }
          return e24.length = r5, e24;
        }(e23, t5)) : (r4 || e23.sort(), function(e24) {
          for (var t6 = 1, r5 = e24.length, n2 = e24[0], o2 = e24[0], i2 = 1; i2 < r5; ++i2, o2 = n2)
            if (o2 = n2, (n2 = e24[i2]) !== o2) {
              if (i2 === t6) {
                t6++;
                continue;
              }
              e24[t6++] = n2;
            }
          return e24.length = t6, e24;
        }(e23));
      };
    }, 7933: (e22) => {
      e22.exports = {guessEndOfLine: function(e23) {
        const t4 = e23.indexOf("\r");
        return t4 >= 0 ? e23.charAt(t4 + 1) === "\n" ? "crlf" : "cr" : "lf";
      }, convertEndOfLineToChars: function(e23) {
        switch (e23) {
          case "cr":
            return "\r";
          case "crlf":
            return "\r\n";
          default:
            return "\n";
        }
      }, countEndOfLineChars: function(e23, t4) {
        let r3;
        if (t4 === "\n")
          r3 = /\n/g;
        else if (t4 === "\r")
          r3 = /\r/g;
        else {
          if (t4 !== "\r\n")
            throw new Error(`Unexpected "eol" ${JSON.stringify(t4)}.`);
          r3 = /\r\n/g;
        }
        const n2 = e23.match(r3);
        return n2 ? n2.length : 0;
      }, normalizeEndOfLine: function(e23) {
        return e23.replace(/\r\n?/g, "\n");
      }};
    }, 47: (e22) => {
      e22.exports = function(e23, t4) {
        const r3 = new SyntaxError(e23 + " (" + t4.start.line + ":" + t4.start.column + ")");
        return r3.loc = t4, r3;
      };
    }, 9428: (e22, t4, r3) => {
      const n2 = r3(6549), o2 = r3(2240), i2 = r3(4652), {getSupportInfo: s2} = r3(7290), u2 = /[^\x20-\x7F]/;
      function a2(e23) {
        return (t5, r4, n3) => {
          const o3 = n3 && n3.backwards;
          if (r4 === false)
            return false;
          const {length: i3} = t5;
          let s3 = r4;
          for (; s3 >= 0 && s3 < i3; ) {
            const r5 = t5.charAt(s3);
            if (e23 instanceof RegExp) {
              if (!e23.test(r5))
                return s3;
            } else if (!e23.includes(r5))
              return s3;
            o3 ? s3-- : s3++;
          }
          return (s3 === -1 || s3 === i3) && s3;
        };
      }
      const c2 = a2(/\s/), l2 = a2(" 	"), f2 = a2(",; 	"), p2 = a2(/[^\n\r]/);
      function h2(e23, t5) {
        if (t5 === false)
          return false;
        if (e23.charAt(t5) === "/" && e23.charAt(t5 + 1) === "*") {
          for (let r4 = t5 + 2; r4 < e23.length; ++r4)
            if (e23.charAt(r4) === "*" && e23.charAt(r4 + 1) === "/")
              return r4 + 2;
        }
        return t5;
      }
      function d2(e23, t5) {
        return t5 !== false && (e23.charAt(t5) === "/" && e23.charAt(t5 + 1) === "/" ? p2(e23, t5) : t5);
      }
      function D2(e23, t5, r4) {
        const n3 = r4 && r4.backwards;
        if (t5 === false)
          return false;
        const o3 = e23.charAt(t5);
        if (n3) {
          if (e23.charAt(t5 - 1) === "\r" && o3 === "\n")
            return t5 - 2;
          if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
            return t5 - 1;
        } else {
          if (o3 === "\r" && e23.charAt(t5 + 1) === "\n")
            return t5 + 2;
          if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
            return t5 + 1;
        }
        return t5;
      }
      function g2(e23, t5, r4 = {}) {
        const n3 = l2(e23, r4.backwards ? t5 - 1 : t5, r4);
        return n3 !== D2(e23, n3, r4);
      }
      function m2(e23, t5) {
        let r4 = null, n3 = t5;
        for (; n3 !== r4; )
          r4 = n3, n3 = f2(e23, n3), n3 = h2(e23, n3), n3 = l2(e23, n3);
        return n3 = d2(e23, n3), n3 = D2(e23, n3), n3 !== false && g2(e23, n3);
      }
      function v2(e23, t5) {
        let r4 = null, n3 = t5;
        for (; n3 !== r4; )
          r4 = n3, n3 = l2(e23, n3), n3 = h2(e23, n3), n3 = d2(e23, n3), n3 = D2(e23, n3);
        return n3;
      }
      function y2(e23, t5, r4) {
        return v2(e23, r4(t5));
      }
      function w2(e23, t5, r4 = 0) {
        let n3 = 0;
        for (let o3 = r4; o3 < e23.length; ++o3)
          e23[o3] === "	" ? n3 = n3 + t5 - n3 % t5 : n3++;
        return n3;
      }
      function b2(e23, t5) {
        const r4 = e23.slice(1, -1), n3 = {quote: '"', regex: /"/g}, o3 = {quote: "'", regex: /'/g}, i3 = t5 === "'" ? o3 : n3, s3 = i3 === o3 ? n3 : o3;
        let u3 = i3.quote;
        return (r4.includes(i3.quote) || r4.includes(s3.quote)) && (u3 = (r4.match(i3.regex) || []).length > (r4.match(s3.regex) || []).length ? s3.quote : i3.quote), u3;
      }
      function C2(e23, t5, r4) {
        const n3 = t5 === '"' ? "'" : '"', o3 = e23.replace(/\\(.)|(["'])/gs, (e24, o4, i3) => o4 === n3 ? o4 : i3 === t5 ? "\\" + i3 : i3 || (r4 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o4) ? o4 : "\\" + o4));
        return t5 + o3 + t5;
      }
      function E2(e23, t5) {
        (e23.comments || (e23.comments = [])).push(t5), t5.printed = false, t5.nodeDescription = function(e24) {
          const t6 = e24.type || e24.kind || "(unknown type)";
          let r4 = String(e24.name || e24.id && (typeof e24.id == "object" ? e24.id.name : e24.id) || e24.key && (typeof e24.key == "object" ? e24.key.name : e24.key) || e24.value && (typeof e24.value == "object" ? "" : String(e24.value)) || e24.operator || "");
          return r4.length > 20 && (r4 = r4.slice(0, 19) + "\u2026"), t6 + (r4 ? " " + r4 : "");
        }(e23);
      }
      e22.exports = {inferParserByLanguage: function(e23, t5) {
        const {languages: r4} = s2({plugins: t5.plugins}), n3 = r4.find(({name: t6}) => t6.toLowerCase() === e23) || r4.find(({aliases: t6}) => Array.isArray(t6) && t6.includes(e23)) || r4.find(({extensions: t6}) => Array.isArray(t6) && t6.includes(`.${e23}`));
        return n3 && n3.parsers[0];
      }, getStringWidth: function(e23) {
        return e23 ? u2.test(e23) ? n2(e23) : e23.length : 0;
      }, getMaxContinuousCount: function(e23, t5) {
        const r4 = e23.match(new RegExp(`(${o2(t5)})+`, "g"));
        return r4 === null ? 0 : r4.reduce((e24, r5) => Math.max(e24, r5.length / t5.length), 0);
      }, getMinNotPresentContinuousCount: function(e23, t5) {
        const r4 = e23.match(new RegExp(`(${o2(t5)})+`, "g"));
        if (r4 === null)
          return 0;
        const n3 = new Map();
        let i3 = 0;
        for (const e24 of r4) {
          const r5 = e24.length / t5.length;
          n3.set(r5, true), r5 > i3 && (i3 = r5);
        }
        for (let e24 = 1; e24 < i3; e24++)
          if (!n3.get(e24))
            return e24;
        return i3 + 1;
      }, getPenultimate: (e23) => e23[e23.length - 2], getLast: i2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: v2, getNextNonSpaceNonCommentCharacterIndex: y2, getNextNonSpaceNonCommentCharacter: function(e23, t5, r4) {
        return e23.charAt(y2(e23, t5, r4));
      }, skip: a2, skipWhitespace: c2, skipSpaces: l2, skipToLineEnd: f2, skipEverythingButNewLine: p2, skipInlineComment: h2, skipTrailingComment: d2, skipNewline: D2, isNextLineEmptyAfterIndex: m2, isNextLineEmpty: function(e23, t5, r4) {
        return m2(e23, r4(t5));
      }, isPreviousLineEmpty: function(e23, t5, r4) {
        let n3 = r4(t5) - 1;
        return n3 = l2(e23, n3, {backwards: true}), n3 = D2(e23, n3, {backwards: true}), n3 = l2(e23, n3, {backwards: true}), n3 !== D2(e23, n3, {backwards: true});
      }, hasNewline: g2, hasNewlineInRange: function(e23, t5, r4) {
        for (let n3 = t5; n3 < r4; ++n3)
          if (e23.charAt(n3) === "\n")
            return true;
        return false;
      }, hasSpaces: function(e23, t5, r4 = {}) {
        return l2(e23, r4.backwards ? t5 - 1 : t5, r4) !== t5;
      }, getAlignmentSize: w2, getIndentSize: function(e23, t5) {
        const r4 = e23.lastIndexOf("\n");
        return r4 === -1 ? 0 : w2(e23.slice(r4 + 1).match(/^[\t ]*/)[0], t5);
      }, getPreferredQuote: b2, printString: function(e23, t5) {
        return C2(e23.slice(1, -1), t5.parser === "json" || t5.parser === "json5" && t5.quoteProps === "preserve" && !t5.singleQuote ? '"' : t5.__isInHtmlAttribute ? "'" : b2(e23, t5.singleQuote ? "'" : '"'), !(t5.parser === "css" || t5.parser === "less" || t5.parser === "scss" || t5.__embeddedInHtml));
      }, printNumber: function(e23) {
        return e23.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
      }, makeString: C2, addLeadingComment: function(e23, t5) {
        t5.leading = true, t5.trailing = false, E2(e23, t5);
      }, addDanglingComment: function(e23, t5, r4) {
        t5.leading = false, t5.trailing = false, r4 && (t5.marker = r4), E2(e23, t5);
      }, addTrailingComment: function(e23, t5) {
        t5.leading = false, t5.trailing = true, E2(e23, t5);
      }, isFrontMatterNode: function(e23) {
        return e23 && e23.type === "front-matter";
      }, getShebang: function(e23) {
        if (!e23.startsWith("#!"))
          return "";
        const t5 = e23.indexOf("\n");
        return t5 === -1 ? e23 : e23.slice(0, t5);
      }, isNonEmptyArray: function(e23) {
        return Array.isArray(e23) && e23.length > 0;
      }, createGroupIdMapper: function(e23) {
        const t5 = new WeakMap();
        return function(r4) {
          return t5.has(r4) || t5.set(r4, Symbol(e23)), t5.get(r4);
        };
      }};
    }, 9355: (e22, t4, r3) => {
      const n2 = r3(6920), {getLast: o2, skipEverythingButNewLine: i2} = r3(9428);
      function s2(e23, t5) {
        return typeof e23.sourceIndex == "number" ? e23.sourceIndex : e23.source ? n2(e23.source.start, t5) - 1 : null;
      }
      function u2(e23, t5) {
        if (e23.type === "css-comment" && e23.inline)
          return i2(t5, e23.source.startOffset);
        const r4 = e23.nodes && o2(e23.nodes);
        return r4 && e23.source && !e23.source.end && (e23 = r4), e23.source && e23.source.end ? n2(e23.source.end, t5) : null;
      }
      function a2(e23, t5, r4) {
        e23.source && (e23.source.startOffset = s2(e23, r4) + t5, e23.source.endOffset = u2(e23, r4) + t5);
        for (const n3 in e23) {
          const o3 = e23[n3];
          n3 !== "source" && o3 && typeof o3 == "object" && a2(o3, t5, r4);
        }
      }
      function c2(e23) {
        let t5 = e23.source.startOffset;
        return typeof e23.prop == "string" && (t5 += e23.prop.length), e23.type === "css-atrule" && typeof e23.name == "string" && (t5 += 1 + e23.name.length + e23.raws.afterName.match(/^\s*:?\s*/)[0].length), e23.type !== "css-atrule" && e23.raws && typeof e23.raws.between == "string" && (t5 += e23.raws.between.length), t5;
      }
      e22.exports = {locStart: function(e23) {
        return e23.source.startOffset;
      }, locEnd: function(e23) {
        return e23.source.endOffset;
      }, calculateLoc: function e23(t5, r4) {
        t5.source && (t5.source.startOffset = s2(t5, r4), t5.source.endOffset = u2(t5, r4));
        for (const n3 in t5) {
          const o3 = t5[n3];
          n3 !== "source" && o3 && typeof o3 == "object" && (o3.type === "value-root" || o3.type === "value-unknown" ? a2(o3, c2(t5), o3.text || o3.value) : e23(o3, r4));
        }
      }, replaceQuotesInInlineComments: function(e23) {
        let t5, r4 = "initial", n3 = "initial", o3 = false;
        const i3 = [];
        for (let s3 = 0; s3 < e23.length; s3++) {
          const u3 = e23[s3];
          switch (r4) {
            case "initial":
              if (u3 === "'") {
                r4 = "single-quotes";
                continue;
              }
              if (u3 === '"') {
                r4 = "double-quotes";
                continue;
              }
              if ((u3 === "u" || u3 === "U") && e23.slice(s3, s3 + 4).toLowerCase() === "url(") {
                r4 = "url", s3 += 3;
                continue;
              }
              if (u3 === "*" && e23[s3 - 1] === "/") {
                r4 = "comment-block";
                continue;
              }
              if (u3 === "/" && e23[s3 - 1] === "/") {
                r4 = "comment-inline", t5 = s3 - 1;
                continue;
              }
              continue;
            case "single-quotes":
              if (u3 === "'" && e23[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                return e23;
              continue;
            case "double-quotes":
              if (u3 === '"' && e23[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                return e23;
              continue;
            case "url":
              if (u3 === ")" && (r4 = "initial"), u3 === "\n" || u3 === "\r")
                return e23;
              if (u3 === "'") {
                r4 = "single-quotes", n3 = "url";
                continue;
              }
              if (u3 === '"') {
                r4 = "double-quotes", n3 = "url";
                continue;
              }
              continue;
            case "comment-block":
              u3 === "/" && e23[s3 - 1] === "*" && (r4 = "initial");
              continue;
            case "comment-inline":
              u3 !== '"' && u3 !== "'" && u3 !== "*" || (o3 = true), u3 !== "\n" && u3 !== "\r" || (o3 && i3.push([t5, s3]), r4 = "initial", o3 = false);
              continue;
          }
        }
        for (const [t6, r5] of i3)
          e23 = e23.slice(0, t6) + e23.slice(t6, r5).replace(/["'*]/g, " ") + e23.slice(r5);
        return e23;
      }};
    }, 738: (e22, t4, r3) => {
      const n2 = r3(47), o2 = r3(4652), i2 = r3(5115), {hasPragma: s2} = r3(8850), {hasSCSSInterpolation: u2, hasStringOrFunction: a2, isLessParser: c2, isSCSS: l2, isSCSSNestedPropertyNode: f2, isSCSSVariable: p2, stringifyNode: h2, isModuleRuleName: d2} = r3(5244), {locStart: D2, locEnd: g2} = r3(9355), {calculateLoc: m2, replaceQuotesInInlineComments: v2} = r3(9355), y2 = (e23) => {
        for (; e23.parent; )
          e23 = e23.parent;
        return e23;
      };
      function w2(e23, t5) {
        const {nodes: r4} = e23;
        let n3 = {open: null, close: null, groups: [], type: "paren_group"};
        const i3 = [n3], s3 = n3;
        let c3 = {groups: [], type: "comma_group"};
        const f3 = [c3];
        for (let s4 = 0; s4 < r4.length; ++s4) {
          const d3 = r4[s4];
          if (l2(t5.parser, d3.value) && d3.type === "number" && d3.unit === ".." && o2(d3.value) === "." && (d3.value = d3.value.slice(0, -1), d3.unit = "..."), d3.type === "func" && d3.value === "selector" && (d3.group.groups = [A2(y2(e23).text.slice(d3.group.open.sourceIndex + 1, d3.group.close.sourceIndex))]), d3.type === "func" && d3.value === "url") {
            const e24 = d3.group && d3.group.groups || [];
            let t6 = [];
            for (let r5 = 0; r5 < e24.length; r5++) {
              const n4 = e24[r5];
              n4.type === "comma_group" ? t6 = [...t6, ...n4.groups] : t6.push(n4);
            }
            if (u2(t6) || !a2(t6) && !p2(t6[0])) {
              const e25 = h2({groups: d3.group.groups});
              d3.group.groups = [e25.trim()];
            }
          }
          if (d3.type === "paren" && d3.value === "(")
            n3 = {open: d3, close: null, groups: [], type: "paren_group"}, i3.push(n3), c3 = {groups: [], type: "comma_group"}, f3.push(c3);
          else if (d3.type === "paren" && d3.value === ")") {
            if (c3.groups.length > 0 && n3.groups.push(c3), n3.close = d3, f3.length === 1)
              throw new Error("Unbalanced parenthesis");
            f3.pop(), c3 = o2(f3), c3.groups.push(n3), i3.pop(), n3 = o2(i3);
          } else
            d3.type === "comma" ? (n3.groups.push(c3), c3 = {groups: [], type: "comma_group"}, f3[f3.length - 1] = c3) : c3.groups.push(d3);
        }
        return c3.groups.length > 0 && n3.groups.push(c3), s3;
      }
      function b2(e23) {
        return e23.type !== "paren_group" || e23.open || e23.close || e23.groups.length !== 1 ? e23.type === "comma_group" && e23.groups.length === 1 ? b2(e23.groups[0]) : e23.type === "paren_group" || e23.type === "comma_group" ? Object.assign(Object.assign({}, e23), {}, {groups: e23.groups.map(b2)}) : e23 : b2(e23.groups[0]);
      }
      function C2(e23, t5, r4) {
        if (e23 && typeof e23 == "object") {
          delete e23.parent;
          for (const n3 in e23)
            C2(e23[n3], t5, r4), n3 === "type" && typeof e23[n3] == "string" && (e23[n3].startsWith(t5) || r4 && r4.test(e23[n3]) || (e23[n3] = t5 + e23[n3]));
        }
        return e23;
      }
      function E2(e23) {
        if (e23 && typeof e23 == "object") {
          delete e23.parent;
          for (const t5 in e23)
            E2(e23[t5]);
          Array.isArray(e23) || !e23.value || e23.type || (e23.type = "unknown");
        }
        return e23;
      }
      function F2(e23, t5) {
        if (e23 && typeof e23 == "object") {
          for (const r4 in e23)
            r4 !== "parent" && (F2(e23[r4], t5), r4 === "nodes" && (e23.group = b2(w2(e23, t5)), delete e23[r4]));
          delete e23.parent;
        }
        return e23;
      }
      function x2(e23, t5) {
        const n3 = r3(9962);
        let o3 = null;
        try {
          o3 = n3(e23, {loose: true}).parse();
        } catch {
          return {type: "value-unknown", value: e23};
        }
        return o3.text = e23, C2(F2(o3, t5), "value-", /^selector-/);
      }
      function A2(e23) {
        if (/\/\/|\/\*/.test(e23))
          return {type: "selector-unknown", value: e23.trim()};
        const t5 = r3(1264);
        let n3 = null;
        try {
          t5((e24) => {
            n3 = e24;
          }).process(e23);
        } catch {
          return {type: "selector-unknown", value: e23};
        }
        return C2(n3, "selector-");
      }
      function k2(e23) {
        const t5 = r3(8322).Z;
        let n3 = null;
        try {
          n3 = t5(e23);
        } catch {
          return {type: "selector-unknown", value: e23};
        }
        return C2(E2(n3), "media-");
      }
      const O2 = /(\s*?)(!default).*$/, _2 = /(\s*?)(!global).*$/;
      function S2(e23, t5) {
        if (e23 && typeof e23 == "object") {
          delete e23.parent;
          for (const r5 in e23)
            S2(e23[r5], t5);
          if (!e23.type)
            return e23;
          e23.raws || (e23.raws = {});
          let r4 = "";
          typeof e23.selector == "string" && (r4 = e23.raws.selector ? e23.raws.selector.scss ? e23.raws.selector.scss : e23.raws.selector.raw : e23.selector, e23.raws.between && e23.raws.between.trim().length > 0 && (r4 += e23.raws.between), e23.raws.selector = r4);
          let n3 = "";
          typeof e23.value == "string" && (n3 = e23.raws.value ? e23.raws.value.scss ? e23.raws.value.scss : e23.raws.value.raw : e23.value, n3 = n3.trim(), e23.raws.value = n3);
          let o3 = "";
          if (typeof e23.params == "string" && (o3 = e23.raws.params ? e23.raws.params.scss ? e23.raws.params.scss : e23.raws.params.raw : e23.params, e23.raws.afterName && e23.raws.afterName.trim().length > 0 && (o3 = e23.raws.afterName + o3), e23.raws.between && e23.raws.between.trim().length > 0 && (o3 += e23.raws.between), o3 = o3.trim(), e23.raws.params = o3), r4.trim().length > 0)
            return r4.startsWith("@") && r4.endsWith(":") ? e23 : e23.mixin ? (e23.selector = x2(r4, t5), e23) : (f2(e23) && (e23.isSCSSNesterProperty = true), e23.selector = A2(r4), e23);
          if (n3.length > 0) {
            const r5 = n3.match(O2);
            r5 && (n3 = n3.slice(0, r5.index), e23.scssDefault = true, r5[0].trim() !== "!default" && (e23.raws.scssDefault = r5[0]));
            const o4 = n3.match(_2);
            if (o4 && (n3 = n3.slice(0, o4.index), e23.scssGlobal = true, o4[0].trim() !== "!global" && (e23.raws.scssGlobal = o4[0])), n3.startsWith("progid:"))
              return {type: "value-unknown", value: n3};
            e23.value = x2(n3, t5);
          }
          if (c2(t5) && e23.type === "css-decl" && n3.startsWith("extend(") && (e23.extend || (e23.extend = e23.raws.between === ":"), e23.extend && !e23.selector && (delete e23.value, e23.selector = A2(n3.slice("extend(".length, -1)))), e23.type === "css-atrule") {
            if (c2(t5)) {
              if (e23.mixin) {
                const t6 = e23.raws.identifier + e23.name + e23.raws.afterName + e23.raws.params;
                return e23.selector = A2(t6), delete e23.params, e23;
              }
              if (e23.function)
                return e23;
            }
            if (t5.parser === "css" && e23.name === "custom-selector") {
              const t6 = e23.params.match(/:--\S+?\s+/)[0].trim();
              return e23.customSelector = t6, e23.selector = A2(e23.params.slice(t6.length).trim()), delete e23.params, e23;
            }
            if (c2(t5)) {
              if (e23.name.includes(":") && !e23.params) {
                e23.variable = true;
                const r5 = e23.name.split(":");
                e23.name = r5[0], e23.value = x2(r5.slice(1).join(":"), t5);
              }
              if (!["page", "nest", "keyframes"].includes(e23.name) && e23.params && e23.params[0] === ":" && (e23.variable = true, e23.value = x2(e23.params.slice(1), t5), e23.raws.afterName += ":"), e23.variable)
                return delete e23.params, e23;
            }
          }
          if (e23.type === "css-atrule" && o3.length > 0) {
            const {name: r5} = e23, n4 = e23.name.toLowerCase();
            return r5 === "warn" || r5 === "error" ? (e23.params = {type: "media-unknown", value: o3}, e23) : r5 === "extend" || r5 === "nest" ? (e23.selector = A2(o3), delete e23.params, e23) : r5 === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(o3) ? e23.params = x2(o3, t5) : (e23.selector = A2(o3), delete e23.params), e23) : d2(n4) ? (e23.import = true, delete e23.filename, e23.params = x2(o3, t5), e23) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(r5) ? (o3 = o3.replace(/(\$\S+?)\s+?\.{3}/, "$1..."), o3 = o3.replace(/^(?!if)(\S+)\s+\(/, "$1("), e23.value = x2(o3, t5), delete e23.params, e23) : ["media", "custom-media"].includes(n4) ? o3.includes("#{") ? {type: "media-unknown", value: o3} : (e23.params = k2(o3), e23) : (e23.params = o3, e23);
          }
        }
        return e23;
      }
      function T2(e23, t5, r4) {
        const o3 = i2(t5), {frontMatter: s3} = o3;
        let u3;
        t5 = o3.content;
        try {
          u3 = e23(t5);
        } catch (e24) {
          const {name: t6, reason: r5, line: o4, column: i3} = e24;
          if (typeof o4 != "number")
            throw e24;
          throw n2(`${t6}: ${r5}`, {start: {line: o4, column: i3}});
        }
        return u3 = S2(C2(u3, "css-"), r4), m2(u3, t5), s3 && (s3.source = {startOffset: 0, endOffset: s3.raw.length}, u3.nodes.unshift(s3)), u3;
      }
      function I2(e23, t5, n3) {
        const o3 = r3(7371);
        return T2((e24) => o3.parse(v2(e24)), e23, n3);
      }
      function N2(e23, t5, n3) {
        const {parse: o3} = r3(304);
        return T2(o3, e23, n3);
      }
      const M2 = {astFormat: "postcss", hasPragma: s2, locStart: D2, locEnd: g2};
      e22.exports = {parsers: {css: Object.assign(Object.assign({}, M2), {}, {parse: function(e23, t5, r4) {
        const n3 = l2(r4.parser, e23) ? [N2, I2] : [I2, N2];
        let o3;
        for (const i3 of n3)
          try {
            return i3(e23, t5, r4);
          } catch (e24) {
            o3 = o3 || e24;
          }
        if (o3)
          throw o3;
      }}), less: Object.assign(Object.assign({}, M2), {}, {parse: I2}), scss: Object.assign(Object.assign({}, M2), {}, {parse: N2})}};
    }, 8850: (e22, t4, r3) => {
      const n2 = r3(3831), o2 = r3(5115);
      e22.exports = {hasPragma: function(e23) {
        return n2.hasPragma(o2(e23).content);
      }, insertPragma: function(e23) {
        const {frontMatter: t5, content: r4} = o2(e23);
        return (t5 ? t5.raw + "\n\n" : "") + n2.insertPragma(r4);
      }};
    }, 5244: (e22, t4, r3) => {
      const {isNonEmptyArray: n2} = r3(9428), o2 = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), i2 = new Set(["import", "use", "forward"]);
      function s2(e23, t5) {
        const r4 = Array.isArray(t5) ? t5 : [t5];
        let n3, o3 = -1;
        for (; n3 = e23.getParentNode(++o3); )
          if (r4.includes(n3.type))
            return o3;
        return -1;
      }
      function u2(e23, t5) {
        const r4 = s2(e23, t5);
        return r4 === -1 ? null : e23.getParentNode(r4);
      }
      function a2(e23) {
        return e23.type === "value-operator" && e23.value === "*";
      }
      function c2(e23) {
        return e23.type === "value-operator" && e23.value === "/";
      }
      function l2(e23) {
        return e23.type === "value-operator" && e23.value === "+";
      }
      function f2(e23) {
        return e23.type === "value-operator" && e23.value === "-";
      }
      function p2(e23) {
        return e23.type === "value-operator" && e23.value === "%";
      }
      function h2(e23) {
        return e23.type === "value-comma_group" && e23.groups && e23.groups[1] && e23.groups[1].type === "value-colon";
      }
      function d2(e23) {
        return e23.type === "value-paren_group" && e23.groups && e23.groups[0] && h2(e23.groups[0]);
      }
      function D2(e23) {
        return e23 && e23.type === "value-colon";
      }
      e22.exports = {getAncestorCounter: s2, getAncestorNode: u2, getPropOfDeclNode: function(e23) {
        const t5 = u2(e23, "css-decl");
        return t5 && t5.prop && t5.prop.toLowerCase();
      }, hasSCSSInterpolation: function(e23) {
        if (n2(e23)) {
          for (let t5 = e23.length - 1; t5 > 0; t5--)
            if (e23[t5].type === "word" && e23[t5].value === "{" && e23[t5 - 1].type === "word" && e23[t5 - 1].value.endsWith("#"))
              return true;
        }
        return false;
      }, hasStringOrFunction: function(e23) {
        if (n2(e23)) {
          for (let t5 = 0; t5 < e23.length; t5++)
            if (e23[t5].type === "string" || e23[t5].type === "func")
              return true;
        }
        return false;
      }, maybeToLowerCase: function(e23) {
        return e23.includes("$") || e23.includes("@") || e23.includes("#") || e23.startsWith("%") || e23.startsWith("--") || e23.startsWith(":--") || e23.includes("(") && e23.includes(")") ? e23 : e23.toLowerCase();
      }, insideValueFunctionNode: function(e23, t5) {
        const r4 = u2(e23, "value-func");
        return r4 && r4.value && r4.value.toLowerCase() === t5;
      }, insideICSSRuleNode: function(e23) {
        const t5 = u2(e23, "css-rule");
        return t5 && t5.raws && t5.raws.selector && (t5.raws.selector.startsWith(":import") || t5.raws.selector.startsWith(":export"));
      }, insideAtRuleNode: function(e23, t5) {
        const r4 = Array.isArray(t5) ? t5 : [t5], n3 = u2(e23, "css-atrule");
        return n3 && r4.includes(n3.name.toLowerCase());
      }, insideURLFunctionInImportAtRuleNode: function(e23) {
        const t5 = e23.getValue(), r4 = u2(e23, "css-atrule");
        return r4 && r4.name === "import" && t5.groups[0].value === "url" && t5.groups.length === 2;
      }, isKeyframeAtRuleKeywords: function(e23, t5) {
        const r4 = u2(e23, "css-atrule");
        return r4 && r4.name && r4.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t5.toLowerCase());
      }, isWideKeywords: function(e23) {
        return ["initial", "inherit", "unset", "revert"].includes(e23.toLowerCase());
      }, isSCSS: function(e23, t5) {
        return e23 === "less" || e23 === "scss" ? e23 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t5);
      }, isSCSSVariable: function(e23) {
        return Boolean(e23 && e23.type === "word" && e23.value.startsWith("$"));
      }, isLastNode: function(e23, t5) {
        const r4 = e23.getParentNode();
        if (!r4)
          return false;
        const {nodes: n3} = r4;
        return n3 && n3.indexOf(t5) === n3.length - 1;
      }, isLessParser: function(e23) {
        return e23.parser === "css" || e23.parser === "less";
      }, isSCSSControlDirectiveNode: function(e23) {
        return e23.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e23.name);
      }, isDetachedRulesetDeclarationNode: function(e23) {
        return !!e23.selector && (typeof e23.selector == "string" && /^@.+:.*$/.test(e23.selector) || e23.selector.value && /^@.+:.*$/.test(e23.selector.value));
      }, isRelationalOperatorNode: function(e23) {
        return e23.type === "value-word" && ["<", ">", "<=", ">="].includes(e23.value);
      }, isEqualityOperatorNode: function(e23) {
        return e23.type === "value-word" && ["==", "!="].includes(e23.value);
      }, isMultiplicationNode: a2, isDivisionNode: c2, isAdditionNode: l2, isSubtractionNode: f2, isModuloNode: p2, isMathOperatorNode: function(e23) {
        return a2(e23) || c2(e23) || l2(e23) || f2(e23) || p2(e23);
      }, isEachKeywordNode: function(e23) {
        return e23.type === "value-word" && e23.value === "in";
      }, isForKeywordNode: function(e23) {
        return e23.type === "value-word" && ["from", "through", "end"].includes(e23.value);
      }, isURLFunctionNode: function(e23) {
        return e23.type === "value-func" && e23.value.toLowerCase() === "url";
      }, isIfElseKeywordNode: function(e23) {
        return e23.type === "value-word" && ["and", "or", "not"].includes(e23.value);
      }, hasComposesNode: function(e23) {
        return e23.value && e23.value.type === "value-root" && e23.value.group && e23.value.group.type === "value-value" && e23.prop.toLowerCase() === "composes";
      }, hasParensAroundNode: function(e23) {
        return e23.value && e23.value.group && e23.value.group.group && e23.value.group.group.type === "value-paren_group" && e23.value.group.group.open !== null && e23.value.group.group.close !== null;
      }, hasEmptyRawBefore: function(e23) {
        return e23.raws && e23.raws.before === "";
      }, isSCSSNestedPropertyNode: function(e23) {
        return !!e23.selector && e23.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
      }, isDetachedRulesetCallNode: function(e23) {
        return e23.raws && e23.raws.params && /^\(\s*\)$/.test(e23.raws.params);
      }, isTemplatePlaceholderNode: function(e23) {
        return e23.name.startsWith("prettier-placeholder");
      }, isTemplatePropNode: function(e23) {
        return e23.prop.startsWith("@prettier-placeholder");
      }, isPostcssSimpleVarNode: function(e23, t5) {
        return e23.value === "$$" && e23.type === "value-func" && t5 && t5.type === "value-word" && !t5.raws.before;
      }, isKeyValuePairNode: h2, isKeyValuePairInParenGroupNode: d2, isKeyInValuePairNode: function(e23, t5) {
        if (!h2(t5))
          return false;
        const {groups: r4} = t5, n3 = r4.indexOf(e23);
        return n3 !== -1 && D2(r4[n3 + 1]);
      }, isSCSSMapItemNode: function(e23) {
        const t5 = e23.getValue();
        if (t5.groups.length === 0)
          return false;
        const r4 = e23.getParentNode(1);
        if (!(d2(t5) || r4 && d2(r4)))
          return false;
        const n3 = u2(e23, "css-decl");
        return !!(n3 && n3.prop && n3.prop.startsWith("$")) || !!d2(r4) || r4.type === "value-func";
      }, isInlineValueCommentNode: function(e23) {
        return e23.type === "value-comment" && e23.inline;
      }, isHashNode: function(e23) {
        return e23.type === "value-word" && e23.value === "#";
      }, isLeftCurlyBraceNode: function(e23) {
        return e23.type === "value-word" && e23.value === "{";
      }, isRightCurlyBraceNode: function(e23) {
        return e23.type === "value-word" && e23.value === "}";
      }, isWordNode: function(e23) {
        return ["value-word", "value-atword"].includes(e23.type);
      }, isColonNode: D2, isMediaAndSupportsKeywords: function(e23) {
        return e23.value && ["not", "and", "or"].includes(e23.value.toLowerCase());
      }, isColorAdjusterFuncNode: function(e23) {
        return e23.type === "value-func" && o2.has(e23.value.toLowerCase());
      }, lastLineHasInlineComment: function(e23) {
        return /\/\//.test(e23.split(/[\n\r]/).pop());
      }, stringifyNode: function e23(t5) {
        if (t5.groups)
          return (t5.open && t5.open.value ? t5.open.value : "") + t5.groups.reduce((r5, n4, o3) => r5 + e23(n4) + (t5.groups[0].type === "comma_group" && o3 !== t5.groups.length - 1 ? "," : ""), "") + (t5.close && t5.close.value ? t5.close.value : "");
        const r4 = t5.raws && t5.raws.before ? t5.raws.before : "", n3 = t5.raws && t5.raws.quote ? t5.raws.quote : "";
        return r4 + n3 + (t5.type === "atword" ? "@" : "") + (t5.value ? t5.value : "") + n3 + (t5.unit ? t5.unit : "") + (t5.group ? e23(t5.group) : "") + (t5.raws && t5.raws.after ? t5.raws.after : "");
      }, isAtWordPlaceholderNode: function(e23) {
        return e23 && e23.type === "value-atword" && e23.value.startsWith("prettier-placeholder-");
      }, isModuleRuleName: function(e23) {
        return i2.has(e23);
      }};
    }, 3831: (e22, t4, r3) => {
      const {parseWithComments: n2, strip: o2, extract: i2, print: s2} = r3(9234), {getShebang: u2} = r3(9428), {normalizeEndOfLine: a2} = r3(7933);
      function c2(e23) {
        const t5 = u2(e23);
        t5 && (e23 = e23.slice(t5.length + 1));
        const r4 = i2(e23), {pragmas: o3, comments: s3} = n2(r4);
        return {shebang: t5, text: e23, pragmas: o3, comments: s3};
      }
      e22.exports = {hasPragma: function(e23) {
        const t5 = Object.keys(c2(e23).pragmas);
        return t5.includes("prettier") || t5.includes("format");
      }, insertPragma: function(e23) {
        const {shebang: t5, text: r4, pragmas: n3, comments: i3} = c2(e23), u3 = o2(r4), l2 = s2({pragmas: Object.assign({format: ""}, n3), comments: i3.trimStart()});
        return (t5 ? `${t5}
` : "") + a2(l2) + (u3.startsWith("\n") ? "\n" : "\n\n") + u3;
      }};
    }, 8988: (e22, t4, r3) => {
      const {outdent: n2} = r3(5311), o2 = "Config", i2 = "Editor", s2 = "Other", u2 = "Global", a2 = "Special", c2 = {cursorOffset: {since: "1.4.0", category: a2, type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: n2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: i2}, endOfLine: {since: "1.15.0", category: u2, type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: n2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: a2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: s2, cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: a2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: s2}, parser: {since: "0.0.10", category: u2, type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e23) => typeof e23 == "string" || typeof e23 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: u2, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e23) => typeof e23 == "string" || typeof e23 == "object", cliName: "plugin", cliCategory: o2}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: u2, description: n2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e23) => typeof e23 == "string" || typeof e23 == "object", cliName: "plugin-search-dir", cliCategory: o2}, printWidth: {since: "0.0.0", category: u2, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: a2, type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: n2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: i2}, rangeStart: {since: "1.4.0", category: a2, type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: n2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: i2}, requirePragma: {since: "1.7.0", category: a2, type: "boolean", default: false, description: n2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: s2}, tabWidth: {type: "int", category: u2, default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: u2, type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: u2, type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
      e22.exports = {CATEGORY_CONFIG: o2, CATEGORY_EDITOR: i2, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: s2, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: u2, CATEGORY_SPECIAL: a2, options: c2};
    }, 7290: (e22, t4, r3) => {
      const n2 = ["cliName", "cliCategory", "cliDescription"];
      function o2(e23, t5) {
        if (e23 == null)
          return {};
        var r4, n3, o3 = function(e24, t6) {
          if (e24 == null)
            return {};
          var r5, n4, o4 = {}, i4 = Object.keys(e24);
          for (n4 = 0; n4 < i4.length; n4++)
            r5 = i4[n4], t6.indexOf(r5) >= 0 || (o4[r5] = e24[r5]);
          return o4;
        }(e23, t5);
        if (Object.getOwnPropertySymbols) {
          var i3 = Object.getOwnPropertySymbols(e23);
          for (n3 = 0; n3 < i3.length; n3++)
            r4 = i3[n3], t5.indexOf(r4) >= 0 || Object.prototype.propertyIsEnumerable.call(e23, r4) && (o3[r4] = e23[r4]);
        }
        return o3;
      }
      r3(4304), r3(4070), r3(2612);
      const i2 = {compare: r3(2828), lt: r3(3725), gte: r3(9195)}, s2 = r3(9077), u2 = r3(4147).i8, a2 = r3(8988).options;
      e22.exports = {getSupportInfo: function({plugins: e23 = [], showUnreleased: t5 = false, showDeprecated: r4 = false, showInternal: c2 = false} = {}) {
        const l2 = u2.split("-", 1)[0], f2 = e23.flatMap((e24) => e24.languages || []).filter(h2), p2 = s2(Object.assign({}, ...e23.map(({options: e24}) => e24), a2), "name").filter((e24) => h2(e24) && d2(e24)).sort((e24, t6) => e24.name === t6.name ? 0 : e24.name < t6.name ? -1 : 1).map(function(e24) {
          return c2 ? e24 : o2(e24, n2);
        }).map((t6) => {
          t6 = Object.assign({}, t6), Array.isArray(t6.default) && (t6.default = t6.default.length === 1 ? t6.default[0].value : t6.default.filter(h2).sort((e24, t7) => i2.compare(t7.since, e24.since))[0].value), Array.isArray(t6.choices) && (t6.choices = t6.choices.filter((e24) => h2(e24) && d2(e24)), t6.name === "parser" && function(e24, t7, r6) {
            const n3 = new Set(e24.choices.map((e25) => e25.value));
            for (const o3 of t7)
              if (o3.parsers) {
                for (const t8 of o3.parsers)
                  if (!n3.has(t8)) {
                    n3.add(t8);
                    const i3 = r6.find((e25) => e25.parsers && e25.parsers[t8]);
                    let s3 = o3.name;
                    i3 && i3.name && (s3 += ` (plugin: ${i3.name})`), e24.choices.push({value: t8, description: s3});
                  }
              }
          }(t6, f2, e23));
          const r5 = Object.fromEntries(e23.filter((e24) => e24.defaultOptions && e24.defaultOptions[t6.name] !== void 0).map((e24) => [e24.name, e24.defaultOptions[t6.name]]));
          return Object.assign(Object.assign({}, t6), {}, {pluginDefaults: r5});
        });
        return {languages: f2, options: p2};
        function h2(e24) {
          return t5 || !("since" in e24) || e24.since && i2.gte(l2, e24.since);
        }
        function d2(e24) {
          return r4 || !("deprecated" in e24) || e24.deprecated && i2.lt(l2, e24.deprecated);
        }
      }};
    }, 9077: (e22) => {
      e22.exports = (e23, t4) => Object.entries(e23).map(([e24, r3]) => Object.assign({[t4]: e24}, r3));
    }, 5115: (e22) => {
      const t4 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
      e22.exports = function(e23) {
        const r3 = e23.match(t4);
        if (!r3)
          return {content: e23};
        const {startDelimiter: n2, language: o2, value: i2 = "", endDelimiter: s2} = r3.groups;
        let u2 = o2.trim() || "yaml";
        if (n2 === "+++" && (u2 = "toml"), u2 !== "yaml" && n2 !== s2)
          return {content: e23};
        const [a2] = r3;
        return {frontMatter: {type: "front-matter", lang: u2, value: i2, startDelimiter: n2, endDelimiter: s2, raw: a2.replace(/\n$/, "")}, content: a2.replace(/[^\n]/g, " ") + e23.slice(a2.length)};
      };
    }, 4652: (e22) => {
      e22.exports = (e23) => e23[e23.length - 1];
    }, 6920: (e22) => {
      e22.exports = function(e23, t4) {
        let r3 = 0;
        for (let n2 = 0; n2 < e23.line - 1; ++n2)
          r3 = t4.indexOf("\n", r3) + 1;
        return r3 + e23.column;
      };
    }, 8472: () => {
    }, 2868: () => {
    }, 3248: () => {
    }, 6083: () => {
    }, 4940: (e22, t4, r3) => {
      r3.r(t4), r3.d(t4, {existsSync: () => n2, readFileSync: () => o2, default: () => i2});
      const n2 = () => false, o2 = () => "", i2 = {existsSync: n2, readFileSync: o2};
    }, 4372: (e22, t4, r3) => {
      r3.r(t4), r3.d(t4, {default: () => n2});
      const n2 = {EOL: "\n", platform: () => "browser", cpus: () => [{model: "Prettier"}]};
    }, 3974: (e22, t4, r3) => {
      r3.r(t4), r3.d(t4, {default: () => n2});
      var n2 = r3(5724), o2 = {};
      for (const e23 in n2)
        e23 !== "default" && (o2[e23] = () => n2[e23]);
      r3.d(t4, o2);
    }, 4147: (e22) => {
      e22.exports = {i8: "2.4.1"};
    }}, t3 = {};
    function r2(n2) {
      var o2 = t3[n2];
      if (o2 !== void 0)
        return o2.exports;
      var i2 = t3[n2] = {id: n2, loaded: false, exports: {}};
      return e21[n2](i2, i2.exports, r2), i2.loaded = true, i2.exports;
    }
    return r2.d = (e22, t4) => {
      for (var n2 in t4)
        r2.o(t4, n2) && !r2.o(e22, n2) && Object.defineProperty(e22, n2, {enumerable: true, get: t4[n2]});
    }, r2.g = function() {
      if (typeof globalThis == "object")
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e22) {
        if (typeof window == "object")
          return window;
      }
    }(), r2.hmd = (e22) => ((e22 = Object.create(e22)).children || (e22.children = []), Object.defineProperty(e22, "exports", {enumerable: true, set: () => {
      throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + e22.id);
    }}), e22), r2.o = (e22, t4) => Object.prototype.hasOwnProperty.call(e22, t4), r2.r = (e22) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e22, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e22, "__esModule", {value: true});
    }, r2(738);
  })();
}));
var __decorate = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
define$1();
class SCodeExample extends __SLitComponent {
  constructor() {
    var _a2;
    super(__deepMerge({
      componentUtils: {
        interface: SCodeExampleInterface
      }
    }));
    this._$copy = void 0;
    this._items = [];
    this._activeTabId = void 0;
    const languages = Object.assign({html: xml, javascript, js: javascript, php, bash, shell: bash, css}, (_a2 = this.props.languages) !== null && _a2 !== void 0 ? _a2 : {});
    Object.keys(languages).forEach((lang) => {
      core.registerLanguage(lang, languages[lang]);
    });
  }
  static get properties() {
    return __SLitComponent.properties({}, SCodeExampleInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css)}
        `;
  }
  firstUpdated() {
    var _a2, _b2, _c2;
    return __awaiter(this, void 0, void 0, function* () {
      this.$templates.forEach(($template) => {
        var _a3, _b3, _c3, _d2, _e2, _f2, _g2;
        if (!$template.getAttribute)
          return;
        let parser = "babel";
        switch ((_b3 = (_a3 = $template.getAttribute("id")) !== null && _a3 !== void 0 ? _a3 : $template.getAttribute("language")) !== null && _b3 !== void 0 ? _b3 : $template.getAttribute("lang")) {
          case "html":
          case "xml":
            parser = "html";
            break;
          case "css":
          case "postcss":
            parser = "postcss";
            break;
        }
        let rawCode = decodeHtmlEntities($template.innerHTML);
        const formatedCode = VV.format(rawCode, {
          parser,
          plugins: [Ot, Bo, Uu]
        });
        this._items = [
          ...this._items,
          {
            id: (_e2 = (_d2 = (_c3 = $template.getAttribute("id")) !== null && _c3 !== void 0 ? _c3 : $template.getAttribute("language")) !== null && _d2 !== void 0 ? _d2 : $template.getAttribute("lang")) !== null && _e2 !== void 0 ? _e2 : "html",
            lang: (_g2 = (_f2 = $template.getAttribute("language")) !== null && _f2 !== void 0 ? _f2 : $template.getAttribute("lang")) !== null && _g2 !== void 0 ? _g2 : "html",
            code: formatedCode
          }
        ];
        $template.remove();
      });
      if (this.active) {
        this.setActiveTab(this.active);
      } else {
        if (this._items[0]) {
          this.setActiveTab(this._items[0].id);
        }
      }
      yield wait(500);
      this._$content = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".s-code-example__content");
      this._$pre = (_b2 = this.shadowRoot) === null || _b2 === void 0 ? void 0 : _b2.querySelector(".s-code-example__code");
      this._$root = (_c2 = this.shadowRoot) === null || _c2 === void 0 ? void 0 : _c2.querySelector(".s-code-example");
      return true;
    });
  }
  setActiveTabByTab(e20) {
    this.setActiveTab(e20.target.id);
  }
  setActiveTab(id2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield wait();
      this._activeTabId = id2;
      this.initPrismOnTab(id2);
    });
  }
  setMoreClass() {
    return __awaiter(this, void 0, void 0, function* () {
      yield wait(500);
      if (this._more) {
        this._$root.classList.add("s-code-example--more");
      } else {
        this._$root.classList.remove("s-code-example--more");
      }
    });
  }
  toggleMore() {
    this._more = !this._more;
    this.setMoreClass();
  }
  initPrismOnTab(id2) {
    var _a2;
    const $content = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`pre#${id2} code`);
    if ($content.hasAttribute("inited")) {
      this.setMoreClass();
      return;
    }
    $content.setAttribute("inited", "true");
    core.highlightElement($content);
    this.setMoreClass();
  }
  copy() {
    const id2 = this._activeTabId;
    const item = this._items.filter((i2) => i2.id === id2)[0];
    this.$copy.copy(item.code);
  }
  render() {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    return html`
            <div
                class="${this.componentUtils.className()} ${this.props.more ? this.componentUtils.className("more") : ""}"
                ?lines="${this.lines}"
                ?mounted="${this.mounted}"
                ?default-style="${this.defaultStyle}"
                toolbar-position="${this.toolbarPosition}"
            >
                <div class="templates">
                    <slot></slot>
                </div>

                <header class="${this.componentUtils.className("__nav")}">
                    <ol class="${this.componentUtils.className("__tabs", "s-tabs")}">
                        ${((_a2 = this._items) !== null && _a2 !== void 0 ? _a2 : []).map((item) => html`
                                <li
                                    class="${this.componentUtils.className("__tab")}"
                                    id="${item.id}"
                                    ?active="${this._activeTabId === item.id}"
                                    @click="${this.setActiveTabByTab}"
                                >
                                    ${item.lang}
                                </li>
                            `)}
                    </ol>
                    ${this.toolbarPosition === "nav" ? html`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                </header>
                <div
                    class="${this.componentUtils.className("__content")}"
                    style="--max-lines: ${(_b2 = this.props.lines) !== null && _b2 !== void 0 ? _b2 : 99999999};"
                >
                    ${this.toolbarPosition !== "nav" ? html`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                    ${((_c2 = this._items) !== null && _c2 !== void 0 ? _c2 : []).map((item) => {
      var _a3, _b3, _c3;
      return html`
                            <pre
                                class="${this.componentUtils.className("__code")}"
                                style="line-height:0;"
                                id="${(_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : item.lang}"
                                ?active="${this._activeTabId === ((_b3 = item.id) !== null && _b3 !== void 0 ? _b3 : item.lang)}"
                            >
                            <code lang="${(_c3 = item.lang) !== null && _c3 !== void 0 ? _c3 : item.id}" class="language-${item.lang} ${item.lang} ${this.props.defaultStyle ? "hljs" : ""}">${item.code.trim()}</code>
                        </pre>
                        `;
    })}
                    <div class="${this.componentUtils.className("__more-bar")}">
                        ${this._moreAction === "toggle" ? html`
                                      <a
                                          class="${this.componentUtils.className("__more-button", "s-btn")}"
                                          @click="${this.toggleMore}"
                                      >
                                          ${this._more ? html`
                                                        ${(_d2 = this.props.lessLabel) !== null && _d2 !== void 0 ? _d2 : "Show less"}
                                                    ` : html`
                                                        ${(_e2 = this.props.moreLabel) !== null && _e2 !== void 0 ? _e2 : "Show more"}
                                                    `}
                                      </a>
                                  ` : html`
                                      <a
                                          class="${this.componentUtils.className("__more-button", "s-btn s-color--accent")}"
                                          href="${this._moreAction}"
                                      >
                                          ${this._more ? html`
                                                        ${(_f2 = this.props.lessLabel) !== null && _f2 !== void 0 ? _f2 : "Show less"}
                                                    ` : html`
                                                        ${(_g2 = this.props.moreLabel) !== null && _g2 !== void 0 ? _g2 : "Show more"}
                                                    `}
                                      </a>
                                  `}                        
                        </a>
                    </div>
                </div>
            </div>
        `;
  }
}
__decorate([
  property()
], SCodeExample.prototype, "_items", void 0);
__decorate([
  property()
], SCodeExample.prototype, "_activeTabId", void 0);
__decorate([
  property({
    type: String
  })
], SCodeExample.prototype, "active", void 0);
__decorate([
  property()
], SCodeExample.prototype, "props", void 0);
__decorate([
  query("s-clipboard-copy")
], SCodeExample.prototype, "$copy", void 0);
__decorate([
  query(".templates")
], SCodeExample.prototype, "$templatesContainer", void 0);
__decorate([
  queryAssignedNodes()
], SCodeExample.prototype, "$templates", void 0);
function define(props = {}, tagName = "s-code-example") {
  __SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SCodeExample);
}
export default SCodeExample;
export {define};

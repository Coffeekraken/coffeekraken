import * as riot from "riot";
import {v4} from "uuid";
import __SPromise from "@coffeekraken/s-promise";
import __SComponentUtils from "@coffeekraken/s-component-utils";
import __SInterface from "@coffeekraken/s-interface";
function uniqid() {
  return v4();
}
function matches(el, selector) {
  if (el.nodeName == "#comment" || el.nodeName == "#text") {
    return false;
  }
  const p = Element.prototype;
  const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
  };
  return f.call(el, selector);
}
let _observer;
const _selectors = {};
function querySelectorLive(selector, cb = null, settings = {}) {
  const id = `${selector} - ${uniqid()}`;
  settings = Object.assign({}, {
    rootNode: document,
    once: true
  }, settings);
  if (!_selectors[selector]) {
    _selectors[selector] = [
      {
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      }
    ];
  } else {
    _selectors[selector].push({
      id,
      selector,
      cb,
      lastMutationId: null,
      settings
    });
  }
  return new __SPromise(({resolve, reject, emit}) => {
    function pushNewNode(node, sel, mutationId) {
      const objs = _selectors[sel];
      if (!objs)
        return;
      objs.forEach((obj) => {
        if (obj.lastMutationId && obj.lastMutationId === mutationId)
          return;
        if (obj.settings.once) {
          if (!node._querySelectorLive) {
            node._querySelectorLive = {};
          }
          if (node._querySelectorLive[obj.id])
            return;
          node._querySelectorLive[obj.id] = true;
        }
        emit("node", node);
        obj.cb && obj.cb(node, () => {
          delete _selectors[obj.selector];
        });
      });
    }
    if (!_observer) {
      _observer = new MutationObserver((mutations) => {
        const mutationId = `mutation-${uniqid()}`;
        mutations.forEach((mutation) => {
          if (mutation.addedNodes && mutation.addedNodes.length) {
            [].forEach.call(mutation.addedNodes, (node) => {
              const selectors = Object.keys(_selectors);
              selectors.forEach((sel) => {
                if (matches(node, sel)) {
                  pushNewNode(node, sel, mutationId);
                }
              });
              if (!node.querySelectorAll)
                return;
              selectors.forEach((sel) => {
                const nestedNodes = node.querySelectorAll(sel);
                [].forEach.call(nestedNodes, (nestedNode) => {
                  pushNewNode(nestedNode, sel, mutationId);
                });
              });
            });
          } else if (mutation.attributeName) {
            const selectors = Object.keys(_selectors);
            selectors.forEach((sel) => {
              if (matches(mutation.target, sel)) {
                pushNewNode(mutation.target, sel, mutationId);
              }
            });
          }
        });
      });
      _observer.observe(settings.rootNode, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["class", "id"]
      });
    }
    [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
      pushNewNode(node, selector, "init");
    });
  });
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", {value: true});
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var riot_compiler = {exports: {}};
var __viteBrowserExternal_fs = new Proxy({}, {
  get() {
    throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});
var __viteBrowserExternal_fs$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_fs});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_fs$1);
var __viteBrowserExternal_path = new Proxy({}, {
  get() {
    throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});
var __viteBrowserExternal_path$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_path});
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_path$1);
/* Riot v5.4.2, @license MIT */
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory(require$$0, require$$1);
  })(commonjsGlobal, function() {
    function camelToDashCase(string) {
      return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    }
    function dashToCamelCase(string) {
      return string.replace(/-(\w)/g, (_, c) => c.toUpperCase());
    }
    function DOMattributesToObject(element) {
      return Array.from(element.attributes).reduce((acc, attribute) => {
        acc[dashToCamelCase(attribute.name)] = attribute.value;
        return acc;
      }, {});
    }
    function moveChildren(source, target) {
      if (source.firstChild) {
        target.appendChild(source.firstChild);
        moveChildren(source, target);
      }
    }
    function cleanNode(node) {
      clearChildren(node.childNodes);
    }
    function clearChildren(children) {
      Array.from(children).forEach(removeChild);
    }
    const removeChild = (node) => node && node.parentNode && node.parentNode.removeChild(node);
    const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);
    const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);
    const COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(), DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol("riot-component"), PLUGINS_SET$1 = new Set(), IS_DIRECTIVE = "is", VALUE_ATTRIBUTE = "value", MOUNT_METHOD_KEY = "mount", UPDATE_METHOD_KEY = "update", UNMOUNT_METHOD_KEY = "unmount", SHOULD_UPDATE_KEY = "shouldUpdate", ON_BEFORE_MOUNT_KEY = "onBeforeMount", ON_MOUNTED_KEY = "onMounted", ON_BEFORE_UPDATE_KEY = "onBeforeUpdate", ON_UPDATED_KEY = "onUpdated", ON_BEFORE_UNMOUNT_KEY = "onBeforeUnmount", ON_UNMOUNTED_KEY = "onUnmounted", PROPS_KEY = "props", STATE_KEY = "state", SLOTS_KEY = "slots", ROOT_KEY = "root", IS_PURE_SYMBOL = Symbol("pure"), IS_COMPONENT_UPDATING = Symbol("is_updating"), PARENT_KEY_SYMBOL = Symbol("parent"), ATTRIBUTES_KEY_SYMBOL = Symbol("attributes"), TEMPLATE_KEY_SYMBOL = Symbol("template");
    var globals = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,
      DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,
      PLUGINS_SET: PLUGINS_SET$1,
      IS_DIRECTIVE,
      VALUE_ATTRIBUTE,
      MOUNT_METHOD_KEY,
      UPDATE_METHOD_KEY,
      UNMOUNT_METHOD_KEY,
      SHOULD_UPDATE_KEY,
      ON_BEFORE_MOUNT_KEY,
      ON_MOUNTED_KEY,
      ON_BEFORE_UPDATE_KEY,
      ON_UPDATED_KEY,
      ON_BEFORE_UNMOUNT_KEY,
      ON_UNMOUNTED_KEY,
      PROPS_KEY,
      STATE_KEY,
      SLOTS_KEY,
      ROOT_KEY,
      IS_PURE_SYMBOL,
      IS_COMPONENT_UPDATING,
      PARENT_KEY_SYMBOL,
      ATTRIBUTES_KEY_SYMBOL,
      TEMPLATE_KEY_SYMBOL
    });
    const EACH = 0;
    const IF = 1;
    const SIMPLE = 2;
    const TAG = 3;
    const SLOT = 4;
    var bindingTypes = {
      EACH,
      IF,
      SIMPLE,
      TAG,
      SLOT
    };
    const ATTRIBUTE = 0;
    const EVENT = 1;
    const TEXT = 2;
    const VALUE = 3;
    var expressionTypes = {
      ATTRIBUTE,
      EVENT,
      TEXT,
      VALUE
    };
    const HEAD_SYMBOL = Symbol("head");
    const TAIL_SYMBOL = Symbol("tail");
    function createHeadTailPlaceholders() {
      const head = document.createComment("fragment head");
      const tail = document.createComment("fragment tail");
      head[HEAD_SYMBOL] = true;
      tail[TAIL_SYMBOL] = true;
      return {
        head,
        tail
      };
    }
    function createTemplateMeta(componentTemplate) {
      const fragment = componentTemplate.dom.cloneNode(true);
      const {
        head,
        tail
      } = createHeadTailPlaceholders();
      return {
        avoidDOMInjection: true,
        fragment,
        head,
        tail,
        children: [head, ...Array.from(fragment.childNodes), tail]
      };
    }
    function getFragmentChildren(_ref) {
      let {
        head,
        tail
      } = _ref;
      const nodes = walkNodes([head], head.nextSibling, (n) => n === tail, false);
      nodes.push(tail);
      return nodes;
    }
    function walkNodes(children, node, check, isFilterActive) {
      const {
        nextSibling
      } = node;
      if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {
        children.push(node);
      }
      if (!nextSibling || check(node))
        return children;
      return walkNodes(children, nextSibling, check, isFilterActive && !node[TAIL_SYMBOL] || nextSibling[HEAD_SYMBOL]);
    }
    function checkType(element, type) {
      return typeof element === type;
    }
    function isSvg(el) {
      const owner = el.ownerSVGElement;
      return !!owner || owner === null;
    }
    function isTemplate(el) {
      return !isNil(el.content);
    }
    function isFunction(value) {
      return checkType(value, "function");
    }
    function isBoolean(value) {
      return checkType(value, "boolean");
    }
    function isObject(value) {
      return !isNil(value) && value.constructor === Object;
    }
    function isNil(value) {
      return value === null || value === void 0;
    }
    var udomdiff = (a, b, get2, before) => {
      const bLength = b.length;
      let aEnd = a.length;
      let bEnd = bLength;
      let aStart = 0;
      let bStart = 0;
      let map = null;
      while (aStart < aEnd || bStart < bEnd) {
        if (aEnd === aStart) {
          const node = bEnd < bLength ? bStart ? get2(b[bStart - 1], -0).nextSibling : get2(b[bEnd - bStart], 0) : before;
          while (bStart < bEnd)
            insertBefore(get2(b[bStart++], 1), node);
        } else if (bEnd === bStart) {
          while (aStart < aEnd) {
            if (!map || !map.has(a[aStart]))
              removeChild(get2(a[aStart], -1));
            aStart++;
          }
        } else if (a[aStart] === b[bStart]) {
          aStart++;
          bStart++;
        } else if (a[aEnd - 1] === b[bEnd - 1]) {
          aEnd--;
          bEnd--;
        } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
          const node = get2(a[--aEnd], -1).nextSibling;
          insertBefore(get2(b[bStart++], 1), get2(a[aStart++], -1).nextSibling);
          insertBefore(get2(b[--bEnd], 1), node);
          a[aEnd] = b[bEnd];
        } else {
          if (!map) {
            map = new Map();
            let i = bStart;
            while (i < bEnd)
              map.set(b[i], i++);
          }
          if (map.has(a[aStart])) {
            const index = map.get(a[aStart]);
            if (bStart < index && index < bEnd) {
              let i = aStart;
              let sequence = 1;
              while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)
                sequence++;
              if (sequence > index - bStart) {
                const node = get2(a[aStart], 0);
                while (bStart < index)
                  insertBefore(get2(b[bStart++], 1), node);
              } else {
                replaceChild(get2(b[bStart++], 1), get2(a[aStart++], -1));
              }
            } else
              aStart++;
          } else
            removeChild(get2(a[aStart++], -1));
        }
      }
      return b;
    };
    const UNMOUNT_SCOPE = Symbol("unmount");
    const EachBinding = {
      nodes: [],
      mount(scope, parentScope) {
        return this.update(scope, parentScope);
      },
      update(scope, parentScope) {
        const {
          placeholder,
          nodes,
          childrenMap
        } = this;
        const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);
        const items = collection ? Array.from(collection) : [];
        const {
          newChildrenMap,
          batches,
          futureNodes
        } = createPatch(items, scope, parentScope, this);
        udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder);
        batches.forEach((fn) => fn());
        this.childrenMap = newChildrenMap;
        this.nodes = futureNodes;
        markEdgeNodes(this.nodes);
        return this;
      },
      unmount(scope, parentScope) {
        this.update(UNMOUNT_SCOPE, parentScope);
        return this;
      }
    };
    function patch(redundant, parentScope) {
      return (item, info) => {
        if (info < 0) {
          const element = redundant[redundant.length - 1];
          if (element) {
            const {
              template,
              nodes,
              context
            } = element;
            nodes.pop();
            if (nodes.length === 0) {
              redundant.pop();
              template.unmount(context, parentScope, null);
            }
          }
        }
        return item;
      };
    }
    function mustFilterItem(condition, context) {
      return condition ? Boolean(condition(context)) === false : false;
    }
    function extendScope(scope, _ref) {
      let {
        itemName,
        indexName,
        index,
        item
      } = _ref;
      scope[itemName] = item;
      if (indexName)
        scope[indexName] = index;
      return scope;
    }
    function markEdgeNodes(nodes) {
      const first = nodes[0];
      const last = nodes[nodes.length - 1];
      if (first)
        first[HEAD_SYMBOL] = true;
      if (last)
        last[TAIL_SYMBOL] = true;
    }
    function createPatch(items, scope, parentScope, binding) {
      const {
        condition,
        template,
        childrenMap,
        itemName,
        getKey,
        indexName,
        root,
        isTemplateTag
      } = binding;
      const newChildrenMap = new Map();
      const batches = [];
      const futureNodes = [];
      items.forEach((item, index) => {
        const context = extendScope(Object.create(scope), {
          itemName,
          indexName,
          index,
          item
        });
        const key = getKey ? getKey(context) : index;
        const oldItem = childrenMap.get(key);
        const nodes = [];
        if (mustFilterItem(condition, context)) {
          return;
        }
        const mustMount = !oldItem;
        const componentTemplate = oldItem ? oldItem.template : template.clone();
        const el = componentTemplate.el || root.cloneNode();
        const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;
        if (mustMount) {
          batches.push(() => componentTemplate.mount(el, context, parentScope, meta));
        } else {
          batches.push(() => componentTemplate.update(context, parentScope));
        }
        if (isTemplateTag) {
          nodes.push(...mustMount ? meta.children : getFragmentChildren(meta));
        } else {
          nodes.push(el);
        }
        childrenMap.delete(key);
        futureNodes.push(...nodes);
        newChildrenMap.set(key, {
          nodes,
          template: componentTemplate,
          context,
          index
        });
      });
      return {
        newChildrenMap,
        batches,
        futureNodes
      };
    }
    function create$6(node, _ref2) {
      let {
        evaluate: evaluate2,
        condition,
        itemName,
        indexName,
        getKey,
        template
      } = _ref2;
      const placeholder = document.createTextNode("");
      const root = node.cloneNode();
      insertBefore(placeholder, node);
      removeChild(node);
      return Object.assign({}, EachBinding, {
        childrenMap: new Map(),
        node,
        root,
        condition,
        evaluate: evaluate2,
        isTemplateTag: isTemplate(root),
        template: template.createDOM(node),
        getKey,
        indexName,
        itemName,
        placeholder
      });
    }
    const IfBinding = {
      mount(scope, parentScope) {
        return this.update(scope, parentScope);
      },
      update(scope, parentScope) {
        const value = !!this.evaluate(scope);
        const mustMount = !this.value && value;
        const mustUnmount = this.value && !value;
        const mount2 = () => {
          const pristine = this.node.cloneNode();
          insertBefore(pristine, this.placeholder);
          this.template = this.template.clone();
          this.template.mount(pristine, scope, parentScope);
        };
        switch (true) {
          case mustMount:
            mount2();
            break;
          case mustUnmount:
            this.unmount(scope);
            break;
          default:
            if (value)
              this.template.update(scope, parentScope);
        }
        this.value = value;
        return this;
      },
      unmount(scope, parentScope) {
        this.template.unmount(scope, parentScope, true);
        return this;
      }
    };
    function create$5(node, _ref) {
      let {
        evaluate: evaluate2,
        template
      } = _ref;
      const placeholder = document.createTextNode("");
      insertBefore(placeholder, node);
      removeChild(node);
      return Object.assign({}, IfBinding, {
        node,
        evaluate: evaluate2,
        placeholder,
        template: template.createDOM(node)
      });
    }
    function panic(message) {
      throw new Error(message);
    }
    function memoize(fn) {
      const cache = new Map();
      const cached = (val) => {
        return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
      };
      cached.cache = cache;
      return cached;
    }
    function evaluateAttributeExpressions(attributes) {
      return attributes.reduce((acc, attribute) => {
        const {
          value,
          type
        } = attribute;
        switch (true) {
          case (!attribute.name && type === ATTRIBUTE):
            return Object.assign({}, acc, value);
          case type === VALUE:
            acc.value = attribute.value;
            break;
          default:
            acc[dashToCamelCase(attribute.name)] = attribute.value;
        }
        return acc;
      }, {});
    }
    const ElementProto = typeof Element === "undefined" ? {} : Element.prototype;
    const isNativeHtmlProperty = memoize((name) => ElementProto.hasOwnProperty(name));
    function setAllAttributes(node, attributes) {
      Object.entries(attributes).forEach((_ref) => {
        let [name, value] = _ref;
        return attributeExpression(node, {
          name
        }, value);
      });
    }
    function removeAllAttributes(node, newAttributes, oldAttributes) {
      const newKeys = newAttributes ? Object.keys(newAttributes) : [];
      Object.keys(oldAttributes).filter((name) => !newKeys.includes(name)).forEach((attribute) => node.removeAttribute(attribute));
    }
    function canRenderAttribute(value) {
      return value === true || ["string", "number"].includes(typeof value);
    }
    function shouldRemoveAttribute(value) {
      return isNil(value) || value === false || value === "";
    }
    function attributeExpression(node, _ref2, value, oldValue) {
      let {
        name
      } = _ref2;
      if (!name) {
        if (oldValue) {
          removeAllAttributes(node, value, oldValue);
        }
        if (value) {
          setAllAttributes(node, value);
        }
        return;
      }
      if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {
        node[name] = value;
      }
      if (shouldRemoveAttribute(value)) {
        node.removeAttribute(name);
      } else if (canRenderAttribute(value)) {
        node.setAttribute(name, normalizeValue(name, value));
      }
    }
    function normalizeValue(name, value) {
      if (value === true)
        return name;
      return value;
    }
    const RE_EVENTS_PREFIX = /^on/;
    const getCallbackAndOptions = (value) => Array.isArray(value) ? value : [value, false];
    const EventListener = {
      handleEvent(event) {
        this[event.type](event);
      }
    };
    const ListenersWeakMap = new WeakMap();
    const createListener = (node) => {
      const listener = Object.create(EventListener);
      ListenersWeakMap.set(node, listener);
      return listener;
    };
    function eventExpression(node, _ref, value) {
      let {
        name
      } = _ref;
      const normalizedEventName = name.replace(RE_EVENTS_PREFIX, "");
      const eventListener = ListenersWeakMap.get(node) || createListener(node);
      const [callback, options] = getCallbackAndOptions(value);
      const handler = eventListener[normalizedEventName];
      const mustRemoveEvent = handler && !callback;
      const mustAddEvent = callback && !handler;
      if (mustRemoveEvent) {
        node.removeEventListener(normalizedEventName, eventListener);
      }
      if (mustAddEvent) {
        node.addEventListener(normalizedEventName, eventListener, options);
      }
      eventListener[normalizedEventName] = callback;
    }
    function normalizeStringValue(value) {
      return isNil(value) ? "" : value;
    }
    const getTextNode = (node, childNodeIndex) => {
      const target = node.childNodes[childNodeIndex];
      if (target.nodeType === Node.COMMENT_NODE) {
        const textNode = document.createTextNode("");
        node.replaceChild(textNode, target);
        return textNode;
      }
      return target;
    };
    function textExpression(node, data, value) {
      node.data = normalizeStringValue(value);
    }
    function valueExpression(node, expression, value) {
      node.value = normalizeStringValue(value);
    }
    var expressions = {
      [ATTRIBUTE]: attributeExpression,
      [EVENT]: eventExpression,
      [TEXT]: textExpression,
      [VALUE]: valueExpression
    };
    const Expression = {
      mount(scope) {
        this.value = this.evaluate(scope);
        apply(this, this.value);
        return this;
      },
      update(scope) {
        const value = this.evaluate(scope);
        if (this.value !== value) {
          apply(this, value);
          this.value = value;
        }
        return this;
      },
      unmount() {
        if (this.type === EVENT)
          apply(this, null);
        return this;
      }
    };
    function apply(expression, value) {
      return expressions[expression.type](expression.node, expression, value, expression.value);
    }
    function create$4(node, data) {
      return Object.assign({}, Expression, data, {
        node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node
      });
    }
    function flattenCollectionMethods(collection, methods, context) {
      return methods.reduce((acc, method) => {
        return Object.assign({}, acc, {
          [method]: (scope) => {
            return collection.map((item) => item[method](scope)) && context;
          }
        });
      }, {});
    }
    function create$3(node, _ref) {
      let {
        expressions: expressions2
      } = _ref;
      return Object.assign({}, flattenCollectionMethods(expressions2.map((expression) => create$4(node, expression)), ["mount", "update", "unmount"]));
    }
    function extendParentScope(attributes, scope, parentScope) {
      if (!attributes || !attributes.length)
        return parentScope;
      const expressions2 = attributes.map((attr) => Object.assign({}, attr, {
        value: attr.evaluate(scope)
      }));
      return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions2));
    }
    const getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;
    const SlotBinding = {
      attributes: [],
      getTemplateScope(scope, parentScope) {
        return extendParentScope(this.attributes, scope, parentScope);
      },
      mount(scope, parentScope) {
        const templateData = scope.slots ? scope.slots.find((_ref) => {
          let {
            id
          } = _ref;
          return id === this.name;
        }) : false;
        const {
          parentNode
        } = this.node;
        const realParent = getRealParent(scope, parentScope);
        this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);
        if (this.template) {
          this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);
          this.template.children = Array.from(this.node.childNodes);
          moveSlotInnerContent(this.node);
        }
        removeChild(this.node);
        return this;
      },
      update(scope, parentScope) {
        if (this.template) {
          const realParent = getRealParent(scope, parentScope);
          this.template.update(this.getTemplateScope(scope, realParent), realParent);
        }
        return this;
      },
      unmount(scope, parentScope, mustRemoveRoot) {
        if (this.template) {
          this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);
        }
        return this;
      }
    };
    function moveSlotInnerContent(slot) {
      const child = slot && slot.firstChild;
      if (!child)
        return;
      insertBefore(child, slot);
      moveSlotInnerContent(slot);
    }
    function createSlot(node, _ref2) {
      let {
        name,
        attributes
      } = _ref2;
      return Object.assign({}, SlotBinding, {
        attributes,
        node,
        name
      });
    }
    function getTag(component2, slots, attributes) {
      if (slots === void 0) {
        slots = [];
      }
      if (attributes === void 0) {
        attributes = [];
      }
      if (component2) {
        return component2({
          slots,
          attributes
        });
      }
      return create(slotsToMarkup(slots), [...slotBindings(slots), {
        expressions: attributes.map((attr) => {
          return Object.assign({
            type: ATTRIBUTE
          }, attr);
        })
      }]);
    }
    function slotBindings(slots) {
      return slots.reduce((acc, _ref) => {
        let {
          bindings: bindings2
        } = _ref;
        return acc.concat(bindings2);
      }, []);
    }
    function slotsToMarkup(slots) {
      return slots.reduce((acc, slot) => {
        return acc + slot.html;
      }, "");
    }
    const TagBinding = {
      mount(scope) {
        return this.update(scope);
      },
      update(scope, parentScope) {
        const name = this.evaluate(scope);
        if (name && name === this.name) {
          this.tag.update(scope);
        } else {
          this.unmount(scope, parentScope, true);
          this.name = name;
          this.tag = getTag(this.getComponent(name), this.slots, this.attributes);
          this.tag.mount(this.node, scope);
        }
        return this;
      },
      unmount(scope, parentScope, keepRootTag) {
        if (this.tag) {
          this.tag.unmount(keepRootTag);
        }
        return this;
      }
    };
    function create$2(node, _ref2) {
      let {
        evaluate: evaluate2,
        getComponent,
        slots,
        attributes
      } = _ref2;
      return Object.assign({}, TagBinding, {
        node,
        evaluate: evaluate2,
        slots,
        attributes,
        getComponent
      });
    }
    var bindings = {
      [IF]: create$5,
      [SIMPLE]: create$3,
      [EACH]: create$6,
      [TAG]: create$2,
      [SLOT]: createSlot
    };
    function fixTextExpressionsOffset(expressions2, textExpressionsOffset) {
      return expressions2.map((e) => e.type === TEXT ? Object.assign({}, e, {
        childNodeIndex: e.childNodeIndex + textExpressionsOffset
      }) : e);
    }
    function create$1(root, binding, templateTagOffset) {
      const {
        selector,
        type,
        redundantAttribute,
        expressions: expressions2
      } = binding;
      const node = selector ? root.querySelector(selector) : root;
      if (redundantAttribute)
        node.removeAttribute(redundantAttribute);
      const bindingExpressions = expressions2 || [];
      return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {
        expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions
      }));
    }
    function createHTMLTree(html, root) {
      const template = isTemplate(root) ? root : document.createElement("template");
      template.innerHTML = html;
      return template.content;
    }
    function createSVGTree(html, container) {
      const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`, "application/xml").documentElement, true);
      return svgNode;
    }
    function createDOMTree(root, html) {
      if (isSvg(root))
        return createSVGTree(html, root);
      return createHTMLTree(html, root);
    }
    function injectDOM(el, dom) {
      switch (true) {
        case isSvg(el):
          moveChildren(dom, el);
          break;
        case isTemplate(el):
          el.parentNode.replaceChild(dom, el);
          break;
        default:
          el.appendChild(dom);
      }
    }
    function createTemplateDOM(el, html) {
      return html && (typeof html === "string" ? createDOMTree(el, html) : html);
    }
    const TemplateChunk = Object.freeze({
      createDOM(el) {
        this.dom = this.dom || createTemplateDOM(el, this.html);
        return this;
      },
      mount(el, scope, parentScope, meta) {
        if (meta === void 0) {
          meta = {};
        }
        if (!el)
          throw new Error("Please provide DOM node to mount properly your template");
        if (this.el)
          this.unmount(scope);
        const {
          fragment,
          children,
          avoidDOMInjection
        } = meta;
        const {
          parentNode
        } = children ? children[0] : el;
        const isTemplateTag = isTemplate(el);
        const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.childNodes).indexOf(el), 0) : null;
        this.isTemplateTag = isTemplateTag;
        this.createDOM(el);
        if (this.dom) {
          this.fragment = fragment || this.dom.cloneNode(true);
        }
        this.el = this.isTemplateTag ? parentNode : el;
        this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null;
        if (!avoidDOMInjection && this.fragment)
          injectDOM(el, this.fragment);
        this.bindings = this.bindingsData.map((binding) => create$1(this.el, binding, templateTagOffset));
        this.bindings.forEach((b) => b.mount(scope, parentScope));
        this.meta = meta;
        return this;
      },
      update(scope, parentScope) {
        this.bindings.forEach((b) => b.update(scope, parentScope));
        return this;
      },
      unmount(scope, parentScope, mustRemoveRoot) {
        if (this.el) {
          this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));
          switch (true) {
            case this.el[IS_PURE_SYMBOL]:
              break;
            case (this.children && mustRemoveRoot !== null):
              clearChildren(this.children);
              break;
            case mustRemoveRoot === true:
              removeChild(this.el);
              break;
            case mustRemoveRoot !== null:
              cleanNode(this.el);
              break;
          }
          this.el = null;
        }
        return this;
      },
      clone() {
        return Object.assign({}, this, {
          meta: {},
          el: null
        });
      }
    });
    function create(html, bindings2) {
      if (bindings2 === void 0) {
        bindings2 = [];
      }
      return Object.assign({}, TemplateChunk, {
        html,
        bindingsData: bindings2
      });
    }
    var DOMBindings = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      template: create,
      createBinding: create$1,
      createExpression: create$4,
      bindingTypes,
      expressionTypes
    });
    function noop() {
      return this;
    }
    function autobindMethods(source, methods) {
      methods.forEach((method) => {
        source[method] = source[method].bind(source);
      });
      return source;
    }
    function callOrAssign(source) {
      return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;
    }
    function defineProperty(source, key, value, options) {
      if (options === void 0) {
        options = {};
      }
      Object.defineProperty(source, key, Object.assign({
        value,
        enumerable: false,
        writable: false,
        configurable: true
      }, options));
      return source;
    }
    function defineProperties(source, properties, options) {
      Object.entries(properties).forEach((_ref) => {
        let [key, value] = _ref;
        defineProperty(source, key, value, options);
      });
      return source;
    }
    function defineDefaults(source, defaults) {
      Object.entries(defaults).forEach((_ref2) => {
        let [key, value] = _ref2;
        if (!source[key])
          source[key] = value;
      });
      return source;
    }
    function domToArray(els) {
      if (!Array.isArray(els)) {
        if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === "number")
          return Array.from(els);
        else
          return [els];
      }
      return els;
    }
    function $(selector, ctx) {
      return domToArray(typeof selector === "string" ? (ctx || document).querySelectorAll(selector) : selector);
    }
    const normalize = (values) => values.length === 1 ? values[0] : values;
    function parseNodes(els, name, method) {
      const names = typeof name === "string" ? [name] : name;
      return normalize(domToArray(els).map((el) => {
        return normalize(names.map((n) => el[method](n)));
      }));
    }
    function set(els, name, value) {
      const attrs = typeof name === "object" ? name : {
        [name]: value
      };
      const props = Object.keys(attrs);
      domToArray(els).forEach((el) => {
        props.forEach((prop) => el.setAttribute(prop, attrs[prop]));
      });
      return els;
    }
    function get(els, name) {
      return parseNodes(els, name, "getAttribute");
    }
    const CSS_BY_NAME = new Map();
    const STYLE_NODE_SELECTOR = "style[riot]";
    const getStyleNode = ((style) => {
      return () => {
        if (style)
          return style;
        style = $(STYLE_NODE_SELECTOR)[0] || document.createElement("style");
        set(style, "type", "text/css");
        if (!style.parentNode)
          document.head.appendChild(style);
        return style;
      };
    })();
    var cssManager = {
      CSS_BY_NAME,
      add(name, css) {
        if (!CSS_BY_NAME.has(name)) {
          CSS_BY_NAME.set(name, css);
          this.inject();
        }
        return this;
      },
      inject() {
        getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join("\n");
        return this;
      },
      remove(name) {
        if (CSS_BY_NAME.has(name)) {
          CSS_BY_NAME.delete(name);
          this.inject();
        }
        return this;
      }
    };
    function curry(fn) {
      for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        acc[_key - 1] = arguments[_key];
      }
      return function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        args = [...acc, ...args];
        return args.length < fn.length ? curry(fn, ...args) : fn(...args);
      };
    }
    function getName(element) {
      return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();
    }
    const COMPONENT_CORE_HELPERS = Object.freeze({
      $(selector) {
        return $(selector, this.root)[0];
      },
      $$(selector) {
        return $(selector, this.root);
      }
    });
    const PURE_COMPONENT_API = Object.freeze({
      [MOUNT_METHOD_KEY]: noop,
      [UPDATE_METHOD_KEY]: noop,
      [UNMOUNT_METHOD_KEY]: noop
    });
    const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
      [SHOULD_UPDATE_KEY]: noop,
      [ON_BEFORE_MOUNT_KEY]: noop,
      [ON_MOUNTED_KEY]: noop,
      [ON_BEFORE_UPDATE_KEY]: noop,
      [ON_UPDATED_KEY]: noop,
      [ON_BEFORE_UNMOUNT_KEY]: noop,
      [ON_UNMOUNTED_KEY]: noop
    });
    const MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {
      clone: noop,
      createDOM: noop
    });
    const memoizedCreateComponent = memoize(createComponent);
    function evaluateInitialProps(element, initialProps) {
      if (initialProps === void 0) {
        initialProps = {};
      }
      return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));
    }
    const bindDOMNodeToComponentObject = (node, component2) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component2;
    function createCoreAPIMethods(mapFunction) {
      return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {
        acc[method] = mapFunction(method);
        return acc;
      }, {});
    }
    function componentTemplateFactory(template, componentShell) {
      const components = createSubcomponents(componentShell.exports ? componentShell.exports.components : {});
      return template(create, expressionTypes, bindingTypes, (name) => {
        if (name === componentShell.name)
          return memoizedCreateComponent(componentShell);
        return components[name] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name);
      });
    }
    function createPureComponent(pureFactoryFunction, _ref) {
      let {
        slots,
        attributes,
        props,
        css,
        template
      } = _ref;
      if (template)
        panic("Pure components can not have html");
      if (css)
        panic("Pure components do not have css");
      const component2 = defineDefaults(pureFactoryFunction({
        slots,
        attributes,
        props
      }), PURE_COMPONENT_API);
      return createCoreAPIMethods((method) => function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (method === MOUNT_METHOD_KEY) {
          const [el] = args;
          el[IS_PURE_SYMBOL] = true;
          bindDOMNodeToComponentObject(el, component2);
        }
        component2[method](...args);
        return component2;
      });
    }
    function createComponent(componentShell) {
      const {
        css,
        template,
        exports: exports2,
        name
      } = componentShell;
      const templateFn = template ? componentTemplateFactory(template, componentShell) : MOCKED_TEMPLATE_INTERFACE;
      return (_ref2) => {
        let {
          slots,
          attributes,
          props
        } = _ref2;
        if (exports2 && exports2[IS_PURE_SYMBOL])
          return createPureComponent(exports2, {
            slots,
            attributes,
            props,
            css,
            template
          });
        const componentAPI = callOrAssign(exports2) || {};
        const component2 = defineComponent({
          css,
          template: templateFn,
          componentAPI,
          name
        })({
          slots,
          attributes,
          props
        });
        return {
          mount(element, parentScope, state) {
            return component2.mount(element, state, parentScope);
          },
          update(parentScope, state) {
            return component2.update(state, parentScope);
          },
          unmount(preserveRoot) {
            return component2.unmount(preserveRoot);
          }
        };
      };
    }
    function defineComponent(_ref3) {
      let {
        css,
        template,
        componentAPI,
        name
      } = _ref3;
      if (css && name)
        cssManager.add(name, css);
      return curry(enhanceComponentAPI)(defineProperties(defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {
        [PROPS_KEY]: {},
        [STATE_KEY]: {}
      })), Object.assign({
        [SLOTS_KEY]: null,
        [ROOT_KEY]: null
      }, COMPONENT_CORE_HELPERS, {
        name,
        css,
        template
      })));
    }
    function createAttributeBindings(node, attributes) {
      if (attributes === void 0) {
        attributes = [];
      }
      const expressions2 = attributes.map((a) => create$4(node, a));
      const binding = {};
      return Object.assign(binding, Object.assign({
        expressions: expressions2
      }, createCoreAPIMethods((method) => (scope) => {
        expressions2.forEach((e) => e[method](scope));
        return binding;
      })));
    }
    function createSubcomponents(components) {
      if (components === void 0) {
        components = {};
      }
      return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {
        let [key, value] = _ref4;
        acc[camelToDashCase(key)] = createComponent(value);
        return acc;
      }, {});
    }
    function runPlugins(component2) {
      return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component2);
    }
    function computeState(oldState, newState) {
      return Object.assign({}, oldState, callOrAssign(newState));
    }
    function addCssHook(element, name) {
      if (getName(element) !== name) {
        set(element, IS_DIRECTIVE, name);
      }
    }
    function enhanceComponentAPI(component2, _ref5) {
      let {
        slots,
        attributes,
        props
      } = _ref5;
      return autobindMethods(runPlugins(defineProperties(isObject(component2) ? Object.create(component2) : component2, {
        mount(element, state, parentScope) {
          if (state === void 0) {
            state = {};
          }
          this[PARENT_KEY_SYMBOL] = parentScope;
          this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);
          defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));
          this[STATE_KEY] = computeState(this[STATE_KEY], state);
          this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();
          bindDOMNodeToComponentObject(element, this);
          component2.name && addCssHook(element, component2.name);
          defineProperty(this, ROOT_KEY, element);
          defineProperty(this, SLOTS_KEY, slots);
          this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
          this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);
          this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
          return this;
        },
        update(state, parentScope) {
          if (state === void 0) {
            state = {};
          }
          if (parentScope) {
            this[PARENT_KEY_SYMBOL] = parentScope;
            this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);
          }
          const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);
          if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false)
            return;
          defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));
          this[STATE_KEY] = computeState(this[STATE_KEY], state);
          this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);
          if (!this[IS_COMPONENT_UPDATING]) {
            this[IS_COMPONENT_UPDATING] = true;
            this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);
          }
          this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);
          this[IS_COMPONENT_UPDATING] = false;
          return this;
        },
        unmount(preserveRoot) {
          this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
          this[ATTRIBUTES_KEY_SYMBOL].unmount();
          this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);
          this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
          return this;
        }
      })), Object.keys(component2).filter((prop) => isFunction(component2[prop])));
    }
    function mountComponent(element, initialProps, componentName) {
      const name = componentName || getName(element);
      if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name))
        panic(`The component named "${name}" was never registered`);
      const component2 = COMPONENTS_IMPLEMENTATION_MAP$1.get(name)({
        props: initialProps
      });
      return component2.mount(element);
    }
    function compose() {
      for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        fns[_key2] = arguments[_key2];
      }
      return fns.reduce((f, g) => function() {
        return f(g(...arguments));
      });
    }
    const {
      DOM_COMPONENT_INSTANCE_PROPERTY,
      COMPONENTS_IMPLEMENTATION_MAP,
      PLUGINS_SET
    } = globals;
    function register(name, _ref) {
      let {
        css,
        template,
        exports: exports2
      } = _ref;
      if (COMPONENTS_IMPLEMENTATION_MAP.has(name))
        panic(`The component "${name}" was already registered`);
      COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponent({
        name,
        css,
        template,
        exports: exports2
      }));
      return COMPONENTS_IMPLEMENTATION_MAP;
    }
    function unregister(name) {
      if (!COMPONENTS_IMPLEMENTATION_MAP.has(name))
        panic(`The component "${name}" was never registered`);
      COMPONENTS_IMPLEMENTATION_MAP.delete(name);
      cssManager.remove(name);
      return COMPONENTS_IMPLEMENTATION_MAP;
    }
    function mount(selector, initialProps, name) {
      return $(selector).map((element) => mountComponent(element, initialProps, name));
    }
    function unmount(selector, keepRootElement) {
      return $(selector).map((element) => {
        if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {
          element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);
        }
        return element;
      });
    }
    function install(plugin) {
      if (!isFunction(plugin))
        panic("Plugins must be of type function");
      if (PLUGINS_SET.has(plugin))
        panic("This plugin was already installed");
      PLUGINS_SET.add(plugin);
      return PLUGINS_SET;
    }
    function uninstall(plugin) {
      if (!PLUGINS_SET.has(plugin))
        panic("This plugin was never installed");
      PLUGINS_SET.delete(plugin);
      return PLUGINS_SET;
    }
    function component(implementation) {
      return function(el, props, _temp) {
        let {
          slots,
          attributes,
          parentScope
        } = _temp === void 0 ? {} : _temp;
        return compose((c) => c.mount(el, parentScope), (c) => c({
          props,
          slots,
          attributes
        }), createComponent)(implementation);
      };
    }
    function pure(func) {
      if (!isFunction(func))
        panic('riot.pure accepts only arguments of type "function"');
      func[IS_PURE_SYMBOL] = true;
      return func;
    }
    const version = "v5.4.2";
    const __ = {
      cssManager,
      DOMBindings,
      createComponent,
      defineComponent,
      globals
    };
    var riot2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      register,
      unregister,
      mount,
      unmount,
      install,
      uninstall,
      component,
      pure,
      version,
      __
    });
    var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs2(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var compiler$1 = {exports: {}};
    var require$$02 = void 0;
    var require$$12 = void 0;
    var require$$2 = void 0;
    (function(module2, exports2) {
      (function(global2, factory) {
        factory(exports2, require$$02, require$$12, require$$2);
      })(commonjsGlobal$1, function(exports3, require$$0$2, require$$1$1, require$$22) {
        var global2 = window;
        function _interopDefaultLegacy(e) {
          return e && typeof e === "object" && "default" in e ? e : {"default": e};
        }
        var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0$2);
        var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1$1);
        var require$$2__default = /* @__PURE__ */ _interopDefaultLegacy(require$$22);
        const TAG_LOGIC_PROPERTY = "exports";
        const TAG_CSS_PROPERTY = "css";
        const TAG_TEMPLATE_PROPERTY = "template";
        const TAG_NAME_PROPERTY = "name";
        function getAugmentedNamespace2(n2) {
          if (n2.__esModule)
            return n2;
          var a = Object.defineProperty({}, "__esModule", {value: true});
          Object.keys(n2).forEach(function(k) {
            var d = Object.getOwnPropertyDescriptor(n2, k);
            Object.defineProperty(a, k, d.get ? d : {enumerable: true, get: function get2() {
              return n2[k];
            }});
          });
          return a;
        }
        function createCommonjsModule(fn) {
          var module3 = {exports: {}};
          return fn(module3, module3.exports), module3.exports;
        }
        /*! *****************************************************************************
          	Copyright (c) Microsoft Corporation.
        
          	Permission to use, copy, modify, and/or distribute this software for any
          	purpose with or without fee is hereby granted.
        
          	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
          	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
          	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
          	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
          	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
          	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
          	PERFORMANCE OF THIS SOFTWARE.
          	***************************************************************************** */
        var _extendStatics = function extendStatics(d, b) {
          _extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return _extendStatics(d, b);
        };
        function __extends(d, b) {
          _extendStatics(d, b);
          function __2() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
        }
        var _assign = function __assign() {
          _assign = Object.assign || function __assign2(t) {
            for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
              s = arguments[i];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return _assign.apply(this, arguments);
        };
        function __rest(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        }
        function __decorate(decorators, target, key, desc) {
          var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
          return c2 > 3 && r && Object.defineProperty(target, key, r), r;
        }
        function __param(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        }
        function __metadata(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        }
        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator(thisArg, body) {
          var _ = {label: 0, sent: function sent() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: []}, f, y, t, g;
          return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return {value: op[1], done: false};
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return {value: op[0] ? op[1] : void 0, done: true};
          }
        }
        var __createBinding = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, {enumerable: true, get: function get2() {
            return m[k];
          }});
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        function __exportStar(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding(o, m, p);
        }
        function __values(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {next: function next() {
              if (o && i >= o.length)
                o = void 0;
              return {value: o && o[i++], done: !o};
            }};
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n2) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n2 === void 0 || n2-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = {error};
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        }
        function __spread() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
          return ar;
        }
        function __spreadArrays() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        }
        function __await(v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
        }
        function __asyncGenerator(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n2) {
            if (g[n2])
              i[n2] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n2, v, a, b]) > 1 || resume(n2, v);
                });
              };
          }
          function resume(n2, v) {
            try {
              step(g[n2](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        }
        function __asyncDelegator(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n2, f) {
            i[n2] = o[n2] ? function(v) {
              return (p = !p) ? {value: __await(o[n2](v)), done: n2 === "return"} : f ? f(v) : v;
            } : f;
          }
        }
        function __asyncValues(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n2) {
            i[n2] = o[n2] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n2](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({value: v2, done: d});
            }, reject);
          }
        }
        function __makeTemplateObject(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", {value: raw});
          } else {
            cooked.raw = raw;
          }
          return cooked;
        }
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", {enumerable: true, value: v});
        } : function(o, v) {
          o["default"] = v;
        };
        function __importStar(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        }
        function __importDefault(mod) {
          return mod && mod.__esModule ? mod : {default: mod};
        }
        function __classPrivateFieldGet(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        }
        function __classPrivateFieldSet(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        }
        var tslib_es6 = /* @__PURE__ */ Object.freeze({__proto__: null, __extends, get __assign() {
          return _assign;
        }, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet});
        var tslib_1 = /* @__PURE__ */ getAugmentedNamespace2(tslib_es6);
        var types$4 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.Def = void 0;
          var Op = Object.prototype;
          var objToStr = Op.toString;
          var hasOwn2 = Op.hasOwnProperty;
          var BaseType = function() {
            function BaseType2() {
            }
            BaseType2.prototype.assert = function(value, deep) {
              if (!this.check(value, deep)) {
                var str = shallowStringify(value);
                throw new Error(str + " does not match type " + this);
              }
              return true;
            };
            BaseType2.prototype.arrayOf = function() {
              var elemType = this;
              return new ArrayType(elemType);
            };
            return BaseType2;
          }();
          var ArrayType = function(_super) {
            tslib_1.__extends(ArrayType2, _super);
            function ArrayType2(elemType) {
              var _this = _super.call(this) || this;
              _this.elemType = elemType;
              _this.kind = "ArrayType";
              return _this;
            }
            ArrayType2.prototype.toString = function() {
              return "[" + this.elemType + "]";
            };
            ArrayType2.prototype.check = function(value, deep) {
              var _this = this;
              return Array.isArray(value) && value.every(function(elem) {
                return _this.elemType.check(elem, deep);
              });
            };
            return ArrayType2;
          }(BaseType);
          var IdentityType = function(_super) {
            tslib_1.__extends(IdentityType2, _super);
            function IdentityType2(value) {
              var _this = _super.call(this) || this;
              _this.value = value;
              _this.kind = "IdentityType";
              return _this;
            }
            IdentityType2.prototype.toString = function() {
              return String(this.value);
            };
            IdentityType2.prototype.check = function(value, deep) {
              var result = value === this.value;
              if (!result && typeof deep === "function") {
                deep(this, value);
              }
              return result;
            };
            return IdentityType2;
          }(BaseType);
          var ObjectType = function(_super) {
            tslib_1.__extends(ObjectType2, _super);
            function ObjectType2(fields) {
              var _this = _super.call(this) || this;
              _this.fields = fields;
              _this.kind = "ObjectType";
              return _this;
            }
            ObjectType2.prototype.toString = function() {
              return "{ " + this.fields.join(", ") + " }";
            };
            ObjectType2.prototype.check = function(value, deep) {
              return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
                return field.type.check(value[field.name], deep);
              });
            };
            return ObjectType2;
          }(BaseType);
          var OrType = function(_super) {
            tslib_1.__extends(OrType2, _super);
            function OrType2(types2) {
              var _this = _super.call(this) || this;
              _this.types = types2;
              _this.kind = "OrType";
              return _this;
            }
            OrType2.prototype.toString = function() {
              return this.types.join(" | ");
            };
            OrType2.prototype.check = function(value, deep) {
              return this.types.some(function(type2) {
                return type2.check(value, deep);
              });
            };
            return OrType2;
          }(BaseType);
          var PredicateType = function(_super) {
            tslib_1.__extends(PredicateType2, _super);
            function PredicateType2(name, predicate) {
              var _this = _super.call(this) || this;
              _this.name = name;
              _this.predicate = predicate;
              _this.kind = "PredicateType";
              return _this;
            }
            PredicateType2.prototype.toString = function() {
              return this.name;
            };
            PredicateType2.prototype.check = function(value, deep) {
              var result = this.predicate(value, deep);
              if (!result && typeof deep === "function") {
                deep(this, value);
              }
              return result;
            };
            return PredicateType2;
          }(BaseType);
          var Def = function() {
            function Def2(type2, typeName) {
              this.type = type2;
              this.typeName = typeName;
              this.baseNames = [];
              this.ownFields = Object.create(null);
              this.allSupertypes = Object.create(null);
              this.supertypeList = [];
              this.allFields = Object.create(null);
              this.fieldNames = [];
              this.finalized = false;
              this.buildable = false;
              this.buildParams = [];
            }
            Def2.prototype.isSupertypeOf = function(that) {
              if (that instanceof Def2) {
                if (this.finalized !== true || that.finalized !== true) {
                  throw new Error("");
                }
                return hasOwn2.call(that.allSupertypes, this.typeName);
              } else {
                throw new Error(that + " is not a Def");
              }
            };
            Def2.prototype.checkAllFields = function(value, deep) {
              var allFields = this.allFields;
              if (this.finalized !== true) {
                throw new Error("" + this.typeName);
              }
              function checkFieldByName(name) {
                var field = allFields[name];
                var type2 = field.type;
                var child = field.getValue(value);
                return type2.check(child, deep);
              }
              return value !== null && typeof value === "object" && Object.keys(allFields).every(checkFieldByName);
            };
            Def2.prototype.bases = function() {
              var supertypeNames = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                supertypeNames[_i] = arguments[_i];
              }
              var bases = this.baseNames;
              if (this.finalized) {
                if (supertypeNames.length !== bases.length) {
                  throw new Error("");
                }
                for (var i = 0; i < supertypeNames.length; i++) {
                  if (supertypeNames[i] !== bases[i]) {
                    throw new Error("");
                  }
                }
                return this;
              }
              supertypeNames.forEach(function(baseName) {
                if (bases.indexOf(baseName) < 0) {
                  bases.push(baseName);
                }
              });
              return this;
            };
            return Def2;
          }();
          exports4.Def = Def;
          var Field = function() {
            function Field2(name, type2, defaultFn, hidden) {
              this.name = name;
              this.type = type2;
              this.defaultFn = defaultFn;
              this.hidden = !!hidden;
            }
            Field2.prototype.toString = function() {
              return JSON.stringify(this.name) + ": " + this.type;
            };
            Field2.prototype.getValue = function(obj) {
              var value = obj[this.name];
              if (typeof value !== "undefined") {
                return value;
              }
              if (typeof this.defaultFn === "function") {
                value = this.defaultFn.call(obj);
              }
              return value;
            };
            return Field2;
          }();
          function shallowStringify(value) {
            if (Array.isArray(value)) {
              return "[" + value.map(shallowStringify).join(", ") + "]";
            }
            if (value && typeof value === "object") {
              return "{ " + Object.keys(value).map(function(key) {
                return key + ": " + value[key];
              }).join(", ") + " }";
            }
            return JSON.stringify(value);
          }
          function typesPlugin(_fork) {
            var Type = {
              or: function or2() {
                var types2 = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  types2[_i] = arguments[_i];
                }
                return new OrType(types2.map(function(type2) {
                  return Type.from(type2);
                }));
              },
              from: function from2(value, name) {
                if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {
                  return value;
                }
                if (value instanceof Def) {
                  return value.type;
                }
                if (isArray2.check(value)) {
                  if (value.length !== 1) {
                    throw new Error("only one element type is permitted for typed arrays");
                  }
                  return new ArrayType(Type.from(value[0]));
                }
                if (isObject3.check(value)) {
                  return new ObjectType(Object.keys(value).map(function(name2) {
                    return new Field(name2, Type.from(value[name2], name2));
                  }));
                }
                if (typeof value === "function") {
                  var bicfIndex = builtInCtorFns.indexOf(value);
                  if (bicfIndex >= 0) {
                    return builtInCtorTypes[bicfIndex];
                  }
                  if (typeof name !== "string") {
                    throw new Error("missing name");
                  }
                  return new PredicateType(name, value);
                }
                return new IdentityType(value);
              },
              def: function def(typeName) {
                return hasOwn2.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
              },
              hasDef: function hasDef(typeName) {
                return hasOwn2.call(defCache, typeName);
              }
            };
            var builtInCtorFns = [];
            var builtInCtorTypes = [];
            function defBuiltInType(name, example) {
              var objStr = objToStr.call(example);
              var type2 = new PredicateType(name, function(value) {
                return objToStr.call(value) === objStr;
              });
              if (example && typeof example.constructor === "function") {
                builtInCtorFns.push(example.constructor);
                builtInCtorTypes.push(type2);
              }
              return type2;
            }
            var isString2 = defBuiltInType("string", "truthy");
            var isFunction3 = defBuiltInType("function", function() {
            });
            var isArray2 = defBuiltInType("array", []);
            var isObject3 = defBuiltInType("object", {});
            var isRegExp2 = defBuiltInType("RegExp", /./);
            var isDate2 = defBuiltInType("Date", new Date());
            var isNumber2 = defBuiltInType("number", 3);
            var isBoolean3 = defBuiltInType("boolean", true);
            var isNull2 = defBuiltInType("null", null);
            var isUndefined2 = defBuiltInType("undefined", void 0);
            var builtInTypes = {string: isString2, function: isFunction3, array: isArray2, object: isObject3, RegExp: isRegExp2, Date: isDate2, number: isNumber2, boolean: isBoolean3, null: isNull2, undefined: isUndefined2};
            var defCache = Object.create(null);
            function defFromValue(value) {
              if (value && typeof value === "object") {
                var type2 = value.type;
                if (typeof type2 === "string" && hasOwn2.call(defCache, type2)) {
                  var d = defCache[type2];
                  if (d.finalized) {
                    return d;
                  }
                }
              }
              return null;
            }
            var DefImpl = function(_super) {
              tslib_1.__extends(DefImpl2, _super);
              function DefImpl2(typeName) {
                var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
                  return _this.check(value, deep);
                }), typeName) || this;
                return _this;
              }
              DefImpl2.prototype.check = function(value, deep) {
                if (this.finalized !== true) {
                  throw new Error("prematurely checking unfinalized type " + this.typeName);
                }
                if (value === null || typeof value !== "object") {
                  return false;
                }
                var vDef = defFromValue(value);
                if (!vDef) {
                  if (this.typeName === "SourceLocation" || this.typeName === "Position") {
                    return this.checkAllFields(value, deep);
                  }
                  return false;
                }
                if (deep && vDef === this) {
                  return this.checkAllFields(value, deep);
                }
                if (!this.isSupertypeOf(vDef)) {
                  return false;
                }
                if (!deep) {
                  return true;
                }
                return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
              };
              DefImpl2.prototype.build = function() {
                var _this = this;
                var buildParams = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  buildParams[_i] = arguments[_i];
                }
                this.buildParams = buildParams;
                if (this.buildable) {
                  return this;
                }
                this.field("type", String, function() {
                  return _this.typeName;
                });
                this.buildable = true;
                var addParam = function addParam2(built, param, arg, isArgAvailable) {
                  if (hasOwn2.call(built, param))
                    return;
                  var all = _this.allFields;
                  if (!hasOwn2.call(all, param)) {
                    throw new Error("" + param);
                  }
                  var field = all[param];
                  var type2 = field.type;
                  var value;
                  if (isArgAvailable) {
                    value = arg;
                  } else if (field.defaultFn) {
                    value = field.defaultFn.call(built);
                  } else {
                    var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name) {
                      return all[name];
                    }).join(", ") + ")";
                    throw new Error(message);
                  }
                  if (!type2.check(value)) {
                    throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
                  }
                  built[param] = value;
                };
                var builder = function builder2() {
                  var args = [];
                  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                    args[_i2] = arguments[_i2];
                  }
                  var argc = args.length;
                  if (!_this.finalized) {
                    throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
                  }
                  var built = Object.create(nodePrototype);
                  _this.buildParams.forEach(function(param, i) {
                    if (i < argc) {
                      addParam(built, param, args[i], true);
                    } else {
                      addParam(built, param, null, false);
                    }
                  });
                  Object.keys(_this.allFields).forEach(function(param) {
                    addParam(built, param, null, false);
                  });
                  if (built.type !== _this.typeName) {
                    throw new Error("");
                  }
                  return built;
                };
                builder.from = function(obj) {
                  if (!_this.finalized) {
                    throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
                  }
                  var built = Object.create(nodePrototype);
                  Object.keys(_this.allFields).forEach(function(param) {
                    if (hasOwn2.call(obj, param)) {
                      addParam(built, param, obj[param], true);
                    } else {
                      addParam(built, param, null, false);
                    }
                  });
                  if (built.type !== _this.typeName) {
                    throw new Error("");
                  }
                  return built;
                };
                Object.defineProperty(builders2, getBuilderName(this.typeName), {enumerable: true, value: builder});
                return this;
              };
              DefImpl2.prototype.field = function(name, type2, defaultFn, hidden) {
                if (this.finalized) {
                  console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName));
                  return this;
                }
                this.ownFields[name] = new Field(name, Type.from(type2), defaultFn, hidden);
                return this;
              };
              DefImpl2.prototype.finalize = function() {
                var _this = this;
                if (!this.finalized) {
                  var allFields = this.allFields;
                  var allSupertypes = this.allSupertypes;
                  this.baseNames.forEach(function(name) {
                    var def = defCache[name];
                    if (def instanceof Def) {
                      def.finalize();
                      extend(allFields, def.allFields);
                      extend(allSupertypes, def.allSupertypes);
                    } else {
                      var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(_this.typeName);
                      throw new Error(message);
                    }
                  });
                  extend(allFields, this.ownFields);
                  allSupertypes[this.typeName] = this;
                  this.fieldNames.length = 0;
                  for (var fieldName in allFields) {
                    if (hasOwn2.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                      this.fieldNames.push(fieldName);
                    }
                  }
                  Object.defineProperty(namedTypes2, this.typeName, {enumerable: true, value: this.type});
                  this.finalized = true;
                  populateSupertypeList(this.typeName, this.supertypeList);
                  if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) {
                    wrapExpressionBuilderWithStatement(this.typeName);
                  }
                }
              };
              return DefImpl2;
            }(Def);
            function getSupertypeNames(typeName) {
              if (!hasOwn2.call(defCache, typeName)) {
                throw new Error("");
              }
              var d = defCache[typeName];
              if (d.finalized !== true) {
                throw new Error("");
              }
              return d.supertypeList.slice(1);
            }
            function computeSupertypeLookupTable(candidates) {
              var table = {};
              var typeNames = Object.keys(defCache);
              var typeNameCount = typeNames.length;
              for (var i = 0; i < typeNameCount; ++i) {
                var typeName = typeNames[i];
                var d = defCache[typeName];
                if (d.finalized !== true) {
                  throw new Error("" + typeName);
                }
                for (var j = 0; j < d.supertypeList.length; ++j) {
                  var superTypeName = d.supertypeList[j];
                  if (hasOwn2.call(candidates, superTypeName)) {
                    table[typeName] = superTypeName;
                    break;
                  }
                }
              }
              return table;
            }
            var builders2 = Object.create(null);
            var nodePrototype = {};
            function defineMethod(name, func) {
              var old = nodePrototype[name];
              if (isUndefined2.check(func)) {
                delete nodePrototype[name];
              } else {
                isFunction3.assert(func);
                Object.defineProperty(nodePrototype, name, {enumerable: true, configurable: true, value: func});
              }
              return old;
            }
            function getBuilderName(typeName) {
              return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
                var len = upperCasePrefix.length;
                switch (len) {
                  case 0:
                    return "";
                  case 1:
                    return upperCasePrefix.toLowerCase();
                  default:
                    return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
                }
              });
            }
            function getStatementBuilderName(typeName) {
              typeName = getBuilderName(typeName);
              return typeName.replace(/(Expression)?$/, "Statement");
            }
            var namedTypes2 = {};
            function getFieldNames(object2) {
              var d = defFromValue(object2);
              if (d) {
                return d.fieldNames.slice(0);
              }
              if ("type" in object2) {
                throw new Error("did not recognize object of type " + JSON.stringify(object2.type));
              }
              return Object.keys(object2);
            }
            function getFieldValue(object2, fieldName) {
              var d = defFromValue(object2);
              if (d) {
                var field = d.allFields[fieldName];
                if (field) {
                  return field.getValue(object2);
                }
              }
              return object2 && object2[fieldName];
            }
            function eachField(object2, callback, context) {
              getFieldNames(object2).forEach(function(name) {
                callback.call(this, name, getFieldValue(object2, name));
              }, context);
            }
            function someField(object2, callback, context) {
              return getFieldNames(object2).some(function(name) {
                return callback.call(this, name, getFieldValue(object2, name));
              }, context);
            }
            function wrapExpressionBuilderWithStatement(typeName) {
              var wrapperName = getStatementBuilderName(typeName);
              if (builders2[wrapperName])
                return;
              var wrapped = builders2[getBuilderName(typeName)];
              if (!wrapped)
                return;
              var builder = function builder2() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return builders2.expressionStatement(wrapped.apply(builders2, args));
              };
              builder.from = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return builders2.expressionStatement(wrapped.from.apply(builders2, args));
              };
              builders2[wrapperName] = builder;
            }
            function populateSupertypeList(typeName, list) {
              list.length = 0;
              list.push(typeName);
              var lastSeen = Object.create(null);
              for (var pos = 0; pos < list.length; ++pos) {
                typeName = list[pos];
                var d = defCache[typeName];
                if (d.finalized !== true) {
                  throw new Error("");
                }
                if (hasOwn2.call(lastSeen, typeName)) {
                  delete list[lastSeen[typeName]];
                }
                lastSeen[typeName] = pos;
                list.push.apply(list, d.baseNames);
              }
              for (var to = 0, from2 = to, len = list.length; from2 < len; ++from2) {
                if (hasOwn2.call(list, from2)) {
                  list[to++] = list[from2];
                }
              }
              list.length = to;
            }
            function extend(into, from2) {
              Object.keys(from2).forEach(function(name) {
                into[name] = from2[name];
              });
              return into;
            }
            function finalize() {
              Object.keys(defCache).forEach(function(name) {
                defCache[name].finalize();
              });
            }
            return {Type, builtInTypes, getSupertypeNames, computeSupertypeLookupTable, builders: builders2, defineMethod, getBuilderName, getStatementBuilderName, namedTypes: namedTypes2, getFieldNames, getFieldValue, eachField, someField, finalize};
          }
          exports4.default = typesPlugin;
        });
        var path = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var Op = Object.prototype;
          var hasOwn2 = Op.hasOwnProperty;
          function pathPlugin(fork2) {
            var types2 = fork2.use(types_1.default);
            var isArray2 = types2.builtInTypes.array;
            var isNumber2 = types2.builtInTypes.number;
            var Path = function Path2(value, parentPath, name) {
              if (!(this instanceof Path2)) {
                throw new Error("Path constructor cannot be invoked without 'new'");
              }
              if (parentPath) {
                if (!(parentPath instanceof Path2)) {
                  throw new Error("");
                }
              } else {
                parentPath = null;
                name = null;
              }
              this.value = value;
              this.parentPath = parentPath;
              this.name = name;
              this.__childCache = null;
            };
            var Pp = Path.prototype;
            function getChildCache(path2) {
              return path2.__childCache || (path2.__childCache = Object.create(null));
            }
            function getChildPath(path2, name) {
              var cache = getChildCache(path2);
              var actualChildValue = path2.getValueProperty(name);
              var childPath = cache[name];
              if (!hasOwn2.call(cache, name) || childPath.value !== actualChildValue) {
                childPath = cache[name] = new path2.constructor(actualChildValue, path2, name);
              }
              return childPath;
            }
            Pp.getValueProperty = function getValueProperty(name) {
              return this.value[name];
            };
            Pp.get = function get2() {
              var names = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                names[_i] = arguments[_i];
              }
              var path2 = this;
              var count = names.length;
              for (var i = 0; i < count; ++i) {
                path2 = getChildPath(path2, names[i]);
              }
              return path2;
            };
            Pp.each = function each(callback, context) {
              var childPaths = [];
              var len = this.value.length;
              var i = 0;
              for (var i = 0; i < len; ++i) {
                if (hasOwn2.call(this.value, i)) {
                  childPaths[i] = this.get(i);
                }
              }
              context = context || this;
              for (i = 0; i < len; ++i) {
                if (hasOwn2.call(childPaths, i)) {
                  callback.call(context, childPaths[i]);
                }
              }
            };
            Pp.map = function map(callback, context) {
              var result = [];
              this.each(function(childPath) {
                result.push(callback.call(this, childPath));
              }, context);
              return result;
            };
            Pp.filter = function filter(callback, context) {
              var result = [];
              this.each(function(childPath) {
                if (callback.call(this, childPath)) {
                  result.push(childPath);
                }
              }, context);
              return result;
            };
            function emptyMoves() {
            }
            function getMoves(path2, offset, start, end) {
              isArray2.assert(path2.value);
              if (offset === 0) {
                return emptyMoves;
              }
              var length = path2.value.length;
              if (length < 1) {
                return emptyMoves;
              }
              var argc = arguments.length;
              if (argc === 2) {
                start = 0;
                end = length;
              } else if (argc === 3) {
                start = Math.max(start, 0);
                end = length;
              } else {
                start = Math.max(start, 0);
                end = Math.min(end, length);
              }
              isNumber2.assert(start);
              isNumber2.assert(end);
              var moves = Object.create(null);
              var cache = getChildCache(path2);
              for (var i = start; i < end; ++i) {
                if (hasOwn2.call(path2.value, i)) {
                  var childPath = path2.get(i);
                  if (childPath.name !== i) {
                    throw new Error("");
                  }
                  var newIndex = i + offset;
                  childPath.name = newIndex;
                  moves[newIndex] = childPath;
                  delete cache[i];
                }
              }
              delete cache.length;
              return function() {
                for (var newIndex2 in moves) {
                  var childPath2 = moves[newIndex2];
                  if (childPath2.name !== +newIndex2) {
                    throw new Error("");
                  }
                  cache[newIndex2] = childPath2;
                  path2.value[newIndex2] = childPath2.value;
                }
              };
            }
            Pp.shift = function shift() {
              var move = getMoves(this, -1);
              var result = this.value.shift();
              move();
              return result;
            };
            Pp.unshift = function unshift() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var move = getMoves(this, args.length);
              var result = this.value.unshift.apply(this.value, args);
              move();
              return result;
            };
            Pp.push = function push() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              isArray2.assert(this.value);
              delete getChildCache(this).length;
              return this.value.push.apply(this.value, args);
            };
            Pp.pop = function pop() {
              isArray2.assert(this.value);
              var cache = getChildCache(this);
              delete cache[this.value.length - 1];
              delete cache.length;
              return this.value.pop();
            };
            Pp.insertAt = function insertAt(index) {
              var argc = arguments.length;
              var move = getMoves(this, argc - 1, index);
              if (move === emptyMoves && argc <= 1) {
                return this;
              }
              index = Math.max(index, 0);
              for (var i = 1; i < argc; ++i) {
                this.value[index + i - 1] = arguments[i];
              }
              move();
              return this;
            };
            Pp.insertBefore = function insertBefore2() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var pp = this.parentPath;
              var argc = args.length;
              var insertAtArgs = [this.name];
              for (var i = 0; i < argc; ++i) {
                insertAtArgs.push(args[i]);
              }
              return pp.insertAt.apply(pp, insertAtArgs);
            };
            Pp.insertAfter = function insertAfter() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var pp = this.parentPath;
              var argc = args.length;
              var insertAtArgs = [this.name + 1];
              for (var i = 0; i < argc; ++i) {
                insertAtArgs.push(args[i]);
              }
              return pp.insertAt.apply(pp, insertAtArgs);
            };
            function repairRelationshipWithParent(path2) {
              if (!(path2 instanceof Path)) {
                throw new Error("");
              }
              var pp = path2.parentPath;
              if (!pp) {
                return path2;
              }
              var parentValue = pp.value;
              var parentCache = getChildCache(pp);
              if (parentValue[path2.name] === path2.value) {
                parentCache[path2.name] = path2;
              } else if (isArray2.check(parentValue)) {
                var i = parentValue.indexOf(path2.value);
                if (i >= 0) {
                  parentCache[path2.name = i] = path2;
                }
              } else {
                parentValue[path2.name] = path2.value;
                parentCache[path2.name] = path2;
              }
              if (parentValue[path2.name] !== path2.value) {
                throw new Error("");
              }
              if (path2.parentPath.get(path2.name) !== path2) {
                throw new Error("");
              }
              return path2;
            }
            Pp.replace = function replace(replacement) {
              var results = [];
              var parentValue = this.parentPath.value;
              var parentCache = getChildCache(this.parentPath);
              var count = arguments.length;
              repairRelationshipWithParent(this);
              if (isArray2.check(parentValue)) {
                var originalLength = parentValue.length;
                var move = getMoves(this.parentPath, count - 1, this.name + 1);
                var spliceArgs = [this.name, 1];
                for (var i = 0; i < count; ++i) {
                  spliceArgs.push(arguments[i]);
                }
                var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
                if (splicedOut[0] !== this.value) {
                  throw new Error("");
                }
                if (parentValue.length !== originalLength - 1 + count) {
                  throw new Error("");
                }
                move();
                if (count === 0) {
                  delete this.value;
                  delete parentCache[this.name];
                  this.__childCache = null;
                } else {
                  if (parentValue[this.name] !== replacement) {
                    throw new Error("");
                  }
                  if (this.value !== replacement) {
                    this.value = replacement;
                    this.__childCache = null;
                  }
                  for (i = 0; i < count; ++i) {
                    results.push(this.parentPath.get(this.name + i));
                  }
                  if (results[0] !== this) {
                    throw new Error("");
                  }
                }
              } else if (count === 1) {
                if (this.value !== replacement) {
                  this.__childCache = null;
                }
                this.value = parentValue[this.name] = replacement;
                results.push(this);
              } else if (count === 0) {
                delete parentValue[this.name];
                delete this.value;
                this.__childCache = null;
              } else {
                throw new Error("Could not replace path");
              }
              return results;
            };
            return Path;
          }
          exports4.default = pathPlugin;
          module3.exports = exports4["default"];
        });
        var scope$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var hasOwn2 = Object.prototype.hasOwnProperty;
          function scopePlugin(fork2) {
            var types2 = fork2.use(types_1.default);
            var Type = types2.Type;
            var namedTypes2 = types2.namedTypes;
            var Node3 = namedTypes2.Node;
            var Expression2 = namedTypes2.Expression;
            var isArray2 = types2.builtInTypes.array;
            var b = types2.builders;
            var Scope2 = function Scope3(path2, parentScope) {
              if (!(this instanceof Scope3)) {
                throw new Error("Scope constructor cannot be invoked without 'new'");
              }
              ScopeType.assert(path2.value);
              var depth;
              if (parentScope) {
                if (!(parentScope instanceof Scope3)) {
                  throw new Error("");
                }
                depth = parentScope.depth + 1;
              } else {
                parentScope = null;
                depth = 0;
              }
              Object.defineProperties(this, {path: {value: path2}, node: {value: path2.value}, isGlobal: {value: !parentScope, enumerable: true}, depth: {value: depth}, parent: {value: parentScope}, bindings: {value: {}}, types: {value: {}}});
            };
            var scopeTypes = [
              namedTypes2.Program,
              namedTypes2.Function,
              namedTypes2.CatchClause
            ];
            var ScopeType = Type.or.apply(Type, scopeTypes);
            Scope2.isEstablishedBy = function(node2) {
              return ScopeType.check(node2);
            };
            var Sp = Scope2.prototype;
            Sp.didScan = false;
            Sp.declares = function(name) {
              this.scan();
              return hasOwn2.call(this.bindings, name);
            };
            Sp.declaresType = function(name) {
              this.scan();
              return hasOwn2.call(this.types, name);
            };
            Sp.declareTemporary = function(prefix2) {
              if (prefix2) {
                if (!/^[a-z$_]/i.test(prefix2)) {
                  throw new Error("");
                }
              } else {
                prefix2 = "t$";
              }
              prefix2 += this.depth.toString(36) + "$";
              this.scan();
              var index = 0;
              while (this.declares(prefix2 + index)) {
                ++index;
              }
              var name = prefix2 + index;
              return this.bindings[name] = types2.builders.identifier(name);
            };
            Sp.injectTemporary = function(identifier, init2) {
              identifier || (identifier = this.declareTemporary());
              var bodyPath = this.path.get("body");
              if (namedTypes2.BlockStatement.check(bodyPath.value)) {
                bodyPath = bodyPath.get("body");
              }
              bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init2 || null)]));
              return identifier;
            };
            Sp.scan = function(force) {
              if (force || !this.didScan) {
                for (var name in this.bindings) {
                  delete this.bindings[name];
                }
                scanScope(this.path, this.bindings, this.types);
                this.didScan = true;
              }
            };
            Sp.getBindings = function() {
              this.scan();
              return this.bindings;
            };
            Sp.getTypes = function() {
              this.scan();
              return this.types;
            };
            function scanScope(path2, bindings2, scopeTypes2) {
              var node2 = path2.value;
              ScopeType.assert(node2);
              if (namedTypes2.CatchClause.check(node2)) {
                var param = path2.get("param");
                if (param.value) {
                  addPattern(param, bindings2);
                }
              } else {
                recursiveScanScope(path2, bindings2, scopeTypes2);
              }
            }
            function recursiveScanScope(path2, bindings2, scopeTypes2) {
              var node2 = path2.value;
              if (path2.parent && namedTypes2.FunctionExpression.check(path2.parent.node) && path2.parent.node.id) {
                addPattern(path2.parent.get("id"), bindings2);
              }
              if (!node2)
                ;
              else if (isArray2.check(node2)) {
                path2.each(function(childPath) {
                  recursiveScanChild(childPath, bindings2, scopeTypes2);
                });
              } else if (namedTypes2.Function.check(node2)) {
                path2.get("params").each(function(paramPath) {
                  addPattern(paramPath, bindings2);
                });
                recursiveScanChild(path2.get("body"), bindings2, scopeTypes2);
              } else if (namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node2) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node2) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node2) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node2)) {
                addTypePattern(path2.get("id"), scopeTypes2);
              } else if (namedTypes2.VariableDeclarator.check(node2)) {
                addPattern(path2.get("id"), bindings2);
                recursiveScanChild(path2.get("init"), bindings2, scopeTypes2);
              } else if (node2.type === "ImportSpecifier" || node2.type === "ImportNamespaceSpecifier" || node2.type === "ImportDefaultSpecifier") {
                addPattern(path2.get(node2.local ? "local" : node2.name ? "name" : "id"), bindings2);
              } else if (Node3.check(node2) && !Expression2.check(node2)) {
                types2.eachField(node2, function(name, child) {
                  var childPath = path2.get(name);
                  if (!pathHasValue(childPath, child)) {
                    throw new Error("");
                  }
                  recursiveScanChild(childPath, bindings2, scopeTypes2);
                });
              }
            }
            function pathHasValue(path2, value) {
              if (path2.value === value) {
                return true;
              }
              if (Array.isArray(path2.value) && path2.value.length === 0 && Array.isArray(value) && value.length === 0) {
                return true;
              }
              return false;
            }
            function recursiveScanChild(path2, bindings2, scopeTypes2) {
              var node2 = path2.value;
              if (!node2 || Expression2.check(node2))
                ;
              else if (namedTypes2.FunctionDeclaration.check(node2) && node2.id !== null) {
                addPattern(path2.get("id"), bindings2);
              } else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node2)) {
                addPattern(path2.get("id"), bindings2);
              } else if (ScopeType.check(node2)) {
                if (namedTypes2.CatchClause.check(node2) && namedTypes2.Identifier.check(node2.param)) {
                  var catchParamName = node2.param.name;
                  var hadBinding = hasOwn2.call(bindings2, catchParamName);
                  recursiveScanScope(path2.get("body"), bindings2, scopeTypes2);
                  if (!hadBinding) {
                    delete bindings2[catchParamName];
                  }
                }
              } else {
                recursiveScanScope(path2, bindings2, scopeTypes2);
              }
            }
            function addPattern(patternPath, bindings2) {
              var pattern = patternPath.value;
              namedTypes2.Pattern.assert(pattern);
              if (namedTypes2.Identifier.check(pattern)) {
                if (hasOwn2.call(bindings2, pattern.name)) {
                  bindings2[pattern.name].push(patternPath);
                } else {
                  bindings2[pattern.name] = [patternPath];
                }
              } else if (namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern)) {
                addPattern(patternPath.get("left"), bindings2);
              } else if (namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern)) {
                patternPath.get("properties").each(function(propertyPath) {
                  var property = propertyPath.value;
                  if (namedTypes2.Pattern.check(property)) {
                    addPattern(propertyPath, bindings2);
                  } else if (namedTypes2.Property.check(property)) {
                    addPattern(propertyPath.get("value"), bindings2);
                  } else if (namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property)) {
                    addPattern(propertyPath.get("argument"), bindings2);
                  }
                });
              } else if (namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern)) {
                patternPath.get("elements").each(function(elementPath) {
                  var element = elementPath.value;
                  if (namedTypes2.Pattern.check(element)) {
                    addPattern(elementPath, bindings2);
                  } else if (namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element)) {
                    addPattern(elementPath.get("argument"), bindings2);
                  }
                });
              } else if (namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern)) {
                addPattern(patternPath.get("pattern"), bindings2);
              } else if (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.RestElement && namedTypes2.RestElement.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) {
                addPattern(patternPath.get("argument"), bindings2);
              }
            }
            function addTypePattern(patternPath, types3) {
              var pattern = patternPath.value;
              namedTypes2.Pattern.assert(pattern);
              if (namedTypes2.Identifier.check(pattern)) {
                if (hasOwn2.call(types3, pattern.name)) {
                  types3[pattern.name].push(patternPath);
                } else {
                  types3[pattern.name] = [patternPath];
                }
              }
            }
            Sp.lookup = function(name) {
              for (var scope2 = this; scope2; scope2 = scope2.parent)
                if (scope2.declares(name))
                  break;
              return scope2;
            };
            Sp.lookupType = function(name) {
              for (var scope2 = this; scope2; scope2 = scope2.parent)
                if (scope2.declaresType(name))
                  break;
              return scope2;
            };
            Sp.getGlobalScope = function() {
              var scope2 = this;
              while (!scope2.isGlobal)
                scope2 = scope2.parent;
              return scope2;
            };
            return Scope2;
          }
          exports4.default = scopePlugin;
          module3.exports = exports4["default"];
        });
        var nodePath = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var path_1 = tslib_1.__importDefault(path);
          var scope_1 = tslib_1.__importDefault(scope$1);
          function nodePathPlugin(fork2) {
            var types2 = fork2.use(types_1.default);
            var n2 = types2.namedTypes;
            var b = types2.builders;
            var isNumber2 = types2.builtInTypes.number;
            var isArray2 = types2.builtInTypes.array;
            var Path = fork2.use(path_1.default);
            var Scope2 = fork2.use(scope_1.default);
            var NodePath = function NodePath2(value, parentPath, name) {
              if (!(this instanceof NodePath2)) {
                throw new Error("NodePath constructor cannot be invoked without 'new'");
              }
              Path.call(this, value, parentPath, name);
            };
            var NPp = NodePath.prototype = Object.create(Path.prototype, {constructor: {value: NodePath, enumerable: false, writable: true, configurable: true}});
            Object.defineProperties(NPp, {node: {get: function get2() {
              Object.defineProperty(this, "node", {configurable: true, value: this._computeNode()});
              return this.node;
            }}, parent: {get: function get2() {
              Object.defineProperty(this, "parent", {configurable: true, value: this._computeParent()});
              return this.parent;
            }}, scope: {get: function get2() {
              Object.defineProperty(this, "scope", {configurable: true, value: this._computeScope()});
              return this.scope;
            }}});
            NPp.replace = function() {
              delete this.node;
              delete this.parent;
              delete this.scope;
              return Path.prototype.replace.apply(this, arguments);
            };
            NPp.prune = function() {
              var remainingNodePath = this.parent;
              this.replace();
              return cleanUpNodesAfterPrune(remainingNodePath);
            };
            NPp._computeNode = function() {
              var value = this.value;
              if (n2.Node.check(value)) {
                return value;
              }
              var pp = this.parentPath;
              return pp && pp.node || null;
            };
            NPp._computeParent = function() {
              var value = this.value;
              var pp = this.parentPath;
              if (!n2.Node.check(value)) {
                while (pp && !n2.Node.check(pp.value)) {
                  pp = pp.parentPath;
                }
                if (pp) {
                  pp = pp.parentPath;
                }
              }
              while (pp && !n2.Node.check(pp.value)) {
                pp = pp.parentPath;
              }
              return pp || null;
            };
            NPp._computeScope = function() {
              var value = this.value;
              var pp = this.parentPath;
              var scope2 = pp && pp.scope;
              if (n2.Node.check(value) && Scope2.isEstablishedBy(value)) {
                scope2 = new Scope2(this, scope2);
              }
              return scope2 || null;
            };
            NPp.getValueProperty = function(name) {
              return types2.getFieldValue(this.value, name);
            };
            NPp.needsParens = function(assumeExpressionContext) {
              var pp = this.parentPath;
              if (!pp) {
                return false;
              }
              var node2 = this.value;
              if (!n2.Expression.check(node2)) {
                return false;
              }
              if (node2.type === "Identifier") {
                return false;
              }
              while (!n2.Node.check(pp.value)) {
                pp = pp.parentPath;
                if (!pp) {
                  return false;
                }
              }
              var parent = pp.value;
              switch (node2.type) {
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                  return parent.type === "MemberExpression" && this.name === "object" && parent.object === node2;
                case "BinaryExpression":
                case "LogicalExpression":
                  switch (parent.type) {
                    case "CallExpression":
                      return this.name === "callee" && parent.callee === node2;
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                      return true;
                    case "MemberExpression":
                      return this.name === "object" && parent.object === node2;
                    case "BinaryExpression":
                    case "LogicalExpression": {
                      var n_1 = node2;
                      var po = parent.operator;
                      var pp_1 = PRECEDENCE2[po];
                      var no = n_1.operator;
                      var np = PRECEDENCE2[no];
                      if (pp_1 > np) {
                        return true;
                      }
                      if (pp_1 === np && this.name === "right") {
                        if (parent.right !== n_1) {
                          throw new Error("Nodes must be equal");
                        }
                        return true;
                      }
                    }
                    default:
                      return false;
                  }
                case "SequenceExpression":
                  switch (parent.type) {
                    case "ForStatement":
                      return false;
                    case "ExpressionStatement":
                      return this.name !== "expression";
                    default:
                      return true;
                  }
                case "YieldExpression":
                  switch (parent.type) {
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "CallExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ConditionalExpression":
                    case "YieldExpression":
                      return true;
                    default:
                      return false;
                  }
                case "Literal":
                  return parent.type === "MemberExpression" && isNumber2.check(node2.value) && this.name === "object" && parent.object === node2;
                case "AssignmentExpression":
                case "ConditionalExpression":
                  switch (parent.type) {
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                      return true;
                    case "CallExpression":
                      return this.name === "callee" && parent.callee === node2;
                    case "ConditionalExpression":
                      return this.name === "test" && parent.test === node2;
                    case "MemberExpression":
                      return this.name === "object" && parent.object === node2;
                    default:
                      return false;
                  }
                default:
                  if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node2) {
                    return containsCallExpression2(node2);
                  }
              }
              if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
                return true;
              return false;
            };
            function isBinary2(node2) {
              return n2.BinaryExpression.check(node2) || n2.LogicalExpression.check(node2);
            }
            var PRECEDENCE2 = {};
            [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"]].forEach(function(tier, i) {
              tier.forEach(function(op) {
                PRECEDENCE2[op] = i;
              });
            });
            function containsCallExpression2(node2) {
              if (n2.CallExpression.check(node2)) {
                return true;
              }
              if (isArray2.check(node2)) {
                return node2.some(containsCallExpression2);
              }
              if (n2.Node.check(node2)) {
                return types2.someField(node2, function(_name, child) {
                  return containsCallExpression2(child);
                });
              }
              return false;
            }
            NPp.canBeFirstInStatement = function() {
              var node2 = this.node;
              return !n2.FunctionExpression.check(node2) && !n2.ObjectExpression.check(node2);
            };
            NPp.firstInStatement = function() {
              return firstInStatement(this);
            };
            function firstInStatement(path2) {
              for (var node2, parent; path2.parent; path2 = path2.parent) {
                node2 = path2.node;
                parent = path2.parent.node;
                if (n2.BlockStatement.check(parent) && path2.parent.name === "body" && path2.name === 0) {
                  if (parent.body[0] !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  return true;
                }
                if (n2.ExpressionStatement.check(parent) && path2.name === "expression") {
                  if (parent.expression !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  return true;
                }
                if (n2.SequenceExpression.check(parent) && path2.parent.name === "expressions" && path2.name === 0) {
                  if (parent.expressions[0] !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  continue;
                }
                if (n2.CallExpression.check(parent) && path2.name === "callee") {
                  if (parent.callee !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  continue;
                }
                if (n2.MemberExpression.check(parent) && path2.name === "object") {
                  if (parent.object !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  continue;
                }
                if (n2.ConditionalExpression.check(parent) && path2.name === "test") {
                  if (parent.test !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  continue;
                }
                if (isBinary2(parent) && path2.name === "left") {
                  if (parent.left !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  continue;
                }
                if (n2.UnaryExpression.check(parent) && !parent.prefix && path2.name === "argument") {
                  if (parent.argument !== node2) {
                    throw new Error("Nodes must be equal");
                  }
                  continue;
                }
                return false;
              }
              return true;
            }
            function cleanUpNodesAfterPrune(remainingNodePath) {
              if (n2.VariableDeclaration.check(remainingNodePath.node)) {
                var declarations = remainingNodePath.get("declarations").value;
                if (!declarations || declarations.length === 0) {
                  return remainingNodePath.prune();
                }
              } else if (n2.ExpressionStatement.check(remainingNodePath.node)) {
                if (!remainingNodePath.get("expression").value) {
                  return remainingNodePath.prune();
                }
              } else if (n2.IfStatement.check(remainingNodePath.node)) {
                cleanUpIfStatementAfterPrune(remainingNodePath);
              }
              return remainingNodePath;
            }
            function cleanUpIfStatementAfterPrune(ifStatement) {
              var testExpression = ifStatement.get("test").value;
              var alternate = ifStatement.get("alternate").value;
              var consequent = ifStatement.get("consequent").value;
              if (!consequent && !alternate) {
                var testExpressionStatement = b.expressionStatement(testExpression);
                ifStatement.replace(testExpressionStatement);
              } else if (!consequent && alternate) {
                var negatedTestExpression = b.unaryExpression("!", testExpression, true);
                if (n2.UnaryExpression.check(testExpression) && testExpression.operator === "!") {
                  negatedTestExpression = testExpression.argument;
                }
                ifStatement.get("test").replace(negatedTestExpression);
                ifStatement.get("consequent").replace(alternate);
                ifStatement.get("alternate").replace();
              }
            }
            return NodePath;
          }
          exports4.default = nodePathPlugin;
          module3.exports = exports4["default"];
        });
        var pathVisitor = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var node_path_1 = tslib_1.__importDefault(nodePath);
          var hasOwn2 = Object.prototype.hasOwnProperty;
          function pathVisitorPlugin(fork2) {
            var types2 = fork2.use(types_1.default);
            var NodePath = fork2.use(node_path_1.default);
            var isArray2 = types2.builtInTypes.array;
            var isObject3 = types2.builtInTypes.object;
            var isFunction3 = types2.builtInTypes.function;
            var undefined$1;
            var PathVisitor = function PathVisitor2() {
              if (!(this instanceof PathVisitor2)) {
                throw new Error("PathVisitor constructor cannot be invoked without 'new'");
              }
              this._reusableContextStack = [];
              this._methodNameTable = computeMethodNameTable(this);
              this._shouldVisitComments = hasOwn2.call(this._methodNameTable, "Block") || hasOwn2.call(this._methodNameTable, "Line");
              this.Context = makeContextConstructor(this);
              this._visiting = false;
              this._changeReported = false;
            };
            function computeMethodNameTable(visitor) {
              var typeNames = Object.create(null);
              for (var methodName in visitor) {
                if (/^visit[A-Z]/.test(methodName)) {
                  typeNames[methodName.slice("visit".length)] = true;
                }
              }
              var supertypeTable = types2.computeSupertypeLookupTable(typeNames);
              var methodNameTable = Object.create(null);
              var typeNameKeys = Object.keys(supertypeTable);
              var typeNameCount = typeNameKeys.length;
              for (var i = 0; i < typeNameCount; ++i) {
                var typeName = typeNameKeys[i];
                methodName = "visit" + supertypeTable[typeName];
                if (isFunction3.check(visitor[methodName])) {
                  methodNameTable[typeName] = methodName;
                }
              }
              return methodNameTable;
            }
            PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
              if (methods instanceof PathVisitor) {
                return methods;
              }
              if (!isObject3.check(methods)) {
                return new PathVisitor();
              }
              var Visitor = function Visitor2() {
                if (!(this instanceof Visitor2)) {
                  throw new Error("Visitor constructor cannot be invoked without 'new'");
                }
                PathVisitor.call(this);
              };
              var Vp = Visitor.prototype = Object.create(PVp);
              Vp.constructor = Visitor;
              extend(Vp, methods);
              extend(Visitor, PathVisitor);
              isFunction3.assert(Visitor.fromMethodsObject);
              isFunction3.assert(Visitor.visit);
              return new Visitor();
            };
            function extend(target, source) {
              for (var property in source) {
                if (hasOwn2.call(source, property)) {
                  target[property] = source[property];
                }
              }
              return target;
            }
            PathVisitor.visit = function visit(node2, methods) {
              return PathVisitor.fromMethodsObject(methods).visit(node2);
            };
            var PVp = PathVisitor.prototype;
            PVp.visit = function() {
              if (this._visiting) {
                throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
              }
              this._visiting = true;
              this._changeReported = false;
              this._abortRequested = false;
              var argc = arguments.length;
              var args = new Array(argc);
              for (var i = 0; i < argc; ++i) {
                args[i] = arguments[i];
              }
              if (!(args[0] instanceof NodePath)) {
                args[0] = new NodePath({root: args[0]}).get("root");
              }
              this.reset.apply(this, args);
              var didNotThrow;
              try {
                var root = this.visitWithoutReset(args[0]);
                didNotThrow = true;
              } finally {
                this._visiting = false;
                if (!didNotThrow && this._abortRequested) {
                  return args[0].value;
                }
              }
              return root;
            };
            PVp.AbortRequest = function AbortRequest() {
            };
            PVp.abort = function() {
              var visitor = this;
              visitor._abortRequested = true;
              var request = new visitor.AbortRequest();
              request.cancel = function() {
                visitor._abortRequested = false;
              };
              throw request;
            };
            PVp.reset = function(_path) {
            };
            PVp.visitWithoutReset = function(path2) {
              if (this instanceof this.Context) {
                return this.visitor.visitWithoutReset(path2);
              }
              if (!(path2 instanceof NodePath)) {
                throw new Error("");
              }
              var value = path2.value;
              var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
              if (methodName) {
                var context = this.acquireContext(path2);
                try {
                  return context.invokeVisitorMethod(methodName);
                } finally {
                  this.releaseContext(context);
                }
              } else {
                return visitChildren(path2, this);
              }
            };
            function visitChildren(path2, visitor) {
              if (!(path2 instanceof NodePath)) {
                throw new Error("");
              }
              if (!(visitor instanceof PathVisitor)) {
                throw new Error("");
              }
              var value = path2.value;
              if (isArray2.check(value)) {
                path2.each(visitor.visitWithoutReset, visitor);
              } else if (!isObject3.check(value))
                ;
              else {
                var childNames = types2.getFieldNames(value);
                if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) {
                  childNames.push("comments");
                }
                var childCount = childNames.length;
                var childPaths = [];
                for (var i = 0; i < childCount; ++i) {
                  var childName = childNames[i];
                  if (!hasOwn2.call(value, childName)) {
                    value[childName] = types2.getFieldValue(value, childName);
                  }
                  childPaths.push(path2.get(childName));
                }
                for (var i = 0; i < childCount; ++i) {
                  visitor.visitWithoutReset(childPaths[i]);
                }
              }
              return path2.value;
            }
            PVp.acquireContext = function(path2) {
              if (this._reusableContextStack.length === 0) {
                return new this.Context(path2);
              }
              return this._reusableContextStack.pop().reset(path2);
            };
            PVp.releaseContext = function(context) {
              if (!(context instanceof this.Context)) {
                throw new Error("");
              }
              this._reusableContextStack.push(context);
              context.currentPath = null;
            };
            PVp.reportChanged = function() {
              this._changeReported = true;
            };
            PVp.wasChangeReported = function() {
              return this._changeReported;
            };
            function makeContextConstructor(visitor) {
              function Context(path2) {
                if (!(this instanceof Context)) {
                  throw new Error("");
                }
                if (!(this instanceof PathVisitor)) {
                  throw new Error("");
                }
                if (!(path2 instanceof NodePath)) {
                  throw new Error("");
                }
                Object.defineProperty(this, "visitor", {value: visitor, writable: false, enumerable: true, configurable: false});
                this.currentPath = path2;
                this.needToCallTraverse = true;
                Object.seal(this);
              }
              if (!(visitor instanceof PathVisitor)) {
                throw new Error("");
              }
              var Cp = Context.prototype = Object.create(visitor);
              Cp.constructor = Context;
              extend(Cp, sharedContextProtoMethods);
              return Context;
            }
            var sharedContextProtoMethods = Object.create(null);
            sharedContextProtoMethods.reset = function reset(path2) {
              if (!(this instanceof this.Context)) {
                throw new Error("");
              }
              if (!(path2 instanceof NodePath)) {
                throw new Error("");
              }
              this.currentPath = path2;
              this.needToCallTraverse = true;
              return this;
            };
            sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
              if (!(this instanceof this.Context)) {
                throw new Error("");
              }
              if (!(this.currentPath instanceof NodePath)) {
                throw new Error("");
              }
              var result = this.visitor[methodName].call(this, this.currentPath);
              if (result === false) {
                this.needToCallTraverse = false;
              } else if (result !== undefined$1) {
                this.currentPath = this.currentPath.replace(result)[0];
                if (this.needToCallTraverse) {
                  this.traverse(this.currentPath);
                }
              }
              if (this.needToCallTraverse !== false) {
                throw new Error("Must either call this.traverse or return false in " + methodName);
              }
              var path2 = this.currentPath;
              return path2 && path2.value;
            };
            sharedContextProtoMethods.traverse = function traverse(path2, newVisitor) {
              if (!(this instanceof this.Context)) {
                throw new Error("");
              }
              if (!(path2 instanceof NodePath)) {
                throw new Error("");
              }
              if (!(this.currentPath instanceof NodePath)) {
                throw new Error("");
              }
              this.needToCallTraverse = false;
              return visitChildren(path2, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
            };
            sharedContextProtoMethods.visit = function visit(path2, newVisitor) {
              if (!(this instanceof this.Context)) {
                throw new Error("");
              }
              if (!(path2 instanceof NodePath)) {
                throw new Error("");
              }
              if (!(this.currentPath instanceof NodePath)) {
                throw new Error("");
              }
              this.needToCallTraverse = false;
              return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path2);
            };
            sharedContextProtoMethods.reportChanged = function reportChanged() {
              this.visitor.reportChanged();
            };
            sharedContextProtoMethods.abort = function abort() {
              this.needToCallTraverse = false;
              this.visitor.abort();
            };
            return PathVisitor;
          }
          exports4.default = pathVisitorPlugin;
          module3.exports = exports4["default"];
        });
        var equiv$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          function default_1(fork2) {
            var types2 = fork2.use(types_1.default);
            var getFieldNames = types2.getFieldNames;
            var getFieldValue = types2.getFieldValue;
            var isArray2 = types2.builtInTypes.array;
            var isObject3 = types2.builtInTypes.object;
            var isDate2 = types2.builtInTypes.Date;
            var isRegExp2 = types2.builtInTypes.RegExp;
            var hasOwn2 = Object.prototype.hasOwnProperty;
            function astNodesAreEquivalent(a, b, problemPath) {
              if (isArray2.check(problemPath)) {
                problemPath.length = 0;
              } else {
                problemPath = null;
              }
              return areEquivalent(a, b, problemPath);
            }
            astNodesAreEquivalent.assert = function(a, b) {
              var problemPath = [];
              if (!astNodesAreEquivalent(a, b, problemPath)) {
                if (problemPath.length === 0) {
                  if (a !== b) {
                    throw new Error("Nodes must be equal");
                  }
                } else {
                  throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
                }
              }
            };
            function subscriptForProperty(property) {
              if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
                return "." + property;
              }
              return "[" + JSON.stringify(property) + "]";
            }
            function areEquivalent(a, b, problemPath) {
              if (a === b) {
                return true;
              }
              if (isArray2.check(a)) {
                return arraysAreEquivalent(a, b, problemPath);
              }
              if (isObject3.check(a)) {
                return objectsAreEquivalent(a, b, problemPath);
              }
              if (isDate2.check(a)) {
                return isDate2.check(b) && +a === +b;
              }
              if (isRegExp2.check(a)) {
                return isRegExp2.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;
              }
              return a == b;
            }
            function arraysAreEquivalent(a, b, problemPath) {
              isArray2.assert(a);
              var aLength = a.length;
              if (!isArray2.check(b) || b.length !== aLength) {
                if (problemPath) {
                  problemPath.push("length");
                }
                return false;
              }
              for (var i = 0; i < aLength; ++i) {
                if (problemPath) {
                  problemPath.push(i);
                }
                if (i in a !== i in b) {
                  return false;
                }
                if (!areEquivalent(a[i], b[i], problemPath)) {
                  return false;
                }
                if (problemPath) {
                  var problemPathTail = problemPath.pop();
                  if (problemPathTail !== i) {
                    throw new Error("" + problemPathTail);
                  }
                }
              }
              return true;
            }
            function objectsAreEquivalent(a, b, problemPath) {
              isObject3.assert(a);
              if (!isObject3.check(b)) {
                return false;
              }
              if (a.type !== b.type) {
                if (problemPath) {
                  problemPath.push("type");
                }
                return false;
              }
              var aNames = getFieldNames(a);
              var aNameCount = aNames.length;
              var bNames = getFieldNames(b);
              var bNameCount = bNames.length;
              if (aNameCount === bNameCount) {
                for (var i = 0; i < aNameCount; ++i) {
                  var name = aNames[i];
                  var aChild = getFieldValue(a, name);
                  var bChild = getFieldValue(b, name);
                  if (problemPath) {
                    problemPath.push(name);
                  }
                  if (!areEquivalent(aChild, bChild, problemPath)) {
                    return false;
                  }
                  if (problemPath) {
                    var problemPathTail = problemPath.pop();
                    if (problemPathTail !== name) {
                      throw new Error("" + problemPathTail);
                    }
                  }
                }
                return true;
              }
              if (!problemPath) {
                return false;
              }
              var seenNames = Object.create(null);
              for (i = 0; i < aNameCount; ++i) {
                seenNames[aNames[i]] = true;
              }
              for (i = 0; i < bNameCount; ++i) {
                name = bNames[i];
                if (!hasOwn2.call(seenNames, name)) {
                  problemPath.push(name);
                  return false;
                }
                delete seenNames[name];
              }
              for (name in seenNames) {
                problemPath.push(name);
                break;
              }
              return false;
            }
            return astNodesAreEquivalent;
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var fork = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var path_visitor_1 = tslib_1.__importDefault(pathVisitor);
          var equiv_1 = tslib_1.__importDefault(equiv$1);
          var path_1 = tslib_1.__importDefault(path);
          var node_path_1 = tslib_1.__importDefault(nodePath);
          function default_1(defs) {
            var fork2 = createFork();
            var types2 = fork2.use(types_1.default);
            defs.forEach(fork2.use);
            types2.finalize();
            var PathVisitor = fork2.use(path_visitor_1.default);
            return {Type: types2.Type, builtInTypes: types2.builtInTypes, namedTypes: types2.namedTypes, builders: types2.builders, defineMethod: types2.defineMethod, getFieldNames: types2.getFieldNames, getFieldValue: types2.getFieldValue, eachField: types2.eachField, someField: types2.someField, getSupertypeNames: types2.getSupertypeNames, getBuilderName: types2.getBuilderName, astNodesAreEquivalent: fork2.use(equiv_1.default), finalize: types2.finalize, Path: fork2.use(path_1.default), NodePath: fork2.use(node_path_1.default), PathVisitor, use: fork2.use, visit: PathVisitor.visit};
          }
          exports4.default = default_1;
          function createFork() {
            var used = [];
            var usedResult = [];
            function use(plugin) {
              var idx = used.indexOf(plugin);
              if (idx === -1) {
                idx = used.length;
                used.push(plugin);
                usedResult[idx] = plugin(fork2);
              }
              return usedResult[idx];
            }
            var fork2 = {use};
            return fork2;
          }
          module3.exports = exports4["default"];
        });
        var coreOperators = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.LogicalOperators = exports4.AssignmentOperators = exports4.BinaryOperators = void 0;
          exports4.BinaryOperators = ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "&", "|", "^", "in", "instanceof"];
          exports4.AssignmentOperators = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="];
          exports4.LogicalOperators = ["||", "&&"];
        });
        var shared = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          function default_1(fork2) {
            var types2 = fork2.use(types_1.default);
            var Type = types2.Type;
            var builtin2 = types2.builtInTypes;
            var isNumber2 = builtin2.number;
            function geq(than) {
              return Type.from(function(value) {
                return isNumber2.check(value) && value >= than;
              }, isNumber2 + " >= " + than);
            }
            var defaults = {
              "null": function _null() {
                return null;
              },
              "emptyArray": function emptyArray() {
                return [];
              },
              "false": function _false() {
                return false;
              },
              "true": function _true() {
                return true;
              },
              "undefined": function undefined$1() {
              },
              "use strict": function useStrict() {
                return "use strict";
              }
            };
            var naiveIsPrimitive = Type.or(builtin2.string, builtin2.number, builtin2.boolean, builtin2.null, builtin2.undefined);
            var isPrimitive2 = Type.from(function(value) {
              if (value === null)
                return true;
              var type2 = typeof value;
              if (type2 === "object" || type2 === "function") {
                return false;
              }
              return true;
            }, naiveIsPrimitive.toString());
            return {geq, defaults, isPrimitive: isPrimitive2};
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var core = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            var types2 = fork2.use(types_1.default);
            var Type = types2.Type;
            var def = Type.def;
            var or2 = Type.or;
            var shared2 = fork2.use(shared_1.default);
            var defaults = shared2.defaults;
            var geq = shared2.geq;
            def("Printable").field("loc", or2(def("SourceLocation"), null), defaults["null"], true);
            def("Node").bases("Printable").field("type", String).field("comments", or2([def("Comment")], null), defaults["null"], true);
            def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or2(String, null), defaults["null"]);
            def("Position").field("line", geq(1)).field("column", geq(0));
            def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or2(String, null), defaults["null"]);
            def("Program").bases("Node").build("body").field("body", [def("Statement")]);
            def("Function").bases("Node").field("id", or2(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]);
            def("Statement").bases("Node");
            def("EmptyStatement").bases("Statement").build();
            def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
            def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
            def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or2(def("Statement"), null), defaults["null"]);
            def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
            def("BreakStatement").bases("Statement").build("label").field("label", or2(def("Identifier"), null), defaults["null"]);
            def("ContinueStatement").bases("Statement").build("label").field("label", or2(def("Identifier"), null), defaults["null"]);
            def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
            def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults["false"]);
            def("ReturnStatement").bases("Statement").build("argument").field("argument", or2(def("Expression"), null));
            def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
            def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or2(def("CatchClause"), null), function() {
              return this.handlers && this.handlers[0] || null;
            }).field("handlers", [def("CatchClause")], function() {
              return this.handler ? [this.handler] : [];
            }, true).field("guardedHandlers", [def("CatchClause")], defaults.emptyArray).field("finalizer", or2(def("BlockStatement"), null), defaults["null"]);
            def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or2(def("Expression"), null), defaults["null"]).field("body", def("BlockStatement"));
            def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
            def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
            def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or2(def("VariableDeclaration"), def("Expression"), null)).field("test", or2(def("Expression"), null)).field("update", or2(def("Expression"), null)).field("body", def("Statement"));
            def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or2(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
            def("DebuggerStatement").bases("Statement").build();
            def("Declaration").bases("Statement");
            def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
            def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
            def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or2("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
            def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or2(def("Expression"), null), defaults["null"]);
            def("Expression").bases("Node");
            def("ThisExpression").bases("Expression").build();
            def("ArrayExpression").bases("Expression").build("elements").field("elements", [or2(def("Expression"), null)]);
            def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
            def("Property").bases("Node").build("kind", "key", "value").field("kind", or2("init", "get", "set")).field("key", or2(def("Literal"), def("Identifier"))).field("value", def("Expression"));
            def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
            var UnaryOperator = or2("-", "+", "!", "~", "typeof", "void", "delete");
            def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults["true"]);
            var BinaryOperator = or2.apply(void 0, coreOperators.BinaryOperators);
            def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
            var AssignmentOperator = or2.apply(void 0, coreOperators.AssignmentOperators);
            def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or2(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
            var UpdateOperator = or2("++", "--");
            def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
            var LogicalOperator = or2.apply(void 0, coreOperators.LogicalOperators);
            def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
            def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
            def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
            def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
            def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or2(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
              var type2 = this.property.type;
              if (type2 === "Literal" || type2 === "MemberExpression" || type2 === "BinaryExpression") {
                return true;
              }
              return false;
            });
            def("Pattern").bases("Node");
            def("SwitchCase").bases("Node").build("test", "consequent").field("test", or2(def("Expression"), null)).field("consequent", [def("Statement")]);
            def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults["false"]);
            def("Literal").bases("Expression").build("value").field("value", or2(String, Boolean, null, Number, RegExp)).field("regex", or2({pattern: String, flags: String}, null), function() {
              if (this.value instanceof RegExp) {
                var flags = "";
                if (this.value.ignoreCase)
                  flags += "i";
                if (this.value.multiline)
                  flags += "m";
                if (this.value.global)
                  flags += "g";
                return {pattern: this.value.source, flags};
              }
              return null;
            });
            def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults["true"]).field("trailing", Boolean, defaults["false"]);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var es6 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var core_1 = tslib_1.__importDefault(core);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(core_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var defaults = fork2.use(shared_1.default).defaults;
            def("Function").field("generator", Boolean, defaults["false"]).field("expression", Boolean, defaults["false"]).field("defaults", [or2(def("Expression"), null)], defaults.emptyArray).field("rest", or2(def("Identifier"), null), defaults["null"]);
            def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field("typeAnnotation", or2(def("TypeAnnotation"), def("TSTypeAnnotation"), null), defaults["null"]);
            def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
            def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or2(def("Identifier"), null));
            def("FunctionExpression").build("id", "params", "body", "generator", "expression");
            def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults["null"]).field("body", or2(def("BlockStatement"), def("Expression"))).field("generator", false, defaults["false"]);
            def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or2(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement"));
            def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or2(def("Expression"), null)).field("delegate", Boolean, defaults["false"]);
            def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or2(def("Expression"), null));
            def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or2(def("Expression"), null));
            def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
            def("Property").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("value", or2(def("Expression"), def("Pattern"))).field("method", Boolean, defaults["false"]).field("shorthand", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]);
            def("ObjectProperty").field("shorthand", Boolean, defaults["false"]);
            def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults["false"]);
            def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or2(def("PropertyPattern"), def("Property"))]);
            def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or2(def("Pattern"), null)]);
            def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
            def("ArrayExpression").field("elements", [or2(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
            def("NewExpression").field("arguments", [or2(def("Expression"), def("SpreadElement"))]);
            def("CallExpression").field("arguments", [or2(def("Expression"), def("SpreadElement"))]);
            def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
            def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or2("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]);
            var ClassBodyElement = or2(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
            def("ClassProperty").bases("Declaration").build("key").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults["false"]);
            def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
            def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
            def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or2(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or2(def("Expression"), null), defaults["null"]);
            def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or2(def("Identifier"), null), defaults["null"]).field("body", def("ClassBody")).field("superClass", or2(def("Expression"), null), defaults["null"]);
            def("Super").bases("Expression").build();
            def("Specifier").bases("Node");
            def("ModuleSpecifier").bases("Specifier").field("local", or2(def("Identifier"), null), defaults["null"]).field("id", or2(def("Identifier"), null), defaults["null"]).field("name", or2(def("Identifier"), null), defaults["null"]);
            def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
            def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
            def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
            def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or2(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults.emptyArray).field("source", def("Literal")).field("importKind", or2("value", "type"), function() {
              return "value";
            });
            def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or2(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults.emptyArray).field("source", or2(def("Literal"), null), defaults["null"]);
            def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
            def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or2(def("Declaration"), def("Expression")));
            def("ExportAllDeclaration").bases("Declaration").build("source").field("source", def("Literal"));
            def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
            def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
            def("TemplateElement").bases("Node").build("value", "tail").field("value", {"cooked": String, "raw": String}).field("tail", Boolean);
            def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var es2016 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es6_1 = tslib_1.__importDefault(es6);
          var types_1 = tslib_1.__importDefault(types$4);
          function default_1(fork2) {
            fork2.use(es6_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var BinaryOperator = or2.apply(void 0, tslib_1.__spreadArrays(coreOperators.BinaryOperators, ["**"]));
            def("BinaryExpression").field("operator", BinaryOperator);
            var AssignmentOperator = or2.apply(void 0, tslib_1.__spreadArrays(coreOperators.AssignmentOperators, ["**="]));
            def("AssignmentExpression").field("operator", AssignmentOperator);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var es2017$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es2016_1 = tslib_1.__importDefault(es2016);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es2016_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var defaults = fork2.use(shared_1.default).defaults;
            def("Function").field("async", Boolean, defaults["false"]);
            def("AwaitExpression").bases("Expression").build("argument").field("argument", def("Expression"));
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var es2018 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es2017_1 = tslib_1.__importDefault(es2017$1);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es2017_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var defaults = fork2.use(shared_1.default).defaults;
            def("ForOfStatement").field("await", Boolean, defaults["false"]);
            def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
            def("ObjectExpression").field("properties", [or2(def("Property"), def("SpreadProperty"), def("SpreadElement"))]);
            def("TemplateElement").field("value", {"cooked": or2(String, null), "raw": String});
            def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
            def("ObjectPattern").field("properties", [or2(def("PropertyPattern"), def("Property"), def("RestElement"), def("SpreadPropertyPattern"))]);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var es2019 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es2018_1 = tslib_1.__importDefault(es2018);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es2018_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var defaults = fork2.use(shared_1.default).defaults;
            def("CatchClause").field("param", or2(def("Pattern"), null), defaults["null"]);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var es2020$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es2019_1 = tslib_1.__importDefault(es2019);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es2019_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var shared2 = fork2.use(shared_1.default);
            var defaults = shared2.defaults;
            def("ImportExpression").bases("Expression").build("source").field("source", def("Expression"));
            def("ExportAllDeclaration").build("source", "exported").field("source", def("Literal")).field("exported", or2(def("Identifier"), null));
            def("ChainElement").bases("Node").field("optional", Boolean, defaults["false"]);
            def("CallExpression").bases("Expression", "ChainElement");
            def("MemberExpression").bases("Expression", "ChainElement");
            def("ChainExpression").bases("Expression").build("expression").field("expression", def("ChainElement"));
            def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults["true"]);
            def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults["true"]);
            var LogicalOperator = or2.apply(void 0, tslib_1.__spreadArrays(coreOperators.LogicalOperators, ["??"]));
            def("LogicalExpression").field("operator", LogicalOperator);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var jsx$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es2020_1 = tslib_1.__importDefault(es2020$1);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es2020_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var defaults = fork2.use(shared_1.default).defaults;
            def("JSXAttribute").bases("Node").build("name", "value").field("name", or2(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or2(def("Literal"), def("JSXExpressionContainer"), def("JSXElement"), def("JSXFragment"), null), defaults["null"]);
            def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
            def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
            def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or2(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults.false);
            var JSXElementName = or2(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
            def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
            var JSXAttributes = [or2(def("JSXAttribute"), def("JSXSpreadAttribute"))];
            def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or2(def("Expression"), def("JSXEmptyExpression")));
            var JSXChildren = [or2(def("JSXText"), def("JSXExpressionContainer"), def("JSXSpreadChild"), def("JSXElement"), def("JSXFragment"), def("Literal"))];
            def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or2(def("JSXClosingElement"), null), defaults["null"]).field("children", JSXChildren, defaults.emptyArray).field("name", JSXElementName, function() {
              return this.openingElement.name;
            }, true).field("selfClosing", Boolean, function() {
              return this.openingElement.selfClosing;
            }, true).field("attributes", JSXAttributes, function() {
              return this.openingElement.attributes;
            }, true);
            def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults.emptyArray).field("selfClosing", Boolean, defaults["false"]);
            def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
            def("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def("JSXOpeningFragment")).field("closingFragment", def("JSXClosingFragment")).field("children", JSXChildren, defaults.emptyArray);
            def("JSXOpeningFragment").bases("Node").build();
            def("JSXClosingFragment").bases("Node").build();
            def("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
              return this.value;
            });
            def("JSXEmptyExpression").bases("Node").build();
            def("JSXSpreadChild").bases("Node").build("expression").field("expression", def("Expression"));
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var esProposals = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          var es2020_1 = tslib_1.__importDefault(es2020$1);
          function default_1(fork2) {
            fork2.use(es2020_1.default);
            var types2 = fork2.use(types_1.default);
            var Type = types2.Type;
            var def = types2.Type.def;
            var or2 = Type.or;
            var shared2 = fork2.use(shared_1.default);
            var defaults = shared2.defaults;
            def("AwaitExpression").build("argument", "all").field("argument", or2(def("Expression"), null)).field("all", Boolean, defaults["false"]);
            def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
            def("Property").field("decorators", or2([def("Decorator")], null), defaults["null"]);
            def("MethodDefinition").field("decorators", or2([def("Decorator")], null), defaults["null"]);
            def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier"));
            def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or2(def("Expression"), null), defaults["null"]);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var typeAnnotations = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var defaults = fork2.use(shared_1.default).defaults;
            var TypeAnnotation = or2(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
            var TypeParamDecl = or2(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
            def("Identifier").field("typeAnnotation", TypeAnnotation, defaults["null"]);
            def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults["null"]);
            def("Function").field("returnType", TypeAnnotation, defaults["null"]).field("typeParameters", TypeParamDecl, defaults["null"]);
            def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or2(def("Expression"), null)).field("static", Boolean, defaults["false"]).field("typeAnnotation", TypeAnnotation, defaults["null"]);
            ["ClassDeclaration", "ClassExpression"].forEach(function(typeName) {
              def(typeName).field("typeParameters", TypeParamDecl, defaults["null"]).field("superTypeParameters", or2(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults["null"]).field("implements", or2([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults.emptyArray);
            });
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var flow$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es_proposals_1 = tslib_1.__importDefault(esProposals);
          var type_annotations_1 = tslib_1.__importDefault(typeAnnotations);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es_proposals_1.default);
            fork2.use(type_annotations_1.default);
            var types2 = fork2.use(types_1.default);
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var defaults = fork2.use(shared_1.default).defaults;
            def("Flow").bases("Node");
            def("FlowType").bases("Flow");
            def("AnyTypeAnnotation").bases("FlowType").build();
            def("EmptyTypeAnnotation").bases("FlowType").build();
            def("MixedTypeAnnotation").bases("FlowType").build();
            def("VoidTypeAnnotation").bases("FlowType").build();
            def("SymbolTypeAnnotation").bases("FlowType").build();
            def("NumberTypeAnnotation").bases("FlowType").build();
            def("BigIntTypeAnnotation").bases("FlowType").build();
            def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
            def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
            def("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String);
            def("StringTypeAnnotation").bases("FlowType").build();
            def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
            def("BooleanTypeAnnotation").bases("FlowType").build();
            def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
            def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
            def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
            def("NullLiteralTypeAnnotation").bases("FlowType").build();
            def("NullTypeAnnotation").bases("FlowType").build();
            def("ThisTypeAnnotation").bases("FlowType").build();
            def("ExistsTypeAnnotation").bases("FlowType").build();
            def("ExistentialTypeParam").bases("FlowType").build();
            def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or2(def("FunctionTypeParam"), null)).field("typeParameters", or2(def("TypeParameterDeclaration"), null));
            def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or2(def("Identifier"), null)).field("typeAnnotation", def("FlowType")).field("optional", Boolean);
            def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType"));
            def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [or2(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))]).field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray).field("inexact", or2(Boolean, void 0), defaults["undefined"]).field("exact", Boolean, defaults["false"]).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults.emptyArray);
            def("Variance").bases("Node").build("kind").field("kind", or2("plus", "minus"));
            var LegacyVariance = or2(def("Variance"), "plus", "minus", null);
            def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or2(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults["null"]);
            def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults["null"]).field("static", Boolean, defaults["false"]);
            def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults["false"]);
            def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or2(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
            def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or2(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or2(def("TypeParameterInstantiation"), null));
            def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or2(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
            def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
            def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
            def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType"));
            def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType"));
            def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
            def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
            def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]);
            def("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults["null"]).field("bound", or2(def("TypeAnnotation"), null), defaults["null"]).field("default", or2(def("FlowType"), null), defaults["null"]);
            def("ClassProperty").field("variance", LegacyVariance, defaults["null"]);
            def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or2(def("Expression"), null), defaults["null"]).field("typeParameters", or2(def("TypeParameterInstantiation"), null), defaults["null"]);
            def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or2([def("InterfaceExtends")], null), defaults["null"]);
            def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterDeclaration"), null), defaults["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
            def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
            def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterInstantiation"), null), defaults["null"]);
            def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterDeclaration"), null)).field("right", def("FlowType"));
            def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
            def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", or2(def("FlowType"), null));
            def("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or2(def("FlowType"), null));
            def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
            def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
            def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
            def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier")).field("predicate", or2(def("FlowPredicate"), null), defaults["null"]);
            def("DeclareClass").bases("InterfaceDeclaration").build("id");
            def("DeclareModule").bases("Statement").build("id", "body").field("id", or2(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
            def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation"));
            def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or2(def("DeclareVariable"), def("DeclareFunction"), def("DeclareClass"), def("FlowType"), def("TypeAlias"), def("DeclareOpaqueType"), def("InterfaceDeclaration"), null)).field("specifiers", [or2(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or2(def("Literal"), null), defaults["null"]);
            def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or2(def("Literal"), null), defaults["null"]);
            def("ImportDeclaration").field("importKind", or2("value", "type", "typeof"), function() {
              return "value";
            });
            def("FlowPredicate").bases("Flow");
            def("InferredPredicate").bases("FlowPredicate").build();
            def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression"));
            def("Function").field("predicate", or2(def("FlowPredicate"), null), defaults["null"]);
            def("CallExpression").field("typeArguments", or2(null, def("TypeParameterInstantiation")), defaults["null"]);
            def("NewExpression").field("typeArguments", or2(null, def("TypeParameterInstantiation")), defaults["null"]);
            def("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def("Identifier")).field("body", or2(def("EnumBooleanBody"), def("EnumNumberBody"), def("EnumStringBody"), def("EnumSymbolBody")));
            def("EnumBooleanBody").build("members", "explicitType").field("members", [def("EnumBooleanMember")]).field("explicitType", Boolean);
            def("EnumNumberBody").build("members", "explicitType").field("members", [def("EnumNumberMember")]).field("explicitType", Boolean);
            def("EnumStringBody").build("members", "explicitType").field("members", or2([def("EnumStringMember")], [def("EnumDefaultedMember")])).field("explicitType", Boolean);
            def("EnumSymbolBody").build("members").field("members", [def("EnumDefaultedMember")]);
            def("EnumBooleanMember").build("id", "init").field("id", def("Identifier")).field("init", or2(def("Literal"), Boolean));
            def("EnumNumberMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
            def("EnumStringMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
            def("EnumDefaultedMember").build("id").field("id", def("Identifier"));
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var esprima$2 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es2020_1 = tslib_1.__importDefault(es2020$1);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es2020_1.default);
            var types2 = fork2.use(types_1.default);
            var defaults = fork2.use(shared_1.default).defaults;
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            def("VariableDeclaration").field("declarations", [or2(def("VariableDeclarator"), def("Identifier"))]);
            def("Property").field("value", or2(def("Expression"), def("Pattern")));
            def("ArrayPattern").field("elements", [or2(def("Pattern"), def("SpreadElement"), null)]);
            def("ObjectPattern").field("properties", [or2(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"))]);
            def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
            def("ExportBatchSpecifier").bases("Specifier").build();
            def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or2(def("Declaration"), def("Expression"), null)).field("specifiers", [or2(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or2(def("Literal"), null), defaults["null"]);
            def("Block").bases("Comment").build("value", "leading", "trailing");
            def("Line").bases("Comment").build("value", "leading", "trailing");
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var babelCore = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var es_proposals_1 = tslib_1.__importDefault(esProposals);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(es_proposals_1.default);
            var types2 = fork2.use(types_1.default);
            var defaults = fork2.use(shared_1.default).defaults;
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            def("Noop").bases("Statement").build();
            def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
            def("BindExpression").bases("Expression").build("object", "callee").field("object", or2(def("Expression"), null)).field("callee", def("Expression"));
            def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
            def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
            def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
            def("CommentBlock").bases("Comment").build("value", "leading", "trailing");
            def("CommentLine").bases("Comment").build("value", "leading", "trailing");
            def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
            def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults["use strict"]);
            def("InterpreterDirective").bases("Node").build("value").field("value", String);
            def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray);
            def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray).field("interpreter", or2(def("InterpreterDirective"), null), defaults["null"]);
            def("StringLiteral").bases("Literal").build("value").field("value", String);
            def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or2(String, null), defaults["null"]).field("extra", {rawValue: Number, raw: String}, function getDefault() {
              return {rawValue: this.value, raw: this.value + ""};
            });
            def("BigIntLiteral").bases("Literal").build("value").field("value", or2(String, Number)).field("extra", {rawValue: String, raw: String}, function getDefault() {
              return {rawValue: String(this.value), raw: this.value + "n"};
            });
            def("NullLiteral").bases("Literal").build().field("value", null, defaults["null"]);
            def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
            def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
              return new RegExp(this.pattern, this.flags);
            });
            var ObjectExpressionProperty = or2(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
            def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
            def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or2("method", "get", "set")).field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("accessibility", or2(def("Literal"), null), defaults["null"]).field("decorators", or2([def("Decorator")], null), defaults["null"]);
            def("ObjectProperty").bases("Node").build("key", "value").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("value", or2(def("Expression"), def("Pattern"))).field("accessibility", or2(def("Literal"), null), defaults["null"]).field("computed", Boolean, defaults["false"]);
            var ClassBodyElement = or2(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"));
            def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
            def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or2(def("Literal"), def("Identifier"), def("Expression")));
            def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName"));
            ["ClassMethod", "ClassPrivateMethod"].forEach(function(typeName) {
              def(typeName).field("kind", or2("get", "set", "method", "constructor"), function() {
                return "method";
              }).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("static", or2(Boolean, null), defaults["null"]).field("abstract", or2(Boolean, null), defaults["null"]).field("access", or2("public", "private", "protected", null), defaults["null"]).field("accessibility", or2("public", "private", "protected", null), defaults["null"]).field("decorators", or2([def("Decorator")], null), defaults["null"]).field("optional", or2(Boolean, null), defaults["null"]);
            });
            var ObjectPatternProperty = or2(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"), def("ObjectProperty"), def("RestProperty"));
            def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or2([def("Decorator")], null), defaults["null"]);
            def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
            def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
            def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or2(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
            def("Import").bases("Expression").build();
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var babel$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var babel_core_1 = tslib_1.__importDefault(babelCore);
          var flow_1 = tslib_1.__importDefault(flow$1);
          function default_1(fork2) {
            fork2.use(babel_core_1.default);
            fork2.use(flow_1.default);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var typescript$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          var babel_core_1 = tslib_1.__importDefault(babelCore);
          var type_annotations_1 = tslib_1.__importDefault(typeAnnotations);
          var types_1 = tslib_1.__importDefault(types$4);
          var shared_1 = tslib_1.__importDefault(shared);
          function default_1(fork2) {
            fork2.use(babel_core_1.default);
            fork2.use(type_annotations_1.default);
            var types2 = fork2.use(types_1.default);
            var n2 = types2.namedTypes;
            var def = types2.Type.def;
            var or2 = types2.Type.or;
            var defaults = fork2.use(shared_1.default).defaults;
            var StringLiteral = types2.Type.from(function(value, deep) {
              if (n2.StringLiteral && n2.StringLiteral.check(value, deep)) {
                return true;
              }
              if (n2.Literal && n2.Literal.check(value, deep) && typeof value.value === "string") {
                return true;
              }
              return false;
            }, "StringLiteral");
            def("TSType").bases("Node");
            var TSEntityName = or2(def("Identifier"), def("TSQualifiedName"));
            def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
            def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or2(def("TSTypeParameterInstantiation"), null), defaults["null"]);
            def("TSHasOptionalTypeParameters").field("typeParameters", or2(def("TSTypeParameterDeclaration"), null, void 0), defaults["null"]);
            def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or2(def("TSTypeAnnotation"), null), defaults["null"]);
            def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
            def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or2({parenthesized: Boolean}, null), defaults["null"]);
            def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression"));
            ["TSAnyKeyword", "TSBigIntKeyword", "TSBooleanKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword", "TSThisType"].forEach(function(keywordType) {
              def(keywordType).bases("TSType").build();
            });
            def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType"));
            def("TSLiteralType").bases("TSType").build("literal").field("literal", or2(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression")));
            ["TSUnionType", "TSIntersectionType"].forEach(function(typeName) {
              def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
            });
            def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType"));
            def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter"));
            def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
            var ParametersType = [or2(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
            ["TSFunctionType", "TSConstructorType"].forEach(function(typeName) {
              def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
            });
            def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("id", or2(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("returnType", or2(def("TSTypeAnnotation"), def("Noop"), null), defaults["null"]);
            def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("params", [def("Pattern")]).field("abstract", Boolean, defaults["false"]).field("accessibility", or2("public", "private", "protected", void 0), defaults["undefined"]).field("static", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("key", or2(def("Identifier"), def("StringLiteral"), def("NumericLiteral"), def("Expression"))).field("kind", or2("get", "set", "method", "constructor"), function getDefault() {
              return "method";
            }).field("access", or2("public", "private", "protected", void 0), defaults["undefined"]).field("decorators", or2([def("Decorator")], null), defaults["null"]).field("returnType", or2(def("TSTypeAnnotation"), def("Noop"), null), defaults["null"]);
            def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or2(Boolean, "+", "-"), defaults["false"]).field("typeParameter", def("TSTypeParameter")).field("optional", or2(Boolean, "+", "-"), defaults["false"]).field("typeAnnotation", or2(def("TSType"), null), defaults["null"]);
            def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or2(def("TSType"), def("TSNamedTupleMember"))]);
            def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults["false"]).field("elementType", def("TSType"));
            def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
            def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
            def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType"));
            def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType"));
            def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or2(def("TSType"), def("TSTypeAnnotation")));
            def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults["false"]);
            def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("readonly", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("initializer", or2(def("Expression"), null), defaults["null"]);
            def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("parameters", ParametersType);
            def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or2(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or2(def("TSTypeAnnotation"), null), defaults["null"]).field("asserts", Boolean, defaults["false"]);
            ["TSCallSignatureDeclaration", "TSConstructSignatureDeclaration"].forEach(function(typeName) {
              def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
            });
            def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or2(def("Identifier"), StringLiteral)).field("initializer", or2(def("Expression"), null), defaults["null"]);
            def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or2(TSEntityName, def("TSImportType")));
            var TSTypeMember = or2(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
            def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
            def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", String).field("constraint", or2(def("TSType"), void 0), defaults["undefined"]).field("default", or2(def("TSType"), void 0), defaults["undefined"]);
            def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or2({parenthesized: Boolean}, null), defaults["null"]);
            def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]);
            def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]);
            def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults["false"]).field("declare", Boolean, defaults["false"]).field("members", [def("TSEnumMember")]).field("initializer", or2(def("Expression"), null), defaults["null"]);
            def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults["false"]).field("typeAnnotation", def("TSType"));
            def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]);
            def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or2(StringLiteral, TSEntityName)).field("declare", Boolean, defaults["false"]).field("global", Boolean, defaults["false"]).field("body", or2(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults["null"]);
            def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or2(TSEntityName, void 0), defaults["undefined"]);
            def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults["false"]).field("moduleReference", or2(TSEntityName, def("TSExternalModuleReference")));
            def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
            def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression"));
            def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier"));
            def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
            def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
            def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults["false"]).field("extends", or2([def("TSExpressionWithTypeArguments")], null), defaults["null"]).field("body", def("TSInterfaceBody"));
            def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or2("public", "private", "protected", void 0), defaults["undefined"]).field("readonly", Boolean, defaults["false"]).field("parameter", or2(def("Identifier"), def("AssignmentPattern")));
            def("ClassProperty").field("access", or2("public", "private", "protected", void 0), defaults["undefined"]);
            def("ClassBody").field("body", [or2(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("TSDeclareMethod"), TSTypeMember)]);
          }
          exports4.default = default_1;
          module3.exports = exports4["default"];
        });
        var namedTypes_1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.namedTypes = void 0;
          (function(namedTypes2) {
          })(exports4.namedTypes || (exports4.namedTypes = {}));
        });
        var main$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.visit = exports4.use = exports4.Type = exports4.someField = exports4.PathVisitor = exports4.Path = exports4.NodePath = exports4.namedTypes = exports4.getSupertypeNames = exports4.getFieldValue = exports4.getFieldNames = exports4.getBuilderName = exports4.finalize = exports4.eachField = exports4.defineMethod = exports4.builtInTypes = exports4.builders = exports4.astNodesAreEquivalent = void 0;
          var fork_1 = tslib_1.__importDefault(fork);
          var core_1 = tslib_1.__importDefault(core);
          var es6_1 = tslib_1.__importDefault(es6);
          var es2016_1 = tslib_1.__importDefault(es2016);
          var es2017_1 = tslib_1.__importDefault(es2017$1);
          var es2018_1 = tslib_1.__importDefault(es2018);
          var es2019_1 = tslib_1.__importDefault(es2019);
          var es2020_1 = tslib_1.__importDefault(es2020$1);
          var jsx_1 = tslib_1.__importDefault(jsx$1);
          var flow_1 = tslib_1.__importDefault(flow$1);
          var esprima_1 = tslib_1.__importDefault(esprima$2);
          var babel_1 = tslib_1.__importDefault(babel$1);
          var typescript_1 = tslib_1.__importDefault(typescript$1);
          var es_proposals_1 = tslib_1.__importDefault(esProposals);
          Object.defineProperty(exports4, "namedTypes", {enumerable: true, get: function get2() {
            return namedTypes_1.namedTypes;
          }});
          var _a = fork_1.default([
            core_1.default,
            es6_1.default,
            es2016_1.default,
            es2017_1.default,
            es2018_1.default,
            es2019_1.default,
            es2020_1.default,
            jsx_1.default,
            flow_1.default,
            esprima_1.default,
            babel_1.default,
            typescript_1.default,
            es_proposals_1.default
          ]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders2 = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n2 = _a.namedTypes, NodePath = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type = _a.Type, use = _a.use, visit = _a.visit;
          exports4.astNodesAreEquivalent = astNodesAreEquivalent;
          exports4.builders = builders2;
          exports4.builtInTypes = builtInTypes;
          exports4.defineMethod = defineMethod;
          exports4.eachField = eachField;
          exports4.finalize = finalize;
          exports4.getBuilderName = getBuilderName;
          exports4.getFieldNames = getFieldNames;
          exports4.getFieldValue = getFieldValue;
          exports4.getSupertypeNames = getSupertypeNames;
          exports4.NodePath = NodePath;
          exports4.Path = Path;
          exports4.PathVisitor = PathVisitor;
          exports4.someField = someField;
          exports4.Type = Type;
          exports4.use = use;
          exports4.visit = visit;
          Object.assign(namedTypes_1.namedTypes, n2);
        });
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var inited = false;
        function init() {
          inited = true;
          var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          }
          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;
        }
        function toByteArray(b64) {
          if (!inited) {
            init();
          }
          var i, j, l, tmp, placeHolders, arr;
          var len = b64.length;
          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
          arr = new Arr(len * 3 / 4 - placeHolders);
          l = placeHolders > 0 ? len - 4 : len;
          var L = 0;
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
            arr[L++] = tmp >> 16 & 255;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
          }
          if (placeHolders === 2) {
            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
            arr[L++] = tmp & 255;
          } else if (placeHolders === 1) {
            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          if (!inited) {
            init();
          }
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3;
          var output = "";
          var parts = [];
          var maxChunkLength = 16383;
          for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            output += lookup[tmp >> 2];
            output += lookup[tmp << 4 & 63];
            output += "==";
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            output += lookup[tmp >> 10];
            output += lookup[tmp >> 4 & 63];
            output += lookup[tmp << 2 & 63];
            output += "=";
          }
          parts.push(output);
          return parts.join("");
        }
        function read(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        }
        function write(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c2;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c2 = Math.pow(2, -e)) < 1) {
              e--;
              c2 *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c2;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c2 >= 2) {
              e++;
              c2 /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c2 - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        }
        var toString = {}.toString;
        var isArray$2 = Array.isArray || function(arr) {
          return toString.call(arr) == "[object Array]";
        };
        /*!
        * The buffer module from node.js, for the browser.
        *
        * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
        * @license  MIT
        */
        var INSPECT_MAX_BYTES = 50;
        Buffer.TYPED_ARRAY_SUPPORT = global2.TYPED_ARRAY_SUPPORT !== void 0 ? global2.TYPED_ARRAY_SUPPORT : true;
        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function createBuffer(that, length) {
          if (kMaxLength() < length) {
            throw new RangeError("Invalid typed array length");
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            that = new Uint8Array(length);
            that.__proto__ = Buffer.prototype;
          } else {
            if (that === null) {
              that = new Buffer(length);
            }
            that.length = length;
          }
          return that;
        }
        function Buffer(arg, encodingOrOffset, length) {
          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
            return new Buffer(arg, encodingOrOffset, length);
          }
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new Error("If encoding is specified then the first argument must be a string");
            }
            return allocUnsafe(this, arg);
          }
          return from(this, arg, encodingOrOffset, length);
        }
        Buffer.poolSize = 8192;
        Buffer._augment = function(arr) {
          arr.__proto__ = Buffer.prototype;
          return arr;
        };
        function from(that, value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('"value" argument must not be a number');
          }
          if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
            return fromArrayBuffer(that, value, encodingOrOffset, length);
          }
          if (typeof value === "string") {
            return fromString(that, value, encodingOrOffset);
          }
          return fromObject(that, value);
        }
        Buffer.from = function(value, encodingOrOffset, length) {
          return from(null, value, encodingOrOffset, length);
        };
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;
        }
        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }
        function alloc(that, size, fill, encoding) {
          assertSize(size);
          if (size <= 0) {
            return createBuffer(that, size);
          }
          if (fill !== void 0) {
            return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
          }
          return createBuffer(that, size);
        }
        Buffer.alloc = function(size, fill, encoding) {
          return alloc(null, size, fill, encoding);
        };
        function allocUnsafe(that, size) {
          assertSize(size);
          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }
          return that;
        }
        Buffer.allocUnsafe = function(size) {
          return allocUnsafe(null, size);
        };
        Buffer.allocUnsafeSlow = function(size) {
          return allocUnsafe(null, size);
        };
        function fromString(that, string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8";
          }
          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }
          var length = byteLength(string, encoding) | 0;
          that = createBuffer(that, length);
          var actual = that.write(string, encoding);
          if (actual !== length) {
            that = that.slice(0, actual);
          }
          return that;
        }
        function fromArrayLike(that, array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          that = createBuffer(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255;
          }
          return that;
        }
        function fromArrayBuffer(that, array, byteOffset, length) {
          array.byteLength;
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError("'offset' is out of bounds");
          }
          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError("'length' is out of bounds");
          }
          if (byteOffset === void 0 && length === void 0) {
            array = new Uint8Array(array);
          } else if (length === void 0) {
            array = new Uint8Array(array, byteOffset);
          } else {
            array = new Uint8Array(array, byteOffset, length);
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            that = array;
            that.__proto__ = Buffer.prototype;
          } else {
            that = fromArrayLike(that, array);
          }
          return that;
        }
        function fromObject(that, obj) {
          if (internalIsBuffer(obj)) {
            var len = checked(obj.length) | 0;
            that = createBuffer(that, len);
            if (that.length === 0) {
              return that;
            }
            obj.copy(that, 0, 0, len);
            return that;
          }
          if (obj) {
            if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
              if (typeof obj.length !== "number" || isnan(obj.length)) {
                return createBuffer(that, 0);
              }
              return fromArrayLike(that, obj);
            }
            if (obj.type === "Buffer" && isArray$2(obj.data)) {
              return fromArrayLike(that, obj.data);
            }
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function checked(length) {
          if (length >= kMaxLength()) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
          }
          return length | 0;
        }
        Buffer.isBuffer = isBuffer;
        function internalIsBuffer(b) {
          return !!(b != null && b._isBuffer);
        }
        Buffer.compare = function compare2(a, b) {
          if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
            throw new TypeError("Arguments must be Buffers");
          }
          if (a === b)
            return 0;
          var x = a.length;
          var y = b.length;
          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }
          if (x < y)
            return -1;
          if (y < x)
            return 1;
          return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        Buffer.concat = function concat(list, length) {
          if (!isArray$2(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          if (list.length === 0) {
            return Buffer.alloc(0);
          }
          var i;
          if (length === void 0) {
            length = 0;
            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }
          var buffer = Buffer.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list.length; ++i) {
            var buf = list[i];
            if (!internalIsBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };
        function byteLength(string, encoding) {
          if (internalIsBuffer(string)) {
            return string.length;
          }
          if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
            return string.byteLength;
          }
          if (typeof string !== "string") {
            string = "" + string;
          }
          var len = string.length;
          if (len === 0)
            return 0;
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
              case void 0:
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase)
                  return utf8ToBytes(string).length;
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer.byteLength = byteLength;
        function slowToString(encoding, start, end) {
          var loweredCase = false;
          if (start === void 0 || start < 0) {
            start = 0;
          }
          if (start > this.length) {
            return "";
          }
          if (end === void 0 || end > this.length) {
            end = this.length;
          }
          if (end <= 0) {
            return "";
          }
          end >>>= 0;
          start >>>= 0;
          if (end <= start) {
            return "";
          }
          if (!encoding)
            encoding = "utf8";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);
              case "ascii":
                return asciiSlice(this, start, end);
              case "latin1":
              case "binary":
                return latin1Slice(this, start, end);
              case "base64":
                return base64Slice(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer.prototype._isBuffer = true;
        function swap$1(b, n2, m) {
          var i = b[n2];
          b[n2] = b[m];
          b[m] = i;
        }
        Buffer.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          }
          for (var i = 0; i < len; i += 2) {
            swap$1(this, i, i + 1);
          }
          return this;
        };
        Buffer.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          }
          for (var i = 0; i < len; i += 4) {
            swap$1(this, i, i + 3);
            swap$1(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          }
          for (var i = 0; i < len; i += 8) {
            swap$1(this, i, i + 7);
            swap$1(this, i + 1, i + 6);
            swap$1(this, i + 2, i + 5);
            swap$1(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer.prototype.toString = function toString2() {
          var length = this.length | 0;
          if (length === 0)
            return "";
          if (arguments.length === 0)
            return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };
        Buffer.prototype.equals = function equals(b) {
          if (!internalIsBuffer(b))
            throw new TypeError("Argument must be a Buffer");
          if (this === b)
            return true;
          return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect2() {
          var str = "";
          var max = INSPECT_MAX_BYTES;
          if (this.length > 0) {
            str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
            if (this.length > max)
              str += " ... ";
          }
          return "<Buffer " + str + ">";
        };
        Buffer.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
          if (!internalIsBuffer(target)) {
            throw new TypeError("Argument must be a Buffer");
          }
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = target ? target.length : 0;
          }
          if (thisStart === void 0) {
            thisStart = 0;
          }
          if (thisEnd === void 0) {
            thisEnd = this.length;
          }
          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError("out of range index");
          }
          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target)
            return 0;
          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);
          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }
          if (x < y)
            return -1;
          if (y < x)
            return 1;
          return 0;
        };
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          if (buffer.length === 0)
            return -1;
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 2147483647) {
            byteOffset = 2147483647;
          } else if (byteOffset < -2147483648) {
            byteOffset = -2147483648;
          }
          byteOffset = +byteOffset;
          if (isNaN(byteOffset)) {
            byteOffset = dir ? 0 : buffer.length - 1;
          }
          if (byteOffset < 0)
            byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir)
              return -1;
            else
              byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir)
              byteOffset = 0;
            else
              return -1;
          }
          if (typeof val === "string") {
            val = Buffer.from(val, encoding);
          }
          if (internalIsBuffer(val)) {
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 255;
            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }
          throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;
          if (encoding !== void 0) {
            encoding = String(encoding).toLowerCase();
            if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read2(buf, i2) {
            if (indexSize === 1) {
              return buf[i2];
            } else {
              return buf.readUInt16BE(i2 * indexSize);
            }
          }
          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1)
                  foundIndex = i;
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1)
                  i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read2(arr, i + j) !== read2(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found)
                return i;
            }
          }
          return -1;
        }
        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          var strLen = string.length;
          if (strLen % 2 !== 0)
            throw new TypeError("Invalid hex string");
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed))
              return i;
            buf[offset + i] = parsed;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer.prototype.write = function write2(string, offset, length, encoding) {
          if (offset === void 0) {
            encoding = "utf8";
            length = this.length;
            offset = 0;
          } else if (length === void 0 && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0;
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === void 0)
                encoding = "utf8";
            } else {
              encoding = length;
              length = void 0;
            }
          } else {
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          }
          var remaining = this.length - offset;
          if (length === void 0 || length > remaining)
            length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError("Attempt to write outside buffer bounds");
          }
          if (!encoding)
            encoding = "utf8";
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);
              case "ascii":
                return asciiWrite(this, string, offset, length);
              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length);
              case "base64":
                return base64Write(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };
        Buffer.prototype.toJSON = function toJSON() {
          return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)};
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return fromByteArray(buf);
          } else {
            return fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1;
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023;
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray(res);
        }
        var MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints);
          }
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
          }
          return res;
        }
        function asciiSlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 127);
          }
          return ret;
        }
        function latin1Slice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0)
            start = 0;
          if (!end || end < 0 || end > len)
            end = len;
          var out = "";
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i]);
          }
          return out;
        }
        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === void 0 ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0)
              start = 0;
          } else if (start > len) {
            start = len;
          }
          if (end < 0) {
            end += len;
            if (end < 0)
              end = 0;
          } else if (end > len) {
            end = len;
          }
          if (end < start)
            end = start;
          var newBuf;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, void 0);
            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }
          return newBuf;
        };
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0)
            throw new RangeError("offset is not uint");
          if (offset + ext > length)
            throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert)
            checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          return val;
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            checkOffset(offset, byteLength2, this.length);
          }
          var val = this[offset + --byteLength2];
          var mul = 1;
          while (byteLength2 > 0 && (mul *= 256)) {
            val += this[offset + --byteLength2] * mul;
          }
          return val;
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 1, this.length);
          return this[offset];
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert)
            checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          mul *= 128;
          if (val >= mul)
            val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert)
            checkOffset(offset, byteLength2, this.length);
          var i = byteLength2;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset + --i] * mul;
          }
          mul *= 128;
          if (val >= mul)
            val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 1, this.length);
          if (!(this[offset] & 128))
            return this[offset];
          return (255 - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 8, this.length);
          return read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert)
            checkOffset(offset, 8, this.length);
          return read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
          if (!internalIsBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var mul = 1;
          var i = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 1, 255, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT)
            value = Math.floor(value);
          this[offset] = value & 255;
          return offset + 1;
        };
        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0)
            value = 65535 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
          }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };
        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0)
            value = 4294967295 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
          }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = 0;
          var mul = 1;
          var sub2 = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
              sub2 = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub2 & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          var sub2 = 0;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
              sub2 = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub2 & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 1, 127, -128);
          if (!Buffer.TYPED_ARRAY_SUPPORT)
            value = Math.floor(value);
          if (value < 0)
            value = 255 + value + 1;
          this[offset] = value & 255;
          return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (value < 0)
            value = 4294967295 + value + 1;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
          if (offset < 0)
            throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4);
          }
          write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8);
          }
          write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.copy = function copy2(target, targetStart, start, end) {
          if (!start)
            start = 0;
          if (!end && end !== 0)
            end = this.length;
          if (targetStart >= target.length)
            targetStart = target.length;
          if (!targetStart)
            targetStart = 0;
          if (end > 0 && end < start)
            end = start;
          if (end === start)
            return 0;
          if (target.length === 0 || this.length === 0)
            return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds");
          }
          if (start < 0 || start >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (end < 0)
            throw new RangeError("sourceEnd out of bounds");
          if (end > this.length)
            end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }
          var len = end - start;
          var i;
          if (this === target && start < targetStart && targetStart < end) {
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
          }
          return len;
        };
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (code < 256) {
                val = code;
              }
            }
            if (encoding !== void 0 && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string");
            }
            if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
          } else if (typeof val === "number") {
            val = val & 255;
          }
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index");
          }
          if (end <= start) {
            return this;
          }
          start = start >>> 0;
          end = end === void 0 ? this.length : end >>> 0;
          if (!val)
            val = 0;
          var i;
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
            var len = bytes.length;
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }
          return this;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
        function base64clean(str) {
          str = stringtrim(str).replace(INVALID_BASE64_RE, "");
          if (str.length < 2)
            return "";
          while (str.length % 4 !== 0) {
            str = str + "=";
          }
          return str;
        }
        function stringtrim(str) {
          if (str.trim)
            return str.trim();
          return str.replace(/^\s+|\s+$/g, "");
        }
        function toHex(n2) {
          if (n2 < 16)
            return "0" + n2.toString(16);
          return n2.toString(16);
        }
        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  continue;
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  continue;
                }
                leadSurrogate = codePoint;
                continue;
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
              }
              codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
            } else if (leadSurrogate) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0)
                break;
              bytes.push(codePoint);
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0)
                break;
              bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0)
                break;
              bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0)
                break;
              bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
            } else {
              throw new Error("Invalid code point");
            }
          }
          return bytes;
        }
        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            byteArray.push(str.charCodeAt(i) & 255);
          }
          return byteArray;
        }
        function utf16leToBytes(str, units) {
          var c2, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0)
              break;
            c2 = str.charCodeAt(i);
            hi = c2 >> 8;
            lo = c2 % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length)
              break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function isnan(val) {
          return val !== val;
        }
        function isBuffer(obj) {
          return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
        }
        function isFastBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
        }
        var inherits;
        if (typeof Object.create === "function") {
          inherits = function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {constructor: {value: ctor, enumerable: false, writable: true, configurable: true}});
          };
        } else {
          inherits = function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function TempCtor2() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
        var inherits$1 = inherits;
        function inspect$1(obj, opts) {
          var ctx = {seen: [], stylize: stylizeNoColor};
          if (arguments.length >= 3)
            ctx.depth = arguments[2];
          if (arguments.length >= 4)
            ctx.colors = arguments[3];
          if (isBoolean2(opts)) {
            ctx.showHidden = opts;
          } else if (opts) {
            _extend(ctx, opts);
          }
          if (isUndefined(ctx.showHidden))
            ctx.showHidden = false;
          if (isUndefined(ctx.depth))
            ctx.depth = 2;
          if (isUndefined(ctx.colors))
            ctx.colors = false;
          if (isUndefined(ctx.customInspect))
            ctx.customInspect = true;
          if (ctx.colors)
            ctx.stylize = stylizeWithColor;
          return formatValue(ctx, obj, ctx.depth);
        }
        inspect$1.colors = {"bold": [1, 22], "italic": [3, 23], "underline": [4, 24], "inverse": [7, 27], "white": [37, 39], "grey": [90, 39], "black": [30, 39], "blue": [34, 39], "cyan": [36, 39], "green": [32, 39], "magenta": [35, 39], "red": [31, 39], "yellow": [33, 39]};
        inspect$1.styles = {
          "special": "cyan",
          "number": "yellow",
          "boolean": "yellow",
          "undefined": "grey",
          "null": "bold",
          "string": "green",
          "date": "magenta",
          "regexp": "red"
        };
        function stylizeWithColor(str, styleType) {
          var style = inspect$1.styles[styleType];
          if (style) {
            return "[" + inspect$1.colors[style][0] + "m" + str + "[" + inspect$1.colors[style][1] + "m";
          } else {
            return str;
          }
        }
        function stylizeNoColor(str, styleType) {
          return str;
        }
        function arrayToHash(array) {
          var hash = {};
          array.forEach(function(val, idx) {
            hash[val] = true;
          });
          return hash;
        }
        function formatValue(ctx, value, recurseTimes) {
          if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== inspect$1 && !(value.constructor && value.constructor.prototype === value)) {
            var ret = value.inspect(recurseTimes, ctx);
            if (!isString(ret)) {
              ret = formatValue(ctx, ret, recurseTimes);
            }
            return ret;
          }
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive;
          }
          var keys = Object.keys(value);
          var visibleKeys = arrayToHash(keys);
          if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value);
          }
          if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
            return formatError$1(value);
          }
          if (keys.length === 0) {
            if (isFunction2(value)) {
              var name = value.name ? ": " + value.name : "";
              return ctx.stylize("[Function" + name + "]", "special");
            }
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), "date");
            }
            if (isError(value)) {
              return formatError$1(value);
            }
          }
          var base = "", array = false, braces = ["{", "}"];
          if (isArray$1(value)) {
            array = true;
            braces = ["[", "]"];
          }
          if (isFunction2(value)) {
            var n2 = value.name ? ": " + value.name : "";
            base = " [Function" + n2 + "]";
          }
          if (isRegExp(value)) {
            base = " " + RegExp.prototype.toString.call(value);
          }
          if (isDate(value)) {
            base = " " + Date.prototype.toUTCString.call(value);
          }
          if (isError(value)) {
            base = " " + formatError$1(value);
          }
          if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1];
          }
          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            } else {
              return ctx.stylize("[Object]", "special");
            }
          }
          ctx.seen.push(value);
          var output;
          if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
          } else {
            output = keys.map(function(key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
          }
          ctx.seen.pop();
          return reduceToSingleString(output, base, braces);
        }
        function formatPrimitive(ctx, value) {
          if (isUndefined(value))
            return ctx.stylize("undefined", "undefined");
          if (isString(value)) {
            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return ctx.stylize(simple, "string");
          }
          if (isNumber$1(value))
            return ctx.stylize("" + value, "number");
          if (isBoolean2(value))
            return ctx.stylize("" + value, "boolean");
          if (isNull(value))
            return ctx.stylize("null", "null");
        }
        function formatError$1(value) {
          return "[" + Error.prototype.toString.call(value) + "]";
        }
        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty$1(value, String(i))) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
            } else {
              output.push("");
            }
          }
          keys.forEach(function(key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
            }
          });
          return output;
        }
        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize("[Getter/Setter]", "special");
            } else {
              str = ctx.stylize("[Getter]", "special");
            }
          } else {
            if (desc.set) {
              str = ctx.stylize("[Setter]", "special");
            }
          }
          if (!hasOwnProperty$1(visibleKeys, key)) {
            name = "[" + key + "]";
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
              } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
              }
              if (str.indexOf("\n") > -1) {
                if (array) {
                  str = str.split("\n").map(function(line) {
                    return "  " + line;
                  }).join("\n").substr(2);
                } else {
                  str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                  }).join("\n");
                }
              }
            } else {
              str = ctx.stylize("[Circular]", "special");
            }
          }
          if (isUndefined(name)) {
            if (array && key.match(/^\d+$/)) {
              return str;
            }
            name = JSON.stringify("" + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name = name.substr(1, name.length - 2);
              name = ctx.stylize(name, "name");
            } else {
              name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
              name = ctx.stylize(name, "string");
            }
          }
          return name + ": " + str;
        }
        function reduceToSingleString(output, base, braces) {
          var length = output.reduce(function(prev, cur) {
            if (cur.indexOf("\n") >= 0)
              ;
            return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          if (length > 60) {
            return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
          }
          return braces[0] + base + " " + output.join(", ") + " " + braces[1];
        }
        function isArray$1(ar) {
          return Array.isArray(ar);
        }
        function isBoolean2(arg) {
          return typeof arg === "boolean";
        }
        function isNull(arg) {
          return arg === null;
        }
        function isNumber$1(arg) {
          return typeof arg === "number";
        }
        function isString(arg) {
          return typeof arg === "string";
        }
        function isUndefined(arg) {
          return arg === void 0;
        }
        function isRegExp(re) {
          return isObject$1(re) && objectToString(re) === "[object RegExp]";
        }
        function isObject$1(arg) {
          return typeof arg === "object" && arg !== null;
        }
        function isDate(d) {
          return isObject$1(d) && objectToString(d) === "[object Date]";
        }
        function isError(e) {
          return isObject$1(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
        }
        function isFunction2(arg) {
          return typeof arg === "function";
        }
        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
        }
        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
        function _extend(origin, add) {
          if (!add || !isObject$1(add))
            return origin;
          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]];
          }
          return origin;
        }
        function hasOwnProperty$1(obj, prop2) {
          return Object.prototype.hasOwnProperty.call(obj, prop2);
        }
        function compare(a, b) {
          if (a === b) {
            return 0;
          }
          var x = a.length;
          var y = b.length;
          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }
          if (x < y) {
            return -1;
          }
          if (y < x) {
            return 1;
          }
          return 0;
        }
        var hasOwn = Object.prototype.hasOwnProperty;
        var objectKeys = Object.keys || function(obj) {
          var keys = [];
          for (var key in obj) {
            if (hasOwn.call(obj, key))
              keys.push(key);
          }
          return keys;
        };
        var pSlice = Array.prototype.slice;
        var _functionsHaveNames;
        function functionsHaveNames() {
          if (typeof _functionsHaveNames !== "undefined") {
            return _functionsHaveNames;
          }
          return _functionsHaveNames = function() {
            return function foo() {
            }.name === "foo";
          }();
        }
        function pToString(obj) {
          return Object.prototype.toString.call(obj);
        }
        function isView(arrbuf) {
          if (isBuffer(arrbuf)) {
            return false;
          }
          if (typeof global2.ArrayBuffer !== "function") {
            return false;
          }
          if (typeof ArrayBuffer.isView === "function") {
            return ArrayBuffer.isView(arrbuf);
          }
          if (!arrbuf) {
            return false;
          }
          if (arrbuf instanceof DataView) {
            return true;
          }
          if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
            return true;
          }
          return false;
        }
        function assert$1(value, message) {
          if (!value)
            fail(value, true, message, "==", ok);
        }
        var regex = /\s*function\s+([^\(\s]*)\s*/;
        function getName$1(func) {
          if (!isFunction2(func)) {
            return;
          }
          if (functionsHaveNames()) {
            return func.name;
          }
          var str = func.toString();
          var match = str.match(regex);
          return match && match[1];
        }
        assert$1.AssertionError = AssertionError;
        function AssertionError(options2) {
          this.name = "AssertionError";
          this.actual = options2.actual;
          this.expected = options2.expected;
          this.operator = options2.operator;
          if (options2.message) {
            this.message = options2.message;
            this.generatedMessage = false;
          } else {
            this.message = getMessage(this);
            this.generatedMessage = true;
          }
          var stackStartFunction = options2.stackStartFunction || fail;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, stackStartFunction);
          } else {
            var err = new Error();
            if (err.stack) {
              var out = err.stack;
              var fn_name = getName$1(stackStartFunction);
              var idx = out.indexOf("\n" + fn_name);
              if (idx >= 0) {
                var next_line = out.indexOf("\n", idx + 1);
                out = out.substring(next_line + 1);
              }
              this.stack = out;
            }
          }
        }
        inherits$1(AssertionError, Error);
        function truncate(s, n2) {
          if (typeof s === "string") {
            return s.length < n2 ? s : s.slice(0, n2);
          } else {
            return s;
          }
        }
        function inspect(something) {
          if (functionsHaveNames() || !isFunction2(something)) {
            return inspect$1(something);
          }
          var rawname = getName$1(something);
          var name = rawname ? ": " + rawname : "";
          return "[Function" + name + "]";
        }
        function getMessage(self2) {
          return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
        }
        function fail(actual, expected, message, operator, stackStartFunction) {
          throw new AssertionError({message, actual, expected, operator, stackStartFunction});
        }
        assert$1.fail = fail;
        function ok(value, message) {
          if (!value)
            fail(value, true, message, "==", ok);
        }
        assert$1.ok = ok;
        assert$1.equal = equal;
        function equal(actual, expected, message) {
          if (actual != expected)
            fail(actual, expected, message, "==", equal);
        }
        assert$1.notEqual = notEqual;
        function notEqual(actual, expected, message) {
          if (actual == expected) {
            fail(actual, expected, message, "!=", notEqual);
          }
        }
        assert$1.deepEqual = deepEqual;
        function deepEqual(actual, expected, message) {
          if (!_deepEqual(actual, expected, false)) {
            fail(actual, expected, message, "deepEqual", deepEqual);
          }
        }
        assert$1.deepStrictEqual = deepStrictEqual;
        function deepStrictEqual(actual, expected, message) {
          if (!_deepEqual(actual, expected, true)) {
            fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
          }
        }
        function _deepEqual(actual, expected, strict, memos) {
          if (actual === expected) {
            return true;
          } else if (isBuffer(actual) && isBuffer(expected)) {
            return compare(actual, expected) === 0;
          } else if (isDate(actual) && isDate(expected)) {
            return actual.getTime() === expected.getTime();
          } else if (isRegExp(actual) && isRegExp(expected)) {
            return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
          } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
            return strict ? actual === expected : actual == expected;
          } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
            return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
          } else if (isBuffer(actual) !== isBuffer(expected)) {
            return false;
          } else {
            memos = memos || {actual: [], expected: []};
            var actualIndex = memos.actual.indexOf(actual);
            if (actualIndex !== -1) {
              if (actualIndex === memos.expected.indexOf(expected)) {
                return true;
              }
            }
            memos.actual.push(actual);
            memos.expected.push(expected);
            return objEquiv(actual, expected, strict, memos);
          }
        }
        function isArguments(object2) {
          return Object.prototype.toString.call(object2) == "[object Arguments]";
        }
        function objEquiv(a, b, strict, actualVisitedObjects) {
          if (a === null || a === void 0 || b === null || b === void 0)
            return false;
          if (isPrimitive(a) || isPrimitive(b))
            return a === b;
          if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
            return false;
          var aIsArgs = isArguments(a);
          var bIsArgs = isArguments(b);
          if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
            return false;
          if (aIsArgs) {
            a = pSlice.call(a);
            b = pSlice.call(b);
            return _deepEqual(a, b, strict);
          }
          var ka = objectKeys(a);
          var kb = objectKeys(b);
          var key, i;
          if (ka.length !== kb.length)
            return false;
          ka.sort();
          kb.sort();
          for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] !== kb[i])
              return false;
          }
          for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
              return false;
          }
          return true;
        }
        assert$1.notDeepEqual = notDeepEqual;
        function notDeepEqual(actual, expected, message) {
          if (_deepEqual(actual, expected, false)) {
            fail(actual, expected, message, "notDeepEqual", notDeepEqual);
          }
        }
        assert$1.notDeepStrictEqual = notDeepStrictEqual;
        function notDeepStrictEqual(actual, expected, message) {
          if (_deepEqual(actual, expected, true)) {
            fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
          }
        }
        assert$1.strictEqual = strictEqual;
        function strictEqual(actual, expected, message) {
          if (actual !== expected) {
            fail(actual, expected, message, "===", strictEqual);
          }
        }
        assert$1.notStrictEqual = notStrictEqual;
        function notStrictEqual(actual, expected, message) {
          if (actual === expected) {
            fail(actual, expected, message, "!==", notStrictEqual);
          }
        }
        function expectedException(actual, expected) {
          if (!actual || !expected) {
            return false;
          }
          if (Object.prototype.toString.call(expected) == "[object RegExp]") {
            return expected.test(actual);
          }
          try {
            if (actual instanceof expected) {
              return true;
            }
          } catch (e) {
          }
          if (Error.isPrototypeOf(expected)) {
            return false;
          }
          return expected.call({}, actual) === true;
        }
        function _tryBlock(block) {
          var error;
          try {
            block();
          } catch (e) {
            error = e;
          }
          return error;
        }
        function _throws(shouldThrow, block, expected, message) {
          var actual;
          if (typeof block !== "function") {
            throw new TypeError('"block" argument must be a function');
          }
          if (typeof expected === "string") {
            message = expected;
            expected = null;
          }
          actual = _tryBlock(block);
          message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
          if (shouldThrow && !actual) {
            fail(actual, expected, "Missing expected exception" + message);
          }
          var userProvidedMessage = typeof message === "string";
          var isUnwantedException = !shouldThrow && isError(actual);
          var isUnexpectedException = !shouldThrow && actual && !expected;
          if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
            fail(actual, expected, "Got unwanted exception" + message);
          }
          if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
            throw actual;
          }
        }
        assert$1.throws = throws;
        function throws(block, error, message) {
          _throws(true, block, error, message);
        }
        assert$1.doesNotThrow = doesNotThrow;
        function doesNotThrow(block, error, message) {
          _throws(false, block, error, message);
        }
        assert$1.ifError = ifError;
        function ifError(err) {
          if (err)
            throw err;
        }
        var assert$2 = /* @__PURE__ */ Object.freeze({__proto__: null, "default": assert$1, AssertionError, fail, ok, assert: ok, equal, notEqual, deepEqual, deepStrictEqual, notDeepEqual, notDeepStrictEqual, strictEqual, notStrictEqual, throws, doesNotThrow, ifError});
        var intToCharMap$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        var encode$3 = function encode$32(number) {
          if (0 <= number && number < intToCharMap$1.length) {
            return intToCharMap$1[number];
          }
          throw new TypeError("Must be between 0 and 63: " + number);
        };
        var decode$1 = function decode$12(charCode) {
          var bigA = 65;
          var bigZ = 90;
          var littleA = 97;
          var littleZ = 122;
          var zero = 48;
          var nine = 57;
          var plus = 43;
          var slash = 47;
          var littleOffset = 26;
          var numberOffset = 52;
          if (bigA <= charCode && charCode <= bigZ) {
            return charCode - bigA;
          }
          if (littleA <= charCode && charCode <= littleZ) {
            return charCode - littleA + littleOffset;
          }
          if (zero <= charCode && charCode <= nine) {
            return charCode - zero + numberOffset;
          }
          if (charCode == plus) {
            return 62;
          }
          if (charCode == slash) {
            return 63;
          }
          return -1;
        };
        var base64$1 = {encode: encode$3, decode: decode$1};
        var VLQ_BASE_SHIFT$1 = 5;
        var VLQ_BASE$1 = 1 << VLQ_BASE_SHIFT$1;
        var VLQ_BASE_MASK$1 = VLQ_BASE$1 - 1;
        var VLQ_CONTINUATION_BIT$1 = VLQ_BASE$1;
        function toVLQSigned$1(aValue) {
          return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
        }
        function fromVLQSigned(aValue) {
          var isNegative = (aValue & 1) === 1;
          var shifted = aValue >> 1;
          return isNegative ? -shifted : shifted;
        }
        var encode$2 = function base64VLQ_encode(aValue) {
          var encoded = "";
          var digit;
          var vlq = toVLQSigned$1(aValue);
          do {
            digit = vlq & VLQ_BASE_MASK$1;
            vlq >>>= VLQ_BASE_SHIFT$1;
            if (vlq > 0) {
              digit |= VLQ_CONTINUATION_BIT$1;
            }
            encoded += base64$1.encode(digit);
          } while (vlq > 0);
          return encoded;
        };
        var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
          var strLen = aStr.length;
          var result = 0;
          var shift = 0;
          var continuation, digit;
          do {
            if (aIndex >= strLen) {
              throw new Error("Expected more digits in base 64 VLQ value.");
            }
            digit = base64$1.decode(aStr.charCodeAt(aIndex++));
            if (digit === -1) {
              throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
            }
            continuation = !!(digit & VLQ_CONTINUATION_BIT$1);
            digit &= VLQ_BASE_MASK$1;
            result = result + (digit << shift);
            shift += VLQ_BASE_SHIFT$1;
          } while (continuation);
          aOutParam.value = fromVLQSigned(result);
          aOutParam.rest = aIndex;
        };
        var base64Vlq$1 = {encode: encode$2, decode};
        var util$3 = createCommonjsModule(function(module3, exports4) {
          function getArg(aArgs, aName, aDefaultValue) {
            if (aName in aArgs) {
              return aArgs[aName];
            } else if (arguments.length === 3) {
              return aDefaultValue;
            } else {
              throw new Error('"' + aName + '" is a required argument.');
            }
          }
          exports4.getArg = getArg;
          var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
          var dataUrlRegexp = /^data:.+\,.+$/;
          function urlParse(aUrl) {
            var match = aUrl.match(urlRegexp);
            if (!match) {
              return null;
            }
            return {scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5]};
          }
          exports4.urlParse = urlParse;
          function urlGenerate(aParsedUrl) {
            var url = "";
            if (aParsedUrl.scheme) {
              url += aParsedUrl.scheme + ":";
            }
            url += "//";
            if (aParsedUrl.auth) {
              url += aParsedUrl.auth + "@";
            }
            if (aParsedUrl.host) {
              url += aParsedUrl.host;
            }
            if (aParsedUrl.port) {
              url += ":" + aParsedUrl.port;
            }
            if (aParsedUrl.path) {
              url += aParsedUrl.path;
            }
            return url;
          }
          exports4.urlGenerate = urlGenerate;
          function normalize3(aPath) {
            var path2 = aPath;
            var url = urlParse(aPath);
            if (url) {
              if (!url.path) {
                return aPath;
              }
              path2 = url.path;
            }
            var isAbsolute = exports4.isAbsolute(path2);
            var parts = path2.split(/\/+/);
            for (var part2, up = 0, i = parts.length - 1; i >= 0; i--) {
              part2 = parts[i];
              if (part2 === ".") {
                parts.splice(i, 1);
              } else if (part2 === "..") {
                up++;
              } else if (up > 0) {
                if (part2 === "") {
                  parts.splice(i + 1, up);
                  up = 0;
                } else {
                  parts.splice(i, 2);
                  up--;
                }
              }
            }
            path2 = parts.join("/");
            if (path2 === "") {
              path2 = isAbsolute ? "/" : ".";
            }
            if (url) {
              url.path = path2;
              return urlGenerate(url);
            }
            return path2;
          }
          exports4.normalize = normalize3;
          function join(aRoot, aPath) {
            if (aRoot === "") {
              aRoot = ".";
            }
            if (aPath === "") {
              aPath = ".";
            }
            var aPathUrl = urlParse(aPath);
            var aRootUrl = urlParse(aRoot);
            if (aRootUrl) {
              aRoot = aRootUrl.path || "/";
            }
            if (aPathUrl && !aPathUrl.scheme) {
              if (aRootUrl) {
                aPathUrl.scheme = aRootUrl.scheme;
              }
              return urlGenerate(aPathUrl);
            }
            if (aPathUrl || aPath.match(dataUrlRegexp)) {
              return aPath;
            }
            if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
              aRootUrl.host = aPath;
              return urlGenerate(aRootUrl);
            }
            var joined = aPath.charAt(0) === "/" ? aPath : normalize3(aRoot.replace(/\/+$/, "") + "/" + aPath);
            if (aRootUrl) {
              aRootUrl.path = joined;
              return urlGenerate(aRootUrl);
            }
            return joined;
          }
          exports4.join = join;
          exports4.isAbsolute = function(aPath) {
            return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
          };
          function relative(aRoot, aPath) {
            if (aRoot === "") {
              aRoot = ".";
            }
            aRoot = aRoot.replace(/\/$/, "");
            var level = 0;
            while (aPath.indexOf(aRoot + "/") !== 0) {
              var index = aRoot.lastIndexOf("/");
              if (index < 0) {
                return aPath;
              }
              aRoot = aRoot.slice(0, index);
              if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                return aPath;
              }
              ++level;
            }
            return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
          }
          exports4.relative = relative;
          var supportsNullProto = function() {
            var obj = Object.create(null);
            return !("__proto__" in obj);
          }();
          function identity(s) {
            return s;
          }
          function toSetString(aStr) {
            if (isProtoString(aStr)) {
              return "$" + aStr;
            }
            return aStr;
          }
          exports4.toSetString = supportsNullProto ? identity : toSetString;
          function fromSetString(aStr) {
            if (isProtoString(aStr)) {
              return aStr.slice(1);
            }
            return aStr;
          }
          exports4.fromSetString = supportsNullProto ? identity : fromSetString;
          function isProtoString(s) {
            if (!s) {
              return false;
            }
            var length = s.length;
            if (length < 9) {
              return false;
            }
            if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
              return false;
            }
            for (var i = length - 10; i >= 0; i--) {
              if (s.charCodeAt(i) !== 36) {
                return false;
              }
            }
            return true;
          }
          function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
            var cmp = strcmp(mappingA.source, mappingB.source);
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0 || onlyCompareOriginal) {
              return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
              return cmp;
            }
            return strcmp(mappingA.name, mappingB.name);
          }
          exports4.compareByOriginalPositions = compareByOriginalPositions;
          function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0 || onlyCompareGenerated) {
              return cmp;
            }
            cmp = strcmp(mappingA.source, mappingB.source);
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0) {
              return cmp;
            }
            return strcmp(mappingA.name, mappingB.name);
          }
          exports4.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
          function strcmp(aStr1, aStr2) {
            if (aStr1 === aStr2) {
              return 0;
            }
            if (aStr1 === null) {
              return 1;
            }
            if (aStr2 === null) {
              return -1;
            }
            if (aStr1 > aStr2) {
              return 1;
            }
            return -1;
          }
          function compareByGeneratedPositionsInflated(mappingA, mappingB) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = strcmp(mappingA.source, mappingB.source);
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0) {
              return cmp;
            }
            return strcmp(mappingA.name, mappingB.name);
          }
          exports4.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
          function parseSourceMapInput(str) {
            return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
          }
          exports4.parseSourceMapInput = parseSourceMapInput;
          function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
            sourceURL = sourceURL || "";
            if (sourceRoot) {
              if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
                sourceRoot += "/";
              }
              sourceURL = sourceRoot + sourceURL;
            }
            if (sourceMapURL) {
              var parsed = urlParse(sourceMapURL);
              if (!parsed) {
                throw new Error("sourceMapURL could not be parsed");
              }
              if (parsed.path) {
                var index = parsed.path.lastIndexOf("/");
                if (index >= 0) {
                  parsed.path = parsed.path.substring(0, index + 1);
                }
              }
              sourceURL = join(urlGenerate(parsed), sourceURL);
            }
            return normalize3(sourceURL);
          }
          exports4.computeSourceURL = computeSourceURL;
        });
        var has = Object.prototype.hasOwnProperty;
        var hasNativeMap = typeof Map !== "undefined";
        function ArraySet$4() {
          this._array = [];
          this._set = hasNativeMap ? new Map() : Object.create(null);
        }
        ArraySet$4.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
          var set2 = new ArraySet$4();
          for (var i = 0, len = aArray.length; i < len; i++) {
            set2.add(aArray[i], aAllowDuplicates);
          }
          return set2;
        };
        ArraySet$4.prototype.size = function ArraySet_size() {
          return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        };
        ArraySet$4.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
          var sStr = hasNativeMap ? aStr : util$3.toSetString(aStr);
          var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
          var idx = this._array.length;
          if (!isDuplicate || aAllowDuplicates) {
            this._array.push(aStr);
          }
          if (!isDuplicate) {
            if (hasNativeMap) {
              this._set.set(aStr, idx);
            } else {
              this._set[sStr] = idx;
            }
          }
        };
        ArraySet$4.prototype.has = function ArraySet_has(aStr) {
          if (hasNativeMap) {
            return this._set.has(aStr);
          } else {
            var sStr = util$3.toSetString(aStr);
            return has.call(this._set, sStr);
          }
        };
        ArraySet$4.prototype.indexOf = function ArraySet_indexOf(aStr) {
          if (hasNativeMap) {
            var idx = this._set.get(aStr);
            if (idx >= 0) {
              return idx;
            }
          } else {
            var sStr = util$3.toSetString(aStr);
            if (has.call(this._set, sStr)) {
              return this._set[sStr];
            }
          }
          throw new Error('"' + aStr + '" is not in the set.');
        };
        ArraySet$4.prototype.at = function ArraySet_at(aIdx) {
          if (aIdx >= 0 && aIdx < this._array.length) {
            return this._array[aIdx];
          }
          throw new Error("No element indexed by " + aIdx);
        };
        ArraySet$4.prototype.toArray = function ArraySet_toArray() {
          return this._array.slice();
        };
        var ArraySet_1$1 = ArraySet$4;
        var arraySet$1 = {ArraySet: ArraySet_1$1};
        function generatedPositionAfter$1(mappingA, mappingB) {
          var lineA = mappingA.generatedLine;
          var lineB = mappingB.generatedLine;
          var columnA = mappingA.generatedColumn;
          var columnB = mappingB.generatedColumn;
          return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
        }
        function MappingList$3() {
          this._array = [];
          this._sorted = true;
          this._last = {generatedLine: -1, generatedColumn: 0};
        }
        MappingList$3.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        };
        MappingList$3.prototype.add = function MappingList_add(aMapping) {
          if (generatedPositionAfter$1(this._last, aMapping)) {
            this._last = aMapping;
            this._array.push(aMapping);
          } else {
            this._sorted = false;
            this._array.push(aMapping);
          }
        };
        MappingList$3.prototype.toArray = function MappingList_toArray() {
          if (!this._sorted) {
            this._array.sort(util$3.compareByGeneratedPositionsInflated);
            this._sorted = true;
          }
          return this._array;
        };
        var MappingList_1$1 = MappingList$3;
        var mappingList$1 = {MappingList: MappingList_1$1};
        var ArraySet$3 = arraySet$1.ArraySet;
        var MappingList$2 = mappingList$1.MappingList;
        function SourceMapGenerator$4(aArgs) {
          if (!aArgs) {
            aArgs = {};
          }
          this._file = util$3.getArg(aArgs, "file", null);
          this._sourceRoot = util$3.getArg(aArgs, "sourceRoot", null);
          this._skipValidation = util$3.getArg(aArgs, "skipValidation", false);
          this._sources = new ArraySet$3();
          this._names = new ArraySet$3();
          this._mappings = new MappingList$2();
          this._sourcesContents = null;
        }
        SourceMapGenerator$4.prototype._version = 3;
        SourceMapGenerator$4.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator$4({file: aSourceMapConsumer.file, sourceRoot});
          aSourceMapConsumer.eachMapping(function(mapping2) {
            var newMapping = {generated: {line: mapping2.generatedLine, column: mapping2.generatedColumn}};
            if (mapping2.source != null) {
              newMapping.source = mapping2.source;
              if (sourceRoot != null) {
                newMapping.source = util$3.relative(sourceRoot, newMapping.source);
              }
              newMapping.original = {line: mapping2.originalLine, column: mapping2.originalColumn};
              if (mapping2.name != null) {
                newMapping.name = mapping2.name;
              }
            }
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var sourceRelative = sourceFile;
            if (sourceRoot !== null) {
              sourceRelative = util$3.relative(sourceRoot, sourceFile);
            }
            if (!generator._sources.has(sourceRelative)) {
              generator._sources.add(sourceRelative);
            }
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
        SourceMapGenerator$4.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
          var generated = util$3.getArg(aArgs, "generated");
          var original = util$3.getArg(aArgs, "original", null);
          var source = util$3.getArg(aArgs, "source", null);
          var name = util$3.getArg(aArgs, "name", null);
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
          if (source != null) {
            source = String(source);
            if (!this._sources.has(source)) {
              this._sources.add(source);
            }
          }
          if (name != null) {
            name = String(name);
            if (!this._names.has(name)) {
              this._names.add(name);
            }
          }
          this._mappings.add({generatedLine: generated.line, generatedColumn: generated.column, originalLine: original != null && original.line, originalColumn: original != null && original.column, source, name});
        };
        SourceMapGenerator$4.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util$3.relative(this._sourceRoot, source);
          }
          if (aSourceContent != null) {
            if (!this._sourcesContents) {
              this._sourcesContents = Object.create(null);
            }
            this._sourcesContents[util$3.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            delete this._sourcesContents[util$3.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
        SourceMapGenerator$4.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          if (sourceRoot != null) {
            sourceFile = util$3.relative(sourceRoot, sourceFile);
          }
          var newSources = new ArraySet$3();
          var newNames = new ArraySet$3();
          this._mappings.unsortedForEach(function(mapping2) {
            if (mapping2.source === sourceFile && mapping2.originalLine != null) {
              var original = aSourceMapConsumer.originalPositionFor({line: mapping2.originalLine, column: mapping2.originalColumn});
              if (original.source != null) {
                mapping2.source = original.source;
                if (aSourceMapPath != null) {
                  mapping2.source = util$3.join(aSourceMapPath, mapping2.source);
                }
                if (sourceRoot != null) {
                  mapping2.source = util$3.relative(sourceRoot, mapping2.source);
                }
                mapping2.originalLine = original.line;
                mapping2.originalColumn = original.column;
                if (original.name != null) {
                  mapping2.name = original.name;
                }
              }
            }
            var source = mapping2.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
            var name = mapping2.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
          }, this);
          this._sources = newSources;
          this._names = newNames;
          aSourceMapConsumer.sources.forEach(function(sourceFile2) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile2 = util$3.join(aSourceMapPath, sourceFile2);
              }
              if (sourceRoot != null) {
                sourceFile2 = util$3.relative(sourceRoot, sourceFile2);
              }
              this.setSourceContent(sourceFile2, content);
            }
          }, this);
        };
        SourceMapGenerator$4.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
          if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
            throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
          }
          if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
            return;
          } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
            return;
          } else {
            throw new Error("Invalid mapping: " + JSON.stringify({generated: aGenerated, source: aSource, original: aOriginal, name: aName}));
          }
        };
        SourceMapGenerator$4.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = "";
          var next;
          var mapping2;
          var nameIdx;
          var sourceIdx;
          var mappings = this._mappings.toArray();
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping2 = mappings[i];
            next = "";
            if (mapping2.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping2.generatedLine !== previousGeneratedLine) {
                next += ";";
                previousGeneratedLine++;
              }
            } else {
              if (i > 0) {
                if (!util$3.compareByGeneratedPositionsInflated(mapping2, mappings[i - 1])) {
                  continue;
                }
                next += ",";
              }
            }
            next += base64Vlq$1.encode(mapping2.generatedColumn - previousGeneratedColumn);
            previousGeneratedColumn = mapping2.generatedColumn;
            if (mapping2.source != null) {
              sourceIdx = this._sources.indexOf(mapping2.source);
              next += base64Vlq$1.encode(sourceIdx - previousSource);
              previousSource = sourceIdx;
              next += base64Vlq$1.encode(mapping2.originalLine - 1 - previousOriginalLine);
              previousOriginalLine = mapping2.originalLine - 1;
              next += base64Vlq$1.encode(mapping2.originalColumn - previousOriginalColumn);
              previousOriginalColumn = mapping2.originalColumn;
              if (mapping2.name != null) {
                nameIdx = this._names.indexOf(mapping2.name);
                next += base64Vlq$1.encode(nameIdx - previousName);
                previousName = nameIdx;
              }
            }
            result += next;
          }
          return result;
        };
        SourceMapGenerator$4.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function(source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util$3.relative(aSourceRoot, source);
            }
            var key = util$3.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
          }, this);
        };
        SourceMapGenerator$4.prototype.toJSON = function SourceMapGenerator_toJSON() {
          var map = {version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings()};
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
          }
          return map;
        };
        SourceMapGenerator$4.prototype.toString = function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
        var SourceMapGenerator_1$1 = SourceMapGenerator$4;
        var sourceMapGenerator$1 = {SourceMapGenerator: SourceMapGenerator_1$1};
        var binarySearch = createCommonjsModule(function(module3, exports4) {
          exports4.GREATEST_LOWER_BOUND = 1;
          exports4.LEAST_UPPER_BOUND = 2;
          function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
            var mid = Math.floor((aHigh - aLow) / 2) + aLow;
            var cmp = aCompare(aNeedle, aHaystack[mid], true);
            if (cmp === 0) {
              return mid;
            } else if (cmp > 0) {
              if (aHigh - mid > 1) {
                return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
              }
              if (aBias == exports4.LEAST_UPPER_BOUND) {
                return aHigh < aHaystack.length ? aHigh : -1;
              } else {
                return mid;
              }
            } else {
              if (mid - aLow > 1) {
                return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
              }
              if (aBias == exports4.LEAST_UPPER_BOUND) {
                return mid;
              } else {
                return aLow < 0 ? -1 : aLow;
              }
            }
          }
          exports4.search = function search(aNeedle, aHaystack, aCompare, aBias) {
            if (aHaystack.length === 0) {
              return -1;
            }
            var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports4.GREATEST_LOWER_BOUND);
            if (index < 0) {
              return -1;
            }
            while (index - 1 >= 0) {
              if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                break;
              }
              --index;
            }
            return index;
          };
        });
        function swap(ary, x, y) {
          var temp = ary[x];
          ary[x] = ary[y];
          ary[y] = temp;
        }
        function randomIntInRange(low, high) {
          return Math.round(low + Math.random() * (high - low));
        }
        function doQuickSort(ary, comparator, p, r) {
          if (p < r) {
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;
            swap(ary, pivotIndex, r);
            var pivot = ary[r];
            for (var j = p; j < r; j++) {
              if (comparator(ary[j], pivot) <= 0) {
                i += 1;
                swap(ary, i, j);
              }
            }
            swap(ary, i + 1, j);
            var q = i + 1;
            doQuickSort(ary, comparator, p, q - 1);
            doQuickSort(ary, comparator, q + 1, r);
          }
        }
        var quickSort_1 = function quickSort_12(ary, comparator) {
          doQuickSort(ary, comparator, 0, ary.length - 1);
        };
        var quickSort$1 = {quickSort: quickSort_1};
        var ArraySet$2 = arraySet$1.ArraySet;
        var quickSort = quickSort$1.quickSort;
        function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
          var sourceMap2 = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap2 = util$3.parseSourceMapInput(aSourceMap);
          }
          return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
        }
        SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
          return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
        };
        SourceMapConsumer$1.prototype._version = 3;
        SourceMapConsumer$1.prototype.__generatedMappings = null;
        Object.defineProperty(SourceMapConsumer$1.prototype, "_generatedMappings", {configurable: true, enumerable: true, get: function get2() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }});
        SourceMapConsumer$1.prototype.__originalMappings = null;
        Object.defineProperty(SourceMapConsumer$1.prototype, "_originalMappings", {configurable: true, enumerable: true, get: function get2() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }});
        SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
          var c2 = aStr.charAt(index);
          return c2 === ";" || c2 === ",";
        };
        SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        };
        SourceMapConsumer$1.GENERATED_ORDER = 1;
        SourceMapConsumer$1.ORIGINAL_ORDER = 2;
        SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
        SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;
        SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
          var mappings;
          switch (order) {
            case SourceMapConsumer$1.GENERATED_ORDER:
              mappings = this._generatedMappings;
              break;
            case SourceMapConsumer$1.ORIGINAL_ORDER:
              mappings = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var sourceRoot = this.sourceRoot;
          mappings.map(function(mapping2) {
            var source = mapping2.source === null ? null : this._sources.at(mapping2.source);
            source = util$3.computeSourceURL(sourceRoot, source, this._sourceMapURL);
            return {source, generatedLine: mapping2.generatedLine, generatedColumn: mapping2.generatedColumn, originalLine: mapping2.originalLine, originalColumn: mapping2.originalColumn, name: mapping2.name === null ? null : this._names.at(mapping2.name)};
          }, this).forEach(aCallback, context);
        };
        SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
          var line = util$3.getArg(aArgs, "line");
          var needle = {source: util$3.getArg(aArgs, "source"), originalLine: line, originalColumn: util$3.getArg(aArgs, "column", 0)};
          needle.source = this._findSourceIndex(needle.source);
          if (needle.source < 0) {
            return [];
          }
          var mappings = [];
          var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$3.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping2 = this._originalMappings[index];
            if (aArgs.column === void 0) {
              var originalLine = mapping2.originalLine;
              while (mapping2 && mapping2.originalLine === originalLine) {
                mappings.push({line: util$3.getArg(mapping2, "generatedLine", null), column: util$3.getArg(mapping2, "generatedColumn", null), lastColumn: util$3.getArg(mapping2, "lastGeneratedColumn", null)});
                mapping2 = this._originalMappings[++index];
              }
            } else {
              var originalColumn = mapping2.originalColumn;
              while (mapping2 && mapping2.originalLine === line && mapping2.originalColumn == originalColumn) {
                mappings.push({line: util$3.getArg(mapping2, "generatedLine", null), column: util$3.getArg(mapping2, "generatedColumn", null), lastColumn: util$3.getArg(mapping2, "lastGeneratedColumn", null)});
                mapping2 = this._originalMappings[++index];
              }
            }
          }
          return mappings;
        };
        var SourceMapConsumer_1 = SourceMapConsumer$1;
        function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
          var sourceMap2 = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap2 = util$3.parseSourceMapInput(aSourceMap);
          }
          var version2 = util$3.getArg(sourceMap2, "version");
          var sources = util$3.getArg(sourceMap2, "sources");
          var names = util$3.getArg(sourceMap2, "names", []);
          var sourceRoot = util$3.getArg(sourceMap2, "sourceRoot", null);
          var sourcesContent = util$3.getArg(sourceMap2, "sourcesContent", null);
          var mappings = util$3.getArg(sourceMap2, "mappings");
          var file = util$3.getArg(sourceMap2, "file", null);
          if (version2 != this._version) {
            throw new Error("Unsupported version: " + version2);
          }
          if (sourceRoot) {
            sourceRoot = util$3.normalize(sourceRoot);
          }
          sources = sources.map(String).map(util$3.normalize).map(function(source) {
            return sourceRoot && util$3.isAbsolute(sourceRoot) && util$3.isAbsolute(source) ? util$3.relative(sourceRoot, source) : source;
          });
          this._names = ArraySet$2.fromArray(names.map(String), true);
          this._sources = ArraySet$2.fromArray(sources, true);
          this._absoluteSources = this._sources.toArray().map(function(s) {
            return util$3.computeSourceURL(sourceRoot, s, aSourceMapURL);
          });
          this.sourceRoot = sourceRoot;
          this.sourcesContent = sourcesContent;
          this._mappings = mappings;
          this._sourceMapURL = aSourceMapURL;
          this.file = file;
        }
        BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
        BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;
        BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
          var relativeSource = aSource;
          if (this.sourceRoot != null) {
            relativeSource = util$3.relative(this.sourceRoot, relativeSource);
          }
          if (this._sources.has(relativeSource)) {
            return this._sources.indexOf(relativeSource);
          }
          var i;
          for (i = 0; i < this._absoluteSources.length; ++i) {
            if (this._absoluteSources[i] == aSource) {
              return i;
            }
          }
          return -1;
        };
        BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
          var smc = Object.create(BasicSourceMapConsumer.prototype);
          var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
          var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
          smc.file = aSourceMap._file;
          smc._sourceMapURL = aSourceMapURL;
          smc._absoluteSources = smc._sources.toArray().map(function(s) {
            return util$3.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
          });
          var generatedMappings = aSourceMap._mappings.toArray().slice();
          var destGeneratedMappings = smc.__generatedMappings = [];
          var destOriginalMappings = smc.__originalMappings = [];
          for (var i = 0, length = generatedMappings.length; i < length; i++) {
            var srcMapping = generatedMappings[i];
            var destMapping = new Mapping$1();
            destMapping.generatedLine = srcMapping.generatedLine;
            destMapping.generatedColumn = srcMapping.generatedColumn;
            if (srcMapping.source) {
              destMapping.source = sources.indexOf(srcMapping.source);
              destMapping.originalLine = srcMapping.originalLine;
              destMapping.originalColumn = srcMapping.originalColumn;
              if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
              }
              destOriginalMappings.push(destMapping);
            }
            destGeneratedMappings.push(destMapping);
          }
          quickSort(smc.__originalMappings, util$3.compareByOriginalPositions);
          return smc;
        };
        BasicSourceMapConsumer.prototype._version = 3;
        Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {get: function get2() {
          return this._absoluteSources.slice();
        }});
        function Mapping$1() {
          this.generatedLine = 0;
          this.generatedColumn = 0;
          this.source = null;
          this.originalLine = null;
          this.originalColumn = null;
          this.name = null;
        }
        BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var length = aStr.length;
          var index = 0;
          var cachedSegments = {};
          var temp = {};
          var originalMappings = [];
          var generatedMappings = [];
          var mapping2, str, segment, end, value;
          while (index < length) {
            if (aStr.charAt(index) === ";") {
              generatedLine++;
              index++;
              previousGeneratedColumn = 0;
            } else if (aStr.charAt(index) === ",") {
              index++;
            } else {
              mapping2 = new Mapping$1();
              mapping2.generatedLine = generatedLine;
              for (end = index; end < length; end++) {
                if (this._charIsMappingSeparator(aStr, end)) {
                  break;
                }
              }
              str = aStr.slice(index, end);
              segment = cachedSegments[str];
              if (segment) {
                index += str.length;
              } else {
                segment = [];
                while (index < end) {
                  base64Vlq$1.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  segment.push(value);
                }
                if (segment.length === 2) {
                  throw new Error("Found a source, but no line and column");
                }
                if (segment.length === 3) {
                  throw new Error("Found a source and line, but no column");
                }
                cachedSegments[str] = segment;
              }
              mapping2.generatedColumn = previousGeneratedColumn + segment[0];
              previousGeneratedColumn = mapping2.generatedColumn;
              if (segment.length > 1) {
                mapping2.source = previousSource + segment[1];
                previousSource += segment[1];
                mapping2.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping2.originalLine;
                mapping2.originalLine += 1;
                mapping2.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping2.originalColumn;
                if (segment.length > 4) {
                  mapping2.name = previousName + segment[4];
                  previousName += segment[4];
                }
              }
              generatedMappings.push(mapping2);
              if (typeof mapping2.originalLine === "number") {
                originalMappings.push(mapping2);
              }
            }
          }
          quickSort(generatedMappings, util$3.compareByGeneratedPositionsDeflated);
          this.__generatedMappings = generatedMappings;
          quickSort(originalMappings, util$3.compareByOriginalPositions);
          this.__originalMappings = originalMappings;
        };
        BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
          }
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
        BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping2 = this._generatedMappings[index];
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
              if (mapping2.generatedLine === nextMapping.generatedLine) {
                mapping2.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
            mapping2.lastGeneratedColumn = Infinity;
          }
        };
        BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {generatedLine: util$3.getArg(aArgs, "line"), generatedColumn: util$3.getArg(aArgs, "column")};
          var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$3.compareByGeneratedPositionsDeflated, util$3.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping2 = this._generatedMappings[index];
            if (mapping2.generatedLine === needle.generatedLine) {
              var source = util$3.getArg(mapping2, "source", null);
              if (source !== null) {
                source = this._sources.at(source);
                source = util$3.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
              }
              var name = util$3.getArg(mapping2, "name", null);
              if (name !== null) {
                name = this._names.at(name);
              }
              return {source, line: util$3.getArg(mapping2, "originalLine", null), column: util$3.getArg(mapping2, "originalColumn", null), name};
            }
          }
          return {source: null, line: null, column: null, name: null};
        };
        BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
          if (!this.sourcesContent) {
            return false;
          }
          return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
            return sc == null;
          });
        };
        BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          if (!this.sourcesContent) {
            return null;
          }
          var index = this._findSourceIndex(aSource);
          if (index >= 0) {
            return this.sourcesContent[index];
          }
          var relativeSource = aSource;
          if (this.sourceRoot != null) {
            relativeSource = util$3.relative(this.sourceRoot, relativeSource);
          }
          var url;
          if (this.sourceRoot != null && (url = util$3.urlParse(this.sourceRoot))) {
            var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
            if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
            }
            if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
            }
          }
          if (nullOnMissing) {
            return null;
          } else {
            throw new Error('"' + relativeSource + '" is not in the SourceMap.');
          }
        };
        BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
          var source = util$3.getArg(aArgs, "source");
          source = this._findSourceIndex(source);
          if (source < 0) {
            return {line: null, column: null, lastColumn: null};
          }
          var needle = {source, originalLine: util$3.getArg(aArgs, "line"), originalColumn: util$3.getArg(aArgs, "column")};
          var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$3.compareByOriginalPositions, util$3.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping2 = this._originalMappings[index];
            if (mapping2.source === needle.source) {
              return {line: util$3.getArg(mapping2, "generatedLine", null), column: util$3.getArg(mapping2, "generatedColumn", null), lastColumn: util$3.getArg(mapping2, "lastGeneratedColumn", null)};
            }
          }
          return {line: null, column: null, lastColumn: null};
        };
        var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;
        function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
          var sourceMap2 = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap2 = util$3.parseSourceMapInput(aSourceMap);
          }
          var version2 = util$3.getArg(sourceMap2, "version");
          var sections = util$3.getArg(sourceMap2, "sections");
          if (version2 != this._version) {
            throw new Error("Unsupported version: " + version2);
          }
          this._sources = new ArraySet$2();
          this._names = new ArraySet$2();
          var lastOffset = {line: -1, column: 0};
          this._sections = sections.map(function(s) {
            if (s.url) {
              throw new Error("Support for url field in sections not implemented.");
            }
            var offset = util$3.getArg(s, "offset");
            var offsetLine = util$3.getArg(offset, "line");
            var offsetColumn = util$3.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
              throw new Error("Section offsets must be ordered and non-overlapping.");
            }
            lastOffset = offset;
            return {generatedOffset: {
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            }, consumer: new SourceMapConsumer$1(util$3.getArg(s, "map"), aSourceMapURL)};
          });
        }
        IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
        IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
        IndexedSourceMapConsumer.prototype._version = 3;
        Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {get: function get2() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }});
        IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {generatedLine: util$3.getArg(aArgs, "line"), generatedColumn: util$3.getArg(aArgs, "column")};
          var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          });
          var section = this._sections[sectionIndex];
          if (!section) {
            return {source: null, line: null, column: null, name: null};
          }
          return section.consumer.originalPositionFor({line: needle.generatedLine - (section.generatedOffset.generatedLine - 1), column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), bias: aArgs.bias});
        };
        IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
          return this._sections.every(function(s) {
            return s.consumer.hasContentsOfAllSources();
          });
        };
        IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
              return content;
            }
          }
          if (nullOnMissing) {
            return null;
          } else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
        IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            if (section.consumer._findSourceIndex(util$3.getArg(aArgs, "source")) === -1) {
              continue;
            }
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = {line: generatedPosition.line + (section.generatedOffset.generatedLine - 1), column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)};
              return ret;
            }
          }
          return {line: null, column: null};
        };
        IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          this.__generatedMappings = [];
          this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
              var mapping2 = sectionMappings[j];
              var source = section.consumer._sources.at(mapping2.source);
              source = util$3.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
              this._sources.add(source);
              source = this._sources.indexOf(source);
              var name = null;
              if (mapping2.name) {
                name = section.consumer._names.at(mapping2.name);
                this._names.add(name);
                name = this._names.indexOf(name);
              }
              var adjustedMapping = {source, generatedLine: mapping2.generatedLine + (section.generatedOffset.generatedLine - 1), generatedColumn: mapping2.generatedColumn + (section.generatedOffset.generatedLine === mapping2.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), originalLine: mapping2.originalLine, originalColumn: mapping2.originalColumn, name};
              this.__generatedMappings.push(adjustedMapping);
              if (typeof adjustedMapping.originalLine === "number") {
                this.__originalMappings.push(adjustedMapping);
              }
            }
          }
          quickSort(this.__generatedMappings, util$3.compareByGeneratedPositionsDeflated);
          quickSort(this.__originalMappings, util$3.compareByOriginalPositions);
        };
        var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;
        var sourceMapConsumer = {SourceMapConsumer: SourceMapConsumer_1, BasicSourceMapConsumer: BasicSourceMapConsumer_1, IndexedSourceMapConsumer: IndexedSourceMapConsumer_1};
        var SourceMapGenerator$3 = sourceMapGenerator$1.SourceMapGenerator;
        var REGEX_NEWLINE = /(\r?\n)/;
        var NEWLINE_CODE = 10;
        var isSourceNode = "$$$isSourceNode$$$";
        function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
          this.children = [];
          this.sourceContents = {};
          this.line = aLine == null ? null : aLine;
          this.column = aColumn == null ? null : aColumn;
          this.source = aSource == null ? null : aSource;
          this.name = aName == null ? null : aName;
          this[isSourceNode] = true;
          if (aChunks != null)
            this.add(aChunks);
        }
        SourceNode$1.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          var node2 = new SourceNode$1();
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var remainingLinesIndex = 0;
          var shiftNextLine = function shiftNextLine2() {
            var lineContents = getNextLine();
            var newLine = getNextLine() || "";
            return lineContents + newLine;
            function getNextLine() {
              return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
            }
          };
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
          var lastMapping = null;
          aSourceMapConsumer.eachMapping(function(mapping2) {
            if (lastMapping !== null) {
              if (lastGeneratedLine < mapping2.generatedLine) {
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
              } else {
                var nextLine = remainingLines[remainingLinesIndex] || "";
                var code = nextLine.substr(0, mapping2.generatedColumn - lastGeneratedColumn);
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn - lastGeneratedColumn);
                lastGeneratedColumn = mapping2.generatedColumn;
                addMappingWithCode(lastMapping, code);
                lastMapping = mapping2;
                return;
              }
            }
            while (lastGeneratedLine < mapping2.generatedLine) {
              node2.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping2.generatedColumn) {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              node2.add(nextLine.substr(0, mapping2.generatedColumn));
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn);
              lastGeneratedColumn = mapping2.generatedColumn;
            }
            lastMapping = mapping2;
          }, this);
          if (remainingLinesIndex < remainingLines.length) {
            if (lastMapping) {
              addMappingWithCode(lastMapping, shiftNextLine());
            }
            node2.add(remainingLines.splice(remainingLinesIndex).join(""));
          }
          aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util$3.join(aRelativePath, sourceFile);
              }
              node2.setSourceContent(sourceFile, content);
            }
          });
          return node2;
          function addMappingWithCode(mapping2, code) {
            if (mapping2 === null || mapping2.source === void 0) {
              node2.add(code);
            } else {
              var source = aRelativePath ? util$3.join(aRelativePath, mapping2.source) : mapping2.source;
              node2.add(new SourceNode$1(mapping2.originalLine, mapping2.originalColumn, source, code, mapping2.name));
            }
          }
        };
        SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
          if (Array.isArray(aChunk)) {
            aChunk.forEach(function(chunk) {
              this.add(chunk);
            }, this);
          } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
            if (aChunk) {
              this.children.push(aChunk);
            }
          } else {
            throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
          }
          return this;
        };
        SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
          if (Array.isArray(aChunk)) {
            for (var i = aChunk.length - 1; i >= 0; i--) {
              this.prepend(aChunk[i]);
            }
          } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
            this.children.unshift(aChunk);
          } else {
            throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
          }
          return this;
        };
        SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
          var chunk;
          for (var i = 0, len = this.children.length; i < len; i++) {
            chunk = this.children[i];
            if (chunk[isSourceNode]) {
              chunk.walk(aFn);
            } else {
              if (chunk !== "") {
                aFn(chunk, {source: this.source, line: this.line, column: this.column, name: this.name});
              }
            }
          }
        };
        SourceNode$1.prototype.join = function SourceNode_join(aSep) {
          var newChildren;
          var i;
          var len = this.children.length;
          if (len > 0) {
            newChildren = [];
            for (i = 0; i < len - 1; i++) {
              newChildren.push(this.children[i]);
              newChildren.push(aSep);
            }
            newChildren.push(this.children[i]);
            this.children = newChildren;
          }
          return this;
        };
        SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
          var lastChild = this.children[this.children.length - 1];
          if (lastChild[isSourceNode]) {
            lastChild.replaceRight(aPattern, aReplacement);
          } else if (typeof lastChild === "string") {
            this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
          } else {
            this.children.push("".replace(aPattern, aReplacement));
          }
          return this;
        };
        SourceNode$1.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util$3.toSetString(aSourceFile)] = aSourceContent;
        };
        SourceNode$1.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
              this.children[i].walkSourceContents(aFn);
            }
          }
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util$3.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
        SourceNode$1.prototype.toString = function SourceNode_toString() {
          var str = "";
          this.walk(function(chunk) {
            str += chunk;
          });
          return str;
        };
        SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
          var generated = {code: "", line: 1, column: 0};
          var map = new SourceMapGenerator$3(aArgs);
          var sourceMappingActive = false;
          var lastOriginalSource = null;
          var lastOriginalLine = null;
          var lastOriginalColumn = null;
          var lastOriginalName = null;
          this.walk(function(chunk, original) {
            generated.code += chunk;
            if (original.source !== null && original.line !== null && original.column !== null) {
              if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                map.addMapping({source: original.source, original: {line: original.line, column: original.column}, generated: {line: generated.line, column: generated.column}, name: original.name});
              }
              lastOriginalSource = original.source;
              lastOriginalLine = original.line;
              lastOriginalColumn = original.column;
              lastOriginalName = original.name;
              sourceMappingActive = true;
            } else if (sourceMappingActive) {
              map.addMapping({generated: {line: generated.line, column: generated.column}});
              lastOriginalSource = null;
              sourceMappingActive = false;
            }
            for (var idx = 0, length = chunk.length; idx < length; idx++) {
              if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0;
                if (idx + 1 === length) {
                  lastOriginalSource = null;
                  sourceMappingActive = false;
                } else if (sourceMappingActive) {
                  map.addMapping({source: original.source, original: {line: original.line, column: original.column}, generated: {line: generated.line, column: generated.column}, name: original.name});
                }
              } else {
                generated.column++;
              }
            }
          });
          this.walkSourceContents(function(sourceFile, sourceContent) {
            map.setSourceContent(sourceFile, sourceContent);
          });
          return {code: generated.code, map};
        };
        var SourceNode_1 = SourceNode$1;
        var sourceNode = {SourceNode: SourceNode_1};
        var SourceMapGenerator$2 = sourceMapGenerator$1.SourceMapGenerator;
        var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
        var SourceNode = sourceNode.SourceNode;
        var sourceMap = {SourceMapGenerator: SourceMapGenerator$2, SourceMapConsumer, SourceNode};
        var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace2(assert$2);
        var util$2 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.isTrailingCommaEnabled = exports4.getParentExportDeclaration = exports4.isExportDeclaration = exports4.fixFaultyLocations = exports4.getTrueLoc = exports4.composeSourceMaps = exports4.copyPos = exports4.comparePos = exports4.getUnionOfKeys = exports4.getOption = void 0;
          var assert_12 = tslib_1.__importDefault(require$$0$1);
          var types2 = tslib_1.__importStar(main$1);
          var n2 = types2.namedTypes;
          var source_map_1 = tslib_1.__importDefault(sourceMap);
          var SourceMapConsumer2 = source_map_1.default.SourceMapConsumer;
          var SourceMapGenerator2 = source_map_1.default.SourceMapGenerator;
          var hasOwn2 = Object.prototype.hasOwnProperty;
          function getOption(options2, key, defaultValue) {
            if (options2 && hasOwn2.call(options2, key)) {
              return options2[key];
            }
            return defaultValue;
          }
          exports4.getOption = getOption;
          function getUnionOfKeys() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var result = {};
            var argc = args.length;
            for (var i = 0; i < argc; ++i) {
              var keys = Object.keys(args[i]);
              var keyCount = keys.length;
              for (var j = 0; j < keyCount; ++j) {
                result[keys[j]] = true;
              }
            }
            return result;
          }
          exports4.getUnionOfKeys = getUnionOfKeys;
          function comparePos(pos1, pos2) {
            return pos1.line - pos2.line || pos1.column - pos2.column;
          }
          exports4.comparePos = comparePos;
          function copyPos(pos) {
            return {line: pos.line, column: pos.column};
          }
          exports4.copyPos = copyPos;
          function composeSourceMaps(formerMap, latterMap) {
            if (formerMap) {
              if (!latterMap) {
                return formerMap;
              }
            } else {
              return latterMap || null;
            }
            var smcFormer = new SourceMapConsumer2(formerMap);
            var smcLatter = new SourceMapConsumer2(latterMap);
            var smg = new SourceMapGenerator2({file: latterMap.file, sourceRoot: latterMap.sourceRoot});
            var sourcesToContents = {};
            smcLatter.eachMapping(function(mapping2) {
              var origPos = smcFormer.originalPositionFor({line: mapping2.originalLine, column: mapping2.originalColumn});
              var sourceName = origPos.source;
              if (sourceName === null) {
                return;
              }
              smg.addMapping({source: sourceName, original: copyPos(origPos), generated: {line: mapping2.generatedLine, column: mapping2.generatedColumn}, name: mapping2.name});
              var sourceContent = smcFormer.sourceContentFor(sourceName);
              if (sourceContent && !hasOwn2.call(sourcesToContents, sourceName)) {
                sourcesToContents[sourceName] = sourceContent;
                smg.setSourceContent(sourceName, sourceContent);
              }
            });
            return smg.toJSON();
          }
          exports4.composeSourceMaps = composeSourceMaps;
          function getTrueLoc(node2, lines2) {
            if (!node2.loc) {
              return null;
            }
            var result = {start: node2.loc.start, end: node2.loc.end};
            function include(node3) {
              expandLoc(result, node3.loc);
            }
            if (node2.declaration && node2.declaration.decorators && isExportDeclaration(node2)) {
              node2.declaration.decorators.forEach(include);
            }
            if (comparePos(result.start, result.end) < 0) {
              result.start = copyPos(result.start);
              lines2.skipSpaces(result.start, false, true);
              if (comparePos(result.start, result.end) < 0) {
                result.end = copyPos(result.end);
                lines2.skipSpaces(result.end, true, true);
              }
            }
            if (node2.comments) {
              node2.comments.forEach(include);
            }
            return result;
          }
          exports4.getTrueLoc = getTrueLoc;
          function expandLoc(parentLoc, childLoc) {
            if (parentLoc && childLoc) {
              if (comparePos(childLoc.start, parentLoc.start) < 0) {
                parentLoc.start = childLoc.start;
              }
              if (comparePos(parentLoc.end, childLoc.end) < 0) {
                parentLoc.end = childLoc.end;
              }
            }
          }
          function fixFaultyLocations(node2, lines2) {
            var loc = node2.loc;
            if (loc) {
              if (loc.start.line < 1) {
                loc.start.line = 1;
              }
              if (loc.end.line < 1) {
                loc.end.line = 1;
              }
            }
            if (node2.type === "File") {
              loc.start = lines2.firstPos();
              loc.end = lines2.lastPos();
            }
            fixForLoopHead(node2, lines2);
            fixTemplateLiteral(node2, lines2);
            if (loc && node2.decorators) {
              node2.decorators.forEach(function(decorator) {
                expandLoc(loc, decorator.loc);
              });
            } else if (node2.declaration && isExportDeclaration(node2)) {
              node2.declaration.loc = null;
              var decorators = node2.declaration.decorators;
              if (decorators) {
                decorators.forEach(function(decorator) {
                  expandLoc(loc, decorator.loc);
                });
              }
            } else if (n2.MethodDefinition && n2.MethodDefinition.check(node2) || n2.Property.check(node2) && (node2.method || node2.shorthand)) {
              node2.value.loc = null;
              if (n2.FunctionExpression.check(node2.value)) {
                node2.value.id = null;
              }
            } else if (node2.type === "ObjectTypeProperty") {
              var loc_1 = node2.loc;
              var end = loc_1 && loc_1.end;
              if (end) {
                end = copyPos(end);
                if (lines2.prevPos(end) && lines2.charAt(end) === ",") {
                  if (end = lines2.skipSpaces(end, true, true)) {
                    loc_1.end = end;
                  }
                }
              }
            }
          }
          exports4.fixFaultyLocations = fixFaultyLocations;
          function fixForLoopHead(node2, lines2) {
            if (node2.type !== "ForStatement") {
              return;
            }
            function fix(child) {
              var loc = child && child.loc;
              var start = loc && loc.start;
              var end = loc && copyPos(loc.end);
              while (start && end && comparePos(start, end) < 0) {
                lines2.prevPos(end);
                if (lines2.charAt(end) === ";") {
                  loc.end.line = end.line;
                  loc.end.column = end.column;
                } else {
                  break;
                }
              }
            }
            fix(node2.init);
            fix(node2.test);
            fix(node2.update);
          }
          function fixTemplateLiteral(node2, lines2) {
            if (node2.type !== "TemplateLiteral") {
              return;
            }
            if (node2.quasis.length === 0) {
              return;
            }
            if (node2.loc) {
              var afterLeftBackTickPos = copyPos(node2.loc.start);
              assert_12.default.strictEqual(lines2.charAt(afterLeftBackTickPos), "`");
              assert_12.default.ok(lines2.nextPos(afterLeftBackTickPos));
              var firstQuasi = node2.quasis[0];
              if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
                firstQuasi.loc.start = afterLeftBackTickPos;
              }
              var rightBackTickPos = copyPos(node2.loc.end);
              assert_12.default.ok(lines2.prevPos(rightBackTickPos));
              assert_12.default.strictEqual(lines2.charAt(rightBackTickPos), "`");
              var lastQuasi = node2.quasis[node2.quasis.length - 1];
              if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
                lastQuasi.loc.end = rightBackTickPos;
              }
            }
            node2.expressions.forEach(function(expr2, i) {
              var dollarCurlyPos = lines2.skipSpaces(expr2.loc.start, true, false);
              if (lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "{" && lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "$") {
                var quasiBefore = node2.quasis[i];
                if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
                  quasiBefore.loc.end = dollarCurlyPos;
                }
              }
              var rightCurlyPos = lines2.skipSpaces(expr2.loc.end, false, false);
              if (lines2.charAt(rightCurlyPos) === "}") {
                assert_12.default.ok(lines2.nextPos(rightCurlyPos));
                var quasiAfter = node2.quasis[i + 1];
                if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
                  quasiAfter.loc.start = rightCurlyPos;
                }
              }
            });
          }
          function isExportDeclaration(node2) {
            if (node2)
              switch (node2.type) {
                case "ExportDeclaration":
                case "ExportDefaultDeclaration":
                case "ExportDefaultSpecifier":
                case "DeclareExportDeclaration":
                case "ExportNamedDeclaration":
                case "ExportAllDeclaration":
                  return true;
              }
            return false;
          }
          exports4.isExportDeclaration = isExportDeclaration;
          function getParentExportDeclaration(path2) {
            var parentNode = path2.getParentNode();
            if (path2.getName() === "declaration" && isExportDeclaration(parentNode)) {
              return parentNode;
            }
            return null;
          }
          exports4.getParentExportDeclaration = getParentExportDeclaration;
          function isTrailingCommaEnabled(options2, context) {
            var trailingComma = options2.trailingComma;
            if (typeof trailingComma === "object") {
              return !!trailingComma[context];
            }
            return !!trailingComma;
          }
          exports4.isTrailingCommaEnabled = isTrailingCommaEnabled;
        });
        var esprima$1 = createCommonjsModule(function(module3, exports4) {
          (function webpackUniversalModuleDefinition(root, factory) {
            module3.exports = factory();
          })(this, function() {
            return function(modules) {
              var installedModules = {};
              function __webpack_require__(moduleId) {
                if (installedModules[moduleId])
                  return installedModules[moduleId].exports;
                var module4 = installedModules[moduleId] = {exports: {}, id: moduleId, loaded: false};
                modules[moduleId].call(module4.exports, module4, module4.exports, __webpack_require__);
                module4.loaded = true;
                return module4.exports;
              }
              __webpack_require__.m = modules;
              __webpack_require__.c = installedModules;
              __webpack_require__.p = "";
              return __webpack_require__(0);
            }([function(module4, exports5, __webpack_require__) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var comment_handler_1 = __webpack_require__(1);
              var jsx_parser_1 = __webpack_require__(3);
              var parser_1 = __webpack_require__(8);
              var tokenizer_1 = __webpack_require__(15);
              function parse(code, options2, delegate) {
                var commentHandler = null;
                var proxyDelegate = function proxyDelegate2(node2, metadata) {
                  if (delegate) {
                    delegate(node2, metadata);
                  }
                  if (commentHandler) {
                    commentHandler.visit(node2, metadata);
                  }
                };
                var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
                var collectComment = false;
                if (options2) {
                  collectComment = typeof options2.comment === "boolean" && options2.comment;
                  var attachComment = typeof options2.attachComment === "boolean" && options2.attachComment;
                  if (collectComment || attachComment) {
                    commentHandler = new comment_handler_1.CommentHandler();
                    commentHandler.attach = attachComment;
                    options2.comment = true;
                    parserDelegate = proxyDelegate;
                  }
                }
                var isModule = false;
                if (options2 && typeof options2.sourceType === "string") {
                  isModule = options2.sourceType === "module";
                }
                var parser2;
                if (options2 && typeof options2.jsx === "boolean" && options2.jsx) {
                  parser2 = new jsx_parser_1.JSXParser(code, options2, parserDelegate);
                } else {
                  parser2 = new parser_1.Parser(code, options2, parserDelegate);
                }
                var program = isModule ? parser2.parseModule() : parser2.parseScript();
                var ast = program;
                if (collectComment && commentHandler) {
                  ast.comments = commentHandler.comments;
                }
                if (parser2.config.tokens) {
                  ast.tokens = parser2.tokens;
                }
                if (parser2.config.tolerant) {
                  ast.errors = parser2.errorHandler.errors;
                }
                return ast;
              }
              exports5.parse = parse;
              function parseModule(code, options2, delegate) {
                var parsingOptions = options2 || {};
                parsingOptions.sourceType = "module";
                return parse(code, parsingOptions, delegate);
              }
              exports5.parseModule = parseModule;
              function parseScript(code, options2, delegate) {
                var parsingOptions = options2 || {};
                parsingOptions.sourceType = "script";
                return parse(code, parsingOptions, delegate);
              }
              exports5.parseScript = parseScript;
              function tokenize(code, options2, delegate) {
                var tokenizer = new tokenizer_1.Tokenizer(code, options2);
                var tokens;
                tokens = [];
                try {
                  while (true) {
                    var token = tokenizer.getNextToken();
                    if (!token) {
                      break;
                    }
                    if (delegate) {
                      token = delegate(token);
                    }
                    tokens.push(token);
                  }
                } catch (e) {
                  tokenizer.errorHandler.tolerate(e);
                }
                if (tokenizer.errorHandler.tolerant) {
                  tokens.errors = tokenizer.errors();
                }
                return tokens;
              }
              exports5.tokenize = tokenize;
              var syntax_1 = __webpack_require__(2);
              exports5.Syntax = syntax_1.Syntax;
              exports5.version = "4.0.1";
            }, function(module4, exports5, __webpack_require__) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var syntax_1 = __webpack_require__(2);
              var CommentHandler = function() {
                function CommentHandler2() {
                  this.attach = false;
                  this.comments = [];
                  this.stack = [];
                  this.leading = [];
                  this.trailing = [];
                }
                CommentHandler2.prototype.insertInnerComments = function(node2, metadata) {
                  if (node2.type === syntax_1.Syntax.BlockStatement && node2.body.length === 0) {
                    var innerComments = [];
                    for (var i = this.leading.length - 1; i >= 0; --i) {
                      var entry = this.leading[i];
                      if (metadata.end.offset >= entry.start) {
                        innerComments.unshift(entry.comment);
                        this.leading.splice(i, 1);
                        this.trailing.splice(i, 1);
                      }
                    }
                    if (innerComments.length) {
                      node2.innerComments = innerComments;
                    }
                  }
                };
                CommentHandler2.prototype.findTrailingComments = function(metadata) {
                  var trailingComments = [];
                  if (this.trailing.length > 0) {
                    for (var i = this.trailing.length - 1; i >= 0; --i) {
                      var entry_1 = this.trailing[i];
                      if (entry_1.start >= metadata.end.offset) {
                        trailingComments.unshift(entry_1.comment);
                      }
                    }
                    this.trailing.length = 0;
                    return trailingComments;
                  }
                  var entry = this.stack[this.stack.length - 1];
                  if (entry && entry.node.trailingComments) {
                    var firstComment = entry.node.trailingComments[0];
                    if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                      trailingComments = entry.node.trailingComments;
                      delete entry.node.trailingComments;
                    }
                  }
                  return trailingComments;
                };
                CommentHandler2.prototype.findLeadingComments = function(metadata) {
                  var leadingComments = [];
                  var target;
                  while (this.stack.length > 0) {
                    var entry = this.stack[this.stack.length - 1];
                    if (entry && entry.start >= metadata.start.offset) {
                      target = entry.node;
                      this.stack.pop();
                    } else {
                      break;
                    }
                  }
                  if (target) {
                    var count = target.leadingComments ? target.leadingComments.length : 0;
                    for (var i = count - 1; i >= 0; --i) {
                      var comment2 = target.leadingComments[i];
                      if (comment2.range[1] <= metadata.start.offset) {
                        leadingComments.unshift(comment2);
                        target.leadingComments.splice(i, 1);
                      }
                    }
                    if (target.leadingComments && target.leadingComments.length === 0) {
                      delete target.leadingComments;
                    }
                    return leadingComments;
                  }
                  for (var i = this.leading.length - 1; i >= 0; --i) {
                    var entry = this.leading[i];
                    if (entry.start <= metadata.start.offset) {
                      leadingComments.unshift(entry.comment);
                      this.leading.splice(i, 1);
                    }
                  }
                  return leadingComments;
                };
                CommentHandler2.prototype.visitNode = function(node2, metadata) {
                  if (node2.type === syntax_1.Syntax.Program && node2.body.length > 0) {
                    return;
                  }
                  this.insertInnerComments(node2, metadata);
                  var trailingComments = this.findTrailingComments(metadata);
                  var leadingComments = this.findLeadingComments(metadata);
                  if (leadingComments.length > 0) {
                    node2.leadingComments = leadingComments;
                  }
                  if (trailingComments.length > 0) {
                    node2.trailingComments = trailingComments;
                  }
                  this.stack.push({node: node2, start: metadata.start.offset});
                };
                CommentHandler2.prototype.visitComment = function(node2, metadata) {
                  var type2 = node2.type[0] === "L" ? "Line" : "Block";
                  var comment2 = {type: type2, value: node2.value};
                  if (node2.range) {
                    comment2.range = node2.range;
                  }
                  if (node2.loc) {
                    comment2.loc = node2.loc;
                  }
                  this.comments.push(comment2);
                  if (this.attach) {
                    var entry = {comment: {type: type2, value: node2.value, range: [metadata.start.offset, metadata.end.offset]}, start: metadata.start.offset};
                    if (node2.loc) {
                      entry.comment.loc = node2.loc;
                    }
                    node2.type = type2;
                    this.leading.push(entry);
                    this.trailing.push(entry);
                  }
                };
                CommentHandler2.prototype.visit = function(node2, metadata) {
                  if (node2.type === "LineComment") {
                    this.visitComment(node2, metadata);
                  } else if (node2.type === "BlockComment") {
                    this.visitComment(node2, metadata);
                  } else if (this.attach) {
                    this.visitNode(node2, metadata);
                  }
                };
                return CommentHandler2;
              }();
              exports5.CommentHandler = CommentHandler;
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              exports5.Syntax = {AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DoWhileStatement: "DoWhileStatement", DebuggerStatement: "DebuggerStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForOfStatement: "ForOfStatement", ForInStatement: "ForInStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchCase: "SwitchCase", SwitchStatement: "SwitchStatement", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression"};
            }, function(module4, exports5, __webpack_require__) {
              var __extends2 = this && this.__extends || function() {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d, b) {
                  d.__proto__ = b;
                } || function(d, b) {
                  for (var p in b)
                    if (b.hasOwnProperty(p))
                      d[p] = b[p];
                };
                return function(d, b) {
                  extendStatics(d, b);
                  function __2() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
                };
              }();
              Object.defineProperty(exports5, "__esModule", {value: true});
              var character_1 = __webpack_require__(4);
              var JSXNode = __webpack_require__(5);
              var jsx_syntax_1 = __webpack_require__(6);
              var Node3 = __webpack_require__(7);
              var parser_1 = __webpack_require__(8);
              var token_1 = __webpack_require__(13);
              var xhtml_entities_1 = __webpack_require__(14);
              token_1.TokenName[100] = "JSXIdentifier";
              token_1.TokenName[101] = "JSXText";
              function getQualifiedElementName(elementName) {
                var qualifiedName;
                switch (elementName.type) {
                  case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                    var id = elementName;
                    qualifiedName = id.name;
                    break;
                  case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                    var ns = elementName;
                    qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                    break;
                  case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                    var expr2 = elementName;
                    qualifiedName = getQualifiedElementName(expr2.object) + "." + getQualifiedElementName(expr2.property);
                    break;
                }
                return qualifiedName;
              }
              var JSXParser = function(_super) {
                __extends2(JSXParser2, _super);
                function JSXParser2(code, options2, delegate) {
                  return _super.call(this, code, options2, delegate) || this;
                }
                JSXParser2.prototype.parsePrimaryExpression = function() {
                  return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
                };
                JSXParser2.prototype.startJSX = function() {
                  this.scanner.index = this.startMarker.index;
                  this.scanner.lineNumber = this.startMarker.line;
                  this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
                };
                JSXParser2.prototype.finishJSX = function() {
                  this.nextToken();
                };
                JSXParser2.prototype.reenterJSX = function() {
                  this.startJSX();
                  this.expectJSX("}");
                  if (this.config.tokens) {
                    this.tokens.pop();
                  }
                };
                JSXParser2.prototype.createJSXNode = function() {
                  this.collectComments();
                  return {index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                };
                JSXParser2.prototype.createJSXChildNode = function() {
                  return {index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                };
                JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                  var result = "&";
                  var valid = true;
                  var terminated = false;
                  var numeric = false;
                  var hex = false;
                  while (!this.scanner.eof() && valid && !terminated) {
                    var ch = this.scanner.source[this.scanner.index];
                    if (ch === quote) {
                      break;
                    }
                    terminated = ch === ";";
                    result += ch;
                    ++this.scanner.index;
                    if (!terminated) {
                      switch (result.length) {
                        case 2:
                          numeric = ch === "#";
                          break;
                        case 3:
                          if (numeric) {
                            hex = ch === "x";
                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                            numeric = numeric && !hex;
                          }
                          break;
                        default:
                          valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                          valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                          break;
                      }
                    }
                  }
                  if (valid && terminated && result.length > 2) {
                    var str = result.substr(1, result.length - 2);
                    if (numeric && str.length > 1) {
                      result = String.fromCharCode(parseInt(str.substr(1), 10));
                    } else if (hex && str.length > 2) {
                      result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                    } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                      result = xhtml_entities_1.XHTMLEntities[str];
                    }
                  }
                  return result;
                };
                JSXParser2.prototype.lexJSX = function() {
                  var cp = this.scanner.source.charCodeAt(this.scanner.index);
                  if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                    var value = this.scanner.source[this.scanner.index++];
                    return {type: 7, value, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index - 1, end: this.scanner.index};
                  }
                  if (cp === 34 || cp === 39) {
                    var start = this.scanner.index;
                    var quote = this.scanner.source[this.scanner.index++];
                    var str = "";
                    while (!this.scanner.eof()) {
                      var ch = this.scanner.source[this.scanner.index++];
                      if (ch === quote) {
                        break;
                      } else if (ch === "&") {
                        str += this.scanXHTMLEntity(quote);
                      } else {
                        str += ch;
                      }
                    }
                    return {type: 8, value: str, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                  }
                  if (cp === 46) {
                    var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                    var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                    var value = n1 === 46 && n2 === 46 ? "..." : ".";
                    var start = this.scanner.index;
                    this.scanner.index += value.length;
                    return {type: 7, value, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                  }
                  if (cp === 96) {
                    return {type: 10, value: "", lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index, end: this.scanner.index};
                  }
                  if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                    var start = this.scanner.index;
                    ++this.scanner.index;
                    while (!this.scanner.eof()) {
                      var ch = this.scanner.source.charCodeAt(this.scanner.index);
                      if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                        ++this.scanner.index;
                      } else if (ch === 45) {
                        ++this.scanner.index;
                      } else {
                        break;
                      }
                    }
                    var id = this.scanner.source.slice(start, this.scanner.index);
                    return {type: 100, value: id, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                  }
                  return this.scanner.lex();
                };
                JSXParser2.prototype.nextJSXToken = function() {
                  this.collectComments();
                  this.startMarker.index = this.scanner.index;
                  this.startMarker.line = this.scanner.lineNumber;
                  this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                  var token = this.lexJSX();
                  this.lastMarker.index = this.scanner.index;
                  this.lastMarker.line = this.scanner.lineNumber;
                  this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                  if (this.config.tokens) {
                    this.tokens.push(this.convertToken(token));
                  }
                  return token;
                };
                JSXParser2.prototype.nextJSXText = function() {
                  this.startMarker.index = this.scanner.index;
                  this.startMarker.line = this.scanner.lineNumber;
                  this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                  var start = this.scanner.index;
                  var text2 = "";
                  while (!this.scanner.eof()) {
                    var ch = this.scanner.source[this.scanner.index];
                    if (ch === "{" || ch === "<") {
                      break;
                    }
                    ++this.scanner.index;
                    text2 += ch;
                    if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      ++this.scanner.lineNumber;
                      if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                        ++this.scanner.index;
                      }
                      this.scanner.lineStart = this.scanner.index;
                    }
                  }
                  this.lastMarker.index = this.scanner.index;
                  this.lastMarker.line = this.scanner.lineNumber;
                  this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                  var token = {type: 101, value: text2, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                  if (text2.length > 0 && this.config.tokens) {
                    this.tokens.push(this.convertToken(token));
                  }
                  return token;
                };
                JSXParser2.prototype.peekJSXToken = function() {
                  var state = this.scanner.saveState();
                  this.scanner.scanComments();
                  var next = this.lexJSX();
                  this.scanner.restoreState(state);
                  return next;
                };
                JSXParser2.prototype.expectJSX = function(value) {
                  var token = this.nextJSXToken();
                  if (token.type !== 7 || token.value !== value) {
                    this.throwUnexpectedToken(token);
                  }
                };
                JSXParser2.prototype.matchJSX = function(value) {
                  var next = this.peekJSXToken();
                  return next.type === 7 && next.value === value;
                };
                JSXParser2.prototype.parseJSXIdentifier = function() {
                  var node2 = this.createJSXNode();
                  var token = this.nextJSXToken();
                  if (token.type !== 100) {
                    this.throwUnexpectedToken(token);
                  }
                  return this.finalize(node2, new JSXNode.JSXIdentifier(token.value));
                };
                JSXParser2.prototype.parseJSXElementName = function() {
                  var node2 = this.createJSXNode();
                  var elementName = this.parseJSXIdentifier();
                  if (this.matchJSX(":")) {
                    var namespace = elementName;
                    this.expectJSX(":");
                    var name_1 = this.parseJSXIdentifier();
                    elementName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_1));
                  } else if (this.matchJSX(".")) {
                    while (this.matchJSX(".")) {
                      var object2 = elementName;
                      this.expectJSX(".");
                      var property = this.parseJSXIdentifier();
                      elementName = this.finalize(node2, new JSXNode.JSXMemberExpression(object2, property));
                    }
                  }
                  return elementName;
                };
                JSXParser2.prototype.parseJSXAttributeName = function() {
                  var node2 = this.createJSXNode();
                  var attributeName;
                  var identifier = this.parseJSXIdentifier();
                  if (this.matchJSX(":")) {
                    var namespace = identifier;
                    this.expectJSX(":");
                    var name_2 = this.parseJSXIdentifier();
                    attributeName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_2));
                  } else {
                    attributeName = identifier;
                  }
                  return attributeName;
                };
                JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                  var node2 = this.createJSXNode();
                  var token = this.nextJSXToken();
                  if (token.type !== 8) {
                    this.throwUnexpectedToken(token);
                  }
                  var raw = this.getTokenRaw(token);
                  return this.finalize(node2, new Node3.Literal(token.value, raw));
                };
                JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                  var node2 = this.createJSXNode();
                  this.expectJSX("{");
                  this.finishJSX();
                  if (this.match("}")) {
                    this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                  }
                  var expression = this.parseAssignmentExpression();
                  this.reenterJSX();
                  return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
                };
                JSXParser2.prototype.parseJSXAttributeValue = function() {
                  return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
                };
                JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                  var node2 = this.createJSXNode();
                  var name = this.parseJSXAttributeName();
                  var value = null;
                  if (this.matchJSX("=")) {
                    this.expectJSX("=");
                    value = this.parseJSXAttributeValue();
                  }
                  return this.finalize(node2, new JSXNode.JSXAttribute(name, value));
                };
                JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                  var node2 = this.createJSXNode();
                  this.expectJSX("{");
                  this.expectJSX("...");
                  this.finishJSX();
                  var argument = this.parseAssignmentExpression();
                  this.reenterJSX();
                  return this.finalize(node2, new JSXNode.JSXSpreadAttribute(argument));
                };
                JSXParser2.prototype.parseJSXAttributes = function() {
                  var attributes = [];
                  while (!this.matchJSX("/") && !this.matchJSX(">")) {
                    var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                    attributes.push(attribute);
                  }
                  return attributes;
                };
                JSXParser2.prototype.parseJSXOpeningElement = function() {
                  var node2 = this.createJSXNode();
                  this.expectJSX("<");
                  var name = this.parseJSXElementName();
                  var attributes = this.parseJSXAttributes();
                  var selfClosing = this.matchJSX("/");
                  if (selfClosing) {
                    this.expectJSX("/");
                  }
                  this.expectJSX(">");
                  return this.finalize(node2, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
                };
                JSXParser2.prototype.parseJSXBoundaryElement = function() {
                  var node2 = this.createJSXNode();
                  this.expectJSX("<");
                  if (this.matchJSX("/")) {
                    this.expectJSX("/");
                    var name_3 = this.parseJSXElementName();
                    this.expectJSX(">");
                    return this.finalize(node2, new JSXNode.JSXClosingElement(name_3));
                  }
                  var name = this.parseJSXElementName();
                  var attributes = this.parseJSXAttributes();
                  var selfClosing = this.matchJSX("/");
                  if (selfClosing) {
                    this.expectJSX("/");
                  }
                  this.expectJSX(">");
                  return this.finalize(node2, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
                };
                JSXParser2.prototype.parseJSXEmptyExpression = function() {
                  var node2 = this.createJSXChildNode();
                  this.collectComments();
                  this.lastMarker.index = this.scanner.index;
                  this.lastMarker.line = this.scanner.lineNumber;
                  this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                  return this.finalize(node2, new JSXNode.JSXEmptyExpression());
                };
                JSXParser2.prototype.parseJSXExpressionContainer = function() {
                  var node2 = this.createJSXNode();
                  this.expectJSX("{");
                  var expression;
                  if (this.matchJSX("}")) {
                    expression = this.parseJSXEmptyExpression();
                    this.expectJSX("}");
                  } else {
                    this.finishJSX();
                    expression = this.parseAssignmentExpression();
                    this.reenterJSX();
                  }
                  return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
                };
                JSXParser2.prototype.parseJSXChildren = function() {
                  var children = [];
                  while (!this.scanner.eof()) {
                    var node2 = this.createJSXChildNode();
                    var token = this.nextJSXText();
                    if (token.start < token.end) {
                      var raw = this.getTokenRaw(token);
                      var child = this.finalize(node2, new JSXNode.JSXText(token.value, raw));
                      children.push(child);
                    }
                    if (this.scanner.source[this.scanner.index] === "{") {
                      var container = this.parseJSXExpressionContainer();
                      children.push(container);
                    } else {
                      break;
                    }
                  }
                  return children;
                };
                JSXParser2.prototype.parseComplexJSXElement = function(el) {
                  var stack = [];
                  while (!this.scanner.eof()) {
                    el.children = el.children.concat(this.parseJSXChildren());
                    var node2 = this.createJSXChildNode();
                    var element = this.parseJSXBoundaryElement();
                    if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                      var opening = element;
                      if (opening.selfClosing) {
                        var child = this.finalize(node2, new JSXNode.JSXElement(opening, [], null));
                        el.children.push(child);
                      } else {
                        stack.push(el);
                        el = {node: node2, opening, closing: null, children: []};
                      }
                    }
                    if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                      el.closing = element;
                      var open_1 = getQualifiedElementName(el.opening.name);
                      var close_1 = getQualifiedElementName(el.closing.name);
                      if (open_1 !== close_1) {
                        this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                      }
                      if (stack.length > 0) {
                        var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                        el = stack[stack.length - 1];
                        el.children.push(child);
                        stack.pop();
                      } else {
                        break;
                      }
                    }
                  }
                  return el;
                };
                JSXParser2.prototype.parseJSXElement = function() {
                  var node2 = this.createJSXNode();
                  var opening = this.parseJSXOpeningElement();
                  var children = [];
                  var closing = null;
                  if (!opening.selfClosing) {
                    var el = this.parseComplexJSXElement({node: node2, opening, closing, children});
                    children = el.children;
                    closing = el.closing;
                  }
                  return this.finalize(node2, new JSXNode.JSXElement(opening, children, closing));
                };
                JSXParser2.prototype.parseJSXRoot = function() {
                  if (this.config.tokens) {
                    this.tokens.pop();
                  }
                  this.startJSX();
                  var element = this.parseJSXElement();
                  this.finishJSX();
                  return element;
                };
                JSXParser2.prototype.isStartOfExpression = function() {
                  return _super.prototype.isStartOfExpression.call(this) || this.match("<");
                };
                return JSXParser2;
              }(parser_1.Parser);
              exports5.JSXParser = JSXParser;
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var Regex = {
                NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
              };
              exports5.Character = {
                fromCodePoint: function fromCodePoint(cp) {
                  return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
                },
                isWhiteSpace: function isWhiteSpace(cp) {
                  return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
                },
                isLineTerminator: function isLineTerminator(cp) {
                  return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
                },
                isIdentifierStart: function isIdentifierStart2(cp) {
                  return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports5.Character.fromCodePoint(cp));
                },
                isIdentifierPart: function isIdentifierPart(cp) {
                  return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports5.Character.fromCodePoint(cp));
                },
                isDecimalDigit: function isDecimalDigit(cp) {
                  return cp >= 48 && cp <= 57;
                },
                isHexDigit: function isHexDigit(cp) {
                  return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
                },
                isOctalDigit: function isOctalDigit(cp) {
                  return cp >= 48 && cp <= 55;
                }
              };
            }, function(module4, exports5, __webpack_require__) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var jsx_syntax_1 = __webpack_require__(6);
              var JSXClosingElement = function() {
                function JSXClosingElement2(name) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                  this.name = name;
                }
                return JSXClosingElement2;
              }();
              exports5.JSXClosingElement = JSXClosingElement;
              var JSXElement = function() {
                function JSXElement2(openingElement, children, closingElement) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                  this.openingElement = openingElement;
                  this.children = children;
                  this.closingElement = closingElement;
                }
                return JSXElement2;
              }();
              exports5.JSXElement = JSXElement;
              var JSXEmptyExpression = function() {
                function JSXEmptyExpression2() {
                  this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
                }
                return JSXEmptyExpression2;
              }();
              exports5.JSXEmptyExpression = JSXEmptyExpression;
              var JSXExpressionContainer = function() {
                function JSXExpressionContainer2(expression) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                  this.expression = expression;
                }
                return JSXExpressionContainer2;
              }();
              exports5.JSXExpressionContainer = JSXExpressionContainer;
              var JSXIdentifier = function() {
                function JSXIdentifier2(name) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                  this.name = name;
                }
                return JSXIdentifier2;
              }();
              exports5.JSXIdentifier = JSXIdentifier;
              var JSXMemberExpression = function() {
                function JSXMemberExpression2(object2, property) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                  this.object = object2;
                  this.property = property;
                }
                return JSXMemberExpression2;
              }();
              exports5.JSXMemberExpression = JSXMemberExpression;
              var JSXAttribute = function() {
                function JSXAttribute2(name, value) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                  this.name = name;
                  this.value = value;
                }
                return JSXAttribute2;
              }();
              exports5.JSXAttribute = JSXAttribute;
              var JSXNamespacedName = function() {
                function JSXNamespacedName2(namespace, name) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                  this.namespace = namespace;
                  this.name = name;
                }
                return JSXNamespacedName2;
              }();
              exports5.JSXNamespacedName = JSXNamespacedName;
              var JSXOpeningElement = function() {
                function JSXOpeningElement2(name, selfClosing, attributes) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                  this.name = name;
                  this.selfClosing = selfClosing;
                  this.attributes = attributes;
                }
                return JSXOpeningElement2;
              }();
              exports5.JSXOpeningElement = JSXOpeningElement;
              var JSXSpreadAttribute = function() {
                function JSXSpreadAttribute2(argument) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                  this.argument = argument;
                }
                return JSXSpreadAttribute2;
              }();
              exports5.JSXSpreadAttribute = JSXSpreadAttribute;
              var JSXText = function() {
                function JSXText2(value, raw) {
                  this.type = jsx_syntax_1.JSXSyntax.JSXText;
                  this.value = value;
                  this.raw = raw;
                }
                return JSXText2;
              }();
              exports5.JSXText = JSXText;
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              exports5.JSXSyntax = {JSXAttribute: "JSXAttribute", JSXClosingElement: "JSXClosingElement", JSXElement: "JSXElement", JSXEmptyExpression: "JSXEmptyExpression", JSXExpressionContainer: "JSXExpressionContainer", JSXIdentifier: "JSXIdentifier", JSXMemberExpression: "JSXMemberExpression", JSXNamespacedName: "JSXNamespacedName", JSXOpeningElement: "JSXOpeningElement", JSXSpreadAttribute: "JSXSpreadAttribute", JSXText: "JSXText"};
            }, function(module4, exports5, __webpack_require__) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var syntax_1 = __webpack_require__(2);
              var ArrayExpression = function() {
                function ArrayExpression2(elements) {
                  this.type = syntax_1.Syntax.ArrayExpression;
                  this.elements = elements;
                }
                return ArrayExpression2;
              }();
              exports5.ArrayExpression = ArrayExpression;
              var ArrayPattern = function() {
                function ArrayPattern2(elements) {
                  this.type = syntax_1.Syntax.ArrayPattern;
                  this.elements = elements;
                }
                return ArrayPattern2;
              }();
              exports5.ArrayPattern = ArrayPattern;
              var ArrowFunctionExpression = function() {
                function ArrowFunctionExpression2(params, body, expression) {
                  this.type = syntax_1.Syntax.ArrowFunctionExpression;
                  this.id = null;
                  this.params = params;
                  this.body = body;
                  this.generator = false;
                  this.expression = expression;
                  this.async = false;
                }
                return ArrowFunctionExpression2;
              }();
              exports5.ArrowFunctionExpression = ArrowFunctionExpression;
              var AssignmentExpression = function() {
                function AssignmentExpression2(operator, left, right) {
                  this.type = syntax_1.Syntax.AssignmentExpression;
                  this.operator = operator;
                  this.left = left;
                  this.right = right;
                }
                return AssignmentExpression2;
              }();
              exports5.AssignmentExpression = AssignmentExpression;
              var AssignmentPattern = function() {
                function AssignmentPattern2(left, right) {
                  this.type = syntax_1.Syntax.AssignmentPattern;
                  this.left = left;
                  this.right = right;
                }
                return AssignmentPattern2;
              }();
              exports5.AssignmentPattern = AssignmentPattern;
              var AsyncArrowFunctionExpression = function() {
                function AsyncArrowFunctionExpression2(params, body, expression) {
                  this.type = syntax_1.Syntax.ArrowFunctionExpression;
                  this.id = null;
                  this.params = params;
                  this.body = body;
                  this.generator = false;
                  this.expression = expression;
                  this.async = true;
                }
                return AsyncArrowFunctionExpression2;
              }();
              exports5.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
              var AsyncFunctionDeclaration = function() {
                function AsyncFunctionDeclaration2(id, params, body) {
                  this.type = syntax_1.Syntax.FunctionDeclaration;
                  this.id = id;
                  this.params = params;
                  this.body = body;
                  this.generator = false;
                  this.expression = false;
                  this.async = true;
                }
                return AsyncFunctionDeclaration2;
              }();
              exports5.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
              var AsyncFunctionExpression = function() {
                function AsyncFunctionExpression2(id, params, body) {
                  this.type = syntax_1.Syntax.FunctionExpression;
                  this.id = id;
                  this.params = params;
                  this.body = body;
                  this.generator = false;
                  this.expression = false;
                  this.async = true;
                }
                return AsyncFunctionExpression2;
              }();
              exports5.AsyncFunctionExpression = AsyncFunctionExpression;
              var AwaitExpression = function() {
                function AwaitExpression2(argument) {
                  this.type = syntax_1.Syntax.AwaitExpression;
                  this.argument = argument;
                }
                return AwaitExpression2;
              }();
              exports5.AwaitExpression = AwaitExpression;
              var BinaryExpression = function() {
                function BinaryExpression2(operator, left, right) {
                  var logical = operator === "||" || operator === "&&";
                  this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                  this.operator = operator;
                  this.left = left;
                  this.right = right;
                }
                return BinaryExpression2;
              }();
              exports5.BinaryExpression = BinaryExpression;
              var BlockStatement = function() {
                function BlockStatement2(body) {
                  this.type = syntax_1.Syntax.BlockStatement;
                  this.body = body;
                }
                return BlockStatement2;
              }();
              exports5.BlockStatement = BlockStatement;
              var BreakStatement = function() {
                function BreakStatement2(label) {
                  this.type = syntax_1.Syntax.BreakStatement;
                  this.label = label;
                }
                return BreakStatement2;
              }();
              exports5.BreakStatement = BreakStatement;
              var CallExpression = function() {
                function CallExpression2(callee, args) {
                  this.type = syntax_1.Syntax.CallExpression;
                  this.callee = callee;
                  this.arguments = args;
                }
                return CallExpression2;
              }();
              exports5.CallExpression = CallExpression;
              var CatchClause = function() {
                function CatchClause2(param, body) {
                  this.type = syntax_1.Syntax.CatchClause;
                  this.param = param;
                  this.body = body;
                }
                return CatchClause2;
              }();
              exports5.CatchClause = CatchClause;
              var ClassBody = function() {
                function ClassBody2(body) {
                  this.type = syntax_1.Syntax.ClassBody;
                  this.body = body;
                }
                return ClassBody2;
              }();
              exports5.ClassBody = ClassBody;
              var ClassDeclaration = function() {
                function ClassDeclaration2(id, superClass, body) {
                  this.type = syntax_1.Syntax.ClassDeclaration;
                  this.id = id;
                  this.superClass = superClass;
                  this.body = body;
                }
                return ClassDeclaration2;
              }();
              exports5.ClassDeclaration = ClassDeclaration;
              var ClassExpression = function() {
                function ClassExpression2(id, superClass, body) {
                  this.type = syntax_1.Syntax.ClassExpression;
                  this.id = id;
                  this.superClass = superClass;
                  this.body = body;
                }
                return ClassExpression2;
              }();
              exports5.ClassExpression = ClassExpression;
              var ComputedMemberExpression = function() {
                function ComputedMemberExpression2(object2, property) {
                  this.type = syntax_1.Syntax.MemberExpression;
                  this.computed = true;
                  this.object = object2;
                  this.property = property;
                }
                return ComputedMemberExpression2;
              }();
              exports5.ComputedMemberExpression = ComputedMemberExpression;
              var ConditionalExpression = function() {
                function ConditionalExpression2(test, consequent, alternate) {
                  this.type = syntax_1.Syntax.ConditionalExpression;
                  this.test = test;
                  this.consequent = consequent;
                  this.alternate = alternate;
                }
                return ConditionalExpression2;
              }();
              exports5.ConditionalExpression = ConditionalExpression;
              var ContinueStatement = function() {
                function ContinueStatement2(label) {
                  this.type = syntax_1.Syntax.ContinueStatement;
                  this.label = label;
                }
                return ContinueStatement2;
              }();
              exports5.ContinueStatement = ContinueStatement;
              var DebuggerStatement = function() {
                function DebuggerStatement2() {
                  this.type = syntax_1.Syntax.DebuggerStatement;
                }
                return DebuggerStatement2;
              }();
              exports5.DebuggerStatement = DebuggerStatement;
              var Directive = function() {
                function Directive2(expression, directive) {
                  this.type = syntax_1.Syntax.ExpressionStatement;
                  this.expression = expression;
                  this.directive = directive;
                }
                return Directive2;
              }();
              exports5.Directive = Directive;
              var DoWhileStatement = function() {
                function DoWhileStatement2(body, test) {
                  this.type = syntax_1.Syntax.DoWhileStatement;
                  this.body = body;
                  this.test = test;
                }
                return DoWhileStatement2;
              }();
              exports5.DoWhileStatement = DoWhileStatement;
              var EmptyStatement = function() {
                function EmptyStatement2() {
                  this.type = syntax_1.Syntax.EmptyStatement;
                }
                return EmptyStatement2;
              }();
              exports5.EmptyStatement = EmptyStatement;
              var ExportAllDeclaration = function() {
                function ExportAllDeclaration2(source) {
                  this.type = syntax_1.Syntax.ExportAllDeclaration;
                  this.source = source;
                }
                return ExportAllDeclaration2;
              }();
              exports5.ExportAllDeclaration = ExportAllDeclaration;
              var ExportDefaultDeclaration = function() {
                function ExportDefaultDeclaration2(declaration) {
                  this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                  this.declaration = declaration;
                }
                return ExportDefaultDeclaration2;
              }();
              exports5.ExportDefaultDeclaration = ExportDefaultDeclaration;
              var ExportNamedDeclaration = function() {
                function ExportNamedDeclaration2(declaration, specifiers, source) {
                  this.type = syntax_1.Syntax.ExportNamedDeclaration;
                  this.declaration = declaration;
                  this.specifiers = specifiers;
                  this.source = source;
                }
                return ExportNamedDeclaration2;
              }();
              exports5.ExportNamedDeclaration = ExportNamedDeclaration;
              var ExportSpecifier = function() {
                function ExportSpecifier2(local, exported) {
                  this.type = syntax_1.Syntax.ExportSpecifier;
                  this.exported = exported;
                  this.local = local;
                }
                return ExportSpecifier2;
              }();
              exports5.ExportSpecifier = ExportSpecifier;
              var ExpressionStatement = function() {
                function ExpressionStatement2(expression) {
                  this.type = syntax_1.Syntax.ExpressionStatement;
                  this.expression = expression;
                }
                return ExpressionStatement2;
              }();
              exports5.ExpressionStatement = ExpressionStatement;
              var ForInStatement = function() {
                function ForInStatement2(left, right, body) {
                  this.type = syntax_1.Syntax.ForInStatement;
                  this.left = left;
                  this.right = right;
                  this.body = body;
                  this.each = false;
                }
                return ForInStatement2;
              }();
              exports5.ForInStatement = ForInStatement;
              var ForOfStatement = function() {
                function ForOfStatement2(left, right, body) {
                  this.type = syntax_1.Syntax.ForOfStatement;
                  this.left = left;
                  this.right = right;
                  this.body = body;
                }
                return ForOfStatement2;
              }();
              exports5.ForOfStatement = ForOfStatement;
              var ForStatement = function() {
                function ForStatement2(init2, test, update, body) {
                  this.type = syntax_1.Syntax.ForStatement;
                  this.init = init2;
                  this.test = test;
                  this.update = update;
                  this.body = body;
                }
                return ForStatement2;
              }();
              exports5.ForStatement = ForStatement;
              var FunctionDeclaration = function() {
                function FunctionDeclaration2(id, params, body, generator) {
                  this.type = syntax_1.Syntax.FunctionDeclaration;
                  this.id = id;
                  this.params = params;
                  this.body = body;
                  this.generator = generator;
                  this.expression = false;
                  this.async = false;
                }
                return FunctionDeclaration2;
              }();
              exports5.FunctionDeclaration = FunctionDeclaration;
              var FunctionExpression = function() {
                function FunctionExpression2(id, params, body, generator) {
                  this.type = syntax_1.Syntax.FunctionExpression;
                  this.id = id;
                  this.params = params;
                  this.body = body;
                  this.generator = generator;
                  this.expression = false;
                  this.async = false;
                }
                return FunctionExpression2;
              }();
              exports5.FunctionExpression = FunctionExpression;
              var Identifier = function() {
                function Identifier2(name) {
                  this.type = syntax_1.Syntax.Identifier;
                  this.name = name;
                }
                return Identifier2;
              }();
              exports5.Identifier = Identifier;
              var IfStatement = function() {
                function IfStatement2(test, consequent, alternate) {
                  this.type = syntax_1.Syntax.IfStatement;
                  this.test = test;
                  this.consequent = consequent;
                  this.alternate = alternate;
                }
                return IfStatement2;
              }();
              exports5.IfStatement = IfStatement;
              var ImportDeclaration = function() {
                function ImportDeclaration2(specifiers, source) {
                  this.type = syntax_1.Syntax.ImportDeclaration;
                  this.specifiers = specifiers;
                  this.source = source;
                }
                return ImportDeclaration2;
              }();
              exports5.ImportDeclaration = ImportDeclaration;
              var ImportDefaultSpecifier = function() {
                function ImportDefaultSpecifier2(local) {
                  this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                  this.local = local;
                }
                return ImportDefaultSpecifier2;
              }();
              exports5.ImportDefaultSpecifier = ImportDefaultSpecifier;
              var ImportNamespaceSpecifier = function() {
                function ImportNamespaceSpecifier2(local) {
                  this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                  this.local = local;
                }
                return ImportNamespaceSpecifier2;
              }();
              exports5.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
              var ImportSpecifier = function() {
                function ImportSpecifier2(local, imported) {
                  this.type = syntax_1.Syntax.ImportSpecifier;
                  this.local = local;
                  this.imported = imported;
                }
                return ImportSpecifier2;
              }();
              exports5.ImportSpecifier = ImportSpecifier;
              var LabeledStatement = function() {
                function LabeledStatement2(label, body) {
                  this.type = syntax_1.Syntax.LabeledStatement;
                  this.label = label;
                  this.body = body;
                }
                return LabeledStatement2;
              }();
              exports5.LabeledStatement = LabeledStatement;
              var Literal = function() {
                function Literal2(value, raw) {
                  this.type = syntax_1.Syntax.Literal;
                  this.value = value;
                  this.raw = raw;
                }
                return Literal2;
              }();
              exports5.Literal = Literal;
              var MetaProperty = function() {
                function MetaProperty2(meta, property) {
                  this.type = syntax_1.Syntax.MetaProperty;
                  this.meta = meta;
                  this.property = property;
                }
                return MetaProperty2;
              }();
              exports5.MetaProperty = MetaProperty;
              var MethodDefinition = function() {
                function MethodDefinition2(key, computed, value, kind, isStatic) {
                  this.type = syntax_1.Syntax.MethodDefinition;
                  this.key = key;
                  this.computed = computed;
                  this.value = value;
                  this.kind = kind;
                  this.static = isStatic;
                }
                return MethodDefinition2;
              }();
              exports5.MethodDefinition = MethodDefinition;
              var Module = function() {
                function Module2(body) {
                  this.type = syntax_1.Syntax.Program;
                  this.body = body;
                  this.sourceType = "module";
                }
                return Module2;
              }();
              exports5.Module = Module;
              var NewExpression = function() {
                function NewExpression2(callee, args) {
                  this.type = syntax_1.Syntax.NewExpression;
                  this.callee = callee;
                  this.arguments = args;
                }
                return NewExpression2;
              }();
              exports5.NewExpression = NewExpression;
              var ObjectExpression = function() {
                function ObjectExpression2(properties) {
                  this.type = syntax_1.Syntax.ObjectExpression;
                  this.properties = properties;
                }
                return ObjectExpression2;
              }();
              exports5.ObjectExpression = ObjectExpression;
              var ObjectPattern = function() {
                function ObjectPattern2(properties) {
                  this.type = syntax_1.Syntax.ObjectPattern;
                  this.properties = properties;
                }
                return ObjectPattern2;
              }();
              exports5.ObjectPattern = ObjectPattern;
              var Property = function() {
                function Property2(kind, key, computed, value, method, shorthand) {
                  this.type = syntax_1.Syntax.Property;
                  this.key = key;
                  this.computed = computed;
                  this.value = value;
                  this.kind = kind;
                  this.method = method;
                  this.shorthand = shorthand;
                }
                return Property2;
              }();
              exports5.Property = Property;
              var RegexLiteral = function() {
                function RegexLiteral2(value, raw, pattern, flags) {
                  this.type = syntax_1.Syntax.Literal;
                  this.value = value;
                  this.raw = raw;
                  this.regex = {pattern, flags};
                }
                return RegexLiteral2;
              }();
              exports5.RegexLiteral = RegexLiteral;
              var RestElement = function() {
                function RestElement2(argument) {
                  this.type = syntax_1.Syntax.RestElement;
                  this.argument = argument;
                }
                return RestElement2;
              }();
              exports5.RestElement = RestElement;
              var ReturnStatement = function() {
                function ReturnStatement2(argument) {
                  this.type = syntax_1.Syntax.ReturnStatement;
                  this.argument = argument;
                }
                return ReturnStatement2;
              }();
              exports5.ReturnStatement = ReturnStatement;
              var Script = function() {
                function Script2(body) {
                  this.type = syntax_1.Syntax.Program;
                  this.body = body;
                  this.sourceType = "script";
                }
                return Script2;
              }();
              exports5.Script = Script;
              var SequenceExpression = function() {
                function SequenceExpression2(expressions2) {
                  this.type = syntax_1.Syntax.SequenceExpression;
                  this.expressions = expressions2;
                }
                return SequenceExpression2;
              }();
              exports5.SequenceExpression = SequenceExpression;
              var SpreadElement = function() {
                function SpreadElement2(argument) {
                  this.type = syntax_1.Syntax.SpreadElement;
                  this.argument = argument;
                }
                return SpreadElement2;
              }();
              exports5.SpreadElement = SpreadElement;
              var StaticMemberExpression = function() {
                function StaticMemberExpression2(object2, property) {
                  this.type = syntax_1.Syntax.MemberExpression;
                  this.computed = false;
                  this.object = object2;
                  this.property = property;
                }
                return StaticMemberExpression2;
              }();
              exports5.StaticMemberExpression = StaticMemberExpression;
              var Super = function() {
                function Super2() {
                  this.type = syntax_1.Syntax.Super;
                }
                return Super2;
              }();
              exports5.Super = Super;
              var SwitchCase = function() {
                function SwitchCase2(test, consequent) {
                  this.type = syntax_1.Syntax.SwitchCase;
                  this.test = test;
                  this.consequent = consequent;
                }
                return SwitchCase2;
              }();
              exports5.SwitchCase = SwitchCase;
              var SwitchStatement = function() {
                function SwitchStatement2(discriminant, cases) {
                  this.type = syntax_1.Syntax.SwitchStatement;
                  this.discriminant = discriminant;
                  this.cases = cases;
                }
                return SwitchStatement2;
              }();
              exports5.SwitchStatement = SwitchStatement;
              var TaggedTemplateExpression = function() {
                function TaggedTemplateExpression2(tag2, quasi) {
                  this.type = syntax_1.Syntax.TaggedTemplateExpression;
                  this.tag = tag2;
                  this.quasi = quasi;
                }
                return TaggedTemplateExpression2;
              }();
              exports5.TaggedTemplateExpression = TaggedTemplateExpression;
              var TemplateElement = function() {
                function TemplateElement2(value, tail) {
                  this.type = syntax_1.Syntax.TemplateElement;
                  this.value = value;
                  this.tail = tail;
                }
                return TemplateElement2;
              }();
              exports5.TemplateElement = TemplateElement;
              var TemplateLiteral = function() {
                function TemplateLiteral2(quasis, expressions2) {
                  this.type = syntax_1.Syntax.TemplateLiteral;
                  this.quasis = quasis;
                  this.expressions = expressions2;
                }
                return TemplateLiteral2;
              }();
              exports5.TemplateLiteral = TemplateLiteral;
              var ThisExpression = function() {
                function ThisExpression2() {
                  this.type = syntax_1.Syntax.ThisExpression;
                }
                return ThisExpression2;
              }();
              exports5.ThisExpression = ThisExpression;
              var ThrowStatement = function() {
                function ThrowStatement2(argument) {
                  this.type = syntax_1.Syntax.ThrowStatement;
                  this.argument = argument;
                }
                return ThrowStatement2;
              }();
              exports5.ThrowStatement = ThrowStatement;
              var TryStatement = function() {
                function TryStatement2(block, handler, finalizer) {
                  this.type = syntax_1.Syntax.TryStatement;
                  this.block = block;
                  this.handler = handler;
                  this.finalizer = finalizer;
                }
                return TryStatement2;
              }();
              exports5.TryStatement = TryStatement;
              var UnaryExpression = function() {
                function UnaryExpression2(operator, argument) {
                  this.type = syntax_1.Syntax.UnaryExpression;
                  this.operator = operator;
                  this.argument = argument;
                  this.prefix = true;
                }
                return UnaryExpression2;
              }();
              exports5.UnaryExpression = UnaryExpression;
              var UpdateExpression = function() {
                function UpdateExpression2(operator, argument, prefix2) {
                  this.type = syntax_1.Syntax.UpdateExpression;
                  this.operator = operator;
                  this.argument = argument;
                  this.prefix = prefix2;
                }
                return UpdateExpression2;
              }();
              exports5.UpdateExpression = UpdateExpression;
              var VariableDeclaration = function() {
                function VariableDeclaration2(declarations, kind) {
                  this.type = syntax_1.Syntax.VariableDeclaration;
                  this.declarations = declarations;
                  this.kind = kind;
                }
                return VariableDeclaration2;
              }();
              exports5.VariableDeclaration = VariableDeclaration;
              var VariableDeclarator = function() {
                function VariableDeclarator2(id, init2) {
                  this.type = syntax_1.Syntax.VariableDeclarator;
                  this.id = id;
                  this.init = init2;
                }
                return VariableDeclarator2;
              }();
              exports5.VariableDeclarator = VariableDeclarator;
              var WhileStatement = function() {
                function WhileStatement2(test, body) {
                  this.type = syntax_1.Syntax.WhileStatement;
                  this.test = test;
                  this.body = body;
                }
                return WhileStatement2;
              }();
              exports5.WhileStatement = WhileStatement;
              var WithStatement = function() {
                function WithStatement2(object2, body) {
                  this.type = syntax_1.Syntax.WithStatement;
                  this.object = object2;
                  this.body = body;
                }
                return WithStatement2;
              }();
              exports5.WithStatement = WithStatement;
              var YieldExpression = function() {
                function YieldExpression2(argument, delegate) {
                  this.type = syntax_1.Syntax.YieldExpression;
                  this.argument = argument;
                  this.delegate = delegate;
                }
                return YieldExpression2;
              }();
              exports5.YieldExpression = YieldExpression;
            }, function(module4, exports5, __webpack_require__) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var assert_12 = __webpack_require__(9);
              var error_handler_1 = __webpack_require__(10);
              var messages_1 = __webpack_require__(11);
              var Node3 = __webpack_require__(7);
              var scanner_1 = __webpack_require__(12);
              var syntax_1 = __webpack_require__(2);
              var token_1 = __webpack_require__(13);
              var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
              var Parser2 = function() {
                function Parser3(code, options2, delegate) {
                  if (options2 === void 0) {
                    options2 = {};
                  }
                  this.config = {range: typeof options2.range === "boolean" && options2.range, loc: typeof options2.loc === "boolean" && options2.loc, source: null, tokens: typeof options2.tokens === "boolean" && options2.tokens, comment: typeof options2.comment === "boolean" && options2.comment, tolerant: typeof options2.tolerant === "boolean" && options2.tolerant};
                  if (this.config.loc && options2.source && options2.source !== null) {
                    this.config.source = String(options2.source);
                  }
                  this.delegate = delegate;
                  this.errorHandler = new error_handler_1.ErrorHandler();
                  this.errorHandler.tolerant = this.config.tolerant;
                  this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                  this.scanner.trackComment = this.config.comment;
                  this.operatorPrecedence = {")": 0, ";": 0, ",": 0, "=": 0, "]": 0, "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 11, "/": 11, "%": 11};
                  this.lookahead = {type: 2, value: "", lineNumber: this.scanner.lineNumber, lineStart: 0, start: 0, end: 0};
                  this.hasLineTerminator = false;
                  this.context = {isModule: false, await: false, allowIn: true, allowStrictDirective: true, allowYield: true, firstCoverInitializedNameError: null, isAssignmentTarget: false, isBindingElement: false, inFunctionBody: false, inIteration: false, inSwitch: false, labelSet: {}, strict: false};
                  this.tokens = [];
                  this.startMarker = {index: 0, line: this.scanner.lineNumber, column: 0};
                  this.lastMarker = {index: 0, line: this.scanner.lineNumber, column: 0};
                  this.nextToken();
                  this.lastMarker = {index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                }
                Parser3.prototype.throwError = function(messageFormat) {
                  var values = [];
                  for (var _i = 1; _i < arguments.length; _i++) {
                    values[_i - 1] = arguments[_i];
                  }
                  var args = Array.prototype.slice.call(arguments, 1);
                  var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                    assert_12.assert(idx < args.length, "Message reference must be in range");
                    return args[idx];
                  });
                  var index = this.lastMarker.index;
                  var line = this.lastMarker.line;
                  var column = this.lastMarker.column + 1;
                  throw this.errorHandler.createError(index, line, column, msg);
                };
                Parser3.prototype.tolerateError = function(messageFormat) {
                  var values = [];
                  for (var _i = 1; _i < arguments.length; _i++) {
                    values[_i - 1] = arguments[_i];
                  }
                  var args = Array.prototype.slice.call(arguments, 1);
                  var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                    assert_12.assert(idx < args.length, "Message reference must be in range");
                    return args[idx];
                  });
                  var index = this.lastMarker.index;
                  var line = this.scanner.lineNumber;
                  var column = this.lastMarker.column + 1;
                  this.errorHandler.tolerateError(index, line, column, msg);
                };
                Parser3.prototype.unexpectedTokenError = function(token, message) {
                  var msg = message || messages_1.Messages.UnexpectedToken;
                  var value;
                  if (token) {
                    if (!message) {
                      msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                      if (token.type === 4) {
                        if (this.scanner.isFutureReservedWord(token.value)) {
                          msg = messages_1.Messages.UnexpectedReserved;
                        } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                          msg = messages_1.Messages.StrictReservedWord;
                        }
                      }
                    }
                    value = token.value;
                  } else {
                    value = "ILLEGAL";
                  }
                  msg = msg.replace("%0", value);
                  if (token && typeof token.lineNumber === "number") {
                    var index = token.start;
                    var line = token.lineNumber;
                    var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                    var column = token.start - lastMarkerLineStart + 1;
                    return this.errorHandler.createError(index, line, column, msg);
                  } else {
                    var index = this.lastMarker.index;
                    var line = this.lastMarker.line;
                    var column = this.lastMarker.column + 1;
                    return this.errorHandler.createError(index, line, column, msg);
                  }
                };
                Parser3.prototype.throwUnexpectedToken = function(token, message) {
                  throw this.unexpectedTokenError(token, message);
                };
                Parser3.prototype.tolerateUnexpectedToken = function(token, message) {
                  this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
                };
                Parser3.prototype.collectComments = function() {
                  if (!this.config.comment) {
                    this.scanner.scanComments();
                  } else {
                    var comments2 = this.scanner.scanComments();
                    if (comments2.length > 0 && this.delegate) {
                      for (var i = 0; i < comments2.length; ++i) {
                        var e = comments2[i];
                        var node2 = void 0;
                        node2 = {type: e.multiLine ? "BlockComment" : "LineComment", value: this.scanner.source.slice(e.slice[0], e.slice[1])};
                        if (this.config.range) {
                          node2.range = e.range;
                        }
                        if (this.config.loc) {
                          node2.loc = e.loc;
                        }
                        var metadata = {start: {line: e.loc.start.line, column: e.loc.start.column, offset: e.range[0]}, end: {line: e.loc.end.line, column: e.loc.end.column, offset: e.range[1]}};
                        this.delegate(node2, metadata);
                      }
                    }
                  }
                };
                Parser3.prototype.getTokenRaw = function(token) {
                  return this.scanner.source.slice(token.start, token.end);
                };
                Parser3.prototype.convertToken = function(token) {
                  var t = {type: token_1.TokenName[token.type], value: this.getTokenRaw(token)};
                  if (this.config.range) {
                    t.range = [token.start, token.end];
                  }
                  if (this.config.loc) {
                    t.loc = {start: {line: this.startMarker.line, column: this.startMarker.column}, end: {line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart}};
                  }
                  if (token.type === 9) {
                    var pattern = token.pattern;
                    var flags = token.flags;
                    t.regex = {pattern, flags};
                  }
                  return t;
                };
                Parser3.prototype.nextToken = function() {
                  var token = this.lookahead;
                  this.lastMarker.index = this.scanner.index;
                  this.lastMarker.line = this.scanner.lineNumber;
                  this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                  this.collectComments();
                  if (this.scanner.index !== this.startMarker.index) {
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                  }
                  var next = this.scanner.lex();
                  this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                  if (next && this.context.strict && next.type === 3) {
                    if (this.scanner.isStrictModeReservedWord(next.value)) {
                      next.type = 4;
                    }
                  }
                  this.lookahead = next;
                  if (this.config.tokens && next.type !== 2) {
                    this.tokens.push(this.convertToken(next));
                  }
                  return token;
                };
                Parser3.prototype.nextRegexToken = function() {
                  this.collectComments();
                  var token = this.scanner.scanRegExp();
                  if (this.config.tokens) {
                    this.tokens.pop();
                    this.tokens.push(this.convertToken(token));
                  }
                  this.lookahead = token;
                  this.nextToken();
                  return token;
                };
                Parser3.prototype.createNode = function() {
                  return {index: this.startMarker.index, line: this.startMarker.line, column: this.startMarker.column};
                };
                Parser3.prototype.startNode = function(token, lastLineStart) {
                  if (lastLineStart === void 0) {
                    lastLineStart = 0;
                  }
                  var column = token.start - token.lineStart;
                  var line = token.lineNumber;
                  if (column < 0) {
                    column += lastLineStart;
                    line--;
                  }
                  return {index: token.start, line, column};
                };
                Parser3.prototype.finalize = function(marker, node2) {
                  if (this.config.range) {
                    node2.range = [marker.index, this.lastMarker.index];
                  }
                  if (this.config.loc) {
                    node2.loc = {start: {line: marker.line, column: marker.column}, end: {line: this.lastMarker.line, column: this.lastMarker.column}};
                    if (this.config.source) {
                      node2.loc.source = this.config.source;
                    }
                  }
                  if (this.delegate) {
                    var metadata = {start: {line: marker.line, column: marker.column, offset: marker.index}, end: {line: this.lastMarker.line, column: this.lastMarker.column, offset: this.lastMarker.index}};
                    this.delegate(node2, metadata);
                  }
                  return node2;
                };
                Parser3.prototype.expect = function(value) {
                  var token = this.nextToken();
                  if (token.type !== 7 || token.value !== value) {
                    this.throwUnexpectedToken(token);
                  }
                };
                Parser3.prototype.expectCommaSeparator = function() {
                  if (this.config.tolerant) {
                    var token = this.lookahead;
                    if (token.type === 7 && token.value === ",") {
                      this.nextToken();
                    } else if (token.type === 7 && token.value === ";") {
                      this.nextToken();
                      this.tolerateUnexpectedToken(token);
                    } else {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                    }
                  } else {
                    this.expect(",");
                  }
                };
                Parser3.prototype.expectKeyword = function(keyword) {
                  var token = this.nextToken();
                  if (token.type !== 4 || token.value !== keyword) {
                    this.throwUnexpectedToken(token);
                  }
                };
                Parser3.prototype.match = function(value) {
                  return this.lookahead.type === 7 && this.lookahead.value === value;
                };
                Parser3.prototype.matchKeyword = function(keyword) {
                  return this.lookahead.type === 4 && this.lookahead.value === keyword;
                };
                Parser3.prototype.matchContextualKeyword = function(keyword) {
                  return this.lookahead.type === 3 && this.lookahead.value === keyword;
                };
                Parser3.prototype.matchAssign = function() {
                  if (this.lookahead.type !== 7) {
                    return false;
                  }
                  var op = this.lookahead.value;
                  return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
                };
                Parser3.prototype.isolateCoverGrammar = function(parseFunction) {
                  var previousIsBindingElement = this.context.isBindingElement;
                  var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                  var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                  this.context.isBindingElement = true;
                  this.context.isAssignmentTarget = true;
                  this.context.firstCoverInitializedNameError = null;
                  var result = parseFunction.call(this);
                  if (this.context.firstCoverInitializedNameError !== null) {
                    this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                  }
                  this.context.isBindingElement = previousIsBindingElement;
                  this.context.isAssignmentTarget = previousIsAssignmentTarget;
                  this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                  return result;
                };
                Parser3.prototype.inheritCoverGrammar = function(parseFunction) {
                  var previousIsBindingElement = this.context.isBindingElement;
                  var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                  var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                  this.context.isBindingElement = true;
                  this.context.isAssignmentTarget = true;
                  this.context.firstCoverInitializedNameError = null;
                  var result = parseFunction.call(this);
                  this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                  this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                  this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                  return result;
                };
                Parser3.prototype.consumeSemicolon = function() {
                  if (this.match(";")) {
                    this.nextToken();
                  } else if (!this.hasLineTerminator) {
                    if (this.lookahead.type !== 2 && !this.match("}")) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    this.lastMarker.index = this.startMarker.index;
                    this.lastMarker.line = this.startMarker.line;
                    this.lastMarker.column = this.startMarker.column;
                  }
                };
                Parser3.prototype.parsePrimaryExpression = function() {
                  var node2 = this.createNode();
                  var expr2;
                  var token, raw;
                  switch (this.lookahead.type) {
                    case 3:
                      if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                        this.tolerateUnexpectedToken(this.lookahead);
                      }
                      expr2 = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node2, new Node3.Identifier(this.nextToken().value));
                      break;
                    case 6:
                    case 8:
                      if (this.context.strict && this.lookahead.octal) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                      }
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      token = this.nextToken();
                      raw = this.getTokenRaw(token);
                      expr2 = this.finalize(node2, new Node3.Literal(token.value, raw));
                      break;
                    case 1:
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      token = this.nextToken();
                      raw = this.getTokenRaw(token);
                      expr2 = this.finalize(node2, new Node3.Literal(token.value === "true", raw));
                      break;
                    case 5:
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      token = this.nextToken();
                      raw = this.getTokenRaw(token);
                      expr2 = this.finalize(node2, new Node3.Literal(null, raw));
                      break;
                    case 10:
                      expr2 = this.parseTemplateLiteral();
                      break;
                    case 7:
                      switch (this.lookahead.value) {
                        case "(":
                          this.context.isBindingElement = false;
                          expr2 = this.inheritCoverGrammar(this.parseGroupExpression);
                          break;
                        case "[":
                          expr2 = this.inheritCoverGrammar(this.parseArrayInitializer);
                          break;
                        case "{":
                          expr2 = this.inheritCoverGrammar(this.parseObjectInitializer);
                          break;
                        case "/":
                        case "/=":
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                          this.scanner.index = this.startMarker.index;
                          token = this.nextRegexToken();
                          raw = this.getTokenRaw(token);
                          expr2 = this.finalize(node2, new Node3.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                          break;
                        default:
                          expr2 = this.throwUnexpectedToken(this.nextToken());
                      }
                      break;
                    case 4:
                      if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                        expr2 = this.parseIdentifierName();
                      } else if (!this.context.strict && this.matchKeyword("let")) {
                        expr2 = this.finalize(node2, new Node3.Identifier(this.nextToken().value));
                      } else {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        if (this.matchKeyword("function")) {
                          expr2 = this.parseFunctionExpression();
                        } else if (this.matchKeyword("this")) {
                          this.nextToken();
                          expr2 = this.finalize(node2, new Node3.ThisExpression());
                        } else if (this.matchKeyword("class")) {
                          expr2 = this.parseClassExpression();
                        } else {
                          expr2 = this.throwUnexpectedToken(this.nextToken());
                        }
                      }
                      break;
                    default:
                      expr2 = this.throwUnexpectedToken(this.nextToken());
                  }
                  return expr2;
                };
                Parser3.prototype.parseSpreadElement = function() {
                  var node2 = this.createNode();
                  this.expect("...");
                  var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  return this.finalize(node2, new Node3.SpreadElement(arg));
                };
                Parser3.prototype.parseArrayInitializer = function() {
                  var node2 = this.createNode();
                  var elements = [];
                  this.expect("[");
                  while (!this.match("]")) {
                    if (this.match(",")) {
                      this.nextToken();
                      elements.push(null);
                    } else if (this.match("...")) {
                      var element = this.parseSpreadElement();
                      if (!this.match("]")) {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        this.expect(",");
                      }
                      elements.push(element);
                    } else {
                      elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                      if (!this.match("]")) {
                        this.expect(",");
                      }
                    }
                  }
                  this.expect("]");
                  return this.finalize(node2, new Node3.ArrayExpression(elements));
                };
                Parser3.prototype.parsePropertyMethod = function(params) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var previousStrict = this.context.strict;
                  var previousAllowStrictDirective = this.context.allowStrictDirective;
                  this.context.allowStrictDirective = params.simple;
                  var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                  if (this.context.strict && params.firstRestricted) {
                    this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                  }
                  if (this.context.strict && params.stricted) {
                    this.tolerateUnexpectedToken(params.stricted, params.message);
                  }
                  this.context.strict = previousStrict;
                  this.context.allowStrictDirective = previousAllowStrictDirective;
                  return body;
                };
                Parser3.prototype.parsePropertyMethodFunction = function() {
                  var isGenerator = false;
                  var node2 = this.createNode();
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = true;
                  var params = this.parseFormalParameters();
                  var method = this.parsePropertyMethod(params);
                  this.context.allowYield = previousAllowYield;
                  return this.finalize(node2, new Node3.FunctionExpression(null, params.params, method, isGenerator));
                };
                Parser3.prototype.parsePropertyMethodAsyncFunction = function() {
                  var node2 = this.createNode();
                  var previousAllowYield = this.context.allowYield;
                  var previousAwait = this.context.await;
                  this.context.allowYield = false;
                  this.context.await = true;
                  var params = this.parseFormalParameters();
                  var method = this.parsePropertyMethod(params);
                  this.context.allowYield = previousAllowYield;
                  this.context.await = previousAwait;
                  return this.finalize(node2, new Node3.AsyncFunctionExpression(null, params.params, method));
                };
                Parser3.prototype.parseObjectPropertyKey = function() {
                  var node2 = this.createNode();
                  var token = this.nextToken();
                  var key;
                  switch (token.type) {
                    case 8:
                    case 6:
                      if (this.context.strict && token.octal) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                      }
                      var raw = this.getTokenRaw(token);
                      key = this.finalize(node2, new Node3.Literal(token.value, raw));
                      break;
                    case 3:
                    case 1:
                    case 5:
                    case 4:
                      key = this.finalize(node2, new Node3.Identifier(token.value));
                      break;
                    case 7:
                      if (token.value === "[") {
                        key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        this.expect("]");
                      } else {
                        key = this.throwUnexpectedToken(token);
                      }
                      break;
                    default:
                      key = this.throwUnexpectedToken(token);
                  }
                  return key;
                };
                Parser3.prototype.isPropertyKey = function(key, value) {
                  return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
                };
                Parser3.prototype.parseObjectProperty = function(hasProto) {
                  var node2 = this.createNode();
                  var token = this.lookahead;
                  var kind;
                  var key = null;
                  var value = null;
                  var computed = false;
                  var method = false;
                  var shorthand = false;
                  var isAsync = false;
                  if (token.type === 3) {
                    var id = token.value;
                    this.nextToken();
                    computed = this.match("[");
                    isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                    key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node2, new Node3.Identifier(id));
                  } else if (this.match("*")) {
                    this.nextToken();
                  } else {
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                  }
                  var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                  if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                    kind = "get";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    this.context.allowYield = false;
                    value = this.parseGetterMethod();
                  } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                    kind = "set";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    value = this.parseSetterMethod();
                  } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                    kind = "init";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    value = this.parseGeneratorMethod();
                    method = true;
                  } else {
                    if (!key) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    kind = "init";
                    if (this.match(":") && !isAsync) {
                      if (!computed && this.isPropertyKey(key, "__proto__")) {
                        if (hasProto.value) {
                          this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                        }
                        hasProto.value = true;
                      }
                      this.nextToken();
                      value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    } else if (this.match("(")) {
                      value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                      method = true;
                    } else if (token.type === 3) {
                      var id = this.finalize(node2, new Node3.Identifier(token.value));
                      if (this.match("=")) {
                        this.context.firstCoverInitializedNameError = this.lookahead;
                        this.nextToken();
                        shorthand = true;
                        var init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        value = this.finalize(node2, new Node3.AssignmentPattern(id, init2));
                      } else {
                        shorthand = true;
                        value = id;
                      }
                    } else {
                      this.throwUnexpectedToken(this.nextToken());
                    }
                  }
                  return this.finalize(node2, new Node3.Property(kind, key, computed, value, method, shorthand));
                };
                Parser3.prototype.parseObjectInitializer = function() {
                  var node2 = this.createNode();
                  this.expect("{");
                  var properties = [];
                  var hasProto = {value: false};
                  while (!this.match("}")) {
                    properties.push(this.parseObjectProperty(hasProto));
                    if (!this.match("}")) {
                      this.expectCommaSeparator();
                    }
                  }
                  this.expect("}");
                  return this.finalize(node2, new Node3.ObjectExpression(properties));
                };
                Parser3.prototype.parseTemplateHead = function() {
                  assert_12.assert(this.lookahead.head, "Template literal must start with a template head");
                  var node2 = this.createNode();
                  var token = this.nextToken();
                  var raw = token.value;
                  var cooked = token.cooked;
                  return this.finalize(node2, new Node3.TemplateElement({raw, cooked}, token.tail));
                };
                Parser3.prototype.parseTemplateElement = function() {
                  if (this.lookahead.type !== 10) {
                    this.throwUnexpectedToken();
                  }
                  var node2 = this.createNode();
                  var token = this.nextToken();
                  var raw = token.value;
                  var cooked = token.cooked;
                  return this.finalize(node2, new Node3.TemplateElement({raw, cooked}, token.tail));
                };
                Parser3.prototype.parseTemplateLiteral = function() {
                  var node2 = this.createNode();
                  var expressions2 = [];
                  var quasis = [];
                  var quasi = this.parseTemplateHead();
                  quasis.push(quasi);
                  while (!quasi.tail) {
                    expressions2.push(this.parseExpression());
                    quasi = this.parseTemplateElement();
                    quasis.push(quasi);
                  }
                  return this.finalize(node2, new Node3.TemplateLiteral(quasis, expressions2));
                };
                Parser3.prototype.reinterpretExpressionAsPattern = function(expr2) {
                  switch (expr2.type) {
                    case syntax_1.Syntax.Identifier:
                    case syntax_1.Syntax.MemberExpression:
                    case syntax_1.Syntax.RestElement:
                    case syntax_1.Syntax.AssignmentPattern:
                      break;
                    case syntax_1.Syntax.SpreadElement:
                      expr2.type = syntax_1.Syntax.RestElement;
                      this.reinterpretExpressionAsPattern(expr2.argument);
                      break;
                    case syntax_1.Syntax.ArrayExpression:
                      expr2.type = syntax_1.Syntax.ArrayPattern;
                      for (var i = 0; i < expr2.elements.length; i++) {
                        if (expr2.elements[i] !== null) {
                          this.reinterpretExpressionAsPattern(expr2.elements[i]);
                        }
                      }
                      break;
                    case syntax_1.Syntax.ObjectExpression:
                      expr2.type = syntax_1.Syntax.ObjectPattern;
                      for (var i = 0; i < expr2.properties.length; i++) {
                        this.reinterpretExpressionAsPattern(expr2.properties[i].value);
                      }
                      break;
                    case syntax_1.Syntax.AssignmentExpression:
                      expr2.type = syntax_1.Syntax.AssignmentPattern;
                      delete expr2.operator;
                      this.reinterpretExpressionAsPattern(expr2.left);
                      break;
                  }
                };
                Parser3.prototype.parseGroupExpression = function() {
                  var expr2;
                  this.expect("(");
                  if (this.match(")")) {
                    this.nextToken();
                    if (!this.match("=>")) {
                      this.expect("=>");
                    }
                    expr2 = {type: ArrowParameterPlaceHolder, params: [], async: false};
                  } else {
                    var startToken = this.lookahead;
                    var params = [];
                    if (this.match("...")) {
                      expr2 = this.parseRestElement(params);
                      this.expect(")");
                      if (!this.match("=>")) {
                        this.expect("=>");
                      }
                      expr2 = {type: ArrowParameterPlaceHolder, params: [expr2], async: false};
                    } else {
                      var arrow = false;
                      this.context.isBindingElement = true;
                      expr2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                      if (this.match(",")) {
                        var expressions2 = [];
                        this.context.isAssignmentTarget = false;
                        expressions2.push(expr2);
                        while (this.lookahead.type !== 2) {
                          if (!this.match(",")) {
                            break;
                          }
                          this.nextToken();
                          if (this.match(")")) {
                            this.nextToken();
                            for (var i = 0; i < expressions2.length; i++) {
                              this.reinterpretExpressionAsPattern(expressions2[i]);
                            }
                            arrow = true;
                            expr2 = {type: ArrowParameterPlaceHolder, params: expressions2, async: false};
                          } else if (this.match("...")) {
                            if (!this.context.isBindingElement) {
                              this.throwUnexpectedToken(this.lookahead);
                            }
                            expressions2.push(this.parseRestElement(params));
                            this.expect(")");
                            if (!this.match("=>")) {
                              this.expect("=>");
                            }
                            this.context.isBindingElement = false;
                            for (var i = 0; i < expressions2.length; i++) {
                              this.reinterpretExpressionAsPattern(expressions2[i]);
                            }
                            arrow = true;
                            expr2 = {type: ArrowParameterPlaceHolder, params: expressions2, async: false};
                          } else {
                            expressions2.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                          }
                          if (arrow) {
                            break;
                          }
                        }
                        if (!arrow) {
                          expr2 = this.finalize(this.startNode(startToken), new Node3.SequenceExpression(expressions2));
                        }
                      }
                      if (!arrow) {
                        this.expect(")");
                        if (this.match("=>")) {
                          if (expr2.type === syntax_1.Syntax.Identifier && expr2.name === "yield") {
                            arrow = true;
                            expr2 = {type: ArrowParameterPlaceHolder, params: [expr2], async: false};
                          }
                          if (!arrow) {
                            if (!this.context.isBindingElement) {
                              this.throwUnexpectedToken(this.lookahead);
                            }
                            if (expr2.type === syntax_1.Syntax.SequenceExpression) {
                              for (var i = 0; i < expr2.expressions.length; i++) {
                                this.reinterpretExpressionAsPattern(expr2.expressions[i]);
                              }
                            } else {
                              this.reinterpretExpressionAsPattern(expr2);
                            }
                            var parameters = expr2.type === syntax_1.Syntax.SequenceExpression ? expr2.expressions : [expr2];
                            expr2 = {type: ArrowParameterPlaceHolder, params: parameters, async: false};
                          }
                        }
                        this.context.isBindingElement = false;
                      }
                    }
                  }
                  return expr2;
                };
                Parser3.prototype.parseArguments = function() {
                  this.expect("(");
                  var args = [];
                  if (!this.match(")")) {
                    while (true) {
                      var expr2 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                      args.push(expr2);
                      if (this.match(")")) {
                        break;
                      }
                      this.expectCommaSeparator();
                      if (this.match(")")) {
                        break;
                      }
                    }
                  }
                  this.expect(")");
                  return args;
                };
                Parser3.prototype.isIdentifierName = function(token) {
                  return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
                };
                Parser3.prototype.parseIdentifierName = function() {
                  var node2 = this.createNode();
                  var token = this.nextToken();
                  if (!this.isIdentifierName(token)) {
                    this.throwUnexpectedToken(token);
                  }
                  return this.finalize(node2, new Node3.Identifier(token.value));
                };
                Parser3.prototype.parseNewExpression = function() {
                  var node2 = this.createNode();
                  var id = this.parseIdentifierName();
                  assert_12.assert(id.name === "new", "New expression must start with `new`");
                  var expr2;
                  if (this.match(".")) {
                    this.nextToken();
                    if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                      var property = this.parseIdentifierName();
                      expr2 = new Node3.MetaProperty(id, property);
                    } else {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  } else {
                    var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                    var args = this.match("(") ? this.parseArguments() : [];
                    expr2 = new Node3.NewExpression(callee, args);
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  }
                  return this.finalize(node2, expr2);
                };
                Parser3.prototype.parseAsyncArgument = function() {
                  var arg = this.parseAssignmentExpression();
                  this.context.firstCoverInitializedNameError = null;
                  return arg;
                };
                Parser3.prototype.parseAsyncArguments = function() {
                  this.expect("(");
                  var args = [];
                  if (!this.match(")")) {
                    while (true) {
                      var expr2 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                      args.push(expr2);
                      if (this.match(")")) {
                        break;
                      }
                      this.expectCommaSeparator();
                      if (this.match(")")) {
                        break;
                      }
                    }
                  }
                  this.expect(")");
                  return args;
                };
                Parser3.prototype.parseLeftHandSideExpressionAllowCall = function() {
                  var startToken = this.lookahead;
                  var maybeAsync = this.matchContextualKeyword("async");
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = true;
                  var expr2;
                  if (this.matchKeyword("super") && this.context.inFunctionBody) {
                    expr2 = this.createNode();
                    this.nextToken();
                    expr2 = this.finalize(expr2, new Node3.Super());
                    if (!this.match("(") && !this.match(".") && !this.match("[")) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  } else {
                    expr2 = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                  }
                  while (true) {
                    if (this.match(".")) {
                      this.context.isBindingElement = false;
                      this.context.isAssignmentTarget = true;
                      this.expect(".");
                      var property = this.parseIdentifierName();
                      expr2 = this.finalize(this.startNode(startToken), new Node3.StaticMemberExpression(expr2, property));
                    } else if (this.match("(")) {
                      var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                      this.context.isBindingElement = false;
                      this.context.isAssignmentTarget = false;
                      var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                      expr2 = this.finalize(this.startNode(startToken), new Node3.CallExpression(expr2, args));
                      if (asyncArrow && this.match("=>")) {
                        for (var i = 0; i < args.length; ++i) {
                          this.reinterpretExpressionAsPattern(args[i]);
                        }
                        expr2 = {type: ArrowParameterPlaceHolder, params: args, async: true};
                      }
                    } else if (this.match("[")) {
                      this.context.isBindingElement = false;
                      this.context.isAssignmentTarget = true;
                      this.expect("[");
                      var property = this.isolateCoverGrammar(this.parseExpression);
                      this.expect("]");
                      expr2 = this.finalize(this.startNode(startToken), new Node3.ComputedMemberExpression(expr2, property));
                    } else if (this.lookahead.type === 10 && this.lookahead.head) {
                      var quasi = this.parseTemplateLiteral();
                      expr2 = this.finalize(this.startNode(startToken), new Node3.TaggedTemplateExpression(expr2, quasi));
                    } else {
                      break;
                    }
                  }
                  this.context.allowIn = previousAllowIn;
                  return expr2;
                };
                Parser3.prototype.parseSuper = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("super");
                  if (!this.match("[") && !this.match(".")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  return this.finalize(node2, new Node3.Super());
                };
                Parser3.prototype.parseLeftHandSideExpression = function() {
                  assert_12.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                  var node2 = this.startNode(this.lookahead);
                  var expr2 = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                  while (true) {
                    if (this.match("[")) {
                      this.context.isBindingElement = false;
                      this.context.isAssignmentTarget = true;
                      this.expect("[");
                      var property = this.isolateCoverGrammar(this.parseExpression);
                      this.expect("]");
                      expr2 = this.finalize(node2, new Node3.ComputedMemberExpression(expr2, property));
                    } else if (this.match(".")) {
                      this.context.isBindingElement = false;
                      this.context.isAssignmentTarget = true;
                      this.expect(".");
                      var property = this.parseIdentifierName();
                      expr2 = this.finalize(node2, new Node3.StaticMemberExpression(expr2, property));
                    } else if (this.lookahead.type === 10 && this.lookahead.head) {
                      var quasi = this.parseTemplateLiteral();
                      expr2 = this.finalize(node2, new Node3.TaggedTemplateExpression(expr2, quasi));
                    } else {
                      break;
                    }
                  }
                  return expr2;
                };
                Parser3.prototype.parseUpdateExpression = function() {
                  var expr2;
                  var startToken = this.lookahead;
                  if (this.match("++") || this.match("--")) {
                    var node2 = this.startNode(startToken);
                    var token = this.nextToken();
                    expr2 = this.inheritCoverGrammar(this.parseUnaryExpression);
                    if (this.context.strict && expr2.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr2.name)) {
                      this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                    }
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    var prefix2 = true;
                    expr2 = this.finalize(node2, new Node3.UpdateExpression(token.value, expr2, prefix2));
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  } else {
                    expr2 = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    if (!this.hasLineTerminator && this.lookahead.type === 7) {
                      if (this.match("++") || this.match("--")) {
                        if (this.context.strict && expr2.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr2.name)) {
                          this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                        }
                        if (!this.context.isAssignmentTarget) {
                          this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                        }
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        var operator = this.nextToken().value;
                        var prefix2 = false;
                        expr2 = this.finalize(this.startNode(startToken), new Node3.UpdateExpression(operator, expr2, prefix2));
                      }
                    }
                  }
                  return expr2;
                };
                Parser3.prototype.parseAwaitExpression = function() {
                  var node2 = this.createNode();
                  this.nextToken();
                  var argument = this.parseUnaryExpression();
                  return this.finalize(node2, new Node3.AwaitExpression(argument));
                };
                Parser3.prototype.parseUnaryExpression = function() {
                  var expr2;
                  if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                    var node2 = this.startNode(this.lookahead);
                    var token = this.nextToken();
                    expr2 = this.inheritCoverGrammar(this.parseUnaryExpression);
                    expr2 = this.finalize(node2, new Node3.UnaryExpression(token.value, expr2));
                    if (this.context.strict && expr2.operator === "delete" && expr2.argument.type === syntax_1.Syntax.Identifier) {
                      this.tolerateError(messages_1.Messages.StrictDelete);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  } else if (this.context.await && this.matchContextualKeyword("await")) {
                    expr2 = this.parseAwaitExpression();
                  } else {
                    expr2 = this.parseUpdateExpression();
                  }
                  return expr2;
                };
                Parser3.prototype.parseExponentiationExpression = function() {
                  var startToken = this.lookahead;
                  var expr2 = this.inheritCoverGrammar(this.parseUnaryExpression);
                  if (expr2.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                    this.nextToken();
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var left = expr2;
                    var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                    expr2 = this.finalize(this.startNode(startToken), new Node3.BinaryExpression("**", left, right));
                  }
                  return expr2;
                };
                Parser3.prototype.binaryPrecedence = function(token) {
                  var op = token.value;
                  var precedence;
                  if (token.type === 7) {
                    precedence = this.operatorPrecedence[op] || 0;
                  } else if (token.type === 4) {
                    precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                  } else {
                    precedence = 0;
                  }
                  return precedence;
                };
                Parser3.prototype.parseBinaryExpression = function() {
                  var startToken = this.lookahead;
                  var expr2 = this.inheritCoverGrammar(this.parseExponentiationExpression);
                  var token = this.lookahead;
                  var prec = this.binaryPrecedence(token);
                  if (prec > 0) {
                    this.nextToken();
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var markers = [startToken, this.lookahead];
                    var left = expr2;
                    var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                    var stack = [left, token.value, right];
                    var precedences = [prec];
                    while (true) {
                      prec = this.binaryPrecedence(this.lookahead);
                      if (prec <= 0) {
                        break;
                      }
                      while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                        right = stack.pop();
                        var operator = stack.pop();
                        precedences.pop();
                        left = stack.pop();
                        markers.pop();
                        var node2 = this.startNode(markers[markers.length - 1]);
                        stack.push(this.finalize(node2, new Node3.BinaryExpression(operator, left, right)));
                      }
                      stack.push(this.nextToken().value);
                      precedences.push(prec);
                      markers.push(this.lookahead);
                      stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                    }
                    var i = stack.length - 1;
                    expr2 = stack[i];
                    var lastMarker = markers.pop();
                    while (i > 1) {
                      var marker = markers.pop();
                      var lastLineStart = lastMarker && lastMarker.lineStart;
                      var node2 = this.startNode(marker, lastLineStart);
                      var operator = stack[i - 1];
                      expr2 = this.finalize(node2, new Node3.BinaryExpression(operator, stack[i - 2], expr2));
                      i -= 2;
                      lastMarker = marker;
                    }
                  }
                  return expr2;
                };
                Parser3.prototype.parseConditionalExpression = function() {
                  var startToken = this.lookahead;
                  var expr2 = this.inheritCoverGrammar(this.parseBinaryExpression);
                  if (this.match("?")) {
                    this.nextToken();
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.context.allowIn = previousAllowIn;
                    this.expect(":");
                    var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr2 = this.finalize(this.startNode(startToken), new Node3.ConditionalExpression(expr2, consequent, alternate));
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  }
                  return expr2;
                };
                Parser3.prototype.checkPatternParam = function(options2, param) {
                  switch (param.type) {
                    case syntax_1.Syntax.Identifier:
                      this.validateParam(options2, param, param.name);
                      break;
                    case syntax_1.Syntax.RestElement:
                      this.checkPatternParam(options2, param.argument);
                      break;
                    case syntax_1.Syntax.AssignmentPattern:
                      this.checkPatternParam(options2, param.left);
                      break;
                    case syntax_1.Syntax.ArrayPattern:
                      for (var i = 0; i < param.elements.length; i++) {
                        if (param.elements[i] !== null) {
                          this.checkPatternParam(options2, param.elements[i]);
                        }
                      }
                      break;
                    case syntax_1.Syntax.ObjectPattern:
                      for (var i = 0; i < param.properties.length; i++) {
                        this.checkPatternParam(options2, param.properties[i].value);
                      }
                      break;
                  }
                  options2.simple = options2.simple && param instanceof Node3.Identifier;
                };
                Parser3.prototype.reinterpretAsCoverFormalsList = function(expr2) {
                  var params = [expr2];
                  var options2;
                  var asyncArrow = false;
                  switch (expr2.type) {
                    case syntax_1.Syntax.Identifier:
                      break;
                    case ArrowParameterPlaceHolder:
                      params = expr2.params;
                      asyncArrow = expr2.async;
                      break;
                    default:
                      return null;
                  }
                  options2 = {simple: true, paramSet: {}};
                  for (var i = 0; i < params.length; ++i) {
                    var param = params[i];
                    if (param.type === syntax_1.Syntax.AssignmentPattern) {
                      if (param.right.type === syntax_1.Syntax.YieldExpression) {
                        if (param.right.argument) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        param.right.type = syntax_1.Syntax.Identifier;
                        param.right.name = "yield";
                        delete param.right.argument;
                        delete param.right.delegate;
                      }
                    } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    this.checkPatternParam(options2, param);
                    params[i] = param;
                  }
                  if (this.context.strict || !this.context.allowYield) {
                    for (var i = 0; i < params.length; ++i) {
                      var param = params[i];
                      if (param.type === syntax_1.Syntax.YieldExpression) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    }
                  }
                  if (options2.message === messages_1.Messages.StrictParamDupe) {
                    var token = this.context.strict ? options2.stricted : options2.firstRestricted;
                    this.throwUnexpectedToken(token, options2.message);
                  }
                  return {simple: options2.simple, params, stricted: options2.stricted, firstRestricted: options2.firstRestricted, message: options2.message};
                };
                Parser3.prototype.parseAssignmentExpression = function() {
                  var expr2;
                  if (!this.context.allowYield && this.matchKeyword("yield")) {
                    expr2 = this.parseYieldExpression();
                  } else {
                    var startToken = this.lookahead;
                    var token = startToken;
                    expr2 = this.parseConditionalExpression();
                    if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                      if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                        var arg = this.parsePrimaryExpression();
                        this.reinterpretExpressionAsPattern(arg);
                        expr2 = {type: ArrowParameterPlaceHolder, params: [arg], async: true};
                      }
                    }
                    if (expr2.type === ArrowParameterPlaceHolder || this.match("=>")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var isAsync = expr2.async;
                      var list = this.reinterpretAsCoverFormalsList(expr2);
                      if (list) {
                        if (this.hasLineTerminator) {
                          this.tolerateUnexpectedToken(this.lookahead);
                        }
                        this.context.firstCoverInitializedNameError = null;
                        var previousStrict = this.context.strict;
                        var previousAllowStrictDirective = this.context.allowStrictDirective;
                        this.context.allowStrictDirective = list.simple;
                        var previousAllowYield = this.context.allowYield;
                        var previousAwait = this.context.await;
                        this.context.allowYield = true;
                        this.context.await = isAsync;
                        var node2 = this.startNode(startToken);
                        this.expect("=>");
                        var body = void 0;
                        if (this.match("{")) {
                          var previousAllowIn = this.context.allowIn;
                          this.context.allowIn = true;
                          body = this.parseFunctionSourceElements();
                          this.context.allowIn = previousAllowIn;
                        } else {
                          body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        }
                        var expression = body.type !== syntax_1.Syntax.BlockStatement;
                        if (this.context.strict && list.firstRestricted) {
                          this.throwUnexpectedToken(list.firstRestricted, list.message);
                        }
                        if (this.context.strict && list.stricted) {
                          this.tolerateUnexpectedToken(list.stricted, list.message);
                        }
                        expr2 = isAsync ? this.finalize(node2, new Node3.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node2, new Node3.ArrowFunctionExpression(list.params, body, expression));
                        this.context.strict = previousStrict;
                        this.context.allowStrictDirective = previousAllowStrictDirective;
                        this.context.allowYield = previousAllowYield;
                        this.context.await = previousAwait;
                      }
                    } else {
                      if (this.matchAssign()) {
                        if (!this.context.isAssignmentTarget) {
                          this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                        }
                        if (this.context.strict && expr2.type === syntax_1.Syntax.Identifier) {
                          var id = expr2;
                          if (this.scanner.isRestrictedWord(id.name)) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                          }
                          if (this.scanner.isStrictModeReservedWord(id.name)) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                          }
                        }
                        if (!this.match("=")) {
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                        } else {
                          this.reinterpretExpressionAsPattern(expr2);
                        }
                        token = this.nextToken();
                        var operator = token.value;
                        var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        expr2 = this.finalize(this.startNode(startToken), new Node3.AssignmentExpression(operator, expr2, right));
                        this.context.firstCoverInitializedNameError = null;
                      }
                    }
                  }
                  return expr2;
                };
                Parser3.prototype.parseExpression = function() {
                  var startToken = this.lookahead;
                  var expr2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  if (this.match(",")) {
                    var expressions2 = [];
                    expressions2.push(expr2);
                    while (this.lookahead.type !== 2) {
                      if (!this.match(",")) {
                        break;
                      }
                      this.nextToken();
                      expressions2.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                    }
                    expr2 = this.finalize(this.startNode(startToken), new Node3.SequenceExpression(expressions2));
                  }
                  return expr2;
                };
                Parser3.prototype.parseStatementListItem = function() {
                  var statement;
                  this.context.isAssignmentTarget = true;
                  this.context.isBindingElement = true;
                  if (this.lookahead.type === 4) {
                    switch (this.lookahead.value) {
                      case "export":
                        if (!this.context.isModule) {
                          this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                        }
                        statement = this.parseExportDeclaration();
                        break;
                      case "import":
                        if (!this.context.isModule) {
                          this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                        }
                        statement = this.parseImportDeclaration();
                        break;
                      case "const":
                        statement = this.parseLexicalDeclaration({inFor: false});
                        break;
                      case "function":
                        statement = this.parseFunctionDeclaration();
                        break;
                      case "class":
                        statement = this.parseClassDeclaration();
                        break;
                      case "let":
                        statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({inFor: false}) : this.parseStatement();
                        break;
                      default:
                        statement = this.parseStatement();
                        break;
                    }
                  } else {
                    statement = this.parseStatement();
                  }
                  return statement;
                };
                Parser3.prototype.parseBlock = function() {
                  var node2 = this.createNode();
                  this.expect("{");
                  var block = [];
                  while (true) {
                    if (this.match("}")) {
                      break;
                    }
                    block.push(this.parseStatementListItem());
                  }
                  this.expect("}");
                  return this.finalize(node2, new Node3.BlockStatement(block));
                };
                Parser3.prototype.parseLexicalBinding = function(kind, options2) {
                  var node2 = this.createNode();
                  var params = [];
                  var id = this.parsePattern(params, kind);
                  if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                    if (this.scanner.isRestrictedWord(id.name)) {
                      this.tolerateError(messages_1.Messages.StrictVarName);
                    }
                  }
                  var init2 = null;
                  if (kind === "const") {
                    if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                      if (this.match("=")) {
                        this.nextToken();
                        init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      } else {
                        this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                      }
                    }
                  } else if (!options2.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                    this.expect("=");
                    init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  }
                  return this.finalize(node2, new Node3.VariableDeclarator(id, init2));
                };
                Parser3.prototype.parseBindingList = function(kind, options2) {
                  var list = [this.parseLexicalBinding(kind, options2)];
                  while (this.match(",")) {
                    this.nextToken();
                    list.push(this.parseLexicalBinding(kind, options2));
                  }
                  return list;
                };
                Parser3.prototype.isLexicalDeclaration = function() {
                  var state = this.scanner.saveState();
                  this.scanner.scanComments();
                  var next = this.scanner.lex();
                  this.scanner.restoreState(state);
                  return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
                };
                Parser3.prototype.parseLexicalDeclaration = function(options2) {
                  var node2 = this.createNode();
                  var kind = this.nextToken().value;
                  assert_12.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                  var declarations = this.parseBindingList(kind, options2);
                  this.consumeSemicolon();
                  return this.finalize(node2, new Node3.VariableDeclaration(declarations, kind));
                };
                Parser3.prototype.parseBindingRestElement = function(params, kind) {
                  var node2 = this.createNode();
                  this.expect("...");
                  var arg = this.parsePattern(params, kind);
                  return this.finalize(node2, new Node3.RestElement(arg));
                };
                Parser3.prototype.parseArrayPattern = function(params, kind) {
                  var node2 = this.createNode();
                  this.expect("[");
                  var elements = [];
                  while (!this.match("]")) {
                    if (this.match(",")) {
                      this.nextToken();
                      elements.push(null);
                    } else {
                      if (this.match("...")) {
                        elements.push(this.parseBindingRestElement(params, kind));
                        break;
                      } else {
                        elements.push(this.parsePatternWithDefault(params, kind));
                      }
                      if (!this.match("]")) {
                        this.expect(",");
                      }
                    }
                  }
                  this.expect("]");
                  return this.finalize(node2, new Node3.ArrayPattern(elements));
                };
                Parser3.prototype.parsePropertyPattern = function(params, kind) {
                  var node2 = this.createNode();
                  var computed = false;
                  var shorthand = false;
                  var method = false;
                  var key;
                  var value;
                  if (this.lookahead.type === 3) {
                    var keyToken = this.lookahead;
                    key = this.parseVariableIdentifier();
                    var init2 = this.finalize(node2, new Node3.Identifier(keyToken.value));
                    if (this.match("=")) {
                      params.push(keyToken);
                      shorthand = true;
                      this.nextToken();
                      var expr2 = this.parseAssignmentExpression();
                      value = this.finalize(this.startNode(keyToken), new Node3.AssignmentPattern(init2, expr2));
                    } else if (!this.match(":")) {
                      params.push(keyToken);
                      shorthand = true;
                      value = init2;
                    } else {
                      this.expect(":");
                      value = this.parsePatternWithDefault(params, kind);
                    }
                  } else {
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    this.expect(":");
                    value = this.parsePatternWithDefault(params, kind);
                  }
                  return this.finalize(node2, new Node3.Property("init", key, computed, value, method, shorthand));
                };
                Parser3.prototype.parseObjectPattern = function(params, kind) {
                  var node2 = this.createNode();
                  var properties = [];
                  this.expect("{");
                  while (!this.match("}")) {
                    properties.push(this.parsePropertyPattern(params, kind));
                    if (!this.match("}")) {
                      this.expect(",");
                    }
                  }
                  this.expect("}");
                  return this.finalize(node2, new Node3.ObjectPattern(properties));
                };
                Parser3.prototype.parsePattern = function(params, kind) {
                  var pattern;
                  if (this.match("[")) {
                    pattern = this.parseArrayPattern(params, kind);
                  } else if (this.match("{")) {
                    pattern = this.parseObjectPattern(params, kind);
                  } else {
                    if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                    }
                    params.push(this.lookahead);
                    pattern = this.parseVariableIdentifier(kind);
                  }
                  return pattern;
                };
                Parser3.prototype.parsePatternWithDefault = function(params, kind) {
                  var startToken = this.lookahead;
                  var pattern = this.parsePattern(params, kind);
                  if (this.match("=")) {
                    this.nextToken();
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.context.allowYield = previousAllowYield;
                    pattern = this.finalize(this.startNode(startToken), new Node3.AssignmentPattern(pattern, right));
                  }
                  return pattern;
                };
                Parser3.prototype.parseVariableIdentifier = function(kind) {
                  var node2 = this.createNode();
                  var token = this.nextToken();
                  if (token.type === 4 && token.value === "yield") {
                    if (this.context.strict) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                    } else if (!this.context.allowYield) {
                      this.throwUnexpectedToken(token);
                    }
                  } else if (token.type !== 3) {
                    if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                    } else {
                      if (this.context.strict || token.value !== "let" || kind !== "var") {
                        this.throwUnexpectedToken(token);
                      }
                    }
                  } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                    this.tolerateUnexpectedToken(token);
                  }
                  return this.finalize(node2, new Node3.Identifier(token.value));
                };
                Parser3.prototype.parseVariableDeclaration = function(options2) {
                  var node2 = this.createNode();
                  var params = [];
                  var id = this.parsePattern(params, "var");
                  if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                    if (this.scanner.isRestrictedWord(id.name)) {
                      this.tolerateError(messages_1.Messages.StrictVarName);
                    }
                  }
                  var init2 = null;
                  if (this.match("=")) {
                    this.nextToken();
                    init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  } else if (id.type !== syntax_1.Syntax.Identifier && !options2.inFor) {
                    this.expect("=");
                  }
                  return this.finalize(node2, new Node3.VariableDeclarator(id, init2));
                };
                Parser3.prototype.parseVariableDeclarationList = function(options2) {
                  var opt = {inFor: options2.inFor};
                  var list = [];
                  list.push(this.parseVariableDeclaration(opt));
                  while (this.match(",")) {
                    this.nextToken();
                    list.push(this.parseVariableDeclaration(opt));
                  }
                  return list;
                };
                Parser3.prototype.parseVariableStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("var");
                  var declarations = this.parseVariableDeclarationList({inFor: false});
                  this.consumeSemicolon();
                  return this.finalize(node2, new Node3.VariableDeclaration(declarations, "var"));
                };
                Parser3.prototype.parseEmptyStatement = function() {
                  var node2 = this.createNode();
                  this.expect(";");
                  return this.finalize(node2, new Node3.EmptyStatement());
                };
                Parser3.prototype.parseExpressionStatement = function() {
                  var node2 = this.createNode();
                  var expr2 = this.parseExpression();
                  this.consumeSemicolon();
                  return this.finalize(node2, new Node3.ExpressionStatement(expr2));
                };
                Parser3.prototype.parseIfClause = function() {
                  if (this.context.strict && this.matchKeyword("function")) {
                    this.tolerateError(messages_1.Messages.StrictFunction);
                  }
                  return this.parseStatement();
                };
                Parser3.prototype.parseIfStatement = function() {
                  var node2 = this.createNode();
                  var consequent;
                  var alternate = null;
                  this.expectKeyword("if");
                  this.expect("(");
                  var test = this.parseExpression();
                  if (!this.match(")") && this.config.tolerant) {
                    this.tolerateUnexpectedToken(this.nextToken());
                    consequent = this.finalize(this.createNode(), new Node3.EmptyStatement());
                  } else {
                    this.expect(")");
                    consequent = this.parseIfClause();
                    if (this.matchKeyword("else")) {
                      this.nextToken();
                      alternate = this.parseIfClause();
                    }
                  }
                  return this.finalize(node2, new Node3.IfStatement(test, consequent, alternate));
                };
                Parser3.prototype.parseDoWhileStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("do");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = true;
                  var body = this.parseStatement();
                  this.context.inIteration = previousInIteration;
                  this.expectKeyword("while");
                  this.expect("(");
                  var test = this.parseExpression();
                  if (!this.match(")") && this.config.tolerant) {
                    this.tolerateUnexpectedToken(this.nextToken());
                  } else {
                    this.expect(")");
                    if (this.match(";")) {
                      this.nextToken();
                    }
                  }
                  return this.finalize(node2, new Node3.DoWhileStatement(body, test));
                };
                Parser3.prototype.parseWhileStatement = function() {
                  var node2 = this.createNode();
                  var body;
                  this.expectKeyword("while");
                  this.expect("(");
                  var test = this.parseExpression();
                  if (!this.match(")") && this.config.tolerant) {
                    this.tolerateUnexpectedToken(this.nextToken());
                    body = this.finalize(this.createNode(), new Node3.EmptyStatement());
                  } else {
                    this.expect(")");
                    var previousInIteration = this.context.inIteration;
                    this.context.inIteration = true;
                    body = this.parseStatement();
                    this.context.inIteration = previousInIteration;
                  }
                  return this.finalize(node2, new Node3.WhileStatement(test, body));
                };
                Parser3.prototype.parseForStatement = function() {
                  var init2 = null;
                  var test = null;
                  var update = null;
                  var forIn = true;
                  var left, right;
                  var node2 = this.createNode();
                  this.expectKeyword("for");
                  this.expect("(");
                  if (this.match(";")) {
                    this.nextToken();
                  } else {
                    if (this.matchKeyword("var")) {
                      init2 = this.createNode();
                      this.nextToken();
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = false;
                      var declarations = this.parseVariableDeclarationList({inFor: true});
                      this.context.allowIn = previousAllowIn;
                      if (declarations.length === 1 && this.matchKeyword("in")) {
                        var decl = declarations[0];
                        if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                          this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                        }
                        init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, "var"));
                        this.nextToken();
                        left = init2;
                        right = this.parseExpression();
                        init2 = null;
                      } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                        init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, "var"));
                        this.nextToken();
                        left = init2;
                        right = this.parseAssignmentExpression();
                        init2 = null;
                        forIn = false;
                      } else {
                        init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, "var"));
                        this.expect(";");
                      }
                    } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                      init2 = this.createNode();
                      var kind = this.nextToken().value;
                      if (!this.context.strict && this.lookahead.value === "in") {
                        init2 = this.finalize(init2, new Node3.Identifier(kind));
                        this.nextToken();
                        left = init2;
                        right = this.parseExpression();
                        init2 = null;
                      } else {
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = false;
                        var declarations = this.parseBindingList(kind, {inFor: true});
                        this.context.allowIn = previousAllowIn;
                        if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                          init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, kind));
                          this.nextToken();
                          left = init2;
                          right = this.parseExpression();
                          init2 = null;
                        } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                          init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, kind));
                          this.nextToken();
                          left = init2;
                          right = this.parseAssignmentExpression();
                          init2 = null;
                          forIn = false;
                        } else {
                          this.consumeSemicolon();
                          init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, kind));
                        }
                      }
                    } else {
                      var initStartToken = this.lookahead;
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = false;
                      init2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                      this.context.allowIn = previousAllowIn;
                      if (this.matchKeyword("in")) {
                        if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                          this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                        }
                        this.nextToken();
                        this.reinterpretExpressionAsPattern(init2);
                        left = init2;
                        right = this.parseExpression();
                        init2 = null;
                      } else if (this.matchContextualKeyword("of")) {
                        if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                          this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                        }
                        this.nextToken();
                        this.reinterpretExpressionAsPattern(init2);
                        left = init2;
                        right = this.parseAssignmentExpression();
                        init2 = null;
                        forIn = false;
                      } else {
                        if (this.match(",")) {
                          var initSeq = [init2];
                          while (this.match(",")) {
                            this.nextToken();
                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                          }
                          init2 = this.finalize(this.startNode(initStartToken), new Node3.SequenceExpression(initSeq));
                        }
                        this.expect(";");
                      }
                    }
                  }
                  if (typeof left === "undefined") {
                    if (!this.match(";")) {
                      test = this.parseExpression();
                    }
                    this.expect(";");
                    if (!this.match(")")) {
                      update = this.parseExpression();
                    }
                  }
                  var body;
                  if (!this.match(")") && this.config.tolerant) {
                    this.tolerateUnexpectedToken(this.nextToken());
                    body = this.finalize(this.createNode(), new Node3.EmptyStatement());
                  } else {
                    this.expect(")");
                    var previousInIteration = this.context.inIteration;
                    this.context.inIteration = true;
                    body = this.isolateCoverGrammar(this.parseStatement);
                    this.context.inIteration = previousInIteration;
                  }
                  return typeof left === "undefined" ? this.finalize(node2, new Node3.ForStatement(init2, test, update, body)) : forIn ? this.finalize(node2, new Node3.ForInStatement(left, right, body)) : this.finalize(node2, new Node3.ForOfStatement(left, right, body));
                };
                Parser3.prototype.parseContinueStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("continue");
                  var label = null;
                  if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                    var id = this.parseVariableIdentifier();
                    label = id;
                    var key = "$" + id.name;
                    if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                      this.throwError(messages_1.Messages.UnknownLabel, id.name);
                    }
                  }
                  this.consumeSemicolon();
                  if (label === null && !this.context.inIteration) {
                    this.throwError(messages_1.Messages.IllegalContinue);
                  }
                  return this.finalize(node2, new Node3.ContinueStatement(label));
                };
                Parser3.prototype.parseBreakStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("break");
                  var label = null;
                  if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                    var id = this.parseVariableIdentifier();
                    var key = "$" + id.name;
                    if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                      this.throwError(messages_1.Messages.UnknownLabel, id.name);
                    }
                    label = id;
                  }
                  this.consumeSemicolon();
                  if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                    this.throwError(messages_1.Messages.IllegalBreak);
                  }
                  return this.finalize(node2, new Node3.BreakStatement(label));
                };
                Parser3.prototype.parseReturnStatement = function() {
                  if (!this.context.inFunctionBody) {
                    this.tolerateError(messages_1.Messages.IllegalReturn);
                  }
                  var node2 = this.createNode();
                  this.expectKeyword("return");
                  var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
                  var argument = hasArgument ? this.parseExpression() : null;
                  this.consumeSemicolon();
                  return this.finalize(node2, new Node3.ReturnStatement(argument));
                };
                Parser3.prototype.parseWithStatement = function() {
                  if (this.context.strict) {
                    this.tolerateError(messages_1.Messages.StrictModeWith);
                  }
                  var node2 = this.createNode();
                  var body;
                  this.expectKeyword("with");
                  this.expect("(");
                  var object2 = this.parseExpression();
                  if (!this.match(")") && this.config.tolerant) {
                    this.tolerateUnexpectedToken(this.nextToken());
                    body = this.finalize(this.createNode(), new Node3.EmptyStatement());
                  } else {
                    this.expect(")");
                    body = this.parseStatement();
                  }
                  return this.finalize(node2, new Node3.WithStatement(object2, body));
                };
                Parser3.prototype.parseSwitchCase = function() {
                  var node2 = this.createNode();
                  var test;
                  if (this.matchKeyword("default")) {
                    this.nextToken();
                    test = null;
                  } else {
                    this.expectKeyword("case");
                    test = this.parseExpression();
                  }
                  this.expect(":");
                  var consequent = [];
                  while (true) {
                    if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                      break;
                    }
                    consequent.push(this.parseStatementListItem());
                  }
                  return this.finalize(node2, new Node3.SwitchCase(test, consequent));
                };
                Parser3.prototype.parseSwitchStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("switch");
                  this.expect("(");
                  var discriminant = this.parseExpression();
                  this.expect(")");
                  var previousInSwitch = this.context.inSwitch;
                  this.context.inSwitch = true;
                  var cases = [];
                  var defaultFound = false;
                  this.expect("{");
                  while (true) {
                    if (this.match("}")) {
                      break;
                    }
                    var clause = this.parseSwitchCase();
                    if (clause.test === null) {
                      if (defaultFound) {
                        this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                      }
                      defaultFound = true;
                    }
                    cases.push(clause);
                  }
                  this.expect("}");
                  this.context.inSwitch = previousInSwitch;
                  return this.finalize(node2, new Node3.SwitchStatement(discriminant, cases));
                };
                Parser3.prototype.parseLabelledStatement = function() {
                  var node2 = this.createNode();
                  var expr2 = this.parseExpression();
                  var statement;
                  if (expr2.type === syntax_1.Syntax.Identifier && this.match(":")) {
                    this.nextToken();
                    var id = expr2;
                    var key = "$" + id.name;
                    if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                      this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                    }
                    this.context.labelSet[key] = true;
                    var body = void 0;
                    if (this.matchKeyword("class")) {
                      this.tolerateUnexpectedToken(this.lookahead);
                      body = this.parseClassDeclaration();
                    } else if (this.matchKeyword("function")) {
                      var token = this.lookahead;
                      var declaration = this.parseFunctionDeclaration();
                      if (this.context.strict) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                      } else if (declaration.generator) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                      }
                      body = declaration;
                    } else {
                      body = this.parseStatement();
                    }
                    delete this.context.labelSet[key];
                    statement = new Node3.LabeledStatement(id, body);
                  } else {
                    this.consumeSemicolon();
                    statement = new Node3.ExpressionStatement(expr2);
                  }
                  return this.finalize(node2, statement);
                };
                Parser3.prototype.parseThrowStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("throw");
                  if (this.hasLineTerminator) {
                    this.throwError(messages_1.Messages.NewlineAfterThrow);
                  }
                  var argument = this.parseExpression();
                  this.consumeSemicolon();
                  return this.finalize(node2, new Node3.ThrowStatement(argument));
                };
                Parser3.prototype.parseCatchClause = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("catch");
                  this.expect("(");
                  if (this.match(")")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  var params = [];
                  var param = this.parsePattern(params);
                  var paramMap = {};
                  for (var i = 0; i < params.length; i++) {
                    var key = "$" + params[i].value;
                    if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                      this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                    }
                    paramMap[key] = true;
                  }
                  if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                    if (this.scanner.isRestrictedWord(param.name)) {
                      this.tolerateError(messages_1.Messages.StrictCatchVariable);
                    }
                  }
                  this.expect(")");
                  var body = this.parseBlock();
                  return this.finalize(node2, new Node3.CatchClause(param, body));
                };
                Parser3.prototype.parseFinallyClause = function() {
                  this.expectKeyword("finally");
                  return this.parseBlock();
                };
                Parser3.prototype.parseTryStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("try");
                  var block = this.parseBlock();
                  var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                  var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                  if (!handler && !finalizer) {
                    this.throwError(messages_1.Messages.NoCatchOrFinally);
                  }
                  return this.finalize(node2, new Node3.TryStatement(block, handler, finalizer));
                };
                Parser3.prototype.parseDebuggerStatement = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("debugger");
                  this.consumeSemicolon();
                  return this.finalize(node2, new Node3.DebuggerStatement());
                };
                Parser3.prototype.parseStatement = function() {
                  var statement;
                  switch (this.lookahead.type) {
                    case 1:
                    case 5:
                    case 6:
                    case 8:
                    case 10:
                    case 9:
                      statement = this.parseExpressionStatement();
                      break;
                    case 7:
                      var value = this.lookahead.value;
                      if (value === "{") {
                        statement = this.parseBlock();
                      } else if (value === "(") {
                        statement = this.parseExpressionStatement();
                      } else if (value === ";") {
                        statement = this.parseEmptyStatement();
                      } else {
                        statement = this.parseExpressionStatement();
                      }
                      break;
                    case 3:
                      statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                      break;
                    case 4:
                      switch (this.lookahead.value) {
                        case "break":
                          statement = this.parseBreakStatement();
                          break;
                        case "continue":
                          statement = this.parseContinueStatement();
                          break;
                        case "debugger":
                          statement = this.parseDebuggerStatement();
                          break;
                        case "do":
                          statement = this.parseDoWhileStatement();
                          break;
                        case "for":
                          statement = this.parseForStatement();
                          break;
                        case "function":
                          statement = this.parseFunctionDeclaration();
                          break;
                        case "if":
                          statement = this.parseIfStatement();
                          break;
                        case "return":
                          statement = this.parseReturnStatement();
                          break;
                        case "switch":
                          statement = this.parseSwitchStatement();
                          break;
                        case "throw":
                          statement = this.parseThrowStatement();
                          break;
                        case "try":
                          statement = this.parseTryStatement();
                          break;
                        case "var":
                          statement = this.parseVariableStatement();
                          break;
                        case "while":
                          statement = this.parseWhileStatement();
                          break;
                        case "with":
                          statement = this.parseWithStatement();
                          break;
                        default:
                          statement = this.parseExpressionStatement();
                          break;
                      }
                      break;
                    default:
                      statement = this.throwUnexpectedToken(this.lookahead);
                  }
                  return statement;
                };
                Parser3.prototype.parseFunctionSourceElements = function() {
                  var node2 = this.createNode();
                  this.expect("{");
                  var body = this.parseDirectivePrologues();
                  var previousLabelSet = this.context.labelSet;
                  var previousInIteration = this.context.inIteration;
                  var previousInSwitch = this.context.inSwitch;
                  var previousInFunctionBody = this.context.inFunctionBody;
                  this.context.labelSet = {};
                  this.context.inIteration = false;
                  this.context.inSwitch = false;
                  this.context.inFunctionBody = true;
                  while (this.lookahead.type !== 2) {
                    if (this.match("}")) {
                      break;
                    }
                    body.push(this.parseStatementListItem());
                  }
                  this.expect("}");
                  this.context.labelSet = previousLabelSet;
                  this.context.inIteration = previousInIteration;
                  this.context.inSwitch = previousInSwitch;
                  this.context.inFunctionBody = previousInFunctionBody;
                  return this.finalize(node2, new Node3.BlockStatement(body));
                };
                Parser3.prototype.validateParam = function(options2, param, name) {
                  var key = "$" + name;
                  if (this.context.strict) {
                    if (this.scanner.isRestrictedWord(name)) {
                      options2.stricted = param;
                      options2.message = messages_1.Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                      options2.stricted = param;
                      options2.message = messages_1.Messages.StrictParamDupe;
                    }
                  } else if (!options2.firstRestricted) {
                    if (this.scanner.isRestrictedWord(name)) {
                      options2.firstRestricted = param;
                      options2.message = messages_1.Messages.StrictParamName;
                    } else if (this.scanner.isStrictModeReservedWord(name)) {
                      options2.firstRestricted = param;
                      options2.message = messages_1.Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                      options2.stricted = param;
                      options2.message = messages_1.Messages.StrictParamDupe;
                    }
                  }
                  if (typeof Object.defineProperty === "function") {
                    Object.defineProperty(options2.paramSet, key, {value: true, enumerable: true, writable: true, configurable: true});
                  } else {
                    options2.paramSet[key] = true;
                  }
                };
                Parser3.prototype.parseRestElement = function(params) {
                  var node2 = this.createNode();
                  this.expect("...");
                  var arg = this.parsePattern(params);
                  if (this.match("=")) {
                    this.throwError(messages_1.Messages.DefaultRestParameter);
                  }
                  if (!this.match(")")) {
                    this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                  }
                  return this.finalize(node2, new Node3.RestElement(arg));
                };
                Parser3.prototype.parseFormalParameter = function(options2) {
                  var params = [];
                  var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                  for (var i = 0; i < params.length; i++) {
                    this.validateParam(options2, params[i], params[i].value);
                  }
                  options2.simple = options2.simple && param instanceof Node3.Identifier;
                  options2.params.push(param);
                };
                Parser3.prototype.parseFormalParameters = function(firstRestricted) {
                  var options2;
                  options2 = {simple: true, params: [], firstRestricted};
                  this.expect("(");
                  if (!this.match(")")) {
                    options2.paramSet = {};
                    while (this.lookahead.type !== 2) {
                      this.parseFormalParameter(options2);
                      if (this.match(")")) {
                        break;
                      }
                      this.expect(",");
                      if (this.match(")")) {
                        break;
                      }
                    }
                  }
                  this.expect(")");
                  return {simple: options2.simple, params: options2.params, stricted: options2.stricted, firstRestricted: options2.firstRestricted, message: options2.message};
                };
                Parser3.prototype.matchAsyncFunction = function() {
                  var match = this.matchContextualKeyword("async");
                  if (match) {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.scanner.lex();
                    this.scanner.restoreState(state);
                    match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                  }
                  return match;
                };
                Parser3.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                  var node2 = this.createNode();
                  var isAsync = this.matchContextualKeyword("async");
                  if (isAsync) {
                    this.nextToken();
                  }
                  this.expectKeyword("function");
                  var isGenerator = isAsync ? false : this.match("*");
                  if (isGenerator) {
                    this.nextToken();
                  }
                  var message;
                  var id = null;
                  var firstRestricted = null;
                  if (!identifierIsOptional || !this.match("(")) {
                    var token = this.lookahead;
                    id = this.parseVariableIdentifier();
                    if (this.context.strict) {
                      if (this.scanner.isRestrictedWord(token.value)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                      }
                    } else {
                      if (this.scanner.isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = messages_1.Messages.StrictFunctionName;
                      } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = messages_1.Messages.StrictReservedWord;
                      }
                    }
                  }
                  var previousAllowAwait = this.context.await;
                  var previousAllowYield = this.context.allowYield;
                  this.context.await = isAsync;
                  this.context.allowYield = !isGenerator;
                  var formalParameters = this.parseFormalParameters(firstRestricted);
                  var params = formalParameters.params;
                  var stricted = formalParameters.stricted;
                  firstRestricted = formalParameters.firstRestricted;
                  if (formalParameters.message) {
                    message = formalParameters.message;
                  }
                  var previousStrict = this.context.strict;
                  var previousAllowStrictDirective = this.context.allowStrictDirective;
                  this.context.allowStrictDirective = formalParameters.simple;
                  var body = this.parseFunctionSourceElements();
                  if (this.context.strict && firstRestricted) {
                    this.throwUnexpectedToken(firstRestricted, message);
                  }
                  if (this.context.strict && stricted) {
                    this.tolerateUnexpectedToken(stricted, message);
                  }
                  this.context.strict = previousStrict;
                  this.context.allowStrictDirective = previousAllowStrictDirective;
                  this.context.await = previousAllowAwait;
                  this.context.allowYield = previousAllowYield;
                  return isAsync ? this.finalize(node2, new Node3.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node2, new Node3.FunctionDeclaration(id, params, body, isGenerator));
                };
                Parser3.prototype.parseFunctionExpression = function() {
                  var node2 = this.createNode();
                  var isAsync = this.matchContextualKeyword("async");
                  if (isAsync) {
                    this.nextToken();
                  }
                  this.expectKeyword("function");
                  var isGenerator = isAsync ? false : this.match("*");
                  if (isGenerator) {
                    this.nextToken();
                  }
                  var message;
                  var id = null;
                  var firstRestricted;
                  var previousAllowAwait = this.context.await;
                  var previousAllowYield = this.context.allowYield;
                  this.context.await = isAsync;
                  this.context.allowYield = !isGenerator;
                  if (!this.match("(")) {
                    var token = this.lookahead;
                    id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                    if (this.context.strict) {
                      if (this.scanner.isRestrictedWord(token.value)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                      }
                    } else {
                      if (this.scanner.isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = messages_1.Messages.StrictFunctionName;
                      } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = messages_1.Messages.StrictReservedWord;
                      }
                    }
                  }
                  var formalParameters = this.parseFormalParameters(firstRestricted);
                  var params = formalParameters.params;
                  var stricted = formalParameters.stricted;
                  firstRestricted = formalParameters.firstRestricted;
                  if (formalParameters.message) {
                    message = formalParameters.message;
                  }
                  var previousStrict = this.context.strict;
                  var previousAllowStrictDirective = this.context.allowStrictDirective;
                  this.context.allowStrictDirective = formalParameters.simple;
                  var body = this.parseFunctionSourceElements();
                  if (this.context.strict && firstRestricted) {
                    this.throwUnexpectedToken(firstRestricted, message);
                  }
                  if (this.context.strict && stricted) {
                    this.tolerateUnexpectedToken(stricted, message);
                  }
                  this.context.strict = previousStrict;
                  this.context.allowStrictDirective = previousAllowStrictDirective;
                  this.context.await = previousAllowAwait;
                  this.context.allowYield = previousAllowYield;
                  return isAsync ? this.finalize(node2, new Node3.AsyncFunctionExpression(id, params, body)) : this.finalize(node2, new Node3.FunctionExpression(id, params, body, isGenerator));
                };
                Parser3.prototype.parseDirective = function() {
                  var token = this.lookahead;
                  var node2 = this.createNode();
                  var expr2 = this.parseExpression();
                  var directive = expr2.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                  this.consumeSemicolon();
                  return this.finalize(node2, directive ? new Node3.Directive(expr2, directive) : new Node3.ExpressionStatement(expr2));
                };
                Parser3.prototype.parseDirectivePrologues = function() {
                  var firstRestricted = null;
                  var body = [];
                  while (true) {
                    var token = this.lookahead;
                    if (token.type !== 8) {
                      break;
                    }
                    var statement = this.parseDirective();
                    body.push(statement);
                    var directive = statement.directive;
                    if (typeof directive !== "string") {
                      break;
                    }
                    if (directive === "use strict") {
                      this.context.strict = true;
                      if (firstRestricted) {
                        this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                      }
                      if (!this.context.allowStrictDirective) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                      }
                    } else {
                      if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                      }
                    }
                  }
                  return body;
                };
                Parser3.prototype.qualifiedPropertyName = function(token) {
                  switch (token.type) {
                    case 3:
                    case 8:
                    case 1:
                    case 5:
                    case 6:
                    case 4:
                      return true;
                    case 7:
                      return token.value === "[";
                  }
                  return false;
                };
                Parser3.prototype.parseGetterMethod = function() {
                  var node2 = this.createNode();
                  var isGenerator = false;
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = !isGenerator;
                  var formalParameters = this.parseFormalParameters();
                  if (formalParameters.params.length > 0) {
                    this.tolerateError(messages_1.Messages.BadGetterArity);
                  }
                  var method = this.parsePropertyMethod(formalParameters);
                  this.context.allowYield = previousAllowYield;
                  return this.finalize(node2, new Node3.FunctionExpression(null, formalParameters.params, method, isGenerator));
                };
                Parser3.prototype.parseSetterMethod = function() {
                  var node2 = this.createNode();
                  var isGenerator = false;
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = !isGenerator;
                  var formalParameters = this.parseFormalParameters();
                  if (formalParameters.params.length !== 1) {
                    this.tolerateError(messages_1.Messages.BadSetterArity);
                  } else if (formalParameters.params[0] instanceof Node3.RestElement) {
                    this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                  }
                  var method = this.parsePropertyMethod(formalParameters);
                  this.context.allowYield = previousAllowYield;
                  return this.finalize(node2, new Node3.FunctionExpression(null, formalParameters.params, method, isGenerator));
                };
                Parser3.prototype.parseGeneratorMethod = function() {
                  var node2 = this.createNode();
                  var isGenerator = true;
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = true;
                  var params = this.parseFormalParameters();
                  this.context.allowYield = false;
                  var method = this.parsePropertyMethod(params);
                  this.context.allowYield = previousAllowYield;
                  return this.finalize(node2, new Node3.FunctionExpression(null, params.params, method, isGenerator));
                };
                Parser3.prototype.isStartOfExpression = function() {
                  var start = true;
                  var value = this.lookahead.value;
                  switch (this.lookahead.type) {
                    case 7:
                      start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                      break;
                    case 4:
                      start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                      break;
                  }
                  return start;
                };
                Parser3.prototype.parseYieldExpression = function() {
                  var node2 = this.createNode();
                  this.expectKeyword("yield");
                  var argument = null;
                  var delegate = false;
                  if (!this.hasLineTerminator) {
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = false;
                    delegate = this.match("*");
                    if (delegate) {
                      this.nextToken();
                      argument = this.parseAssignmentExpression();
                    } else if (this.isStartOfExpression()) {
                      argument = this.parseAssignmentExpression();
                    }
                    this.context.allowYield = previousAllowYield;
                  }
                  return this.finalize(node2, new Node3.YieldExpression(argument, delegate));
                };
                Parser3.prototype.parseClassElement = function(hasConstructor) {
                  var token = this.lookahead;
                  var node2 = this.createNode();
                  var kind = "";
                  var key = null;
                  var value = null;
                  var computed = false;
                  var method = false;
                  var isStatic = false;
                  var isAsync = false;
                  if (this.match("*")) {
                    this.nextToken();
                  } else {
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    var id = key;
                    if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                      token = this.lookahead;
                      isStatic = true;
                      computed = this.match("[");
                      if (this.match("*")) {
                        this.nextToken();
                      } else {
                        key = this.parseObjectPropertyKey();
                      }
                    }
                    if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                      var punctuator = this.lookahead.value;
                      if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                        isAsync = true;
                        token = this.lookahead;
                        key = this.parseObjectPropertyKey();
                        if (token.type === 3 && token.value === "constructor") {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                        }
                      }
                    }
                  }
                  var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                  if (token.type === 3) {
                    if (token.value === "get" && lookaheadPropertyKey) {
                      kind = "get";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      this.context.allowYield = false;
                      value = this.parseGetterMethod();
                    } else if (token.value === "set" && lookaheadPropertyKey) {
                      kind = "set";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      value = this.parseSetterMethod();
                    }
                  } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                    kind = "init";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    value = this.parseGeneratorMethod();
                    method = true;
                  }
                  if (!kind && key && this.match("(")) {
                    kind = "init";
                    value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                    method = true;
                  }
                  if (!kind) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  if (kind === "init") {
                    kind = "method";
                  }
                  if (!computed) {
                    if (isStatic && this.isPropertyKey(key, "prototype")) {
                      this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                    }
                    if (!isStatic && this.isPropertyKey(key, "constructor")) {
                      if (kind !== "method" || !method || value && value.generator) {
                        this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                      }
                      if (hasConstructor.value) {
                        this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                      } else {
                        hasConstructor.value = true;
                      }
                      kind = "constructor";
                    }
                  }
                  return this.finalize(node2, new Node3.MethodDefinition(key, computed, value, kind, isStatic));
                };
                Parser3.prototype.parseClassElementList = function() {
                  var body = [];
                  var hasConstructor = {value: false};
                  this.expect("{");
                  while (!this.match("}")) {
                    if (this.match(";")) {
                      this.nextToken();
                    } else {
                      body.push(this.parseClassElement(hasConstructor));
                    }
                  }
                  this.expect("}");
                  return body;
                };
                Parser3.prototype.parseClassBody = function() {
                  var node2 = this.createNode();
                  var elementList = this.parseClassElementList();
                  return this.finalize(node2, new Node3.ClassBody(elementList));
                };
                Parser3.prototype.parseClassDeclaration = function(identifierIsOptional) {
                  var node2 = this.createNode();
                  var previousStrict = this.context.strict;
                  this.context.strict = true;
                  this.expectKeyword("class");
                  var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
                  var superClass = null;
                  if (this.matchKeyword("extends")) {
                    this.nextToken();
                    superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                  }
                  var classBody = this.parseClassBody();
                  this.context.strict = previousStrict;
                  return this.finalize(node2, new Node3.ClassDeclaration(id, superClass, classBody));
                };
                Parser3.prototype.parseClassExpression = function() {
                  var node2 = this.createNode();
                  var previousStrict = this.context.strict;
                  this.context.strict = true;
                  this.expectKeyword("class");
                  var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
                  var superClass = null;
                  if (this.matchKeyword("extends")) {
                    this.nextToken();
                    superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                  }
                  var classBody = this.parseClassBody();
                  this.context.strict = previousStrict;
                  return this.finalize(node2, new Node3.ClassExpression(id, superClass, classBody));
                };
                Parser3.prototype.parseModule = function() {
                  this.context.strict = true;
                  this.context.isModule = true;
                  this.scanner.isModule = true;
                  var node2 = this.createNode();
                  var body = this.parseDirectivePrologues();
                  while (this.lookahead.type !== 2) {
                    body.push(this.parseStatementListItem());
                  }
                  return this.finalize(node2, new Node3.Module(body));
                };
                Parser3.prototype.parseScript = function() {
                  var node2 = this.createNode();
                  var body = this.parseDirectivePrologues();
                  while (this.lookahead.type !== 2) {
                    body.push(this.parseStatementListItem());
                  }
                  return this.finalize(node2, new Node3.Script(body));
                };
                Parser3.prototype.parseModuleSpecifier = function() {
                  var node2 = this.createNode();
                  if (this.lookahead.type !== 8) {
                    this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                  }
                  var token = this.nextToken();
                  var raw = this.getTokenRaw(token);
                  return this.finalize(node2, new Node3.Literal(token.value, raw));
                };
                Parser3.prototype.parseImportSpecifier = function() {
                  var node2 = this.createNode();
                  var imported;
                  var local;
                  if (this.lookahead.type === 3) {
                    imported = this.parseVariableIdentifier();
                    local = imported;
                    if (this.matchContextualKeyword("as")) {
                      this.nextToken();
                      local = this.parseVariableIdentifier();
                    }
                  } else {
                    imported = this.parseIdentifierName();
                    local = imported;
                    if (this.matchContextualKeyword("as")) {
                      this.nextToken();
                      local = this.parseVariableIdentifier();
                    } else {
                      this.throwUnexpectedToken(this.nextToken());
                    }
                  }
                  return this.finalize(node2, new Node3.ImportSpecifier(local, imported));
                };
                Parser3.prototype.parseNamedImports = function() {
                  this.expect("{");
                  var specifiers = [];
                  while (!this.match("}")) {
                    specifiers.push(this.parseImportSpecifier());
                    if (!this.match("}")) {
                      this.expect(",");
                    }
                  }
                  this.expect("}");
                  return specifiers;
                };
                Parser3.prototype.parseImportDefaultSpecifier = function() {
                  var node2 = this.createNode();
                  var local = this.parseIdentifierName();
                  return this.finalize(node2, new Node3.ImportDefaultSpecifier(local));
                };
                Parser3.prototype.parseImportNamespaceSpecifier = function() {
                  var node2 = this.createNode();
                  this.expect("*");
                  if (!this.matchContextualKeyword("as")) {
                    this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                  }
                  this.nextToken();
                  var local = this.parseIdentifierName();
                  return this.finalize(node2, new Node3.ImportNamespaceSpecifier(local));
                };
                Parser3.prototype.parseImportDeclaration = function() {
                  if (this.context.inFunctionBody) {
                    this.throwError(messages_1.Messages.IllegalImportDeclaration);
                  }
                  var node2 = this.createNode();
                  this.expectKeyword("import");
                  var src;
                  var specifiers = [];
                  if (this.lookahead.type === 8) {
                    src = this.parseModuleSpecifier();
                  } else {
                    if (this.match("{")) {
                      specifiers = specifiers.concat(this.parseNamedImports());
                    } else if (this.match("*")) {
                      specifiers.push(this.parseImportNamespaceSpecifier());
                    } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                      specifiers.push(this.parseImportDefaultSpecifier());
                      if (this.match(",")) {
                        this.nextToken();
                        if (this.match("*")) {
                          specifiers.push(this.parseImportNamespaceSpecifier());
                        } else if (this.match("{")) {
                          specifiers = specifiers.concat(this.parseNamedImports());
                        } else {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                      }
                    } else {
                      this.throwUnexpectedToken(this.nextToken());
                    }
                    if (!this.matchContextualKeyword("from")) {
                      var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                      this.throwError(message, this.lookahead.value);
                    }
                    this.nextToken();
                    src = this.parseModuleSpecifier();
                  }
                  this.consumeSemicolon();
                  return this.finalize(node2, new Node3.ImportDeclaration(specifiers, src));
                };
                Parser3.prototype.parseExportSpecifier = function() {
                  var node2 = this.createNode();
                  var local = this.parseIdentifierName();
                  var exported = local;
                  if (this.matchContextualKeyword("as")) {
                    this.nextToken();
                    exported = this.parseIdentifierName();
                  }
                  return this.finalize(node2, new Node3.ExportSpecifier(local, exported));
                };
                Parser3.prototype.parseExportDeclaration = function() {
                  if (this.context.inFunctionBody) {
                    this.throwError(messages_1.Messages.IllegalExportDeclaration);
                  }
                  var node2 = this.createNode();
                  this.expectKeyword("export");
                  var exportDeclaration;
                  if (this.matchKeyword("default")) {
                    this.nextToken();
                    if (this.matchKeyword("function")) {
                      var declaration = this.parseFunctionDeclaration(true);
                      exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                    } else if (this.matchKeyword("class")) {
                      var declaration = this.parseClassDeclaration(true);
                      exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                    } else if (this.matchContextualKeyword("async")) {
                      var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                      exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                    } else {
                      if (this.matchContextualKeyword("from")) {
                        this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                      }
                      var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                      this.consumeSemicolon();
                      exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                    }
                  } else if (this.match("*")) {
                    this.nextToken();
                    if (!this.matchContextualKeyword("from")) {
                      var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                      this.throwError(message, this.lookahead.value);
                    }
                    this.nextToken();
                    var src = this.parseModuleSpecifier();
                    this.consumeSemicolon();
                    exportDeclaration = this.finalize(node2, new Node3.ExportAllDeclaration(src));
                  } else if (this.lookahead.type === 4) {
                    var declaration = void 0;
                    switch (this.lookahead.value) {
                      case "let":
                      case "const":
                        declaration = this.parseLexicalDeclaration({inFor: false});
                        break;
                      case "var":
                      case "class":
                      case "function":
                        declaration = this.parseStatementListItem();
                        break;
                      default:
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    exportDeclaration = this.finalize(node2, new Node3.ExportNamedDeclaration(declaration, [], null));
                  } else if (this.matchAsyncFunction()) {
                    var declaration = this.parseFunctionDeclaration();
                    exportDeclaration = this.finalize(node2, new Node3.ExportNamedDeclaration(declaration, [], null));
                  } else {
                    var specifiers = [];
                    var source = null;
                    var isExportFromIdentifier = false;
                    this.expect("{");
                    while (!this.match("}")) {
                      isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                      specifiers.push(this.parseExportSpecifier());
                      if (!this.match("}")) {
                        this.expect(",");
                      }
                    }
                    this.expect("}");
                    if (this.matchContextualKeyword("from")) {
                      this.nextToken();
                      source = this.parseModuleSpecifier();
                      this.consumeSemicolon();
                    } else if (isExportFromIdentifier) {
                      var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                      this.throwError(message, this.lookahead.value);
                    } else {
                      this.consumeSemicolon();
                    }
                    exportDeclaration = this.finalize(node2, new Node3.ExportNamedDeclaration(null, specifiers, source));
                  }
                  return exportDeclaration;
                };
                return Parser3;
              }();
              exports5.Parser = Parser2;
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              function assert2(condition, message) {
                if (!condition) {
                  throw new Error("ASSERT: " + message);
                }
              }
              exports5.assert = assert2;
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var ErrorHandler = function() {
                function ErrorHandler2() {
                  this.errors = [];
                  this.tolerant = false;
                }
                ErrorHandler2.prototype.recordError = function(error) {
                  this.errors.push(error);
                };
                ErrorHandler2.prototype.tolerate = function(error) {
                  if (this.tolerant) {
                    this.recordError(error);
                  } else {
                    throw error;
                  }
                };
                ErrorHandler2.prototype.constructError = function(msg, column) {
                  var error = new Error(msg);
                  try {
                    throw error;
                  } catch (base) {
                    if (Object.create && Object.defineProperty) {
                      error = Object.create(base);
                      Object.defineProperty(error, "column", {value: column});
                    }
                  }
                  return error;
                };
                ErrorHandler2.prototype.createError = function(index, line, col, description) {
                  var msg = "Line " + line + ": " + description;
                  var error = this.constructError(msg, col);
                  error.index = index;
                  error.lineNumber = line;
                  error.description = description;
                  return error;
                };
                ErrorHandler2.prototype.throwError = function(index, line, col, description) {
                  throw this.createError(index, line, col, description);
                };
                ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
                  var error = this.createError(index, line, col, description);
                  if (this.tolerant) {
                    this.recordError(error);
                  } else {
                    throw error;
                  }
                };
                return ErrorHandler2;
              }();
              exports5.ErrorHandler = ErrorHandler;
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              exports5.Messages = {BadGetterArity: "Getter must not have any formal parameters", BadSetterArity: "Setter must have exactly one formal parameter", BadSetterRestParameter: "Setter function argument must not be a rest parameter", ConstructorIsAsync: "Class constructor may not be an async method", ConstructorSpecialMethod: "Class constructor may not be an accessor", DeclarationMissingInitializer: "Missing initializer in %0 declaration", DefaultRestParameter: "Unexpected token =", DuplicateBinding: "Duplicate binding %0", DuplicateConstructor: "A class may only have one constructor", DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals", ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer", GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts", IllegalBreak: "Illegal break statement", IllegalContinue: "Illegal continue statement", IllegalExportDeclaration: "Unexpected token", IllegalImportDeclaration: "Unexpected token", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list", IllegalReturn: "Illegal return statement", InvalidEscapedReservedWord: "Keyword must not contain escaped characters", InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence", InvalidLHSInAssignment: "Invalid left-hand side in assignment", InvalidLHSInForIn: "Invalid left-hand side in for-in", InvalidLHSInForLoop: "Invalid left-hand side in for-loop", InvalidModuleSpecifier: "Unexpected token", InvalidRegExp: "Invalid regular expression", LetInLexicalBinding: "let is disallowed as a lexically bound name", MissingFromClause: "Unexpected token", MultipleDefaultsInSwitch: "More than one default clause in switch statement", NewlineAfterThrow: "Illegal newline after throw", NoAsAfterImportNamespace: "Unexpected token", NoCatchOrFinally: "Missing catch or finally after try", ParameterAfterRestParameter: "Rest parameter must be last formal parameter", Redeclaration: "%0 '%1' has already been declared", StaticPrototype: "Classes may not have static property named prototype", StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode", StrictDelete: "Delete of an unqualified identifier in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block", StrictFunctionName: "Function name may not be eval or arguments in strict mode", StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode", StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode", StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode", StrictModeWith: "Strict mode code may not include a with statement", StrictOctalLiteral: "Octal literals are not allowed in strict mode.", StrictParamDupe: "Strict mode function may not have duplicate parameter names", StrictParamName: "Parameter name eval or arguments is not allowed in strict mode", StrictReservedWord: "Use of future reserved word in strict mode", StrictVarName: "Variable name may not be eval or arguments in strict mode", TemplateOctalLiteral: "Octal literals are not allowed in template strings.", UnexpectedEOS: "Unexpected end of input", UnexpectedIdentifier: "Unexpected identifier", UnexpectedNumber: "Unexpected number", UnexpectedReserved: "Unexpected reserved word", UnexpectedString: "Unexpected string", UnexpectedTemplate: "Unexpected quasi %0", UnexpectedToken: "Unexpected token %0", UnexpectedTokenIllegal: "Unexpected token ILLEGAL", UnknownLabel: "Undefined label '%0'", UnterminatedRegExp: "Invalid regular expression: missing /"};
            }, function(module4, exports5, __webpack_require__) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var assert_12 = __webpack_require__(9);
              var character_1 = __webpack_require__(4);
              var messages_1 = __webpack_require__(11);
              function hexValue(ch) {
                return "0123456789abcdef".indexOf(ch.toLowerCase());
              }
              function octalValue(ch) {
                return "01234567".indexOf(ch);
              }
              var Scanner = function() {
                function Scanner2(code, handler) {
                  this.source = code;
                  this.errorHandler = handler;
                  this.trackComment = false;
                  this.isModule = false;
                  this.length = code.length;
                  this.index = 0;
                  this.lineNumber = code.length > 0 ? 1 : 0;
                  this.lineStart = 0;
                  this.curlyStack = [];
                }
                Scanner2.prototype.saveState = function() {
                  return {index: this.index, lineNumber: this.lineNumber, lineStart: this.lineStart};
                };
                Scanner2.prototype.restoreState = function(state) {
                  this.index = state.index;
                  this.lineNumber = state.lineNumber;
                  this.lineStart = state.lineStart;
                };
                Scanner2.prototype.eof = function() {
                  return this.index >= this.length;
                };
                Scanner2.prototype.throwUnexpectedToken = function(message) {
                  if (message === void 0) {
                    message = messages_1.Messages.UnexpectedTokenIllegal;
                  }
                  return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                };
                Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                  if (message === void 0) {
                    message = messages_1.Messages.UnexpectedTokenIllegal;
                  }
                  this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                };
                Scanner2.prototype.skipSingleLineComment = function(offset) {
                  var comments2 = [];
                  var start, loc;
                  if (this.trackComment) {
                    comments2 = [];
                    start = this.index - offset;
                    loc = {start: {line: this.lineNumber, column: this.index - this.lineStart - offset}, end: {}};
                  }
                  while (!this.eof()) {
                    var ch = this.source.charCodeAt(this.index);
                    ++this.index;
                    if (character_1.Character.isLineTerminator(ch)) {
                      if (this.trackComment) {
                        loc.end = {line: this.lineNumber, column: this.index - this.lineStart - 1};
                        var entry = {multiLine: false, slice: [start + offset, this.index - 1], range: [start, this.index - 1], loc};
                        comments2.push(entry);
                      }
                      if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                        ++this.index;
                      }
                      ++this.lineNumber;
                      this.lineStart = this.index;
                      return comments2;
                    }
                  }
                  if (this.trackComment) {
                    loc.end = {line: this.lineNumber, column: this.index - this.lineStart};
                    var entry = {multiLine: false, slice: [start + offset, this.index], range: [start, this.index], loc};
                    comments2.push(entry);
                  }
                  return comments2;
                };
                Scanner2.prototype.skipMultiLineComment = function() {
                  var comments2 = [];
                  var start, loc;
                  if (this.trackComment) {
                    comments2 = [];
                    start = this.index - 2;
                    loc = {start: {line: this.lineNumber, column: this.index - this.lineStart - 2}, end: {}};
                  }
                  while (!this.eof()) {
                    var ch = this.source.charCodeAt(this.index);
                    if (character_1.Character.isLineTerminator(ch)) {
                      if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                        ++this.index;
                      }
                      ++this.lineNumber;
                      ++this.index;
                      this.lineStart = this.index;
                    } else if (ch === 42) {
                      if (this.source.charCodeAt(this.index + 1) === 47) {
                        this.index += 2;
                        if (this.trackComment) {
                          loc.end = {line: this.lineNumber, column: this.index - this.lineStart};
                          var entry = {multiLine: true, slice: [start + 2, this.index - 2], range: [start, this.index], loc};
                          comments2.push(entry);
                        }
                        return comments2;
                      }
                      ++this.index;
                    } else {
                      ++this.index;
                    }
                  }
                  if (this.trackComment) {
                    loc.end = {line: this.lineNumber, column: this.index - this.lineStart};
                    var entry = {multiLine: true, slice: [start + 2, this.index], range: [start, this.index], loc};
                    comments2.push(entry);
                  }
                  this.tolerateUnexpectedToken();
                  return comments2;
                };
                Scanner2.prototype.scanComments = function() {
                  var comments2;
                  if (this.trackComment) {
                    comments2 = [];
                  }
                  var start = this.index === 0;
                  while (!this.eof()) {
                    var ch = this.source.charCodeAt(this.index);
                    if (character_1.Character.isWhiteSpace(ch)) {
                      ++this.index;
                    } else if (character_1.Character.isLineTerminator(ch)) {
                      ++this.index;
                      if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                        ++this.index;
                      }
                      ++this.lineNumber;
                      this.lineStart = this.index;
                      start = true;
                    } else if (ch === 47) {
                      ch = this.source.charCodeAt(this.index + 1);
                      if (ch === 47) {
                        this.index += 2;
                        var comment2 = this.skipSingleLineComment(2);
                        if (this.trackComment) {
                          comments2 = comments2.concat(comment2);
                        }
                        start = true;
                      } else if (ch === 42) {
                        this.index += 2;
                        var comment2 = this.skipMultiLineComment();
                        if (this.trackComment) {
                          comments2 = comments2.concat(comment2);
                        }
                      } else {
                        break;
                      }
                    } else if (start && ch === 45) {
                      if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                        this.index += 3;
                        var comment2 = this.skipSingleLineComment(3);
                        if (this.trackComment) {
                          comments2 = comments2.concat(comment2);
                        }
                      } else {
                        break;
                      }
                    } else if (ch === 60 && !this.isModule) {
                      if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                        this.index += 4;
                        var comment2 = this.skipSingleLineComment(4);
                        if (this.trackComment) {
                          comments2 = comments2.concat(comment2);
                        }
                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  }
                  return comments2;
                };
                Scanner2.prototype.isFutureReservedWord = function(id) {
                  switch (id) {
                    case "enum":
                    case "export":
                    case "import":
                    case "super":
                      return true;
                    default:
                      return false;
                  }
                };
                Scanner2.prototype.isStrictModeReservedWord = function(id) {
                  switch (id) {
                    case "implements":
                    case "interface":
                    case "package":
                    case "private":
                    case "protected":
                    case "public":
                    case "static":
                    case "yield":
                    case "let":
                      return true;
                    default:
                      return false;
                  }
                };
                Scanner2.prototype.isRestrictedWord = function(id) {
                  return id === "eval" || id === "arguments";
                };
                Scanner2.prototype.isKeyword = function(id) {
                  switch (id.length) {
                    case 2:
                      return id === "if" || id === "in" || id === "do";
                    case 3:
                      return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                    case 4:
                      return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                    case 5:
                      return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                    case 6:
                      return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                    case 7:
                      return id === "default" || id === "finally" || id === "extends";
                    case 8:
                      return id === "function" || id === "continue" || id === "debugger";
                    case 10:
                      return id === "instanceof";
                    default:
                      return false;
                  }
                };
                Scanner2.prototype.codePointAt = function(i) {
                  var cp = this.source.charCodeAt(i);
                  if (cp >= 55296 && cp <= 56319) {
                    var second = this.source.charCodeAt(i + 1);
                    if (second >= 56320 && second <= 57343) {
                      var first = cp;
                      cp = (first - 55296) * 1024 + second - 56320 + 65536;
                    }
                  }
                  return cp;
                };
                Scanner2.prototype.scanHexEscape = function(prefix2) {
                  var len = prefix2 === "u" ? 4 : 2;
                  var code = 0;
                  for (var i = 0; i < len; ++i) {
                    if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                      code = code * 16 + hexValue(this.source[this.index++]);
                    } else {
                      return null;
                    }
                  }
                  return String.fromCharCode(code);
                };
                Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                  var ch = this.source[this.index];
                  var code = 0;
                  if (ch === "}") {
                    this.throwUnexpectedToken();
                  }
                  while (!this.eof()) {
                    ch = this.source[this.index++];
                    if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                      break;
                    }
                    code = code * 16 + hexValue(ch);
                  }
                  if (code > 1114111 || ch !== "}") {
                    this.throwUnexpectedToken();
                  }
                  return character_1.Character.fromCodePoint(code);
                };
                Scanner2.prototype.getIdentifier = function() {
                  var start = this.index++;
                  while (!this.eof()) {
                    var ch = this.source.charCodeAt(this.index);
                    if (ch === 92) {
                      this.index = start;
                      return this.getComplexIdentifier();
                    } else if (ch >= 55296 && ch < 57343) {
                      this.index = start;
                      return this.getComplexIdentifier();
                    }
                    if (character_1.Character.isIdentifierPart(ch)) {
                      ++this.index;
                    } else {
                      break;
                    }
                  }
                  return this.source.slice(start, this.index);
                };
                Scanner2.prototype.getComplexIdentifier = function() {
                  var cp = this.codePointAt(this.index);
                  var id = character_1.Character.fromCodePoint(cp);
                  this.index += id.length;
                  var ch;
                  if (cp === 92) {
                    if (this.source.charCodeAt(this.index) !== 117) {
                      this.throwUnexpectedToken();
                    }
                    ++this.index;
                    if (this.source[this.index] === "{") {
                      ++this.index;
                      ch = this.scanUnicodeCodePointEscape();
                    } else {
                      ch = this.scanHexEscape("u");
                      if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken();
                      }
                    }
                    id = ch;
                  }
                  while (!this.eof()) {
                    cp = this.codePointAt(this.index);
                    if (!character_1.Character.isIdentifierPart(cp)) {
                      break;
                    }
                    ch = character_1.Character.fromCodePoint(cp);
                    id += ch;
                    this.index += ch.length;
                    if (cp === 92) {
                      id = id.substr(0, id.length - 1);
                      if (this.source.charCodeAt(this.index) !== 117) {
                        this.throwUnexpectedToken();
                      }
                      ++this.index;
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        ch = this.scanUnicodeCodePointEscape();
                      } else {
                        ch = this.scanHexEscape("u");
                        if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken();
                        }
                      }
                      id += ch;
                    }
                  }
                  return id;
                };
                Scanner2.prototype.octalToDecimal = function(ch) {
                  var octal = ch !== "0";
                  var code = octalValue(ch);
                  if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                    octal = true;
                    code = code * 8 + octalValue(this.source[this.index++]);
                    if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                      code = code * 8 + octalValue(this.source[this.index++]);
                    }
                  }
                  return {code, octal};
                };
                Scanner2.prototype.scanIdentifier = function() {
                  var type2;
                  var start = this.index;
                  var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                  if (id.length === 1) {
                    type2 = 3;
                  } else if (this.isKeyword(id)) {
                    type2 = 4;
                  } else if (id === "null") {
                    type2 = 5;
                  } else if (id === "true" || id === "false") {
                    type2 = 1;
                  } else {
                    type2 = 3;
                  }
                  if (type2 !== 3 && start + id.length !== this.index) {
                    var restore = this.index;
                    this.index = start;
                    this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                    this.index = restore;
                  }
                  return {type: type2, value: id, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.scanPunctuator = function() {
                  var start = this.index;
                  var str = this.source[this.index];
                  switch (str) {
                    case "(":
                    case "{":
                      if (str === "{") {
                        this.curlyStack.push("{");
                      }
                      ++this.index;
                      break;
                    case ".":
                      ++this.index;
                      if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                        this.index += 2;
                        str = "...";
                      }
                      break;
                    case "}":
                      ++this.index;
                      this.curlyStack.pop();
                      break;
                    case ")":
                    case ";":
                    case ",":
                    case "[":
                    case "]":
                    case ":":
                    case "?":
                    case "~":
                      ++this.index;
                      break;
                    default:
                      str = this.source.substr(this.index, 4);
                      if (str === ">>>=") {
                        this.index += 4;
                      } else {
                        str = str.substr(0, 3);
                        if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                          this.index += 3;
                        } else {
                          str = str.substr(0, 2);
                          if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                            this.index += 2;
                          } else {
                            str = this.source[this.index];
                            if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                              ++this.index;
                            }
                          }
                        }
                      }
                  }
                  if (this.index === start) {
                    this.throwUnexpectedToken();
                  }
                  return {type: 7, value: str, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.scanHexLiteral = function(start) {
                  var num = "";
                  while (!this.eof()) {
                    if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                      break;
                    }
                    num += this.source[this.index++];
                  }
                  if (num.length === 0) {
                    this.throwUnexpectedToken();
                  }
                  if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                    this.throwUnexpectedToken();
                  }
                  return {type: 6, value: parseInt("0x" + num, 16), lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.scanBinaryLiteral = function(start) {
                  var num = "";
                  var ch;
                  while (!this.eof()) {
                    ch = this.source[this.index];
                    if (ch !== "0" && ch !== "1") {
                      break;
                    }
                    num += this.source[this.index++];
                  }
                  if (num.length === 0) {
                    this.throwUnexpectedToken();
                  }
                  if (!this.eof()) {
                    ch = this.source.charCodeAt(this.index);
                    if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                      this.throwUnexpectedToken();
                    }
                  }
                  return {type: 6, value: parseInt(num, 2), lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.scanOctalLiteral = function(prefix2, start) {
                  var num = "";
                  var octal = false;
                  if (character_1.Character.isOctalDigit(prefix2.charCodeAt(0))) {
                    octal = true;
                    num = "0" + this.source[this.index++];
                  } else {
                    ++this.index;
                  }
                  while (!this.eof()) {
                    if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                      break;
                    }
                    num += this.source[this.index++];
                  }
                  if (!octal && num.length === 0) {
                    this.throwUnexpectedToken();
                  }
                  if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    this.throwUnexpectedToken();
                  }
                  return {type: 6, value: parseInt(num, 8), octal, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.isImplicitOctalLiteral = function() {
                  for (var i = this.index + 1; i < this.length; ++i) {
                    var ch = this.source[i];
                    if (ch === "8" || ch === "9") {
                      return false;
                    }
                    if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                      return true;
                    }
                  }
                  return true;
                };
                Scanner2.prototype.scanNumericLiteral = function() {
                  var start = this.index;
                  var ch = this.source[start];
                  assert_12.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                  var num = "";
                  if (ch !== ".") {
                    num = this.source[this.index++];
                    ch = this.source[this.index];
                    if (num === "0") {
                      if (ch === "x" || ch === "X") {
                        ++this.index;
                        return this.scanHexLiteral(start);
                      }
                      if (ch === "b" || ch === "B") {
                        ++this.index;
                        return this.scanBinaryLiteral(start);
                      }
                      if (ch === "o" || ch === "O") {
                        return this.scanOctalLiteral(ch, start);
                      }
                      if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        if (this.isImplicitOctalLiteral()) {
                          return this.scanOctalLiteral(ch, start);
                        }
                      }
                    }
                    while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      num += this.source[this.index++];
                    }
                    ch = this.source[this.index];
                  }
                  if (ch === ".") {
                    num += this.source[this.index++];
                    while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      num += this.source[this.index++];
                    }
                    ch = this.source[this.index];
                  }
                  if (ch === "e" || ch === "E") {
                    num += this.source[this.index++];
                    ch = this.source[this.index];
                    if (ch === "+" || ch === "-") {
                      num += this.source[this.index++];
                    }
                    if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        num += this.source[this.index++];
                      }
                    } else {
                      this.throwUnexpectedToken();
                    }
                  }
                  if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                    this.throwUnexpectedToken();
                  }
                  return {type: 6, value: parseFloat(num), lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.scanStringLiteral = function() {
                  var start = this.index;
                  var quote = this.source[start];
                  assert_12.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                  ++this.index;
                  var octal = false;
                  var str = "";
                  while (!this.eof()) {
                    var ch = this.source[this.index++];
                    if (ch === quote) {
                      quote = "";
                      break;
                    } else if (ch === "\\") {
                      ch = this.source[this.index++];
                      if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                          case "u":
                            if (this.source[this.index] === "{") {
                              ++this.index;
                              str += this.scanUnicodeCodePointEscape();
                            } else {
                              var unescaped_1 = this.scanHexEscape(ch);
                              if (unescaped_1 === null) {
                                this.throwUnexpectedToken();
                              }
                              str += unescaped_1;
                            }
                            break;
                          case "x":
                            var unescaped = this.scanHexEscape(ch);
                            if (unescaped === null) {
                              this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                            }
                            str += unescaped;
                            break;
                          case "n":
                            str += "\n";
                            break;
                          case "r":
                            str += "\r";
                            break;
                          case "t":
                            str += "	";
                            break;
                          case "b":
                            str += "\b";
                            break;
                          case "f":
                            str += "\f";
                            break;
                          case "v":
                            str += "\v";
                            break;
                          case "8":
                          case "9":
                            str += ch;
                            this.tolerateUnexpectedToken();
                            break;
                          default:
                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                              var octToDec = this.octalToDecimal(ch);
                              octal = octToDec.octal || octal;
                              str += String.fromCharCode(octToDec.code);
                            } else {
                              str += ch;
                            }
                            break;
                        }
                      } else {
                        ++this.lineNumber;
                        if (ch === "\r" && this.source[this.index] === "\n") {
                          ++this.index;
                        }
                        this.lineStart = this.index;
                      }
                    } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      break;
                    } else {
                      str += ch;
                    }
                  }
                  if (quote !== "") {
                    this.index = start;
                    this.throwUnexpectedToken();
                  }
                  return {type: 8, value: str, octal, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.scanTemplate = function() {
                  var cooked = "";
                  var terminated = false;
                  var start = this.index;
                  var head = this.source[start] === "`";
                  var tail = false;
                  var rawOffset = 2;
                  ++this.index;
                  while (!this.eof()) {
                    var ch = this.source[this.index++];
                    if (ch === "`") {
                      rawOffset = 1;
                      tail = true;
                      terminated = true;
                      break;
                    } else if (ch === "$") {
                      if (this.source[this.index] === "{") {
                        this.curlyStack.push("${");
                        ++this.index;
                        terminated = true;
                        break;
                      }
                      cooked += ch;
                    } else if (ch === "\\") {
                      ch = this.source[this.index++];
                      if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                          case "n":
                            cooked += "\n";
                            break;
                          case "r":
                            cooked += "\r";
                            break;
                          case "t":
                            cooked += "	";
                            break;
                          case "u":
                            if (this.source[this.index] === "{") {
                              ++this.index;
                              cooked += this.scanUnicodeCodePointEscape();
                            } else {
                              var restore = this.index;
                              var unescaped_2 = this.scanHexEscape(ch);
                              if (unescaped_2 !== null) {
                                cooked += unescaped_2;
                              } else {
                                this.index = restore;
                                cooked += ch;
                              }
                            }
                            break;
                          case "x":
                            var unescaped = this.scanHexEscape(ch);
                            if (unescaped === null) {
                              this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                            }
                            cooked += unescaped;
                            break;
                          case "b":
                            cooked += "\b";
                            break;
                          case "f":
                            cooked += "\f";
                            break;
                          case "v":
                            cooked += "\v";
                            break;
                          default:
                            if (ch === "0") {
                              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                              }
                              cooked += "\0";
                            } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                              this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                            } else {
                              cooked += ch;
                            }
                            break;
                        }
                      } else {
                        ++this.lineNumber;
                        if (ch === "\r" && this.source[this.index] === "\n") {
                          ++this.index;
                        }
                        this.lineStart = this.index;
                      }
                    } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      ++this.lineNumber;
                      if (ch === "\r" && this.source[this.index] === "\n") {
                        ++this.index;
                      }
                      this.lineStart = this.index;
                      cooked += "\n";
                    } else {
                      cooked += ch;
                    }
                  }
                  if (!terminated) {
                    this.throwUnexpectedToken();
                  }
                  if (!head) {
                    this.curlyStack.pop();
                  }
                  return {type: 10, value: this.source.slice(start + 1, this.index - rawOffset), cooked, head, tail, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.testRegExp = function(pattern, flags) {
                  var astralSubstitute = "\uFFFF";
                  var tmp = pattern;
                  var self2 = this;
                  if (flags.indexOf("u") >= 0) {
                    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                      var codePoint = parseInt($1 || $2, 16);
                      if (codePoint > 1114111) {
                        self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                      }
                      if (codePoint <= 65535) {
                        return String.fromCharCode(codePoint);
                      }
                      return astralSubstitute;
                    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                  }
                  try {
                    RegExp(tmp);
                  } catch (e) {
                    this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                  }
                  try {
                    return new RegExp(pattern, flags);
                  } catch (exception) {
                    return null;
                  }
                };
                Scanner2.prototype.scanRegExpBody = function() {
                  var ch = this.source[this.index];
                  assert_12.assert(ch === "/", "Regular expression literal must start with a slash");
                  var str = this.source[this.index++];
                  var classMarker = false;
                  var terminated = false;
                  while (!this.eof()) {
                    ch = this.source[this.index++];
                    str += ch;
                    if (ch === "\\") {
                      ch = this.source[this.index++];
                      if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                      }
                      str += ch;
                    } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    } else if (classMarker) {
                      if (ch === "]") {
                        classMarker = false;
                      }
                    } else {
                      if (ch === "/") {
                        terminated = true;
                        break;
                      } else if (ch === "[") {
                        classMarker = true;
                      }
                    }
                  }
                  if (!terminated) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  }
                  return str.substr(1, str.length - 2);
                };
                Scanner2.prototype.scanRegExpFlags = function() {
                  var str = "";
                  var flags = "";
                  while (!this.eof()) {
                    var ch = this.source[this.index];
                    if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                      break;
                    }
                    ++this.index;
                    if (ch === "\\" && !this.eof()) {
                      ch = this.source[this.index];
                      if (ch === "u") {
                        ++this.index;
                        var restore = this.index;
                        var char = this.scanHexEscape("u");
                        if (char !== null) {
                          flags += char;
                          for (str += "\\u"; restore < this.index; ++restore) {
                            str += this.source[restore];
                          }
                        } else {
                          this.index = restore;
                          flags += "u";
                          str += "\\u";
                        }
                        this.tolerateUnexpectedToken();
                      } else {
                        str += "\\";
                        this.tolerateUnexpectedToken();
                      }
                    } else {
                      flags += ch;
                      str += ch;
                    }
                  }
                  return flags;
                };
                Scanner2.prototype.scanRegExp = function() {
                  var start = this.index;
                  var pattern = this.scanRegExpBody();
                  var flags = this.scanRegExpFlags();
                  var value = this.testRegExp(pattern, flags);
                  return {type: 9, value: "", pattern, flags, regex: value, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                };
                Scanner2.prototype.lex = function() {
                  if (this.eof()) {
                    return {type: 2, value: "", lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index};
                  }
                  var cp = this.source.charCodeAt(this.index);
                  if (character_1.Character.isIdentifierStart(cp)) {
                    return this.scanIdentifier();
                  }
                  if (cp === 40 || cp === 41 || cp === 59) {
                    return this.scanPunctuator();
                  }
                  if (cp === 39 || cp === 34) {
                    return this.scanStringLiteral();
                  }
                  if (cp === 46) {
                    if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                      return this.scanNumericLiteral();
                    }
                    return this.scanPunctuator();
                  }
                  if (character_1.Character.isDecimalDigit(cp)) {
                    return this.scanNumericLiteral();
                  }
                  if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                    return this.scanTemplate();
                  }
                  if (cp >= 55296 && cp < 57343) {
                    if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                      return this.scanIdentifier();
                    }
                  }
                  return this.scanPunctuator();
                };
                return Scanner2;
              }();
              exports5.Scanner = Scanner;
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              exports5.TokenName = {};
              exports5.TokenName[1] = "Boolean";
              exports5.TokenName[2] = "<end>";
              exports5.TokenName[3] = "Identifier";
              exports5.TokenName[4] = "Keyword";
              exports5.TokenName[5] = "Null";
              exports5.TokenName[6] = "Numeric";
              exports5.TokenName[7] = "Punctuator";
              exports5.TokenName[8] = "String";
              exports5.TokenName[9] = "RegularExpression";
              exports5.TokenName[10] = "Template";
            }, function(module4, exports5) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              exports5.XHTMLEntities = {quot: '"', amp: "&", apos: "'", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666", lang: "\u27E8", rang: "\u27E9"};
            }, function(module4, exports5, __webpack_require__) {
              Object.defineProperty(exports5, "__esModule", {value: true});
              var error_handler_1 = __webpack_require__(10);
              var scanner_1 = __webpack_require__(12);
              var token_1 = __webpack_require__(13);
              var Reader = function() {
                function Reader2() {
                  this.values = [];
                  this.curly = this.paren = -1;
                }
                Reader2.prototype.beforeFunctionExpression = function(t) {
                  return [
                    "(",
                    "{",
                    "[",
                    "in",
                    "typeof",
                    "instanceof",
                    "new",
                    "return",
                    "case",
                    "delete",
                    "throw",
                    "void",
                    "=",
                    "+=",
                    "-=",
                    "*=",
                    "**=",
                    "/=",
                    "%=",
                    "<<=",
                    ">>=",
                    ">>>=",
                    "&=",
                    "|=",
                    "^=",
                    ",",
                    "+",
                    "-",
                    "*",
                    "**",
                    "/",
                    "%",
                    "++",
                    "--",
                    "<<",
                    ">>",
                    ">>>",
                    "&",
                    "|",
                    "^",
                    "!",
                    "~",
                    "&&",
                    "||",
                    "?",
                    ":",
                    "===",
                    "==",
                    ">=",
                    "<=",
                    "<",
                    ">",
                    "!=",
                    "!=="
                  ].indexOf(t) >= 0;
                };
                Reader2.prototype.isRegexStart = function() {
                  var previous = this.values[this.values.length - 1];
                  var regex2 = previous !== null;
                  switch (previous) {
                    case "this":
                    case "]":
                      regex2 = false;
                      break;
                    case ")":
                      var keyword = this.values[this.paren - 1];
                      regex2 = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                      break;
                    case "}":
                      regex2 = false;
                      if (this.values[this.curly - 3] === "function") {
                        var check = this.values[this.curly - 4];
                        regex2 = check ? !this.beforeFunctionExpression(check) : false;
                      } else if (this.values[this.curly - 4] === "function") {
                        var check = this.values[this.curly - 5];
                        regex2 = check ? !this.beforeFunctionExpression(check) : true;
                      }
                      break;
                  }
                  return regex2;
                };
                Reader2.prototype.push = function(token) {
                  if (token.type === 7 || token.type === 4) {
                    if (token.value === "{") {
                      this.curly = this.values.length;
                    } else if (token.value === "(") {
                      this.paren = this.values.length;
                    }
                    this.values.push(token.value);
                  } else {
                    this.values.push(null);
                  }
                };
                return Reader2;
              }();
              var Tokenizer2 = function() {
                function Tokenizer3(code, config) {
                  this.errorHandler = new error_handler_1.ErrorHandler();
                  this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
                  this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                  this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
                  this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
                  this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
                  this.buffer = [];
                  this.reader = new Reader();
                }
                Tokenizer3.prototype.errors = function() {
                  return this.errorHandler.errors;
                };
                Tokenizer3.prototype.getNextToken = function() {
                  if (this.buffer.length === 0) {
                    var comments2 = this.scanner.scanComments();
                    if (this.scanner.trackComment) {
                      for (var i = 0; i < comments2.length; ++i) {
                        var e = comments2[i];
                        var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                        var comment2 = {type: e.multiLine ? "BlockComment" : "LineComment", value};
                        if (this.trackRange) {
                          comment2.range = e.range;
                        }
                        if (this.trackLoc) {
                          comment2.loc = e.loc;
                        }
                        this.buffer.push(comment2);
                      }
                    }
                    if (!this.scanner.eof()) {
                      var loc = void 0;
                      if (this.trackLoc) {
                        loc = {start: {line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart}, end: {}};
                      }
                      var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                      var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                      this.reader.push(token);
                      var entry = {type: token_1.TokenName[token.type], value: this.scanner.source.slice(token.start, token.end)};
                      if (this.trackRange) {
                        entry.range = [token.start, token.end];
                      }
                      if (this.trackLoc) {
                        loc.end = {line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                        entry.loc = loc;
                      }
                      if (token.type === 9) {
                        var pattern = token.pattern;
                        var flags = token.flags;
                        entry.regex = {pattern, flags};
                      }
                      this.buffer.push(entry);
                    }
                  }
                  return this.buffer.shift();
                };
                return Tokenizer3;
              }();
              exports5.Tokenizer = Tokenizer2;
            }]);
          });
        });
        var esprima = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.parse = void 0;
          function parse(source, options2) {
            var comments2 = [];
            var ast = esprima$1.parse(source, {loc: true, locations: true, comment: true, onComment: comments2, range: util$2.getOption(options2, "range", false), tolerant: util$2.getOption(options2, "tolerant", true), tokens: true, jsx: util$2.getOption(options2, "jsx", false)});
            if (!Array.isArray(ast.comments)) {
              ast.comments = comments2;
            }
            return ast;
          }
          exports4.parse = parse;
        });
        var _endianness;
        function endianness() {
          if (typeof _endianness === "undefined") {
            var a = new ArrayBuffer(2);
            var b = new Uint8Array(a);
            var c2 = new Uint16Array(a);
            b[0] = 1;
            b[1] = 2;
            if (c2[0] === 258) {
              _endianness = "BE";
            } else if (c2[0] === 513) {
              _endianness = "LE";
            } else {
              throw new Error("unable to figure out endianess");
            }
          }
          return _endianness;
        }
        function hostname() {
          if (typeof global2.location !== "undefined") {
            return global2.location.hostname;
          } else
            return "";
        }
        function loadavg() {
          return [];
        }
        function uptime() {
          return 0;
        }
        function freemem() {
          return Number.MAX_VALUE;
        }
        function totalmem() {
          return Number.MAX_VALUE;
        }
        function cpus() {
          return [];
        }
        function type() {
          return "Browser";
        }
        function release() {
          if (typeof global2.navigator !== "undefined") {
            return global2.navigator.appVersion;
          }
          return "";
        }
        function networkInterfaces() {
        }
        function getNetworkInterfaces() {
        }
        function arch() {
          return "javascript";
        }
        function platform() {
          return "browser";
        }
        function tmpDir() {
          return "/tmp";
        }
        var tmpdir = tmpDir;
        var EOL = "\n";
        var os = {EOL, tmpdir, tmpDir, networkInterfaces, getNetworkInterfaces, release, type, cpus, totalmem, freemem, uptime, loadavg, hostname, endianness};
        var os$1 = /* @__PURE__ */ Object.freeze({__proto__: null, endianness, hostname, loadavg, uptime, freemem, totalmem, cpus, type, release, networkInterfaces, getNetworkInterfaces, arch, platform, tmpDir, tmpdir, EOL, "default": os});
        var require$$13 = /* @__PURE__ */ getAugmentedNamespace2(os$1);
        var options = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.normalize = void 0;
          var defaults = {parser: esprima, tabWidth: 4, useTabs: false, reuseWhitespace: true, lineTerminator: require$$13.EOL || "\n", wrapColumn: 74, sourceFileName: null, sourceMapName: null, sourceRoot: null, inputSourceMap: null, range: false, tolerant: true, quote: null, trailingComma: false, arrayBracketSpacing: false, objectCurlySpacing: true, arrowParensAlways: false, flowObjectCommas: true, tokens: true};
          var hasOwn2 = defaults.hasOwnProperty;
          function normalize3(opts) {
            var options2 = opts || defaults;
            function get2(key) {
              return hasOwn2.call(options2, key) ? options2[key] : defaults[key];
            }
            return {tabWidth: +get2("tabWidth"), useTabs: !!get2("useTabs"), reuseWhitespace: !!get2("reuseWhitespace"), lineTerminator: get2("lineTerminator"), wrapColumn: Math.max(get2("wrapColumn"), 0), sourceFileName: get2("sourceFileName"), sourceMapName: get2("sourceMapName"), sourceRoot: get2("sourceRoot"), inputSourceMap: get2("inputSourceMap"), parser: get2("esprima") || get2("parser"), range: get2("range"), tolerant: get2("tolerant"), quote: get2("quote"), trailingComma: get2("trailingComma"), arrayBracketSpacing: get2("arrayBracketSpacing"), objectCurlySpacing: get2("objectCurlySpacing"), arrowParensAlways: get2("arrowParensAlways"), flowObjectCommas: get2("flowObjectCommas"), tokens: !!get2("tokens")};
          }
          exports4.normalize = normalize3;
        });
        var assert_1$1 = tslib_1.__importDefault(require$$0$1);
        var Mapping = function() {
          function Mapping2(sourceLines, sourceLoc, targetLoc) {
            if (targetLoc === void 0) {
              targetLoc = sourceLoc;
            }
            this.sourceLines = sourceLines;
            this.sourceLoc = sourceLoc;
            this.targetLoc = targetLoc;
          }
          Mapping2.prototype.slice = function(lines2, start, end) {
            if (end === void 0) {
              end = lines2.lastPos();
            }
            var sourceLines = this.sourceLines;
            var sourceLoc = this.sourceLoc;
            var targetLoc = this.targetLoc;
            function skip(name) {
              var sourceFromPos = sourceLoc[name];
              var targetFromPos = targetLoc[name];
              var targetToPos = start;
              if (name === "end") {
                targetToPos = end;
              } else {
                assert_1$1.default.strictEqual(name, "start");
              }
              return skipChars(sourceLines, sourceFromPos, lines2, targetFromPos, targetToPos);
            }
            if (util$2.comparePos(start, targetLoc.start) <= 0) {
              if (util$2.comparePos(targetLoc.end, end) <= 0) {
                targetLoc = {start: subtractPos(targetLoc.start, start.line, start.column), end: subtractPos(targetLoc.end, start.line, start.column)};
              } else if (util$2.comparePos(end, targetLoc.start) <= 0) {
                return null;
              } else {
                sourceLoc = {start: sourceLoc.start, end: skip("end")};
                targetLoc = {start: subtractPos(targetLoc.start, start.line, start.column), end: subtractPos(end, start.line, start.column)};
              }
            } else {
              if (util$2.comparePos(targetLoc.end, start) <= 0) {
                return null;
              }
              if (util$2.comparePos(targetLoc.end, end) <= 0) {
                sourceLoc = {start: skip("start"), end: sourceLoc.end};
                targetLoc = {
                  start: {line: 1, column: 0},
                  end: subtractPos(targetLoc.end, start.line, start.column)
                };
              } else {
                sourceLoc = {start: skip("start"), end: skip("end")};
                targetLoc = {
                  start: {line: 1, column: 0},
                  end: subtractPos(end, start.line, start.column)
                };
              }
            }
            return new Mapping2(this.sourceLines, sourceLoc, targetLoc);
          };
          Mapping2.prototype.add = function(line, column) {
            return new Mapping2(this.sourceLines, this.sourceLoc, {start: addPos(this.targetLoc.start, line, column), end: addPos(this.targetLoc.end, line, column)});
          };
          Mapping2.prototype.subtract = function(line, column) {
            return new Mapping2(this.sourceLines, this.sourceLoc, {start: subtractPos(this.targetLoc.start, line, column), end: subtractPos(this.targetLoc.end, line, column)});
          };
          Mapping2.prototype.indent = function(by, skipFirstLine, noNegativeColumns) {
            if (skipFirstLine === void 0) {
              skipFirstLine = false;
            }
            if (noNegativeColumns === void 0) {
              noNegativeColumns = false;
            }
            if (by === 0) {
              return this;
            }
            var targetLoc = this.targetLoc;
            var startLine = targetLoc.start.line;
            var endLine = targetLoc.end.line;
            if (skipFirstLine && startLine === 1 && endLine === 1) {
              return this;
            }
            targetLoc = {start: targetLoc.start, end: targetLoc.end};
            if (!skipFirstLine || startLine > 1) {
              var startColumn = targetLoc.start.column + by;
              targetLoc.start = {line: startLine, column: noNegativeColumns ? Math.max(0, startColumn) : startColumn};
            }
            if (!skipFirstLine || endLine > 1) {
              var endColumn = targetLoc.end.column + by;
              targetLoc.end = {line: endLine, column: noNegativeColumns ? Math.max(0, endColumn) : endColumn};
            }
            return new Mapping2(this.sourceLines, this.sourceLoc, targetLoc);
          };
          return Mapping2;
        }();
        var _default$2 = Mapping;
        function addPos(toPos, line, column) {
          return {line: toPos.line + line - 1, column: toPos.line === 1 ? toPos.column + column : toPos.column};
        }
        function subtractPos(fromPos, line, column) {
          return {line: fromPos.line - line + 1, column: fromPos.line === line ? fromPos.column - column : fromPos.column};
        }
        function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
          var targetComparison = util$2.comparePos(targetFromPos, targetToPos);
          if (targetComparison === 0) {
            return sourceFromPos;
          }
          var sourceCursor, targetCursor;
          if (targetComparison < 0) {
            sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();
            targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
            var lineDiff = targetToPos.line - targetCursor.line;
            sourceCursor.line += lineDiff;
            targetCursor.line += lineDiff;
            if (lineDiff > 0) {
              sourceCursor.column = 0;
              targetCursor.column = 0;
            } else {
              assert_1$1.default.strictEqual(lineDiff, 0);
            }
            while (util$2.comparePos(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {
              assert_1$1.default.ok(sourceLines.nextPos(sourceCursor, true));
              assert_1$1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
            }
          } else {
            sourceCursor = sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();
            targetCursor = targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();
            var lineDiff = targetToPos.line - targetCursor.line;
            sourceCursor.line += lineDiff;
            targetCursor.line += lineDiff;
            if (lineDiff < 0) {
              sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
              targetCursor.column = targetLines.getLineLength(targetCursor.line);
            } else {
              assert_1$1.default.strictEqual(lineDiff, 0);
            }
            while (util$2.comparePos(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {
              assert_1$1.default.ok(sourceLines.prevPos(sourceCursor, true));
              assert_1$1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
            }
          }
          return sourceCursor;
        }
        var mapping = /* @__PURE__ */ Object.defineProperty({default: _default$2}, "__esModule", {value: true});
        var lines = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.concat = exports4.fromString = exports4.countSpaces = exports4.Lines = void 0;
          var assert_12 = tslib_1.__importDefault(require$$0$1);
          var source_map_1 = tslib_1.__importDefault(sourceMap);
          var mapping_1 = tslib_1.__importDefault(mapping);
          var Lines = function() {
            function Lines2(infos, sourceFileName) {
              if (sourceFileName === void 0) {
                sourceFileName = null;
              }
              this.infos = infos;
              this.mappings = [];
              this.cachedSourceMap = null;
              this.cachedTabWidth = void 0;
              assert_12.default.ok(infos.length > 0);
              this.length = infos.length;
              this.name = sourceFileName || null;
              if (this.name) {
                this.mappings.push(new mapping_1.default(this, {start: this.firstPos(), end: this.lastPos()}));
              }
            }
            Lines2.prototype.toString = function(options2) {
              return this.sliceString(this.firstPos(), this.lastPos(), options2);
            };
            Lines2.prototype.getSourceMap = function(sourceMapName, sourceRoot) {
              if (!sourceMapName) {
                return null;
              }
              var targetLines = this;
              function updateJSON(json) {
                json = json || {};
                json.file = sourceMapName;
                if (sourceRoot) {
                  json.sourceRoot = sourceRoot;
                }
                return json;
              }
              if (targetLines.cachedSourceMap) {
                return updateJSON(targetLines.cachedSourceMap.toJSON());
              }
              var smg = new source_map_1.default.SourceMapGenerator(updateJSON());
              var sourcesToContents = {};
              targetLines.mappings.forEach(function(mapping2) {
                var sourceCursor = mapping2.sourceLines.skipSpaces(mapping2.sourceLoc.start) || mapping2.sourceLines.lastPos();
                var targetCursor = targetLines.skipSpaces(mapping2.targetLoc.start) || targetLines.lastPos();
                while (util$2.comparePos(sourceCursor, mapping2.sourceLoc.end) < 0 && util$2.comparePos(targetCursor, mapping2.targetLoc.end) < 0) {
                  var sourceChar = mapping2.sourceLines.charAt(sourceCursor);
                  var targetChar = targetLines.charAt(targetCursor);
                  assert_12.default.strictEqual(sourceChar, targetChar);
                  var sourceName = mapping2.sourceLines.name;
                  smg.addMapping({source: sourceName, original: {line: sourceCursor.line, column: sourceCursor.column}, generated: {line: targetCursor.line, column: targetCursor.column}});
                  if (!hasOwn2.call(sourcesToContents, sourceName)) {
                    var sourceContent = mapping2.sourceLines.toString();
                    smg.setSourceContent(sourceName, sourceContent);
                    sourcesToContents[sourceName] = sourceContent;
                  }
                  targetLines.nextPos(targetCursor, true);
                  mapping2.sourceLines.nextPos(sourceCursor, true);
                }
              });
              targetLines.cachedSourceMap = smg;
              return smg.toJSON();
            };
            Lines2.prototype.bootstrapCharAt = function(pos) {
              assert_12.default.strictEqual(typeof pos, "object");
              assert_12.default.strictEqual(typeof pos.line, "number");
              assert_12.default.strictEqual(typeof pos.column, "number");
              var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];
              if (typeof string === "undefined")
                return "";
              if (column === string.length && line < strings.length)
                return "\n";
              if (column >= string.length)
                return "";
              return string.charAt(column);
            };
            Lines2.prototype.charAt = function(pos) {
              assert_12.default.strictEqual(typeof pos, "object");
              assert_12.default.strictEqual(typeof pos.line, "number");
              assert_12.default.strictEqual(typeof pos.column, "number");
              var line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c2 = column;
              if (typeof info === "undefined" || c2 < 0)
                return "";
              var indent = this.getIndentAt(line);
              if (c2 < indent)
                return " ";
              c2 += info.sliceStart - indent;
              if (c2 === info.sliceEnd && line < this.length)
                return "\n";
              if (c2 >= info.sliceEnd)
                return "";
              return info.line.charAt(c2);
            };
            Lines2.prototype.stripMargin = function(width, skipFirstLine) {
              if (width === 0)
                return this;
              assert_12.default.ok(width > 0, "negative margin: " + width);
              if (skipFirstLine && this.length === 1)
                return this;
              var lines2 = new Lines2(this.infos.map(function(info, i) {
                if (info.line && (i > 0 || !skipFirstLine)) {
                  info = tslib_1.__assign(tslib_1.__assign({}, info), {indent: Math.max(0, info.indent - width)});
                }
                return info;
              }));
              if (this.mappings.length > 0) {
                var newMappings_1 = lines2.mappings;
                assert_12.default.strictEqual(newMappings_1.length, 0);
                this.mappings.forEach(function(mapping2) {
                  newMappings_1.push(mapping2.indent(width, skipFirstLine, true));
                });
              }
              return lines2;
            };
            Lines2.prototype.indent = function(by) {
              if (by === 0) {
                return this;
              }
              var lines2 = new Lines2(this.infos.map(function(info) {
                if (info.line && !info.locked) {
                  info = tslib_1.__assign(tslib_1.__assign({}, info), {indent: info.indent + by});
                }
                return info;
              }));
              if (this.mappings.length > 0) {
                var newMappings_2 = lines2.mappings;
                assert_12.default.strictEqual(newMappings_2.length, 0);
                this.mappings.forEach(function(mapping2) {
                  newMappings_2.push(mapping2.indent(by));
                });
              }
              return lines2;
            };
            Lines2.prototype.indentTail = function(by) {
              if (by === 0) {
                return this;
              }
              if (this.length < 2) {
                return this;
              }
              var lines2 = new Lines2(this.infos.map(function(info, i) {
                if (i > 0 && info.line && !info.locked) {
                  info = tslib_1.__assign(tslib_1.__assign({}, info), {indent: info.indent + by});
                }
                return info;
              }));
              if (this.mappings.length > 0) {
                var newMappings_3 = lines2.mappings;
                assert_12.default.strictEqual(newMappings_3.length, 0);
                this.mappings.forEach(function(mapping2) {
                  newMappings_3.push(mapping2.indent(by, true));
                });
              }
              return lines2;
            };
            Lines2.prototype.lockIndentTail = function() {
              if (this.length < 2) {
                return this;
              }
              return new Lines2(this.infos.map(function(info, i) {
                return tslib_1.__assign(tslib_1.__assign({}, info), {locked: i > 0});
              }));
            };
            Lines2.prototype.getIndentAt = function(line) {
              assert_12.default.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
              return Math.max(this.infos[line - 1].indent, 0);
            };
            Lines2.prototype.guessTabWidth = function() {
              if (typeof this.cachedTabWidth === "number") {
                return this.cachedTabWidth;
              }
              var counts = [];
              var lastIndent = 0;
              for (var line = 1, last2 = this.length; line <= last2; ++line) {
                var info = this.infos[line - 1];
                var sliced = info.line.slice(info.sliceStart, info.sliceEnd);
                if (isOnlyWhitespace(sliced)) {
                  continue;
                }
                var diff = Math.abs(info.indent - lastIndent);
                counts[diff] = ~~counts[diff] + 1;
                lastIndent = info.indent;
              }
              var maxCount = -1;
              var result = 2;
              for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
                if (hasOwn2.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
                  maxCount = counts[tabWidth];
                  result = tabWidth;
                }
              }
              return this.cachedTabWidth = result;
            };
            Lines2.prototype.startsWithComment = function() {
              if (this.infos.length === 0) {
                return false;
              }
              var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
              return firstLine.length === 0 || firstLine.slice(0, 2) === "//" || firstLine.slice(0, 2) === "/*";
            };
            Lines2.prototype.isOnlyWhitespace = function() {
              return isOnlyWhitespace(this.toString());
            };
            Lines2.prototype.isPrecededOnlyByWhitespace = function(pos) {
              var info = this.infos[pos.line - 1];
              var indent = Math.max(info.indent, 0);
              var diff = pos.column - indent;
              if (diff <= 0) {
                return true;
              }
              var start = info.sliceStart;
              var end = Math.min(start + diff, info.sliceEnd);
              var prefix2 = info.line.slice(start, end);
              return isOnlyWhitespace(prefix2);
            };
            Lines2.prototype.getLineLength = function(line) {
              var info = this.infos[line - 1];
              return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
            };
            Lines2.prototype.nextPos = function(pos, skipSpaces) {
              if (skipSpaces === void 0) {
                skipSpaces = false;
              }
              var l = Math.max(pos.line, 0), c2 = Math.max(pos.column, 0);
              if (c2 < this.getLineLength(l)) {
                pos.column += 1;
                return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
              }
              if (l < this.length) {
                pos.line += 1;
                pos.column = 0;
                return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
              }
              return false;
            };
            Lines2.prototype.prevPos = function(pos, skipSpaces) {
              if (skipSpaces === void 0) {
                skipSpaces = false;
              }
              var l = pos.line, c2 = pos.column;
              if (c2 < 1) {
                l -= 1;
                if (l < 1)
                  return false;
                c2 = this.getLineLength(l);
              } else {
                c2 = Math.min(c2 - 1, this.getLineLength(l));
              }
              pos.line = l;
              pos.column = c2;
              return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
            };
            Lines2.prototype.firstPos = function() {
              return {line: 1, column: 0};
            };
            Lines2.prototype.lastPos = function() {
              return {line: this.length, column: this.getLineLength(this.length)};
            };
            Lines2.prototype.skipSpaces = function(pos, backward, modifyInPlace) {
              if (backward === void 0) {
                backward = false;
              }
              if (modifyInPlace === void 0) {
                modifyInPlace = false;
              }
              if (pos) {
                pos = modifyInPlace ? pos : {line: pos.line, column: pos.column};
              } else if (backward) {
                pos = this.lastPos();
              } else {
                pos = this.firstPos();
              }
              if (backward) {
                while (this.prevPos(pos)) {
                  if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
                    return pos;
                  }
                }
                return null;
              } else {
                while (isOnlyWhitespace(this.charAt(pos))) {
                  if (!this.nextPos(pos)) {
                    return null;
                  }
                }
                return pos;
              }
            };
            Lines2.prototype.trimLeft = function() {
              var pos = this.skipSpaces(this.firstPos(), false, true);
              return pos ? this.slice(pos) : emptyLines;
            };
            Lines2.prototype.trimRight = function() {
              var pos = this.skipSpaces(this.lastPos(), true, true);
              return pos ? this.slice(this.firstPos(), pos) : emptyLines;
            };
            Lines2.prototype.trim = function() {
              var start = this.skipSpaces(this.firstPos(), false, true);
              if (start === null) {
                return emptyLines;
              }
              var end = this.skipSpaces(this.lastPos(), true, true);
              if (end === null) {
                return emptyLines;
              }
              return this.slice(start, end);
            };
            Lines2.prototype.eachPos = function(callback, startPos, skipSpaces) {
              if (startPos === void 0) {
                startPos = this.firstPos();
              }
              if (skipSpaces === void 0) {
                skipSpaces = false;
              }
              var pos = this.firstPos();
              if (startPos) {
                pos.line = startPos.line, pos.column = startPos.column;
              }
              if (skipSpaces && !this.skipSpaces(pos, false, true)) {
                return;
              }
              do
                callback.call(this, pos);
              while (this.nextPos(pos, skipSpaces));
            };
            Lines2.prototype.bootstrapSlice = function(start, end) {
              var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);
              if (strings.length > 0) {
                strings.push(strings.pop().slice(0, end.column));
                strings[0] = strings[0].slice(start.column);
              }
              return fromString2(strings.join("\n"));
            };
            Lines2.prototype.slice = function(start, end) {
              if (!end) {
                if (!start) {
                  return this;
                }
                end = this.lastPos();
              }
              if (!start) {
                throw new Error("cannot slice with end but not start");
              }
              var sliced = this.infos.slice(start.line - 1, end.line);
              if (start.line === end.line) {
                sliced[0] = sliceInfo(sliced[0], start.column, end.column);
              } else {
                assert_12.default.ok(start.line < end.line);
                sliced[0] = sliceInfo(sliced[0], start.column);
                sliced.push(sliceInfo(sliced.pop(), 0, end.column));
              }
              var lines2 = new Lines2(sliced);
              if (this.mappings.length > 0) {
                var newMappings_4 = lines2.mappings;
                assert_12.default.strictEqual(newMappings_4.length, 0);
                this.mappings.forEach(function(mapping2) {
                  var sliced2 = mapping2.slice(this, start, end);
                  if (sliced2) {
                    newMappings_4.push(sliced2);
                  }
                }, this);
              }
              return lines2;
            };
            Lines2.prototype.bootstrapSliceString = function(start, end, options2) {
              return this.slice(start, end).toString(options2);
            };
            Lines2.prototype.sliceString = function(start, end, options$1) {
              if (start === void 0) {
                start = this.firstPos();
              }
              if (end === void 0) {
                end = this.lastPos();
              }
              var _a = options.normalize(options$1), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;
              var parts = [];
              for (var line = start.line; line <= end.line; ++line) {
                var info = this.infos[line - 1];
                if (line === start.line) {
                  if (line === end.line) {
                    info = sliceInfo(info, start.column, end.column);
                  } else {
                    info = sliceInfo(info, start.column);
                  }
                } else if (line === end.line) {
                  info = sliceInfo(info, 0, end.column);
                }
                var indent = Math.max(info.indent, 0);
                var before_1 = info.line.slice(0, info.sliceStart);
                if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {
                  parts.push(info.line.slice(0, info.sliceEnd));
                  continue;
                }
                var tabs = 0;
                var spaces = indent;
                if (useTabs) {
                  tabs = Math.floor(indent / tabWidth);
                  spaces -= tabs * tabWidth;
                }
                var result = "";
                if (tabs > 0) {
                  result += new Array(tabs + 1).join("	");
                }
                if (spaces > 0) {
                  result += new Array(spaces + 1).join(" ");
                }
                result += info.line.slice(info.sliceStart, info.sliceEnd);
                parts.push(result);
              }
              return parts.join(lineTerminator);
            };
            Lines2.prototype.isEmpty = function() {
              return this.length < 2 && this.getLineLength(1) < 1;
            };
            Lines2.prototype.join = function(elements) {
              var separator = this;
              var infos = [];
              var mappings = [];
              var prevInfo;
              function appendLines(linesOrNull) {
                if (linesOrNull === null) {
                  return;
                }
                if (prevInfo) {
                  var info = linesOrNull.infos[0];
                  var indent = new Array(info.indent + 1).join(" ");
                  var prevLine_1 = infos.length;
                  var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
                  prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);
                  prevInfo.locked = prevInfo.locked || info.locked;
                  prevInfo.sliceEnd = prevInfo.line.length;
                  if (linesOrNull.mappings.length > 0) {
                    linesOrNull.mappings.forEach(function(mapping2) {
                      mappings.push(mapping2.add(prevLine_1, prevColumn_1));
                    });
                  }
                } else if (linesOrNull.mappings.length > 0) {
                  mappings.push.apply(mappings, linesOrNull.mappings);
                }
                linesOrNull.infos.forEach(function(info2, i) {
                  if (!prevInfo || i > 0) {
                    prevInfo = tslib_1.__assign({}, info2);
                    infos.push(prevInfo);
                  }
                });
              }
              function appendWithSeparator(linesOrNull, i) {
                if (i > 0)
                  appendLines(separator);
                appendLines(linesOrNull);
              }
              elements.map(function(elem) {
                var lines3 = fromString2(elem);
                if (lines3.isEmpty())
                  return null;
                return lines3;
              }).forEach(function(linesOrNull, i) {
                if (separator.isEmpty()) {
                  appendLines(linesOrNull);
                } else {
                  appendWithSeparator(linesOrNull, i);
                }
              });
              if (infos.length < 1)
                return emptyLines;
              var lines2 = new Lines2(infos);
              lines2.mappings = mappings;
              return lines2;
            };
            Lines2.prototype.concat = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var list = [this];
              list.push.apply(list, args);
              assert_12.default.strictEqual(list.length, args.length + 1);
              return emptyLines.join(list);
            };
            return Lines2;
          }();
          exports4.Lines = Lines;
          var fromStringCache = {};
          var hasOwn2 = fromStringCache.hasOwnProperty;
          var maxCacheKeyLen = 10;
          function countSpaces(spaces, tabWidth) {
            var count = 0;
            var len = spaces.length;
            for (var i = 0; i < len; ++i) {
              switch (spaces.charCodeAt(i)) {
                case 9: {
                  assert_12.default.strictEqual(typeof tabWidth, "number");
                  assert_12.default.ok(tabWidth > 0);
                  var next = Math.ceil(count / tabWidth) * tabWidth;
                  if (next === count) {
                    count += tabWidth;
                  } else {
                    count = next;
                  }
                  break;
                }
                case 11:
                case 12:
                case 13:
                case 65279:
                  break;
                case 32:
                default:
                  count += 1;
                  break;
              }
            }
            return count;
          }
          exports4.countSpaces = countSpaces;
          var leadingSpaceExp = /^\s*/;
          var lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
          function fromString2(string, options$1) {
            if (string instanceof Lines)
              return string;
            string += "";
            var tabWidth = options$1 && options$1.tabWidth;
            var tabless = string.indexOf("	") < 0;
            var cacheable = !options$1 && tabless && string.length <= maxCacheKeyLen;
            assert_12.default.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);
            if (cacheable && hasOwn2.call(fromStringCache, string))
              return fromStringCache[string];
            var lines2 = new Lines(string.split(lineTerminatorSeqExp).map(function(line) {
              var spaces = leadingSpaceExp.exec(line)[0];
              return {
                line,
                indent: countSpaces(spaces, tabWidth),
                locked: false,
                sliceStart: spaces.length,
                sliceEnd: line.length
              };
            }), options.normalize(options$1).sourceFileName);
            if (cacheable)
              fromStringCache[string] = lines2;
            return lines2;
          }
          exports4.fromString = fromString2;
          function isOnlyWhitespace(string) {
            return !/\S/.test(string);
          }
          function sliceInfo(info, startCol, endCol) {
            var sliceStart = info.sliceStart;
            var sliceEnd = info.sliceEnd;
            var indent = Math.max(info.indent, 0);
            var lineLength = indent + sliceEnd - sliceStart;
            if (typeof endCol === "undefined") {
              endCol = lineLength;
            }
            startCol = Math.max(startCol, 0);
            endCol = Math.min(endCol, lineLength);
            endCol = Math.max(endCol, startCol);
            if (endCol < indent) {
              indent = endCol;
              sliceEnd = sliceStart;
            } else {
              sliceEnd -= lineLength - endCol;
            }
            lineLength = endCol;
            lineLength -= startCol;
            if (startCol < indent) {
              indent -= startCol;
            } else {
              startCol -= indent;
              indent = 0;
              sliceStart += startCol;
            }
            assert_12.default.ok(indent >= 0);
            assert_12.default.ok(sliceStart <= sliceEnd);
            assert_12.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);
            if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {
              return info;
            }
            return {
              line: info.line,
              indent,
              locked: false,
              sliceStart,
              sliceEnd
            };
          }
          function concat(elements) {
            return emptyLines.join(elements);
          }
          exports4.concat = concat;
          var emptyLines = fromString2("");
        });
        var comments = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.printComments = exports4.attach = void 0;
          var assert_12 = tslib_1.__importDefault(require$$0$1);
          var types2 = tslib_1.__importStar(main$1);
          var n2 = types2.namedTypes;
          var isArray2 = types2.builtInTypes.array;
          var isObject3 = types2.builtInTypes.object;
          var childNodesCache = new WeakMap();
          function getSortedChildNodes(node2, lines2, resultArray) {
            if (!node2) {
              return resultArray;
            }
            util$2.fixFaultyLocations(node2, lines2);
            if (resultArray) {
              if (n2.Node.check(node2) && n2.SourceLocation.check(node2.loc)) {
                var i = resultArray.length - 1;
                for (; i >= 0; --i) {
                  var child = resultArray[i];
                  if (child && child.loc && util$2.comparePos(child.loc.end, node2.loc.start) <= 0) {
                    break;
                  }
                }
                resultArray.splice(i + 1, 0, node2);
                return resultArray;
              }
            } else {
              var childNodes = childNodesCache.get(node2);
              if (childNodes) {
                return childNodes;
              }
            }
            var names;
            if (isArray2.check(node2)) {
              names = Object.keys(node2);
            } else if (isObject3.check(node2)) {
              names = types2.getFieldNames(node2);
            } else {
              return resultArray;
            }
            if (!resultArray) {
              childNodesCache.set(node2, resultArray = []);
            }
            for (var i = 0, nameCount = names.length; i < nameCount; ++i) {
              getSortedChildNodes(node2[names[i]], lines2, resultArray);
            }
            return resultArray;
          }
          function decorateComment(node2, comment2, lines2) {
            var childNodes = getSortedChildNodes(node2, lines2);
            var left = 0;
            var right = childNodes && childNodes.length;
            var precedingNode;
            var followingNode;
            while (typeof right === "number" && left < right) {
              var middle = left + right >> 1;
              var child = childNodes[middle];
              if (util$2.comparePos(child.loc.start, comment2.loc.start) <= 0 && util$2.comparePos(comment2.loc.end, child.loc.end) <= 0) {
                decorateComment(comment2.enclosingNode = child, comment2, lines2);
                return;
              }
              if (util$2.comparePos(child.loc.end, comment2.loc.start) <= 0) {
                precedingNode = child;
                left = middle + 1;
                continue;
              }
              if (util$2.comparePos(comment2.loc.end, child.loc.start) <= 0) {
                followingNode = child;
                right = middle;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (precedingNode) {
              comment2.precedingNode = precedingNode;
            }
            if (followingNode) {
              comment2.followingNode = followingNode;
            }
          }
          function attach(comments2, ast, lines2) {
            if (!isArray2.check(comments2)) {
              return;
            }
            var tiesToBreak = [];
            comments2.forEach(function(comment2) {
              comment2.loc.lines = lines2;
              decorateComment(ast, comment2, lines2);
              var pn = comment2.precedingNode;
              var en = comment2.enclosingNode;
              var fn = comment2.followingNode;
              if (pn && fn) {
                var tieCount = tiesToBreak.length;
                if (tieCount > 0) {
                  var lastTie = tiesToBreak[tieCount - 1];
                  assert_12.default.strictEqual(lastTie.precedingNode === comment2.precedingNode, lastTie.followingNode === comment2.followingNode);
                  if (lastTie.followingNode !== comment2.followingNode) {
                    breakTies(tiesToBreak, lines2);
                  }
                }
                tiesToBreak.push(comment2);
              } else if (pn) {
                breakTies(tiesToBreak, lines2);
                addTrailingComment(pn, comment2);
              } else if (fn) {
                breakTies(tiesToBreak, lines2);
                addLeadingComment(fn, comment2);
              } else if (en) {
                breakTies(tiesToBreak, lines2);
                addDanglingComment(en, comment2);
              } else {
                throw new Error("AST contains no nodes at all?");
              }
            });
            breakTies(tiesToBreak, lines2);
            comments2.forEach(function(comment2) {
              delete comment2.precedingNode;
              delete comment2.enclosingNode;
              delete comment2.followingNode;
            });
          }
          exports4.attach = attach;
          function breakTies(tiesToBreak, lines2) {
            var tieCount = tiesToBreak.length;
            if (tieCount === 0) {
              return;
            }
            var pn = tiesToBreak[0].precedingNode;
            var fn = tiesToBreak[0].followingNode;
            var gapEndPos = fn.loc.start;
            var indexOfFirstLeadingComment = tieCount;
            var comment2;
            for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
              comment2 = tiesToBreak[indexOfFirstLeadingComment - 1];
              assert_12.default.strictEqual(comment2.precedingNode, pn);
              assert_12.default.strictEqual(comment2.followingNode, fn);
              var gap = lines2.sliceString(comment2.loc.end, gapEndPos);
              if (/\S/.test(gap)) {
                break;
              }
              gapEndPos = comment2.loc.start;
            }
            while (indexOfFirstLeadingComment <= tieCount && (comment2 = tiesToBreak[indexOfFirstLeadingComment]) && (comment2.type === "Line" || comment2.type === "CommentLine") && comment2.loc.start.column > fn.loc.start.column) {
              ++indexOfFirstLeadingComment;
            }
            tiesToBreak.forEach(function(comment3, i) {
              if (i < indexOfFirstLeadingComment) {
                addTrailingComment(pn, comment3);
              } else {
                addLeadingComment(fn, comment3);
              }
            });
            tiesToBreak.length = 0;
          }
          function addCommentHelper(node2, comment2) {
            var comments2 = node2.comments || (node2.comments = []);
            comments2.push(comment2);
          }
          function addLeadingComment(node2, comment2) {
            comment2.leading = true;
            comment2.trailing = false;
            addCommentHelper(node2, comment2);
          }
          function addDanglingComment(node2, comment2) {
            comment2.leading = false;
            comment2.trailing = false;
            addCommentHelper(node2, comment2);
          }
          function addTrailingComment(node2, comment2) {
            comment2.leading = false;
            comment2.trailing = true;
            addCommentHelper(node2, comment2);
          }
          function printLeadingComment(commentPath, print) {
            var comment2 = commentPath.getValue();
            n2.Comment.assert(comment2);
            var loc = comment2.loc;
            var lines$1 = loc && loc.lines;
            var parts = [print(commentPath)];
            if (comment2.trailing) {
              parts.push("\n");
            } else if (lines$1 instanceof lines.Lines) {
              var trailingSpace = lines$1.slice(loc.end, lines$1.skipSpaces(loc.end) || lines$1.lastPos());
              if (trailingSpace.length === 1) {
                parts.push(trailingSpace);
              } else {
                parts.push(new Array(trailingSpace.length).join("\n"));
              }
            } else {
              parts.push("\n");
            }
            return lines.concat(parts);
          }
          function printTrailingComment(commentPath, print) {
            var comment2 = commentPath.getValue(commentPath);
            n2.Comment.assert(comment2);
            var loc = comment2.loc;
            var lines$1 = loc && loc.lines;
            var parts = [];
            if (lines$1 instanceof lines.Lines) {
              var fromPos = lines$1.skipSpaces(loc.start, true) || lines$1.firstPos();
              var leadingSpace = lines$1.slice(fromPos, loc.start);
              if (leadingSpace.length === 1) {
                parts.push(leadingSpace);
              } else {
                parts.push(new Array(leadingSpace.length).join("\n"));
              }
            }
            parts.push(print(commentPath));
            return lines.concat(parts);
          }
          function printComments(path2, print) {
            var value = path2.getValue();
            var innerLines = print(path2);
            var comments2 = n2.Node.check(value) && types2.getFieldValue(value, "comments");
            if (!comments2 || comments2.length === 0) {
              return innerLines;
            }
            var leadingParts = [];
            var trailingParts = [innerLines];
            path2.each(function(commentPath) {
              var comment2 = commentPath.getValue();
              var leading = types2.getFieldValue(comment2, "leading");
              var trailing = types2.getFieldValue(comment2, "trailing");
              if (leading || trailing && !(n2.Statement.check(value) || comment2.type === "Block" || comment2.type === "CommentBlock")) {
                leadingParts.push(printLeadingComment(commentPath, print));
              } else if (trailing) {
                trailingParts.push(printTrailingComment(commentPath, print));
              }
            }, "comments");
            leadingParts.push.apply(leadingParts, trailingParts);
            return lines.concat(leadingParts);
          }
          exports4.printComments = printComments;
        });
        var parser$1 = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.parse = void 0;
          var assert_12 = tslib_1.__importDefault(require$$0$1);
          var types2 = tslib_1.__importStar(main$1);
          var b = types2.builders;
          var isObject3 = types2.builtInTypes.object;
          var isArray2 = types2.builtInTypes.array;
          var util2 = tslib_1.__importStar(util$2);
          function parse(source, options$1) {
            options$1 = options.normalize(options$1);
            var lines$1 = lines.fromString(source, options$1);
            var sourceWithoutTabs = lines$1.toString({tabWidth: options$1.tabWidth, reuseWhitespace: false, useTabs: false});
            var comments$1 = [];
            var ast = options$1.parser.parse(sourceWithoutTabs, {jsx: true, loc: true, locations: true, range: options$1.range, comment: true, onComment: comments$1, tolerant: util2.getOption(options$1, "tolerant", true), ecmaVersion: 6, sourceType: util2.getOption(options$1, "sourceType", "module")});
            var tokens = Array.isArray(ast.tokens) ? ast.tokens : esprima$1.tokenize(sourceWithoutTabs, {loc: true});
            delete ast.tokens;
            tokens.forEach(function(token) {
              if (typeof token.value !== "string") {
                token.value = lines$1.sliceString(token.loc.start, token.loc.end);
              }
            });
            if (Array.isArray(ast.comments)) {
              comments$1 = ast.comments;
              delete ast.comments;
            }
            if (ast.loc) {
              util2.fixFaultyLocations(ast, lines$1);
            } else {
              ast.loc = {start: lines$1.firstPos(), end: lines$1.lastPos()};
            }
            ast.loc.lines = lines$1;
            ast.loc.indent = 0;
            var file;
            var program;
            if (ast.type === "Program") {
              program = ast;
              file = b.file(ast, options$1.sourceFileName || null);
              file.loc = {start: lines$1.firstPos(), end: lines$1.lastPos(), lines: lines$1, indent: 0};
            } else if (ast.type === "File") {
              file = ast;
              program = file.program;
            }
            if (options$1.tokens) {
              file.tokens = tokens;
            }
            var trueProgramLoc = util2.getTrueLoc({type: program.type, loc: program.loc, body: [], comments: comments$1}, lines$1);
            program.loc.start = trueProgramLoc.start;
            program.loc.end = trueProgramLoc.end;
            comments.attach(comments$1, program.body.length ? file.program : file, lines$1);
            return new TreeCopier(lines$1, tokens).copy(file);
          }
          exports4.parse = parse;
          var TreeCopier = function TreeCopier2(lines2, tokens) {
            assert_12.default.ok(this instanceof TreeCopier2);
            this.lines = lines2;
            this.tokens = tokens;
            this.startTokenIndex = 0;
            this.endTokenIndex = tokens.length;
            this.indent = 0;
            this.seen = new Map();
          };
          var TCp = TreeCopier.prototype;
          TCp.copy = function(node2) {
            if (this.seen.has(node2)) {
              return this.seen.get(node2);
            }
            if (isArray2.check(node2)) {
              var copy_1 = new Array(node2.length);
              this.seen.set(node2, copy_1);
              node2.forEach(function(item, i2) {
                copy_1[i2] = this.copy(item);
              }, this);
              return copy_1;
            }
            if (!isObject3.check(node2)) {
              return node2;
            }
            util2.fixFaultyLocations(node2, this.lines);
            var copy2 = Object.create(Object.getPrototypeOf(node2), {original: {
              value: node2,
              configurable: false,
              enumerable: false,
              writable: true
            }});
            this.seen.set(node2, copy2);
            var loc = node2.loc;
            var oldIndent = this.indent;
            var newIndent = oldIndent;
            var oldStartTokenIndex = this.startTokenIndex;
            var oldEndTokenIndex = this.endTokenIndex;
            if (loc) {
              if (node2.type === "Block" || node2.type === "Line" || node2.type === "CommentBlock" || node2.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) {
                newIndent = this.indent = loc.start.column;
              }
              loc.lines = this.lines;
              loc.tokens = this.tokens;
              loc.indent = newIndent;
              this.findTokenRange(loc);
            }
            var keys = Object.keys(node2);
            var keyCount = keys.length;
            for (var i = 0; i < keyCount; ++i) {
              var key = keys[i];
              if (key === "loc") {
                copy2[key] = node2[key];
              } else if (key === "tokens" && node2.type === "File") {
                copy2[key] = node2[key];
              } else {
                copy2[key] = this.copy(node2[key]);
              }
            }
            this.indent = oldIndent;
            this.startTokenIndex = oldStartTokenIndex;
            this.endTokenIndex = oldEndTokenIndex;
            return copy2;
          };
          TCp.findTokenRange = function(loc) {
            while (this.startTokenIndex > 0) {
              var token = loc.tokens[this.startTokenIndex];
              if (util2.comparePos(loc.start, token.loc.start) < 0) {
                --this.startTokenIndex;
              } else
                break;
            }
            while (this.endTokenIndex < loc.tokens.length) {
              var token = loc.tokens[this.endTokenIndex];
              if (util2.comparePos(token.loc.end, loc.end) < 0) {
                ++this.endTokenIndex;
              } else
                break;
            }
            while (this.startTokenIndex < this.endTokenIndex) {
              var token = loc.tokens[this.startTokenIndex];
              if (util2.comparePos(token.loc.start, loc.start) < 0) {
                ++this.startTokenIndex;
              } else
                break;
            }
            loc.start.token = this.startTokenIndex;
            while (this.endTokenIndex > this.startTokenIndex) {
              var token = loc.tokens[this.endTokenIndex - 1];
              if (util2.comparePos(loc.end, token.loc.end) < 0) {
                --this.endTokenIndex;
              } else
                break;
            }
            loc.end.token = this.endTokenIndex;
          };
        });
        var assert_1 = tslib_1.__importDefault(require$$0$1);
        var types$3 = tslib_1.__importStar(main$1);
        var util$1 = tslib_1.__importStar(util$2);
        var n = types$3.namedTypes;
        var isArray = types$3.builtInTypes.array;
        var isNumber = types$3.builtInTypes.number;
        var PRECEDENCE = {};
        [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].forEach(function(tier, i) {
          tier.forEach(function(op) {
            PRECEDENCE[op] = i;
          });
        });
        var FastPath = function FastPath2(value) {
          assert_1.default.ok(this instanceof FastPath2);
          this.stack = [value];
        };
        var FPp = FastPath.prototype;
        FastPath.from = function(obj) {
          if (obj instanceof FastPath) {
            return obj.copy();
          }
          if (obj instanceof types$3.NodePath) {
            var copy2 = Object.create(FastPath.prototype);
            var stack = [obj.value];
            for (var pp = void 0; pp = obj.parentPath; obj = pp)
              stack.push(obj.name, pp.value);
            copy2.stack = stack.reverse();
            return copy2;
          }
          return new FastPath(obj);
        };
        FPp.copy = function copy2() {
          var copy3 = Object.create(FastPath.prototype);
          copy3.stack = this.stack.slice(0);
          return copy3;
        };
        FPp.getName = function getName3() {
          var s = this.stack;
          var len = s.length;
          if (len > 1) {
            return s[len - 2];
          }
          return null;
        };
        FPp.getValue = function getValue() {
          var s = this.stack;
          return s[s.length - 1];
        };
        FPp.valueIsDuplicate = function() {
          var s = this.stack;
          var valueIndex = s.length - 1;
          return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
        };
        function getNodeHelper(path2, count) {
          var s = path2.stack;
          for (var i = s.length - 1; i >= 0; i -= 2) {
            var value = s[i];
            if (n.Node.check(value) && --count < 0) {
              return value;
            }
          }
          return null;
        }
        FPp.getNode = function getNode(count) {
          if (count === void 0) {
            count = 0;
          }
          return getNodeHelper(this, ~~count);
        };
        FPp.getParentNode = function getParentNode(count) {
          if (count === void 0) {
            count = 0;
          }
          return getNodeHelper(this, ~~count + 1);
        };
        FPp.getRootValue = function getRootValue() {
          var s = this.stack;
          if (s.length % 2 === 0) {
            return s[1];
          }
          return s[0];
        };
        FPp.call = function call(callback) {
          var s = this.stack;
          var origLen = s.length;
          var value = s[origLen - 1];
          var argc = arguments.length;
          for (var i = 1; i < argc; ++i) {
            var name = arguments[i];
            value = value[name];
            s.push(name, value);
          }
          var result = callback(this);
          s.length = origLen;
          return result;
        };
        FPp.each = function each(callback) {
          var s = this.stack;
          var origLen = s.length;
          var value = s[origLen - 1];
          var argc = arguments.length;
          for (var i = 1; i < argc; ++i) {
            var name = arguments[i];
            value = value[name];
            s.push(name, value);
          }
          for (var i = 0; i < value.length; ++i) {
            if (i in value) {
              s.push(i, value[i]);
              callback(this);
              s.length -= 2;
            }
          }
          s.length = origLen;
        };
        FPp.map = function map(callback) {
          var s = this.stack;
          var origLen = s.length;
          var value = s[origLen - 1];
          var argc = arguments.length;
          for (var i = 1; i < argc; ++i) {
            var name = arguments[i];
            value = value[name];
            s.push(name, value);
          }
          var result = new Array(value.length);
          for (var i = 0; i < value.length; ++i) {
            if (i in value) {
              s.push(i, value[i]);
              result[i] = callback(this, i);
              s.length -= 2;
            }
          }
          s.length = origLen;
          return result;
        };
        FPp.hasParens = function() {
          var node2 = this.getNode();
          var prevToken = this.getPrevToken(node2);
          if (!prevToken) {
            return false;
          }
          var nextToken = this.getNextToken(node2);
          if (!nextToken) {
            return false;
          }
          if (prevToken.value === "(") {
            if (nextToken.value === ")") {
              return true;
            }
            var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);
            if (justNeedsOpeningParen) {
              return true;
            }
          }
          return false;
        };
        FPp.getPrevToken = function(node2) {
          node2 = node2 || this.getNode();
          var loc = node2 && node2.loc;
          var tokens = loc && loc.tokens;
          if (tokens && loc.start.token > 0) {
            var token = tokens[loc.start.token - 1];
            if (token) {
              var rootLoc = this.getRootValue().loc;
              if (util$1.comparePos(rootLoc.start, token.loc.start) <= 0) {
                return token;
              }
            }
          }
          return null;
        };
        FPp.getNextToken = function(node2) {
          node2 = node2 || this.getNode();
          var loc = node2 && node2.loc;
          var tokens = loc && loc.tokens;
          if (tokens && loc.end.token < tokens.length) {
            var token = tokens[loc.end.token];
            if (token) {
              var rootLoc = this.getRootValue().loc;
              if (util$1.comparePos(token.loc.end, rootLoc.end) <= 0) {
                return token;
              }
            }
          }
          return null;
        };
        FPp.needsParens = function(assumeExpressionContext) {
          var node2 = this.getNode();
          if (node2.type === "AssignmentExpression" && node2.left.type === "ObjectPattern") {
            return true;
          }
          var parent = this.getParentNode();
          if (!parent) {
            return false;
          }
          var name = this.getName();
          if (this.getValue() !== node2) {
            return false;
          }
          if (n.Statement.check(node2)) {
            return false;
          }
          if (node2.type === "Identifier") {
            return false;
          }
          if (parent.type === "ParenthesizedExpression" || node2.extra && node2.extra.parenthesized) {
            return false;
          }
          switch (node2.type) {
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
              return parent.type === "MemberExpression" && name === "object" && parent.object === node2;
            case "BinaryExpression":
            case "LogicalExpression":
              switch (parent.type) {
                case "CallExpression":
                  return name === "callee" && parent.callee === node2;
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                  return true;
                case "MemberExpression":
                  return name === "object" && parent.object === node2;
                case "BinaryExpression":
                case "LogicalExpression": {
                  var po = parent.operator;
                  var pp = PRECEDENCE[po];
                  var no = node2.operator;
                  var np = PRECEDENCE[no];
                  if (pp > np) {
                    return true;
                  }
                  if (pp === np && name === "right") {
                    assert_1.default.strictEqual(parent.right, node2);
                    return true;
                  }
                  break;
                }
                default:
                  return false;
              }
              break;
            case "SequenceExpression":
              switch (parent.type) {
                case "ReturnStatement":
                  return false;
                case "ForStatement":
                  return false;
                case "ExpressionStatement":
                  return name !== "expression";
                default:
                  return true;
              }
            case "IntersectionTypeAnnotation":
            case "UnionTypeAnnotation":
              return parent.type === "NullableTypeAnnotation";
            case "Literal":
              return parent.type === "MemberExpression" && isNumber.check(node2.value) && name === "object" && parent.object === node2;
            case "NumericLiteral":
              return parent.type === "MemberExpression" && name === "object" && parent.object === node2;
            case "YieldExpression":
            case "AwaitExpression":
            case "AssignmentExpression":
            case "ConditionalExpression":
              switch (parent.type) {
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "BinaryExpression":
                case "LogicalExpression":
                  return true;
                case "CallExpression":
                case "NewExpression":
                  return name === "callee" && parent.callee === node2;
                case "ConditionalExpression":
                  return name === "test" && parent.test === node2;
                case "MemberExpression":
                  return name === "object" && parent.object === node2;
                default:
                  return false;
              }
            case "ArrowFunctionExpression":
              if (n.CallExpression.check(parent) && name === "callee" && parent.callee === node2) {
                return true;
              }
              if (n.MemberExpression.check(parent) && name === "object" && parent.object === node2) {
                return true;
              }
              if (n.TSAsExpression && n.TSAsExpression.check(parent) && name === "expression" && parent.expression === node2) {
                return true;
              }
              return isBinary(parent);
            case "ObjectExpression":
              if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node2) {
                return true;
              }
              break;
            case "TSAsExpression":
              if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node2 && node2.expression.type === "ObjectExpression") {
                return true;
              }
              break;
            case "CallExpression":
              if (name === "declaration" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node2.callee)) {
                return true;
              }
          }
          if (parent.type === "NewExpression" && name === "callee" && parent.callee === node2) {
            return containsCallExpression(node2);
          }
          if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {
            return true;
          }
          return false;
        };
        function isBinary(node2) {
          return n.BinaryExpression.check(node2) || n.LogicalExpression.check(node2);
        }
        function containsCallExpression(node2) {
          if (n.CallExpression.check(node2)) {
            return true;
          }
          if (isArray.check(node2)) {
            return node2.some(containsCallExpression);
          }
          if (n.Node.check(node2)) {
            return types$3.someField(node2, function(_name, child) {
              return containsCallExpression(child);
            });
          }
          return false;
        }
        FPp.canBeFirstInStatement = function() {
          var node2 = this.getNode();
          if (n.FunctionExpression.check(node2)) {
            return false;
          }
          if (n.ObjectExpression.check(node2)) {
            return false;
          }
          if (n.ClassExpression.check(node2)) {
            return false;
          }
          return true;
        };
        FPp.firstInStatement = function() {
          var s = this.stack;
          var parentName, parent;
          var childName, child;
          for (var i = s.length - 1; i >= 0; i -= 2) {
            if (n.Node.check(s[i])) {
              childName = parentName;
              child = parent;
              parentName = s[i - 1];
              parent = s[i];
            }
            if (!parent || !child) {
              continue;
            }
            if (n.BlockStatement.check(parent) && parentName === "body" && childName === 0) {
              assert_1.default.strictEqual(parent.body[0], child);
              return true;
            }
            if (n.ExpressionStatement.check(parent) && childName === "expression") {
              assert_1.default.strictEqual(parent.expression, child);
              return true;
            }
            if (n.AssignmentExpression.check(parent) && childName === "left") {
              assert_1.default.strictEqual(parent.left, child);
              return true;
            }
            if (n.ArrowFunctionExpression.check(parent) && childName === "body") {
              assert_1.default.strictEqual(parent.body, child);
              return true;
            }
            if (n.SequenceExpression.check(parent) && parentName === "expressions" && childName === 0) {
              assert_1.default.strictEqual(parent.expressions[0], child);
              continue;
            }
            if (n.CallExpression.check(parent) && childName === "callee") {
              assert_1.default.strictEqual(parent.callee, child);
              continue;
            }
            if (n.MemberExpression.check(parent) && childName === "object") {
              assert_1.default.strictEqual(parent.object, child);
              continue;
            }
            if (n.ConditionalExpression.check(parent) && childName === "test") {
              assert_1.default.strictEqual(parent.test, child);
              continue;
            }
            if (isBinary(parent) && childName === "left") {
              assert_1.default.strictEqual(parent.left, child);
              continue;
            }
            if (n.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
              assert_1.default.strictEqual(parent.argument, child);
              continue;
            }
            return false;
          }
          return true;
        };
        var _default$1 = FastPath;
        var fastPath = /* @__PURE__ */ Object.defineProperty({default: _default$1}, "__esModule", {value: true});
        var patcher = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.getReprinter = exports4.Patcher = void 0;
          var assert_12 = tslib_1.__importDefault(require$$0$1);
          var linesModule = tslib_1.__importStar(lines);
          var types2 = tslib_1.__importStar(main$1);
          var Printable = types2.namedTypes.Printable;
          var Expression2 = types2.namedTypes.Expression;
          var ReturnStatement = types2.namedTypes.ReturnStatement;
          var SourceLocation2 = types2.namedTypes.SourceLocation;
          var fast_path_1 = tslib_1.__importDefault(fastPath);
          var isObject3 = types2.builtInTypes.object;
          var isArray2 = types2.builtInTypes.array;
          var isString2 = types2.builtInTypes.string;
          var riskyAdjoiningCharExp = /[0-9a-z_$]/i;
          var Patcher = function Patcher2(lines2) {
            assert_12.default.ok(this instanceof Patcher2);
            assert_12.default.ok(lines2 instanceof linesModule.Lines);
            var self2 = this, replacements = [];
            self2.replace = function(loc, lines3) {
              if (isString2.check(lines3))
                lines3 = linesModule.fromString(lines3);
              replacements.push({lines: lines3, start: loc.start, end: loc.end});
            };
            self2.get = function(loc) {
              loc = loc || {start: {line: 1, column: 0}, end: {line: lines2.length, column: lines2.getLineLength(lines2.length)}};
              var sliceFrom = loc.start, toConcat = [];
              function pushSlice(from2, to) {
                assert_12.default.ok(util$2.comparePos(from2, to) <= 0);
                toConcat.push(lines2.slice(from2, to));
              }
              replacements.sort(function(a, b) {
                return util$2.comparePos(a.start, b.start);
              }).forEach(function(rep) {
                if (util$2.comparePos(sliceFrom, rep.start) > 0)
                  ;
                else {
                  pushSlice(sliceFrom, rep.start);
                  toConcat.push(rep.lines);
                  sliceFrom = rep.end;
                }
              });
              pushSlice(sliceFrom, loc.end);
              return linesModule.concat(toConcat);
            };
          };
          exports4.Patcher = Patcher;
          var Pp = Patcher.prototype;
          Pp.tryToReprintComments = function(newNode, oldNode, print) {
            var patcher2 = this;
            if (!newNode.comments && !oldNode.comments) {
              return true;
            }
            var newPath = fast_path_1.default.from(newNode);
            var oldPath = fast_path_1.default.from(oldNode);
            newPath.stack.push("comments", getSurroundingComments(newNode));
            oldPath.stack.push("comments", getSurroundingComments(oldNode));
            var reprints = [];
            var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
            if (ableToReprintComments && reprints.length > 0) {
              reprints.forEach(function(reprint) {
                var oldComment = reprint.oldPath.getValue();
                assert_12.default.ok(oldComment.leading || oldComment.trailing);
                patcher2.replace(oldComment.loc, print(reprint.newPath).indentTail(oldComment.loc.indent));
              });
            }
            return ableToReprintComments;
          };
          function getSurroundingComments(node2) {
            var result = [];
            if (node2.comments && node2.comments.length > 0) {
              node2.comments.forEach(function(comment2) {
                if (comment2.leading || comment2.trailing) {
                  result.push(comment2);
                }
              });
            }
            return result;
          }
          Pp.deleteComments = function(node2) {
            if (!node2.comments) {
              return;
            }
            var patcher2 = this;
            node2.comments.forEach(function(comment2) {
              if (comment2.leading) {
                patcher2.replace({start: comment2.loc.start, end: node2.loc.lines.skipSpaces(comment2.loc.end, false, false)}, "");
              } else if (comment2.trailing) {
                patcher2.replace({start: node2.loc.lines.skipSpaces(comment2.loc.start, true, false), end: comment2.loc.end}, "");
              }
            });
          };
          function getReprinter(path2) {
            assert_12.default.ok(path2 instanceof fast_path_1.default);
            var node2 = path2.getValue();
            if (!Printable.check(node2))
              return;
            var orig = node2.original;
            var origLoc = orig && orig.loc;
            var lines2 = origLoc && origLoc.lines;
            var reprints = [];
            if (!lines2 || !findReprints(path2, reprints))
              return;
            return function(print) {
              var patcher2 = new Patcher(lines2);
              reprints.forEach(function(reprint) {
                var newNode = reprint.newPath.getValue();
                var oldNode = reprint.oldPath.getValue();
                SourceLocation2.assert(oldNode.loc, true);
                var needToPrintNewPathWithComments = !patcher2.tryToReprintComments(newNode, oldNode, print);
                if (needToPrintNewPathWithComments) {
                  patcher2.deleteComments(oldNode);
                }
                var newLines = print(reprint.newPath, {
                  includeComments: needToPrintNewPathWithComments,
                  avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()
                }).indentTail(oldNode.loc.indent);
                var nls = needsLeadingSpace(lines2, oldNode.loc, newLines);
                var nts = needsTrailingSpace(lines2, oldNode.loc, newLines);
                if (nls || nts) {
                  var newParts = [];
                  nls && newParts.push(" ");
                  newParts.push(newLines);
                  nts && newParts.push(" ");
                  newLines = linesModule.concat(newParts);
                }
                patcher2.replace(oldNode.loc, newLines);
              });
              var patchedLines = patcher2.get(origLoc).indentTail(-orig.loc.indent);
              if (path2.needsParens()) {
                return linesModule.concat(["(", patchedLines, ")"]);
              }
              return patchedLines;
            };
          }
          exports4.getReprinter = getReprinter;
          function needsLeadingSpace(oldLines, oldLoc, newLines) {
            var posBeforeOldLoc = util$2.copyPos(oldLoc.start);
            var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
            var newFirstChar = newLines.charAt(newLines.firstPos());
            return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
          }
          function needsTrailingSpace(oldLines, oldLoc, newLines) {
            var charAfterOldLoc = oldLines.charAt(oldLoc.end);
            var newLastPos = newLines.lastPos();
            var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
            return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
          }
          function findReprints(newPath, reprints) {
            var newNode = newPath.getValue();
            Printable.assert(newNode);
            var oldNode = newNode.original;
            Printable.assert(oldNode);
            assert_12.default.deepEqual(reprints, []);
            if (newNode.type !== oldNode.type) {
              return false;
            }
            var oldPath = new fast_path_1.default(oldNode);
            var canReprint = findChildReprints(newPath, oldPath, reprints);
            if (!canReprint) {
              reprints.length = 0;
            }
            return canReprint;
          }
          function findAnyReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            var oldNode = oldPath.getValue();
            if (newNode === oldNode)
              return true;
            if (isArray2.check(newNode))
              return findArrayReprints(newPath, oldPath, reprints);
            if (isObject3.check(newNode))
              return findObjectReprints(newPath, oldPath, reprints);
            return false;
          }
          function findArrayReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            var oldNode = oldPath.getValue();
            if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
              return true;
            }
            isArray2.assert(newNode);
            var len = newNode.length;
            if (!(isArray2.check(oldNode) && oldNode.length === len))
              return false;
            for (var i = 0; i < len; ++i) {
              newPath.stack.push(i, newNode[i]);
              oldPath.stack.push(i, oldNode[i]);
              var canReprint = findAnyReprints(newPath, oldPath, reprints);
              newPath.stack.length -= 2;
              oldPath.stack.length -= 2;
              if (!canReprint) {
                return false;
              }
            }
            return true;
          }
          function findObjectReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            isObject3.assert(newNode);
            if (newNode.original === null) {
              return false;
            }
            var oldNode = oldPath.getValue();
            if (!isObject3.check(oldNode))
              return false;
            if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
              return true;
            }
            if (Printable.check(newNode)) {
              if (!Printable.check(oldNode)) {
                return false;
              }
              var newParentNode = newPath.getParentNode();
              var oldParentNode = oldPath.getParentNode();
              if (oldParentNode !== null && oldParentNode.type === "FunctionTypeAnnotation" && newParentNode !== null && newParentNode.type === "FunctionTypeAnnotation") {
                var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;
                var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
                if (!oldNeedsParens && newNeedParens) {
                  return false;
                }
              }
              if (newNode.type === oldNode.type) {
                var childReprints = [];
                if (findChildReprints(newPath, oldPath, childReprints)) {
                  reprints.push.apply(reprints, childReprints);
                } else if (oldNode.loc) {
                  reprints.push({oldPath: oldPath.copy(), newPath: newPath.copy()});
                } else {
                  return false;
                }
                return true;
              }
              if (Expression2.check(newNode) && Expression2.check(oldNode) && oldNode.loc) {
                reprints.push({oldPath: oldPath.copy(), newPath: newPath.copy()});
                return true;
              }
              return false;
            }
            return findChildReprints(newPath, oldPath, reprints);
          }
          function findChildReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            var oldNode = oldPath.getValue();
            isObject3.assert(newNode);
            isObject3.assert(oldNode);
            if (newNode.original === null) {
              return false;
            }
            if (newPath.needsParens() && !oldPath.hasParens()) {
              return false;
            }
            var keys = util$2.getUnionOfKeys(oldNode, newNode);
            if (oldNode.type === "File" || newNode.type === "File") {
              delete keys.tokens;
            }
            delete keys.loc;
            var originalReprintCount = reprints.length;
            for (var k in keys) {
              if (k.charAt(0) === "_") {
                continue;
              }
              newPath.stack.push(k, types2.getFieldValue(newNode, k));
              oldPath.stack.push(k, types2.getFieldValue(oldNode, k));
              var canReprint = findAnyReprints(newPath, oldPath, reprints);
              newPath.stack.length -= 2;
              oldPath.stack.length -= 2;
              if (!canReprint) {
                return false;
              }
            }
            if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {
              return false;
            }
            return true;
          }
        });
        var printer = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.Printer = void 0;
          var assert_12 = tslib_1.__importDefault(require$$0$1);
          var types2 = tslib_1.__importStar(main$1);
          var namedTypes2 = types2.namedTypes;
          var isString2 = types2.builtInTypes.string;
          var isObject3 = types2.builtInTypes.object;
          var fast_path_1 = tslib_1.__importDefault(fastPath);
          var util2 = tslib_1.__importStar(util$2);
          var PrintResult = function PrintResult2(code, sourceMap2) {
            assert_12.default.ok(this instanceof PrintResult2);
            isString2.assert(code);
            this.code = code;
            if (sourceMap2) {
              isObject3.assert(sourceMap2);
              this.map = sourceMap2;
            }
          };
          var PRp = PrintResult.prototype;
          var warnedAboutToString = false;
          PRp.toString = function() {
            if (!warnedAboutToString) {
              console.warn("Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged.");
              warnedAboutToString = true;
            }
            return this.code;
          };
          var emptyPrintResult = new PrintResult("");
          var Printer = function Printer2(config) {
            assert_12.default.ok(this instanceof Printer2);
            var explicitTabWidth = config && config.tabWidth;
            config = options.normalize(config);
            config.sourceFileName = null;
            function makePrintFunctionWith(options2, overrides) {
              options2 = Object.assign({}, options2, overrides);
              return function(path2) {
                return print(path2, options2);
              };
            }
            function print(path2, options2) {
              assert_12.default.ok(path2 instanceof fast_path_1.default);
              options2 = options2 || {};
              if (options2.includeComments) {
                return comments.printComments(path2, makePrintFunctionWith(options2, {includeComments: false}));
              }
              var oldTabWidth = config.tabWidth;
              if (!explicitTabWidth) {
                var loc = path2.getNode().loc;
                if (loc && loc.lines && loc.lines.guessTabWidth) {
                  config.tabWidth = loc.lines.guessTabWidth();
                }
              }
              var reprinter = patcher.getReprinter(path2);
              var lines2 = reprinter ? reprinter(print) : genericPrint(path2, config, options2, makePrintFunctionWith(options2, {includeComments: true, avoidRootParens: false}));
              config.tabWidth = oldTabWidth;
              return lines2;
            }
            this.print = function(ast) {
              if (!ast) {
                return emptyPrintResult;
              }
              var lines2 = print(fast_path_1.default.from(ast), {includeComments: true, avoidRootParens: false});
              return new PrintResult(lines2.toString(config), util2.composeSourceMaps(config.inputSourceMap, lines2.getSourceMap(config.sourceMapName, config.sourceRoot)));
            };
            this.printGenerically = function(ast) {
              if (!ast) {
                return emptyPrintResult;
              }
              function printGenerically(path3) {
                return comments.printComments(path3, function(path4) {
                  return genericPrint(path4, config, {includeComments: true, avoidRootParens: false}, printGenerically);
                });
              }
              var path2 = fast_path_1.default.from(ast);
              var oldReuseWhitespace = config.reuseWhitespace;
              config.reuseWhitespace = false;
              var pr = new PrintResult(printGenerically(path2).toString(config));
              config.reuseWhitespace = oldReuseWhitespace;
              return pr;
            };
          };
          exports4.Printer = Printer;
          function genericPrint(path2, config, options2, printPath) {
            assert_12.default.ok(path2 instanceof fast_path_1.default);
            var node2 = path2.getValue();
            var parts = [];
            var linesWithoutParens = genericPrintNoParens(path2, config, printPath);
            if (!node2 || linesWithoutParens.isEmpty()) {
              return linesWithoutParens;
            }
            var shouldAddParens = node2.extra ? node2.extra.parenthesized : false;
            var decoratorsLines = printDecorators(path2, printPath);
            if (decoratorsLines.isEmpty()) {
              if (!options2.avoidRootParens) {
                shouldAddParens = shouldAddParens || path2.needsParens();
              }
            } else {
              parts.push(decoratorsLines);
            }
            if (shouldAddParens) {
              parts.unshift("(");
            }
            parts.push(linesWithoutParens);
            if (shouldAddParens) {
              parts.push(")");
            }
            return lines.concat(parts);
          }
          function genericPrintNoParens(path2, options2, print) {
            var n2 = path2.getValue();
            if (!n2) {
              return lines.fromString("");
            }
            if (typeof n2 === "string") {
              return lines.fromString(n2, options2);
            }
            namedTypes2.Printable.assert(n2);
            var parts = [];
            switch (n2.type) {
              case "File":
                return path2.call(print, "program");
              case "Program":
                if (n2.directives) {
                  path2.each(function(childPath) {
                    parts.push(print(childPath), ";\n");
                  }, "directives");
                }
                if (n2.interpreter) {
                  parts.push(path2.call(print, "interpreter"));
                }
                parts.push(path2.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options2, print);
                }, "body"));
                return lines.concat(parts);
              case "Noop":
              case "EmptyStatement":
                return lines.fromString("");
              case "ExpressionStatement":
                return lines.concat([path2.call(print, "expression"), ";"]);
              case "ParenthesizedExpression":
                return lines.concat(["(", path2.call(print, "expression"), ")"]);
              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
                return lines.fromString(" ").join([path2.call(print, "left"), n2.operator, path2.call(print, "right")]);
              case "AssignmentPattern":
                return lines.concat([path2.call(print, "left"), " = ", path2.call(print, "right")]);
              case "MemberExpression":
              case "OptionalMemberExpression": {
                parts.push(path2.call(print, "object"));
                var property = path2.call(print, "property");
                var optional = types2.getFieldValue(n2, "optional");
                if (n2.computed) {
                  parts.push(optional ? "?.[" : "[", property, "]");
                } else {
                  parts.push(optional ? "?." : ".", property);
                }
                return lines.concat(parts);
              }
              case "ChainExpression":
                return path2.call(print, "expression");
              case "MetaProperty":
                return lines.concat([path2.call(print, "meta"), ".", path2.call(print, "property")]);
              case "BindExpression":
                if (n2.object) {
                  parts.push(path2.call(print, "object"));
                }
                parts.push("::", path2.call(print, "callee"));
                return lines.concat(parts);
              case "Path":
                return lines.fromString(".").join(n2.body);
              case "Identifier":
                return lines.concat([lines.fromString(n2.name, options2), n2.optional ? "?" : "", path2.call(print, "typeAnnotation")]);
              case "SpreadElement":
              case "SpreadElementPattern":
              case "RestProperty":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "ObjectTypeSpreadProperty":
              case "RestElement":
                return lines.concat(["...", path2.call(print, "argument"), path2.call(print, "typeAnnotation")]);
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "TSDeclareFunction":
                if (n2.declare) {
                  parts.push("declare ");
                }
                if (n2.async) {
                  parts.push("async ");
                }
                parts.push("function");
                if (n2.generator)
                  parts.push("*");
                if (n2.id) {
                  parts.push(" ", path2.call(print, "id"), path2.call(print, "typeParameters"));
                } else {
                  if (n2.typeParameters) {
                    parts.push(path2.call(print, "typeParameters"));
                  }
                }
                parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType"));
                if (n2.body) {
                  parts.push(" ", path2.call(print, "body"));
                }
                return lines.concat(parts);
              case "ArrowFunctionExpression":
                if (n2.async) {
                  parts.push("async ");
                }
                if (n2.typeParameters) {
                  parts.push(path2.call(print, "typeParameters"));
                }
                if (!options2.arrowParensAlways && n2.params.length === 1 && !n2.rest && n2.params[0].type === "Identifier" && !n2.params[0].typeAnnotation && !n2.returnType) {
                  parts.push(path2.call(print, "params", 0));
                } else {
                  parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType"));
                }
                parts.push(" => ", path2.call(print, "body"));
                return lines.concat(parts);
              case "MethodDefinition":
                return printMethod(path2, options2, print);
              case "YieldExpression":
                parts.push("yield");
                if (n2.delegate)
                  parts.push("*");
                if (n2.argument)
                  parts.push(" ", path2.call(print, "argument"));
                return lines.concat(parts);
              case "AwaitExpression":
                parts.push("await");
                if (n2.all)
                  parts.push("*");
                if (n2.argument)
                  parts.push(" ", path2.call(print, "argument"));
                return lines.concat(parts);
              case "ModuleDeclaration":
                parts.push("module", path2.call(print, "id"));
                if (n2.source) {
                  assert_12.default.ok(!n2.body);
                  parts.push("from", path2.call(print, "source"));
                } else {
                  parts.push(path2.call(print, "body"));
                }
                return lines.fromString(" ").join(parts);
              case "ImportSpecifier":
                if (n2.importKind && n2.importKind !== "value") {
                  parts.push(n2.importKind + " ");
                }
                if (n2.imported) {
                  parts.push(path2.call(print, "imported"));
                  if (n2.local && n2.local.name !== n2.imported.name) {
                    parts.push(" as ", path2.call(print, "local"));
                  }
                } else if (n2.id) {
                  parts.push(path2.call(print, "id"));
                  if (n2.name) {
                    parts.push(" as ", path2.call(print, "name"));
                  }
                }
                return lines.concat(parts);
              case "ExportSpecifier":
                if (n2.local) {
                  parts.push(path2.call(print, "local"));
                  if (n2.exported && n2.exported.name !== n2.local.name) {
                    parts.push(" as ", path2.call(print, "exported"));
                  }
                } else if (n2.id) {
                  parts.push(path2.call(print, "id"));
                  if (n2.name) {
                    parts.push(" as ", path2.call(print, "name"));
                  }
                }
                return lines.concat(parts);
              case "ExportBatchSpecifier":
                return lines.fromString("*");
              case "ImportNamespaceSpecifier":
                parts.push("* as ");
                if (n2.local) {
                  parts.push(path2.call(print, "local"));
                } else if (n2.id) {
                  parts.push(path2.call(print, "id"));
                }
                return lines.concat(parts);
              case "ImportDefaultSpecifier":
                if (n2.local) {
                  return path2.call(print, "local");
                }
                return path2.call(print, "id");
              case "TSExportAssignment":
                return lines.concat(["export = ", path2.call(print, "expression")]);
              case "ExportDeclaration":
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return printExportDeclaration(path2, options2, print);
              case "ExportAllDeclaration":
                parts.push("export *");
                if (n2.exported) {
                  parts.push(" as ", path2.call(print, "exported"));
                }
                parts.push(" from ", path2.call(print, "source"), ";");
                return lines.concat(parts);
              case "TSNamespaceExportDeclaration":
                parts.push("export as namespace ", path2.call(print, "id"));
                return maybeAddSemicolon(lines.concat(parts));
              case "ExportNamespaceSpecifier":
                return lines.concat(["* as ", path2.call(print, "exported")]);
              case "ExportDefaultSpecifier":
                return path2.call(print, "exported");
              case "Import":
                return lines.fromString("import", options2);
              case "ImportExpression":
                return lines.concat(["import(", path2.call(print, "source"), ")"]);
              case "ImportDeclaration": {
                parts.push("import ");
                if (n2.importKind && n2.importKind !== "value") {
                  parts.push(n2.importKind + " ");
                }
                if (n2.specifiers && n2.specifiers.length > 0) {
                  var unbracedSpecifiers_1 = [];
                  var bracedSpecifiers_1 = [];
                  path2.each(function(specifierPath) {
                    var spec = specifierPath.getValue();
                    if (spec.type === "ImportSpecifier") {
                      bracedSpecifiers_1.push(print(specifierPath));
                    } else if (spec.type === "ImportDefaultSpecifier" || spec.type === "ImportNamespaceSpecifier") {
                      unbracedSpecifiers_1.push(print(specifierPath));
                    }
                  }, "specifiers");
                  unbracedSpecifiers_1.forEach(function(lines2, i) {
                    if (i > 0) {
                      parts.push(", ");
                    }
                    parts.push(lines2);
                  });
                  if (bracedSpecifiers_1.length > 0) {
                    var lines$1 = lines.fromString(", ").join(bracedSpecifiers_1);
                    if (lines$1.getLineLength(1) > options2.wrapColumn) {
                      lines$1 = lines.concat([lines.fromString(",\n").join(bracedSpecifiers_1).indent(options2.tabWidth), ","]);
                    }
                    if (unbracedSpecifiers_1.length > 0) {
                      parts.push(", ");
                    }
                    if (lines$1.length > 1) {
                      parts.push("{\n", lines$1, "\n}");
                    } else if (options2.objectCurlySpacing) {
                      parts.push("{ ", lines$1, " }");
                    } else {
                      parts.push("{", lines$1, "}");
                    }
                  }
                  parts.push(" from ");
                }
                parts.push(path2.call(print, "source"), ";");
                return lines.concat(parts);
              }
              case "BlockStatement": {
                var naked_1 = path2.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options2, print);
                }, "body");
                if (naked_1.isEmpty()) {
                  if (!n2.directives || n2.directives.length === 0) {
                    return lines.fromString("{}");
                  }
                }
                parts.push("{\n");
                if (n2.directives) {
                  path2.each(function(childPath) {
                    parts.push(maybeAddSemicolon(print(childPath).indent(options2.tabWidth)), n2.directives.length > 1 || !naked_1.isEmpty() ? "\n" : "");
                  }, "directives");
                }
                parts.push(naked_1.indent(options2.tabWidth));
                parts.push("\n}");
                return lines.concat(parts);
              }
              case "ReturnStatement": {
                parts.push("return");
                if (n2.argument) {
                  var argLines = path2.call(print, "argument");
                  if (argLines.startsWithComment() || argLines.length > 1 && namedTypes2.JSXElement && namedTypes2.JSXElement.check(n2.argument)) {
                    parts.push(" (\n", argLines.indent(options2.tabWidth), "\n)");
                  } else {
                    parts.push(" ", argLines);
                  }
                }
                parts.push(";");
                return lines.concat(parts);
              }
              case "CallExpression":
              case "OptionalCallExpression":
                parts.push(path2.call(print, "callee"));
                if (n2.typeParameters) {
                  parts.push(path2.call(print, "typeParameters"));
                }
                if (n2.typeArguments) {
                  parts.push(path2.call(print, "typeArguments"));
                }
                if (types2.getFieldValue(n2, "optional")) {
                  parts.push("?.");
                }
                parts.push(printArgumentsList(path2, options2, print));
                return lines.concat(parts);
              case "ObjectExpression":
              case "ObjectPattern":
              case "ObjectTypeAnnotation": {
                var isTypeAnnotation_1 = n2.type === "ObjectTypeAnnotation";
                var separator_1 = options2.flowObjectCommas ? "," : isTypeAnnotation_1 ? ";" : ",";
                var fields = [];
                var allowBreak_1 = false;
                if (isTypeAnnotation_1) {
                  fields.push("indexers", "callProperties");
                  if (n2.internalSlots != null) {
                    fields.push("internalSlots");
                  }
                }
                fields.push("properties");
                var len_1 = 0;
                fields.forEach(function(field) {
                  len_1 += n2[field].length;
                });
                var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0;
                var leftBrace = n2.exact ? "{|" : "{";
                var rightBrace = n2.exact ? "|}" : "}";
                parts.push(oneLine_1 ? leftBrace : leftBrace + "\n");
                var leftBraceIndex = parts.length - 1;
                var i_1 = 0;
                fields.forEach(function(field) {
                  path2.each(function(childPath) {
                    var lines2 = print(childPath);
                    if (!oneLine_1) {
                      lines2 = lines2.indent(options2.tabWidth);
                    }
                    var multiLine = !isTypeAnnotation_1 && lines2.length > 1;
                    if (multiLine && allowBreak_1) {
                      parts.push("\n");
                    }
                    parts.push(lines2);
                    if (i_1 < len_1 - 1) {
                      parts.push(separator_1 + (multiLine ? "\n\n" : "\n"));
                      allowBreak_1 = !multiLine;
                    } else if (len_1 !== 1 && isTypeAnnotation_1) {
                      parts.push(separator_1);
                    } else if (!oneLine_1 && util2.isTrailingCommaEnabled(options2, "objects") && childPath.getValue().type !== "RestElement") {
                      parts.push(separator_1);
                    }
                    i_1++;
                  }, field);
                });
                if (n2.inexact) {
                  var line = lines.fromString("...", options2);
                  if (oneLine_1) {
                    if (len_1 > 0) {
                      parts.push(separator_1, " ");
                    }
                    parts.push(line);
                  } else {
                    parts.push("\n", line.indent(options2.tabWidth));
                  }
                }
                parts.push(oneLine_1 ? rightBrace : "\n" + rightBrace);
                if (i_1 !== 0 && oneLine_1 && options2.objectCurlySpacing) {
                  parts[leftBraceIndex] = leftBrace + " ";
                  parts[parts.length - 1] = " " + rightBrace;
                }
                if (n2.typeAnnotation) {
                  parts.push(path2.call(print, "typeAnnotation"));
                }
                return lines.concat(parts);
              }
              case "PropertyPattern":
                return lines.concat([path2.call(print, "key"), ": ", path2.call(print, "pattern")]);
              case "ObjectProperty":
              case "Property": {
                if (n2.method || n2.kind === "get" || n2.kind === "set") {
                  return printMethod(path2, options2, print);
                }
                if (n2.shorthand && n2.value.type === "AssignmentPattern") {
                  return path2.call(print, "value");
                }
                var key = path2.call(print, "key");
                if (n2.computed) {
                  parts.push("[", key, "]");
                } else {
                  parts.push(key);
                }
                if (!n2.shorthand || n2.key.name !== n2.value.name) {
                  parts.push(": ", path2.call(print, "value"));
                }
                return lines.concat(parts);
              }
              case "ClassMethod":
              case "ObjectMethod":
              case "ClassPrivateMethod":
              case "TSDeclareMethod":
                return printMethod(path2, options2, print);
              case "PrivateName":
                return lines.concat(["#", path2.call(print, "id")]);
              case "Decorator":
                return lines.concat(["@", path2.call(print, "expression")]);
              case "ArrayExpression":
              case "ArrayPattern": {
                var elems = n2.elements;
                var len_2 = elems.length;
                var printed_1 = path2.map(print, "elements");
                var joined = lines.fromString(", ").join(printed_1);
                var oneLine_2 = joined.getLineLength(1) <= options2.wrapColumn;
                if (oneLine_2) {
                  if (options2.arrayBracketSpacing) {
                    parts.push("[ ");
                  } else {
                    parts.push("[");
                  }
                } else {
                  parts.push("[\n");
                }
                path2.each(function(elemPath) {
                  var i = elemPath.getName();
                  var elem = elemPath.getValue();
                  if (!elem) {
                    parts.push(",");
                  } else {
                    var lines2 = printed_1[i];
                    if (oneLine_2) {
                      if (i > 0)
                        parts.push(" ");
                    } else {
                      lines2 = lines2.indent(options2.tabWidth);
                    }
                    parts.push(lines2);
                    if (i < len_2 - 1 || !oneLine_2 && util2.isTrailingCommaEnabled(options2, "arrays"))
                      parts.push(",");
                    if (!oneLine_2)
                      parts.push("\n");
                  }
                }, "elements");
                if (oneLine_2 && options2.arrayBracketSpacing) {
                  parts.push(" ]");
                } else {
                  parts.push("]");
                }
                if (n2.typeAnnotation) {
                  parts.push(path2.call(print, "typeAnnotation"));
                }
                return lines.concat(parts);
              }
              case "SequenceExpression":
                return lines.fromString(", ").join(path2.map(print, "expressions"));
              case "ThisExpression":
                return lines.fromString("this");
              case "Super":
                return lines.fromString("super");
              case "NullLiteral":
                return lines.fromString("null");
              case "RegExpLiteral":
                return lines.fromString(n2.extra.raw);
              case "BigIntLiteral":
                return lines.fromString(n2.value + "n");
              case "NumericLiteral":
                if (n2.extra && typeof n2.extra.raw === "string" && Number(n2.extra.raw) === n2.value) {
                  return lines.fromString(n2.extra.raw, options2);
                }
                return lines.fromString(n2.value, options2);
              case "BooleanLiteral":
              case "StringLiteral":
              case "Literal":
                if (typeof n2.value === "number" && typeof n2.raw === "string" && Number(n2.raw) === n2.value) {
                  return lines.fromString(n2.raw, options2);
                }
                if (typeof n2.value !== "string") {
                  return lines.fromString(n2.value, options2);
                }
                return lines.fromString(nodeStr(n2.value, options2), options2);
              case "Directive":
                return path2.call(print, "value");
              case "DirectiveLiteral":
                return lines.fromString(nodeStr(n2.value, options2));
              case "InterpreterDirective":
                return lines.fromString("#!" + n2.value + "\n", options2);
              case "ModuleSpecifier":
                if (n2.local) {
                  throw new Error("The ESTree ModuleSpecifier type should be abstract");
                }
                return lines.fromString(nodeStr(n2.value, options2), options2);
              case "UnaryExpression":
                parts.push(n2.operator);
                if (/[a-z]$/.test(n2.operator))
                  parts.push(" ");
                parts.push(path2.call(print, "argument"));
                return lines.concat(parts);
              case "UpdateExpression":
                parts.push(path2.call(print, "argument"), n2.operator);
                if (n2.prefix)
                  parts.reverse();
                return lines.concat(parts);
              case "ConditionalExpression":
                return lines.concat([path2.call(print, "test"), " ? ", path2.call(print, "consequent"), " : ", path2.call(print, "alternate")]);
              case "NewExpression": {
                parts.push("new ", path2.call(print, "callee"));
                if (n2.typeParameters) {
                  parts.push(path2.call(print, "typeParameters"));
                }
                if (n2.typeArguments) {
                  parts.push(path2.call(print, "typeArguments"));
                }
                var args = n2.arguments;
                if (args) {
                  parts.push(printArgumentsList(path2, options2, print));
                }
                return lines.concat(parts);
              }
              case "VariableDeclaration": {
                if (n2.declare) {
                  parts.push("declare ");
                }
                parts.push(n2.kind, " ");
                var maxLen_1 = 0;
                var printed = path2.map(function(childPath) {
                  var lines2 = print(childPath);
                  maxLen_1 = Math.max(lines2.length, maxLen_1);
                  return lines2;
                }, "declarations");
                if (maxLen_1 === 1) {
                  parts.push(lines.fromString(", ").join(printed));
                } else if (printed.length > 1) {
                  parts.push(lines.fromString(",\n").join(printed).indentTail(n2.kind.length + 1));
                } else {
                  parts.push(printed[0]);
                }
                var parentNode = path2.getParentNode();
                if (!namedTypes2.ForStatement.check(parentNode) && !namedTypes2.ForInStatement.check(parentNode) && !(namedTypes2.ForOfStatement && namedTypes2.ForOfStatement.check(parentNode)) && !(namedTypes2.ForAwaitStatement && namedTypes2.ForAwaitStatement.check(parentNode))) {
                  parts.push(";");
                }
                return lines.concat(parts);
              }
              case "VariableDeclarator":
                return n2.init ? lines.fromString(" = ").join([path2.call(print, "id"), path2.call(print, "init")]) : path2.call(print, "id");
              case "WithStatement":
                return lines.concat(["with (", path2.call(print, "object"), ") ", path2.call(print, "body")]);
              case "IfStatement": {
                var con = adjustClause(path2.call(print, "consequent"), options2);
                parts.push("if (", path2.call(print, "test"), ")", con);
                if (n2.alternate)
                  parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path2.call(print, "alternate"), options2));
                return lines.concat(parts);
              }
              case "ForStatement": {
                var init2 = path2.call(print, "init");
                var sep = init2.length > 1 ? ";\n" : "; ";
                var forParen = "for (";
                var indented = lines.fromString(sep).join([init2, path2.call(print, "test"), path2.call(print, "update")]).indentTail(forParen.length);
                var head = lines.concat([forParen, indented, ")"]);
                var clause = adjustClause(path2.call(print, "body"), options2);
                parts.push(head);
                if (head.length > 1) {
                  parts.push("\n");
                  clause = clause.trimLeft();
                }
                parts.push(clause);
                return lines.concat(parts);
              }
              case "WhileStatement":
                return lines.concat(["while (", path2.call(print, "test"), ")", adjustClause(path2.call(print, "body"), options2)]);
              case "ForInStatement":
                return lines.concat([n2.each ? "for each (" : "for (", path2.call(print, "left"), " in ", path2.call(print, "right"), ")", adjustClause(path2.call(print, "body"), options2)]);
              case "ForOfStatement":
              case "ForAwaitStatement":
                parts.push("for ");
                if (n2.await || n2.type === "ForAwaitStatement") {
                  parts.push("await ");
                }
                parts.push("(", path2.call(print, "left"), " of ", path2.call(print, "right"), ")", adjustClause(path2.call(print, "body"), options2));
                return lines.concat(parts);
              case "DoWhileStatement": {
                var doBody = lines.concat(["do", adjustClause(path2.call(print, "body"), options2)]);
                parts.push(doBody);
                if (endsWithBrace(doBody))
                  parts.push(" while");
                else
                  parts.push("\nwhile");
                parts.push(" (", path2.call(print, "test"), ");");
                return lines.concat(parts);
              }
              case "DoExpression": {
                var statements = path2.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options2, print);
                }, "body");
                return lines.concat(["do {\n", statements.indent(options2.tabWidth), "\n}"]);
              }
              case "BreakStatement":
                parts.push("break");
                if (n2.label)
                  parts.push(" ", path2.call(print, "label"));
                parts.push(";");
                return lines.concat(parts);
              case "ContinueStatement":
                parts.push("continue");
                if (n2.label)
                  parts.push(" ", path2.call(print, "label"));
                parts.push(";");
                return lines.concat(parts);
              case "LabeledStatement":
                return lines.concat([path2.call(print, "label"), ":\n", path2.call(print, "body")]);
              case "TryStatement":
                parts.push("try ", path2.call(print, "block"));
                if (n2.handler) {
                  parts.push(" ", path2.call(print, "handler"));
                } else if (n2.handlers) {
                  path2.each(function(handlerPath) {
                    parts.push(" ", print(handlerPath));
                  }, "handlers");
                }
                if (n2.finalizer) {
                  parts.push(" finally ", path2.call(print, "finalizer"));
                }
                return lines.concat(parts);
              case "CatchClause":
                parts.push("catch ");
                if (n2.param) {
                  parts.push("(", path2.call(print, "param"));
                }
                if (n2.guard) {
                  parts.push(" if ", path2.call(print, "guard"));
                }
                if (n2.param) {
                  parts.push(") ");
                }
                parts.push(path2.call(print, "body"));
                return lines.concat(parts);
              case "ThrowStatement":
                return lines.concat(["throw ", path2.call(print, "argument"), ";"]);
              case "SwitchStatement":
                return lines.concat(["switch (", path2.call(print, "discriminant"), ") {\n", lines.fromString("\n").join(path2.map(print, "cases")), "\n}"]);
              case "SwitchCase":
                if (n2.test)
                  parts.push("case ", path2.call(print, "test"), ":");
                else
                  parts.push("default:");
                if (n2.consequent.length > 0) {
                  parts.push("\n", path2.call(function(consequentPath) {
                    return printStatementSequence(consequentPath, options2, print);
                  }, "consequent").indent(options2.tabWidth));
                }
                return lines.concat(parts);
              case "DebuggerStatement":
                return lines.fromString("debugger;");
              case "JSXAttribute":
                parts.push(path2.call(print, "name"));
                if (n2.value)
                  parts.push("=", path2.call(print, "value"));
                return lines.concat(parts);
              case "JSXIdentifier":
                return lines.fromString(n2.name, options2);
              case "JSXNamespacedName":
                return lines.fromString(":").join([path2.call(print, "namespace"), path2.call(print, "name")]);
              case "JSXMemberExpression":
                return lines.fromString(".").join([path2.call(print, "object"), path2.call(print, "property")]);
              case "JSXSpreadAttribute":
                return lines.concat(["{...", path2.call(print, "argument"), "}"]);
              case "JSXSpreadChild":
                return lines.concat(["{...", path2.call(print, "expression"), "}"]);
              case "JSXExpressionContainer":
                return lines.concat(["{", path2.call(print, "expression"), "}"]);
              case "JSXElement":
              case "JSXFragment": {
                var openingPropName = "opening" + (n2.type === "JSXElement" ? "Element" : "Fragment");
                var closingPropName = "closing" + (n2.type === "JSXElement" ? "Element" : "Fragment");
                var openingLines = path2.call(print, openingPropName);
                if (n2[openingPropName].selfClosing) {
                  assert_12.default.ok(!n2[closingPropName], "unexpected " + closingPropName + " element in self-closing " + n2.type);
                  return openingLines;
                }
                var childLines = lines.concat(path2.map(function(childPath) {
                  var child = childPath.getValue();
                  if (namedTypes2.Literal.check(child) && typeof child.value === "string") {
                    if (/\S/.test(child.value)) {
                      return child.value.replace(/^\s+|\s+$/g, "");
                    } else if (/\n/.test(child.value)) {
                      return "\n";
                    }
                  }
                  return print(childPath);
                }, "children")).indentTail(options2.tabWidth);
                var closingLines = path2.call(print, closingPropName);
                return lines.concat([openingLines, childLines, closingLines]);
              }
              case "JSXOpeningElement": {
                parts.push("<", path2.call(print, "name"));
                var attrParts_1 = [];
                path2.each(function(attrPath) {
                  attrParts_1.push(" ", print(attrPath));
                }, "attributes");
                var attrLines = lines.concat(attrParts_1);
                var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options2.wrapColumn;
                if (needLineWrap) {
                  attrParts_1.forEach(function(part2, i) {
                    if (part2 === " ") {
                      assert_12.default.strictEqual(i % 2, 0);
                      attrParts_1[i] = "\n";
                    }
                  });
                  attrLines = lines.concat(attrParts_1).indentTail(options2.tabWidth);
                }
                parts.push(attrLines, n2.selfClosing ? " />" : ">");
                return lines.concat(parts);
              }
              case "JSXClosingElement":
                return lines.concat(["</", path2.call(print, "name"), ">"]);
              case "JSXOpeningFragment":
                return lines.fromString("<>");
              case "JSXClosingFragment":
                return lines.fromString("</>");
              case "JSXText":
                return lines.fromString(n2.value, options2);
              case "JSXEmptyExpression":
                return lines.fromString("");
              case "TypeAnnotatedIdentifier":
                return lines.concat([path2.call(print, "annotation"), " ", path2.call(print, "identifier")]);
              case "ClassBody":
                if (n2.body.length === 0) {
                  return lines.fromString("{}");
                }
                return lines.concat(["{\n", path2.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options2, print);
                }, "body").indent(options2.tabWidth), "\n}"]);
              case "ClassPropertyDefinition":
                parts.push("static ", path2.call(print, "definition"));
                if (!namedTypes2.MethodDefinition.check(n2.definition))
                  parts.push(";");
                return lines.concat(parts);
              case "ClassProperty": {
                if (n2.declare) {
                  parts.push("declare ");
                }
                var access = n2.accessibility || n2.access;
                if (typeof access === "string") {
                  parts.push(access, " ");
                }
                if (n2.static) {
                  parts.push("static ");
                }
                if (n2.abstract) {
                  parts.push("abstract ");
                }
                if (n2.readonly) {
                  parts.push("readonly ");
                }
                var key = path2.call(print, "key");
                if (n2.computed) {
                  key = lines.concat(["[", key, "]"]);
                }
                if (n2.variance) {
                  key = lines.concat([printVariance(path2, print), key]);
                }
                parts.push(key);
                if (n2.optional) {
                  parts.push("?");
                }
                if (n2.typeAnnotation) {
                  parts.push(path2.call(print, "typeAnnotation"));
                }
                if (n2.value) {
                  parts.push(" = ", path2.call(print, "value"));
                }
                parts.push(";");
                return lines.concat(parts);
              }
              case "ClassPrivateProperty":
                if (n2.static) {
                  parts.push("static ");
                }
                parts.push(path2.call(print, "key"));
                if (n2.typeAnnotation) {
                  parts.push(path2.call(print, "typeAnnotation"));
                }
                if (n2.value) {
                  parts.push(" = ", path2.call(print, "value"));
                }
                parts.push(";");
                return lines.concat(parts);
              case "ClassDeclaration":
              case "ClassExpression":
                if (n2.declare) {
                  parts.push("declare ");
                }
                if (n2.abstract) {
                  parts.push("abstract ");
                }
                parts.push("class");
                if (n2.id) {
                  parts.push(" ", path2.call(print, "id"));
                }
                if (n2.typeParameters) {
                  parts.push(path2.call(print, "typeParameters"));
                }
                if (n2.superClass) {
                  parts.push(" extends ", path2.call(print, "superClass"), path2.call(print, "superTypeParameters"));
                }
                if (n2["implements"] && n2["implements"].length > 0) {
                  parts.push(" implements ", lines.fromString(", ").join(path2.map(print, "implements")));
                }
                parts.push(" ", path2.call(print, "body"));
                return lines.concat(parts);
              case "TemplateElement":
                return lines.fromString(n2.value.raw, options2).lockIndentTail();
              case "TemplateLiteral": {
                var expressions_1 = path2.map(print, "expressions");
                parts.push("`");
                path2.each(function(childPath) {
                  var i = childPath.getName();
                  parts.push(print(childPath));
                  if (i < expressions_1.length) {
                    parts.push("${", expressions_1[i], "}");
                  }
                }, "quasis");
                parts.push("`");
                return lines.concat(parts).lockIndentTail();
              }
              case "TaggedTemplateExpression":
                return lines.concat([path2.call(print, "tag"), path2.call(print, "quasi")]);
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "Flow":
              case "FlowType":
              case "FlowPredicate":
              case "MemberTypeAnnotation":
              case "Type":
              case "TSHasOptionalTypeParameterInstantiation":
              case "TSHasOptionalTypeParameters":
              case "TSHasOptionalTypeAnnotation":
              case "ChainElement":
                throw new Error("unprintable type: " + JSON.stringify(n2.type));
              case "CommentBlock":
              case "Block":
                return lines.concat(["/*", lines.fromString(n2.value, options2), "*/"]);
              case "CommentLine":
              case "Line":
                return lines.concat(["//", lines.fromString(n2.value, options2)]);
              case "TypeAnnotation":
                if (n2.typeAnnotation) {
                  if (n2.typeAnnotation.type !== "FunctionTypeAnnotation") {
                    parts.push(": ");
                  }
                  parts.push(path2.call(print, "typeAnnotation"));
                  return lines.concat(parts);
                }
                return lines.fromString("");
              case "ExistentialTypeParam":
              case "ExistsTypeAnnotation":
                return lines.fromString("*", options2);
              case "EmptyTypeAnnotation":
                return lines.fromString("empty", options2);
              case "AnyTypeAnnotation":
                return lines.fromString("any", options2);
              case "MixedTypeAnnotation":
                return lines.fromString("mixed", options2);
              case "ArrayTypeAnnotation":
                return lines.concat([path2.call(print, "elementType"), "[]"]);
              case "TupleTypeAnnotation": {
                var printed_2 = path2.map(print, "types");
                var joined = lines.fromString(", ").join(printed_2);
                var oneLine_3 = joined.getLineLength(1) <= options2.wrapColumn;
                if (oneLine_3) {
                  if (options2.arrayBracketSpacing) {
                    parts.push("[ ");
                  } else {
                    parts.push("[");
                  }
                } else {
                  parts.push("[\n");
                }
                path2.each(function(elemPath) {
                  var i = elemPath.getName();
                  var elem = elemPath.getValue();
                  if (!elem) {
                    parts.push(",");
                  } else {
                    var lines2 = printed_2[i];
                    if (oneLine_3) {
                      if (i > 0)
                        parts.push(" ");
                    } else {
                      lines2 = lines2.indent(options2.tabWidth);
                    }
                    parts.push(lines2);
                    if (i < n2.types.length - 1 || !oneLine_3 && util2.isTrailingCommaEnabled(options2, "arrays"))
                      parts.push(",");
                    if (!oneLine_3)
                      parts.push("\n");
                  }
                }, "types");
                if (oneLine_3 && options2.arrayBracketSpacing) {
                  parts.push(" ]");
                } else {
                  parts.push("]");
                }
                return lines.concat(parts);
              }
              case "BooleanTypeAnnotation":
                return lines.fromString("boolean", options2);
              case "BooleanLiteralTypeAnnotation":
                assert_12.default.strictEqual(typeof n2.value, "boolean");
                return lines.fromString("" + n2.value, options2);
              case "InterfaceTypeAnnotation":
                parts.push("interface");
                if (n2.extends && n2.extends.length > 0) {
                  parts.push(" extends ", lines.fromString(", ").join(path2.map(print, "extends")));
                }
                parts.push(" ", path2.call(print, "body"));
                return lines.concat(parts);
              case "DeclareClass":
                return printFlowDeclaration(path2, ["class ", path2.call(print, "id"), " ", path2.call(print, "body")]);
              case "DeclareFunction":
                return printFlowDeclaration(path2, ["function ", path2.call(print, "id"), ";"]);
              case "DeclareModule":
                return printFlowDeclaration(path2, ["module ", path2.call(print, "id"), " ", path2.call(print, "body")]);
              case "DeclareModuleExports":
                return printFlowDeclaration(path2, ["module.exports", path2.call(print, "typeAnnotation")]);
              case "DeclareVariable":
                return printFlowDeclaration(path2, ["var ", path2.call(print, "id"), ";"]);
              case "DeclareExportDeclaration":
              case "DeclareExportAllDeclaration":
                return lines.concat(["declare ", printExportDeclaration(path2, options2, print)]);
              case "EnumDeclaration":
                return lines.concat(["enum ", path2.call(print, "id"), path2.call(print, "body")]);
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (n2.type === "EnumSymbolBody" || n2.explicitType) {
                  parts.push(" of ", n2.type.slice(4, -4).toLowerCase());
                }
                parts.push(" {\n", lines.fromString("\n").join(path2.map(print, "members")).indent(options2.tabWidth), "\n}");
                return lines.concat(parts);
              }
              case "EnumDefaultedMember":
                return lines.concat([path2.call(print, "id"), ","]);
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return lines.concat([path2.call(print, "id"), " = ", path2.call(print, "init"), ","]);
              case "InferredPredicate":
                return lines.fromString("%checks", options2);
              case "DeclaredPredicate":
                return lines.concat(["%checks(", path2.call(print, "value"), ")"]);
              case "FunctionTypeAnnotation": {
                var parent = path2.getParentNode(0);
                var isArrowFunctionTypeAnnotation = !(namedTypes2.ObjectTypeCallProperty.check(parent) || namedTypes2.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes2.DeclareFunction.check(path2.getParentNode(2)));
                var needsColon = isArrowFunctionTypeAnnotation && !namedTypes2.FunctionTypeParam.check(parent) && !namedTypes2.TypeAlias.check(parent);
                if (needsColon) {
                  parts.push(": ");
                }
                var needsParens = n2.params.length !== 1 || n2.params[0].name;
                parts.push(needsParens ? "(" : "", printFunctionParams(path2, options2, print), needsParens ? ")" : "");
                if (n2.returnType) {
                  parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path2.call(print, "returnType"));
                }
                return lines.concat(parts);
              }
              case "FunctionTypeParam": {
                var name = path2.call(print, "name");
                parts.push(name);
                if (n2.optional) {
                  parts.push("?");
                }
                if (name.infos[0].line) {
                  parts.push(": ");
                }
                parts.push(path2.call(print, "typeAnnotation"));
                return lines.concat(parts);
              }
              case "GenericTypeAnnotation":
                return lines.concat([path2.call(print, "id"), path2.call(print, "typeParameters")]);
              case "DeclareInterface":
                parts.push("declare ");
              case "InterfaceDeclaration":
              case "TSInterfaceDeclaration":
                if (n2.declare) {
                  parts.push("declare ");
                }
                parts.push("interface ", path2.call(print, "id"), path2.call(print, "typeParameters"), " ");
                if (n2["extends"] && n2["extends"].length > 0) {
                  parts.push("extends ", lines.fromString(", ").join(path2.map(print, "extends")), " ");
                }
                if (n2.body) {
                  parts.push(path2.call(print, "body"));
                }
                return lines.concat(parts);
              case "ClassImplements":
              case "InterfaceExtends":
                return lines.concat([path2.call(print, "id"), path2.call(print, "typeParameters")]);
              case "IntersectionTypeAnnotation":
                return lines.fromString(" & ").join(path2.map(print, "types"));
              case "NullableTypeAnnotation":
                return lines.concat(["?", path2.call(print, "typeAnnotation")]);
              case "NullLiteralTypeAnnotation":
                return lines.fromString("null", options2);
              case "ThisTypeAnnotation":
                return lines.fromString("this", options2);
              case "NumberTypeAnnotation":
                return lines.fromString("number", options2);
              case "ObjectTypeCallProperty":
                return path2.call(print, "value");
              case "ObjectTypeIndexer":
                if (n2.static) {
                  parts.push("static ");
                }
                parts.push(printVariance(path2, print), "[");
                if (n2.id) {
                  parts.push(path2.call(print, "id"), ": ");
                }
                parts.push(path2.call(print, "key"), "]: ", path2.call(print, "value"));
                return lines.concat(parts);
              case "ObjectTypeProperty":
                return lines.concat([printVariance(path2, print), path2.call(print, "key"), n2.optional ? "?" : "", ": ", path2.call(print, "value")]);
              case "ObjectTypeInternalSlot":
                return lines.concat([n2.static ? "static " : "", "[[", path2.call(print, "id"), "]]", n2.optional ? "?" : "", n2.value.type !== "FunctionTypeAnnotation" ? ": " : "", path2.call(print, "value")]);
              case "QualifiedTypeIdentifier":
                return lines.concat([path2.call(print, "qualification"), ".", path2.call(print, "id")]);
              case "StringLiteralTypeAnnotation":
                return lines.fromString(nodeStr(n2.value, options2), options2);
              case "NumberLiteralTypeAnnotation":
              case "NumericLiteralTypeAnnotation":
                assert_12.default.strictEqual(typeof n2.value, "number");
                return lines.fromString(JSON.stringify(n2.value), options2);
              case "BigIntLiteralTypeAnnotation":
                return lines.fromString(n2.raw, options2);
              case "StringTypeAnnotation":
                return lines.fromString("string", options2);
              case "DeclareTypeAlias":
                parts.push("declare ");
              case "TypeAlias":
                return lines.concat(["type ", path2.call(print, "id"), path2.call(print, "typeParameters"), " = ", path2.call(print, "right"), ";"]);
              case "DeclareOpaqueType":
                parts.push("declare ");
              case "OpaqueType":
                parts.push("opaque type ", path2.call(print, "id"), path2.call(print, "typeParameters"));
                if (n2["supertype"]) {
                  parts.push(": ", path2.call(print, "supertype"));
                }
                if (n2["impltype"]) {
                  parts.push(" = ", path2.call(print, "impltype"));
                }
                parts.push(";");
                return lines.concat(parts);
              case "TypeCastExpression":
                return lines.concat(["(", path2.call(print, "expression"), path2.call(print, "typeAnnotation"), ")"]);
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation":
                return lines.concat(["<", lines.fromString(", ").join(path2.map(print, "params")), ">"]);
              case "Variance":
                if (n2.kind === "plus") {
                  return lines.fromString("+");
                }
                if (n2.kind === "minus") {
                  return lines.fromString("-");
                }
                return lines.fromString("");
              case "TypeParameter":
                if (n2.variance) {
                  parts.push(printVariance(path2, print));
                }
                parts.push(path2.call(print, "name"));
                if (n2.bound) {
                  parts.push(path2.call(print, "bound"));
                }
                if (n2["default"]) {
                  parts.push("=", path2.call(print, "default"));
                }
                return lines.concat(parts);
              case "TypeofTypeAnnotation":
                return lines.concat([lines.fromString("typeof ", options2), path2.call(print, "argument")]);
              case "UnionTypeAnnotation":
                return lines.fromString(" | ").join(path2.map(print, "types"));
              case "VoidTypeAnnotation":
                return lines.fromString("void", options2);
              case "NullTypeAnnotation":
                return lines.fromString("null", options2);
              case "SymbolTypeAnnotation":
                return lines.fromString("symbol", options2);
              case "BigIntTypeAnnotation":
                return lines.fromString("bigint", options2);
              case "TSType":
                throw new Error("unprintable type: " + JSON.stringify(n2.type));
              case "TSNumberKeyword":
                return lines.fromString("number", options2);
              case "TSBigIntKeyword":
                return lines.fromString("bigint", options2);
              case "TSObjectKeyword":
                return lines.fromString("object", options2);
              case "TSBooleanKeyword":
                return lines.fromString("boolean", options2);
              case "TSStringKeyword":
                return lines.fromString("string", options2);
              case "TSSymbolKeyword":
                return lines.fromString("symbol", options2);
              case "TSAnyKeyword":
                return lines.fromString("any", options2);
              case "TSVoidKeyword":
                return lines.fromString("void", options2);
              case "TSThisType":
                return lines.fromString("this", options2);
              case "TSNullKeyword":
                return lines.fromString("null", options2);
              case "TSUndefinedKeyword":
                return lines.fromString("undefined", options2);
              case "TSUnknownKeyword":
                return lines.fromString("unknown", options2);
              case "TSNeverKeyword":
                return lines.fromString("never", options2);
              case "TSArrayType":
                return lines.concat([path2.call(print, "elementType"), "[]"]);
              case "TSLiteralType":
                return path2.call(print, "literal");
              case "TSUnionType":
                return lines.fromString(" | ").join(path2.map(print, "types"));
              case "TSIntersectionType":
                return lines.fromString(" & ").join(path2.map(print, "types"));
              case "TSConditionalType":
                parts.push(path2.call(print, "checkType"), " extends ", path2.call(print, "extendsType"), " ? ", path2.call(print, "trueType"), " : ", path2.call(print, "falseType"));
                return lines.concat(parts);
              case "TSInferType":
                parts.push("infer ", path2.call(print, "typeParameter"));
                return lines.concat(parts);
              case "TSParenthesizedType":
                return lines.concat(["(", path2.call(print, "typeAnnotation"), ")"]);
              case "TSFunctionType":
                return lines.concat([path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ") => ", path2.call(print, "typeAnnotation", "typeAnnotation")]);
              case "TSConstructorType":
                return lines.concat(["new ", path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ") => ", path2.call(print, "typeAnnotation", "typeAnnotation")]);
              case "TSMappedType": {
                parts.push(n2.readonly ? "readonly " : "", "[", path2.call(print, "typeParameter"), "]", n2.optional ? "?" : "");
                if (n2.typeAnnotation) {
                  parts.push(": ", path2.call(print, "typeAnnotation"), ";");
                }
                return lines.concat(["{\n", lines.concat(parts).indent(options2.tabWidth), "\n}"]);
              }
              case "TSTupleType":
                return lines.concat(["[", lines.fromString(", ").join(path2.map(print, "elementTypes")), "]"]);
              case "TSNamedTupleMember":
                parts.push(path2.call(print, "label"));
                if (n2.optional) {
                  parts.push("?");
                }
                parts.push(": ", path2.call(print, "elementType"));
                return lines.concat(parts);
              case "TSRestType":
                return lines.concat(["...", path2.call(print, "typeAnnotation")]);
              case "TSOptionalType":
                return lines.concat([path2.call(print, "typeAnnotation"), "?"]);
              case "TSIndexedAccessType":
                return lines.concat([path2.call(print, "objectType"), "[", path2.call(print, "indexType"), "]"]);
              case "TSTypeOperator":
                return lines.concat([path2.call(print, "operator"), " ", path2.call(print, "typeAnnotation")]);
              case "TSTypeLiteral": {
                var memberLines = lines.fromString(",\n").join(path2.map(print, "members"));
                if (memberLines.isEmpty()) {
                  return lines.fromString("{}", options2);
                }
                parts.push("{\n", memberLines.indent(options2.tabWidth), "\n}");
                return lines.concat(parts);
              }
              case "TSEnumMember":
                parts.push(path2.call(print, "id"));
                if (n2.initializer) {
                  parts.push(" = ", path2.call(print, "initializer"));
                }
                return lines.concat(parts);
              case "TSTypeQuery":
                return lines.concat(["typeof ", path2.call(print, "exprName")]);
              case "TSParameterProperty":
                if (n2.accessibility) {
                  parts.push(n2.accessibility, " ");
                }
                if (n2.export) {
                  parts.push("export ");
                }
                if (n2.static) {
                  parts.push("static ");
                }
                if (n2.readonly) {
                  parts.push("readonly ");
                }
                parts.push(path2.call(print, "parameter"));
                return lines.concat(parts);
              case "TSTypeReference":
                return lines.concat([path2.call(print, "typeName"), path2.call(print, "typeParameters")]);
              case "TSQualifiedName":
                return lines.concat([path2.call(print, "left"), ".", path2.call(print, "right")]);
              case "TSAsExpression": {
                var expression = path2.call(print, "expression");
                parts.push(expression, lines.fromString(" as "), path2.call(print, "typeAnnotation"));
                return lines.concat(parts);
              }
              case "TSNonNullExpression":
                return lines.concat([path2.call(print, "expression"), "!"]);
              case "TSTypeAnnotation":
                return lines.concat([": ", path2.call(print, "typeAnnotation")]);
              case "TSIndexSignature":
                return lines.concat([n2.readonly ? "readonly " : "", "[", path2.map(print, "parameters"), "]", path2.call(print, "typeAnnotation")]);
              case "TSPropertySignature":
                parts.push(printVariance(path2, print), n2.readonly ? "readonly " : "");
                if (n2.computed) {
                  parts.push("[", path2.call(print, "key"), "]");
                } else {
                  parts.push(path2.call(print, "key"));
                }
                parts.push(n2.optional ? "?" : "", path2.call(print, "typeAnnotation"));
                return lines.concat(parts);
              case "TSMethodSignature":
                if (n2.computed) {
                  parts.push("[", path2.call(print, "key"), "]");
                } else {
                  parts.push(path2.call(print, "key"));
                }
                if (n2.optional) {
                  parts.push("?");
                }
                parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation"));
                return lines.concat(parts);
              case "TSTypePredicate":
                if (n2.asserts) {
                  parts.push("asserts ");
                }
                parts.push(path2.call(print, "parameterName"));
                if (n2.typeAnnotation) {
                  parts.push(" is ", path2.call(print, "typeAnnotation", "typeAnnotation"));
                }
                return lines.concat(parts);
              case "TSCallSignatureDeclaration":
                return lines.concat([path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation")]);
              case "TSConstructSignatureDeclaration":
                if (n2.typeParameters) {
                  parts.push("new", path2.call(print, "typeParameters"));
                } else {
                  parts.push("new ");
                }
                parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation"));
                return lines.concat(parts);
              case "TSTypeAliasDeclaration":
                return lines.concat([n2.declare ? "declare " : "", "type ", path2.call(print, "id"), path2.call(print, "typeParameters"), " = ", path2.call(print, "typeAnnotation"), ";"]);
              case "TSTypeParameter": {
                parts.push(path2.call(print, "name"));
                var parent = path2.getParentNode(0);
                var isInMappedType = namedTypes2.TSMappedType.check(parent);
                if (n2.constraint) {
                  parts.push(isInMappedType ? " in " : " extends ", path2.call(print, "constraint"));
                }
                if (n2["default"]) {
                  parts.push(" = ", path2.call(print, "default"));
                }
                return lines.concat(parts);
              }
              case "TSTypeAssertion": {
                parts.push("<", path2.call(print, "typeAnnotation"), "> ", path2.call(print, "expression"));
                return lines.concat(parts);
              }
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return lines.concat(["<", lines.fromString(", ").join(path2.map(print, "params")), ">"]);
              case "TSEnumDeclaration": {
                parts.push(n2.declare ? "declare " : "", n2.const ? "const " : "", "enum ", path2.call(print, "id"));
                var memberLines = lines.fromString(",\n").join(path2.map(print, "members"));
                if (memberLines.isEmpty()) {
                  parts.push(" {}");
                } else {
                  parts.push(" {\n", memberLines.indent(options2.tabWidth), "\n}");
                }
                return lines.concat(parts);
              }
              case "TSExpressionWithTypeArguments":
                return lines.concat([path2.call(print, "expression"), path2.call(print, "typeParameters")]);
              case "TSInterfaceBody": {
                var lines$1 = lines.fromString(";\n").join(path2.map(print, "body"));
                if (lines$1.isEmpty()) {
                  return lines.fromString("{}", options2);
                }
                return lines.concat(["{\n", lines$1.indent(options2.tabWidth), ";", "\n}"]);
              }
              case "TSImportType":
                parts.push("import(", path2.call(print, "argument"), ")");
                if (n2.qualifier) {
                  parts.push(".", path2.call(print, "qualifier"));
                }
                if (n2.typeParameters) {
                  parts.push(path2.call(print, "typeParameters"));
                }
                return lines.concat(parts);
              case "TSImportEqualsDeclaration":
                if (n2.isExport) {
                  parts.push("export ");
                }
                parts.push("import ", path2.call(print, "id"), " = ", path2.call(print, "moduleReference"));
                return maybeAddSemicolon(lines.concat(parts));
              case "TSExternalModuleReference":
                return lines.concat(["require(", path2.call(print, "expression"), ")"]);
              case "TSModuleDeclaration": {
                var parent = path2.getParentNode();
                if (parent.type === "TSModuleDeclaration") {
                  parts.push(".");
                } else {
                  if (n2.declare) {
                    parts.push("declare ");
                  }
                  if (!n2.global) {
                    var isExternal = n2.id.type === "StringLiteral" || n2.id.type === "Literal" && typeof n2.id.value === "string";
                    if (isExternal) {
                      parts.push("module ");
                    } else if (n2.loc && n2.loc.lines && n2.id.loc) {
                      var prefix2 = n2.loc.lines.sliceString(n2.loc.start, n2.id.loc.start);
                      if (prefix2.indexOf("module") >= 0) {
                        parts.push("module ");
                      } else {
                        parts.push("namespace ");
                      }
                    } else {
                      parts.push("namespace ");
                    }
                  }
                }
                parts.push(path2.call(print, "id"));
                if (n2.body && n2.body.type === "TSModuleDeclaration") {
                  parts.push(path2.call(print, "body"));
                } else if (n2.body) {
                  var bodyLines = path2.call(print, "body");
                  if (bodyLines.isEmpty()) {
                    parts.push(" {}");
                  } else {
                    parts.push(" {\n", bodyLines.indent(options2.tabWidth), "\n}");
                  }
                }
                return lines.concat(parts);
              }
              case "TSModuleBlock":
                return path2.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options2, print);
                }, "body");
              case "ClassHeritage":
              case "ComprehensionBlock":
              case "ComprehensionExpression":
              case "Glob":
              case "GeneratorExpression":
              case "LetStatement":
              case "LetExpression":
              case "GraphExpression":
              case "GraphIndexExpression":
              case "XMLDefaultDeclaration":
              case "XMLAnyName":
              case "XMLQualifiedIdentifier":
              case "XMLFunctionQualifiedIdentifier":
              case "XMLAttributeSelector":
              case "XMLFilterExpression":
              case "XML":
              case "XMLElement":
              case "XMLList":
              case "XMLEscape":
              case "XMLText":
              case "XMLStartTag":
              case "XMLEndTag":
              case "XMLPointTag":
              case "XMLName":
              case "XMLAttribute":
              case "XMLCdata":
              case "XMLComment":
              case "XMLProcessingInstruction":
              default:
                debugger;
                throw new Error("unknown type: " + JSON.stringify(n2.type));
            }
          }
          function printDecorators(path2, printPath) {
            var parts = [];
            var node2 = path2.getValue();
            if (node2.decorators && node2.decorators.length > 0 && !util2.getParentExportDeclaration(path2)) {
              path2.each(function(decoratorPath) {
                parts.push(printPath(decoratorPath), "\n");
              }, "decorators");
            } else if (util2.isExportDeclaration(node2) && node2.declaration && node2.declaration.decorators) {
              path2.each(function(decoratorPath) {
                parts.push(printPath(decoratorPath), "\n");
              }, "declaration", "decorators");
            }
            return lines.concat(parts);
          }
          function printStatementSequence(path2, options2, print) {
            var filtered = [];
            var sawComment = false;
            var sawStatement = false;
            path2.each(function(stmtPath) {
              var stmt = stmtPath.getValue();
              if (!stmt) {
                return;
              }
              if (stmt.type === "EmptyStatement" && !(stmt.comments && stmt.comments.length > 0)) {
                return;
              }
              if (namedTypes2.Comment.check(stmt)) {
                sawComment = true;
              } else if (namedTypes2.Statement.check(stmt)) {
                sawStatement = true;
              } else {
                isString2.assert(stmt);
              }
              filtered.push({node: stmt, printed: print(stmtPath)});
            });
            if (sawComment) {
              assert_12.default.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement lists, but may not coexist with non-Comment nodes.");
            }
            var prevTrailingSpace = null;
            var len = filtered.length;
            var parts = [];
            filtered.forEach(function(info, i) {
              var printed = info.printed;
              var stmt = info.node;
              var multiLine = printed.length > 1;
              var notFirst = i > 0;
              var notLast = i < len - 1;
              var leadingSpace;
              var trailingSpace;
              var lines2 = stmt && stmt.loc && stmt.loc.lines;
              var trueLoc = lines2 && options2.reuseWhitespace && util2.getTrueLoc(stmt, lines2);
              if (notFirst) {
                if (trueLoc) {
                  var beforeStart = lines2.skipSpaces(trueLoc.start, true);
                  var beforeStartLine = beforeStart ? beforeStart.line : 1;
                  var leadingGap = trueLoc.start.line - beforeStartLine;
                  leadingSpace = Array(leadingGap + 1).join("\n");
                } else {
                  leadingSpace = multiLine ? "\n\n" : "\n";
                }
              } else {
                leadingSpace = "";
              }
              if (notLast) {
                if (trueLoc) {
                  var afterEnd = lines2.skipSpaces(trueLoc.end);
                  var afterEndLine = afterEnd ? afterEnd.line : lines2.length;
                  var trailingGap = afterEndLine - trueLoc.end.line;
                  trailingSpace = Array(trailingGap + 1).join("\n");
                } else {
                  trailingSpace = multiLine ? "\n\n" : "\n";
                }
              } else {
                trailingSpace = "";
              }
              parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
              if (notLast) {
                prevTrailingSpace = trailingSpace;
              } else if (trailingSpace) {
                parts.push(trailingSpace);
              }
            });
            return lines.concat(parts);
          }
          function maxSpace(s1, s2) {
            if (!s1 && !s2) {
              return lines.fromString("");
            }
            if (!s1) {
              return lines.fromString(s2);
            }
            if (!s2) {
              return lines.fromString(s1);
            }
            var spaceLines1 = lines.fromString(s1);
            var spaceLines2 = lines.fromString(s2);
            if (spaceLines2.length > spaceLines1.length) {
              return spaceLines2;
            }
            return spaceLines1;
          }
          function printMethod(path2, options2, print) {
            var node2 = path2.getNode();
            var kind = node2.kind;
            var parts = [];
            var nodeValue = node2.value;
            if (!namedTypes2.FunctionExpression.check(nodeValue)) {
              nodeValue = node2;
            }
            var access = node2.accessibility || node2.access;
            if (typeof access === "string") {
              parts.push(access, " ");
            }
            if (node2.static) {
              parts.push("static ");
            }
            if (node2.abstract) {
              parts.push("abstract ");
            }
            if (node2.readonly) {
              parts.push("readonly ");
            }
            if (nodeValue.async) {
              parts.push("async ");
            }
            if (nodeValue.generator) {
              parts.push("*");
            }
            if (kind === "get" || kind === "set") {
              parts.push(kind, " ");
            }
            var key = path2.call(print, "key");
            if (node2.computed) {
              key = lines.concat(["[", key, "]"]);
            }
            parts.push(key);
            if (node2.optional) {
              parts.push("?");
            }
            if (node2 === nodeValue) {
              parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType"));
              if (node2.body) {
                parts.push(" ", path2.call(print, "body"));
              } else {
                parts.push(";");
              }
            } else {
              parts.push(path2.call(print, "value", "typeParameters"), "(", path2.call(function(valuePath) {
                return printFunctionParams(valuePath, options2, print);
              }, "value"), ")", path2.call(print, "value", "returnType"));
              if (nodeValue.body) {
                parts.push(" ", path2.call(print, "value", "body"));
              } else {
                parts.push(";");
              }
            }
            return lines.concat(parts);
          }
          function printArgumentsList(path2, options2, print) {
            var printed = path2.map(print, "arguments");
            var trailingComma = util2.isTrailingCommaEnabled(options2, "parameters");
            var joined = lines.fromString(", ").join(printed);
            if (joined.getLineLength(1) > options2.wrapColumn) {
              joined = lines.fromString(",\n").join(printed);
              return lines.concat(["(\n", joined.indent(options2.tabWidth), trailingComma ? ",\n)" : "\n)"]);
            }
            return lines.concat(["(", joined, ")"]);
          }
          function printFunctionParams(path2, options2, print) {
            var fun = path2.getValue();
            var params;
            var printed = [];
            if (fun.params) {
              params = fun.params;
              printed = path2.map(print, "params");
            } else if (fun.parameters) {
              params = fun.parameters;
              printed = path2.map(print, "parameters");
            }
            if (fun.defaults) {
              path2.each(function(defExprPath) {
                var i = defExprPath.getName();
                var p = printed[i];
                if (p && defExprPath.getValue()) {
                  printed[i] = lines.concat([p, " = ", print(defExprPath)]);
                }
              }, "defaults");
            }
            if (fun.rest) {
              printed.push(lines.concat(["...", path2.call(print, "rest")]));
            }
            var joined = lines.fromString(", ").join(printed);
            if (joined.length > 1 || joined.getLineLength(1) > options2.wrapColumn) {
              joined = lines.fromString(",\n").join(printed);
              if (util2.isTrailingCommaEnabled(options2, "parameters") && !fun.rest && params[params.length - 1].type !== "RestElement") {
                joined = lines.concat([joined, ",\n"]);
              } else {
                joined = lines.concat([joined, "\n"]);
              }
              return lines.concat(["\n", joined.indent(options2.tabWidth)]);
            }
            return joined;
          }
          function printExportDeclaration(path2, options2, print) {
            var decl = path2.getValue();
            var parts = ["export "];
            if (decl.exportKind && decl.exportKind === "type") {
              if (!decl.declaration) {
                parts.push("type ");
              }
            }
            var shouldPrintSpaces = options2.objectCurlySpacing;
            namedTypes2.Declaration.assert(decl);
            if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
              parts.push("default ");
            }
            if (decl.declaration) {
              parts.push(path2.call(print, "declaration"));
            } else if (decl.specifiers) {
              if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier") {
                parts.push("*");
              } else if (decl.specifiers.length === 0) {
                parts.push("{}");
              } else if (decl.specifiers[0].type === "ExportDefaultSpecifier") {
                var unbracedSpecifiers_2 = [];
                var bracedSpecifiers_2 = [];
                path2.each(function(specifierPath) {
                  var spec = specifierPath.getValue();
                  if (spec.type === "ExportDefaultSpecifier") {
                    unbracedSpecifiers_2.push(print(specifierPath));
                  } else {
                    bracedSpecifiers_2.push(print(specifierPath));
                  }
                }, "specifiers");
                unbracedSpecifiers_2.forEach(function(lines2, i) {
                  if (i > 0) {
                    parts.push(", ");
                  }
                  parts.push(lines2);
                });
                if (bracedSpecifiers_2.length > 0) {
                  var lines_2 = lines.fromString(", ").join(bracedSpecifiers_2);
                  if (lines_2.getLineLength(1) > options2.wrapColumn) {
                    lines_2 = lines.concat([lines.fromString(",\n").join(bracedSpecifiers_2).indent(options2.tabWidth), ","]);
                  }
                  if (unbracedSpecifiers_2.length > 0) {
                    parts.push(", ");
                  }
                  if (lines_2.length > 1) {
                    parts.push("{\n", lines_2, "\n}");
                  } else if (options2.objectCurlySpacing) {
                    parts.push("{ ", lines_2, " }");
                  } else {
                    parts.push("{", lines_2, "}");
                  }
                }
              } else {
                parts.push(shouldPrintSpaces ? "{ " : "{", lines.fromString(", ").join(path2.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
              }
              if (decl.source) {
                parts.push(" from ", path2.call(print, "source"));
              }
            }
            var lines$1 = lines.concat(parts);
            if (lastNonSpaceCharacter(lines$1) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration" || decl.declaration.type === "TSModuleDeclaration" || decl.declaration.type === "TSInterfaceDeclaration" || decl.declaration.type === "TSEnumDeclaration"))) {
              lines$1 = lines.concat([lines$1, ";"]);
            }
            return lines$1;
          }
          function printFlowDeclaration(path2, parts) {
            var parentExportDecl = util2.getParentExportDeclaration(path2);
            if (parentExportDecl) {
              assert_12.default.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
            } else {
              parts.unshift("declare ");
            }
            return lines.concat(parts);
          }
          function printVariance(path2, print) {
            return path2.call(function(variancePath) {
              var value = variancePath.getValue();
              if (value) {
                if (value === "plus") {
                  return lines.fromString("+");
                }
                if (value === "minus") {
                  return lines.fromString("-");
                }
                return print(variancePath);
              }
              return lines.fromString("");
            }, "variance");
          }
          function adjustClause(clause, options2) {
            if (clause.length > 1)
              return lines.concat([" ", clause]);
            return lines.concat(["\n", maybeAddSemicolon(clause).indent(options2.tabWidth)]);
          }
          function lastNonSpaceCharacter(lines2) {
            var pos = lines2.lastPos();
            do {
              var ch = lines2.charAt(pos);
              if (/\S/.test(ch))
                return ch;
            } while (lines2.prevPos(pos));
          }
          function endsWithBrace(lines2) {
            return lastNonSpaceCharacter(lines2) === "}";
          }
          function swapQuotes(str) {
            return str.replace(/['"]/g, function(m) {
              return m === '"' ? "'" : '"';
            });
          }
          function nodeStr(str, options2) {
            isString2.assert(str);
            switch (options2.quote) {
              case "auto": {
                var double = JSON.stringify(str);
                var single = swapQuotes(JSON.stringify(swapQuotes(str)));
                return double.length > single.length ? single : double;
              }
              case "single":
                return swapQuotes(JSON.stringify(swapQuotes(str)));
              case "double":
              default:
                return JSON.stringify(str);
            }
          }
          function maybeAddSemicolon(lines$1) {
            var eoc = lastNonSpaceCharacter(lines$1);
            if (!eoc || "\n};".indexOf(eoc) < 0)
              return lines.concat([lines$1, ";"]);
            return lines$1;
          }
        });
        var main = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.run = exports4.prettyPrint = exports4.print = exports4.types = exports4.parse = void 0;
          var fs_1 = tslib_1.__importDefault(require$$0__default["default"]);
          var types2 = tslib_1.__importStar(main$1);
          exports4.types = types2;
          Object.defineProperty(exports4, "parse", {enumerable: true, get: function get2() {
            return parser$1.parse;
          }});
          Object.defineProperty(exports4, "visit", {enumerable: true, get: function get2() {
            return main$1.visit;
          }});
          function print(node2, options2) {
            return new printer.Printer(options2).print(node2);
          }
          exports4.print = print;
          function prettyPrint(node2, options2) {
            return new printer.Printer(options2).printGenerically(node2);
          }
          exports4.prettyPrint = prettyPrint;
          function run(transformer, options2) {
            return runFile(process.argv[2], transformer, options2);
          }
          exports4.run = run;
          function runFile(path2, transformer, options2) {
            fs_1.default.readFile(path2, "utf-8", function(err, code) {
              if (err) {
                console.error(err);
                return;
              }
              runString(code, transformer, options2);
            });
          }
          function defaultWriteback(output) {
            process.stdout.write(output);
          }
          function runString(code, transformer, options2) {
            var writeback = options2 && options2.writeback || defaultWriteback;
            transformer(parser$1.parse(code, options2), function(node2) {
              writeback(print(node2, options2).code);
            });
          }
        });
        const types$2 = main.types;
        const builders = main.types.builders;
        const namedTypes = main.types.namedTypes;
        function nullNode() {
          return builders.literal(null);
        }
        function simplePropertyNode(key, value) {
          return builders.property("init", builders.literal(key), value, false);
        }
        function sourcemapAsJSON(map) {
          if (map && map.toJSON)
            return map.toJSON();
          return map;
        }
        function isObject2(value) {
          return !isNil2(value) && value.constructor === Object;
        }
        function isNil2(value) {
          return value === null || value === void 0;
        }
        function isNode() {
          return typeof process !== "undefined";
        }
        function composeSourcemaps(formerMap, latterMap) {
          if (isNode() && formerMap && latterMap && latterMap.mappings) {
            return util$2.composeSourceMaps(sourcemapAsJSON(formerMap), sourcemapAsJSON(latterMap));
          } else if (isNode() && formerMap) {
            return sourcemapAsJSON(formerMap);
          }
          return {};
        }
        const intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        var encode$1 = function encode$12(number) {
          if (0 <= number && number < intToCharMap.length) {
            return intToCharMap[number];
          }
          throw new TypeError("Must be between 0 and 63: " + number);
        };
        var base64 = {encode: encode$1};
        const VLQ_BASE_SHIFT = 5;
        const VLQ_BASE = 1 << VLQ_BASE_SHIFT;
        const VLQ_BASE_MASK = VLQ_BASE - 1;
        const VLQ_CONTINUATION_BIT = VLQ_BASE;
        function toVLQSigned(aValue) {
          return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
        }
        var encode = function base64VLQ_encode(aValue) {
          let encoded = "";
          let digit;
          let vlq = toVLQSigned(aValue);
          do {
            digit = vlq & VLQ_BASE_MASK;
            vlq >>>= VLQ_BASE_SHIFT;
            if (vlq > 0) {
              digit |= VLQ_CONTINUATION_BIT;
            }
            encoded += base64.encode(digit);
          } while (vlq > 0);
          return encoded;
        };
        var base64Vlq = {encode};
        var util = createCommonjsModule(function(module3, exports4) {
          function getArg(aArgs, aName, aDefaultValue) {
            if (aName in aArgs) {
              return aArgs[aName];
            } else if (arguments.length === 3) {
              return aDefaultValue;
            }
            throw new Error('"' + aName + '" is a required argument.');
          }
          exports4.getArg = getArg;
          const urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
          const dataUrlRegexp = /^data:.+\,.+$/;
          function urlParse(aUrl) {
            const match = aUrl.match(urlRegexp);
            if (!match) {
              return null;
            }
            return {scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5]};
          }
          exports4.urlParse = urlParse;
          function urlGenerate(aParsedUrl) {
            let url = "";
            if (aParsedUrl.scheme) {
              url += aParsedUrl.scheme + ":";
            }
            url += "//";
            if (aParsedUrl.auth) {
              url += aParsedUrl.auth + "@";
            }
            if (aParsedUrl.host) {
              url += aParsedUrl.host;
            }
            if (aParsedUrl.port) {
              url += ":" + aParsedUrl.port;
            }
            if (aParsedUrl.path) {
              url += aParsedUrl.path;
            }
            return url;
          }
          exports4.urlGenerate = urlGenerate;
          const MAX_CACHED_INPUTS = 32;
          function lruMemoize(f) {
            const cache = [];
            return function(input) {
              for (let i = 0; i < cache.length; i++) {
                if (cache[i].input === input) {
                  const temp = cache[0];
                  cache[0] = cache[i];
                  cache[i] = temp;
                  return cache[0].result;
                }
              }
              const result = f(input);
              cache.unshift({input, result});
              if (cache.length > MAX_CACHED_INPUTS) {
                cache.pop();
              }
              return result;
            };
          }
          const normalize3 = lruMemoize(function normalize4(aPath) {
            let path2 = aPath;
            const url = urlParse(aPath);
            if (url) {
              if (!url.path) {
                return aPath;
              }
              path2 = url.path;
            }
            const isAbsolute = exports4.isAbsolute(path2);
            const parts = [];
            let start = 0;
            let i = 0;
            while (true) {
              start = i;
              i = path2.indexOf("/", start);
              if (i === -1) {
                parts.push(path2.slice(start));
                break;
              } else {
                parts.push(path2.slice(start, i));
                while (i < path2.length && path2[i] === "/") {
                  i++;
                }
              }
            }
            let up = 0;
            for (i = parts.length - 1; i >= 0; i--) {
              const part2 = parts[i];
              if (part2 === ".") {
                parts.splice(i, 1);
              } else if (part2 === "..") {
                up++;
              } else if (up > 0) {
                if (part2 === "") {
                  parts.splice(i + 1, up);
                  up = 0;
                } else {
                  parts.splice(i, 2);
                  up--;
                }
              }
            }
            path2 = parts.join("/");
            if (path2 === "") {
              path2 = isAbsolute ? "/" : ".";
            }
            if (url) {
              url.path = path2;
              return urlGenerate(url);
            }
            return path2;
          });
          exports4.normalize = normalize3;
          function join(aRoot, aPath) {
            if (aRoot === "") {
              aRoot = ".";
            }
            if (aPath === "") {
              aPath = ".";
            }
            const aPathUrl = urlParse(aPath);
            const aRootUrl = urlParse(aRoot);
            if (aRootUrl) {
              aRoot = aRootUrl.path || "/";
            }
            if (aPathUrl && !aPathUrl.scheme) {
              if (aRootUrl) {
                aPathUrl.scheme = aRootUrl.scheme;
              }
              return urlGenerate(aPathUrl);
            }
            if (aPathUrl || aPath.match(dataUrlRegexp)) {
              return aPath;
            }
            if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
              aRootUrl.host = aPath;
              return urlGenerate(aRootUrl);
            }
            const joined = aPath.charAt(0) === "/" ? aPath : normalize3(aRoot.replace(/\/+$/, "") + "/" + aPath);
            if (aRootUrl) {
              aRootUrl.path = joined;
              return urlGenerate(aRootUrl);
            }
            return joined;
          }
          exports4.join = join;
          exports4.isAbsolute = function(aPath) {
            return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
          };
          function relative(aRoot, aPath) {
            if (aRoot === "") {
              aRoot = ".";
            }
            aRoot = aRoot.replace(/\/$/, "");
            let level = 0;
            while (aPath.indexOf(aRoot + "/") !== 0) {
              const index = aRoot.lastIndexOf("/");
              if (index < 0) {
                return aPath;
              }
              aRoot = aRoot.slice(0, index);
              if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                return aPath;
              }
              ++level;
            }
            return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
          }
          exports4.relative = relative;
          const supportsNullProto = function() {
            const obj = Object.create(null);
            return !("__proto__" in obj);
          }();
          function identity(s) {
            return s;
          }
          function toSetString(aStr) {
            if (isProtoString(aStr)) {
              return "$" + aStr;
            }
            return aStr;
          }
          exports4.toSetString = supportsNullProto ? identity : toSetString;
          function fromSetString(aStr) {
            if (isProtoString(aStr)) {
              return aStr.slice(1);
            }
            return aStr;
          }
          exports4.fromSetString = supportsNullProto ? identity : fromSetString;
          function isProtoString(s) {
            if (!s) {
              return false;
            }
            const length = s.length;
            if (length < 9) {
              return false;
            }
            if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
              return false;
            }
            for (let i = length - 10; i >= 0; i--) {
              if (s.charCodeAt(i) !== 36) {
                return false;
              }
            }
            return true;
          }
          function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
            let cmp = strcmp(mappingA.source, mappingB.source);
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0 || onlyCompareOriginal) {
              return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
              return cmp;
            }
            return strcmp(mappingA.name, mappingB.name);
          }
          exports4.compareByOriginalPositions = compareByOriginalPositions;
          function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
            let cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0 || onlyCompareGenerated) {
              return cmp;
            }
            cmp = strcmp(mappingA.source, mappingB.source);
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0) {
              return cmp;
            }
            return strcmp(mappingA.name, mappingB.name);
          }
          exports4.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
          function strcmp(aStr1, aStr2) {
            if (aStr1 === aStr2) {
              return 0;
            }
            if (aStr1 === null) {
              return 1;
            }
            if (aStr2 === null) {
              return -1;
            }
            if (aStr1 > aStr2) {
              return 1;
            }
            return -1;
          }
          function compareByGeneratedPositionsInflated(mappingA, mappingB) {
            let cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = strcmp(mappingA.source, mappingB.source);
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
              return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0) {
              return cmp;
            }
            return strcmp(mappingA.name, mappingB.name);
          }
          exports4.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
          function parseSourceMapInput(str) {
            return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
          }
          exports4.parseSourceMapInput = parseSourceMapInput;
          function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
            sourceURL = sourceURL || "";
            if (sourceRoot) {
              if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
                sourceRoot += "/";
              }
              sourceURL = sourceRoot + sourceURL;
            }
            if (sourceMapURL) {
              const parsed = urlParse(sourceMapURL);
              if (!parsed) {
                throw new Error("sourceMapURL could not be parsed");
              }
              if (parsed.path) {
                const index = parsed.path.lastIndexOf("/");
                if (index >= 0) {
                  parsed.path = parsed.path.substring(0, index + 1);
                }
              }
              sourceURL = join(urlGenerate(parsed), sourceURL);
            }
            return normalize3(sourceURL);
          }
          exports4.computeSourceURL = computeSourceURL;
        });
        class ArraySet$1 {
          constructor() {
            this._array = [];
            this._set = new Map();
          }
          static fromArray(aArray, aAllowDuplicates) {
            const set2 = new ArraySet$1();
            for (let i = 0, len = aArray.length; i < len; i++) {
              set2.add(aArray[i], aAllowDuplicates);
            }
            return set2;
          }
          size() {
            return this._set.size;
          }
          add(aStr, aAllowDuplicates) {
            const isDuplicate = this.has(aStr);
            const idx = this._array.length;
            if (!isDuplicate || aAllowDuplicates) {
              this._array.push(aStr);
            }
            if (!isDuplicate) {
              this._set.set(aStr, idx);
            }
          }
          has(aStr) {
            return this._set.has(aStr);
          }
          indexOf(aStr) {
            const idx = this._set.get(aStr);
            if (idx >= 0) {
              return idx;
            }
            throw new Error('"' + aStr + '" is not in the set.');
          }
          at(aIdx) {
            if (aIdx >= 0 && aIdx < this._array.length) {
              return this._array[aIdx];
            }
            throw new Error("No element indexed by " + aIdx);
          }
          toArray() {
            return this._array.slice();
          }
        }
        var ArraySet_1 = ArraySet$1;
        var arraySet = {ArraySet: ArraySet_1};
        function generatedPositionAfter(mappingA, mappingB) {
          const lineA = mappingA.generatedLine;
          const lineB = mappingB.generatedLine;
          const columnA = mappingA.generatedColumn;
          const columnB = mappingB.generatedColumn;
          return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
        }
        class MappingList$1 {
          constructor() {
            this._array = [];
            this._sorted = true;
            this._last = {generatedLine: -1, generatedColumn: 0};
          }
          unsortedForEach(aCallback, aThisArg) {
            this._array.forEach(aCallback, aThisArg);
          }
          add(aMapping) {
            if (generatedPositionAfter(this._last, aMapping)) {
              this._last = aMapping;
              this._array.push(aMapping);
            } else {
              this._sorted = false;
              this._array.push(aMapping);
            }
          }
          toArray() {
            if (!this._sorted) {
              this._array.sort(util.compareByGeneratedPositionsInflated);
              this._sorted = true;
            }
            return this._array;
          }
        }
        var MappingList_1 = MappingList$1;
        var mappingList = {MappingList: MappingList_1};
        const ArraySet = arraySet.ArraySet;
        const MappingList = mappingList.MappingList;
        class SourceMapGenerator$1 {
          constructor(aArgs) {
            if (!aArgs) {
              aArgs = {};
            }
            this._file = util.getArg(aArgs, "file", null);
            this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
            this._skipValidation = util.getArg(aArgs, "skipValidation", false);
            this._sources = new ArraySet();
            this._names = new ArraySet();
            this._mappings = new MappingList();
            this._sourcesContents = null;
          }
          static fromSourceMap(aSourceMapConsumer) {
            const sourceRoot = aSourceMapConsumer.sourceRoot;
            const generator = new SourceMapGenerator$1({file: aSourceMapConsumer.file, sourceRoot});
            aSourceMapConsumer.eachMapping(function(mapping2) {
              const newMapping = {generated: {line: mapping2.generatedLine, column: mapping2.generatedColumn}};
              if (mapping2.source != null) {
                newMapping.source = mapping2.source;
                if (sourceRoot != null) {
                  newMapping.source = util.relative(sourceRoot, newMapping.source);
                }
                newMapping.original = {line: mapping2.originalLine, column: mapping2.originalColumn};
                if (mapping2.name != null) {
                  newMapping.name = mapping2.name;
                }
              }
              generator.addMapping(newMapping);
            });
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              let sourceRelative = sourceFile;
              if (sourceRoot !== null) {
                sourceRelative = util.relative(sourceRoot, sourceFile);
              }
              if (!generator._sources.has(sourceRelative)) {
                generator._sources.add(sourceRelative);
              }
              const content = aSourceMapConsumer.sourceContentFor(sourceFile);
              if (content != null) {
                generator.setSourceContent(sourceFile, content);
              }
            });
            return generator;
          }
          addMapping(aArgs) {
            const generated = util.getArg(aArgs, "generated");
            const original = util.getArg(aArgs, "original", null);
            let source = util.getArg(aArgs, "source", null);
            let name = util.getArg(aArgs, "name", null);
            if (!this._skipValidation) {
              this._validateMapping(generated, original, source, name);
            }
            if (source != null) {
              source = String(source);
              if (!this._sources.has(source)) {
                this._sources.add(source);
              }
            }
            if (name != null) {
              name = String(name);
              if (!this._names.has(name)) {
                this._names.add(name);
              }
            }
            this._mappings.add({generatedLine: generated.line, generatedColumn: generated.column, originalLine: original != null && original.line, originalColumn: original != null && original.column, source, name});
          }
          setSourceContent(aSourceFile, aSourceContent) {
            let source = aSourceFile;
            if (this._sourceRoot != null) {
              source = util.relative(this._sourceRoot, source);
            }
            if (aSourceContent != null) {
              if (!this._sourcesContents) {
                this._sourcesContents = Object.create(null);
              }
              this._sourcesContents[util.toSetString(source)] = aSourceContent;
            } else if (this._sourcesContents) {
              delete this._sourcesContents[util.toSetString(source)];
              if (Object.keys(this._sourcesContents).length === 0) {
                this._sourcesContents = null;
              }
            }
          }
          applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
            let sourceFile = aSourceFile;
            if (aSourceFile == null) {
              if (aSourceMapConsumer.file == null) {
                throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
              }
              sourceFile = aSourceMapConsumer.file;
            }
            const sourceRoot = this._sourceRoot;
            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }
            const newSources = this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;
            const newNames = new ArraySet();
            this._mappings.unsortedForEach(function(mapping2) {
              if (mapping2.source === sourceFile && mapping2.originalLine != null) {
                const original = aSourceMapConsumer.originalPositionFor({line: mapping2.originalLine, column: mapping2.originalColumn});
                if (original.source != null) {
                  mapping2.source = original.source;
                  if (aSourceMapPath != null) {
                    mapping2.source = util.join(aSourceMapPath, mapping2.source);
                  }
                  if (sourceRoot != null) {
                    mapping2.source = util.relative(sourceRoot, mapping2.source);
                  }
                  mapping2.originalLine = original.line;
                  mapping2.originalColumn = original.column;
                  if (original.name != null) {
                    mapping2.name = original.name;
                  }
                }
              }
              const source = mapping2.source;
              if (source != null && !newSources.has(source)) {
                newSources.add(source);
              }
              const name = mapping2.name;
              if (name != null && !newNames.has(name)) {
                newNames.add(name);
              }
            }, this);
            this._sources = newSources;
            this._names = newNames;
            aSourceMapConsumer.sources.forEach(function(srcFile) {
              const content = aSourceMapConsumer.sourceContentFor(srcFile);
              if (content != null) {
                if (aSourceMapPath != null) {
                  srcFile = util.join(aSourceMapPath, srcFile);
                }
                if (sourceRoot != null) {
                  srcFile = util.relative(sourceRoot, srcFile);
                }
                this.setSourceContent(srcFile, content);
              }
            }, this);
          }
          _validateMapping(aGenerated, aOriginal, aSource, aName) {
            if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
              throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
            }
            if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)
              ;
            else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
              ;
            else {
              throw new Error("Invalid mapping: " + JSON.stringify({generated: aGenerated, source: aSource, original: aOriginal, name: aName}));
            }
          }
          _serializeMappings() {
            let previousGeneratedColumn = 0;
            let previousGeneratedLine = 1;
            let previousOriginalColumn = 0;
            let previousOriginalLine = 0;
            let previousName = 0;
            let previousSource = 0;
            let result = "";
            let next;
            let mapping2;
            let nameIdx;
            let sourceIdx;
            const mappings = this._mappings.toArray();
            for (let i = 0, len = mappings.length; i < len; i++) {
              mapping2 = mappings[i];
              next = "";
              if (mapping2.generatedLine !== previousGeneratedLine) {
                previousGeneratedColumn = 0;
                while (mapping2.generatedLine !== previousGeneratedLine) {
                  next += ";";
                  previousGeneratedLine++;
                }
              } else if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping2, mappings[i - 1])) {
                  continue;
                }
                next += ",";
              }
              next += base64Vlq.encode(mapping2.generatedColumn - previousGeneratedColumn);
              previousGeneratedColumn = mapping2.generatedColumn;
              if (mapping2.source != null) {
                sourceIdx = this._sources.indexOf(mapping2.source);
                next += base64Vlq.encode(sourceIdx - previousSource);
                previousSource = sourceIdx;
                next += base64Vlq.encode(mapping2.originalLine - 1 - previousOriginalLine);
                previousOriginalLine = mapping2.originalLine - 1;
                next += base64Vlq.encode(mapping2.originalColumn - previousOriginalColumn);
                previousOriginalColumn = mapping2.originalColumn;
                if (mapping2.name != null) {
                  nameIdx = this._names.indexOf(mapping2.name);
                  next += base64Vlq.encode(nameIdx - previousName);
                  previousName = nameIdx;
                }
              }
              result += next;
            }
            return result;
          }
          _generateSourcesContent(aSources, aSourceRoot) {
            return aSources.map(function(source) {
              if (!this._sourcesContents) {
                return null;
              }
              if (aSourceRoot != null) {
                source = util.relative(aSourceRoot, source);
              }
              const key = util.toSetString(source);
              return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
            }, this);
          }
          toJSON() {
            const map = {version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings()};
            if (this._file != null) {
              map.file = this._file;
            }
            if (this._sourceRoot != null) {
              map.sourceRoot = this._sourceRoot;
            }
            if (this._sourcesContents) {
              map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
            }
            return map;
          }
          toString() {
            return JSON.stringify(this.toJSON());
          }
        }
        SourceMapGenerator$1.prototype._version = 3;
        var SourceMapGenerator_1 = SourceMapGenerator$1;
        var sourceMapGenerator = {SourceMapGenerator: SourceMapGenerator_1};
        createCommonjsModule(function(module3, exports4) {
          exports4.GREATEST_LOWER_BOUND = 1;
          exports4.LEAST_UPPER_BOUND = 2;
          function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
            const mid = Math.floor((aHigh - aLow) / 2) + aLow;
            const cmp = aCompare(aNeedle, aHaystack[mid], true);
            if (cmp === 0) {
              return mid;
            } else if (cmp > 0) {
              if (aHigh - mid > 1) {
                return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
              }
              if (aBias == exports4.LEAST_UPPER_BOUND) {
                return aHigh < aHaystack.length ? aHigh : -1;
              }
              return mid;
            }
            if (mid - aLow > 1) {
              return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
            }
            if (aBias == exports4.LEAST_UPPER_BOUND) {
              return mid;
            }
            return aLow < 0 ? -1 : aLow;
          }
          exports4.search = function search(aNeedle, aHaystack, aCompare, aBias) {
            if (aHaystack.length === 0) {
              return -1;
            }
            let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports4.GREATEST_LOWER_BOUND);
            if (index < 0) {
              return -1;
            }
            while (index - 1 >= 0) {
              if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                break;
              }
              --index;
            }
            return index;
          };
        });
        createCommonjsModule(function(module3) {
          if (typeof fetch === "function") {
            let mappingsWasmUrl = null;
            module3.exports = function readWasm() {
              if (typeof mappingsWasmUrl !== "string") {
                throw new Error("You must provide the URL of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer");
              }
              return fetch(mappingsWasmUrl).then((response) => response.arrayBuffer());
            };
            module3.exports.initialize = (url) => mappingsWasmUrl = url;
          } else {
            const fs = require$$0__default["default"];
            const path2 = require$$1__default["default"];
            module3.exports = function readWasm() {
              return new Promise((resolve, reject) => {
                const wasmPath = path2.join(__dirname, "mappings.wasm");
                fs.readFile(wasmPath, null, (error, data) => {
                  if (error) {
                    reject(error);
                    return;
                  }
                  resolve(data.buffer);
                });
              });
            };
            module3.exports.initialize = (_) => {
              console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
            };
          }
        });
        var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
        function createSourcemap(options2) {
          return new SourceMapGenerator(options2);
        }
        const Output = Object.freeze({code: "", ast: [], meta: {}, map: null});
        function createOutput(data, meta) {
          const output = Object.assign({}, Output, data, {meta});
          if (!output.map && meta && meta.options && meta.options.file)
            return Object.assign({}, output, {map: createSourcemap({file: meta.options.file})});
          return output;
        }
        function transform(compiler2, meta, source) {
          const result = compiler2 ? compiler2(source, meta) : {code: source};
          return createOutput(result, meta);
        }
        function panic$1(message) {
          throw new Error(message);
        }
        const postprocessors = new Set();
        function register$1(postprocessor) {
          if (postprocessors.has(postprocessor)) {
            panic$1(`This postprocessor "${postprocessor.name || postprocessor.toString()}" was already registered`);
          }
          postprocessors.add(postprocessor);
          return postprocessors;
        }
        function execute$1(compilerOutput, meta) {
          return Array.from(postprocessors).reduce(function(acc, postprocessor) {
            const {code, map} = acc;
            const output = postprocessor(code, meta);
            return {code: output.code, map: composeSourcemaps(map, output.map)};
          }, createOutput(compilerOutput, meta));
        }
        const preprocessors = Object.freeze({javascript: new Map(), css: new Map(), template: new Map().set("default", (code) => ({code}))});
        function preprocessorTypeError(type2) {
          panic$1(`No preprocessor of type "${type2}" was found, please make sure to use one of these: 'javascript', 'css' or 'template'`);
        }
        function preprocessorNameNotFoundError(name) {
          panic$1(`No preprocessor named "${name}" was found, are you sure you have registered it?'`);
        }
        function register2(type2, name, preprocessor) {
          if (!type2)
            panic$1("Please define the type of preprocessor you want to register 'javascript', 'css' or 'template'");
          if (!name)
            panic$1("Please define a name for your preprocessor");
          if (!preprocessor)
            panic$1("Please provide a preprocessor function");
          if (!preprocessors[type2])
            preprocessorTypeError(type2);
          if (preprocessors[type2].has(name))
            panic$1(`The preprocessor ${name} was already registered before`);
          preprocessors[type2].set(name, preprocessor);
          return preprocessors;
        }
        function execute(type2, name, meta, source) {
          if (!preprocessors[type2])
            preprocessorTypeError(type2);
          if (!preprocessors[type2].has(name))
            preprocessorNameNotFoundError(name);
          return transform(preprocessors[type2].get(name), meta, source);
        }
        function compose2() {
          for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
            fns[_key] = arguments[_key];
          }
          return fns.reduce((f, g) => function() {
            return f(g(...arguments));
          });
        }
        /*! https://mths.be/cssesc v3.0.0 by @mathias */
        var object = {};
        var hasOwnProperty = object.hasOwnProperty;
        var merge = function merge2(options2, defaults) {
          if (!options2) {
            return defaults;
          }
          var result = {};
          for (var key in defaults) {
            result[key] = hasOwnProperty.call(options2, key) ? options2[key] : defaults[key];
          }
          return result;
        };
        var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
        var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
        var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
        var cssesc = function cssesc2(string, options2) {
          options2 = merge(options2, cssesc2.options);
          if (options2.quotes != "single" && options2.quotes != "double") {
            options2.quotes = "single";
          }
          var quote = options2.quotes == "double" ? '"' : "'";
          var isIdentifier2 = options2.isIdentifier;
          var firstChar = string.charAt(0);
          var output = "";
          var counter = 0;
          var length = string.length;
          while (counter < length) {
            var character = string.charAt(counter++);
            var codePoint = character.charCodeAt();
            var value = void 0;
            if (codePoint < 32 || codePoint > 126) {
              if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
                var extra = string.charCodeAt(counter++);
                if ((extra & 64512) == 56320) {
                  codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
                } else {
                  counter--;
                }
              }
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            } else {
              if (options2.escapeEverything) {
                if (regexAnySingleEscape.test(character)) {
                  value = "\\" + character;
                } else {
                  value = "\\" + codePoint.toString(16).toUpperCase() + " ";
                }
              } else if (/[\t\n\f\r\x0B]/.test(character)) {
                value = "\\" + codePoint.toString(16).toUpperCase() + " ";
              } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier2 && regexSingleEscape.test(character)) {
                value = "\\" + character;
              } else {
                value = character;
              }
            }
            output += value;
          }
          if (isIdentifier2) {
            if (/^-[-\d]/.test(output)) {
              output = "\\-" + output.slice(1);
            } else if (/\d/.test(firstChar)) {
              output = "\\3" + firstChar + " " + output.slice(1);
            }
          }
          output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
            if ($1 && $1.length % 2) {
              return $0;
            }
            return ($1 || "") + $2;
          });
          if (!isIdentifier2 && options2.wrap) {
            return quote + output + quote;
          }
          return output;
        };
        cssesc.options = {"escapeEverything": false, "isIdentifier": false, "quotes": "single", "wrap": false};
        cssesc.version = "3.0.0";
        var cssesc_1 = cssesc;
        const ATTRIBUTE_TYPE_NAME = "type";
        function getPreprocessorTypeByAttribute(sourceNode2) {
          const typeAttribute = sourceNode2.attributes ? sourceNode2.attributes.find((attribute) => attribute.name === ATTRIBUTE_TYPE_NAME) : null;
          return typeAttribute ? normalize2(typeAttribute.value) : null;
        }
        function normalize2(value) {
          return value.replace("text/", "");
        }
        function preprocess(preprocessorType, preprocessorName, meta, node2) {
          const code = node2.text;
          return preprocessorName ? execute(preprocessorType, preprocessorName, meta, code) : {code};
        }
        const R_MLCOMMS = /\/\*[^*]*\*+(?:[^*/][^*]*\*+)*\//g;
        const S_LINESTR = /"[^"\n\\]*(?:\\[\S\s][^"\n\\]*)*"|'[^'\n\\]*(?:\\[\S\s][^'\n\\]*)*'/.source;
        const CSS_SELECTOR = RegExp(`([{}]|^)[; ]*((?:[^@ ;{}][^{}]*)?[^@ ;{}:] ?)(?={)|${S_LINESTR}`, "g");
        function scopedCSS(tag2, css2) {
          const host = ":host";
          const selectorsBlacklist = ["from", "to"];
          return css2.replace(CSS_SELECTOR, function(m, p1, p2) {
            if (!p2)
              return m;
            p2 = p2.replace(/[^,]+/g, function(sel) {
              const s = sel.trim();
              if (s.indexOf(tag2) === 0) {
                return sel;
              }
              if (!s || selectorsBlacklist.indexOf(s) > -1 || s.slice(-1) === "%") {
                return sel;
              }
              if (s.indexOf(host) < 0) {
                return `${tag2} ${s},[is="${tag2}"] ${s}`;
              } else {
                return `${s.replace(host, tag2)},${s.replace(host, `[is="${tag2}"]`)}`;
              }
            });
            return p1 ? `${p1} ${p2}` : p2;
          });
        }
        function compactCss(code) {
          return code.replace(R_MLCOMMS, "").replace(/\s+/g, " ").trim();
        }
        const escapeBackslashes = (s) => s.replace(/\\/g, "\\\\");
        const escapeIdentifier = (identifier) => escapeBackslashes(cssesc_1(identifier, {isIdentifier: true}));
        function css(sourceNode2, source, meta, ast) {
          const preprocessorName = getPreprocessorTypeByAttribute(sourceNode2);
          const {options: options2} = meta;
          const preprocessorOutput = preprocess("css", preprocessorName, meta, sourceNode2.text);
          const normalizedCssCode = compactCss(preprocessorOutput.code);
          const escapedCssIdentifier = escapeIdentifier(meta.tagName);
          const cssCode = (options2.scopedCss ? scopedCSS(escapedCssIdentifier, escapeBackslashes(normalizedCssCode)) : escapeBackslashes(normalizedCssCode)).trim();
          types$2.visit(ast, {visitProperty(path2) {
            if (path2.value.key.value === TAG_CSS_PROPERTY) {
              path2.value.value = builders.templateLiteral([builders.templateElement({raw: cssCode, cooked: ""}, false)], []);
              return false;
            }
            this.traverse(path2);
          }});
          return ast;
        }
        function curry2(fn) {
          for (var _len2 = arguments.length, acc = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            acc[_key2 - 1] = arguments[_key2];
          }
          return function() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            args = [...acc, ...args];
            return args.length < fn.length ? curry2(fn, ...args) : fn(...args);
          };
        }
        function generateJavascript(ast, options2) {
          return main.print(ast, Object.assign({}, options2, {tabWidth: 2, wrapColumn: 0, quote: "single"}));
        }
        function hasHTMLOutsideRootNode(root, code, parse) {
          const additionalCode = root ? [
            code.substr(0, root.start),
            code.substr(root.end, code.length)
          ].join("").trim() : "";
          if (additionalCode) {
            try {
              const {template: template2, javascript: javascript2, css: css2} = parse(additionalCode).output;
              return [template2, javascript2, css2].some(isObject2);
            } catch (error) {
              return false;
            }
          }
          return false;
        }
        function isEmptySourcemap(map) {
          return !map || !map.mappings || !map.mappings.length;
        }
        var builtin = {AggregateError: false, "Array": false, "ArrayBuffer": false, Atomics: false, BigInt: false, BigInt64Array: false, BigUint64Array: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, FinalizationRegistry: false, "Float32Array": false, "Float64Array": false, "Function": false, globalThis: false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, WeakRef: false, "WeakSet": false};
        var es5 = {"Array": false, "Boolean": false, constructor: false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Function": false, hasOwnProperty: false, "Infinity": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, propertyIsEnumerable: false, "RangeError": false, "ReferenceError": false, "RegExp": false, "String": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false};
        var es2015 = {"Array": false, "ArrayBuffer": false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Float32Array": false, "Float64Array": false, "Function": false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, "WeakSet": false};
        var es2017 = {"Array": false, "ArrayBuffer": false, Atomics: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Float32Array": false, "Float64Array": false, "Function": false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, "WeakSet": false};
        var es2020 = {"Array": false, "ArrayBuffer": false, Atomics: false, BigInt: false, BigInt64Array: false, BigUint64Array: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Float32Array": false, "Float64Array": false, "Function": false, globalThis: false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, "WeakSet": false};
        var es2021 = {AggregateError: false, "Array": false, "ArrayBuffer": false, Atomics: false, BigInt: false, BigInt64Array: false, BigUint64Array: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, FinalizationRegistry: false, "Float32Array": false, "Float64Array": false, "Function": false, globalThis: false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, WeakRef: false, "WeakSet": false};
        var browser = {AbortController: false, AbortSignal: false, addEventListener: false, alert: false, AnalyserNode: false, Animation: false, AnimationEffectReadOnly: false, AnimationEffectTiming: false, AnimationEffectTimingReadOnly: false, AnimationEvent: false, AnimationPlaybackEvent: false, AnimationTimeline: false, applicationCache: false, ApplicationCache: false, ApplicationCacheErrorEvent: false, atob: false, Attr: false, Audio: false, AudioBuffer: false, AudioBufferSourceNode: false, AudioContext: false, AudioDestinationNode: false, AudioListener: false, AudioNode: false, AudioParam: false, AudioProcessingEvent: false, AudioScheduledSourceNode: false, "AudioWorkletGlobalScope ": false, AudioWorkletNode: false, AudioWorkletProcessor: false, BarProp: false, BaseAudioContext: false, BatteryManager: false, BeforeUnloadEvent: false, BiquadFilterNode: false, Blob: false, BlobEvent: false, blur: false, BroadcastChannel: false, btoa: false, BudgetService: false, ByteLengthQueuingStrategy: false, Cache: false, caches: false, CacheStorage: false, cancelAnimationFrame: false, cancelIdleCallback: false, CanvasCaptureMediaStreamTrack: false, CanvasGradient: false, CanvasPattern: false, CanvasRenderingContext2D: false, ChannelMergerNode: false, ChannelSplitterNode: false, CharacterData: false, clearInterval: false, clearTimeout: false, clientInformation: false, ClipboardEvent: false, close: false, closed: false, CloseEvent: false, Comment: false, CompositionEvent: false, confirm: false, console: false, ConstantSourceNode: false, ConvolverNode: false, CountQueuingStrategy: false, createImageBitmap: false, Credential: false, CredentialsContainer: false, crypto: false, Crypto: false, CryptoKey: false, CSS: false, CSSConditionRule: false, CSSFontFaceRule: false, CSSGroupingRule: false, CSSImportRule: false, CSSKeyframeRule: false, CSSKeyframesRule: false, CSSMediaRule: false, CSSNamespaceRule: false, CSSPageRule: false, CSSRule: false, CSSRuleList: false, CSSStyleDeclaration: false, CSSStyleRule: false, CSSStyleSheet: false, CSSSupportsRule: false, CustomElementRegistry: false, customElements: false, CustomEvent: false, DataTransfer: false, DataTransferItem: false, DataTransferItemList: false, defaultstatus: false, defaultStatus: false, DelayNode: false, DeviceMotionEvent: false, DeviceOrientationEvent: false, devicePixelRatio: false, dispatchEvent: false, document: false, Document: false, DocumentFragment: false, DocumentType: false, DOMError: false, DOMException: false, DOMImplementation: false, DOMMatrix: false, DOMMatrixReadOnly: false, DOMParser: false, DOMPoint: false, DOMPointReadOnly: false, DOMQuad: false, DOMRect: false, DOMRectReadOnly: false, DOMStringList: false, DOMStringMap: false, DOMTokenList: false, DragEvent: false, DynamicsCompressorNode: false, Element: false, ErrorEvent: false, event: false, Event: false, EventSource: false, EventTarget: false, external: false, fetch: false, File: false, FileList: false, FileReader: false, find: false, focus: false, FocusEvent: false, FontFace: false, FontFaceSetLoadEvent: false, FormData: false, frameElement: false, frames: false, GainNode: false, Gamepad: false, GamepadButton: false, GamepadEvent: false, getComputedStyle: false, getSelection: false, HashChangeEvent: false, Headers: false, history: false, History: false, HTMLAllCollection: false, HTMLAnchorElement: false, HTMLAreaElement: false, HTMLAudioElement: false, HTMLBaseElement: false, HTMLBodyElement: false, HTMLBRElement: false, HTMLButtonElement: false, HTMLCanvasElement: false, HTMLCollection: false, HTMLContentElement: false, HTMLDataElement: false, HTMLDataListElement: false, HTMLDetailsElement: false, HTMLDialogElement: false, HTMLDirectoryElement: false, HTMLDivElement: false, HTMLDListElement: false, HTMLDocument: false, HTMLElement: false, HTMLEmbedElement: false, HTMLFieldSetElement: false, HTMLFontElement: false, HTMLFormControlsCollection: false, HTMLFormElement: false, HTMLFrameElement: false, HTMLFrameSetElement: false, HTMLHeadElement: false, HTMLHeadingElement: false, HTMLHRElement: false, HTMLHtmlElement: false, HTMLIFrameElement: false, HTMLImageElement: false, HTMLInputElement: false, HTMLLabelElement: false, HTMLLegendElement: false, HTMLLIElement: false, HTMLLinkElement: false, HTMLMapElement: false, HTMLMarqueeElement: false, HTMLMediaElement: false, HTMLMenuElement: false, HTMLMetaElement: false, HTMLMeterElement: false, HTMLModElement: false, HTMLObjectElement: false, HTMLOListElement: false, HTMLOptGroupElement: false, HTMLOptionElement: false, HTMLOptionsCollection: false, HTMLOutputElement: false, HTMLParagraphElement: false, HTMLParamElement: false, HTMLPictureElement: false, HTMLPreElement: false, HTMLProgressElement: false, HTMLQuoteElement: false, HTMLScriptElement: false, HTMLSelectElement: false, HTMLShadowElement: false, HTMLSlotElement: false, HTMLSourceElement: false, HTMLSpanElement: false, HTMLStyleElement: false, HTMLTableCaptionElement: false, HTMLTableCellElement: false, HTMLTableColElement: false, HTMLTableElement: false, HTMLTableRowElement: false, HTMLTableSectionElement: false, HTMLTemplateElement: false, HTMLTextAreaElement: false, HTMLTimeElement: false, HTMLTitleElement: false, HTMLTrackElement: false, HTMLUListElement: false, HTMLUnknownElement: false, HTMLVideoElement: false, IDBCursor: false, IDBCursorWithValue: false, IDBDatabase: false, IDBFactory: false, IDBIndex: false, IDBKeyRange: false, IDBObjectStore: false, IDBOpenDBRequest: false, IDBRequest: false, IDBTransaction: false, IDBVersionChangeEvent: false, IdleDeadline: false, IIRFilterNode: false, Image: false, ImageBitmap: false, ImageBitmapRenderingContext: false, ImageCapture: false, ImageData: false, indexedDB: false, innerHeight: false, innerWidth: false, InputEvent: false, IntersectionObserver: false, IntersectionObserverEntry: false, "Intl": false, isSecureContext: false, KeyboardEvent: false, KeyframeEffect: false, KeyframeEffectReadOnly: false, length: false, localStorage: false, location: true, Location: false, locationbar: false, matchMedia: false, MediaDeviceInfo: false, MediaDevices: false, MediaElementAudioSourceNode: false, MediaEncryptedEvent: false, MediaError: false, MediaKeyMessageEvent: false, MediaKeySession: false, MediaKeyStatusMap: false, MediaKeySystemAccess: false, MediaList: false, MediaQueryList: false, MediaQueryListEvent: false, MediaRecorder: false, MediaSettingsRange: false, MediaSource: false, MediaStream: false, MediaStreamAudioDestinationNode: false, MediaStreamAudioSourceNode: false, MediaStreamEvent: false, MediaStreamTrack: false, MediaStreamTrackEvent: false, menubar: false, MessageChannel: false, MessageEvent: false, MessagePort: false, MIDIAccess: false, MIDIConnectionEvent: false, MIDIInput: false, MIDIInputMap: false, MIDIMessageEvent: false, MIDIOutput: false, MIDIOutputMap: false, MIDIPort: false, MimeType: false, MimeTypeArray: false, MouseEvent: false, moveBy: false, moveTo: false, MutationEvent: false, MutationObserver: false, MutationRecord: false, name: false, NamedNodeMap: false, NavigationPreloadManager: false, navigator: false, Navigator: false, NetworkInformation: false, Node: false, NodeFilter: false, NodeIterator: false, NodeList: false, Notification: false, OfflineAudioCompletionEvent: false, OfflineAudioContext: false, offscreenBuffering: false, OffscreenCanvas: true, OffscreenCanvasRenderingContext2D: false, onabort: true, onafterprint: true, onanimationend: true, onanimationiteration: true, onanimationstart: true, onappinstalled: true, onauxclick: true, onbeforeinstallprompt: true, onbeforeprint: true, onbeforeunload: true, onblur: true, oncancel: true, oncanplay: true, oncanplaythrough: true, onchange: true, onclick: true, onclose: true, oncontextmenu: true, oncuechange: true, ondblclick: true, ondevicemotion: true, ondeviceorientation: true, ondeviceorientationabsolute: true, ondrag: true, ondragend: true, ondragenter: true, ondragleave: true, ondragover: true, ondragstart: true, ondrop: true, ondurationchange: true, onemptied: true, onended: true, onerror: true, onfocus: true, ongotpointercapture: true, onhashchange: true, oninput: true, oninvalid: true, onkeydown: true, onkeypress: true, onkeyup: true, onlanguagechange: true, onload: true, onloadeddata: true, onloadedmetadata: true, onloadstart: true, onlostpointercapture: true, onmessage: true, onmessageerror: true, onmousedown: true, onmouseenter: true, onmouseleave: true, onmousemove: true, onmouseout: true, onmouseover: true, onmouseup: true, onmousewheel: true, onoffline: true, ononline: true, onpagehide: true, onpageshow: true, onpause: true, onplay: true, onplaying: true, onpointercancel: true, onpointerdown: true, onpointerenter: true, onpointerleave: true, onpointermove: true, onpointerout: true, onpointerover: true, onpointerup: true, onpopstate: true, onprogress: true, onratechange: true, onrejectionhandled: true, onreset: true, onresize: true, onscroll: true, onsearch: true, onseeked: true, onseeking: true, onselect: true, onstalled: true, onstorage: true, onsubmit: true, onsuspend: true, ontimeupdate: true, ontoggle: true, ontransitionend: true, onunhandledrejection: true, onunload: true, onvolumechange: true, onwaiting: true, onwheel: true, open: false, openDatabase: false, opener: false, Option: false, origin: false, OscillatorNode: false, outerHeight: false, outerWidth: false, OverconstrainedError: false, PageTransitionEvent: false, pageXOffset: false, pageYOffset: false, PannerNode: false, parent: false, Path2D: false, PaymentAddress: false, PaymentRequest: false, PaymentRequestUpdateEvent: false, PaymentResponse: false, performance: false, Performance: false, PerformanceEntry: false, PerformanceLongTaskTiming: false, PerformanceMark: false, PerformanceMeasure: false, PerformanceNavigation: false, PerformanceNavigationTiming: false, PerformanceObserver: false, PerformanceObserverEntryList: false, PerformancePaintTiming: false, PerformanceResourceTiming: false, PerformanceTiming: false, PeriodicWave: false, Permissions: false, PermissionStatus: false, personalbar: false, PhotoCapabilities: false, Plugin: false, PluginArray: false, PointerEvent: false, PopStateEvent: false, postMessage: false, Presentation: false, PresentationAvailability: false, PresentationConnection: false, PresentationConnectionAvailableEvent: false, PresentationConnectionCloseEvent: false, PresentationConnectionList: false, PresentationReceiver: false, PresentationRequest: false, print: false, ProcessingInstruction: false, ProgressEvent: false, PromiseRejectionEvent: false, prompt: false, PushManager: false, PushSubscription: false, PushSubscriptionOptions: false, queueMicrotask: false, RadioNodeList: false, Range: false, ReadableStream: false, registerProcessor: false, RemotePlayback: false, removeEventListener: false, Request: false, requestAnimationFrame: false, requestIdleCallback: false, resizeBy: false, ResizeObserver: false, ResizeObserverEntry: false, resizeTo: false, Response: false, RTCCertificate: false, RTCDataChannel: false, RTCDataChannelEvent: false, RTCDtlsTransport: false, RTCIceCandidate: false, RTCIceGatherer: false, RTCIceTransport: false, RTCPeerConnection: false, RTCPeerConnectionIceEvent: false, RTCRtpContributingSource: false, RTCRtpReceiver: false, RTCRtpSender: false, RTCSctpTransport: false, RTCSessionDescription: false, RTCStatsReport: false, RTCTrackEvent: false, screen: false, Screen: false, screenLeft: false, ScreenOrientation: false, screenTop: false, screenX: false, screenY: false, ScriptProcessorNode: false, scroll: false, scrollbars: false, scrollBy: false, scrollTo: false, scrollX: false, scrollY: false, SecurityPolicyViolationEvent: false, Selection: false, self: false, ServiceWorker: false, ServiceWorkerContainer: false, ServiceWorkerRegistration: false, sessionStorage: false, setInterval: false, setTimeout: false, ShadowRoot: false, SharedWorker: false, SourceBuffer: false, SourceBufferList: false, speechSynthesis: false, SpeechSynthesisEvent: false, SpeechSynthesisUtterance: false, StaticRange: false, status: false, statusbar: false, StereoPannerNode: false, stop: false, Storage: false, StorageEvent: false, StorageManager: false, styleMedia: false, StyleSheet: false, StyleSheetList: false, SubtleCrypto: false, SVGAElement: false, SVGAngle: false, SVGAnimatedAngle: false, SVGAnimatedBoolean: false, SVGAnimatedEnumeration: false, SVGAnimatedInteger: false, SVGAnimatedLength: false, SVGAnimatedLengthList: false, SVGAnimatedNumber: false, SVGAnimatedNumberList: false, SVGAnimatedPreserveAspectRatio: false, SVGAnimatedRect: false, SVGAnimatedString: false, SVGAnimatedTransformList: false, SVGAnimateElement: false, SVGAnimateMotionElement: false, SVGAnimateTransformElement: false, SVGAnimationElement: false, SVGCircleElement: false, SVGClipPathElement: false, SVGComponentTransferFunctionElement: false, SVGDefsElement: false, SVGDescElement: false, SVGDiscardElement: false, SVGElement: false, SVGEllipseElement: false, SVGFEBlendElement: false, SVGFEColorMatrixElement: false, SVGFEComponentTransferElement: false, SVGFECompositeElement: false, SVGFEConvolveMatrixElement: false, SVGFEDiffuseLightingElement: false, SVGFEDisplacementMapElement: false, SVGFEDistantLightElement: false, SVGFEDropShadowElement: false, SVGFEFloodElement: false, SVGFEFuncAElement: false, SVGFEFuncBElement: false, SVGFEFuncGElement: false, SVGFEFuncRElement: false, SVGFEGaussianBlurElement: false, SVGFEImageElement: false, SVGFEMergeElement: false, SVGFEMergeNodeElement: false, SVGFEMorphologyElement: false, SVGFEOffsetElement: false, SVGFEPointLightElement: false, SVGFESpecularLightingElement: false, SVGFESpotLightElement: false, SVGFETileElement: false, SVGFETurbulenceElement: false, SVGFilterElement: false, SVGForeignObjectElement: false, SVGGElement: false, SVGGeometryElement: false, SVGGradientElement: false, SVGGraphicsElement: false, SVGImageElement: false, SVGLength: false, SVGLengthList: false, SVGLinearGradientElement: false, SVGLineElement: false, SVGMarkerElement: false, SVGMaskElement: false, SVGMatrix: false, SVGMetadataElement: false, SVGMPathElement: false, SVGNumber: false, SVGNumberList: false, SVGPathElement: false, SVGPatternElement: false, SVGPoint: false, SVGPointList: false, SVGPolygonElement: false, SVGPolylineElement: false, SVGPreserveAspectRatio: false, SVGRadialGradientElement: false, SVGRect: false, SVGRectElement: false, SVGScriptElement: false, SVGSetElement: false, SVGStopElement: false, SVGStringList: false, SVGStyleElement: false, SVGSVGElement: false, SVGSwitchElement: false, SVGSymbolElement: false, SVGTextContentElement: false, SVGTextElement: false, SVGTextPathElement: false, SVGTextPositioningElement: false, SVGTitleElement: false, SVGTransform: false, SVGTransformList: false, SVGTSpanElement: false, SVGUnitTypes: false, SVGUseElement: false, SVGViewElement: false, TaskAttributionTiming: false, Text: false, TextDecoder: false, TextEncoder: false, TextEvent: false, TextMetrics: false, TextTrack: false, TextTrackCue: false, TextTrackCueList: false, TextTrackList: false, TimeRanges: false, toolbar: false, top: false, Touch: false, TouchEvent: false, TouchList: false, TrackEvent: false, TransitionEvent: false, TreeWalker: false, UIEvent: false, URL: false, URLSearchParams: false, ValidityState: false, visualViewport: false, VisualViewport: false, VTTCue: false, WaveShaperNode: false, WebAssembly: false, WebGL2RenderingContext: false, WebGLActiveInfo: false, WebGLBuffer: false, WebGLContextEvent: false, WebGLFramebuffer: false, WebGLProgram: false, WebGLQuery: false, WebGLRenderbuffer: false, WebGLRenderingContext: false, WebGLSampler: false, WebGLShader: false, WebGLShaderPrecisionFormat: false, WebGLSync: false, WebGLTexture: false, WebGLTransformFeedback: false, WebGLUniformLocation: false, WebGLVertexArrayObject: false, WebSocket: false, WheelEvent: false, window: false, Window: false, Worker: false, WritableStream: false, XMLDocument: false, XMLHttpRequest: false, XMLHttpRequestEventTarget: false, XMLHttpRequestUpload: false, XMLSerializer: false, XPathEvaluator: false, XPathExpression: false, XPathResult: false, XSLTProcessor: false};
        var worker = {addEventListener: false, applicationCache: false, atob: false, Blob: false, BroadcastChannel: false, btoa: false, Cache: false, caches: false, clearInterval: false, clearTimeout: false, close: true, console: false, fetch: false, FileReaderSync: false, FormData: false, Headers: false, IDBCursor: false, IDBCursorWithValue: false, IDBDatabase: false, IDBFactory: false, IDBIndex: false, IDBKeyRange: false, IDBObjectStore: false, IDBOpenDBRequest: false, IDBRequest: false, IDBTransaction: false, IDBVersionChangeEvent: false, ImageData: false, importScripts: true, indexedDB: false, location: false, MessageChannel: false, MessagePort: false, name: false, navigator: false, Notification: false, onclose: true, onconnect: true, onerror: true, onlanguagechange: true, onmessage: true, onoffline: true, ononline: true, onrejectionhandled: true, onunhandledrejection: true, performance: false, Performance: false, PerformanceEntry: false, PerformanceMark: false, PerformanceMeasure: false, PerformanceNavigation: false, PerformanceResourceTiming: false, PerformanceTiming: false, postMessage: true, "Promise": false, queueMicrotask: false, removeEventListener: false, Request: false, Response: false, self: true, ServiceWorkerRegistration: false, setInterval: false, setTimeout: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false, WebSocket: false, Worker: false, WorkerGlobalScope: false, XMLHttpRequest: false};
        var node = {__dirname: false, __filename: false, AbortController: false, Buffer: false, clearImmediate: false, clearInterval: false, clearTimeout: false, console: false, exports: true, global: false, "Intl": false, module: false, process: false, queueMicrotask: false, require: false, setImmediate: false, setInterval: false, setTimeout: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false};
        var nodeBuiltin = {AbortController: false, Buffer: false, clearImmediate: false, clearInterval: false, clearTimeout: false, console: false, global: false, "Intl": false, process: false, queueMicrotask: false, setImmediate: false, setInterval: false, setTimeout: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false};
        var commonjs = {exports: true, global: false, module: false, require: false};
        var amd = {define: false, require: false};
        var mocha = {after: false, afterEach: false, before: false, beforeEach: false, context: false, describe: false, it: false, mocha: false, run: false, setup: false, specify: false, suite: false, suiteSetup: false, suiteTeardown: false, teardown: false, test: false, xcontext: false, xdescribe: false, xit: false, xspecify: false};
        var jasmine = {afterAll: false, afterEach: false, beforeAll: false, beforeEach: false, describe: false, expect: false, expectAsync: false, fail: false, fdescribe: false, fit: false, it: false, jasmine: false, pending: false, runs: false, spyOn: false, spyOnAllFunctions: false, spyOnProperty: false, waits: false, waitsFor: false, xdescribe: false, xit: false};
        var jest = {afterAll: false, afterEach: false, beforeAll: false, beforeEach: false, describe: false, expect: false, fdescribe: false, fit: false, it: false, jest: false, pit: false, require: false, test: false, xdescribe: false, xit: false, xtest: false};
        var qunit = {asyncTest: false, deepEqual: false, equal: false, expect: false, module: false, notDeepEqual: false, notEqual: false, notOk: false, notPropEqual: false, notStrictEqual: false, ok: false, propEqual: false, QUnit: false, raises: false, start: false, stop: false, strictEqual: false, test: false, throws: false};
        var phantomjs = {console: true, exports: true, phantom: true, require: true, WebPage: true};
        var couch = {emit: false, exports: false, getRow: false, log: false, module: false, provides: false, require: false, respond: false, send: false, start: false, sum: false};
        var rhino = {defineClass: false, deserialize: false, gc: false, help: false, importClass: false, importPackage: false, java: false, load: false, loadClass: false, Packages: false, print: false, quit: false, readFile: false, readUrl: false, runCommand: false, seal: false, serialize: false, spawn: false, sync: false, toint32: false, version: false};
        var nashorn = {__DIR__: false, __FILE__: false, __LINE__: false, com: false, edu: false, exit: false, java: false, Java: false, javafx: false, JavaImporter: false, javax: false, JSAdapter: false, load: false, loadWithNewGlobal: false, org: false, Packages: false, print: false, quit: false};
        var wsh = {ActiveXObject: false, CollectGarbage: false, Debug: false, Enumerator: false, GetObject: false, RuntimeObject: false, ScriptEngine: false, ScriptEngineBuildVersion: false, ScriptEngineMajorVersion: false, ScriptEngineMinorVersion: false, VBArray: false, WScript: false, WSH: false};
        var jquery = {$: false, jQuery: false};
        var yui = {YAHOO: false, YAHOO_config: false, YUI: false, YUI_config: false};
        var shelljs = {cat: false, cd: false, chmod: false, config: false, cp: false, dirs: false, echo: false, env: false, error: false, exec: false, exit: false, find: false, grep: false, ln: false, ls: false, mkdir: false, mv: false, popd: false, pushd: false, pwd: false, rm: false, sed: false, set: false, target: false, tempdir: false, test: false, touch: false, which: false};
        var prototypejs = {$: false, $$: false, $A: false, $break: false, $continue: false, $F: false, $H: false, $R: false, $w: false, Abstract: false, Ajax: false, Autocompleter: false, Builder: false, Class: false, Control: false, Draggable: false, Draggables: false, Droppables: false, Effect: false, Element: false, Enumerable: false, Event: false, Field: false, Form: false, Hash: false, Insertion: false, ObjectRange: false, PeriodicalExecuter: false, Position: false, Prototype: false, Scriptaculous: false, Selector: false, Sortable: false, SortableObserver: false, Sound: false, Template: false, Toggle: false, Try: false};
        var meteor = {$: false, Accounts: false, AccountsClient: false, AccountsCommon: false, AccountsServer: false, App: false, Assets: false, Blaze: false, check: false, Cordova: false, DDP: false, DDPRateLimiter: false, DDPServer: false, Deps: false, EJSON: false, Email: false, HTTP: false, Log: false, Match: false, Meteor: false, Mongo: false, MongoInternals: false, Npm: false, Package: false, Plugin: false, process: false, Random: false, ReactiveDict: false, ReactiveVar: false, Router: false, ServiceConfiguration: false, Session: false, share: false, Spacebars: false, Template: false, Tinytest: false, Tracker: false, UI: false, Utils: false, WebApp: false, WebAppInternals: false};
        var mongo = {_isWindows: false, _rand: false, BulkWriteResult: false, cat: false, cd: false, connect: false, db: false, getHostName: false, getMemInfo: false, hostname: false, ISODate: false, listFiles: false, load: false, ls: false, md5sumFile: false, mkdir: false, Mongo: false, NumberInt: false, NumberLong: false, ObjectId: false, PlanCache: false, print: false, printjson: false, pwd: false, quit: false, removeFile: false, rs: false, sh: false, UUID: false, version: false, WriteResult: false};
        var applescript = {$: false, Application: false, Automation: false, console: false, delay: false, Library: false, ObjC: false, ObjectSpecifier: false, Path: false, Progress: false, Ref: false};
        var serviceworker = {addEventListener: false, applicationCache: false, atob: false, Blob: false, BroadcastChannel: false, btoa: false, Cache: false, caches: false, CacheStorage: false, clearInterval: false, clearTimeout: false, Client: false, clients: false, Clients: false, close: true, console: false, ExtendableEvent: false, ExtendableMessageEvent: false, fetch: false, FetchEvent: false, FileReaderSync: false, FormData: false, Headers: false, IDBCursor: false, IDBCursorWithValue: false, IDBDatabase: false, IDBFactory: false, IDBIndex: false, IDBKeyRange: false, IDBObjectStore: false, IDBOpenDBRequest: false, IDBRequest: false, IDBTransaction: false, IDBVersionChangeEvent: false, ImageData: false, importScripts: false, indexedDB: false, location: false, MessageChannel: false, MessagePort: false, name: false, navigator: false, Notification: false, onclose: true, onconnect: true, onerror: true, onfetch: true, oninstall: true, onlanguagechange: true, onmessage: true, onmessageerror: true, onnotificationclick: true, onnotificationclose: true, onoffline: true, ononline: true, onpush: true, onpushsubscriptionchange: true, onrejectionhandled: true, onsync: true, onunhandledrejection: true, performance: false, Performance: false, PerformanceEntry: false, PerformanceMark: false, PerformanceMeasure: false, PerformanceNavigation: false, PerformanceResourceTiming: false, PerformanceTiming: false, postMessage: true, "Promise": false, queueMicrotask: false, registration: false, removeEventListener: false, Request: false, Response: false, self: false, ServiceWorker: false, ServiceWorkerContainer: false, ServiceWorkerGlobalScope: false, ServiceWorkerMessageEvent: false, ServiceWorkerRegistration: false, setInterval: false, setTimeout: false, skipWaiting: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false, WebSocket: false, WindowClient: false, Worker: false, WorkerGlobalScope: false, XMLHttpRequest: false};
        var atomtest = {advanceClock: false, atom: false, fakeClearInterval: false, fakeClearTimeout: false, fakeSetInterval: false, fakeSetTimeout: false, resetTimeouts: false, waitsForPromise: false};
        var embertest = {andThen: false, click: false, currentPath: false, currentRouteName: false, currentURL: false, fillIn: false, find: false, findAll: false, findWithAssert: false, keyEvent: false, pauseTest: false, resumeTest: false, triggerEvent: false, visit: false, wait: false};
        var protractor = {$: false, $$: false, browser: false, by: false, By: false, DartObject: false, element: false, protractor: false};
        var webextensions = {browser: false, chrome: false, opr: false};
        var greasemonkey = {cloneInto: false, createObjectIn: false, exportFunction: false, GM: false, GM_addStyle: false, GM_addValueChangeListener: false, GM_deleteValue: false, GM_download: false, GM_getResourceText: false, GM_getResourceURL: false, GM_getTab: false, GM_getTabs: false, GM_getValue: false, GM_info: false, GM_listValues: false, GM_log: false, GM_notification: false, GM_openInTab: false, GM_registerMenuCommand: false, GM_removeValueChangeListener: false, GM_saveTab: false, GM_setClipboard: false, GM_setValue: false, GM_unregisterMenuCommand: false, GM_xmlhttpRequest: false, unsafeWindow: false};
        var devtools = {$: false, $_: false, $$: false, $0: false, $1: false, $2: false, $3: false, $4: false, $x: false, chrome: false, clear: false, copy: false, debug: false, dir: false, dirxml: false, getEventListeners: false, inspect: false, keys: false, monitor: false, monitorEvents: false, profile: false, profileEnd: false, queryObjects: false, table: false, undebug: false, unmonitor: false, unmonitorEvents: false, values: false};
        var require$$03 = {builtin, es5, es2015, es2017, es2020, es2021, browser, worker, node, nodeBuiltin, commonjs, amd, mocha, jasmine, jest, qunit, phantomjs, couch, rhino, nashorn, wsh, jquery, yui, shelljs, prototypejs, meteor, mongo, applescript, serviceworker, atomtest, embertest, protractor, "shared-node-browser": {clearInterval: false, clearTimeout: false, console: false, setInterval: false, setTimeout: false, URL: false, URLSearchParams: false}, webextensions, greasemonkey, devtools};
        var globals2 = require$$03;
        const browserAPIs = ["window", "document", "console"];
        const builtinAPIs = Object.keys(globals2.builtin);
        const isIdentifier = (n2) => namedTypes.Identifier.check(n2);
        const isLiteral = (n2) => namedTypes.Literal.check(n2);
        const isExpressionStatement = (n2) => namedTypes.ExpressionStatement.check(n2);
        const isThisExpression = (n2) => namedTypes.ThisExpression.check(n2);
        const isThisExpressionStatement = (n2) => isExpressionStatement(n2) && isMemberExpression(n2.expression.left) && isThisExpression(n2.expression.left.object);
        const isNewExpression = (n2) => namedTypes.NewExpression.check(n2);
        const isSequenceExpression = (n2) => namedTypes.SequenceExpression.check(n2);
        const isExportDefaultStatement = (n2) => namedTypes.ExportDefaultDeclaration.check(n2);
        const isMemberExpression = (n2) => namedTypes.MemberExpression.check(n2);
        const isImportDeclaration = (n2) => namedTypes.ImportDeclaration.check(n2);
        const isBrowserAPI = (_ref) => {
          let {name} = _ref;
          return browserAPIs.includes(name);
        };
        const isBuiltinAPI = (_ref2) => {
          let {name} = _ref2;
          return builtinAPIs.includes(name);
        };
        const isRaw = (n2) => n2 && n2.raw;
        const LINES_RE = /\r\n?|\n/g;
        function splitStringByEOL(string) {
          return string.split(LINES_RE);
        }
        function getLineAndColumnByPosition(string, position) {
          const lines2 = splitStringByEOL(string.slice(0, position));
          return {line: lines2.length, column: lines2[lines2.length - 1].length};
        }
        function addLineOffset(input, source, node2) {
          const {column, line} = getLineAndColumnByPosition(source, node2.start);
          return `${"\n".repeat(line - 1)}${" ".repeat(column + 1)}${input}`;
        }
        function getBabelOptions(options2) {
          return {sourceType: util$2.getOption(options2, "sourceType", "module"), strictMode: util$2.getOption(options2, "strictMode", false), allowImportExportEverywhere: true, allowReturnOutsideFunction: true, startLine: 1, tokens: true, plugins: ["asyncGenerators", "bigInt", "classPrivateMethods", "classPrivateProperties", "classProperties", "decorators-legacy", "doExpressions", "dynamicImport", "exportDefaultFrom", "exportExtensions", "exportNamespaceFrom", "functionBind", "functionSent", "importMeta", "nullishCoalescingOperator", "numericSeparator", "objectRestSpread", "optionalCatchBinding", "optionalChaining", ["pipelineOperator", {proposal: "minimal"}], "throwExpressions"]};
        }
        var _default = getBabelOptions;
        var _babel_options = /* @__PURE__ */ Object.defineProperty({default: _default}, "__esModule", {value: true});
        const beforeExpr = true;
        const startsExpr = true;
        const isLoop = true;
        const isAssign = true;
        const prefix = true;
        const postfix = true;
        class TokenType {
          constructor(label, conf) {
            if (conf === void 0) {
              conf = {};
            }
            this.label = void 0;
            this.keyword = void 0;
            this.beforeExpr = void 0;
            this.startsExpr = void 0;
            this.rightAssociative = void 0;
            this.isLoop = void 0;
            this.isAssign = void 0;
            this.prefix = void 0;
            this.postfix = void 0;
            this.binop = void 0;
            this.updateContext = void 0;
            this.label = label;
            this.keyword = conf.keyword;
            this.beforeExpr = !!conf.beforeExpr;
            this.startsExpr = !!conf.startsExpr;
            this.rightAssociative = !!conf.rightAssociative;
            this.isLoop = !!conf.isLoop;
            this.isAssign = !!conf.isAssign;
            this.prefix = !!conf.prefix;
            this.postfix = !!conf.postfix;
            this.binop = conf.binop != null ? conf.binop : null;
            this.updateContext = null;
          }
        }
        const keywords = new Map();
        function createKeyword(name, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          options2.keyword = name;
          const token = new TokenType(name, options2);
          keywords.set(name, token);
          return token;
        }
        function createBinop(name, binop) {
          return new TokenType(name, {beforeExpr, binop});
        }
        const types$1 = {num: new TokenType("num", {startsExpr}), bigint: new TokenType("bigint", {startsExpr}), decimal: new TokenType("decimal", {startsExpr}), regexp: new TokenType("regexp", {startsExpr}), string: new TokenType("string", {startsExpr}), name: new TokenType("name", {startsExpr}), eof: new TokenType("eof"), bracketL: new TokenType("[", {beforeExpr, startsExpr}), bracketHashL: new TokenType("#[", {beforeExpr, startsExpr}), bracketBarL: new TokenType("[|", {beforeExpr, startsExpr}), bracketR: new TokenType("]"), bracketBarR: new TokenType("|]"), braceL: new TokenType("{", {beforeExpr, startsExpr}), braceBarL: new TokenType("{|", {beforeExpr, startsExpr}), braceHashL: new TokenType("#{", {beforeExpr, startsExpr}), braceR: new TokenType("}"), braceBarR: new TokenType("|}"), parenL: new TokenType("(", {beforeExpr, startsExpr}), parenR: new TokenType(")"), comma: new TokenType(",", {beforeExpr}), semi: new TokenType(";", {beforeExpr}), colon: new TokenType(":", {beforeExpr}), doubleColon: new TokenType("::", {beforeExpr}), dot: new TokenType("."), question: new TokenType("?", {beforeExpr}), questionDot: new TokenType("?."), arrow: new TokenType("=>", {beforeExpr}), template: new TokenType("template"), ellipsis: new TokenType("...", {beforeExpr}), backQuote: new TokenType("`", {startsExpr}), dollarBraceL: new TokenType("${", {beforeExpr, startsExpr}), at: new TokenType("@"), hash: new TokenType("#", {startsExpr}), interpreterDirective: new TokenType("#!..."), eq: new TokenType("=", {beforeExpr, isAssign}), assign: new TokenType("_=", {beforeExpr, isAssign}), incDec: new TokenType("++/--", {prefix, postfix, startsExpr}), bang: new TokenType("!", {beforeExpr, prefix, startsExpr}), tilde: new TokenType("~", {beforeExpr, prefix, startsExpr}), pipeline: createBinop("|>", 0), nullishCoalescing: createBinop("??", 1), logicalOR: createBinop("||", 1), logicalAND: createBinop("&&", 2), bitwiseOR: createBinop("|", 3), bitwiseXOR: createBinop("^", 4), bitwiseAND: createBinop("&", 5), equality: createBinop("==/!=/===/!==", 6), relational: createBinop("</>/<=/>=", 7), bitShift: createBinop("<</>>/>>>", 8), plusMin: new TokenType("+/-", {beforeExpr, binop: 9, prefix, startsExpr}), modulo: new TokenType("%", {beforeExpr, binop: 10, startsExpr}), star: new TokenType("*", {binop: 10}), slash: createBinop("/", 10), exponent: new TokenType("**", {beforeExpr, binop: 11, rightAssociative: true}), _break: createKeyword("break"), _case: createKeyword("case", {beforeExpr}), _catch: createKeyword("catch"), _continue: createKeyword("continue"), _debugger: createKeyword("debugger"), _default: createKeyword("default", {beforeExpr}), _do: createKeyword("do", {isLoop, beforeExpr}), _else: createKeyword("else", {beforeExpr}), _finally: createKeyword("finally"), _for: createKeyword("for", {isLoop}), _function: createKeyword("function", {startsExpr}), _if: createKeyword("if"), _return: createKeyword("return", {beforeExpr}), _switch: createKeyword("switch"), _throw: createKeyword("throw", {beforeExpr, prefix, startsExpr}), _try: createKeyword("try"), _var: createKeyword("var"), _const: createKeyword("const"), _while: createKeyword("while", {isLoop}), _with: createKeyword("with"), _new: createKeyword("new", {beforeExpr, startsExpr}), _this: createKeyword("this", {startsExpr}), _super: createKeyword("super", {startsExpr}), _class: createKeyword("class", {startsExpr}), _extends: createKeyword("extends", {beforeExpr}), _export: createKeyword("export"), _import: createKeyword("import", {startsExpr}), _null: createKeyword("null", {startsExpr}), _true: createKeyword("true", {startsExpr}), _false: createKeyword("false", {startsExpr}), _in: createKeyword("in", {beforeExpr, binop: 7}), _instanceof: createKeyword("instanceof", {beforeExpr, binop: 7}), _typeof: createKeyword("typeof", {beforeExpr, prefix, startsExpr}), _void: createKeyword("void", {beforeExpr, prefix, startsExpr}), _delete: createKeyword("delete", {beforeExpr, prefix, startsExpr})};
        const lineBreak = /\r\n?|[\n\u2028\u2029]/;
        const lineBreakG = new RegExp(lineBreak.source, "g");
        function isNewLine(code) {
          switch (code) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        function isWhitespace(code) {
          switch (code) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        class Position {
          constructor(line, col) {
            this.line = void 0;
            this.column = void 0;
            this.line = line;
            this.column = col;
          }
        }
        class SourceLocation {
          constructor(start, end) {
            this.start = void 0;
            this.end = void 0;
            this.filename = void 0;
            this.identifierName = void 0;
            this.start = start;
            this.end = end;
          }
        }
        function getLineInfo(input, offset) {
          let line = 1;
          let lineStart = 0;
          let match;
          lineBreakG.lastIndex = 0;
          while ((match = lineBreakG.exec(input)) && match.index < offset) {
            line++;
            lineStart = lineBreakG.lastIndex;
          }
          return new Position(line, offset - lineStart);
        }
        class BaseParser {
          constructor() {
            this.sawUnambiguousESM = false;
            this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(name) {
            return this.plugins.has(name);
          }
          getPluginOption(plugin, name) {
            if (this.hasPlugin(plugin))
              return this.plugins.get(plugin)[name];
          }
        }
        function last(stack) {
          return stack[stack.length - 1];
        }
        class CommentsParser extends BaseParser {
          addComment(comment2) {
            if (this.filename)
              comment2.loc.filename = this.filename;
            this.state.trailingComments.push(comment2);
            this.state.leadingComments.push(comment2);
          }
          adjustCommentsAfterTrailingComma(node2, elements, takeAllComments) {
            if (this.state.leadingComments.length === 0) {
              return;
            }
            let lastElement = null;
            let i = elements.length;
            while (lastElement === null && i > 0) {
              lastElement = elements[--i];
            }
            if (lastElement === null) {
              return;
            }
            for (let j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
            const newTrailingComments = [];
            for (let i2 = 0; i2 < this.state.leadingComments.length; i2++) {
              const leadingComment = this.state.leadingComments[i2];
              if (leadingComment.end < node2.end) {
                newTrailingComments.push(leadingComment);
                if (!takeAllComments) {
                  this.state.leadingComments.splice(i2, 1);
                  i2--;
                }
              } else {
                if (node2.trailingComments === void 0) {
                  node2.trailingComments = [];
                }
                node2.trailingComments.push(leadingComment);
              }
            }
            if (takeAllComments)
              this.state.leadingComments = [];
            if (newTrailingComments.length > 0) {
              lastElement.trailingComments = newTrailingComments;
            } else if (lastElement.trailingComments !== void 0) {
              lastElement.trailingComments = [];
            }
          }
          processComment(node2) {
            if (node2.type === "Program" && node2.body.length > 0)
              return;
            const stack = this.state.commentStack;
            let firstChild, lastChild, trailingComments, i, j;
            if (this.state.trailingComments.length > 0) {
              if (this.state.trailingComments[0].start >= node2.end) {
                trailingComments = this.state.trailingComments;
                this.state.trailingComments = [];
              } else {
                this.state.trailingComments.length = 0;
              }
            } else if (stack.length > 0) {
              const lastInStack = last(stack);
              if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node2.end) {
                trailingComments = lastInStack.trailingComments;
                delete lastInStack.trailingComments;
              }
            }
            if (stack.length > 0 && last(stack).start >= node2.start) {
              firstChild = stack.pop();
            }
            while (stack.length > 0 && last(stack).start >= node2.start) {
              lastChild = stack.pop();
            }
            if (!lastChild && firstChild)
              lastChild = firstChild;
            if (firstChild) {
              switch (node2.type) {
                case "ObjectExpression":
                  this.adjustCommentsAfterTrailingComma(node2, node2.properties);
                  break;
                case "ObjectPattern":
                  this.adjustCommentsAfterTrailingComma(node2, node2.properties, true);
                  break;
                case "CallExpression":
                  this.adjustCommentsAfterTrailingComma(node2, node2.arguments);
                  break;
                case "ArrayExpression":
                  this.adjustCommentsAfterTrailingComma(node2, node2.elements);
                  break;
                case "ArrayPattern":
                  this.adjustCommentsAfterTrailingComma(node2, node2.elements, true);
                  break;
              }
            } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node2.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node2.type !== "ExportSpecifier")) {
              this.adjustCommentsAfterTrailingComma(node2, [this.state.commentPreviousNode]);
            }
            if (lastChild) {
              if (lastChild.leadingComments) {
                if (lastChild !== node2 && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node2.start) {
                  node2.leadingComments = lastChild.leadingComments;
                  delete lastChild.leadingComments;
                } else {
                  for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
                    if (lastChild.leadingComments[i].end <= node2.start) {
                      node2.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                      break;
                    }
                  }
                }
              }
            } else if (this.state.leadingComments.length > 0) {
              if (last(this.state.leadingComments).end <= node2.start) {
                if (this.state.commentPreviousNode) {
                  for (j = 0; j < this.state.leadingComments.length; j++) {
                    if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                      this.state.leadingComments.splice(j, 1);
                      j--;
                    }
                  }
                }
                if (this.state.leadingComments.length > 0) {
                  node2.leadingComments = this.state.leadingComments;
                  this.state.leadingComments = [];
                }
              } else {
                for (i = 0; i < this.state.leadingComments.length; i++) {
                  if (this.state.leadingComments[i].end > node2.start) {
                    break;
                  }
                }
                const leadingComments = this.state.leadingComments.slice(0, i);
                if (leadingComments.length) {
                  node2.leadingComments = leadingComments;
                }
                trailingComments = this.state.leadingComments.slice(i);
                if (trailingComments.length === 0) {
                  trailingComments = null;
                }
              }
            }
            this.state.commentPreviousNode = node2;
            if (trailingComments) {
              if (trailingComments.length && trailingComments[0].start >= node2.start && last(trailingComments).end <= node2.end) {
                node2.innerComments = trailingComments;
              } else {
                const firstTrailingCommentIndex = trailingComments.findIndex((comment2) => comment2.end >= node2.end);
                if (firstTrailingCommentIndex > 0) {
                  node2.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);
                  node2.trailingComments = trailingComments.slice(firstTrailingCommentIndex);
                } else {
                  node2.trailingComments = trailingComments;
                }
              }
            }
            stack.push(node2);
          }
        }
        const ErrorCodes = Object.freeze({SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"});
        const ErrorMessages = makeErrorTemplates({AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.", PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."}, ErrorCodes.SyntaxError);
        const SourceTypeModuleErrorMessages = makeErrorTemplates({ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`}, ErrorCodes.SourceTypeModuleError);
        function makeErrorTemplates(messages, code) {
          const templates = {};
          Object.keys(messages).forEach((reasonCode) => {
            templates[reasonCode] = Object.freeze({code, reasonCode, template: messages[reasonCode]});
          });
          return Object.freeze(templates);
        }
        class ParserError extends CommentsParser {
          getLocationForPosition(pos) {
            let loc;
            if (pos === this.state.start)
              loc = this.state.startLoc;
            else if (pos === this.state.lastTokStart)
              loc = this.state.lastTokStartLoc;
            else if (pos === this.state.end)
              loc = this.state.endLoc;
            else if (pos === this.state.lastTokEnd)
              loc = this.state.lastTokEndLoc;
            else
              loc = getLineInfo(this.input, pos);
            return loc;
          }
          raise(pos, _ref3) {
            let {code, reasonCode, template: template2} = _ref3;
            for (var _len4 = arguments.length, params = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
              params[_key4 - 2] = arguments[_key4];
            }
            return this.raiseWithData(pos, {code, reasonCode}, template2, ...params);
          }
          raiseOverwrite(pos, _ref4) {
            let {code, template: template2} = _ref4;
            for (var _len5 = arguments.length, params = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
              params[_key5 - 2] = arguments[_key5];
            }
            const loc = this.getLocationForPosition(pos);
            const message = template2.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
            if (this.options.errorRecovery) {
              const errors = this.state.errors;
              for (let i = errors.length - 1; i >= 0; i--) {
                const error = errors[i];
                if (error.pos === pos) {
                  return Object.assign(error, {message});
                } else if (error.pos < pos) {
                  break;
                }
              }
            }
            return this._raise({code, loc, pos}, message);
          }
          raiseWithData(pos, data, errorTemplate) {
            for (var _len6 = arguments.length, params = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {
              params[_key6 - 3] = arguments[_key6];
            }
            const loc = this.getLocationForPosition(pos);
            const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
            return this._raise(Object.assign({loc, pos}, data), message);
          }
          _raise(errorContext, message) {
            const err = new SyntaxError(message);
            Object.assign(err, errorContext);
            if (this.options.errorRecovery) {
              if (!this.isLookahead)
                this.state.errors.push(err);
              return err;
            } else {
              throw err;
            }
          }
        }
        var estree = (superClass) => class extends superClass {
          estreeParseRegExpLiteral(_ref5) {
            let {pattern, flags} = _ref5;
            let regex2 = null;
            try {
              regex2 = new RegExp(pattern, flags);
            } catch (e) {
            }
            const node2 = this.estreeParseLiteral(regex2);
            node2.regex = {pattern, flags};
            return node2;
          }
          estreeParseBigIntLiteral(value) {
            let bigInt;
            try {
              bigInt = BigInt(value);
            } catch (_unused) {
              bigInt = null;
            }
            const node2 = this.estreeParseLiteral(bigInt);
            node2.bigint = String(node2.value || value);
            return node2;
          }
          estreeParseDecimalLiteral(value) {
            const decimal = null;
            const node2 = this.estreeParseLiteral(decimal);
            node2.decimal = String(node2.value || value);
            return node2;
          }
          estreeParseLiteral(value) {
            return this.parseLiteral(value, "Literal");
          }
          directiveToStmt(directive) {
            const directiveLiteral = directive.value;
            const stmt = this.startNodeAt(directive.start, directive.loc.start);
            const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
            expression.value = directiveLiteral.extra.expressionValue;
            expression.raw = directiveLiteral.extra.raw;
            stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
            stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
            return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
          }
          initFunction(node2, isAsync) {
            super.initFunction(node2, isAsync);
            node2.expression = false;
          }
          checkDeclaration(node2) {
            if (node2 != null && this.isObjectProperty(node2)) {
              this.checkDeclaration(node2.value);
            } else {
              super.checkDeclaration(node2);
            }
          }
          getObjectOrClassMethodParams(method) {
            return method.value.params;
          }
          isValidDirective(stmt) {
            var _stmt$expression$extr;
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
          }
          stmtToDirective(stmt) {
            const directive = super.stmtToDirective(stmt);
            const value = stmt.expression.value;
            this.addExtra(directive.value, "expressionValue", value);
            return directive;
          }
          parseBlockBody(node2) {
            for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
              args[_key7 - 1] = arguments[_key7];
            }
            super.parseBlockBody(node2, ...args);
            const directiveStatements = node2.directives.map((d) => this.directiveToStmt(d));
            node2.body = directiveStatements.concat(node2.body);
            delete node2.directives;
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
            if (method.typeParameters) {
              method.value.typeParameters = method.typeParameters;
              delete method.typeParameters;
            }
            classBody.body.push(method);
          }
          parseExprAtom(refExpressionErrors) {
            switch (this.state.type) {
              case types$1.num:
              case types$1.string:
                return this.estreeParseLiteral(this.state.value);
              case types$1.regexp:
                return this.estreeParseRegExpLiteral(this.state.value);
              case types$1.bigint:
                return this.estreeParseBigIntLiteral(this.state.value);
              case types$1.decimal:
                return this.estreeParseDecimalLiteral(this.state.value);
              case types$1._null:
                return this.estreeParseLiteral(null);
              case types$1._true:
                return this.estreeParseLiteral(true);
              case types$1._false:
                return this.estreeParseLiteral(false);
              default:
                return super.parseExprAtom(refExpressionErrors);
            }
          }
          parseMaybePrivateName() {
            const node2 = super.parseMaybePrivateName(...arguments);
            if (node2.type === "PrivateName" && this.getPluginOption("estree", "classFeatures")) {
              return this.convertPrivateNameToPrivateIdentifier(node2);
            }
            return node2;
          }
          convertPrivateNameToPrivateIdentifier(node2) {
            const name = super.getPrivateNameSV(node2);
            node2 = node2;
            delete node2.id;
            node2.name = name;
            node2.type = "PrivateIdentifier";
            return node2;
          }
          isPrivateName(node2) {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.isPrivateName(node2);
            }
            return node2.type === "PrivateIdentifier";
          }
          getPrivateNameSV(node2) {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.getPrivateNameSV(node2);
            }
            return node2.name;
          }
          parseLiteral(value, type2, startPos, startLoc) {
            const node2 = super.parseLiteral(value, type2, startPos, startLoc);
            node2.raw = node2.extra.raw;
            delete node2.extra;
            return node2;
          }
          parseFunctionBody(node2, allowExpression, isMethod) {
            if (isMethod === void 0) {
              isMethod = false;
            }
            super.parseFunctionBody(node2, allowExpression, isMethod);
            node2.expression = node2.body.type !== "BlockStatement";
          }
          parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope) {
            if (inClassScope === void 0) {
              inClassScope = false;
            }
            let funcNode = this.startNode();
            funcNode.kind = node2.kind;
            funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope);
            funcNode.type = "FunctionExpression";
            delete funcNode.kind;
            node2.value = funcNode;
            if (type2 === "ClassPrivateMethod") {
              node2.computed = false;
            }
            type2 = "MethodDefinition";
            return this.finishNode(node2, type2);
          }
          parseClassProperty() {
            const propertyNode = super.parseClassProperty(...arguments);
            if (this.getPluginOption("estree", "classFeatures")) {
              propertyNode.type = "PropertyDefinition";
            }
            return propertyNode;
          }
          parseClassPrivateProperty() {
            const propertyNode = super.parseClassPrivateProperty(...arguments);
            if (this.getPluginOption("estree", "classFeatures")) {
              propertyNode.type = "PropertyDefinition";
              propertyNode.computed = false;
            }
            return propertyNode;
          }
          parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor) {
            const node2 = super.parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor);
            if (node2) {
              node2.type = "Property";
              if (node2.kind === "method")
                node2.kind = "init";
              node2.shorthand = false;
            }
            return node2;
          }
          parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors) {
            const node2 = super.parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors);
            if (node2) {
              node2.kind = "init";
              node2.type = "Property";
            }
            return node2;
          }
          toAssignable(node2, isLHS) {
            if (isLHS === void 0) {
              isLHS = false;
            }
            if (node2 != null && this.isObjectProperty(node2)) {
              this.toAssignable(node2.value, isLHS);
              return node2;
            }
            return super.toAssignable(node2, isLHS);
          }
          toAssignableObjectExpressionProp(prop2) {
            if (prop2.kind === "get" || prop2.kind === "set") {
              this.raise(prop2.key.start, ErrorMessages.PatternHasAccessor);
            } else if (prop2.method) {
              this.raise(prop2.key.start, ErrorMessages.PatternHasMethod);
            } else {
              for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
                args[_key8 - 1] = arguments[_key8];
              }
              super.toAssignableObjectExpressionProp(prop2, ...args);
            }
          }
          finishCallExpression(node2, optional) {
            super.finishCallExpression(node2, optional);
            if (node2.callee.type === "Import") {
              node2.type = "ImportExpression";
              node2.source = node2.arguments[0];
              delete node2.arguments;
              delete node2.callee;
            }
            return node2;
          }
          toReferencedArguments(node2) {
            if (node2.type === "ImportExpression") {
              return;
            }
            super.toReferencedArguments(node2);
          }
          parseExport(node2) {
            super.parseExport(node2);
            switch (node2.type) {
              case "ExportAllDeclaration":
                node2.exported = null;
                break;
              case "ExportNamedDeclaration":
                if (node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier") {
                  node2.type = "ExportAllDeclaration";
                  node2.exported = node2.specifiers[0].exported;
                  delete node2.specifiers;
                }
                break;
            }
            return node2;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            const node2 = super.parseSubscript(base, startPos, startLoc, noCalls, state);
            if (state.optionalChainMember) {
              if (node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression") {
                node2.type = node2.type.substring(8);
              }
              if (state.stop) {
                const chain = this.startNodeAtNode(node2);
                chain.expression = node2;
                return this.finishNode(chain, "ChainExpression");
              }
            } else if (node2.type === "MemberExpression" || node2.type === "CallExpression") {
              node2.optional = false;
            }
            return node2;
          }
          hasPropertyAsPrivateName(node2) {
            if (node2.type === "ChainExpression") {
              node2 = node2.expression;
            }
            return super.hasPropertyAsPrivateName(node2);
          }
          isOptionalChain(node2) {
            return node2.type === "ChainExpression";
          }
          isObjectProperty(node2) {
            return node2.type === "Property" && node2.kind === "init" && !node2.method;
          }
          isObjectMethod(node2) {
            return node2.method || node2.kind === "get" || node2.kind === "set";
          }
        };
        class TokContext {
          constructor(token, isExpr, preserveSpace, override) {
            this.token = void 0;
            this.isExpr = void 0;
            this.preserveSpace = void 0;
            this.override = void 0;
            this.token = token;
            this.isExpr = !!isExpr;
            this.preserveSpace = !!preserveSpace;
            this.override = override;
          }
        }
        const types$1$1 = {braceStatement: new TokContext("{", false), braceExpression: new TokContext("{", true), recordExpression: new TokContext("#{", true), templateQuasi: new TokContext("${", false), parenStatement: new TokContext("(", false), parenExpression: new TokContext("(", true), template: new TokContext("`", true, true, (p) => p.readTmplToken()), functionExpression: new TokContext("function", true), functionStatement: new TokContext("function", false)};
        types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
          if (this.state.context.length === 1) {
            this.state.exprAllowed = true;
            return;
          }
          let out = this.state.context.pop();
          if (out === types$1$1.braceStatement && this.curContext().token === "function") {
            out = this.state.context.pop();
          }
          this.state.exprAllowed = !out.isExpr;
        };
        types$1.name.updateContext = function(prevType) {
          let allowed = false;
          if (prevType !== types$1.dot) {
            if (this.state.value === "of" && !this.state.exprAllowed && prevType !== types$1._function && prevType !== types$1._class) {
              allowed = true;
            }
          }
          this.state.exprAllowed = allowed;
          if (this.state.isIterator) {
            this.state.isIterator = false;
          }
        };
        types$1.braceL.updateContext = function(prevType) {
          this.state.context.push(this.braceIsBlock(prevType) ? types$1$1.braceStatement : types$1$1.braceExpression);
          this.state.exprAllowed = true;
        };
        types$1.dollarBraceL.updateContext = function() {
          this.state.context.push(types$1$1.templateQuasi);
          this.state.exprAllowed = true;
        };
        types$1.parenL.updateContext = function(prevType) {
          const statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
          this.state.context.push(statementParens ? types$1$1.parenStatement : types$1$1.parenExpression);
          this.state.exprAllowed = true;
        };
        types$1.incDec.updateContext = function() {
        };
        types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
          if (prevType.beforeExpr && prevType !== types$1.semi && prevType !== types$1._else && !(prevType === types$1._return && this.hasPrecedingLineBreak()) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types$1$1.b_stat)) {
            this.state.context.push(types$1$1.functionExpression);
          } else {
            this.state.context.push(types$1$1.functionStatement);
          }
          this.state.exprAllowed = false;
        };
        types$1.backQuote.updateContext = function() {
          if (this.curContext() === types$1$1.template) {
            this.state.context.pop();
          } else {
            this.state.context.push(types$1$1.template);
          }
          this.state.exprAllowed = false;
        };
        types$1.braceHashL.updateContext = function() {
          this.state.context.push(types$1$1.recordExpression);
          this.state.exprAllowed = true;
        };
        let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
        let nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
        const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
        const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(code, set2) {
          let pos = 65536;
          for (let i = 0, length = set2.length; i < length; i += 2) {
            pos += set2[i];
            if (pos > code)
              return false;
            pos += set2[i + 1];
            if (pos >= code)
              return true;
          }
          return false;
        }
        function isIdentifierStart(code) {
          if (code < 65)
            return code === 36;
          if (code <= 90)
            return true;
          if (code < 97)
            return code === 95;
          if (code <= 122)
            return true;
          if (code <= 65535) {
            return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
          }
          return isInAstralSet(code, astralIdentifierStartCodes);
        }
        function isIdentifierChar(code) {
          if (code < 48)
            return code === 36;
          if (code < 58)
            return true;
          if (code < 65)
            return false;
          if (code <= 90)
            return true;
          if (code < 97)
            return code === 95;
          if (code <= 122)
            return true;
          if (code <= 65535) {
            return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
          }
          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
        }
        const reservedWords = {keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"]};
        const keywords$1 = new Set(reservedWords.keyword);
        const reservedWordsStrictSet = new Set(reservedWords.strict);
        const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
        function isReservedWord(word, inModule) {
          return inModule && word === "await" || word === "enum";
        }
        function isStrictReservedWord(word, inModule) {
          return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
        }
        function isStrictBindOnlyReservedWord(word) {
          return reservedWordsStrictBindSet.has(word);
        }
        function isStrictBindReservedWord(word, inModule) {
          return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
        }
        function isKeyword(word) {
          return keywords$1.has(word);
        }
        const keywordRelationalOperator = /^in(stanceof)?$/;
        function isIteratorStart(current, next) {
          return current === 64 && next === 64;
        }
        const SCOPE_OTHER = 0, SCOPE_PROGRAM = 1, SCOPE_FUNCTION = 2, SCOPE_ARROW = 4, SCOPE_SIMPLE_CATCH = 8, SCOPE_SUPER = 16, SCOPE_DIRECT_SUPER = 32, SCOPE_CLASS = 64, SCOPE_STATIC_BLOCK = 128, SCOPE_TS_MODULE = 256, SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
        const BIND_KIND_VALUE = 1, BIND_KIND_TYPE = 2, BIND_SCOPE_VAR = 4, BIND_SCOPE_LEXICAL = 8, BIND_SCOPE_FUNCTION = 16, BIND_FLAGS_NONE = 64, BIND_FLAGS_CLASS = 128, BIND_FLAGS_TS_ENUM = 256, BIND_FLAGS_TS_CONST_ENUM = 512, BIND_FLAGS_TS_EXPORT_ONLY = 1024, BIND_FLAGS_FLOW_DECLARE_FN = 2048;
        const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS, BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0, BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0, BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0, BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS, BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0, BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM, BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE, BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE, BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM, BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
        const CLASS_ELEMENT_FLAG_STATIC = 4, CLASS_ELEMENT_KIND_GETTER = 2, CLASS_ELEMENT_KIND_SETTER = 1, CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
        const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER, CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER, CLASS_ELEMENT_OTHER = 0;
        class Scope {
          constructor(flags) {
            this.flags = void 0;
            this.var = [];
            this.lexical = [];
            this.functions = [];
            this.flags = flags;
          }
        }
        class ScopeHandler {
          constructor(raise, inModule) {
            this.scopeStack = [];
            this.undefinedExports = new Map();
            this.undefinedPrivateNames = new Map();
            this.raise = raise;
            this.inModule = inModule;
          }
          get inFunction() {
            return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
          }
          get allowSuper() {
            return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
          }
          get allowDirectSuper() {
            return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
          }
          get inClass() {
            return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
          }
          get inStaticBlock() {
            return (this.currentThisScope().flags & SCOPE_STATIC_BLOCK) > 0;
          }
          get inNonArrowFunction() {
            return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(flags) {
            return new Scope(flags);
          }
          enter(flags) {
            this.scopeStack.push(this.createScope(flags));
          }
          exit() {
            this.scopeStack.pop();
          }
          treatFunctionsAsVarInScope(scope2) {
            return !!(scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_PROGRAM);
          }
          declareName(name, bindingType, pos) {
            let scope2 = this.currentScope();
            if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
              this.checkRedeclarationInScope(scope2, name, bindingType, pos);
              if (bindingType & BIND_SCOPE_FUNCTION) {
                scope2.functions.push(name);
              } else {
                scope2.lexical.push(name);
              }
              if (bindingType & BIND_SCOPE_LEXICAL) {
                this.maybeExportDefined(scope2, name);
              }
            } else if (bindingType & BIND_SCOPE_VAR) {
              for (let i = this.scopeStack.length - 1; i >= 0; --i) {
                scope2 = this.scopeStack[i];
                this.checkRedeclarationInScope(scope2, name, bindingType, pos);
                scope2.var.push(name);
                this.maybeExportDefined(scope2, name);
                if (scope2.flags & SCOPE_VAR)
                  break;
              }
            }
            if (this.inModule && scope2.flags & SCOPE_PROGRAM) {
              this.undefinedExports.delete(name);
            }
          }
          maybeExportDefined(scope2, name) {
            if (this.inModule && scope2.flags & SCOPE_PROGRAM) {
              this.undefinedExports.delete(name);
            }
          }
          checkRedeclarationInScope(scope2, name, bindingType, pos) {
            if (this.isRedeclaredInScope(scope2, name, bindingType)) {
              this.raise(pos, ErrorMessages.VarRedeclaration, name);
            }
          }
          isRedeclaredInScope(scope2, name, bindingType) {
            if (!(bindingType & BIND_KIND_VALUE))
              return false;
            if (bindingType & BIND_SCOPE_LEXICAL) {
              return scope2.lexical.indexOf(name) > -1 || scope2.functions.indexOf(name) > -1 || scope2.var.indexOf(name) > -1;
            }
            if (bindingType & BIND_SCOPE_FUNCTION) {
              return scope2.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope2) && scope2.var.indexOf(name) > -1;
            }
            return scope2.lexical.indexOf(name) > -1 && !(scope2.flags & SCOPE_SIMPLE_CATCH && scope2.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope2) && scope2.functions.indexOf(name) > -1;
          }
          checkLocalExport(id) {
            if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
              this.undefinedExports.set(id.name, id.start);
            }
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScope() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const scope2 = this.scopeStack[i];
              if (scope2.flags & SCOPE_VAR) {
                return scope2;
              }
            }
          }
          currentThisScope() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const scope2 = this.scopeStack[i];
              if ((scope2.flags & SCOPE_VAR || scope2.flags & SCOPE_CLASS) && !(scope2.flags & SCOPE_ARROW)) {
                return scope2;
              }
            }
          }
        }
        class FlowScope extends Scope {
          constructor() {
            super(...arguments);
            this.declareFunctions = [];
          }
        }
        class FlowScopeHandler extends ScopeHandler {
          createScope(flags) {
            return new FlowScope(flags);
          }
          declareName(name, bindingType, pos) {
            const scope2 = this.currentScope();
            if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
              this.checkRedeclarationInScope(scope2, name, bindingType, pos);
              this.maybeExportDefined(scope2, name);
              scope2.declareFunctions.push(name);
              return;
            }
            super.declareName(...arguments);
          }
          isRedeclaredInScope(scope2, name, bindingType) {
            if (super.isRedeclaredInScope(...arguments))
              return true;
            if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
              return !scope2.declareFunctions.includes(name) && (scope2.lexical.includes(name) || scope2.functions.includes(name));
            }
            return false;
          }
          checkLocalExport(id) {
            if (this.scopeStack[0].declareFunctions.indexOf(id.name) === -1) {
              super.checkLocalExport(id);
            }
          }
        }
        const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
        const FlowErrors = makeErrorTemplates({AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment."}, ErrorCodes.SyntaxError);
        function isEsModuleType(bodyElement) {
          return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
        }
        function hasTypeImportKind(node2) {
          return node2.importKind === "type" || node2.importKind === "typeof";
        }
        function isMaybeDefaultImport(state) {
          return (state.type === types$1.name || !!state.type.keyword) && state.value !== "from";
        }
        const exportSuggestions = {const: "declare export var", let: "declare export var", type: "export type", interface: "export interface"};
        function partition(list, test) {
          const list1 = [];
          const list2 = [];
          for (let i = 0; i < list.length; i++) {
            (test(list[i], i, list) ? list1 : list2).push(list[i]);
          }
          return [list1, list2];
        }
        const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
        var flow = (superClass) => class extends superClass {
          constructor() {
            super(...arguments);
            this.flowPragma = void 0;
          }
          getScopeHandler() {
            return FlowScopeHandler;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(type2, val) {
            if (type2 !== types$1.string && type2 !== types$1.semi && type2 !== types$1.interpreterDirective) {
              if (this.flowPragma === void 0) {
                this.flowPragma = null;
              }
            }
            return super.finishToken(type2, val);
          }
          addComment(comment2) {
            if (this.flowPragma === void 0) {
              const matches2 = FLOW_PRAGMA_REGEX.exec(comment2.value);
              if (!matches2)
                ;
              else if (matches2[1] === "flow") {
                this.flowPragma = "flow";
              } else if (matches2[1] === "noflow") {
                this.flowPragma = "noflow";
              } else {
                throw new Error("Unexpected flow pragma");
              }
            }
            return super.addComment(comment2);
          }
          flowParseTypeInitialiser(tok) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            this.expect(tok || types$1.colon);
            const type2 = this.flowParseType();
            this.state.inType = oldInType;
            return type2;
          }
          flowParsePredicate() {
            const node2 = this.startNode();
            const moduloPos = this.state.start;
            this.next();
            this.expectContextual("checks");
            if (this.state.lastTokStart > moduloPos + 1) {
              this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
            }
            if (this.eat(types$1.parenL)) {
              node2.value = this.parseExpression();
              this.expect(types$1.parenR);
              return this.finishNode(node2, "DeclaredPredicate");
            } else {
              return this.finishNode(node2, "InferredPredicate");
            }
          }
          flowParseTypeAndPredicateInitialiser() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            this.expect(types$1.colon);
            let type2 = null;
            let predicate = null;
            if (this.match(types$1.modulo)) {
              this.state.inType = oldInType;
              predicate = this.flowParsePredicate();
            } else {
              type2 = this.flowParseType();
              this.state.inType = oldInType;
              if (this.match(types$1.modulo)) {
                predicate = this.flowParsePredicate();
              }
            }
            return [type2, predicate];
          }
          flowParseDeclareClass(node2) {
            this.next();
            this.flowParseInterfaceish(node2, true);
            return this.finishNode(node2, "DeclareClass");
          }
          flowParseDeclareFunction(node2) {
            this.next();
            const id = node2.id = this.parseIdentifier();
            const typeNode = this.startNode();
            const typeContainer = this.startNode();
            if (this.isRelational("<")) {
              typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              typeNode.typeParameters = null;
            }
            this.expect(types$1.parenL);
            const tmp = this.flowParseFunctionTypeParams();
            typeNode.params = tmp.params;
            typeNode.rest = tmp.rest;
            typeNode.this = tmp._this;
            this.expect(types$1.parenR);
            [typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
            typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
            id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
            this.resetEndLocation(id);
            this.semicolon();
            this.scope.declareName(node2.id.name, BIND_FLOW_DECLARE_FN, node2.id.start);
            return this.finishNode(node2, "DeclareFunction");
          }
          flowParseDeclare(node2, insideModule) {
            if (this.match(types$1._class)) {
              return this.flowParseDeclareClass(node2);
            } else if (this.match(types$1._function)) {
              return this.flowParseDeclareFunction(node2);
            } else if (this.match(types$1._var)) {
              return this.flowParseDeclareVariable(node2);
            } else if (this.eatContextual("module")) {
              if (this.match(types$1.dot)) {
                return this.flowParseDeclareModuleExports(node2);
              } else {
                if (insideModule) {
                  this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
                }
                return this.flowParseDeclareModule(node2);
              }
            } else if (this.isContextual("type")) {
              return this.flowParseDeclareTypeAlias(node2);
            } else if (this.isContextual("opaque")) {
              return this.flowParseDeclareOpaqueType(node2);
            } else if (this.isContextual("interface")) {
              return this.flowParseDeclareInterface(node2);
            } else if (this.match(types$1._export)) {
              return this.flowParseDeclareExportDeclaration(node2, insideModule);
            } else {
              throw this.unexpected();
            }
          }
          flowParseDeclareVariable(node2) {
            this.next();
            node2.id = this.flowParseTypeAnnotatableIdentifier(true);
            this.scope.declareName(node2.id.name, BIND_VAR, node2.id.start);
            this.semicolon();
            return this.finishNode(node2, "DeclareVariable");
          }
          flowParseDeclareModule(node2) {
            this.scope.enter(SCOPE_OTHER);
            if (this.match(types$1.string)) {
              node2.id = this.parseExprAtom();
            } else {
              node2.id = this.parseIdentifier();
            }
            const bodyNode = node2.body = this.startNode();
            const body = bodyNode.body = [];
            this.expect(types$1.braceL);
            while (!this.match(types$1.braceR)) {
              let bodyNode2 = this.startNode();
              if (this.match(types$1._import)) {
                this.next();
                if (!this.isContextual("type") && !this.match(types$1._typeof)) {
                  this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
                }
                this.parseImport(bodyNode2);
              } else {
                this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
                bodyNode2 = this.flowParseDeclare(bodyNode2, true);
              }
              body.push(bodyNode2);
            }
            this.scope.exit();
            this.expect(types$1.braceR);
            this.finishNode(bodyNode, "BlockStatement");
            let kind = null;
            let hasModuleExport = false;
            body.forEach((bodyElement) => {
              if (isEsModuleType(bodyElement)) {
                if (kind === "CommonJS") {
                  this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
                }
                kind = "ES";
              } else if (bodyElement.type === "DeclareModuleExports") {
                if (hasModuleExport) {
                  this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
                }
                if (kind === "ES") {
                  this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
                }
                kind = "CommonJS";
                hasModuleExport = true;
              }
            });
            node2.kind = kind || "CommonJS";
            return this.finishNode(node2, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(node2, insideModule) {
            this.expect(types$1._export);
            if (this.eat(types$1._default)) {
              if (this.match(types$1._function) || this.match(types$1._class)) {
                node2.declaration = this.flowParseDeclare(this.startNode());
              } else {
                node2.declaration = this.flowParseType();
                this.semicolon();
              }
              node2.default = true;
              return this.finishNode(node2, "DeclareExportDeclaration");
            } else {
              if (this.match(types$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
                const label = this.state.value;
                const suggestion = exportSuggestions[label];
                throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
              }
              if (this.match(types$1._var) || this.match(types$1._function) || this.match(types$1._class) || this.isContextual("opaque")) {
                node2.declaration = this.flowParseDeclare(this.startNode());
                node2.default = false;
                return this.finishNode(node2, "DeclareExportDeclaration");
              } else if (this.match(types$1.star) || this.match(types$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
                node2 = this.parseExport(node2);
                if (node2.type === "ExportNamedDeclaration") {
                  node2.type = "ExportDeclaration";
                  node2.default = false;
                  delete node2.exportKind;
                }
                node2.type = "Declare" + node2.type;
                return node2;
              }
            }
            throw this.unexpected();
          }
          flowParseDeclareModuleExports(node2) {
            this.next();
            this.expectContextual("exports");
            node2.typeAnnotation = this.flowParseTypeAnnotation();
            this.semicolon();
            return this.finishNode(node2, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(node2) {
            this.next();
            this.flowParseTypeAlias(node2);
            node2.type = "DeclareTypeAlias";
            return node2;
          }
          flowParseDeclareOpaqueType(node2) {
            this.next();
            this.flowParseOpaqueType(node2, true);
            node2.type = "DeclareOpaqueType";
            return node2;
          }
          flowParseDeclareInterface(node2) {
            this.next();
            this.flowParseInterfaceish(node2);
            return this.finishNode(node2, "DeclareInterface");
          }
          flowParseInterfaceish(node2, isClass) {
            if (isClass === void 0) {
              isClass = false;
            }
            node2.id = this.flowParseRestrictedIdentifier(!isClass, true);
            this.scope.declareName(node2.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node2.id.start);
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              node2.typeParameters = null;
            }
            node2.extends = [];
            node2.implements = [];
            node2.mixins = [];
            if (this.eat(types$1._extends)) {
              do {
                node2.extends.push(this.flowParseInterfaceExtends());
              } while (!isClass && this.eat(types$1.comma));
            }
            if (this.isContextual("mixins")) {
              this.next();
              do {
                node2.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(types$1.comma));
            }
            if (this.isContextual("implements")) {
              this.next();
              do {
                node2.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(types$1.comma));
            }
            node2.body = this.flowParseObjectType({allowStatic: isClass, allowExact: false, allowSpread: false, allowProto: isClass, allowInexact: false});
          }
          flowParseInterfaceExtends() {
            const node2 = this.startNode();
            node2.id = this.flowParseQualifiedTypeIdentifier();
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            return this.finishNode(node2, "InterfaceExtends");
          }
          flowParseInterface(node2) {
            this.flowParseInterfaceish(node2);
            return this.finishNode(node2, "InterfaceDeclaration");
          }
          checkNotUnderscore(word) {
            if (word === "_") {
              this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
            }
          }
          checkReservedType(word, startLoc, declaration) {
            if (!reservedTypes.has(word))
              return;
            this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
          }
          flowParseRestrictedIdentifier(liberal, declaration) {
            this.checkReservedType(this.state.value, this.state.start, declaration);
            return this.parseIdentifier(liberal);
          }
          flowParseTypeAlias(node2) {
            node2.id = this.flowParseRestrictedIdentifier(false, true);
            this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.start);
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              node2.typeParameters = null;
            }
            node2.right = this.flowParseTypeInitialiser(types$1.eq);
            this.semicolon();
            return this.finishNode(node2, "TypeAlias");
          }
          flowParseOpaqueType(node2, declare) {
            this.expectContextual("type");
            node2.id = this.flowParseRestrictedIdentifier(true, true);
            this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.start);
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              node2.typeParameters = null;
            }
            node2.supertype = null;
            if (this.match(types$1.colon)) {
              node2.supertype = this.flowParseTypeInitialiser(types$1.colon);
            }
            node2.impltype = null;
            if (!declare) {
              node2.impltype = this.flowParseTypeInitialiser(types$1.eq);
            }
            this.semicolon();
            return this.finishNode(node2, "OpaqueType");
          }
          flowParseTypeParameter(requireDefault) {
            if (requireDefault === void 0) {
              requireDefault = false;
            }
            const nodeStart = this.state.start;
            const node2 = this.startNode();
            const variance = this.flowParseVariance();
            const ident = this.flowParseTypeAnnotatableIdentifier();
            node2.name = ident.name;
            node2.variance = variance;
            node2.bound = ident.typeAnnotation;
            if (this.match(types$1.eq)) {
              this.eat(types$1.eq);
              node2.default = this.flowParseType();
            } else {
              if (requireDefault) {
                this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
              }
            }
            return this.finishNode(node2, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const oldInType = this.state.inType;
            const node2 = this.startNode();
            node2.params = [];
            this.state.inType = true;
            if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
              this.next();
            } else {
              this.unexpected();
            }
            let defaultRequired = false;
            do {
              const typeParameter = this.flowParseTypeParameter(defaultRequired);
              node2.params.push(typeParameter);
              if (typeParameter.default) {
                defaultRequired = true;
              }
              if (!this.isRelational(">")) {
                this.expect(types$1.comma);
              }
            } while (!this.isRelational(">"));
            this.expectRelational(">");
            this.state.inType = oldInType;
            return this.finishNode(node2, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const node2 = this.startNode();
            const oldInType = this.state.inType;
            node2.params = [];
            this.state.inType = true;
            this.expectRelational("<");
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = false;
            while (!this.isRelational(">")) {
              node2.params.push(this.flowParseType());
              if (!this.isRelational(">")) {
                this.expect(types$1.comma);
              }
            }
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            this.expectRelational(">");
            this.state.inType = oldInType;
            return this.finishNode(node2, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const node2 = this.startNode();
            const oldInType = this.state.inType;
            node2.params = [];
            this.state.inType = true;
            this.expectRelational("<");
            while (!this.isRelational(">")) {
              node2.params.push(this.flowParseTypeOrImplicitInstantiation());
              if (!this.isRelational(">")) {
                this.expect(types$1.comma);
              }
            }
            this.expectRelational(">");
            this.state.inType = oldInType;
            return this.finishNode(node2, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const node2 = this.startNode();
            this.expectContextual("interface");
            node2.extends = [];
            if (this.eat(types$1._extends)) {
              do {
                node2.extends.push(this.flowParseInterfaceExtends());
              } while (this.eat(types$1.comma));
            }
            node2.body = this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false});
            return this.finishNode(node2, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(types$1.num) || this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(node2, isStatic, variance) {
            node2.static = isStatic;
            if (this.lookahead().type === types$1.colon) {
              node2.id = this.flowParseObjectPropertyKey();
              node2.key = this.flowParseTypeInitialiser();
            } else {
              node2.id = null;
              node2.key = this.flowParseType();
            }
            this.expect(types$1.bracketR);
            node2.value = this.flowParseTypeInitialiser();
            node2.variance = variance;
            return this.finishNode(node2, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(node2, isStatic) {
            node2.static = isStatic;
            node2.id = this.flowParseObjectPropertyKey();
            this.expect(types$1.bracketR);
            this.expect(types$1.bracketR);
            if (this.isRelational("<") || this.match(types$1.parenL)) {
              node2.method = true;
              node2.optional = false;
              node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start));
            } else {
              node2.method = false;
              if (this.eat(types$1.question)) {
                node2.optional = true;
              }
              node2.value = this.flowParseTypeInitialiser();
            }
            return this.finishNode(node2, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(node2) {
            node2.params = [];
            node2.rest = null;
            node2.typeParameters = null;
            node2.this = null;
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            this.expect(types$1.parenL);
            if (this.match(types$1._this)) {
              node2.this = this.flowParseFunctionTypeParam(true);
              node2.this.name = null;
              if (!this.match(types$1.parenR)) {
                this.expect(types$1.comma);
              }
            }
            while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
              node2.params.push(this.flowParseFunctionTypeParam(false));
              if (!this.match(types$1.parenR)) {
                this.expect(types$1.comma);
              }
            }
            if (this.eat(types$1.ellipsis)) {
              node2.rest = this.flowParseFunctionTypeParam(false);
            }
            this.expect(types$1.parenR);
            node2.returnType = this.flowParseTypeInitialiser();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(node2, isStatic) {
            const valueNode = this.startNode();
            node2.static = isStatic;
            node2.value = this.flowParseObjectTypeMethodish(valueNode);
            return this.finishNode(node2, "ObjectTypeCallProperty");
          }
          flowParseObjectType(_ref6) {
            let {allowStatic, allowExact, allowSpread, allowProto, allowInexact} = _ref6;
            const oldInType = this.state.inType;
            this.state.inType = true;
            const nodeStart = this.startNode();
            nodeStart.callProperties = [];
            nodeStart.properties = [];
            nodeStart.indexers = [];
            nodeStart.internalSlots = [];
            let endDelim;
            let exact;
            let inexact = false;
            if (allowExact && this.match(types$1.braceBarL)) {
              this.expect(types$1.braceBarL);
              endDelim = types$1.braceBarR;
              exact = true;
            } else {
              this.expect(types$1.braceL);
              endDelim = types$1.braceR;
              exact = false;
            }
            nodeStart.exact = exact;
            while (!this.match(endDelim)) {
              let isStatic = false;
              let protoStart = null;
              let inexactStart = null;
              const node2 = this.startNode();
              if (allowProto && this.isContextual("proto")) {
                const lookahead = this.lookahead();
                if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
                  this.next();
                  protoStart = this.state.start;
                  allowStatic = false;
                }
              }
              if (allowStatic && this.isContextual("static")) {
                const lookahead = this.lookahead();
                if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
                  this.next();
                  isStatic = true;
                }
              }
              const variance = this.flowParseVariance();
              if (this.eat(types$1.bracketL)) {
                if (protoStart != null) {
                  this.unexpected(protoStart);
                }
                if (this.eat(types$1.bracketL)) {
                  if (variance) {
                    this.unexpected(variance.start);
                  }
                  nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic));
                } else {
                  nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic, variance));
                }
              } else if (this.match(types$1.parenL) || this.isRelational("<")) {
                if (protoStart != null) {
                  this.unexpected(protoStart);
                }
                if (variance) {
                  this.unexpected(variance.start);
                }
                nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic));
              } else {
                let kind = "init";
                if (this.isContextual("get") || this.isContextual("set")) {
                  const lookahead = this.lookahead();
                  if (lookahead.type === types$1.name || lookahead.type === types$1.string || lookahead.type === types$1.num) {
                    kind = this.state.value;
                    this.next();
                  }
                }
                const propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
                if (propOrInexact === null) {
                  inexact = true;
                  inexactStart = this.state.lastTokStart;
                } else {
                  nodeStart.properties.push(propOrInexact);
                }
              }
              this.flowObjectTypeSemicolon();
              if (inexactStart && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
                this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
              }
            }
            this.expect(endDelim);
            if (allowSpread) {
              nodeStart.inexact = inexact;
            }
            const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
            this.state.inType = oldInType;
            return out;
          }
          flowParseObjectTypeProperty(node2, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
            if (this.eat(types$1.ellipsis)) {
              const isInexactToken = this.match(types$1.comma) || this.match(types$1.semi) || this.match(types$1.braceR) || this.match(types$1.braceBarR);
              if (isInexactToken) {
                if (!allowSpread) {
                  this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
                } else if (!allowInexact) {
                  this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
                }
                if (variance) {
                  this.raise(variance.start, FlowErrors.InexactVariance);
                }
                return null;
              }
              if (!allowSpread) {
                this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
              }
              if (protoStart != null) {
                this.unexpected(protoStart);
              }
              if (variance) {
                this.raise(variance.start, FlowErrors.SpreadVariance);
              }
              node2.argument = this.flowParseType();
              return this.finishNode(node2, "ObjectTypeSpreadProperty");
            } else {
              node2.key = this.flowParseObjectPropertyKey();
              node2.static = isStatic;
              node2.proto = protoStart != null;
              node2.kind = kind;
              let optional = false;
              if (this.isRelational("<") || this.match(types$1.parenL)) {
                node2.method = true;
                if (protoStart != null) {
                  this.unexpected(protoStart);
                }
                if (variance) {
                  this.unexpected(variance.start);
                }
                node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start));
                if (kind === "get" || kind === "set") {
                  this.flowCheckGetterSetterParams(node2);
                }
                if (!allowSpread && node2.key.name === "constructor" && node2.value.this) {
                  this.raise(node2.value.this.start, FlowErrors.ThisParamBannedInConstructor);
                }
              } else {
                if (kind !== "init")
                  this.unexpected();
                node2.method = false;
                if (this.eat(types$1.question)) {
                  optional = true;
                }
                node2.value = this.flowParseTypeInitialiser();
                node2.variance = variance;
              }
              node2.optional = optional;
              return this.finishNode(node2, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(property) {
            const paramCount = property.kind === "get" ? 0 : 1;
            const start = property.start;
            const length = property.value.params.length + (property.value.rest ? 1 : 0);
            if (property.value.this) {
              this.raise(property.value.this.start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
            }
            if (length !== paramCount) {
              if (property.kind === "get") {
                this.raise(start, ErrorMessages.BadGetterArity);
              } else {
                this.raise(start, ErrorMessages.BadSetterArity);
              }
            }
            if (property.kind === "set" && property.value.rest) {
              this.raise(start, ErrorMessages.BadSetterRestParameter);
            }
          }
          flowObjectTypeSemicolon() {
            if (!this.eat(types$1.semi) && !this.eat(types$1.comma) && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
              this.unexpected();
            }
          }
          flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
            startPos = startPos || this.state.start;
            startLoc = startLoc || this.state.startLoc;
            let node2 = id || this.flowParseRestrictedIdentifier(true);
            while (this.eat(types$1.dot)) {
              const node22 = this.startNodeAt(startPos, startLoc);
              node22.qualification = node2;
              node22.id = this.flowParseRestrictedIdentifier(true);
              node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
            }
            return node2;
          }
          flowParseGenericType(startPos, startLoc, id) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.typeParameters = null;
            node2.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            }
            return this.finishNode(node2, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const node2 = this.startNode();
            this.expect(types$1._typeof);
            node2.argument = this.flowParsePrimaryType();
            return this.finishNode(node2, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const node2 = this.startNode();
            node2.types = [];
            this.expect(types$1.bracketL);
            while (this.state.pos < this.length && !this.match(types$1.bracketR)) {
              node2.types.push(this.flowParseType());
              if (this.match(types$1.bracketR))
                break;
              this.expect(types$1.comma);
            }
            this.expect(types$1.bracketR);
            return this.finishNode(node2, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(first) {
            let name = null;
            let optional = false;
            let typeAnnotation = null;
            const node2 = this.startNode();
            const lh = this.lookahead();
            const isThis = this.state.type === types$1._this;
            if (lh.type === types$1.colon || lh.type === types$1.question) {
              if (isThis && !first) {
                this.raise(node2.start, FlowErrors.ThisParamMustBeFirst);
              }
              name = this.parseIdentifier(isThis);
              if (this.eat(types$1.question)) {
                optional = true;
                if (isThis) {
                  this.raise(node2.start, FlowErrors.ThisParamMayNotBeOptional);
                }
              }
              typeAnnotation = this.flowParseTypeInitialiser();
            } else {
              typeAnnotation = this.flowParseType();
            }
            node2.name = name;
            node2.optional = optional;
            node2.typeAnnotation = typeAnnotation;
            return this.finishNode(node2, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(type2) {
            const node2 = this.startNodeAt(type2.start, type2.loc.start);
            node2.name = null;
            node2.optional = false;
            node2.typeAnnotation = type2;
            return this.finishNode(node2, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(params) {
            if (params === void 0) {
              params = [];
            }
            let rest = null;
            let _this = null;
            if (this.match(types$1._this)) {
              _this = this.flowParseFunctionTypeParam(true);
              _this.name = null;
              if (!this.match(types$1.parenR)) {
                this.expect(types$1.comma);
              }
            }
            while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
              params.push(this.flowParseFunctionTypeParam(false));
              if (!this.match(types$1.parenR)) {
                this.expect(types$1.comma);
              }
            }
            if (this.eat(types$1.ellipsis)) {
              rest = this.flowParseFunctionTypeParam(false);
            }
            return {params, rest, _this};
          }
          flowIdentToTypeAnnotation(startPos, startLoc, node2, id) {
            switch (id.name) {
              case "any":
                return this.finishNode(node2, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(node2, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(node2, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(node2, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(node2, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(node2, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(node2, "SymbolTypeAnnotation");
              default:
                this.checkNotUnderscore(id.name);
                return this.flowParseGenericType(startPos, startLoc, id);
            }
          }
          flowParsePrimaryType() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const node2 = this.startNode();
            let tmp;
            let type2;
            let isGroupedType = false;
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case types$1.name:
                if (this.isContextual("interface")) {
                  return this.flowParseInterfaceType();
                }
                return this.flowIdentToTypeAnnotation(startPos, startLoc, node2, this.parseIdentifier());
              case types$1.braceL:
                return this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true});
              case types$1.braceBarL:
                return this.flowParseObjectType({allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false});
              case types$1.bracketL:
                this.state.noAnonFunctionType = false;
                type2 = this.flowParseTupleType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                return type2;
              case types$1.relational:
                if (this.state.value === "<") {
                  node2.typeParameters = this.flowParseTypeParameterDeclaration();
                  this.expect(types$1.parenL);
                  tmp = this.flowParseFunctionTypeParams();
                  node2.params = tmp.params;
                  node2.rest = tmp.rest;
                  node2.this = tmp._this;
                  this.expect(types$1.parenR);
                  this.expect(types$1.arrow);
                  node2.returnType = this.flowParseType();
                  return this.finishNode(node2, "FunctionTypeAnnotation");
                }
                break;
              case types$1.parenL:
                this.next();
                if (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
                  if (this.match(types$1.name) || this.match(types$1._this)) {
                    const token = this.lookahead().type;
                    isGroupedType = token !== types$1.question && token !== types$1.colon;
                  } else {
                    isGroupedType = true;
                  }
                }
                if (isGroupedType) {
                  this.state.noAnonFunctionType = false;
                  type2 = this.flowParseType();
                  this.state.noAnonFunctionType = oldNoAnonFunctionType;
                  if (this.state.noAnonFunctionType || !(this.match(types$1.comma) || this.match(types$1.parenR) && this.lookahead().type === types$1.arrow)) {
                    this.expect(types$1.parenR);
                    return type2;
                  } else {
                    this.eat(types$1.comma);
                  }
                }
                if (type2) {
                  tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type2)]);
                } else {
                  tmp = this.flowParseFunctionTypeParams();
                }
                node2.params = tmp.params;
                node2.rest = tmp.rest;
                node2.this = tmp._this;
                this.expect(types$1.parenR);
                this.expect(types$1.arrow);
                node2.returnType = this.flowParseType();
                node2.typeParameters = null;
                return this.finishNode(node2, "FunctionTypeAnnotation");
              case types$1.string:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case types$1._true:
              case types$1._false:
                node2.value = this.match(types$1._true);
                this.next();
                return this.finishNode(node2, "BooleanLiteralTypeAnnotation");
              case types$1.plusMin:
                if (this.state.value === "-") {
                  this.next();
                  if (this.match(types$1.num)) {
                    return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node2.start, node2.loc.start);
                  }
                  if (this.match(types$1.bigint)) {
                    return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node2.start, node2.loc.start);
                  }
                  throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
                }
                throw this.unexpected();
              case types$1.num:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case types$1.bigint:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case types$1._void:
                this.next();
                return this.finishNode(node2, "VoidTypeAnnotation");
              case types$1._null:
                this.next();
                return this.finishNode(node2, "NullLiteralTypeAnnotation");
              case types$1._this:
                this.next();
                return this.finishNode(node2, "ThisTypeAnnotation");
              case types$1.star:
                this.next();
                return this.finishNode(node2, "ExistsTypeAnnotation");
              default:
                if (this.state.type.keyword === "typeof") {
                  return this.flowParseTypeofType();
                } else if (this.state.type.keyword) {
                  const label = this.state.type.label;
                  this.next();
                  return super.createIdentifier(node2, label);
                }
            }
            throw this.unexpected();
          }
          flowParsePostfixType() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let type2 = this.flowParsePrimaryType();
            let seenOptionalIndexedAccess = false;
            while ((this.match(types$1.bracketL) || this.match(types$1.questionDot)) && !this.canInsertSemicolon()) {
              const node2 = this.startNodeAt(startPos, startLoc);
              const optional = this.eat(types$1.questionDot);
              seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
              this.expect(types$1.bracketL);
              if (!optional && this.match(types$1.bracketR)) {
                node2.elementType = type2;
                this.next();
                type2 = this.finishNode(node2, "ArrayTypeAnnotation");
              } else {
                node2.objectType = type2;
                node2.indexType = this.flowParseType();
                this.expect(types$1.bracketR);
                if (seenOptionalIndexedAccess) {
                  node2.optional = optional;
                  type2 = this.finishNode(node2, "OptionalIndexedAccessType");
                } else {
                  type2 = this.finishNode(node2, "IndexedAccessType");
                }
              }
            }
            return type2;
          }
          flowParsePrefixType() {
            const node2 = this.startNode();
            if (this.eat(types$1.question)) {
              node2.typeAnnotation = this.flowParsePrefixType();
              return this.finishNode(node2, "NullableTypeAnnotation");
            } else {
              return this.flowParsePostfixType();
            }
          }
          flowParseAnonFunctionWithoutParens() {
            const param = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(types$1.arrow)) {
              const node2 = this.startNodeAt(param.start, param.loc.start);
              node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
              node2.rest = null;
              node2.this = null;
              node2.returnType = this.flowParseType();
              node2.typeParameters = null;
              return this.finishNode(node2, "FunctionTypeAnnotation");
            }
            return param;
          }
          flowParseIntersectionType() {
            const node2 = this.startNode();
            this.eat(types$1.bitwiseAND);
            const type2 = this.flowParseAnonFunctionWithoutParens();
            node2.types = [type2];
            while (this.eat(types$1.bitwiseAND)) {
              node2.types.push(this.flowParseAnonFunctionWithoutParens());
            }
            return node2.types.length === 1 ? type2 : this.finishNode(node2, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const node2 = this.startNode();
            this.eat(types$1.bitwiseOR);
            const type2 = this.flowParseIntersectionType();
            node2.types = [type2];
            while (this.eat(types$1.bitwiseOR)) {
              node2.types.push(this.flowParseIntersectionType());
            }
            return node2.types.length === 1 ? type2 : this.finishNode(node2, "UnionTypeAnnotation");
          }
          flowParseType() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const type2 = this.flowParseUnionType();
            this.state.inType = oldInType;
            this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
            return type2;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === types$1.name && this.state.value === "_") {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const node2 = this.parseIdentifier();
              return this.flowParseGenericType(startPos, startLoc, node2);
            } else {
              return this.flowParseType();
            }
          }
          flowParseTypeAnnotation() {
            const node2 = this.startNode();
            node2.typeAnnotation = this.flowParseTypeInitialiser();
            return this.finishNode(node2, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
            const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            if (this.match(types$1.colon)) {
              ident.typeAnnotation = this.flowParseTypeAnnotation();
              this.resetEndLocation(ident);
            }
            return ident;
          }
          typeCastToParameter(node2) {
            node2.expression.typeAnnotation = node2.typeAnnotation;
            this.resetEndLocation(node2.expression, node2.typeAnnotation.end, node2.typeAnnotation.loc.end);
            return node2.expression;
          }
          flowParseVariance() {
            let variance = null;
            if (this.match(types$1.plusMin)) {
              variance = this.startNode();
              if (this.state.value === "+") {
                variance.kind = "plus";
              } else {
                variance.kind = "minus";
              }
              this.next();
              this.finishNode(variance, "Variance");
            }
            return variance;
          }
          parseFunctionBody(node2, allowExpressionBody, isMethod) {
            if (isMethod === void 0) {
              isMethod = false;
            }
            if (allowExpressionBody) {
              return this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod));
            }
            return super.parseFunctionBody(node2, false, isMethod);
          }
          parseFunctionBodyAndFinish(node2, type2, isMethod) {
            if (isMethod === void 0) {
              isMethod = false;
            }
            if (this.match(types$1.colon)) {
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
              node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
            }
            super.parseFunctionBodyAndFinish(node2, type2, isMethod);
          }
          parseStatement(context, topLevel) {
            if (this.state.strict && this.match(types$1.name) && this.state.value === "interface") {
              const lookahead = this.lookahead();
              if (lookahead.type === types$1.name || isKeyword(lookahead.value)) {
                const node2 = this.startNode();
                this.next();
                return this.flowParseInterface(node2);
              }
            } else if (this.shouldParseEnums() && this.isContextual("enum")) {
              const node2 = this.startNode();
              this.next();
              return this.flowParseEnumDeclaration(node2);
            }
            const stmt = super.parseStatement(context, topLevel);
            if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
              this.flowPragma = null;
            }
            return stmt;
          }
          parseExpressionStatement(node2, expr2) {
            if (expr2.type === "Identifier") {
              if (expr2.name === "declare") {
                if (this.match(types$1._class) || this.match(types$1.name) || this.match(types$1._function) || this.match(types$1._var) || this.match(types$1._export)) {
                  return this.flowParseDeclare(node2);
                }
              } else if (this.match(types$1.name)) {
                if (expr2.name === "interface") {
                  return this.flowParseInterface(node2);
                } else if (expr2.name === "type") {
                  return this.flowParseTypeAlias(node2);
                } else if (expr2.name === "opaque") {
                  return this.flowParseOpaqueType(node2, false);
                }
              }
            }
            return super.parseExpressionStatement(node2, expr2);
          }
          shouldParseExportDeclaration() {
            return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            if (this.match(types$1.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
              return false;
            }
            return super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual("enum")) {
              const node2 = this.startNode();
              this.next();
              return this.flowParseEnumDeclaration(node2);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(expr2, startPos, startLoc, refNeedsArrowPos) {
            if (!this.match(types$1.question))
              return expr2;
            if (refNeedsArrowPos) {
              const result = this.tryParse(() => super.parseConditional(expr2, startPos, startLoc));
              if (!result.node) {
                refNeedsArrowPos.start = result.error.pos || this.state.start;
                return expr2;
              }
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
            this.expect(types$1.question);
            const state = this.state.clone();
            const originalNoArrowAt = this.state.noArrowAt;
            const node2 = this.startNodeAt(startPos, startLoc);
            let {consequent, failed} = this.tryParseConditionalConsequent();
            let [valid, invalid] = this.getArrowLikeExpressions(consequent);
            if (failed || invalid.length > 0) {
              const noArrowAt = [...originalNoArrowAt];
              if (invalid.length > 0) {
                this.state = state;
                this.state.noArrowAt = noArrowAt;
                for (let i = 0; i < invalid.length; i++) {
                  noArrowAt.push(invalid[i].start);
                }
                ({consequent, failed} = this.tryParseConditionalConsequent());
                [valid, invalid] = this.getArrowLikeExpressions(consequent);
              }
              if (failed && valid.length > 1) {
                this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
              }
              if (failed && valid.length === 1) {
                this.state = state;
                this.state.noArrowAt = noArrowAt.concat(valid[0].start);
                ({consequent, failed} = this.tryParseConditionalConsequent());
              }
            }
            this.getArrowLikeExpressions(consequent, true);
            this.state.noArrowAt = originalNoArrowAt;
            this.expect(types$1.colon);
            node2.test = expr2;
            node2.consequent = consequent;
            node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0, void 0));
            return this.finishNode(node2, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const consequent = this.parseMaybeAssignAllowIn();
            const failed = !this.match(types$1.colon);
            this.state.noArrowParamsConversionAt.pop();
            return {consequent, failed};
          }
          getArrowLikeExpressions(node2, disallowInvalid) {
            const stack = [node2];
            const arrows = [];
            while (stack.length !== 0) {
              const node3 = stack.pop();
              if (node3.type === "ArrowFunctionExpression") {
                if (node3.typeParameters || !node3.returnType) {
                  this.finishArrowValidation(node3);
                } else {
                  arrows.push(node3);
                }
                stack.push(node3.body);
              } else if (node3.type === "ConditionalExpression") {
                stack.push(node3.consequent);
                stack.push(node3.alternate);
              }
            }
            if (disallowInvalid) {
              arrows.forEach((node3) => this.finishArrowValidation(node3));
              return [arrows, []];
            }
            return partition(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)));
          }
          finishArrowValidation(node2) {
            var _node$extra;
            this.toAssignableList(node2.params, (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingComma, false);
            this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
            super.checkParams(node2, false, true);
            this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(node2, parse) {
            let result;
            if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              result = parse();
              this.state.noArrowParamsConversionAt.pop();
            } else {
              result = parse();
            }
            return result;
          }
          parseParenItem(node2, startPos, startLoc) {
            node2 = super.parseParenItem(node2, startPos, startLoc);
            if (this.eat(types$1.question)) {
              node2.optional = true;
              this.resetEndLocation(node2);
            }
            if (this.match(types$1.colon)) {
              const typeCastNode = this.startNodeAt(startPos, startLoc);
              typeCastNode.expression = node2;
              typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
              return this.finishNode(typeCastNode, "TypeCastExpression");
            }
            return node2;
          }
          assertModuleNodeAllowed(node2) {
            if (node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type") {
              return;
            }
            super.assertModuleNodeAllowed(node2);
          }
          parseExport(node2) {
            const decl = super.parseExport(node2);
            if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
              decl.exportKind = decl.exportKind || "value";
            }
            return decl;
          }
          parseExportDeclaration(node2) {
            if (this.isContextual("type")) {
              node2.exportKind = "type";
              const declarationNode = this.startNode();
              this.next();
              if (this.match(types$1.braceL)) {
                node2.specifiers = this.parseExportSpecifiers();
                this.parseExportFrom(node2);
                return null;
              } else {
                return this.flowParseTypeAlias(declarationNode);
              }
            } else if (this.isContextual("opaque")) {
              node2.exportKind = "type";
              const declarationNode = this.startNode();
              this.next();
              return this.flowParseOpaqueType(declarationNode, false);
            } else if (this.isContextual("interface")) {
              node2.exportKind = "type";
              const declarationNode = this.startNode();
              this.next();
              return this.flowParseInterface(declarationNode);
            } else if (this.shouldParseEnums() && this.isContextual("enum")) {
              node2.exportKind = "value";
              const declarationNode = this.startNode();
              this.next();
              return this.flowParseEnumDeclaration(declarationNode);
            } else {
              return super.parseExportDeclaration(node2);
            }
          }
          eatExportStar(node2) {
            if (super.eatExportStar(...arguments))
              return true;
            if (this.isContextual("type") && this.lookahead().type === types$1.star) {
              node2.exportKind = "type";
              this.next();
              this.next();
              return true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(node2) {
            const pos = this.state.start;
            const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2);
            if (hasNamespace && node2.exportKind === "type") {
              this.unexpected(pos);
            }
            return hasNamespace;
          }
          parseClassId(node2, isStatement, optionalId) {
            super.parseClassId(node2, isStatement, optionalId);
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterDeclaration();
            }
          }
          parseClassMember(classBody, member, state) {
            const pos = this.state.start;
            if (this.isContextual("declare")) {
              if (this.parseClassMemberFromModifier(classBody, member)) {
                return;
              }
              member.declare = true;
            }
            super.parseClassMember(classBody, member, state);
            if (member.declare) {
              if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
                this.raise(pos, FlowErrors.DeclareClassElement);
              } else if (member.value) {
                this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
              }
            }
          }
          getTokenFromCode(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 123 && next === 124) {
              return this.finishOp(types$1.braceBarL, 2);
            } else if (this.state.inType && (code === 62 || code === 60)) {
              return this.finishOp(types$1.relational, 1);
            } else if (this.state.inType && code === 63) {
              if (next === 46) {
                return this.finishOp(types$1.questionDot, 2);
              }
              return this.finishOp(types$1.question, 1);
            } else if (isIteratorStart(code, next)) {
              this.state.isIterator = true;
              return super.readWord();
            } else {
              return super.getTokenFromCode(code);
            }
          }
          isAssignable(node2, isBinding) {
            switch (node2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
                return true;
              case "ObjectExpression": {
                const last2 = node2.properties.length - 1;
                return node2.properties.every((prop2, i) => {
                  return prop2.type !== "ObjectMethod" && (i === last2 || prop2.type === "SpreadElement") && this.isAssignable(prop2);
                });
              }
              case "ObjectProperty":
                return this.isAssignable(node2.value);
              case "SpreadElement":
                return this.isAssignable(node2.argument);
              case "ArrayExpression":
                return node2.elements.every((element) => this.isAssignable(element));
              case "AssignmentExpression":
                return node2.operator === "=";
              case "ParenthesizedExpression":
              case "TypeCastExpression":
                return this.isAssignable(node2.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !isBinding;
              default:
                return false;
            }
          }
          toAssignable(node2, isLHS) {
            if (isLHS === void 0) {
              isLHS = false;
            }
            if (node2.type === "TypeCastExpression") {
              return super.toAssignable(this.typeCastToParameter(node2), isLHS);
            } else {
              return super.toAssignable(node2, isLHS);
            }
          }
          toAssignableList(exprList, trailingCommaPos, isLHS) {
            for (let i = 0; i < exprList.length; i++) {
              const expr2 = exprList[i];
              if ((expr2 == null ? void 0 : expr2.type) === "TypeCastExpression") {
                exprList[i] = this.typeCastToParameter(expr2);
              }
            }
            return super.toAssignableList(exprList, trailingCommaPos, isLHS);
          }
          toReferencedList(exprList, isParenthesizedExpr) {
            for (let i = 0; i < exprList.length; i++) {
              var _expr$extra;
              const expr2 = exprList[i];
              if (expr2 && expr2.type === "TypeCastExpression" && !((_expr$extra = expr2.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
                this.raise(expr2.typeAnnotation.start, FlowErrors.TypeCastInPattern);
              }
            }
            return exprList;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
            if (canBePattern && !this.state.maybeInArrowParameters) {
              this.toReferencedList(node2.elements);
            }
            return node2;
          }
          checkLVal(expr2) {
            if (expr2.type !== "TypeCastExpression") {
              for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
                args[_key9 - 1] = arguments[_key9];
              }
              return super.checkLVal(expr2, ...args);
            }
          }
          parseClassProperty(node2) {
            if (this.match(types$1.colon)) {
              node2.typeAnnotation = this.flowParseTypeAnnotation();
            }
            return super.parseClassProperty(node2);
          }
          parseClassPrivateProperty(node2) {
            if (this.match(types$1.colon)) {
              node2.typeAnnotation = this.flowParseTypeAnnotation();
            }
            return super.parseClassPrivateProperty(node2);
          }
          isClassMethod() {
            return this.isRelational("<") || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(types$1.colon) || super.isClassProperty();
          }
          isNonstaticConstructor(method) {
            return !this.match(types$1.colon) && super.isNonstaticConstructor(method);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            if (method.variance) {
              this.unexpected(method.variance.start);
            }
            delete method.variance;
            if (this.isRelational("<")) {
              method.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
            if (method.params && isConstructor) {
              const params = method.params;
              if (params.length > 0 && this.isThisParam(params[0])) {
                this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
              }
            } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
              const params = method.value.params;
              if (params.length > 0 && this.isThisParam(params[0])) {
                this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
              }
            }
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            if (method.variance) {
              this.unexpected(method.variance.start);
            }
            delete method.variance;
            if (this.isRelational("<")) {
              method.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          parseClassSuper(node2) {
            super.parseClassSuper(node2);
            if (node2.superClass && this.isRelational("<")) {
              node2.superTypeParameters = this.flowParseTypeParameterInstantiation();
            }
            if (this.isContextual("implements")) {
              this.next();
              const implemented = node2.implements = [];
              do {
                const node3 = this.startNode();
                node3.id = this.flowParseRestrictedIdentifier(true);
                if (this.isRelational("<")) {
                  node3.typeParameters = this.flowParseTypeParameterInstantiation();
                } else {
                  node3.typeParameters = null;
                }
                implemented.push(this.finishNode(node3, "ClassImplements"));
              } while (this.eat(types$1.comma));
            }
          }
          checkGetterSetterParams(method) {
            super.checkGetterSetterParams(method);
            const params = this.getObjectOrClassMethodParams(method);
            if (params.length > 0) {
              const param = params[0];
              if (this.isThisParam(param) && method.kind === "get") {
                this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
              } else if (this.isThisParam(param)) {
                this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
              }
            }
          }
          parsePropertyName(node2, isPrivateNameAllowed) {
            const variance = this.flowParseVariance();
            const key = super.parsePropertyName(node2, isPrivateNameAllowed);
            node2.variance = variance;
            return key;
          }
          parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            if (prop2.variance) {
              this.unexpected(prop2.variance.start);
            }
            delete prop2.variance;
            let typeParameters;
            if (this.isRelational("<") && !isAccessor) {
              typeParameters = this.flowParseTypeParameterDeclaration();
              if (!this.match(types$1.parenL))
                this.unexpected();
            }
            super.parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
            if (typeParameters) {
              (prop2.value || prop2).typeParameters = typeParameters;
            }
          }
          parseAssignableListItemTypes(param) {
            if (this.eat(types$1.question)) {
              if (param.type !== "Identifier") {
                this.raise(param.start, FlowErrors.OptionalBindingPattern);
              }
              if (this.isThisParam(param)) {
                this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
              }
              param.optional = true;
            }
            if (this.match(types$1.colon)) {
              param.typeAnnotation = this.flowParseTypeAnnotation();
            } else if (this.isThisParam(param)) {
              this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
            }
            if (this.match(types$1.eq) && this.isThisParam(param)) {
              this.raise(param.start, FlowErrors.ThisParamNoDefault);
            }
            this.resetEndLocation(param);
            return param;
          }
          parseMaybeDefault(startPos, startLoc, left) {
            const node2 = super.parseMaybeDefault(startPos, startLoc, left);
            if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
              this.raise(node2.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
            }
            return node2;
          }
          shouldParseDefaultImport(node2) {
            if (!hasTypeImportKind(node2)) {
              return super.shouldParseDefaultImport(node2);
            }
            return isMaybeDefaultImport(this.state);
          }
          parseImportSpecifierLocal(node2, specifier, type2, contextDescription) {
            specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
            this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
            node2.specifiers.push(this.finishNode(specifier, type2));
          }
          maybeParseDefaultImportSpecifier(node2) {
            node2.importKind = "value";
            let kind = null;
            if (this.match(types$1._typeof)) {
              kind = "typeof";
            } else if (this.isContextual("type")) {
              kind = "type";
            }
            if (kind) {
              const lh = this.lookahead();
              if (kind === "type" && lh.type === types$1.star) {
                this.unexpected(lh.start);
              }
              if (isMaybeDefaultImport(lh) || lh.type === types$1.braceL || lh.type === types$1.star) {
                this.next();
                node2.importKind = kind;
              }
            }
            return super.maybeParseDefaultImportSpecifier(node2);
          }
          parseImportSpecifier(node2) {
            const specifier = this.startNode();
            const firstIdentLoc = this.state.start;
            const firstIdent = this.parseModuleExportName();
            let specifierTypeKind = null;
            if (firstIdent.type === "Identifier") {
              if (firstIdent.name === "type") {
                specifierTypeKind = "type";
              } else if (firstIdent.name === "typeof") {
                specifierTypeKind = "typeof";
              }
            }
            let isBinding = false;
            if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
              const as_ident = this.parseIdentifier(true);
              if (specifierTypeKind !== null && !this.match(types$1.name) && !this.state.type.keyword) {
                specifier.imported = as_ident;
                specifier.importKind = specifierTypeKind;
                specifier.local = as_ident.__clone();
              } else {
                specifier.imported = firstIdent;
                specifier.importKind = null;
                specifier.local = this.parseIdentifier();
              }
            } else if (specifierTypeKind !== null && (this.match(types$1.name) || this.state.type.keyword)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
              if (this.eatContextual("as")) {
                specifier.local = this.parseIdentifier();
              } else {
                isBinding = true;
                specifier.local = specifier.imported.__clone();
              }
            } else {
              if (firstIdent.type === "StringLiteral") {
                throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
              }
              isBinding = true;
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = specifier.imported.__clone();
            }
            const nodeIsTypeImport = hasTypeImportKind(node2);
            const specifierIsTypeImport = hasTypeImportKind(specifier);
            if (nodeIsTypeImport && specifierIsTypeImport) {
              this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);
            }
            if (nodeIsTypeImport || specifierIsTypeImport) {
              this.checkReservedType(specifier.local.name, specifier.local.start, true);
            }
            if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
              this.checkReservedWord(specifier.local.name, specifier.start, true, true);
            }
            this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
            node2.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case types$1._this:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(node2, allowModifiers) {
            const kind = node2.kind;
            if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            super.parseFunctionParams(node2, allowModifiers);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind);
            if (this.match(types$1.colon)) {
              decl.id.typeAnnotation = this.flowParseTypeAnnotation();
              this.resetEndLocation(decl.id);
            }
          }
          parseAsyncArrowFromCallExpression(node2, call) {
            if (this.match(types$1.colon)) {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              node2.returnType = this.flowParseTypeAnnotation();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
            }
            return super.parseAsyncArrowFromCallExpression(node2, call);
          }
          shouldParseAsyncArrow() {
            return this.match(types$1.colon) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
            var _jsx;
            let state = null;
            let jsx2;
            if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
              state = this.state.clone();
              jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);
              if (!jsx2.error)
                return jsx2.node;
              const {context} = this.state;
              if (context[context.length - 1] === types$1$1.j_oTag) {
                context.length -= 2;
              } else if (context[context.length - 1] === types$1$1.j_expr) {
                context.length -= 1;
              }
            }
            if ((_jsx = jsx2) != null && _jsx.error || this.isRelational("<")) {
              var _jsx2, _jsx3;
              state = state || this.state.clone();
              let typeParameters;
              const arrow = this.tryParse((abort) => {
                var _arrowExpression$extr;
                typeParameters = this.flowParseTypeParameterDeclaration();
                const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                  const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
                  this.resetStartLocationFromNode(result, typeParameters);
                  return result;
                });
                if (arrowExpression2.type !== "ArrowFunctionExpression" && (_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) {
                  abort();
                }
                const expr2 = this.maybeUnwrapTypeCastExpression(arrowExpression2);
                expr2.typeParameters = typeParameters;
                this.resetStartLocationFromNode(expr2, typeParameters);
                return arrowExpression2;
              }, state);
              let arrowExpression = null;
              if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                if (!arrow.error && !arrow.aborted) {
                  if (arrow.node.async) {
                    this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
                  }
                  return arrow.node;
                }
                arrowExpression = arrow.node;
              }
              if ((_jsx2 = jsx2) != null && _jsx2.node) {
                this.state = jsx2.failState;
                return jsx2.node;
              }
              if (arrowExpression) {
                this.state = arrow.failState;
                return arrowExpression;
              }
              if ((_jsx3 = jsx2) != null && _jsx3.thrown)
                throw jsx2.error;
              if (arrow.thrown)
                throw arrow.error;
              throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
            }
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
          }
          parseArrow(node2) {
            if (this.match(types$1.colon)) {
              const result = this.tryParse(() => {
                const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const typeNode = this.startNode();
                [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.canInsertSemicolon())
                  this.unexpected();
                if (!this.match(types$1.arrow))
                  this.unexpected();
                return typeNode;
              });
              if (result.thrown)
                return null;
              if (result.error)
                this.state = result.failState;
              node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(node2);
          }
          shouldParseArrow() {
            return this.match(types$1.colon) || super.shouldParseArrow();
          }
          setArrowFunctionParameters(node2, params) {
            if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
              node2.params = params;
            } else {
              super.setArrowFunctionParameters(node2, params);
            }
          }
          checkParams(node2, allowDuplicates, isArrowFunction) {
            if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
              return;
            }
            for (let i = 0; i < node2.params.length; i++) {
              if (this.isThisParam(node2.params[i]) && i > 0) {
                this.raise(node2.params[i].start, FlowErrors.ThisParamMustBeFirst);
              }
            }
            return super.checkParams(...arguments);
          }
          parseParenAndDistinguishExpression(canBeArrow) {
            return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(base, startPos, startLoc, noCalls) {
            if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
              this.next();
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
              base = this.finishNode(node2, "CallExpression");
            } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
              const state = this.state.clone();
              const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
              if (!arrow.error && !arrow.aborted)
                return arrow.node;
              const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
              if (result.node && !result.error)
                return result.node;
              if (arrow.node) {
                this.state = arrow.failState;
                return arrow.node;
              }
              if (result.node) {
                this.state = result.failState;
                return result.node;
              }
              throw arrow.error || result.error;
            }
            return super.parseSubscripts(base, startPos, startLoc, noCalls);
          }
          parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
            if (this.match(types$1.questionDot) && this.isLookaheadToken_lt()) {
              subscriptState.optionalChainMember = true;
              if (noCalls) {
                subscriptState.stop = true;
                return base;
              }
              this.next();
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              node2.typeArguments = this.flowParseTypeParameterInstantiation();
              this.expect(types$1.parenL);
              node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
              node2.optional = true;
              return this.finishCallExpression(node2, true);
            } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              const result = this.tryParse(() => {
                node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
                this.expect(types$1.parenL);
                node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                if (subscriptState.optionalChainMember)
                  node2.optional = false;
                return this.finishCallExpression(node2, subscriptState.optionalChainMember);
              });
              if (result.node) {
                if (result.error)
                  this.state = result.failState;
                return result.node;
              }
            }
            return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
          }
          parseNewArguments(node2) {
            let targs = null;
            if (this.shouldParseTypes() && this.isRelational("<")) {
              targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
            }
            node2.typeArguments = targs;
            super.parseNewArguments(node2);
          }
          parseAsyncArrowWithTypeParameters(startPos, startLoc) {
            const node2 = this.startNodeAt(startPos, startLoc);
            this.parseFunctionParams(node2);
            if (!this.parseArrow(node2))
              return;
            return this.parseArrowExpression(node2, void 0, true);
          }
          readToken_mult_modulo(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 42 && next === 47 && this.state.hasFlowComment) {
              this.state.hasFlowComment = false;
              this.state.pos += 2;
              this.nextToken();
              return;
            }
            super.readToken_mult_modulo(code);
          }
          readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 124 && next === 125) {
              this.finishOp(types$1.braceBarR, 2);
              return;
            }
            super.readToken_pipe_amp(code);
          }
          parseTopLevel(file, program) {
            const fileNode = super.parseTopLevel(file, program);
            if (this.state.hasFlowComment) {
              this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
            }
            return fileNode;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment) {
                this.unexpected(null, FlowErrors.NestedFlowComment);
              }
              this.hasFlowCommentCompletion();
              this.state.pos += this.skipFlowComment();
              this.state.hasFlowComment = true;
              return;
            }
            if (this.state.hasFlowComment) {
              const end = this.input.indexOf("*-/", this.state.pos += 2);
              if (end === -1) {
                throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
              }
              this.state.pos = end + 3;
              return;
            }
            super.skipBlockComment();
          }
          skipFlowComment() {
            const {pos} = this.state;
            let shiftToFirstNonWhiteSpace = 2;
            while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
              shiftToFirstNonWhiteSpace++;
            }
            const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
            const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
            if (ch2 === 58 && ch3 === 58) {
              return shiftToFirstNonWhiteSpace + 2;
            }
            if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
              return shiftToFirstNonWhiteSpace + 12;
            }
            if (ch2 === 58 && ch3 !== 58) {
              return shiftToFirstNonWhiteSpace;
            }
            return false;
          }
          hasFlowCommentCompletion() {
            const end = this.input.indexOf("*/", this.state.pos);
            if (end === -1) {
              throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
            }
          }
          flowEnumErrorBooleanMemberNotInitialized(pos, _ref7) {
            let {enumName, memberName} = _ref7;
            this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
          }
          flowEnumErrorInvalidMemberName(pos, _ref8) {
            let {enumName, memberName} = _ref8;
            const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
            this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
          }
          flowEnumErrorDuplicateMemberName(pos, _ref9) {
            let {enumName, memberName} = _ref9;
            this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
          }
          flowEnumErrorInconsistentMemberValues(pos, _ref10) {
            let {enumName} = _ref10;
            this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
          }
          flowEnumErrorInvalidExplicitType(pos, _ref11) {
            let {enumName, suppliedType} = _ref11;
            return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
          }
          flowEnumErrorInvalidMemberInitializer(pos, _ref12) {
            let {enumName, explicitType, memberName} = _ref12;
            let message = null;
            switch (explicitType) {
              case "boolean":
              case "number":
              case "string":
                message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
                break;
              case "symbol":
                message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
                break;
              default:
                message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
            }
            return this.raise(pos, message, enumName, memberName, explicitType);
          }
          flowEnumErrorNumberMemberNotInitialized(pos, _ref13) {
            let {enumName, memberName} = _ref13;
            this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref14) {
            let {enumName} = _ref14;
            this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
          }
          flowEnumMemberInit() {
            const startPos = this.state.start;
            const endOfInit = () => this.match(types$1.comma) || this.match(types$1.braceR);
            switch (this.state.type) {
              case types$1.num: {
                const literal = this.parseLiteral(this.state.value, "NumericLiteral");
                if (endOfInit()) {
                  return {type: "number", pos: literal.start, value: literal};
                }
                return {type: "invalid", pos: startPos};
              }
              case types$1.string: {
                const literal = this.parseLiteral(this.state.value, "StringLiteral");
                if (endOfInit()) {
                  return {type: "string", pos: literal.start, value: literal};
                }
                return {type: "invalid", pos: startPos};
              }
              case types$1._true:
              case types$1._false: {
                const literal = this.parseBooleanLiteral();
                if (endOfInit()) {
                  return {type: "boolean", pos: literal.start, value: literal};
                }
                return {type: "invalid", pos: startPos};
              }
              default:
                return {type: "invalid", pos: startPos};
            }
          }
          flowEnumMemberRaw() {
            const pos = this.state.start;
            const id = this.parseIdentifier(true);
            const init2 = this.eat(types$1.eq) ? this.flowEnumMemberInit() : {type: "none", pos};
            return {id, init: init2};
          }
          flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
            const {explicitType} = context;
            if (explicitType === null) {
              return;
            }
            if (explicitType !== expectedType) {
              this.flowEnumErrorInvalidMemberInitializer(pos, context);
            }
          }
          flowEnumMembers(_ref15) {
            let {enumName, explicitType} = _ref15;
            const seenNames = new Set();
            const members = {booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: []};
            let hasUnknownMembers = false;
            while (!this.match(types$1.braceR)) {
              if (this.eat(types$1.ellipsis)) {
                hasUnknownMembers = true;
                break;
              }
              const memberNode = this.startNode();
              const {id, init: init2} = this.flowEnumMemberRaw();
              const memberName = id.name;
              if (memberName === "") {
                continue;
              }
              if (/^[a-z]/.test(memberName)) {
                this.flowEnumErrorInvalidMemberName(id.start, {enumName, memberName});
              }
              if (seenNames.has(memberName)) {
                this.flowEnumErrorDuplicateMemberName(id.start, {enumName, memberName});
              }
              seenNames.add(memberName);
              const context = {enumName, explicitType, memberName};
              memberNode.id = id;
              switch (init2.type) {
                case "boolean": {
                  this.flowEnumCheckExplicitTypeMismatch(init2.pos, context, "boolean");
                  memberNode.init = init2.value;
                  members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                  break;
                }
                case "number": {
                  this.flowEnumCheckExplicitTypeMismatch(init2.pos, context, "number");
                  memberNode.init = init2.value;
                  members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                  break;
                }
                case "string": {
                  this.flowEnumCheckExplicitTypeMismatch(init2.pos, context, "string");
                  memberNode.init = init2.value;
                  members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                  break;
                }
                case "invalid": {
                  throw this.flowEnumErrorInvalidMemberInitializer(init2.pos, context);
                }
                case "none": {
                  switch (explicitType) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(init2.pos, context);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(init2.pos, context);
                      break;
                    default:
                      members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                  }
                }
              }
              if (!this.match(types$1.braceR)) {
                this.expect(types$1.comma);
              }
            }
            return {members, hasUnknownMembers};
          }
          flowEnumStringMembers(initializedMembers, defaultedMembers, _ref16) {
            let {enumName} = _ref16;
            if (initializedMembers.length === 0) {
              return defaultedMembers;
            } else if (defaultedMembers.length === 0) {
              return initializedMembers;
            } else if (defaultedMembers.length > initializedMembers.length) {
              for (const member of initializedMembers) {
                this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {enumName});
              }
              return defaultedMembers;
            } else {
              for (const member of defaultedMembers) {
                this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {enumName});
              }
              return initializedMembers;
            }
          }
          flowEnumParseExplicitType(_ref17) {
            let {enumName} = _ref17;
            if (this.eatContextual("of")) {
              if (!this.match(types$1.name)) {
                throw this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName, suppliedType: null});
              }
              const {value} = this.state;
              this.next();
              if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
                this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName, suppliedType: value});
              }
              return value;
            }
            return null;
          }
          flowEnumBody(node2, _ref18) {
            let {enumName, nameLoc} = _ref18;
            const explicitType = this.flowEnumParseExplicitType({enumName});
            this.expect(types$1.braceL);
            const {members, hasUnknownMembers} = this.flowEnumMembers({enumName, explicitType});
            node2.hasUnknownMembers = hasUnknownMembers;
            switch (explicitType) {
              case "boolean":
                node2.explicitType = true;
                node2.members = members.booleanMembers;
                this.expect(types$1.braceR);
                return this.finishNode(node2, "EnumBooleanBody");
              case "number":
                node2.explicitType = true;
                node2.members = members.numberMembers;
                this.expect(types$1.braceR);
                return this.finishNode(node2, "EnumNumberBody");
              case "string":
                node2.explicitType = true;
                node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {enumName});
                this.expect(types$1.braceR);
                return this.finishNode(node2, "EnumStringBody");
              case "symbol":
                node2.members = members.defaultedMembers;
                this.expect(types$1.braceR);
                return this.finishNode(node2, "EnumSymbolBody");
              default: {
                const empty2 = () => {
                  node2.members = [];
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumStringBody");
                };
                node2.explicitType = false;
                const boolsLen = members.booleanMembers.length;
                const numsLen = members.numberMembers.length;
                const strsLen = members.stringMembers.length;
                const defaultedLen = members.defaultedMembers.length;
                if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                  return empty2();
                } else if (!boolsLen && !numsLen) {
                  node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {enumName});
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumStringBody");
                } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                  for (const member of members.defaultedMembers) {
                    this.flowEnumErrorBooleanMemberNotInitialized(member.start, {enumName, memberName: member.id.name});
                  }
                  node2.members = members.booleanMembers;
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumBooleanBody");
                } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                  for (const member of members.defaultedMembers) {
                    this.flowEnumErrorNumberMemberNotInitialized(member.start, {enumName, memberName: member.id.name});
                  }
                  node2.members = members.numberMembers;
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumNumberBody");
                } else {
                  this.flowEnumErrorInconsistentMemberValues(nameLoc, {enumName});
                  return empty2();
                }
              }
            }
          }
          flowParseEnumDeclaration(node2) {
            const id = this.parseIdentifier();
            node2.id = id;
            node2.body = this.flowEnumBody(this.startNode(), {enumName: id.name, nameLoc: id.start});
            return this.finishNode(node2, "EnumDeclaration");
          }
          updateContext(prevType) {
            if (this.match(types$1.name) && this.state.value === "of" && prevType === types$1.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === "interface") {
              this.state.exprAllowed = false;
            } else {
              super.updateContext(prevType);
            }
          }
          isLookaheadToken_lt() {
            const next = this.nextTokenStart();
            if (this.input.charCodeAt(next) === 60) {
              const afterNext = this.input.charCodeAt(next + 1);
              return afterNext !== 60 && afterNext !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(node2) {
            return node2.type === "TypeCastExpression" ? node2.expression : node2;
          }
        };
        const entities$1 = {quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666"};
        const HEX_NUMBER$1 = /^[\da-fA-F]+$/;
        const DECIMAL_NUMBER$1 = /^\d+$/;
        const JsxErrors = makeErrorTemplates({AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"}, ErrorCodes.SyntaxError);
        types$1$1.j_oTag = new TokContext("<tag", false);
        types$1$1.j_cTag = new TokContext("</tag", false);
        types$1$1.j_expr = new TokContext("<tag>...</tag>", true, true);
        types$1.jsxName = new TokenType("jsxName");
        types$1.jsxText = new TokenType("jsxText", {beforeExpr: true});
        types$1.jsxTagStart = new TokenType("jsxTagStart", {startsExpr: true});
        types$1.jsxTagEnd = new TokenType("jsxTagEnd");
        types$1.jsxTagStart.updateContext = function() {
          this.state.context.push(types$1$1.j_expr);
          this.state.context.push(types$1$1.j_oTag);
          this.state.exprAllowed = false;
        };
        types$1.jsxTagEnd.updateContext = function(prevType) {
          const out = this.state.context.pop();
          if (out === types$1$1.j_oTag && prevType === types$1.slash || out === types$1$1.j_cTag) {
            this.state.context.pop();
            this.state.exprAllowed = this.curContext() === types$1$1.j_expr;
          } else {
            this.state.exprAllowed = true;
          }
        };
        function isFragment(object2) {
          return object2 ? object2.type === "JSXOpeningFragment" || object2.type === "JSXClosingFragment" : false;
        }
        function getQualifiedJSXName(object2) {
          if (object2.type === "JSXIdentifier") {
            return object2.name;
          }
          if (object2.type === "JSXNamespacedName") {
            return object2.namespace.name + ":" + object2.name.name;
          }
          if (object2.type === "JSXMemberExpression") {
            return getQualifiedJSXName(object2.object) + "." + getQualifiedJSXName(object2.property);
          }
          throw new Error("Node had unexpected type: " + object2.type);
        }
        var jsx = (superClass) => class extends superClass {
          jsxReadToken() {
            let out = "";
            let chunkStart = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) {
                throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
              }
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    if (ch === 60 && this.state.exprAllowed) {
                      ++this.state.pos;
                      return this.finishToken(types$1.jsxTagStart);
                    }
                    return super.getTokenFromCode(ch);
                  }
                  out += this.input.slice(chunkStart, this.state.pos);
                  return this.finishToken(types$1.jsxText, out);
                case 38:
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadEntity();
                  chunkStart = this.state.pos;
                  break;
                case 62:
                case 125:
                default:
                  if (isNewLine(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadNewLine(true);
                    chunkStart = this.state.pos;
                  } else {
                    ++this.state.pos;
                  }
              }
            }
          }
          jsxReadNewLine(normalizeCRLF) {
            const ch = this.input.charCodeAt(this.state.pos);
            let out;
            ++this.state.pos;
            if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
              out = normalizeCRLF ? "\n" : "\r\n";
            } else {
              out = String.fromCharCode(ch);
            }
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            return out;
          }
          jsxReadString(quote) {
            let out = "";
            let chunkStart = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) {
                throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
              }
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === quote)
                break;
              if (ch === 38) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
              } else if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(false);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
            }
            out += this.input.slice(chunkStart, this.state.pos++);
            return this.finishToken(types$1.string, out);
          }
          jsxReadEntity() {
            let str = "";
            let count = 0;
            let entity;
            let ch = this.input[this.state.pos];
            const startPos = ++this.state.pos;
            while (this.state.pos < this.length && count++ < 10) {
              ch = this.input[this.state.pos++];
              if (ch === ";") {
                if (str[0] === "#") {
                  if (str[1] === "x") {
                    str = str.substr(2);
                    if (HEX_NUMBER$1.test(str)) {
                      entity = String.fromCodePoint(parseInt(str, 16));
                    }
                  } else {
                    str = str.substr(1);
                    if (DECIMAL_NUMBER$1.test(str)) {
                      entity = String.fromCodePoint(parseInt(str, 10));
                    }
                  }
                } else {
                  entity = entities$1[str];
                }
                break;
              }
              str += ch;
            }
            if (!entity) {
              this.state.pos = startPos;
              return "&";
            }
            return entity;
          }
          jsxReadWord() {
            let ch;
            const start = this.state.pos;
            do {
              ch = this.input.charCodeAt(++this.state.pos);
            } while (isIdentifierChar(ch) || ch === 45);
            return this.finishToken(types$1.jsxName, this.input.slice(start, this.state.pos));
          }
          jsxParseIdentifier() {
            const node2 = this.startNode();
            if (this.match(types$1.jsxName)) {
              node2.name = this.state.value;
            } else if (this.state.type.keyword) {
              node2.name = this.state.type.keyword;
            } else {
              this.unexpected();
            }
            this.next();
            return this.finishNode(node2, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const name = this.jsxParseIdentifier();
            if (!this.eat(types$1.colon))
              return name;
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.namespace = name;
            node2.name = this.jsxParseIdentifier();
            return this.finishNode(node2, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let node2 = this.jsxParseNamespacedName();
            if (node2.type === "JSXNamespacedName") {
              return node2;
            }
            while (this.eat(types$1.dot)) {
              const newNode = this.startNodeAt(startPos, startLoc);
              newNode.object = node2;
              newNode.property = this.jsxParseIdentifier();
              node2 = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node2;
          }
          jsxParseAttributeValue() {
            let node2;
            switch (this.state.type) {
              case types$1.braceL:
                node2 = this.startNode();
                this.next();
                node2 = this.jsxParseExpressionContainer(node2);
                if (node2.expression.type === "JSXEmptyExpression") {
                  this.raise(node2.start, JsxErrors.AttributeIsEmpty);
                }
                return node2;
              case types$1.jsxTagStart:
              case types$1.string:
                return this.parseExprAtom();
              default:
                throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
            }
          }
          jsxParseEmptyExpression() {
            const node2 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
            return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.start, this.state.startLoc);
          }
          jsxParseSpreadChild(node2) {
            this.next();
            node2.expression = this.parseExpression();
            this.expect(types$1.braceR);
            return this.finishNode(node2, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(node2) {
            if (this.match(types$1.braceR)) {
              node2.expression = this.jsxParseEmptyExpression();
            } else {
              const expression = this.parseExpression();
              node2.expression = expression;
            }
            this.expect(types$1.braceR);
            return this.finishNode(node2, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const node2 = this.startNode();
            if (this.eat(types$1.braceL)) {
              this.expect(types$1.ellipsis);
              node2.argument = this.parseMaybeAssignAllowIn();
              this.expect(types$1.braceR);
              return this.finishNode(node2, "JSXSpreadAttribute");
            }
            node2.name = this.jsxParseNamespacedName();
            node2.value = this.eat(types$1.eq) ? this.jsxParseAttributeValue() : null;
            return this.finishNode(node2, "JSXAttribute");
          }
          jsxParseOpeningElementAt(startPos, startLoc) {
            const node2 = this.startNodeAt(startPos, startLoc);
            if (this.match(types$1.jsxTagEnd)) {
              this.expect(types$1.jsxTagEnd);
              return this.finishNode(node2, "JSXOpeningFragment");
            }
            node2.name = this.jsxParseElementName();
            return this.jsxParseOpeningElementAfterName(node2);
          }
          jsxParseOpeningElementAfterName(node2) {
            const attributes = [];
            while (!this.match(types$1.slash) && !this.match(types$1.jsxTagEnd)) {
              attributes.push(this.jsxParseAttribute());
            }
            node2.attributes = attributes;
            node2.selfClosing = this.eat(types$1.slash);
            this.expect(types$1.jsxTagEnd);
            return this.finishNode(node2, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(startPos, startLoc) {
            const node2 = this.startNodeAt(startPos, startLoc);
            if (this.match(types$1.jsxTagEnd)) {
              this.expect(types$1.jsxTagEnd);
              return this.finishNode(node2, "JSXClosingFragment");
            }
            node2.name = this.jsxParseElementName();
            this.expect(types$1.jsxTagEnd);
            return this.finishNode(node2, "JSXClosingElement");
          }
          jsxParseElementAt(startPos, startLoc) {
            const node2 = this.startNodeAt(startPos, startLoc);
            const children = [];
            const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
            let closingElement = null;
            if (!openingElement.selfClosing) {
              contents:
                for (; ; ) {
                  switch (this.state.type) {
                    case types$1.jsxTagStart:
                      startPos = this.state.start;
                      startLoc = this.state.startLoc;
                      this.next();
                      if (this.eat(types$1.slash)) {
                        closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                        break contents;
                      }
                      children.push(this.jsxParseElementAt(startPos, startLoc));
                      break;
                    case types$1.jsxText:
                      children.push(this.parseExprAtom());
                      break;
                    case types$1.braceL: {
                      const node3 = this.startNode();
                      this.next();
                      if (this.match(types$1.ellipsis)) {
                        children.push(this.jsxParseSpreadChild(node3));
                      } else {
                        children.push(this.jsxParseExpressionContainer(node3));
                      }
                      break;
                    }
                    default:
                      throw this.unexpected();
                  }
                }
              if (isFragment(openingElement) && !isFragment(closingElement)) {
                this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
              } else if (!isFragment(openingElement) && isFragment(closingElement)) {
                this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
              } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                  this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
                }
              }
            }
            if (isFragment(openingElement)) {
              node2.openingFragment = openingElement;
              node2.closingFragment = closingElement;
            } else {
              node2.openingElement = openingElement;
              node2.closingElement = closingElement;
            }
            node2.children = children;
            if (this.isRelational("<")) {
              throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
            }
            return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
          }
          jsxParseElement() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            this.next();
            return this.jsxParseElementAt(startPos, startLoc);
          }
          parseExprAtom(refExpressionErrors) {
            if (this.match(types$1.jsxText)) {
              return this.parseLiteral(this.state.value, "JSXText");
            } else if (this.match(types$1.jsxTagStart)) {
              return this.jsxParseElement();
            } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
              this.finishToken(types$1.jsxTagStart);
              return this.jsxParseElement();
            } else {
              return super.parseExprAtom(refExpressionErrors);
            }
          }
          getTokenFromCode(code) {
            if (this.state.inPropertyName)
              return super.getTokenFromCode(code);
            const context = this.curContext();
            if (context === types$1$1.j_expr) {
              return this.jsxReadToken();
            }
            if (context === types$1$1.j_oTag || context === types$1$1.j_cTag) {
              if (isIdentifierStart(code)) {
                return this.jsxReadWord();
              }
              if (code === 62) {
                ++this.state.pos;
                return this.finishToken(types$1.jsxTagEnd);
              }
              if ((code === 34 || code === 39) && context === types$1$1.j_oTag) {
                return this.jsxReadString(code);
              }
            }
            if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
              ++this.state.pos;
              return this.finishToken(types$1.jsxTagStart);
            }
            return super.getTokenFromCode(code);
          }
          updateContext(prevType) {
            if (this.match(types$1.braceL)) {
              const curContext = this.curContext();
              if (curContext === types$1$1.j_oTag) {
                this.state.context.push(types$1$1.braceExpression);
              } else if (curContext === types$1$1.j_expr) {
                this.state.context.push(types$1$1.templateQuasi);
              } else {
                super.updateContext(prevType);
              }
              this.state.exprAllowed = true;
            } else if (this.match(types$1.slash) && prevType === types$1.jsxTagStart) {
              this.state.context.length -= 2;
              this.state.context.push(types$1$1.j_cTag);
              this.state.exprAllowed = false;
            } else {
              return super.updateContext(prevType);
            }
          }
        };
        class TypeScriptScope extends Scope {
          constructor() {
            super(...arguments);
            this.types = [];
            this.enums = [];
            this.constEnums = [];
            this.classes = [];
            this.exportOnlyBindings = [];
          }
        }
        class TypeScriptScopeHandler extends ScopeHandler {
          createScope(flags) {
            return new TypeScriptScope(flags);
          }
          declareName(name, bindingType, pos) {
            const scope2 = this.currentScope();
            if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
              this.maybeExportDefined(scope2, name);
              scope2.exportOnlyBindings.push(name);
              return;
            }
            super.declareName(...arguments);
            if (bindingType & BIND_KIND_TYPE) {
              if (!(bindingType & BIND_KIND_VALUE)) {
                this.checkRedeclarationInScope(scope2, name, bindingType, pos);
                this.maybeExportDefined(scope2, name);
              }
              scope2.types.push(name);
            }
            if (bindingType & BIND_FLAGS_TS_ENUM)
              scope2.enums.push(name);
            if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
              scope2.constEnums.push(name);
            if (bindingType & BIND_FLAGS_CLASS)
              scope2.classes.push(name);
          }
          isRedeclaredInScope(scope2, name, bindingType) {
            if (scope2.enums.indexOf(name) > -1) {
              if (bindingType & BIND_FLAGS_TS_ENUM) {
                const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
                const wasConst = scope2.constEnums.indexOf(name) > -1;
                return isConst !== wasConst;
              }
              return true;
            }
            if (bindingType & BIND_FLAGS_CLASS && scope2.classes.indexOf(name) > -1) {
              if (scope2.lexical.indexOf(name) > -1) {
                return !!(bindingType & BIND_KIND_VALUE);
              } else {
                return false;
              }
            }
            if (bindingType & BIND_KIND_TYPE && scope2.types.indexOf(name) > -1) {
              return true;
            }
            return super.isRedeclaredInScope(...arguments);
          }
          checkLocalExport(id) {
            if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
              super.checkLocalExport(id);
            }
          }
        }
        const PARAM = 0, PARAM_YIELD = 1, PARAM_AWAIT = 2, PARAM_RETURN = 4, PARAM_IN = 8;
        class ProductionParameterHandler {
          constructor() {
            this.stacks = [];
          }
          enter(flags) {
            this.stacks.push(flags);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (this.currentFlags() & PARAM_AWAIT) > 0;
          }
          get hasYield() {
            return (this.currentFlags() & PARAM_YIELD) > 0;
          }
          get hasReturn() {
            return (this.currentFlags() & PARAM_RETURN) > 0;
          }
          get hasIn() {
            return (this.currentFlags() & PARAM_IN) > 0;
          }
        }
        function functionFlags(isAsync, isGenerator) {
          return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
        }
        function nonNull(x) {
          if (x == null) {
            throw new Error(`Unexpected ${x} value.`);
          }
          return x;
        }
        function assert(x) {
          if (!x) {
            throw new Error("Assert fail");
          }
        }
        const TSErrors = makeErrorTemplates({AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."}, ErrorCodes.SyntaxError);
        function keywordTypeFromName(value) {
          switch (value) {
            case "any":
              return "TSAnyKeyword";
            case "boolean":
              return "TSBooleanKeyword";
            case "bigint":
              return "TSBigIntKeyword";
            case "never":
              return "TSNeverKeyword";
            case "number":
              return "TSNumberKeyword";
            case "object":
              return "TSObjectKeyword";
            case "string":
              return "TSStringKeyword";
            case "symbol":
              return "TSSymbolKeyword";
            case "undefined":
              return "TSUndefinedKeyword";
            case "unknown":
              return "TSUnknownKeyword";
            default:
              return void 0;
          }
        }
        function tsIsAccessModifier(modifier) {
          return modifier === "private" || modifier === "public" || modifier === "protected";
        }
        var typescript = (superClass) => class extends superClass {
          getScopeHandler() {
            return TypeScriptScopeHandler;
          }
          tsIsIdentifier() {
            return this.match(types$1.name);
          }
          tsTokenCanFollowModifier() {
            return (this.match(types$1.bracketL) || this.match(types$1.braceL) || this.match(types$1.star) || this.match(types$1.ellipsis) || this.match(types$1.hash) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            this.next();
            return this.tsTokenCanFollowModifier();
          }
          tsParseModifier(allowedModifiers) {
            if (!this.match(types$1.name)) {
              return void 0;
            }
            const modifier = this.state.value;
            if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
            return void 0;
          }
          tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {
            const enforceOrder = (pos, modifier, before, after) => {
              if (modifier === before && modified[after]) {
                this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
              }
            };
            const incompatible = (pos, modifier, mod1, mod2) => {
              if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
                this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
              }
            };
            for (; ; ) {
              const startPos = this.state.start;
              const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));
              if (!modifier)
                break;
              if (tsIsAccessModifier(modifier)) {
                if (modified.accessibility) {
                  this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
                } else {
                  enforceOrder(startPos, modifier, modifier, "override");
                  enforceOrder(startPos, modifier, modifier, "static");
                  modified.accessibility = modifier;
                }
              } else {
                if (Object.hasOwnProperty.call(modified, modifier)) {
                  this.raise(startPos, TSErrors.DuplicateModifier, modifier);
                } else {
                  enforceOrder(startPos, modifier, "static", "readonly");
                  enforceOrder(startPos, modifier, "static", "override");
                  enforceOrder(startPos, modifier, "override", "readonly");
                  enforceOrder(startPos, modifier, "abstract", "override");
                  incompatible(startPos, modifier, "declare", "override");
                  incompatible(startPos, modifier, "static", "abstract");
                }
                modified[modifier] = true;
              }
              if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
                this.raise(startPos, errorTemplate, modifier);
              }
            }
          }
          tsIsListTerminator(kind) {
            switch (kind) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(types$1.braceR);
              case "HeritageClauseElement":
                return this.match(types$1.braceL);
              case "TupleElementTypes":
                return this.match(types$1.bracketR);
              case "TypeParametersOrArguments":
                return this.isRelational(">");
            }
            throw new Error("Unreachable");
          }
          tsParseList(kind, parseElement) {
            const result = [];
            while (!this.tsIsListTerminator(kind)) {
              result.push(parseElement());
            }
            return result;
          }
          tsParseDelimitedList(kind, parseElement) {
            return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
          }
          tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
            const result = [];
            for (; ; ) {
              if (this.tsIsListTerminator(kind)) {
                break;
              }
              const element = parseElement();
              if (element == null) {
                return void 0;
              }
              result.push(element);
              if (this.eat(types$1.comma)) {
                continue;
              }
              if (this.tsIsListTerminator(kind)) {
                break;
              }
              if (expectSuccess) {
                this.expect(types$1.comma);
              }
              return void 0;
            }
            return result;
          }
          tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
            if (!skipFirstToken) {
              if (bracket) {
                this.expect(types$1.bracketL);
              } else {
                this.expectRelational("<");
              }
            }
            const result = this.tsParseDelimitedList(kind, parseElement);
            if (bracket) {
              this.expect(types$1.bracketR);
            } else {
              this.expectRelational(">");
            }
            return result;
          }
          tsParseImportType() {
            const node2 = this.startNode();
            this.expect(types$1._import);
            this.expect(types$1.parenL);
            if (!this.match(types$1.string)) {
              this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
            }
            node2.argument = this.parseExprAtom();
            this.expect(types$1.parenR);
            if (this.eat(types$1.dot)) {
              node2.qualifier = this.tsParseEntityName(true);
            }
            if (this.isRelational("<")) {
              node2.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node2, "TSImportType");
          }
          tsParseEntityName(allowReservedWords) {
            let entity = this.parseIdentifier();
            while (this.eat(types$1.dot)) {
              const node2 = this.startNodeAtNode(entity);
              node2.left = entity;
              node2.right = this.parseIdentifier(allowReservedWords);
              entity = this.finishNode(node2, "TSQualifiedName");
            }
            return entity;
          }
          tsParseTypeReference() {
            const node2 = this.startNode();
            node2.typeName = this.tsParseEntityName(false);
            if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
              node2.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node2, "TSTypeReference");
          }
          tsParseThisTypePredicate(lhs) {
            this.next();
            const node2 = this.startNodeAtNode(lhs);
            node2.parameterName = lhs;
            node2.typeAnnotation = this.tsParseTypeAnnotation(false);
            node2.asserts = false;
            return this.finishNode(node2, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSThisType");
          }
          tsParseTypeQuery() {
            const node2 = this.startNode();
            this.expect(types$1._typeof);
            if (this.match(types$1._import)) {
              node2.exprName = this.tsParseImportType();
            } else {
              node2.exprName = this.tsParseEntityName(true);
            }
            return this.finishNode(node2, "TSTypeQuery");
          }
          tsParseTypeParameter() {
            const node2 = this.startNode();
            node2.name = this.parseIdentifierName(node2.start);
            node2.constraint = this.tsEatThenParseType(types$1._extends);
            node2.default = this.tsEatThenParseType(types$1.eq);
            return this.finishNode(node2, "TSTypeParameter");
          }
          tsTryParseTypeParameters() {
            if (this.isRelational("<")) {
              return this.tsParseTypeParameters();
            }
          }
          tsParseTypeParameters() {
            const node2 = this.startNode();
            if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
              this.next();
            } else {
              this.unexpected();
            }
            node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
            if (node2.params.length === 0) {
              this.raise(node2.start, TSErrors.EmptyTypeParameters);
            }
            return this.finishNode(node2, "TSTypeParameterDeclaration");
          }
          tsTryNextParseConstantContext() {
            if (this.lookahead().type === types$1._const) {
              this.next();
              return this.tsParseTypeReference();
            }
            return null;
          }
          tsFillSignature(returnToken, signature) {
            const returnTokenRequired = returnToken === types$1.arrow;
            signature.typeParameters = this.tsTryParseTypeParameters();
            this.expect(types$1.parenL);
            signature.parameters = this.tsParseBindingListForSignature();
            if (returnTokenRequired) {
              signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
            } else if (this.match(returnToken)) {
              signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
            }
          }
          tsParseBindingListForSignature() {
            return this.parseBindingList(types$1.parenR, 41).map((pattern) => {
              if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
                this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
              }
              return pattern;
            });
          }
          tsParseTypeMemberSemicolon() {
            if (!this.eat(types$1.comma) && !this.isLineTerminator()) {
              this.expect(types$1.semi);
            }
          }
          tsParseSignatureMember(kind, node2) {
            this.tsFillSignature(types$1.colon, node2);
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(node2, kind);
          }
          tsIsUnambiguouslyIndexSignature() {
            this.next();
            return this.eat(types$1.name) && this.match(types$1.colon);
          }
          tsTryParseIndexSignature(node2) {
            if (!(this.match(types$1.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
              return void 0;
            }
            this.expect(types$1.bracketL);
            const id = this.parseIdentifier();
            id.typeAnnotation = this.tsParseTypeAnnotation();
            this.resetEndLocation(id);
            this.expect(types$1.bracketR);
            node2.parameters = [id];
            const type2 = this.tsTryParseTypeAnnotation();
            if (type2)
              node2.typeAnnotation = type2;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(node2, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(node2, readonly) {
            if (this.eat(types$1.question))
              node2.optional = true;
            const nodeAny = node2;
            if (this.match(types$1.parenL) || this.isRelational("<")) {
              if (readonly) {
                this.raise(node2.start, TSErrors.ReadonlyForMethodSignature);
              }
              const method = nodeAny;
              if (method.kind && this.isRelational("<")) {
                this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
              }
              this.tsFillSignature(types$1.colon, method);
              this.tsParseTypeMemberSemicolon();
              if (method.kind === "get") {
                if (method.parameters.length > 0) {
                  this.raise(this.state.pos, ErrorMessages.BadGetterArity);
                  if (this.isThisParam(method.parameters[0])) {
                    this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                  }
                }
              } else if (method.kind === "set") {
                if (method.parameters.length !== 1) {
                  this.raise(this.state.pos, ErrorMessages.BadSetterArity);
                } else {
                  const firstParameter = method.parameters[0];
                  if (this.isThisParam(firstParameter)) {
                    this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                  }
                  if (firstParameter.type === "Identifier" && firstParameter.optional) {
                    this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
                  }
                  if (firstParameter.type === "RestElement") {
                    this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
                  }
                }
                if (method.typeAnnotation) {
                  this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
                }
              } else {
                method.kind = "method";
              }
              return this.finishNode(method, "TSMethodSignature");
            } else {
              const property = nodeAny;
              if (readonly)
                property.readonly = true;
              const type2 = this.tsTryParseTypeAnnotation();
              if (type2)
                property.typeAnnotation = type2;
              this.tsParseTypeMemberSemicolon();
              return this.finishNode(property, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const node2 = this.startNode();
            if (this.match(types$1.parenL) || this.isRelational("<")) {
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
            }
            if (this.match(types$1._new)) {
              const id = this.startNode();
              this.next();
              if (this.match(types$1.parenL) || this.isRelational("<")) {
                return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2);
              } else {
                node2.key = this.createIdentifier(id, "new");
                return this.tsParsePropertyOrMethodSignature(node2, false);
              }
            }
            this.tsParseModifiers(node2, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
            const idx = this.tsTryParseIndexSignature(node2);
            if (idx) {
              return idx;
            }
            this.parsePropertyName(node2, false);
            if (!node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier()) {
              node2.kind = node2.key.name;
              this.parsePropertyName(node2, false);
            }
            return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly);
          }
          tsParseTypeLiteral() {
            const node2 = this.startNode();
            node2.members = this.tsParseObjectTypeMembers();
            return this.finishNode(node2, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(types$1.braceL);
            const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            this.expect(types$1.braceR);
            return members;
          }
          tsIsStartOfMappedType() {
            this.next();
            if (this.eat(types$1.plusMin)) {
              return this.isContextual("readonly");
            }
            if (this.isContextual("readonly")) {
              this.next();
            }
            if (!this.match(types$1.bracketL)) {
              return false;
            }
            this.next();
            if (!this.tsIsIdentifier()) {
              return false;
            }
            this.next();
            return this.match(types$1._in);
          }
          tsParseMappedTypeParameter() {
            const node2 = this.startNode();
            node2.name = this.parseIdentifierName(node2.start);
            node2.constraint = this.tsExpectThenParseType(types$1._in);
            return this.finishNode(node2, "TSTypeParameter");
          }
          tsParseMappedType() {
            const node2 = this.startNode();
            this.expect(types$1.braceL);
            if (this.match(types$1.plusMin)) {
              node2.readonly = this.state.value;
              this.next();
              this.expectContextual("readonly");
            } else if (this.eatContextual("readonly")) {
              node2.readonly = true;
            }
            this.expect(types$1.bracketL);
            node2.typeParameter = this.tsParseMappedTypeParameter();
            node2.nameType = this.eatContextual("as") ? this.tsParseType() : null;
            this.expect(types$1.bracketR);
            if (this.match(types$1.plusMin)) {
              node2.optional = this.state.value;
              this.next();
              this.expect(types$1.question);
            } else if (this.eat(types$1.question)) {
              node2.optional = true;
            }
            node2.typeAnnotation = this.tsTryParseType();
            this.semicolon();
            this.expect(types$1.braceR);
            return this.finishNode(node2, "TSMappedType");
          }
          tsParseTupleType() {
            const node2 = this.startNode();
            node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let seenOptionalElement = false;
            let labeledElements = null;
            node2.elementTypes.forEach((elementNode) => {
              var _labeledElements;
              let {type: type2} = elementNode;
              if (seenOptionalElement && type2 !== "TSRestType" && type2 !== "TSOptionalType" && !(type2 === "TSNamedTupleMember" && elementNode.optional)) {
                this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
              }
              seenOptionalElement = seenOptionalElement || type2 === "TSNamedTupleMember" && elementNode.optional || type2 === "TSOptionalType";
              if (type2 === "TSRestType") {
                elementNode = elementNode.typeAnnotation;
                type2 = elementNode.type;
              }
              const isLabeled = type2 === "TSNamedTupleMember";
              labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;
              if (labeledElements !== isLabeled) {
                this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
              }
            });
            return this.finishNode(node2, "TSTupleType");
          }
          tsParseTupleElementType() {
            const {start: startPos, startLoc} = this.state;
            const rest = this.eat(types$1.ellipsis);
            let type2 = this.tsParseType();
            const optional = this.eat(types$1.question);
            const labeled = this.eat(types$1.colon);
            if (labeled) {
              const labeledNode = this.startNodeAtNode(type2);
              labeledNode.optional = optional;
              if (type2.type === "TSTypeReference" && !type2.typeParameters && type2.typeName.type === "Identifier") {
                labeledNode.label = type2.typeName;
              } else {
                this.raise(type2.start, TSErrors.InvalidTupleMemberLabel);
                labeledNode.label = type2;
              }
              labeledNode.elementType = this.tsParseType();
              type2 = this.finishNode(labeledNode, "TSNamedTupleMember");
            } else if (optional) {
              const optionalTypeNode = this.startNodeAtNode(type2);
              optionalTypeNode.typeAnnotation = type2;
              type2 = this.finishNode(optionalTypeNode, "TSOptionalType");
            }
            if (rest) {
              const restNode = this.startNodeAt(startPos, startLoc);
              restNode.typeAnnotation = type2;
              type2 = this.finishNode(restNode, "TSRestType");
            }
            return type2;
          }
          tsParseParenthesizedType() {
            const node2 = this.startNode();
            this.expect(types$1.parenL);
            node2.typeAnnotation = this.tsParseType();
            this.expect(types$1.parenR);
            return this.finishNode(node2, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(type2, abstract) {
            const node2 = this.startNode();
            if (type2 === "TSConstructorType") {
              node2.abstract = !!abstract;
              if (abstract)
                this.next();
              this.next();
            }
            this.tsFillSignature(types$1.arrow, node2);
            return this.finishNode(node2, type2);
          }
          tsParseLiteralTypeNode() {
            const node2 = this.startNode();
            node2.literal = (() => {
              switch (this.state.type) {
                case types$1.num:
                case types$1.bigint:
                case types$1.string:
                case types$1._true:
                case types$1._false:
                  return this.parseExprAtom();
                default:
                  throw this.unexpected();
              }
            })();
            return this.finishNode(node2, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const node2 = this.startNode();
            node2.literal = this.parseTemplate(false);
            return this.finishNode(node2, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            if (this.state.inType)
              return this.tsParseType();
            return super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const thisKeyword = this.tsParseThisTypeNode();
            if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
              return this.tsParseThisTypePredicate(thisKeyword);
            } else {
              return thisKeyword;
            }
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case types$1.name:
              case types$1._void:
              case types$1._null: {
                const type2 = this.match(types$1._void) ? "TSVoidKeyword" : this.match(types$1._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (type2 !== void 0 && this.lookaheadCharCode() !== 46) {
                  const node2 = this.startNode();
                  this.next();
                  return this.finishNode(node2, type2);
                }
                return this.tsParseTypeReference();
              }
              case types$1.string:
              case types$1.num:
              case types$1.bigint:
              case types$1._true:
              case types$1._false:
                return this.tsParseLiteralTypeNode();
              case types$1.plusMin:
                if (this.state.value === "-") {
                  const node2 = this.startNode();
                  const nextToken = this.lookahead();
                  if (nextToken.type !== types$1.num && nextToken.type !== types$1.bigint) {
                    throw this.unexpected();
                  }
                  node2.literal = this.parseMaybeUnary();
                  return this.finishNode(node2, "TSLiteralType");
                }
                break;
              case types$1._this:
                return this.tsParseThisTypeOrThisTypePredicate();
              case types$1._typeof:
                return this.tsParseTypeQuery();
              case types$1._import:
                return this.tsParseImportType();
              case types$1.braceL:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case types$1.bracketL:
                return this.tsParseTupleType();
              case types$1.parenL:
                return this.tsParseParenthesizedType();
              case types$1.backQuote:
                return this.tsParseTemplateLiteralType();
            }
            throw this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let type2 = this.tsParseNonArrayType();
            while (!this.hasPrecedingLineBreak() && this.eat(types$1.bracketL)) {
              if (this.match(types$1.bracketR)) {
                const node2 = this.startNodeAtNode(type2);
                node2.elementType = type2;
                this.expect(types$1.bracketR);
                type2 = this.finishNode(node2, "TSArrayType");
              } else {
                const node2 = this.startNodeAtNode(type2);
                node2.objectType = type2;
                node2.indexType = this.tsParseType();
                this.expect(types$1.bracketR);
                type2 = this.finishNode(node2, "TSIndexedAccessType");
              }
            }
            return type2;
          }
          tsParseTypeOperator(operator) {
            const node2 = this.startNode();
            this.expectContextual(operator);
            node2.operator = operator;
            node2.typeAnnotation = this.tsParseTypeOperatorOrHigher();
            if (operator === "readonly") {
              this.tsCheckTypeAnnotationForReadOnly(node2);
            }
            return this.finishNode(node2, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(node2) {
            switch (node2.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(node2.start, TSErrors.UnexpectedReadonly);
            }
          }
          tsParseInferType() {
            const node2 = this.startNode();
            this.expectContextual("infer");
            const typeParameter = this.startNode();
            typeParameter.name = this.parseIdentifierName(typeParameter.start);
            node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
            return this.finishNode(node2, "TSInferType");
          }
          tsParseTypeOperatorOrHigher() {
            const operator = ["keyof", "unique", "readonly"].find((kw) => this.isContextual(kw));
            return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
          }
          tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
            const node2 = this.startNode();
            const hasLeadingOperator = this.eat(operator);
            const types2 = [];
            do {
              types2.push(parseConstituentType());
            } while (this.eat(operator));
            if (types2.length === 1 && !hasLeadingOperator) {
              return types2[0];
            }
            node2.types = types2;
            return this.finishNode(node2, kind);
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types$1.bitwiseAND);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types$1.bitwiseOR);
          }
          tsIsStartOfFunctionType() {
            if (this.isRelational("<")) {
              return true;
            }
            return this.match(types$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (this.match(types$1.name) || this.match(types$1._this)) {
              this.next();
              return true;
            }
            if (this.match(types$1.braceL)) {
              let braceStackCounter = 1;
              this.next();
              while (braceStackCounter > 0) {
                if (this.match(types$1.braceL)) {
                  ++braceStackCounter;
                } else if (this.match(types$1.braceR)) {
                  --braceStackCounter;
                }
                this.next();
              }
              return true;
            }
            if (this.match(types$1.bracketL)) {
              let braceStackCounter = 1;
              this.next();
              while (braceStackCounter > 0) {
                if (this.match(types$1.bracketL)) {
                  ++braceStackCounter;
                } else if (this.match(types$1.bracketR)) {
                  --braceStackCounter;
                }
                this.next();
              }
              return true;
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            this.next();
            if (this.match(types$1.parenR) || this.match(types$1.ellipsis)) {
              return true;
            }
            if (this.tsSkipParameterStart()) {
              if (this.match(types$1.colon) || this.match(types$1.comma) || this.match(types$1.question) || this.match(types$1.eq)) {
                return true;
              }
              if (this.match(types$1.parenR)) {
                this.next();
                if (this.match(types$1.arrow)) {
                  return true;
                }
              }
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(returnToken) {
            return this.tsInType(() => {
              const t = this.startNode();
              this.expect(returnToken);
              const node2 = this.startNode();
              const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (asserts && this.match(types$1._this)) {
                let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                if (thisTypePredicate.type === "TSThisType") {
                  node2.parameterName = thisTypePredicate;
                  node2.asserts = true;
                  thisTypePredicate = this.finishNode(node2, "TSTypePredicate");
                } else {
                  this.resetStartLocationFromNode(thisTypePredicate, node2);
                  thisTypePredicate.asserts = true;
                }
                t.typeAnnotation = thisTypePredicate;
                return this.finishNode(t, "TSTypeAnnotation");
              }
              const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!typePredicateVariable) {
                if (!asserts) {
                  return this.tsParseTypeAnnotation(false, t);
                }
                node2.parameterName = this.parseIdentifier();
                node2.asserts = asserts;
                t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
                return this.finishNode(t, "TSTypeAnnotation");
              }
              const type2 = this.tsParseTypeAnnotation(false);
              node2.parameterName = typePredicateVariable;
              node2.typeAnnotation = type2;
              node2.asserts = asserts;
              t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
              return this.finishNode(t, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            return this.match(types$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types$1.colon) : void 0;
          }
          tsTryParseTypeAnnotation() {
            return this.match(types$1.colon) ? this.tsParseTypeAnnotation() : void 0;
          }
          tsTryParseType() {
            return this.tsEatThenParseType(types$1.colon);
          }
          tsParseTypePredicatePrefix() {
            const id = this.parseIdentifier();
            if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
              this.next();
              return id;
            }
          }
          tsParseTypePredicateAsserts() {
            if (!this.match(types$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
              return false;
            }
            const containsEsc = this.state.containsEsc;
            this.next();
            if (!this.match(types$1.name) && !this.match(types$1._this)) {
              return false;
            }
            if (containsEsc) {
              this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
            }
            return true;
          }
          tsParseTypeAnnotation(eatColon, t) {
            if (eatColon === void 0) {
              eatColon = true;
            }
            if (t === void 0) {
              t = this.startNode();
            }
            this.tsInType(() => {
              if (eatColon)
                this.expect(types$1.colon);
              t.typeAnnotation = this.tsParseType();
            });
            return this.finishNode(t, "TSTypeAnnotation");
          }
          tsParseType() {
            assert(this.state.inType);
            const type2 = this.tsParseNonConditionalType();
            if (this.hasPrecedingLineBreak() || !this.eat(types$1._extends)) {
              return type2;
            }
            const node2 = this.startNodeAtNode(type2);
            node2.checkType = type2;
            node2.extendsType = this.tsParseNonConditionalType();
            this.expect(types$1.question);
            node2.trueType = this.tsParseType();
            this.expect(types$1.colon);
            node2.falseType = this.tsParseType();
            return this.finishNode(node2, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual("abstract") && this.lookahead().type === types$1._new;
          }
          tsParseNonConditionalType() {
            if (this.tsIsStartOfFunctionType()) {
              return this.tsParseFunctionOrConstructorType("TSFunctionType");
            }
            if (this.match(types$1._new)) {
              return this.tsParseFunctionOrConstructorType("TSConstructorType");
            } else if (this.isAbstractConstructorSignature()) {
              return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
            }
            return this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            const node2 = this.startNode();
            const _const = this.tsTryNextParseConstantContext();
            node2.typeAnnotation = _const || this.tsNextThenParseType();
            this.expectRelational(">");
            node2.expression = this.parseMaybeUnary();
            return this.finishNode(node2, "TSTypeAssertion");
          }
          tsParseHeritageClause(descriptor) {
            const originalStart = this.state.start;
            const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
            if (!delimitedList.length) {
              this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
            }
            return delimitedList;
          }
          tsParseExpressionWithTypeArguments() {
            const node2 = this.startNode();
            node2.expression = this.tsParseEntityName(false);
            if (this.isRelational("<")) {
              node2.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node2, "TSExpressionWithTypeArguments");
          }
          tsParseInterfaceDeclaration(node2) {
            node2.id = this.parseIdentifier();
            this.checkLVal(node2.id, "typescript interface declaration", BIND_TS_INTERFACE);
            node2.typeParameters = this.tsTryParseTypeParameters();
            if (this.eat(types$1._extends)) {
              node2.extends = this.tsParseHeritageClause("extends");
            }
            const body = this.startNode();
            body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
            node2.body = this.finishNode(body, "TSInterfaceBody");
            return this.finishNode(node2, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(node2) {
            node2.id = this.parseIdentifier();
            this.checkLVal(node2.id, "typescript type alias", BIND_TS_TYPE);
            node2.typeParameters = this.tsTryParseTypeParameters();
            node2.typeAnnotation = this.tsInType(() => {
              this.expect(types$1.eq);
              if (this.isContextual("intrinsic") && this.lookahead().type !== types$1.dot) {
                const node3 = this.startNode();
                this.next();
                return this.finishNode(node3, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            });
            this.semicolon();
            return this.finishNode(node2, "TSTypeAliasDeclaration");
          }
          tsInNoContext(cb) {
            const oldContext = this.state.context;
            this.state.context = [oldContext[0]];
            try {
              return cb();
            } finally {
              this.state.context = oldContext;
            }
          }
          tsInType(cb) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            try {
              return cb();
            } finally {
              this.state.inType = oldInType;
            }
          }
          tsEatThenParseType(token) {
            return !this.match(token) ? void 0 : this.tsNextThenParseType();
          }
          tsExpectThenParseType(token) {
            return this.tsDoThenParseType(() => this.expect(token));
          }
          tsNextThenParseType() {
            return this.tsDoThenParseType(() => this.next());
          }
          tsDoThenParseType(cb) {
            return this.tsInType(() => {
              cb();
              return this.tsParseType();
            });
          }
          tsParseEnumMember() {
            const node2 = this.startNode();
            node2.id = this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
            if (this.eat(types$1.eq)) {
              node2.initializer = this.parseMaybeAssignAllowIn();
            }
            return this.finishNode(node2, "TSEnumMember");
          }
          tsParseEnumDeclaration(node2, isConst) {
            if (isConst)
              node2.const = true;
            node2.id = this.parseIdentifier();
            this.checkLVal(node2.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
            this.expect(types$1.braceL);
            node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
            this.expect(types$1.braceR);
            return this.finishNode(node2, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const node2 = this.startNode();
            this.scope.enter(SCOPE_OTHER);
            this.expect(types$1.braceL);
            this.parseBlockOrModuleBlockBody(node2.body = [], void 0, true, types$1.braceR);
            this.scope.exit();
            return this.finishNode(node2, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(node2, nested) {
            if (nested === void 0) {
              nested = false;
            }
            node2.id = this.parseIdentifier();
            if (!nested) {
              this.checkLVal(node2.id, "module or namespace declaration", BIND_TS_NAMESPACE);
            }
            if (this.eat(types$1.dot)) {
              const inner = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(inner, true);
              node2.body = inner;
            } else {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              node2.body = this.tsParseModuleBlock();
              this.prodParam.exit();
              this.scope.exit();
            }
            return this.finishNode(node2, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(node2) {
            if (this.isContextual("global")) {
              node2.global = true;
              node2.id = this.parseIdentifier();
            } else if (this.match(types$1.string)) {
              node2.id = this.parseExprAtom();
            } else {
              this.unexpected();
            }
            if (this.match(types$1.braceL)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              node2.body = this.tsParseModuleBlock();
              this.prodParam.exit();
              this.scope.exit();
            } else {
              this.semicolon();
            }
            return this.finishNode(node2, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(node2, isExport) {
            node2.isExport = isExport || false;
            node2.id = this.parseIdentifier();
            this.checkLVal(node2.id, "import equals declaration", BIND_LEXICAL);
            this.expect(types$1.eq);
            const moduleReference = this.tsParseModuleReference();
            if (node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
              this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
            }
            node2.moduleReference = moduleReference;
            this.semicolon();
            return this.finishNode(node2, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual("require") && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const node2 = this.startNode();
            this.expectContextual("require");
            this.expect(types$1.parenL);
            if (!this.match(types$1.string)) {
              throw this.unexpected();
            }
            node2.expression = this.parseExprAtom();
            this.expect(types$1.parenR);
            return this.finishNode(node2, "TSExternalModuleReference");
          }
          tsLookAhead(f) {
            const state = this.state.clone();
            const res = f();
            this.state = state;
            return res;
          }
          tsTryParseAndCatch(f) {
            const result = this.tryParse((abort) => f() || abort());
            if (result.aborted || !result.node)
              return void 0;
            if (result.error)
              this.state = result.failState;
            return result.node;
          }
          tsTryParse(f) {
            const state = this.state.clone();
            const result = f();
            if (result !== void 0 && result !== false) {
              return result;
            } else {
              this.state = state;
              return void 0;
            }
          }
          tsTryParseDeclare(nany) {
            if (this.isLineTerminator()) {
              return;
            }
            let starttype = this.state.type;
            let kind;
            if (this.isContextual("let")) {
              starttype = types$1._var;
              kind = "let";
            }
            return this.tsInAmbientContext(() => {
              switch (starttype) {
                case types$1._function:
                  nany.declare = true;
                  return this.parseFunctionStatement(nany, false, true);
                case types$1._class:
                  nany.declare = true;
                  return this.parseClass(nany, true, false);
                case types$1._const:
                  if (this.match(types$1._const) && this.isLookaheadContextual("enum")) {
                    this.expect(types$1._const);
                    this.expectContextual("enum");
                    return this.tsParseEnumDeclaration(nany, true);
                  }
                case types$1._var:
                  kind = kind || this.state.value;
                  return this.parseVarStatement(nany, kind);
                case types$1.name: {
                  const value = this.state.value;
                  if (value === "global") {
                    return this.tsParseAmbientExternalModuleDeclaration(nany);
                  } else {
                    return this.tsParseDeclaration(nany, value, true);
                  }
                }
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true);
          }
          tsParseExpressionStatement(node2, expr2) {
            switch (expr2.name) {
              case "declare": {
                const declaration = this.tsTryParseDeclare(node2);
                if (declaration) {
                  declaration.declare = true;
                  return declaration;
                }
                break;
              }
              case "global":
                if (this.match(types$1.braceL)) {
                  this.scope.enter(SCOPE_TS_MODULE);
                  this.prodParam.enter(PARAM);
                  const mod = node2;
                  mod.global = true;
                  mod.id = expr2;
                  mod.body = this.tsParseModuleBlock();
                  this.scope.exit();
                  this.prodParam.exit();
                  return this.finishNode(mod, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(node2, expr2.name, false);
            }
          }
          tsParseDeclaration(node2, value, next) {
            switch (value) {
              case "abstract":
                if (this.tsCheckLineTerminator(next) && (this.match(types$1._class) || this.match(types$1.name))) {
                  return this.tsParseAbstractDeclaration(node2);
                }
                break;
              case "enum":
                if (next || this.match(types$1.name)) {
                  if (next)
                    this.next();
                  return this.tsParseEnumDeclaration(node2, false);
                }
                break;
              case "interface":
                if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                  return this.tsParseInterfaceDeclaration(node2);
                }
                break;
              case "module":
                if (this.tsCheckLineTerminator(next)) {
                  if (this.match(types$1.string)) {
                    return this.tsParseAmbientExternalModuleDeclaration(node2);
                  } else if (this.match(types$1.name)) {
                    return this.tsParseModuleOrNamespaceDeclaration(node2);
                  }
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node2);
                }
                break;
              case "type":
                if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                  return this.tsParseTypeAliasDeclaration(node2);
                }
                break;
            }
          }
          tsCheckLineTerminator(next) {
            if (next) {
              if (this.hasFollowingLineBreak())
                return false;
              this.next();
              return true;
            }
            return !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
            if (!this.isRelational("<")) {
              return void 0;
            }
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const res = this.tsTryParseAndCatch(() => {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.typeParameters = this.tsParseTypeParameters();
              super.parseFunctionParams(node2);
              node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
              this.expect(types$1.arrow);
              return node2;
            });
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            if (!res) {
              return void 0;
            }
            return this.parseArrowExpression(res, null, true);
          }
          tsParseTypeArguments() {
            const node2 = this.startNode();
            node2.params = this.tsInType(() => this.tsInNoContext(() => {
              this.expectRelational("<");
              return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
            }));
            if (node2.params.length === 0) {
              this.raise(node2.start, TSErrors.EmptyTypeArguments);
            }
            this.state.exprAllowed = false;
            this.expectRelational(">");
            return this.finishNode(node2, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            if (this.match(types$1.name)) {
              switch (this.state.value) {
                case "abstract":
                case "declare":
                case "enum":
                case "interface":
                case "module":
                case "namespace":
                case "type":
                  return true;
              }
            }
            return false;
          }
          isExportDefaultSpecifier() {
            if (this.tsIsDeclarationStart())
              return false;
            return super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(allowModifiers, decorators) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let accessibility;
            let readonly = false;
            if (allowModifiers !== void 0) {
              accessibility = this.parseAccessModifier();
              readonly = !!this.tsParseModifier(["readonly"]);
              if (allowModifiers === false && (accessibility || readonly)) {
                this.raise(startPos, TSErrors.UnexpectedParameterModifier);
              }
            }
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left);
            const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
            if (accessibility || readonly) {
              const pp = this.startNodeAt(startPos, startLoc);
              if (decorators.length) {
                pp.decorators = decorators;
              }
              if (accessibility)
                pp.accessibility = accessibility;
              if (readonly)
                pp.readonly = readonly;
              if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
                this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
              }
              pp.parameter = elt;
              return this.finishNode(pp, "TSParameterProperty");
            }
            if (decorators.length) {
              left.decorators = decorators;
            }
            return elt;
          }
          parseFunctionBodyAndFinish(node2, type2, isMethod) {
            if (isMethod === void 0) {
              isMethod = false;
            }
            if (this.match(types$1.colon)) {
              node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
            }
            const bodilessType = type2 === "FunctionDeclaration" ? "TSDeclareFunction" : type2 === "ClassMethod" ? "TSDeclareMethod" : void 0;
            if (bodilessType && !this.match(types$1.braceL) && this.isLineTerminator()) {
              this.finishNode(node2, bodilessType);
              return;
            }
            if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
              this.raise(node2.start, TSErrors.DeclareFunctionHasImplementation);
              if (node2.declare) {
                super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod);
                return;
              }
            }
            super.parseFunctionBodyAndFinish(node2, type2, isMethod);
          }
          registerFunctionStatementId(node2) {
            if (!node2.body && node2.id) {
              this.checkLVal(node2.id, "function name", BIND_TS_AMBIENT);
            } else {
              super.registerFunctionStatementId(...arguments);
            }
          }
          tsCheckForInvalidTypeCasts(items) {
            items.forEach((node2) => {
              if ((node2 == null ? void 0 : node2.type) === "TSTypeCastExpression") {
                this.raise(node2.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
              }
            });
          }
          toReferencedList(exprList, isInParens) {
            this.tsCheckForInvalidTypeCasts(exprList);
            return exprList;
          }
          parseArrayLike() {
            const node2 = super.parseArrayLike(...arguments);
            if (node2.type === "ArrayExpression") {
              this.tsCheckForInvalidTypeCasts(node2.elements);
            }
            return node2;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            if (!this.hasPrecedingLineBreak() && this.match(types$1.bang)) {
              this.state.exprAllowed = false;
              this.next();
              const nonNullExpression = this.startNodeAt(startPos, startLoc);
              nonNullExpression.expression = base;
              return this.finishNode(nonNullExpression, "TSNonNullExpression");
            }
            if (this.isRelational("<")) {
              const result = this.tsTryParseAndCatch(() => {
                if (!noCalls && this.atPossibleAsyncArrow(base)) {
                  const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                  if (asyncArrowFn) {
                    return asyncArrowFn;
                  }
                }
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.callee = base;
                const typeArguments = this.tsParseTypeArguments();
                if (typeArguments) {
                  if (!noCalls && this.eat(types$1.parenL)) {
                    node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                    this.tsCheckForInvalidTypeCasts(node2.arguments);
                    node2.typeParameters = typeArguments;
                    if (state.optionalChainMember) {
                      node2.optional = false;
                    }
                    return this.finishCallExpression(node2, state.optionalChainMember);
                  } else if (this.match(types$1.backQuote)) {
                    const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                    result2.typeParameters = typeArguments;
                    return result2;
                  }
                }
                this.unexpected();
              });
              if (result)
                return result;
            }
            return super.parseSubscript(base, startPos, startLoc, noCalls, state);
          }
          parseNewArguments(node2) {
            if (this.isRelational("<")) {
              const typeParameters = this.tsTryParseAndCatch(() => {
                const args = this.tsParseTypeArguments();
                if (!this.match(types$1.parenL))
                  this.unexpected();
                return args;
              });
              if (typeParameters) {
                node2.typeParameters = typeParameters;
              }
            }
            super.parseNewArguments(node2);
          }
          parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
            if (nonNull(types$1._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
              const node2 = this.startNodeAt(leftStartPos, leftStartLoc);
              node2.expression = left;
              const _const = this.tsTryNextParseConstantContext();
              if (_const) {
                node2.typeAnnotation = _const;
              } else {
                node2.typeAnnotation = this.tsNextThenParseType();
              }
              this.finishNode(node2, "TSAsExpression");
              this.reScan_lt_gt();
              return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec);
            }
            return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          }
          checkDuplicateExports() {
          }
          parseImport(node2) {
            node2.importKind = "value";
            if (this.match(types$1.name) || this.match(types$1.star) || this.match(types$1.braceL)) {
              let ahead = this.lookahead();
              if (this.isContextual("type") && ahead.type !== types$1.comma && !(ahead.type === types$1.name && ahead.value === "from") && ahead.type !== types$1.eq) {
                node2.importKind = "type";
                this.next();
                ahead = this.lookahead();
              }
              if (this.match(types$1.name) && ahead.type === types$1.eq) {
                return this.tsParseImportEqualsDeclaration(node2);
              }
            }
            const importNode = super.parseImport(node2);
            if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
              this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
            }
            return importNode;
          }
          parseExport(node2) {
            if (this.match(types$1._import)) {
              this.next();
              if (this.isContextual("type") && this.lookaheadCharCode() !== 61) {
                node2.importKind = "type";
                this.next();
              } else {
                node2.importKind = "value";
              }
              return this.tsParseImportEqualsDeclaration(node2, true);
            } else if (this.eat(types$1.eq)) {
              const assign = node2;
              assign.expression = this.parseExpression();
              this.semicolon();
              return this.finishNode(assign, "TSExportAssignment");
            } else if (this.eatContextual("as")) {
              const decl = node2;
              this.expectContextual("namespace");
              decl.id = this.parseIdentifier();
              this.semicolon();
              return this.finishNode(decl, "TSNamespaceExportDeclaration");
            } else {
              if (this.isContextual("type") && this.lookahead().type === types$1.braceL) {
                this.next();
                node2.exportKind = "type";
              } else {
                node2.exportKind = "value";
              }
              return super.parseExport(node2);
            }
          }
          isAbstractClass() {
            return this.isContextual("abstract") && this.lookahead().type === types$1._class;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const cls = this.startNode();
              this.next();
              cls.abstract = true;
              this.parseClass(cls, true, true);
              return cls;
            }
            if (this.state.value === "interface") {
              const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
              if (result)
                return result;
            }
            return super.parseExportDefaultExpression();
          }
          parseStatementContent(context, topLevel) {
            if (this.state.type === types$1._const) {
              const ahead = this.lookahead();
              if (ahead.type === types$1.name && ahead.value === "enum") {
                const node2 = this.startNode();
                this.expect(types$1._const);
                this.expectContextual("enum");
                return this.tsParseEnumDeclaration(node2, true);
              }
            }
            return super.parseStatementContent(context, topLevel);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(member, modifiers) {
            return modifiers.some((modifier) => {
              if (tsIsAccessModifier(modifier)) {
                return member.accessibility === modifier;
              }
              return !!member[modifier];
            });
          }
          parseClassMember(classBody, member, state) {
            const invalidModifersForStaticBlocks = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
            this.tsParseModifiers(member, invalidModifersForStaticBlocks.concat(["static"]));
            const callParseClassMemberWithIsStatic = () => {
              const isStatic = !!member.static;
              if (isStatic && this.eat(types$1.braceL)) {
                if (this.tsHasSomeModifiers(member, invalidModifersForStaticBlocks)) {
                  this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);
                }
                this.parseClassStaticBlock(classBody, member);
              } else {
                this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
              }
            };
            if (member.declare) {
              this.tsInAmbientContext(callParseClassMemberWithIsStatic);
            } else {
              callParseClassMemberWithIsStatic();
            }
          }
          parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const idx = this.tsTryParseIndexSignature(member);
            if (idx) {
              classBody.body.push(idx);
              if (member.abstract) {
                this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
              }
              if (member.accessibility) {
                this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
              }
              if (member.declare) {
                this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
              }
              if (member.override) {
                this.raise(member.start, TSErrors.IndexSignatureHasOverride);
              }
              return;
            }
            if (!this.state.inAbstractClass && member.abstract) {
              this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
            }
            if (member.override) {
              if (!state.hadSuperClass) {
                this.raise(member.start, TSErrors.OverrideNotInSubClass);
              }
            }
            super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
          parsePostMemberNameModifiers(methodOrProp) {
            const optional = this.eat(types$1.question);
            if (optional)
              methodOrProp.optional = true;
            if (methodOrProp.readonly && this.match(types$1.parenL)) {
              this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
            }
            if (methodOrProp.declare && this.match(types$1.parenL)) {
              this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
            }
          }
          parseExpressionStatement(node2, expr2) {
            const decl = expr2.type === "Identifier" ? this.tsParseExpressionStatement(node2, expr2) : void 0;
            return decl || super.parseExpressionStatement(node2, expr2);
          }
          shouldParseExportDeclaration() {
            if (this.tsIsDeclarationStart())
              return true;
            return super.shouldParseExportDeclaration();
          }
          parseConditional(expr2, startPos, startLoc, refNeedsArrowPos) {
            if (!refNeedsArrowPos || !this.match(types$1.question)) {
              return super.parseConditional(expr2, startPos, startLoc, refNeedsArrowPos);
            }
            const result = this.tryParse(() => super.parseConditional(expr2, startPos, startLoc));
            if (!result.node) {
              refNeedsArrowPos.start = result.error.pos || this.state.start;
              return expr2;
            }
            if (result.error)
              this.state = result.failState;
            return result.node;
          }
          parseParenItem(node2, startPos, startLoc) {
            node2 = super.parseParenItem(node2, startPos, startLoc);
            if (this.eat(types$1.question)) {
              node2.optional = true;
              this.resetEndLocation(node2);
            }
            if (this.match(types$1.colon)) {
              const typeCastNode = this.startNodeAt(startPos, startLoc);
              typeCastNode.expression = node2;
              typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
              return this.finishNode(typeCastNode, "TSTypeCastExpression");
            }
            return node2;
          }
          parseExportDeclaration(node2) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const isDeclare = this.eatContextual("declare");
            if (isDeclare && (this.isContextual("declare") || !this.shouldParseExportDeclaration())) {
              throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
            }
            let declaration;
            if (this.match(types$1.name)) {
              declaration = this.tsTryParseExportDeclaration();
            }
            if (!declaration) {
              declaration = super.parseExportDeclaration(node2);
            }
            if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
              node2.exportKind = "type";
            }
            if (declaration && isDeclare) {
              this.resetStartLocation(declaration, startPos, startLoc);
              declaration.declare = true;
            }
            return declaration;
          }
          parseClassId(node2, isStatement, optionalId) {
            if ((!isStatement || optionalId) && this.isContextual("implements")) {
              return;
            }
            super.parseClassId(node2, isStatement, optionalId, node2.declare ? BIND_TS_AMBIENT : BIND_CLASS);
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters)
              node2.typeParameters = typeParameters;
          }
          parseClassPropertyAnnotation(node2) {
            if (!node2.optional && this.eat(types$1.bang)) {
              node2.definite = true;
            }
            const type2 = this.tsTryParseTypeAnnotation();
            if (type2)
              node2.typeAnnotation = type2;
          }
          parseClassProperty(node2) {
            this.parseClassPropertyAnnotation(node2);
            if (this.state.isAmbientContext && this.match(types$1.eq)) {
              this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
            }
            return super.parseClassProperty(node2);
          }
          parseClassPrivateProperty(node2) {
            if (node2.abstract) {
              this.raise(node2.start, TSErrors.PrivateElementHasAbstract);
            }
            if (node2.accessibility) {
              this.raise(node2.start, TSErrors.PrivateElementHasAccessibility, node2.accessibility);
            }
            this.parseClassPropertyAnnotation(node2);
            return super.parseClassPrivateProperty(node2);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters && isConstructor) {
              this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
            }
            if (method.declare && (method.kind === "get" || method.kind === "set")) {
              this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
            }
            if (typeParameters)
              method.typeParameters = typeParameters;
            super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters)
              method.typeParameters = typeParameters;
            super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          parseClassSuper(node2) {
            super.parseClassSuper(node2);
            if (node2.superClass && this.isRelational("<")) {
              node2.superTypeParameters = this.tsParseTypeArguments();
            }
            if (this.eatContextual("implements")) {
              node2.implements = this.tsParseHeritageClause("implements");
            }
          }
          parseObjPropValue(prop2) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters)
              prop2.typeParameters = typeParameters;
            for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
              args[_key10 - 1] = arguments[_key10];
            }
            super.parseObjPropValue(prop2, ...args);
          }
          parseFunctionParams(node2, allowModifiers) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters)
              node2.typeParameters = typeParameters;
            super.parseFunctionParams(node2, allowModifiers);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind);
            if (decl.id.type === "Identifier" && this.eat(types$1.bang)) {
              decl.definite = true;
            }
            const type2 = this.tsTryParseTypeAnnotation();
            if (type2) {
              decl.id.typeAnnotation = type2;
              this.resetEndLocation(decl.id);
            }
          }
          parseAsyncArrowFromCallExpression(node2, call) {
            if (this.match(types$1.colon)) {
              node2.returnType = this.tsParseTypeAnnotation();
            }
            return super.parseAsyncArrowFromCallExpression(node2, call);
          }
          parseMaybeAssign() {
            for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
              args[_key11] = arguments[_key11];
            }
            var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
            let state;
            let jsx2;
            let typeCast;
            if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
              state = this.state.clone();
              jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state);
              if (!jsx2.error)
                return jsx2.node;
              const {context} = this.state;
              if (context[context.length - 1] === types$1$1.j_oTag) {
                context.length -= 2;
              } else if (context[context.length - 1] === types$1$1.j_expr) {
                context.length -= 1;
              }
            }
            if (!((_jsx = jsx2) != null && _jsx.error) && !this.isRelational("<")) {
              return super.parseMaybeAssign(...args);
            }
            let typeParameters;
            state = state || this.state.clone();
            const arrow = this.tryParse((abort) => {
              var _expr$extra, _typeParameters;
              typeParameters = this.tsParseTypeParameters();
              const expr2 = super.parseMaybeAssign(...args);
              if (expr2.type !== "ArrowFunctionExpression" || (_expr$extra = expr2.extra) != null && _expr$extra.parenthesized) {
                abort();
              }
              if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
                this.resetStartLocationFromNode(expr2, typeParameters);
              }
              expr2.typeParameters = typeParameters;
              return expr2;
            }, state);
            if (!arrow.error && !arrow.aborted)
              return arrow.node;
            if (!jsx2) {
              assert(!this.hasPlugin("jsx"));
              typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
              if (!typeCast.error)
                return typeCast.node;
            }
            if ((_jsx2 = jsx2) != null && _jsx2.node) {
              this.state = jsx2.failState;
              return jsx2.node;
            }
            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }
            if ((_typeCast = typeCast) != null && _typeCast.node) {
              this.state = typeCast.failState;
              return typeCast.node;
            }
            if ((_jsx3 = jsx2) != null && _jsx3.thrown)
              throw jsx2.error;
            if (arrow.thrown)
              throw arrow.error;
            if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
              throw typeCast.error;
            throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
          }
          parseMaybeUnary(refExpressionErrors) {
            if (!this.hasPlugin("jsx") && this.isRelational("<")) {
              return this.tsParseTypeAssertion();
            } else {
              return super.parseMaybeUnary(refExpressionErrors);
            }
          }
          parseArrow(node2) {
            if (this.match(types$1.colon)) {
              const result = this.tryParse((abort) => {
                const returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
                if (this.canInsertSemicolon() || !this.match(types$1.arrow))
                  abort();
                return returnType;
              });
              if (result.aborted)
                return;
              if (!result.thrown) {
                if (result.error)
                  this.state = result.failState;
                node2.returnType = result.node;
              }
            }
            return super.parseArrow(node2);
          }
          parseAssignableListItemTypes(param) {
            if (this.eat(types$1.question)) {
              if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
                this.raise(param.start, TSErrors.PatternIsOptional);
              }
              param.optional = true;
            }
            const type2 = this.tsTryParseTypeAnnotation();
            if (type2)
              param.typeAnnotation = type2;
            this.resetEndLocation(param);
            return param;
          }
          toAssignable(node2, isLHS) {
            if (isLHS === void 0) {
              isLHS = false;
            }
            switch (node2.type) {
              case "TSTypeCastExpression":
                return super.toAssignable(this.typeCastToParameter(node2), isLHS);
              case "TSParameterProperty":
                return super.toAssignable(node2, isLHS);
              case "ParenthesizedExpression":
                return this.toAssignableParenthesizedExpression(node2, isLHS);
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                node2.expression = this.toAssignable(node2.expression, isLHS);
                return node2;
              default:
                return super.toAssignable(node2, isLHS);
            }
          }
          toAssignableParenthesizedExpression(node2, isLHS) {
            switch (node2.expression.type) {
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                node2.expression = this.toAssignable(node2.expression, isLHS);
                return node2;
              default:
                return super.toAssignable(node2, isLHS);
            }
          }
          checkLVal(expr2, contextDescription) {
            var _expr$extra2;
            for (var _len12 = arguments.length, args = new Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) {
              args[_key12 - 2] = arguments[_key12];
            }
            switch (expr2.type) {
              case "TSTypeCastExpression":
                return;
              case "TSParameterProperty":
                this.checkLVal(expr2.parameter, "parameter property", ...args);
                return;
              case "TSAsExpression":
              case "TSTypeAssertion":
                if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr2.extra) != null && _expr$extra2.parenthesized)) {
                  this.raise(expr2.start, ErrorMessages.InvalidLhs, contextDescription);
                  break;
                }
                this.checkLVal(expr2.expression, "parenthesized expression", ...args);
                return;
              case "TSNonNullExpression":
                this.checkLVal(expr2.expression, contextDescription, ...args);
                return;
              default:
                super.checkLVal(expr2, contextDescription, ...args);
                return;
            }
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case types$1._this:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseMaybeDecoratorArguments(expr2) {
            if (this.isRelational("<")) {
              const typeArguments = this.tsParseTypeArguments();
              if (this.match(types$1.parenL)) {
                const call = super.parseMaybeDecoratorArguments(expr2);
                call.typeParameters = typeArguments;
                return call;
              }
              this.unexpected(this.state.start, types$1.parenL);
            }
            return super.parseMaybeDecoratorArguments(expr2);
          }
          checkCommaAfterRest(close) {
            if (this.state.isAmbientContext && this.match(types$1.comma) && this.lookaheadCharCode() === close) {
              this.next();
            } else {
              super.checkCommaAfterRest(close);
            }
          }
          isClassMethod() {
            return this.isRelational("<") || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(types$1.bang) || this.match(types$1.colon) || super.isClassProperty();
          }
          parseMaybeDefault() {
            const node2 = super.parseMaybeDefault(...arguments);
            if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
              this.raise(node2.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
            }
            return node2;
          }
          getTokenFromCode(code) {
            if (this.state.inType && (code === 62 || code === 60)) {
              return this.finishOp(types$1.relational, 1);
            } else {
              return super.getTokenFromCode(code);
            }
          }
          reScan_lt_gt() {
            if (this.match(types$1.relational)) {
              const code = this.input.charCodeAt(this.state.start);
              if (code === 60 || code === 62) {
                this.state.pos -= 1;
                this.readToken_lt_gt(code);
              }
            }
          }
          toAssignableList(exprList) {
            for (let i = 0; i < exprList.length; i++) {
              const expr2 = exprList[i];
              if (!expr2)
                continue;
              switch (expr2.type) {
                case "TSTypeCastExpression":
                  exprList[i] = this.typeCastToParameter(expr2);
                  break;
                case "TSAsExpression":
                case "TSTypeAssertion":
                  if (!this.state.maybeInArrowParameters) {
                    exprList[i] = this.typeCastToParameter(expr2);
                  } else {
                    this.raise(expr2.start, TSErrors.UnexpectedTypeCastInParameter);
                  }
                  break;
              }
            }
            return super.toAssignableList(...arguments);
          }
          typeCastToParameter(node2) {
            node2.expression.typeAnnotation = node2.typeAnnotation;
            this.resetEndLocation(node2.expression, node2.typeAnnotation.end, node2.typeAnnotation.loc.end);
            return node2.expression;
          }
          shouldParseArrow() {
            return this.match(types$1.colon) || super.shouldParseArrow();
          }
          shouldParseAsyncArrow() {
            return this.match(types$1.colon) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(node2) {
            if (this.isRelational("<")) {
              const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
              if (typeArguments)
                node2.typeParameters = typeArguments;
            }
            return super.jsxParseOpeningElementAfterName(node2);
          }
          getGetterSetterExpectedParamCount(method) {
            const baseCount = super.getGetterSetterExpectedParamCount(method);
            const params = this.getObjectOrClassMethodParams(method);
            const firstParam = params[0];
            const hasContextParam = firstParam && this.isThisParam(firstParam);
            return hasContextParam ? baseCount + 1 : baseCount;
          }
          parseCatchClauseParam() {
            const param = super.parseCatchClauseParam();
            const type2 = this.tsTryParseTypeAnnotation();
            if (type2) {
              param.typeAnnotation = type2;
              this.resetEndLocation(param);
            }
            return param;
          }
          tsInAmbientContext(cb) {
            const oldIsAmbientContext = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
              return cb();
            } finally {
              this.state.isAmbientContext = oldIsAmbientContext;
            }
          }
          parseClass(node2) {
            const oldInAbstractClass = this.state.inAbstractClass;
            this.state.inAbstractClass = !!node2.abstract;
            try {
              for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
                args[_key13 - 1] = arguments[_key13];
              }
              return super.parseClass(node2, ...args);
            } finally {
              this.state.inAbstractClass = oldInAbstractClass;
            }
          }
          tsParseAbstractDeclaration(node2) {
            if (this.match(types$1._class)) {
              node2.abstract = true;
              return this.parseClass(node2, true, false);
            } else if (this.isContextual("interface")) {
              if (!this.hasFollowingLineBreak()) {
                node2.abstract = true;
                this.raise(node2.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
                this.next();
                return this.tsParseInterfaceDeclaration(node2);
              }
            } else {
              this.unexpected(null, types$1._class);
            }
          }
          parseMethod() {
            const method = super.parseMethod(...arguments);
            if (method.abstract) {
              const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
              if (hasBody) {
                const {key} = method;
                this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === "Identifier" ? key.name : `[${this.input.slice(key.start, key.end)}]`);
              }
            }
            return method;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            if (this.shouldParseAsAmbientContext()) {
              this.state.isAmbientContext = true;
            }
            return super.parse();
          }
          getExpression() {
            if (this.shouldParseAsAmbientContext()) {
              this.state.isAmbientContext = true;
            }
            return super.getExpression();
          }
        };
        types$1.placeholder = new TokenType("%%", {startsExpr: true});
        const PlaceHolderErrors = makeErrorTemplates({ClassNameIsRequired: "A class name is required."}, ErrorCodes.SyntaxError);
        var placeholders = (superClass) => class extends superClass {
          parsePlaceholder(expectedNode) {
            if (this.match(types$1.placeholder)) {
              const node2 = this.startNode();
              this.next();
              this.assertNoSpace("Unexpected space in placeholder.");
              node2.name = super.parseIdentifier(true);
              this.assertNoSpace("Unexpected space in placeholder.");
              this.expect(types$1.placeholder);
              return this.finishPlaceholder(node2, expectedNode);
            }
          }
          finishPlaceholder(node2, expectedNode) {
            const isFinished = !!(node2.expectedNode && node2.type === "Placeholder");
            node2.expectedNode = expectedNode;
            return isFinished ? node2 : this.finishNode(node2, "Placeholder");
          }
          getTokenFromCode(code) {
            if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
              return this.finishOp(types$1.placeholder, 2);
            }
            return super.getTokenFromCode(...arguments);
          }
          parseExprAtom() {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
          }
          parseIdentifier() {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
          }
          checkReservedWord(word) {
            if (word !== void 0)
              super.checkReservedWord(...arguments);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
          }
          checkLVal(expr2) {
            if (expr2.type !== "Placeholder")
              super.checkLVal(...arguments);
          }
          toAssignable(node2) {
            if (node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression") {
              node2.expectedNode = "Pattern";
              return node2;
            }
            return super.toAssignable(...arguments);
          }
          isLet(context) {
            if (super.isLet(context)) {
              return true;
            }
            if (!this.isContextual("let")) {
              return false;
            }
            if (context)
              return false;
            const nextToken = this.lookahead();
            if (nextToken.type === types$1.placeholder) {
              return true;
            }
            return false;
          }
          verifyBreakContinue(node2) {
            if (node2.label && node2.label.type === "Placeholder")
              return;
            super.verifyBreakContinue(...arguments);
          }
          parseExpressionStatement(node2, expr2) {
            if (expr2.type !== "Placeholder" || expr2.extra && expr2.extra.parenthesized) {
              return super.parseExpressionStatement(...arguments);
            }
            if (this.match(types$1.colon)) {
              const stmt = node2;
              stmt.label = this.finishPlaceholder(expr2, "Identifier");
              this.next();
              stmt.body = this.parseStatement("label");
              return this.finishNode(stmt, "LabeledStatement");
            }
            this.semicolon();
            node2.name = expr2.name;
            return this.finishPlaceholder(node2, "Statement");
          }
          parseBlock() {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
          }
          parseFunctionId() {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
          }
          parseClass(node2, isStatement, optionalId) {
            const type2 = isStatement ? "ClassDeclaration" : "ClassExpression";
            this.next();
            this.takeDecorators(node2);
            const oldStrict = this.state.strict;
            const placeholder = this.parsePlaceholder("Identifier");
            if (placeholder) {
              if (this.match(types$1._extends) || this.match(types$1.placeholder) || this.match(types$1.braceL)) {
                node2.id = placeholder;
              } else if (optionalId || !isStatement) {
                node2.id = null;
                node2.body = this.finishPlaceholder(placeholder, "ClassBody");
                return this.finishNode(node2, type2);
              } else {
                this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
              }
            } else {
              this.parseClassId(node2, isStatement, optionalId);
            }
            this.parseClassSuper(node2);
            node2.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node2.superClass, oldStrict);
            return this.finishNode(node2, type2);
          }
          parseExport(node2) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder)
              return super.parseExport(...arguments);
            if (!this.isContextual("from") && !this.match(types$1.comma)) {
              node2.specifiers = [];
              node2.source = null;
              node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
              return this.finishNode(node2, "ExportNamedDeclaration");
            }
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = placeholder;
            node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
            return super.parseExport(node2);
          }
          isExportDefaultSpecifier() {
            if (this.match(types$1._default)) {
              const next = this.nextTokenStart();
              if (this.isUnparsedContextual(next, "from")) {
                if (this.input.startsWith(types$1.placeholder.label, this.nextTokenStartSince(next + 4))) {
                  return true;
                }
              }
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(node2) {
            if (node2.specifiers && node2.specifiers.length > 0) {
              return true;
            }
            return super.maybeParseExportDefaultSpecifier(...arguments);
          }
          checkExport(node2) {
            const {specifiers} = node2;
            if (specifiers != null && specifiers.length) {
              node2.specifiers = specifiers.filter((node3) => node3.exported.type === "Placeholder");
            }
            super.checkExport(node2);
            node2.specifiers = specifiers;
          }
          parseImport(node2) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder)
              return super.parseImport(...arguments);
            node2.specifiers = [];
            if (!this.isContextual("from") && !this.match(types$1.comma)) {
              node2.source = this.finishPlaceholder(placeholder, "StringLiteral");
              this.semicolon();
              return this.finishNode(node2, "ImportDeclaration");
            }
            const specifier = this.startNodeAtNode(placeholder);
            specifier.local = placeholder;
            this.finishNode(specifier, "ImportDefaultSpecifier");
            node2.specifiers.push(specifier);
            if (this.eat(types$1.comma)) {
              const hasStarImport = this.maybeParseStarImportSpecifier(node2);
              if (!hasStarImport)
                this.parseNamedImportSpecifiers(node2);
            }
            this.expectContextual("from");
            node2.source = this.parseImportSource();
            this.semicolon();
            return this.finishNode(node2, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
          }
        };
        var v8intrinsic = (superClass) => class extends superClass {
          parseV8Intrinsic() {
            if (this.match(types$1.modulo)) {
              const v8IntrinsicStart = this.state.start;
              const node2 = this.startNode();
              this.eat(types$1.modulo);
              if (this.match(types$1.name)) {
                const name = this.parseIdentifierName(this.state.start);
                const identifier = this.createIdentifier(node2, name);
                identifier.type = "V8IntrinsicIdentifier";
                if (this.match(types$1.parenL)) {
                  return identifier;
                }
              }
              this.unexpected(v8IntrinsicStart);
            }
          }
          parseExprAtom() {
            return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
          }
        };
        function hasPlugin(plugins, name) {
          return plugins.some((plugin) => {
            if (Array.isArray(plugin)) {
              return plugin[0] === name;
            } else {
              return plugin === name;
            }
          });
        }
        function getPluginOption(plugins, name, option) {
          const plugin = plugins.find((plugin2) => {
            if (Array.isArray(plugin2)) {
              return plugin2[0] === name;
            } else {
              return plugin2 === name;
            }
          });
          if (plugin && Array.isArray(plugin)) {
            return plugin[1][option];
          }
          return null;
        }
        const PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
        const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
        function validatePlugins(plugins) {
          if (hasPlugin(plugins, "decorators")) {
            if (hasPlugin(plugins, "decorators-legacy")) {
              throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            }
            const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
            if (decoratorsBeforeExport == null) {
              throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
            } else if (typeof decoratorsBeforeExport !== "boolean") {
              throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
          }
          if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
            throw new Error("Cannot combine flow and typescript plugins.");
          }
          if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
          }
          if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
            throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map((p) => `'${p}'`).join(", "));
          }
          if (hasPlugin(plugins, "moduleAttributes")) {
            if (hasPlugin(plugins, "importAssertions")) {
              throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            }
            const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
            if (moduleAttributesVerionPluginOption !== "may-2020") {
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
          }
          if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
            throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
          }
          if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
            const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            error.missingPlugins = "doExpressions";
            throw error;
          }
        }
        const mixinPlugins = {estree, jsx, flow, typescript, v8intrinsic, placeholders};
        const mixinPluginNames = Object.keys(mixinPlugins);
        const defaultOptions = {sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false};
        function getOptions(opts) {
          const options2 = {};
          for (const key of Object.keys(defaultOptions)) {
            options2[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
          }
          return options2;
        }
        class State {
          constructor() {
            this.strict = void 0;
            this.curLine = void 0;
            this.startLoc = void 0;
            this.endLoc = void 0;
            this.errors = [];
            this.potentialArrowAt = -1;
            this.noArrowAt = [];
            this.noArrowParamsConversionAt = [];
            this.maybeInArrowParameters = false;
            this.inPipeline = false;
            this.inType = false;
            this.noAnonFunctionType = false;
            this.inPropertyName = false;
            this.hasFlowComment = false;
            this.isIterator = false;
            this.isAmbientContext = false;
            this.inAbstractClass = false;
            this.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
            this.soloAwait = false;
            this.inFSharpPipelineDirectBody = false;
            this.labels = [];
            this.decoratorStack = [[]];
            this.comments = [];
            this.trailingComments = [];
            this.leadingComments = [];
            this.commentStack = [];
            this.commentPreviousNode = null;
            this.pos = 0;
            this.lineStart = 0;
            this.type = types$1.eof;
            this.value = null;
            this.start = 0;
            this.end = 0;
            this.lastTokEndLoc = null;
            this.lastTokStartLoc = null;
            this.lastTokStart = 0;
            this.lastTokEnd = 0;
            this.context = [types$1$1.braceStatement];
            this.exprAllowed = true;
            this.containsEsc = false;
            this.strictErrors = new Map();
            this.exportedIdentifiers = [];
            this.tokensLength = 0;
          }
          init(options2) {
            this.strict = options2.strictMode === false ? false : options2.sourceType === "module";
            this.curLine = options2.startLine;
            this.startLoc = this.endLoc = this.curPosition();
          }
          curPosition() {
            return new Position(this.curLine, this.pos - this.lineStart);
          }
          clone(skipArrays) {
            const state = new State();
            const keys = Object.keys(this);
            for (let i = 0, length = keys.length; i < length; i++) {
              const key = keys[i];
              let val = this[key];
              if (!skipArrays && Array.isArray(val)) {
                val = val.slice();
              }
              state[key] = val;
            }
            return state;
          }
        }
        var _isDigit = function isDigit(code) {
          return code >= 48 && code <= 57;
        };
        const VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
        const forbiddenNumericSeparatorSiblings = {decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120]};
        const allowedNumericSeparatorSiblings = {};
        allowedNumericSeparatorSiblings.bin = [48, 49];
        allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
        allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
        allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
        class Token {
          constructor(state) {
            this.type = state.type;
            this.value = state.value;
            this.start = state.start;
            this.end = state.end;
            this.loc = new SourceLocation(state.startLoc, state.endLoc);
          }
        }
        class Tokenizer extends ParserError {
          constructor(options2, input) {
            super();
            this.isLookahead = void 0;
            this.tokens = [];
            this.state = new State();
            this.state.init(options2);
            this.input = input;
            this.length = input.length;
            this.isLookahead = false;
          }
          pushToken(token) {
            this.tokens.length = this.state.tokensLength;
            this.tokens.push(token);
            ++this.state.tokensLength;
          }
          next() {
            if (!this.isLookahead) {
              this.checkKeywordEscapes();
              if (this.options.tokens) {
                this.pushToken(new Token(this.state));
              }
            }
            this.state.lastTokEnd = this.state.end;
            this.state.lastTokStart = this.state.start;
            this.state.lastTokEndLoc = this.state.endLoc;
            this.state.lastTokStartLoc = this.state.startLoc;
            this.nextToken();
          }
          eat(type2) {
            if (this.match(type2)) {
              this.next();
              return true;
            } else {
              return false;
            }
          }
          match(type2) {
            return this.state.type === type2;
          }
          lookahead() {
            const old = this.state;
            this.state = old.clone(true);
            this.isLookahead = true;
            this.next();
            this.isLookahead = false;
            const curr = this.state;
            this.state = old;
            return curr;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(pos) {
            skipWhiteSpace.lastIndex = pos;
            const skip = skipWhiteSpace.exec(this.input);
            return pos + skip[0].length;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          setStrict(strict) {
            this.state.strict = strict;
            if (strict) {
              this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));
              this.state.strictErrors.clear();
            }
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            const curContext = this.curContext();
            if (!(curContext != null && curContext.preserveSpace))
              this.skipSpace();
            this.state.start = this.state.pos;
            this.state.startLoc = this.state.curPosition();
            if (this.state.pos >= this.length) {
              this.finishToken(types$1.eof);
              return;
            }
            const override = curContext == null ? void 0 : curContext.override;
            if (override) {
              override(this);
            } else {
              this.getTokenFromCode(this.input.codePointAt(this.state.pos));
            }
          }
          pushComment(block, text2, start, end, startLoc, endLoc) {
            const comment2 = {type: block ? "CommentBlock" : "CommentLine", value: text2, start, end, loc: new SourceLocation(startLoc, endLoc)};
            if (this.options.tokens)
              this.pushToken(comment2);
            this.state.comments.push(comment2);
            this.addComment(comment2);
          }
          skipBlockComment() {
            const startLoc = this.state.curPosition();
            const start = this.state.pos;
            const end = this.input.indexOf("*/", this.state.pos + 2);
            if (end === -1)
              throw this.raise(start, ErrorMessages.UnterminatedComment);
            this.state.pos = end + 2;
            lineBreakG.lastIndex = start;
            let match;
            while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
              ++this.state.curLine;
              this.state.lineStart = match.index + match[0].length;
            }
            if (this.isLookahead)
              return;
            this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
          }
          skipLineComment(startSkip) {
            const start = this.state.pos;
            const startLoc = this.state.curPosition();
            let ch = this.input.charCodeAt(this.state.pos += startSkip);
            if (this.state.pos < this.length) {
              while (!isNewLine(ch) && ++this.state.pos < this.length) {
                ch = this.input.charCodeAt(this.state.pos);
              }
            }
            if (this.isLookahead)
              return;
            this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
          }
          skipSpace() {
            loop:
              while (this.state.pos < this.length) {
                const ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                      ++this.state.pos;
                    }
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos;
                    ++this.state.curLine;
                    this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42:
                        this.skipBlockComment();
                        break;
                      case 47:
                        this.skipLineComment(2);
                        break;
                      default:
                        break loop;
                    }
                    break;
                  default:
                    if (isWhitespace(ch)) {
                      ++this.state.pos;
                    } else {
                      break loop;
                    }
                }
              }
          }
          finishToken(type2, val) {
            this.state.end = this.state.pos;
            this.state.endLoc = this.state.curPosition();
            const prevType = this.state.type;
            this.state.type = type2;
            this.state.value = val;
            if (!this.isLookahead)
              this.updateContext(prevType);
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter()) {
              return;
            }
            const nextPos = this.state.pos + 1;
            const next = this.input.charCodeAt(nextPos);
            if (next >= 48 && next <= 57) {
              throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
            }
            if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
              this.expectPlugin("recordAndTuple");
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
                throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
              }
              if (next === 123) {
                this.finishToken(types$1.braceHashL);
              } else {
                this.finishToken(types$1.bracketHashL);
              }
              this.state.pos += 2;
            } else {
              this.finishOp(types$1.hash, 1);
            }
          }
          readToken_dot() {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next >= 48 && next <= 57) {
              this.readNumber(true);
              return;
            }
            if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
              this.state.pos += 3;
              this.finishToken(types$1.ellipsis);
            } else {
              ++this.state.pos;
              this.finishToken(types$1.dot);
            }
          }
          readToken_slash() {
            if (this.state.exprAllowed && !this.state.inType) {
              ++this.state.pos;
              this.readRegexp();
              return;
            }
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 61) {
              this.finishOp(types$1.assign, 2);
            } else {
              this.finishOp(types$1.slash, 1);
            }
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return false;
            let ch = this.input.charCodeAt(this.state.pos + 1);
            if (ch !== 33)
              return false;
            const start = this.state.pos;
            this.state.pos += 1;
            while (!isNewLine(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
            const value = this.input.slice(start + 2, this.state.pos);
            this.finishToken(types$1.interpreterDirective, value);
            return true;
          }
          readToken_mult_modulo(code) {
            let type2 = code === 42 ? types$1.star : types$1.modulo;
            let width = 1;
            let next = this.input.charCodeAt(this.state.pos + 1);
            const exprAllowed = this.state.exprAllowed;
            if (code === 42 && next === 42) {
              width++;
              next = this.input.charCodeAt(this.state.pos + 2);
              type2 = types$1.exponent;
            }
            if (next === 61 && !exprAllowed) {
              width++;
              type2 = types$1.assign;
            }
            this.finishOp(type2, width);
          }
          readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === code) {
              if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                this.finishOp(types$1.assign, 3);
              } else {
                this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
              }
              return;
            }
            if (code === 124) {
              if (next === 62) {
                this.finishOp(types$1.pipeline, 2);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && next === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
                }
                this.finishOp(types$1.braceBarR, 2);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && next === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
                }
                this.finishOp(types$1.bracketBarR, 2);
                return;
              }
            }
            if (next === 61) {
              this.finishOp(types$1.assign, 2);
              return;
            }
            this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
          }
          readToken_caret() {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 61) {
              this.finishOp(types$1.assign, 2);
            } else {
              this.finishOp(types$1.bitwiseXOR, 1);
            }
          }
          readToken_plus_min(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === code) {
              if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {
                this.skipLineComment(3);
                this.skipSpace();
                this.nextToken();
                return;
              }
              this.finishOp(types$1.incDec, 2);
              return;
            }
            if (next === 61) {
              this.finishOp(types$1.assign, 2);
            } else {
              this.finishOp(types$1.plusMin, 1);
            }
          }
          readToken_lt_gt(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            let size = 1;
            if (next === code) {
              size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
              if (this.input.charCodeAt(this.state.pos + size) === 61) {
                this.finishOp(types$1.assign, size + 1);
                return;
              }
              this.finishOp(types$1.bitShift, size);
              return;
            }
            if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
              this.skipLineComment(4);
              this.skipSpace();
              this.nextToken();
              return;
            }
            if (next === 61) {
              size = 2;
            }
            this.finishOp(types$1.relational, size);
          }
          readToken_eq_excl(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 61) {
              this.finishOp(types$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              return;
            }
            if (code === 61 && next === 62) {
              this.state.pos += 2;
              this.finishToken(types$1.arrow);
              return;
            }
            this.finishOp(code === 61 ? types$1.eq : types$1.bang, 1);
          }
          readToken_question() {
            const next = this.input.charCodeAt(this.state.pos + 1);
            const next2 = this.input.charCodeAt(this.state.pos + 2);
            if (next === 63) {
              if (next2 === 61) {
                this.finishOp(types$1.assign, 3);
              } else {
                this.finishOp(types$1.nullishCoalescing, 2);
              }
            } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
              this.state.pos += 2;
              this.finishToken(types$1.questionDot);
            } else {
              ++this.state.pos;
              this.finishToken(types$1.question);
            }
          }
          getTokenFromCode(code) {
            switch (code) {
              case 46:
                this.readToken_dot();
                return;
              case 40:
                ++this.state.pos;
                this.finishToken(types$1.parenL);
                return;
              case 41:
                ++this.state.pos;
                this.finishToken(types$1.parenR);
                return;
              case 59:
                ++this.state.pos;
                this.finishToken(types$1.semi);
                return;
              case 44:
                ++this.state.pos;
                this.finishToken(types$1.comma);
                return;
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                    throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
                  }
                  this.finishToken(types$1.bracketBarL);
                  this.state.pos += 2;
                } else {
                  ++this.state.pos;
                  this.finishToken(types$1.bracketL);
                }
                return;
              case 93:
                ++this.state.pos;
                this.finishToken(types$1.bracketR);
                return;
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                    throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
                  }
                  this.finishToken(types$1.braceBarL);
                  this.state.pos += 2;
                } else {
                  ++this.state.pos;
                  this.finishToken(types$1.braceL);
                }
                return;
              case 125:
                ++this.state.pos;
                this.finishToken(types$1.braceR);
                return;
              case 58:
                if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                  this.finishOp(types$1.doubleColon, 2);
                } else {
                  ++this.state.pos;
                  this.finishToken(types$1.colon);
                }
                return;
              case 63:
                this.readToken_question();
                return;
              case 96:
                ++this.state.pos;
                this.finishToken(types$1.backQuote);
                return;
              case 48: {
                const next = this.input.charCodeAt(this.state.pos + 1);
                if (next === 120 || next === 88) {
                  this.readRadixNumber(16);
                  return;
                }
                if (next === 111 || next === 79) {
                  this.readRadixNumber(8);
                  return;
                }
                if (next === 98 || next === 66) {
                  this.readRadixNumber(2);
                  return;
                }
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                this.readNumber(false);
                return;
              case 34:
              case 39:
                this.readString(code);
                return;
              case 47:
                this.readToken_slash();
                return;
              case 37:
              case 42:
                this.readToken_mult_modulo(code);
                return;
              case 124:
              case 38:
                this.readToken_pipe_amp(code);
                return;
              case 94:
                this.readToken_caret();
                return;
              case 43:
              case 45:
                this.readToken_plus_min(code);
                return;
              case 60:
              case 62:
                this.readToken_lt_gt(code);
                return;
              case 61:
              case 33:
                this.readToken_eq_excl(code);
                return;
              case 126:
                this.finishOp(types$1.tilde, 1);
                return;
              case 64:
                ++this.state.pos;
                this.finishToken(types$1.at);
                return;
              case 35:
                this.readToken_numberSign();
                return;
              case 92:
                this.readWord();
                return;
              default:
                if (isIdentifierStart(code)) {
                  this.readWord();
                  return;
                }
            }
            throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
          }
          finishOp(type2, size) {
            const str = this.input.slice(this.state.pos, this.state.pos + size);
            this.state.pos += size;
            this.finishToken(type2, str);
          }
          readRegexp() {
            const start = this.state.pos;
            let escaped, inClass;
            for (; ; ) {
              if (this.state.pos >= this.length) {
                throw this.raise(start, ErrorMessages.UnterminatedRegExp);
              }
              const ch = this.input.charAt(this.state.pos);
              if (lineBreak.test(ch)) {
                throw this.raise(start, ErrorMessages.UnterminatedRegExp);
              }
              if (escaped) {
                escaped = false;
              } else {
                if (ch === "[") {
                  inClass = true;
                } else if (ch === "]" && inClass) {
                  inClass = false;
                } else if (ch === "/" && !inClass) {
                  break;
                }
                escaped = ch === "\\";
              }
              ++this.state.pos;
            }
            const content = this.input.slice(start, this.state.pos);
            ++this.state.pos;
            let mods = "";
            while (this.state.pos < this.length) {
              const char = this.input[this.state.pos];
              const charCode = this.input.codePointAt(this.state.pos);
              if (VALID_REGEX_FLAGS.has(char)) {
                if (mods.indexOf(char) > -1) {
                  this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);
                }
              } else if (isIdentifierChar(charCode) || charCode === 92) {
                this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);
              } else {
                break;
              }
              ++this.state.pos;
              mods += char;
            }
            this.finishToken(types$1.regexp, {pattern: content, flags: mods});
          }
          readInt(radix, len, forceLen, allowNumSeparator) {
            if (allowNumSeparator === void 0) {
              allowNumSeparator = true;
            }
            const start = this.state.pos;
            const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
            const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
            let invalid = false;
            let total = 0;
            for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
              const code = this.input.charCodeAt(this.state.pos);
              let val;
              if (code === 95) {
                const prev = this.input.charCodeAt(this.state.pos - 1);
                const next = this.input.charCodeAt(this.state.pos + 1);
                if (allowedSiblings.indexOf(next) === -1) {
                  this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
                } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
                  this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
                }
                if (!allowNumSeparator) {
                  this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
                }
                ++this.state.pos;
                continue;
              }
              if (code >= 97) {
                val = code - 97 + 10;
              } else if (code >= 65) {
                val = code - 65 + 10;
              } else if (_isDigit(code)) {
                val = code - 48;
              } else {
                val = Infinity;
              }
              if (val >= radix) {
                if (this.options.errorRecovery && val <= 9) {
                  val = 0;
                  this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
                } else if (forceLen) {
                  val = 0;
                  invalid = true;
                } else {
                  break;
                }
              }
              ++this.state.pos;
              total = total * radix + val;
            }
            if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
              return null;
            }
            return total;
          }
          readRadixNumber(radix) {
            const start = this.state.pos;
            let isBigInt = false;
            this.state.pos += 2;
            const val = this.readInt(radix);
            if (val == null) {
              this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
            }
            const next = this.input.charCodeAt(this.state.pos);
            if (next === 110) {
              ++this.state.pos;
              isBigInt = true;
            } else if (next === 109) {
              throw this.raise(start, ErrorMessages.InvalidDecimal);
            }
            if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
              throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
            }
            if (isBigInt) {
              const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(types$1.bigint, str);
              return;
            }
            this.finishToken(types$1.num, val);
          }
          readNumber(startsWithDot) {
            const start = this.state.pos;
            let isFloat = false;
            let isBigInt = false;
            let isDecimal = false;
            let hasExponent = false;
            let isOctal = false;
            if (!startsWithDot && this.readInt(10) === null) {
              this.raise(start, ErrorMessages.InvalidNumber);
            }
            const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
            if (hasLeadingZero) {
              const integer = this.input.slice(start, this.state.pos);
              this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);
              if (!this.state.strict) {
                const underscorePos = integer.indexOf("_");
                if (underscorePos > 0) {
                  this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
                }
              }
              isOctal = hasLeadingZero && !/[89]/.test(integer);
            }
            let next = this.input.charCodeAt(this.state.pos);
            if (next === 46 && !isOctal) {
              ++this.state.pos;
              this.readInt(10);
              isFloat = true;
              next = this.input.charCodeAt(this.state.pos);
            }
            if ((next === 69 || next === 101) && !isOctal) {
              next = this.input.charCodeAt(++this.state.pos);
              if (next === 43 || next === 45) {
                ++this.state.pos;
              }
              if (this.readInt(10) === null) {
                this.raise(start, ErrorMessages.InvalidOrMissingExponent);
              }
              isFloat = true;
              hasExponent = true;
              next = this.input.charCodeAt(this.state.pos);
            }
            if (next === 110) {
              if (isFloat || hasLeadingZero) {
                this.raise(start, ErrorMessages.InvalidBigIntLiteral);
              }
              ++this.state.pos;
              isBigInt = true;
            }
            if (next === 109) {
              this.expectPlugin("decimal", this.state.pos);
              if (hasExponent || hasLeadingZero) {
                this.raise(start, ErrorMessages.InvalidDecimal);
              }
              ++this.state.pos;
              isDecimal = true;
            }
            if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
              throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
            }
            const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
            if (isBigInt) {
              this.finishToken(types$1.bigint, str);
              return;
            }
            if (isDecimal) {
              this.finishToken(types$1.decimal, str);
              return;
            }
            const val = isOctal ? parseInt(str, 8) : parseFloat(str);
            this.finishToken(types$1.num, val);
          }
          readCodePoint(throwOnInvalid) {
            const ch = this.input.charCodeAt(this.state.pos);
            let code;
            if (ch === 123) {
              const codePos = ++this.state.pos;
              code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
              ++this.state.pos;
              if (code !== null && code > 1114111) {
                if (throwOnInvalid) {
                  this.raise(codePos, ErrorMessages.InvalidCodePoint);
                } else {
                  return null;
                }
              }
            } else {
              code = this.readHexChar(4, false, throwOnInvalid);
            }
            return code;
          }
          readString(quote) {
            let out = "", chunkStart = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) {
                throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
              }
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === quote)
                break;
              if (ch === 92) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.readEscapedChar(false);
                chunkStart = this.state.pos;
              } else if (ch === 8232 || ch === 8233) {
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
              } else if (isNewLine(ch)) {
                throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
              } else {
                ++this.state.pos;
              }
            }
            out += this.input.slice(chunkStart, this.state.pos++);
            this.finishToken(types$1.string, out);
          }
          readTmplToken() {
            let out = "", chunkStart = this.state.pos, containsInvalid = false;
            for (; ; ) {
              if (this.state.pos >= this.length) {
                throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
              }
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
                if (this.state.pos === this.state.start && this.match(types$1.template)) {
                  if (ch === 36) {
                    this.state.pos += 2;
                    this.finishToken(types$1.dollarBraceL);
                    return;
                  } else {
                    ++this.state.pos;
                    this.finishToken(types$1.backQuote);
                    return;
                  }
                }
                out += this.input.slice(chunkStart, this.state.pos);
                this.finishToken(types$1.template, containsInvalid ? null : out);
                return;
              }
              if (ch === 92) {
                out += this.input.slice(chunkStart, this.state.pos);
                const escaped = this.readEscapedChar(true);
                if (escaped === null) {
                  containsInvalid = true;
                } else {
                  out += escaped;
                }
                chunkStart = this.state.pos;
              } else if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                ++this.state.pos;
                switch (ch) {
                  case 13:
                    if (this.input.charCodeAt(this.state.pos) === 10) {
                      ++this.state.pos;
                    }
                  case 10:
                    out += "\n";
                    break;
                  default:
                    out += String.fromCharCode(ch);
                    break;
                }
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
            }
          }
          recordStrictModeErrors(pos, message) {
            if (this.state.strict && !this.state.strictErrors.has(pos)) {
              this.raise(pos, message);
            } else {
              this.state.strictErrors.set(pos, message);
            }
          }
          readEscapedChar(inTemplate) {
            const throwOnInvalid = !inTemplate;
            const ch = this.input.charCodeAt(++this.state.pos);
            ++this.state.pos;
            switch (ch) {
              case 110:
                return "\n";
              case 114:
                return "\r";
              case 120: {
                const code = this.readHexChar(2, false, throwOnInvalid);
                return code === null ? null : String.fromCharCode(code);
              }
              case 117: {
                const code = this.readCodePoint(throwOnInvalid);
                return code === null ? null : String.fromCodePoint(code);
              }
              case 116:
                return "	";
              case 98:
                return "\b";
              case 118:
                return "\v";
              case 102:
                return "\f";
              case 13:
                if (this.input.charCodeAt(this.state.pos) === 10) {
                  ++this.state.pos;
                }
              case 10:
                this.state.lineStart = this.state.pos;
                ++this.state.curLine;
              case 8232:
              case 8233:
                return "";
              case 56:
              case 57:
                if (inTemplate) {
                  return null;
                } else {
                  this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
                }
              default:
                if (ch >= 48 && ch <= 55) {
                  const codePos = this.state.pos - 1;
                  const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
                  let octalStr = match[0];
                  let octal = parseInt(octalStr, 8);
                  if (octal > 255) {
                    octalStr = octalStr.slice(0, -1);
                    octal = parseInt(octalStr, 8);
                  }
                  this.state.pos += octalStr.length - 1;
                  const next = this.input.charCodeAt(this.state.pos);
                  if (octalStr !== "0" || next === 56 || next === 57) {
                    if (inTemplate) {
                      return null;
                    } else {
                      this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
                    }
                  }
                  return String.fromCharCode(octal);
                }
                return String.fromCharCode(ch);
            }
          }
          readHexChar(len, forceLen, throwOnInvalid) {
            const codePos = this.state.pos;
            const n2 = this.readInt(16, len, forceLen, false);
            if (n2 === null) {
              if (throwOnInvalid) {
                this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
              } else {
                this.state.pos = codePos - 1;
              }
            }
            return n2;
          }
          readWord1() {
            let word = "";
            this.state.containsEsc = false;
            const start = this.state.pos;
            let chunkStart = this.state.pos;
            while (this.state.pos < this.length) {
              const ch = this.input.codePointAt(this.state.pos);
              if (isIdentifierChar(ch)) {
                this.state.pos += ch <= 65535 ? 1 : 2;
              } else if (this.state.isIterator && ch === 64) {
                ++this.state.pos;
              } else if (ch === 92) {
                this.state.containsEsc = true;
                word += this.input.slice(chunkStart, this.state.pos);
                const escStart = this.state.pos;
                const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                  this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
                  continue;
                }
                ++this.state.pos;
                const esc = this.readCodePoint(true);
                if (esc !== null) {
                  if (!identifierCheck(esc)) {
                    this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
                  }
                  word += String.fromCodePoint(esc);
                }
                chunkStart = this.state.pos;
              } else {
                break;
              }
            }
            return word + this.input.slice(chunkStart, this.state.pos);
          }
          isIterator(word) {
            return word === "@@iterator" || word === "@@asyncIterator";
          }
          readWord() {
            const word = this.readWord1();
            const type2 = keywords.get(word) || types$1.name;
            if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
              this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);
            }
            this.finishToken(type2, word);
          }
          checkKeywordEscapes() {
            const kw = this.state.type.keyword;
            if (kw && this.state.containsEsc) {
              this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
            }
          }
          braceIsBlock(prevType) {
            const parent = this.curContext();
            if (parent === types$1$1.functionExpression || parent === types$1$1.functionStatement) {
              return true;
            }
            if (prevType === types$1.colon && (parent === types$1$1.braceStatement || parent === types$1$1.braceExpression)) {
              return !parent.isExpr;
            }
            if (prevType === types$1._return || prevType === types$1.name && this.state.exprAllowed) {
              return this.hasPrecedingLineBreak();
            }
            if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
              return true;
            }
            if (prevType === types$1.braceL) {
              return parent === types$1$1.braceStatement;
            }
            if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
              return false;
            }
            if (prevType === types$1.relational) {
              return true;
            }
            return !this.state.exprAllowed;
          }
          updateContext(prevType) {
            const type2 = this.state.type;
            let update;
            if (type2.keyword && (prevType === types$1.dot || prevType === types$1.questionDot)) {
              this.state.exprAllowed = false;
            } else if (update = type2.updateContext) {
              update.call(this, prevType);
            } else {
              this.state.exprAllowed = type2.beforeExpr;
            }
          }
        }
        class ClassScope {
          constructor() {
            this.privateNames = new Set();
            this.loneAccessors = new Map();
            this.undefinedPrivateNames = new Map();
          }
        }
        class ClassScopeHandler {
          constructor(raise) {
            this.stack = [];
            this.undefinedPrivateNames = new Map();
            this.raise = raise;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new ClassScope());
          }
          exit() {
            const oldClassScope = this.stack.pop();
            const current = this.current();
            for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {
              if (current) {
                if (!current.undefinedPrivateNames.has(name)) {
                  current.undefinedPrivateNames.set(name, pos);
                }
              } else {
                this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
              }
            }
          }
          declarePrivateName(name, elementType, pos) {
            const classScope = this.current();
            let redefined = classScope.privateNames.has(name);
            if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
              const accessor = redefined && classScope.loneAccessors.get(name);
              if (accessor) {
                const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
                const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
                const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
                const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
                redefined = oldKind === newKind || oldStatic !== newStatic;
                if (!redefined)
                  classScope.loneAccessors.delete(name);
              } else if (!redefined) {
                classScope.loneAccessors.set(name, elementType);
              }
            }
            if (redefined) {
              this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
            }
            classScope.privateNames.add(name);
            classScope.undefinedPrivateNames.delete(name);
          }
          usePrivateName(name, pos) {
            let classScope;
            for (classScope of this.stack) {
              if (classScope.privateNames.has(name))
                return;
            }
            if (classScope) {
              classScope.undefinedPrivateNames.set(name, pos);
            } else {
              this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
            }
          }
        }
        const kExpression = 0, kMaybeArrowParameterDeclaration = 1, kMaybeAsyncArrowParameterDeclaration = 2, kParameterDeclaration = 3;
        class ExpressionScope {
          constructor(type2) {
            if (type2 === void 0) {
              type2 = kExpression;
            }
            this.type = void 0;
            this.type = type2;
          }
          canBeArrowParameterDeclaration() {
            return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
          }
          isCertainlyParameterDeclaration() {
            return this.type === kParameterDeclaration;
          }
        }
        class ArrowHeadParsingScope extends ExpressionScope {
          constructor(type2) {
            super(type2);
            this.errors = new Map();
          }
          recordDeclarationError(pos, template2) {
            this.errors.set(pos, template2);
          }
          clearDeclarationError(pos) {
            this.errors.delete(pos);
          }
          iterateErrors(iterator) {
            this.errors.forEach(iterator);
          }
        }
        class ExpressionScopeHandler {
          constructor(raise) {
            this.stack = [new ExpressionScope()];
            this.raise = raise;
          }
          enter(scope2) {
            this.stack.push(scope2);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(pos, template2) {
            const {stack} = this;
            let i = stack.length - 1;
            let scope2 = stack[i];
            while (!scope2.isCertainlyParameterDeclaration()) {
              if (scope2.canBeArrowParameterDeclaration()) {
                scope2.recordDeclarationError(pos, template2);
              } else {
                return;
              }
              scope2 = stack[--i];
            }
            this.raise(pos, template2);
          }
          recordParenthesizedIdentifierError(pos, template2) {
            const {stack} = this;
            const scope2 = stack[stack.length - 1];
            if (scope2.isCertainlyParameterDeclaration()) {
              this.raise(pos, template2);
            } else if (scope2.canBeArrowParameterDeclaration()) {
              scope2.recordDeclarationError(pos, template2);
            } else {
              return;
            }
          }
          recordAsyncArrowParametersError(pos, template2) {
            const {stack} = this;
            let i = stack.length - 1;
            let scope2 = stack[i];
            while (scope2.canBeArrowParameterDeclaration()) {
              if (scope2.type === kMaybeAsyncArrowParameterDeclaration) {
                scope2.recordDeclarationError(pos, template2);
              }
              scope2 = stack[--i];
            }
          }
          validateAsPattern() {
            const {stack} = this;
            const currentScope = stack[stack.length - 1];
            if (!currentScope.canBeArrowParameterDeclaration())
              return;
            currentScope.iterateErrors((template2, pos) => {
              this.raise(pos, template2);
              let i = stack.length - 2;
              let scope2 = stack[i];
              while (scope2.canBeArrowParameterDeclaration()) {
                scope2.clearDeclarationError(pos);
                scope2 = stack[--i];
              }
            });
          }
        }
        function newParameterDeclarationScope() {
          return new ExpressionScope(kParameterDeclaration);
        }
        function newArrowHeadScope() {
          return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
        }
        function newAsyncArrowScope() {
          return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
        }
        function newExpressionScope() {
          return new ExpressionScope();
        }
        class UtilParser extends Tokenizer {
          addExtra(node2, key, val) {
            if (!node2)
              return;
            const extra = node2.extra = node2.extra || {};
            extra[key] = val;
          }
          isRelational(op) {
            return this.match(types$1.relational) && this.state.value === op;
          }
          expectRelational(op) {
            if (this.isRelational(op)) {
              this.next();
            } else {
              this.unexpected(null, types$1.relational);
            }
          }
          isContextual(name) {
            return this.match(types$1.name) && this.state.value === name && !this.state.containsEsc;
          }
          isUnparsedContextual(nameStart, name) {
            const nameEnd = nameStart + name.length;
            return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
          }
          isLookaheadContextual(name) {
            const next = this.nextTokenStart();
            return this.isUnparsedContextual(next, name);
          }
          eatContextual(name) {
            return this.isContextual(name) && this.eat(types$1.name);
          }
          expectContextual(name, template2) {
            if (!this.eatContextual(name))
              this.unexpected(null, template2);
          }
          canInsertSemicolon() {
            return this.match(types$1.eof) || this.match(types$1.braceR) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
          }
          hasFollowingLineBreak() {
            return lineBreak.test(this.input.slice(this.state.end, this.nextTokenStart()));
          }
          isLineTerminator() {
            return this.eat(types$1.semi) || this.canInsertSemicolon();
          }
          semicolon(allowAsi) {
            if (allowAsi === void 0) {
              allowAsi = true;
            }
            if (allowAsi ? this.isLineTerminator() : this.eat(types$1.semi))
              return;
            this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
          }
          expect(type2, pos) {
            this.eat(type2) || this.unexpected(pos, type2);
          }
          assertNoSpace(message) {
            if (message === void 0) {
              message = "Unexpected space.";
            }
            if (this.state.start > this.state.lastTokEnd) {
              this.raise(this.state.lastTokEnd, {code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedSpace", template: message});
            }
          }
          unexpected(pos, messageOrType) {
            if (messageOrType === void 0) {
              messageOrType = {code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token"};
            }
            if (messageOrType instanceof TokenType) {
              messageOrType = {code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedToken", template: `Unexpected token, expected "${messageOrType.label}"`};
            }
            throw this.raise(pos != null ? pos : this.state.start, messageOrType);
          }
          expectPlugin(name, pos) {
            if (!this.hasPlugin(name)) {
              throw this.raiseWithData(pos != null ? pos : this.state.start, {missingPlugin: [name]}, `This experimental syntax requires enabling the parser plugin: '${name}'`);
            }
            return true;
          }
          expectOnePlugin(names, pos) {
            if (!names.some((n2) => this.hasPlugin(n2))) {
              throw this.raiseWithData(pos != null ? pos : this.state.start, {missingPlugin: names}, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
            }
          }
          tryParse(fn, oldState) {
            if (oldState === void 0) {
              oldState = this.state.clone();
            }
            const abortSignal = {node: null};
            try {
              const node2 = fn(function(node3) {
                if (node3 === void 0) {
                  node3 = null;
                }
                abortSignal.node = node3;
                throw abortSignal;
              });
              if (this.state.errors.length > oldState.errors.length) {
                const failState = this.state;
                this.state = oldState;
                return {node: node2, error: failState.errors[oldState.errors.length], thrown: false, aborted: false, failState};
              }
              return {node: node2, error: null, thrown: false, aborted: false, failState: null};
            } catch (error) {
              const failState = this.state;
              this.state = oldState;
              if (error instanceof SyntaxError) {
                return {node: null, error, thrown: true, aborted: false, failState};
              }
              if (error === abortSignal) {
                return {node: abortSignal.node, error: null, thrown: false, aborted: true, failState};
              }
              throw error;
            }
          }
          checkExpressionErrors(refExpressionErrors, andThrow) {
            if (!refExpressionErrors)
              return false;
            const {shorthandAssign, doubleProto} = refExpressionErrors;
            if (!andThrow)
              return shorthandAssign >= 0 || doubleProto >= 0;
            if (shorthandAssign >= 0) {
              this.unexpected(shorthandAssign);
            }
            if (doubleProto >= 0) {
              this.raise(doubleProto, ErrorMessages.DuplicateProto);
            }
          }
          isLiteralPropertyName() {
            return this.match(types$1.name) || !!this.state.type.keyword || this.match(types$1.string) || this.match(types$1.num) || this.match(types$1.bigint) || this.match(types$1.decimal);
          }
          isPrivateName(node2) {
            return node2.type === "PrivateName";
          }
          getPrivateNameSV(node2) {
            return node2.id.name;
          }
          hasPropertyAsPrivateName(node2) {
            return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
          }
          isOptionalChain(node2) {
            return node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression";
          }
          isObjectProperty(node2) {
            return node2.type === "ObjectProperty";
          }
          isObjectMethod(node2) {
            return node2.type === "ObjectMethod";
          }
          initializeScopes(inModule) {
            if (inModule === void 0) {
              inModule = this.options.sourceType === "module";
            }
            const oldLabels = this.state.labels;
            this.state.labels = [];
            const oldExportedIdentifiers = this.state.exportedIdentifiers;
            this.state.exportedIdentifiers = [];
            const oldInModule = this.inModule;
            this.inModule = inModule;
            const oldScope = this.scope;
            const ScopeHandler2 = this.getScopeHandler();
            this.scope = new ScopeHandler2(this.raise.bind(this), this.inModule);
            const oldProdParam = this.prodParam;
            this.prodParam = new ProductionParameterHandler();
            const oldClassScope = this.classScope;
            this.classScope = new ClassScopeHandler(this.raise.bind(this));
            const oldExpressionScope = this.expressionScope;
            this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
            return () => {
              this.state.labels = oldLabels;
              this.state.exportedIdentifiers = oldExportedIdentifiers;
              this.inModule = oldInModule;
              this.scope = oldScope;
              this.prodParam = oldProdParam;
              this.classScope = oldClassScope;
              this.expressionScope = oldExpressionScope;
            };
          }
          enterInitialScopes() {
            let paramFlags = PARAM;
            if (this.hasPlugin("topLevelAwait") && this.inModule) {
              paramFlags |= PARAM_AWAIT;
            }
            this.scope.enter(SCOPE_PROGRAM);
            this.prodParam.enter(paramFlags);
          }
        }
        class ExpressionErrors {
          constructor() {
            this.shorthandAssign = -1;
            this.doubleProto = -1;
          }
        }
        class Node2 {
          constructor(parser2, pos, loc) {
            this.type = void 0;
            this.start = void 0;
            this.end = void 0;
            this.loc = void 0;
            this.range = void 0;
            this.leadingComments = void 0;
            this.trailingComments = void 0;
            this.innerComments = void 0;
            this.extra = void 0;
            this.type = "";
            this.start = pos;
            this.end = 0;
            this.loc = new SourceLocation(loc);
            if (parser2 != null && parser2.options.ranges)
              this.range = [pos, 0];
            if (parser2 != null && parser2.filename)
              this.loc.filename = parser2.filename;
          }
          __clone() {
            const newNode = new Node2();
            const keys = Object.keys(this);
            for (let i = 0, length = keys.length; i < length; i++) {
              const key = keys[i];
              if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
                newNode[key] = this[key];
              }
            }
            return newNode;
          }
        }
        class NodeUtils extends UtilParser {
          startNode() {
            return new Node2(this, this.state.start, this.state.startLoc);
          }
          startNodeAt(pos, loc) {
            return new Node2(this, pos, loc);
          }
          startNodeAtNode(type2) {
            return this.startNodeAt(type2.start, type2.loc.start);
          }
          finishNode(node2, type2) {
            return this.finishNodeAt(node2, type2, this.state.lastTokEnd, this.state.lastTokEndLoc);
          }
          finishNodeAt(node2, type2, pos, loc) {
            node2.type = type2;
            node2.end = pos;
            node2.loc.end = loc;
            if (this.options.ranges)
              node2.range[1] = pos;
            this.processComment(node2);
            return node2;
          }
          resetStartLocation(node2, start, startLoc) {
            node2.start = start;
            node2.loc.start = startLoc;
            if (this.options.ranges)
              node2.range[0] = start;
          }
          resetEndLocation(node2, end, endLoc) {
            if (end === void 0) {
              end = this.state.lastTokEnd;
            }
            if (endLoc === void 0) {
              endLoc = this.state.lastTokEndLoc;
            }
            node2.end = end;
            node2.loc.end = endLoc;
            if (this.options.ranges)
              node2.range[1] = end;
          }
          resetStartLocationFromNode(node2, locationNode) {
            this.resetStartLocation(node2, locationNode.start, locationNode.loc.start);
          }
        }
        const unwrapParenthesizedExpression = (node2) => {
          return node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
        };
        class LValParser extends NodeUtils {
          toAssignable(node2, isLHS) {
            if (isLHS === void 0) {
              isLHS = false;
            }
            var _node$extra, _node$extra3;
            let parenthesized = void 0;
            if (node2.type === "ParenthesizedExpression" || (_node$extra = node2.extra) != null && _node$extra.parenthesized) {
              parenthesized = unwrapParenthesizedExpression(node2);
              if (isLHS) {
                if (parenthesized.type === "Identifier") {
                  this.expressionScope.recordParenthesizedIdentifierError(node2.start, ErrorMessages.InvalidParenthesizedAssignment);
                } else if (parenthesized.type !== "MemberExpression") {
                  this.raise(node2.start, ErrorMessages.InvalidParenthesizedAssignment);
                }
              } else {
                this.raise(node2.start, ErrorMessages.InvalidParenthesizedAssignment);
              }
            }
            switch (node2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
                break;
              case "ObjectExpression":
                node2.type = "ObjectPattern";
                for (let i = 0, length = node2.properties.length, last2 = length - 1; i < length; i++) {
                  var _node$extra2;
                  const prop2 = node2.properties[i];
                  const isLast = i === last2;
                  this.toAssignableObjectExpressionProp(prop2, isLast, isLHS);
                  if (isLast && prop2.type === "RestElement" && (_node$extra2 = node2.extra) != null && _node$extra2.trailingComma) {
                    this.raiseRestNotLast(node2.extra.trailingComma);
                  }
                }
                break;
              case "ObjectProperty":
                this.toAssignable(node2.value, isLHS);
                break;
              case "SpreadElement": {
                this.checkToRestConversion(node2);
                node2.type = "RestElement";
                const arg = node2.argument;
                this.toAssignable(arg, isLHS);
                break;
              }
              case "ArrayExpression":
                node2.type = "ArrayPattern";
                this.toAssignableList(node2.elements, (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
                break;
              case "AssignmentExpression":
                if (node2.operator !== "=") {
                  this.raise(node2.left.end, ErrorMessages.MissingEqInAssignment);
                }
                node2.type = "AssignmentPattern";
                delete node2.operator;
                this.toAssignable(node2.left, isLHS);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(parenthesized, isLHS);
                break;
            }
            return node2;
          }
          toAssignableObjectExpressionProp(prop2, isLast, isLHS) {
            if (prop2.type === "ObjectMethod") {
              const error = prop2.kind === "get" || prop2.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
              this.raise(prop2.key.start, error);
            } else if (prop2.type === "SpreadElement" && !isLast) {
              this.raiseRestNotLast(prop2.start);
            } else {
              this.toAssignable(prop2, isLHS);
            }
          }
          toAssignableList(exprList, trailingCommaPos, isLHS) {
            let end = exprList.length;
            if (end) {
              const last2 = exprList[end - 1];
              if ((last2 == null ? void 0 : last2.type) === "RestElement") {
                --end;
              } else if ((last2 == null ? void 0 : last2.type) === "SpreadElement") {
                last2.type = "RestElement";
                let arg = last2.argument;
                this.toAssignable(arg, isLHS);
                arg = unwrapParenthesizedExpression(arg);
                if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
                  this.unexpected(arg.start);
                }
                if (trailingCommaPos) {
                  this.raiseTrailingCommaAfterRest(trailingCommaPos);
                }
                --end;
              }
            }
            for (let i = 0; i < end; i++) {
              const elt = exprList[i];
              if (elt) {
                this.toAssignable(elt, isLHS);
                if (elt.type === "RestElement") {
                  this.raiseRestNotLast(elt.start);
                }
              }
            }
            return exprList;
          }
          toReferencedList(exprList, isParenthesizedExpr) {
            return exprList;
          }
          toReferencedListDeep(exprList, isParenthesizedExpr) {
            this.toReferencedList(exprList, isParenthesizedExpr);
            for (const expr2 of exprList) {
              if ((expr2 == null ? void 0 : expr2.type) === "ArrayExpression") {
                this.toReferencedListDeep(expr2.elements);
              }
            }
          }
          parseSpread(refExpressionErrors, refNeedsArrowPos) {
            const node2 = this.startNode();
            this.next();
            node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos);
            return this.finishNode(node2, "SpreadElement");
          }
          parseRestBinding() {
            const node2 = this.startNode();
            this.next();
            node2.argument = this.parseBindingAtom();
            return this.finishNode(node2, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case types$1.bracketL: {
                const node2 = this.startNode();
                this.next();
                node2.elements = this.parseBindingList(types$1.bracketR, 93, true);
                return this.finishNode(node2, "ArrayPattern");
              }
              case types$1.braceL:
                return this.parseObjectLike(types$1.braceR, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
            const elts = [];
            let first = true;
            while (!this.eat(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(types$1.comma);
              }
              if (allowEmpty && this.match(types$1.comma)) {
                elts.push(null);
              } else if (this.eat(close)) {
                break;
              } else if (this.match(types$1.ellipsis)) {
                elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
                this.checkCommaAfterRest(closeCharCode);
                this.expect(close);
                break;
              } else {
                const decorators = [];
                if (this.match(types$1.at) && this.hasPlugin("decorators")) {
                  this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
                }
                while (this.match(types$1.at)) {
                  decorators.push(this.parseDecorator());
                }
                elts.push(this.parseAssignableListItem(allowModifiers, decorators));
              }
            }
            return elts;
          }
          parseAssignableListItem(allowModifiers, decorators) {
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left);
            const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
            if (decorators.length) {
              left.decorators = decorators;
            }
            return elt;
          }
          parseAssignableListItemTypes(param) {
            return param;
          }
          parseMaybeDefault(startPos, startLoc, left) {
            var _startLoc, _startPos, _left;
            startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
            startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
            left = (_left = left) != null ? _left : this.parseBindingAtom();
            if (!this.eat(types$1.eq))
              return left;
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.left = left;
            node2.right = this.parseMaybeAssignAllowIn();
            return this.finishNode(node2, "AssignmentPattern");
          }
          checkLVal(expr2, contextDescription, bindingType, checkClashes, disallowLetBinding, strictModeChanged) {
            if (bindingType === void 0) {
              bindingType = BIND_NONE;
            }
            if (strictModeChanged === void 0) {
              strictModeChanged = false;
            }
            switch (expr2.type) {
              case "Identifier": {
                const {name} = expr2;
                if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
                  this.raise(expr2.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
                }
                if (checkClashes) {
                  if (checkClashes.has(name)) {
                    this.raise(expr2.start, ErrorMessages.ParamDupe);
                  } else {
                    checkClashes.add(name);
                  }
                }
                if (disallowLetBinding && name === "let") {
                  this.raise(expr2.start, ErrorMessages.LetInLexicalBinding);
                }
                if (!(bindingType & BIND_NONE)) {
                  this.scope.declareName(name, bindingType, expr2.start);
                }
                break;
              }
              case "MemberExpression":
                if (bindingType !== BIND_NONE) {
                  this.raise(expr2.start, ErrorMessages.InvalidPropertyBindingPattern);
                }
                break;
              case "ObjectPattern":
                for (let prop2 of expr2.properties) {
                  if (this.isObjectProperty(prop2))
                    prop2 = prop2.value;
                  else if (this.isObjectMethod(prop2))
                    continue;
                  this.checkLVal(prop2, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
                }
                break;
              case "ArrayPattern":
                for (const elem of expr2.elements) {
                  if (elem) {
                    this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
                  }
                }
                break;
              case "AssignmentPattern":
                this.checkLVal(expr2.left, "assignment pattern", bindingType, checkClashes);
                break;
              case "RestElement":
                this.checkLVal(expr2.argument, "rest element", bindingType, checkClashes);
                break;
              case "ParenthesizedExpression":
                this.checkLVal(expr2.expression, "parenthesized expression", bindingType, checkClashes);
                break;
              default: {
                this.raise(expr2.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
              }
            }
          }
          checkToRestConversion(node2) {
            if (node2.argument.type !== "Identifier" && node2.argument.type !== "MemberExpression") {
              this.raise(node2.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
            }
          }
          checkCommaAfterRest(close) {
            if (this.match(types$1.comma)) {
              if (this.lookaheadCharCode() === close) {
                this.raiseTrailingCommaAfterRest(this.state.start);
              } else {
                this.raiseRestNotLast(this.state.start);
              }
            }
          }
          raiseRestNotLast(pos) {
            throw this.raise(pos, ErrorMessages.ElementAfterRest);
          }
          raiseTrailingCommaAfterRest(pos) {
            this.raise(pos, ErrorMessages.RestTrailingComma);
          }
        }
        class ExpressionParser extends LValParser {
          checkProto(prop2, isRecord, protoRef, refExpressionErrors) {
            if (prop2.type === "SpreadElement" || this.isObjectMethod(prop2) || prop2.computed || prop2.shorthand) {
              return;
            }
            const key = prop2.key;
            const name = key.type === "Identifier" ? key.name : key.value;
            if (name === "__proto__") {
              if (isRecord) {
                this.raise(key.start, ErrorMessages.RecordNoProto);
                return;
              }
              if (protoRef.used) {
                if (refExpressionErrors) {
                  if (refExpressionErrors.doubleProto === -1) {
                    refExpressionErrors.doubleProto = key.start;
                  }
                } else {
                  this.raise(key.start, ErrorMessages.DuplicateProto);
                }
              }
              protoRef.used = true;
            }
          }
          shouldExitDescending(expr2, potentialArrowAt) {
            return expr2.type === "ArrowFunctionExpression" && expr2.start === potentialArrowAt;
          }
          getExpression() {
            let paramFlags = PARAM;
            if (this.hasPlugin("topLevelAwait") && this.inModule) {
              paramFlags |= PARAM_AWAIT;
            }
            this.scope.enter(SCOPE_PROGRAM);
            this.prodParam.enter(paramFlags);
            this.nextToken();
            const expr2 = this.parseExpression();
            if (!this.match(types$1.eof)) {
              this.unexpected();
            }
            expr2.comments = this.state.comments;
            expr2.errors = this.state.errors;
            if (this.options.tokens) {
              expr2.tokens = this.tokens;
            }
            return expr2;
          }
          parseExpression(disallowIn, refExpressionErrors) {
            if (disallowIn) {
              return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
            }
            return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          parseExpressionBase(refExpressionErrors) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const expr2 = this.parseMaybeAssign(refExpressionErrors);
            if (this.match(types$1.comma)) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.expressions = [expr2];
              while (this.eat(types$1.comma)) {
                node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
              }
              this.toReferencedList(node2.expressions);
              return this.finishNode(node2, "SequenceExpression");
            }
            return expr2;
          }
          parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
            return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));
          }
          parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
            return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            if (this.isContextual("yield")) {
              if (this.prodParam.hasYield) {
                this.state.exprAllowed = true;
                let left2 = this.parseYield();
                if (afterLeftParse) {
                  left2 = afterLeftParse.call(this, left2, startPos, startLoc);
                }
                return left2;
              }
            }
            let ownExpressionErrors;
            if (refExpressionErrors) {
              ownExpressionErrors = false;
            } else {
              refExpressionErrors = new ExpressionErrors();
              ownExpressionErrors = true;
            }
            if (this.match(types$1.parenL) || this.match(types$1.name)) {
              this.state.potentialArrowAt = this.state.start;
            }
            let left = this.parseMaybeConditional(refExpressionErrors, refNeedsArrowPos);
            if (afterLeftParse) {
              left = afterLeftParse.call(this, left, startPos, startLoc);
            }
            if (this.state.type.isAssign) {
              const node2 = this.startNodeAt(startPos, startLoc);
              const operator = this.state.value;
              node2.operator = operator;
              if (this.match(types$1.eq)) {
                node2.left = this.toAssignable(left, true);
                refExpressionErrors.doubleProto = -1;
              } else {
                node2.left = left;
              }
              if (refExpressionErrors.shorthandAssign >= node2.left.start) {
                refExpressionErrors.shorthandAssign = -1;
              }
              this.checkLVal(left, "assignment expression");
              this.next();
              node2.right = this.parseMaybeAssign();
              return this.finishNode(node2, "AssignmentExpression");
            } else if (ownExpressionErrors) {
              this.checkExpressionErrors(refExpressionErrors, true);
            }
            return left;
          }
          parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const potentialArrowAt = this.state.potentialArrowAt;
            const expr2 = this.parseExprOps(refExpressionErrors);
            if (this.shouldExitDescending(expr2, potentialArrowAt)) {
              return expr2;
            }
            return this.parseConditional(expr2, startPos, startLoc, refNeedsArrowPos);
          }
          parseConditional(expr2, startPos, startLoc, refNeedsArrowPos) {
            if (this.eat(types$1.question)) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.test = expr2;
              node2.consequent = this.parseMaybeAssignAllowIn();
              this.expect(types$1.colon);
              node2.alternate = this.parseMaybeAssign();
              return this.finishNode(node2, "ConditionalExpression");
            }
            return expr2;
          }
          parseExprOps(refExpressionErrors) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const potentialArrowAt = this.state.potentialArrowAt;
            const expr2 = this.parseMaybeUnary(refExpressionErrors);
            if (this.shouldExitDescending(expr2, potentialArrowAt)) {
              return expr2;
            }
            return this.parseExprOp(expr2, startPos, startLoc, -1);
          }
          parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
            let prec = this.state.type.binop;
            if (prec != null && (this.prodParam.hasIn || !this.match(types$1._in))) {
              if (prec > minPrec) {
                const op = this.state.type;
                if (op === types$1.pipeline) {
                  this.expectPlugin("pipelineOperator");
                  if (this.state.inFSharpPipelineDirectBody) {
                    return left;
                  }
                  this.state.inPipeline = true;
                  this.checkPipelineAtInfixOperator(left, leftStartPos);
                }
                const node2 = this.startNodeAt(leftStartPos, leftStartLoc);
                node2.left = left;
                node2.operator = this.state.value;
                const logical = op === types$1.logicalOR || op === types$1.logicalAND;
                const coalesce = op === types$1.nullishCoalescing;
                if (coalesce) {
                  prec = types$1.logicalAND.binop;
                }
                this.next();
                if (op === types$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
                  if (this.match(types$1.name) && this.state.value === "await" && this.prodParam.hasAwait) {
                    throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
                  }
                }
                node2.right = this.parseExprOpRightExpr(op, prec);
                this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                const nextOp = this.state.type;
                if (coalesce && (nextOp === types$1.logicalOR || nextOp === types$1.logicalAND) || logical && nextOp === types$1.nullishCoalescing) {
                  throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
                }
                return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec);
              }
            }
            return left;
          }
          parseExprOpRightExpr(op, prec) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            switch (op) {
              case types$1.pipeline:
                switch (this.getPluginOption("pipelineOperator", "proposal")) {
                  case "smart":
                    return this.withTopicPermittingContext(() => {
                      return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                    });
                  case "fsharp":
                    return this.withSoloAwaitPermittingContext(() => {
                      return this.parseFSharpPipelineBody(prec);
                    });
                }
              default:
                return this.parseExprOpBaseRightExpr(op, prec);
            }
          }
          parseExprOpBaseRightExpr(op, prec) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
          }
          checkExponentialAfterUnary(node2) {
            if (this.match(types$1.exponent)) {
              this.raise(node2.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
            }
          }
          parseMaybeUnary(refExpressionErrors, sawUnary) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const isAwait = this.isContextual("await");
            if (isAwait && this.isAwaitAllowed()) {
              this.next();
              const expr3 = this.parseAwait(startPos, startLoc);
              if (!sawUnary)
                this.checkExponentialAfterUnary(expr3);
              return expr3;
            }
            if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
              return this.parseModuleExpression();
            }
            const update = this.match(types$1.incDec);
            const node2 = this.startNode();
            if (this.state.type.prefix) {
              node2.operator = this.state.value;
              node2.prefix = true;
              if (this.match(types$1._throw)) {
                this.expectPlugin("throwExpressions");
              }
              const isDelete = this.match(types$1._delete);
              this.next();
              node2.argument = this.parseMaybeUnary(null, true);
              this.checkExpressionErrors(refExpressionErrors, true);
              if (this.state.strict && isDelete) {
                const arg = node2.argument;
                if (arg.type === "Identifier") {
                  this.raise(node2.start, ErrorMessages.StrictDelete);
                } else if (this.hasPropertyAsPrivateName(arg)) {
                  this.raise(node2.start, ErrorMessages.DeletePrivateField);
                }
              }
              if (!update) {
                if (!sawUnary)
                  this.checkExponentialAfterUnary(node2);
                return this.finishNode(node2, "UnaryExpression");
              }
            }
            const expr2 = this.parseUpdate(node2, update, refExpressionErrors);
            if (isAwait) {
              const startsExpr2 = this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types$1.modulo);
              if (startsExpr2 && !this.isAmbiguousAwait()) {
                this.raiseOverwrite(startPos, this.hasPlugin("topLevelAwait") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);
                return this.parseAwait(startPos, startLoc);
              }
            }
            return expr2;
          }
          parseUpdate(node2, update, refExpressionErrors) {
            if (update) {
              this.checkLVal(node2.argument, "prefix operation");
              return this.finishNode(node2, "UpdateExpression");
            }
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let expr2 = this.parseExprSubscripts(refExpressionErrors);
            if (this.checkExpressionErrors(refExpressionErrors, false))
              return expr2;
            while (this.state.type.postfix && !this.canInsertSemicolon()) {
              const node3 = this.startNodeAt(startPos, startLoc);
              node3.operator = this.state.value;
              node3.prefix = false;
              node3.argument = expr2;
              this.checkLVal(expr2, "postfix operation");
              this.next();
              expr2 = this.finishNode(node3, "UpdateExpression");
            }
            return expr2;
          }
          parseExprSubscripts(refExpressionErrors) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const potentialArrowAt = this.state.potentialArrowAt;
            const expr2 = this.parseExprAtom(refExpressionErrors);
            if (this.shouldExitDescending(expr2, potentialArrowAt)) {
              return expr2;
            }
            return this.parseSubscripts(expr2, startPos, startLoc);
          }
          parseSubscripts(base, startPos, startLoc, noCalls) {
            const state = {optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(base), stop: false};
            do {
              base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
              state.maybeAsyncArrow = false;
            } while (!state.stop);
            return base;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            if (!noCalls && this.eat(types$1.doubleColon)) {
              return this.parseBind(base, startPos, startLoc, noCalls, state);
            } else if (this.match(types$1.backQuote)) {
              return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
            }
            let optional = false;
            if (this.match(types$1.questionDot)) {
              if (noCalls && this.lookaheadCharCode() === 40) {
                state.stop = true;
                return base;
              }
              state.optionalChainMember = optional = true;
              this.next();
            }
            if (!noCalls && this.match(types$1.parenL)) {
              return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
            } else if (optional || this.match(types$1.bracketL) || this.eat(types$1.dot)) {
              return this.parseMember(base, startPos, startLoc, state, optional);
            } else {
              state.stop = true;
              return base;
            }
          }
          parseMember(base, startPos, startLoc, state, optional) {
            const node2 = this.startNodeAt(startPos, startLoc);
            const computed = this.eat(types$1.bracketL);
            node2.object = base;
            node2.computed = computed;
            const property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);
            if (this.isPrivateName(property)) {
              if (node2.object.type === "Super") {
                this.raise(startPos, ErrorMessages.SuperPrivateField);
              }
              this.classScope.usePrivateName(this.getPrivateNameSV(property), property.start);
            }
            node2.property = property;
            if (computed) {
              this.expect(types$1.bracketR);
            }
            if (state.optionalChainMember) {
              node2.optional = optional;
              return this.finishNode(node2, "OptionalMemberExpression");
            } else {
              return this.finishNode(node2, "MemberExpression");
            }
          }
          parseBind(base, startPos, startLoc, noCalls, state) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.object = base;
            node2.callee = this.parseNoCallExpr();
            state.stop = true;
            return this.parseSubscripts(this.finishNode(node2, "BindExpression"), startPos, startLoc, noCalls);
          }
          parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            this.next();
            let node2 = this.startNodeAt(startPos, startLoc);
            node2.callee = base;
            if (state.maybeAsyncArrow) {
              this.expressionScope.enter(newAsyncArrowScope());
            }
            if (state.optionalChainMember) {
              node2.optional = optional;
            }
            if (optional) {
              node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
            } else {
              node2.arguments = this.parseCallExpressionArguments(types$1.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", node2);
            }
            this.finishCallExpression(node2, state.optionalChainMember);
            if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
              state.stop = true;
              this.expressionScope.validateAsPattern();
              this.expressionScope.exit();
              node2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node2);
            } else {
              if (state.maybeAsyncArrow) {
                this.expressionScope.exit();
              }
              this.toReferencedArguments(node2);
            }
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            return node2;
          }
          toReferencedArguments(node2, isParenthesizedExpr) {
            this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
          }
          parseTaggedTemplateExpression(base, startPos, startLoc, state) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.tag = base;
            node2.quasi = this.parseTemplate(true);
            if (state.optionalChainMember) {
              this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
            }
            return this.finishNode(node2, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(base) {
            return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
          }
          finishCallExpression(node2, optional) {
            if (node2.callee.type === "Import") {
              if (node2.arguments.length === 2) {
                if (!this.hasPlugin("moduleAttributes")) {
                  this.expectPlugin("importAssertions");
                }
              }
              if (node2.arguments.length === 0 || node2.arguments.length > 2) {
                this.raise(node2.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
              } else {
                for (const arg of node2.arguments) {
                  if (arg.type === "SpreadElement") {
                    this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
                  }
                }
              }
            }
            return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
            const elts = [];
            let first = true;
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            while (!this.eat(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(types$1.comma);
                if (this.match(close)) {
                  if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                    this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
                  }
                  if (nodeForExtra) {
                    this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
                  }
                  this.next();
                  break;
                }
              }
              elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : void 0, possibleAsyncArrow ? {start: 0} : void 0, allowPlaceholder));
            }
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return elts;
          }
          shouldParseAsyncArrow() {
            return this.match(types$1.arrow) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(node2, call) {
            var _call$extra;
            this.expect(types$1.arrow);
            this.parseArrowExpression(node2, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
            return node2;
          }
          parseNoCallExpr() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
          }
          parseExprAtom(refExpressionErrors) {
            if (this.state.type === types$1.slash)
              this.readRegexp();
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            let node2;
            switch (this.state.type) {
              case types$1._super:
                return this.parseSuper();
              case types$1._import:
                node2 = this.startNode();
                this.next();
                if (this.match(types$1.dot)) {
                  return this.parseImportMetaProperty(node2);
                }
                if (!this.match(types$1.parenL)) {
                  this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
                }
                return this.finishNode(node2, "Import");
              case types$1._this:
                node2 = this.startNode();
                this.next();
                return this.finishNode(node2, "ThisExpression");
              case types$1.name: {
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                  if (this.match(types$1._function)) {
                    const last2 = this.state.context.length - 1;
                    if (this.state.context[last2] !== types$1$1.functionStatement) {
                      throw new Error("Internal error");
                    }
                    this.state.context[last2] = types$1$1.functionExpression;
                    this.next();
                    return this.parseFunction(this.startNodeAtNode(id), void 0, true);
                  } else if (this.match(types$1.name)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(id);
                    } else {
                      return id;
                    }
                  } else if (this.match(types$1._do)) {
                    return this.parseDo(true);
                  }
                }
                if (canBeArrow && this.match(types$1.arrow) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                return id;
              }
              case types$1._do: {
                return this.parseDo(false);
              }
              case types$1.regexp: {
                const value = this.state.value;
                node2 = this.parseLiteral(value.value, "RegExpLiteral");
                node2.pattern = value.pattern;
                node2.flags = value.flags;
                return node2;
              }
              case types$1.num:
                return this.parseLiteral(this.state.value, "NumericLiteral");
              case types$1.bigint:
                return this.parseLiteral(this.state.value, "BigIntLiteral");
              case types$1.decimal:
                return this.parseLiteral(this.state.value, "DecimalLiteral");
              case types$1.string:
                return this.parseLiteral(this.state.value, "StringLiteral");
              case types$1._null:
                node2 = this.startNode();
                this.next();
                return this.finishNode(node2, "NullLiteral");
              case types$1._true:
              case types$1._false:
                return this.parseBooleanLiteral();
              case types$1.parenL:
                return this.parseParenAndDistinguishExpression(canBeArrow);
              case types$1.bracketBarL:
              case types$1.bracketHashL: {
                return this.parseArrayLike(this.state.type === types$1.bracketBarL ? types$1.bracketBarR : types$1.bracketR, false, true, refExpressionErrors);
              }
              case types$1.bracketL: {
                return this.parseArrayLike(types$1.bracketR, true, false, refExpressionErrors);
              }
              case types$1.braceBarL:
              case types$1.braceHashL: {
                return this.parseObjectLike(this.state.type === types$1.braceBarL ? types$1.braceBarR : types$1.braceR, false, true, refExpressionErrors);
              }
              case types$1.braceL: {
                return this.parseObjectLike(types$1.braceR, false, false, refExpressionErrors);
              }
              case types$1._function:
                return this.parseFunctionOrFunctionSent();
              case types$1.at:
                this.parseDecorators();
              case types$1._class:
                node2 = this.startNode();
                this.takeDecorators(node2);
                return this.parseClass(node2, false);
              case types$1._new:
                return this.parseNewOrNewTarget();
              case types$1.backQuote:
                return this.parseTemplate(false);
              case types$1.doubleColon: {
                node2 = this.startNode();
                this.next();
                node2.object = null;
                const callee = node2.callee = this.parseNoCallExpr();
                if (callee.type === "MemberExpression") {
                  return this.finishNode(node2, "BindExpression");
                } else {
                  throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
                }
              }
              case types$1.hash: {
                if (this.state.inPipeline) {
                  node2 = this.startNode();
                  if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                    this.raise(node2.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);
                  }
                  this.next();
                  if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                    this.raise(node2.start, ErrorMessages.PrimaryTopicNotAllowed);
                  }
                  this.registerTopicReference();
                  return this.finishNode(node2, "PipelinePrimaryTopicReference");
                }
                const nextCh = this.input.codePointAt(this.state.end);
                if (isIdentifierStart(nextCh) || nextCh === 92) {
                  const start = this.state.start;
                  node2 = this.parseMaybePrivateName(true);
                  if (this.match(types$1._in)) {
                    this.expectPlugin("privateIn");
                    this.classScope.usePrivateName(this.getPrivateNameSV(node2), node2.start);
                  } else if (this.hasPlugin("privateIn")) {
                    this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, this.getPrivateNameSV(node2));
                  } else {
                    throw this.unexpected(start);
                  }
                  return node2;
                }
              }
              case types$1.relational: {
                if (this.state.value === "<") {
                  const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                  if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                    this.expectOnePlugin(["jsx", "flow", "typescript"]);
                  }
                }
              }
              default:
                throw this.unexpected();
            }
          }
          parseAsyncArrowUnaryFunction(id) {
            const node2 = this.startNodeAtNode(id);
            this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
            const params = [this.parseIdentifier()];
            this.prodParam.exit();
            if (this.hasPrecedingLineBreak()) {
              this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
            }
            this.expect(types$1.arrow);
            this.parseArrowExpression(node2, params, true);
            return node2;
          }
          parseDo(isAsync) {
            this.expectPlugin("doExpressions");
            if (isAsync) {
              this.expectPlugin("asyncDoExpressions");
            }
            const node2 = this.startNode();
            node2.async = isAsync;
            this.next();
            const oldLabels = this.state.labels;
            this.state.labels = [];
            if (isAsync) {
              this.prodParam.enter(PARAM_AWAIT);
              node2.body = this.parseBlock();
              this.prodParam.exit();
            } else {
              node2.body = this.parseBlock();
            }
            this.state.labels = oldLabels;
            return this.finishNode(node2, "DoExpression");
          }
          parseSuper() {
            const node2 = this.startNode();
            this.next();
            if (this.match(types$1.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
              this.raise(node2.start, ErrorMessages.SuperNotAllowed);
            } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
              this.raise(node2.start, ErrorMessages.UnexpectedSuper);
            }
            if (!this.match(types$1.parenL) && !this.match(types$1.bracketL) && !this.match(types$1.dot)) {
              this.raise(node2.start, ErrorMessages.UnsupportedSuper);
            }
            return this.finishNode(node2, "Super");
          }
          parseBooleanLiteral() {
            const node2 = this.startNode();
            node2.value = this.match(types$1._true);
            this.next();
            return this.finishNode(node2, "BooleanLiteral");
          }
          parseMaybePrivateName(isPrivateNameAllowed) {
            const isPrivate = this.match(types$1.hash);
            if (isPrivate) {
              if (!isPrivateNameAllowed) {
                this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);
              }
              const node2 = this.startNode();
              this.next();
              this.assertNoSpace("Unexpected space between # and identifier");
              node2.id = this.parseIdentifier(true);
              return this.finishNode(node2, "PrivateName");
            } else {
              return this.parseIdentifier(true);
            }
          }
          parseFunctionOrFunctionSent() {
            const node2 = this.startNode();
            this.next();
            if (this.prodParam.hasYield && this.match(types$1.dot)) {
              const meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
              this.next();
              return this.parseMetaProperty(node2, meta, "sent");
            }
            return this.parseFunction(node2);
          }
          parseMetaProperty(node2, meta, propertyName) {
            node2.meta = meta;
            if (meta.name === "function" && propertyName === "sent") {
              if (this.isContextual(propertyName)) {
                this.expectPlugin("functionSent");
              } else if (!this.hasPlugin("functionSent")) {
                this.unexpected();
              }
            }
            const containsEsc = this.state.containsEsc;
            node2.property = this.parseIdentifier(true);
            if (node2.property.name !== propertyName || containsEsc) {
              this.raise(node2.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
            }
            return this.finishNode(node2, "MetaProperty");
          }
          parseImportMetaProperty(node2) {
            const id = this.createIdentifier(this.startNodeAtNode(node2), "import");
            this.next();
            if (this.isContextual("meta")) {
              if (!this.inModule) {
                this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
              }
              this.sawUnambiguousESM = true;
            }
            return this.parseMetaProperty(node2, id, "meta");
          }
          parseLiteral(value, type2, startPos, startLoc) {
            startPos = startPos || this.state.start;
            startLoc = startLoc || this.state.startLoc;
            const node2 = this.startNodeAt(startPos, startLoc);
            this.addExtra(node2, "rawValue", value);
            this.addExtra(node2, "raw", this.input.slice(startPos, this.state.end));
            node2.value = value;
            this.next();
            return this.finishNode(node2, type2);
          }
          parseParenAndDistinguishExpression(canBeArrow) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let val;
            this.next();
            this.expressionScope.enter(newArrowHeadScope());
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true;
            this.state.inFSharpPipelineDirectBody = false;
            const innerStartPos = this.state.start;
            const innerStartLoc = this.state.startLoc;
            const exprList = [];
            const refExpressionErrors = new ExpressionErrors();
            const refNeedsArrowPos = {start: 0};
            let first = true;
            let spreadStart;
            let optionalCommaStart;
            while (!this.match(types$1.parenR)) {
              if (first) {
                first = false;
              } else {
                this.expect(types$1.comma, refNeedsArrowPos.start || null);
                if (this.match(types$1.parenR)) {
                  optionalCommaStart = this.state.start;
                  break;
                }
              }
              if (this.match(types$1.ellipsis)) {
                const spreadNodeStartPos = this.state.start;
                const spreadNodeStartLoc = this.state.startLoc;
                spreadStart = this.state.start;
                exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
                this.checkCommaAfterRest(41);
                break;
              } else {
                exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
              }
            }
            const innerEndPos = this.state.lastTokEnd;
            const innerEndLoc = this.state.lastTokEndLoc;
            this.expect(types$1.parenR);
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            let arrowNode = this.startNodeAt(startPos, startLoc);
            if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
              this.expressionScope.validateAsPattern();
              this.expressionScope.exit();
              this.parseArrowExpression(arrowNode, exprList, false);
              return arrowNode;
            }
            this.expressionScope.exit();
            if (!exprList.length) {
              this.unexpected(this.state.lastTokStart);
            }
            if (optionalCommaStart)
              this.unexpected(optionalCommaStart);
            if (spreadStart)
              this.unexpected(spreadStart);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (refNeedsArrowPos.start)
              this.unexpected(refNeedsArrowPos.start);
            this.toReferencedListDeep(exprList, true);
            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc);
              val.expressions = exprList;
              this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
              val = exprList[0];
            }
            if (!this.options.createParenthesizedExpressions) {
              this.addExtra(val, "parenthesized", true);
              this.addExtra(val, "parenStart", startPos);
              return val;
            }
            const parenExpression = this.startNodeAt(startPos, startLoc);
            parenExpression.expression = val;
            this.finishNode(parenExpression, "ParenthesizedExpression");
            return parenExpression;
          }
          shouldParseArrow() {
            return !this.canInsertSemicolon();
          }
          parseArrow(node2) {
            if (this.eat(types$1.arrow)) {
              return node2;
            }
          }
          parseParenItem(node2, startPos, startLoc) {
            return node2;
          }
          parseNewOrNewTarget() {
            const node2 = this.startNode();
            this.next();
            if (this.match(types$1.dot)) {
              const meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
              this.next();
              const metaProp = this.parseMetaProperty(node2, meta, "target");
              if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
                this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
              }
              return metaProp;
            }
            return this.parseNew(node2);
          }
          parseNew(node2) {
            node2.callee = this.parseNoCallExpr();
            if (node2.callee.type === "Import") {
              this.raise(node2.callee.start, ErrorMessages.ImportCallNotNewExpression);
            } else if (this.isOptionalChain(node2.callee)) {
              this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
            } else if (this.eat(types$1.questionDot)) {
              this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
            }
            this.parseNewArguments(node2);
            return this.finishNode(node2, "NewExpression");
          }
          parseNewArguments(node2) {
            if (this.eat(types$1.parenL)) {
              const args = this.parseExprList(types$1.parenR);
              this.toReferencedList(args);
              node2.arguments = args;
            } else {
              node2.arguments = [];
            }
          }
          parseTemplateElement(isTagged) {
            const elem = this.startNode();
            if (this.state.value === null) {
              if (!isTagged) {
                this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
              }
            }
            elem.value = {raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value};
            this.next();
            elem.tail = this.match(types$1.backQuote);
            return this.finishNode(elem, "TemplateElement");
          }
          parseTemplate(isTagged) {
            const node2 = this.startNode();
            this.next();
            node2.expressions = [];
            let curElt = this.parseTemplateElement(isTagged);
            node2.quasis = [curElt];
            while (!curElt.tail) {
              this.expect(types$1.dollarBraceL);
              node2.expressions.push(this.parseTemplateSubstitution());
              this.expect(types$1.braceR);
              node2.quasis.push(curElt = this.parseTemplateElement(isTagged));
            }
            this.next();
            return this.finishNode(node2, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
            if (isRecord) {
              this.expectPlugin("recordAndTuple");
            }
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const propHash = Object.create(null);
            let first = true;
            const node2 = this.startNode();
            node2.properties = [];
            this.next();
            while (!this.match(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(types$1.comma);
                if (this.match(close)) {
                  this.addExtra(node2, "trailingComma", this.state.lastTokStart);
                  break;
                }
              }
              const prop2 = this.parsePropertyDefinition(isPattern, refExpressionErrors);
              if (!isPattern) {
                this.checkProto(prop2, isRecord, propHash, refExpressionErrors);
              }
              if (isRecord && !this.isObjectProperty(prop2) && prop2.type !== "SpreadElement") {
                this.raise(prop2.start, ErrorMessages.InvalidRecordProperty);
              }
              if (prop2.shorthand) {
                this.addExtra(prop2, "shorthand", true);
              }
              node2.properties.push(prop2);
            }
            this.state.exprAllowed = false;
            this.next();
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            let type2 = "ObjectExpression";
            if (isPattern) {
              type2 = "ObjectPattern";
            } else if (isRecord) {
              type2 = "RecordExpression";
            }
            return this.finishNode(node2, type2);
          }
          maybeAsyncOrAccessorProp(prop2) {
            return !prop2.computed && prop2.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types$1.bracketL) || this.match(types$1.star));
          }
          parsePropertyDefinition(isPattern, refExpressionErrors) {
            let decorators = [];
            if (this.match(types$1.at)) {
              if (this.hasPlugin("decorators")) {
                this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
              }
              while (this.match(types$1.at)) {
                decorators.push(this.parseDecorator());
              }
            }
            const prop2 = this.startNode();
            let isGenerator = false;
            let isAsync = false;
            let isAccessor = false;
            let startPos;
            let startLoc;
            if (this.match(types$1.ellipsis)) {
              if (decorators.length)
                this.unexpected();
              if (isPattern) {
                this.next();
                prop2.argument = this.parseIdentifier();
                this.checkCommaAfterRest(125);
                return this.finishNode(prop2, "RestElement");
              }
              return this.parseSpread();
            }
            if (decorators.length) {
              prop2.decorators = decorators;
              decorators = [];
            }
            prop2.method = false;
            if (isPattern || refExpressionErrors) {
              startPos = this.state.start;
              startLoc = this.state.startLoc;
            }
            if (!isPattern) {
              isGenerator = this.eat(types$1.star);
            }
            const containsEsc = this.state.containsEsc;
            const key = this.parsePropertyName(prop2, false);
            if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop2)) {
              const keyName = key.name;
              if (keyName === "async" && !this.hasPrecedingLineBreak()) {
                isAsync = true;
                isGenerator = this.eat(types$1.star);
                this.parsePropertyName(prop2, false);
              }
              if (keyName === "get" || keyName === "set") {
                isAccessor = true;
                prop2.kind = keyName;
                if (this.match(types$1.star)) {
                  isGenerator = true;
                  this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
                  this.next();
                }
                this.parsePropertyName(prop2, false);
              }
            }
            this.parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
            return prop2;
          }
          getGetterSetterExpectedParamCount(method) {
            return method.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(method) {
            return method.params;
          }
          checkGetterSetterParams(method) {
            var _params;
            const paramCount = this.getGetterSetterExpectedParamCount(method);
            const params = this.getObjectOrClassMethodParams(method);
            const start = method.start;
            if (params.length !== paramCount) {
              if (method.kind === "get") {
                this.raise(start, ErrorMessages.BadGetterArity);
              } else {
                this.raise(start, ErrorMessages.BadSetterArity);
              }
            }
            if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
              this.raise(start, ErrorMessages.BadSetterRestParameter);
            }
          }
          parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor) {
            if (isAccessor) {
              this.parseMethod(prop2, isGenerator, false, false, false, "ObjectMethod");
              this.checkGetterSetterParams(prop2);
              return prop2;
            }
            if (isAsync || isGenerator || this.match(types$1.parenL)) {
              if (isPattern)
                this.unexpected();
              prop2.kind = "method";
              prop2.method = true;
              return this.parseMethod(prop2, isGenerator, isAsync, false, false, "ObjectMethod");
            }
          }
          parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors) {
            prop2.shorthand = false;
            if (this.eat(types$1.colon)) {
              prop2.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
              return this.finishNode(prop2, "ObjectProperty");
            }
            if (!prop2.computed && prop2.key.type === "Identifier") {
              this.checkReservedWord(prop2.key.name, prop2.key.start, true, false);
              if (isPattern) {
                prop2.value = this.parseMaybeDefault(startPos, startLoc, prop2.key.__clone());
              } else if (this.match(types$1.eq) && refExpressionErrors) {
                if (refExpressionErrors.shorthandAssign === -1) {
                  refExpressionErrors.shorthandAssign = this.state.start;
                }
                prop2.value = this.parseMaybeDefault(startPos, startLoc, prop2.key.__clone());
              } else {
                prop2.value = prop2.key.__clone();
              }
              prop2.shorthand = true;
              return this.finishNode(prop2, "ObjectProperty");
            }
          }
          parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            const node2 = this.parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors);
            if (!node2)
              this.unexpected();
            return node2;
          }
          parsePropertyName(prop2, isPrivateNameAllowed) {
            if (this.eat(types$1.bracketL)) {
              prop2.computed = true;
              prop2.key = this.parseMaybeAssignAllowIn();
              this.expect(types$1.bracketR);
            } else {
              const oldInPropertyName = this.state.inPropertyName;
              this.state.inPropertyName = true;
              prop2.key = this.match(types$1.num) || this.match(types$1.string) || this.match(types$1.bigint) || this.match(types$1.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);
              if (!this.isPrivateName(prop2.key)) {
                prop2.computed = false;
              }
              this.state.inPropertyName = oldInPropertyName;
            }
            return prop2.key;
          }
          initFunction(node2, isAsync) {
            node2.id = null;
            node2.generator = false;
            node2.async = !!isAsync;
          }
          parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope) {
            if (inClassScope === void 0) {
              inClassScope = false;
            }
            this.initFunction(node2, isAsync);
            node2.generator = !!isGenerator;
            const allowModifiers = isConstructor;
            this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
            this.prodParam.enter(functionFlags(isAsync, node2.generator));
            this.parseFunctionParams(node2, allowModifiers);
            this.parseFunctionBodyAndFinish(node2, type2, true);
            this.prodParam.exit();
            this.scope.exit();
            return node2;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            if (isTuple) {
              this.expectPlugin("recordAndTuple");
            }
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const node2 = this.startNode();
            this.next();
            node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2);
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(node2, params, isAsync, trailingCommaPos) {
            this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
            let flags = functionFlags(isAsync, false);
            if (!this.match(types$1.bracketL) && this.prodParam.hasIn) {
              flags |= PARAM_IN;
            }
            this.prodParam.enter(flags);
            this.initFunction(node2, isAsync);
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            if (params) {
              this.state.maybeInArrowParameters = true;
              this.setArrowFunctionParameters(node2, params, trailingCommaPos);
            }
            this.state.maybeInArrowParameters = false;
            this.parseFunctionBody(node2, true);
            this.prodParam.exit();
            this.scope.exit();
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            return this.finishNode(node2, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(node2, params, trailingCommaPos) {
            node2.params = this.toAssignableList(params, trailingCommaPos, false);
          }
          parseFunctionBodyAndFinish(node2, type2, isMethod) {
            if (isMethod === void 0) {
              isMethod = false;
            }
            this.parseFunctionBody(node2, false, isMethod);
            this.finishNode(node2, type2);
          }
          parseFunctionBody(node2, allowExpression, isMethod) {
            if (isMethod === void 0) {
              isMethod = false;
            }
            const isExpression = allowExpression && !this.match(types$1.braceL);
            this.expressionScope.enter(newExpressionScope());
            if (isExpression) {
              node2.body = this.parseMaybeAssign();
              this.checkParams(node2, false, allowExpression, false);
            } else {
              const oldStrict = this.state.strict;
              const oldLabels = this.state.labels;
              this.state.labels = [];
              this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
              node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
                const nonSimple = !this.isSimpleParamList(node2.params);
                if (hasStrictModeDirective && nonSimple) {
                  const errorPos = (node2.kind === "method" || node2.kind === "constructor") && !!node2.key ? node2.key.end : node2.start;
                  this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
                }
                const strictModeChanged = !oldStrict && this.state.strict;
                this.checkParams(node2, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
                if (this.state.strict && node2.id) {
                  this.checkLVal(node2.id, "function name", BIND_OUTSIDE, void 0, void 0, strictModeChanged);
                }
              });
              this.prodParam.exit();
              this.expressionScope.exit();
              this.state.labels = oldLabels;
            }
          }
          isSimpleParamList(params) {
            for (let i = 0, len = params.length; i < len; i++) {
              if (params[i].type !== "Identifier")
                return false;
            }
            return true;
          }
          checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged) {
            if (strictModeChanged === void 0) {
              strictModeChanged = true;
            }
            const checkClashes = new Set();
            for (const param of node2.params) {
              this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, void 0, strictModeChanged);
            }
          }
          parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
            const elts = [];
            let first = true;
            while (!this.eat(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(types$1.comma);
                if (this.match(close)) {
                  if (nodeForExtra) {
                    this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
                  }
                  this.next();
                  break;
                }
              }
              elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
            }
            return elts;
          }
          parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
            let elt;
            if (this.match(types$1.comma)) {
              if (!allowEmpty) {
                this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
              }
              elt = null;
            } else if (this.match(types$1.ellipsis)) {
              const spreadNodeStartPos = this.state.start;
              const spreadNodeStartLoc = this.state.startLoc;
              elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
            } else if (this.match(types$1.question)) {
              this.expectPlugin("partialApplication");
              if (!allowPlaceholder) {
                this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
              }
              const node2 = this.startNode();
              this.next();
              elt = this.finishNode(node2, "ArgumentPlaceholder");
            } else {
              elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
            }
            return elt;
          }
          parseIdentifier(liberal) {
            const node2 = this.startNode();
            const name = this.parseIdentifierName(node2.start, liberal);
            return this.createIdentifier(node2, name);
          }
          createIdentifier(node2, name) {
            node2.name = name;
            node2.loc.identifierName = name;
            return this.finishNode(node2, "Identifier");
          }
          parseIdentifierName(pos, liberal) {
            let name;
            const {start, type: type2} = this.state;
            if (type2 === types$1.name) {
              name = this.state.value;
            } else if (type2.keyword) {
              name = type2.keyword;
              const curContext = this.curContext();
              if ((type2 === types$1._class || type2 === types$1._function) && (curContext === types$1$1.functionStatement || curContext === types$1$1.functionExpression)) {
                this.state.context.pop();
              }
            } else {
              throw this.unexpected();
            }
            if (liberal) {
              this.state.type = types$1.name;
            } else {
              this.checkReservedWord(name, start, !!type2.keyword, false);
            }
            this.next();
            return name;
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            if (this.prodParam.hasYield && word === "yield") {
              this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
              return;
            }
            if (word === "await") {
              if (this.prodParam.hasAwait) {
                this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
                return;
              } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {
                this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
                return;
              } else {
                this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
              }
            }
            if (this.scope.inClass && !this.scope.inNonArrowFunction && word === "arguments") {
              this.raise(startLoc, ErrorMessages.ArgumentsInClass);
              return;
            }
            if (checkKeywords && isKeyword(word)) {
              this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
              return;
            }
            const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
            if (reservedTest(word, this.inModule)) {
              this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
            }
          }
          isAwaitAllowed() {
            if (this.prodParam.hasAwait)
              return true;
            if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
              return true;
            }
            return false;
          }
          parseAwait(startPos, startLoc) {
            const node2 = this.startNodeAt(startPos, startLoc);
            this.expressionScope.recordParameterInitializerError(node2.start, ErrorMessages.AwaitExpressionFormalParameter);
            if (this.eat(types$1.star)) {
              this.raise(node2.start, ErrorMessages.ObsoleteAwaitStar);
            }
            if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
              if (this.isAmbiguousAwait()) {
                this.ambiguousScriptDifferentAst = true;
              } else {
                this.sawUnambiguousESM = true;
              }
            }
            if (!this.state.soloAwait) {
              node2.argument = this.parseMaybeUnary(null, true);
            }
            return this.finishNode(node2, "AwaitExpression");
          }
          isAmbiguousAwait() {
            return this.hasPrecedingLineBreak() || this.match(types$1.plusMin) || this.match(types$1.parenL) || this.match(types$1.bracketL) || this.match(types$1.backQuote) || this.match(types$1.regexp) || this.match(types$1.slash) || this.hasPlugin("v8intrinsic") && this.match(types$1.modulo);
          }
          parseYield() {
            const node2 = this.startNode();
            this.expressionScope.recordParameterInitializerError(node2.start, ErrorMessages.YieldInParameter);
            this.next();
            if (this.match(types$1.semi) || !this.match(types$1.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
              node2.delegate = false;
              node2.argument = null;
            } else {
              node2.delegate = this.eat(types$1.star);
              node2.argument = this.parseMaybeAssign();
            }
            return this.finishNode(node2, "YieldExpression");
          }
          checkPipelineAtInfixOperator(left, leftStartPos) {
            if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
              if (left.type === "SequenceExpression") {
                this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
              }
            }
          }
          parseSmartPipelineBody(childExpression, startPos, startLoc) {
            this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);
            return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);
          }
          checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {
            if (this.match(types$1.arrow)) {
              throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
            } else if (childExpression.type === "SequenceExpression") {
              this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
            }
          }
          parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            const isSimpleReference = this.isSimpleReference(childExpression);
            if (isSimpleReference) {
              bodyNode.callee = childExpression;
            } else {
              if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
                this.raise(startPos, ErrorMessages.PipelineTopicUnused);
              }
              bodyNode.expression = childExpression;
            }
            return this.finishNode(bodyNode, isSimpleReference ? "PipelineBareFunction" : "PipelineTopicExpression");
          }
          isSimpleReference(expression) {
            switch (expression.type) {
              case "MemberExpression":
                return !expression.computed && this.isSimpleReference(expression.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          withTopicPermittingContext(callback) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {maxNumOfResolvableTopics: 1, maxTopicIndex: null};
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          }
          withTopicForbiddingContext(callback) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          }
          withSoloAwaitPermittingContext(callback) {
            const outerContextSoloAwaitState = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return callback();
            } finally {
              this.state.soloAwait = outerContextSoloAwaitState;
            }
          }
          allowInAnd(callback) {
            const flags = this.prodParam.currentFlags();
            const prodParamToSet = PARAM_IN & ~flags;
            if (prodParamToSet) {
              this.prodParam.enter(flags | PARAM_IN);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
          disallowInAnd(callback) {
            const flags = this.prodParam.currentFlags();
            const prodParamToClear = PARAM_IN & flags;
            if (prodParamToClear) {
              this.prodParam.enter(flags & ~PARAM_IN);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          primaryTopicReferenceIsAllowedInCurrentTopicContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentTopicContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(prec) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return ret;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const node2 = this.startNode();
            this.next();
            this.eat(types$1.braceL);
            const revertScopes = this.initializeScopes(true);
            this.enterInitialScopes();
            const program = this.startNode();
            try {
              node2.body = this.parseProgram(program, types$1.braceR, "module");
            } finally {
              revertScopes();
            }
            this.eat(types$1.braceR);
            return this.finishNode(node2, "ModuleExpression");
          }
        }
        const loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};
        const FUNC_NO_FLAGS = 0, FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
        const loneSurrogate = /[\uD800-\uDFFF]/u;
        class StatementParser extends ExpressionParser {
          parseTopLevel(file, program) {
            file.program = this.parseProgram(program);
            file.comments = this.state.comments;
            if (this.options.tokens)
              file.tokens = this.tokens;
            return this.finishNode(file, "File");
          }
          parseProgram(program, end, sourceType) {
            if (end === void 0) {
              end = types$1.eof;
            }
            if (sourceType === void 0) {
              sourceType = this.options.sourceType;
            }
            program.sourceType = sourceType;
            program.interpreter = this.parseInterpreterDirective();
            this.parseBlockBody(program, true, true, end);
            if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
              for (const [name] of Array.from(this.scope.undefinedExports)) {
                const pos = this.scope.undefinedExports.get(name);
                this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
              }
            }
            return this.finishNode(program, "Program");
          }
          stmtToDirective(stmt) {
            const expr2 = stmt.expression;
            const directiveLiteral = this.startNodeAt(expr2.start, expr2.loc.start);
            const directive = this.startNodeAt(stmt.start, stmt.loc.start);
            const raw = this.input.slice(expr2.start, expr2.end);
            const val = directiveLiteral.value = raw.slice(1, -1);
            this.addExtra(directiveLiteral, "raw", raw);
            this.addExtra(directiveLiteral, "rawValue", val);
            directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr2.end, expr2.loc.end);
            return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
          }
          parseInterpreterDirective() {
            if (!this.match(types$1.interpreterDirective)) {
              return null;
            }
            const node2 = this.startNode();
            node2.value = this.state.value;
            this.next();
            return this.finishNode(node2, "InterpreterDirective");
          }
          isLet(context) {
            if (!this.isContextual("let")) {
              return false;
            }
            return this.isLetKeyword(context);
          }
          isLetKeyword(context) {
            const next = this.nextTokenStart();
            const nextCh = this.input.charCodeAt(next);
            if (nextCh === 91)
              return true;
            if (context)
              return false;
            if (nextCh === 123)
              return true;
            if (isIdentifierStart(nextCh)) {
              let pos = next + 1;
              while (isIdentifierChar(this.input.charCodeAt(pos))) {
                ++pos;
              }
              const ident = this.input.slice(next, pos);
              if (!keywordRelationalOperator.test(ident))
                return true;
            }
            return false;
          }
          parseStatement(context, topLevel) {
            if (this.match(types$1.at)) {
              this.parseDecorators(true);
            }
            return this.parseStatementContent(context, topLevel);
          }
          parseStatementContent(context, topLevel) {
            let starttype = this.state.type;
            const node2 = this.startNode();
            let kind;
            if (this.isLet(context)) {
              starttype = types$1._var;
              kind = "let";
            }
            switch (starttype) {
              case types$1._break:
              case types$1._continue:
                return this.parseBreakContinueStatement(node2, starttype.keyword);
              case types$1._debugger:
                return this.parseDebuggerStatement(node2);
              case types$1._do:
                return this.parseDoStatement(node2);
              case types$1._for:
                return this.parseForStatement(node2);
              case types$1._function:
                if (this.lookaheadCharCode() === 46)
                  break;
                if (context) {
                  if (this.state.strict) {
                    this.raise(this.state.start, ErrorMessages.StrictFunction);
                  } else if (context !== "if" && context !== "label") {
                    this.raise(this.state.start, ErrorMessages.SloppyFunction);
                  }
                }
                return this.parseFunctionStatement(node2, false, !context);
              case types$1._class:
                if (context)
                  this.unexpected();
                return this.parseClass(node2, true);
              case types$1._if:
                return this.parseIfStatement(node2);
              case types$1._return:
                return this.parseReturnStatement(node2);
              case types$1._switch:
                return this.parseSwitchStatement(node2);
              case types$1._throw:
                return this.parseThrowStatement(node2);
              case types$1._try:
                return this.parseTryStatement(node2);
              case types$1._const:
              case types$1._var:
                kind = kind || this.state.value;
                if (context && kind !== "var") {
                  this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
                }
                return this.parseVarStatement(node2, kind);
              case types$1._while:
                return this.parseWhileStatement(node2);
              case types$1._with:
                return this.parseWithStatement(node2);
              case types$1.braceL:
                return this.parseBlock();
              case types$1.semi:
                return this.parseEmptyStatement(node2);
              case types$1._import: {
                const nextTokenCharCode = this.lookaheadCharCode();
                if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                  break;
                }
              }
              case types$1._export: {
                if (!this.options.allowImportExportEverywhere && !topLevel) {
                  this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
                }
                this.next();
                let result;
                if (starttype === types$1._import) {
                  result = this.parseImport(node2);
                  if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                    this.sawUnambiguousESM = true;
                  }
                } else {
                  result = this.parseExport(node2);
                  if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                    this.sawUnambiguousESM = true;
                  }
                }
                this.assertModuleNodeAllowed(node2);
                return result;
              }
              default: {
                if (this.isAsyncFunction()) {
                  if (context) {
                    this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
                  }
                  this.next();
                  return this.parseFunctionStatement(node2, true, !context);
                }
              }
            }
            const maybeName = this.state.value;
            const expr2 = this.parseExpression();
            if (starttype === types$1.name && expr2.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node2, maybeName, expr2, context);
            } else {
              return this.parseExpressionStatement(node2, expr2);
            }
          }
          assertModuleNodeAllowed(node2) {
            if (!this.options.allowImportExportEverywhere && !this.inModule) {
              this.raise(node2.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
            }
          }
          takeDecorators(node2) {
            const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            if (decorators.length) {
              node2.decorators = decorators;
              this.resetStartLocationFromNode(node2, decorators[0]);
              this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
            }
          }
          canHaveLeadingDecorator() {
            return this.match(types$1._class);
          }
          parseDecorators(allowExport) {
            const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            while (this.match(types$1.at)) {
              const decorator = this.parseDecorator();
              currentContextDecorators.push(decorator);
            }
            if (this.match(types$1._export)) {
              if (!allowExport) {
                this.unexpected();
              }
              if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
              }
            } else if (!this.canHaveLeadingDecorator()) {
              throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
            }
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators-legacy", "decorators"]);
            const node2 = this.startNode();
            this.next();
            if (this.hasPlugin("decorators")) {
              this.state.decoratorStack.push([]);
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              let expr2;
              if (this.eat(types$1.parenL)) {
                expr2 = this.parseExpression();
                this.expect(types$1.parenR);
              } else {
                expr2 = this.parseIdentifier(false);
                while (this.eat(types$1.dot)) {
                  const node3 = this.startNodeAt(startPos, startLoc);
                  node3.object = expr2;
                  node3.property = this.parseIdentifier(true);
                  node3.computed = false;
                  expr2 = this.finishNode(node3, "MemberExpression");
                }
              }
              node2.expression = this.parseMaybeDecoratorArguments(expr2);
              this.state.decoratorStack.pop();
            } else {
              node2.expression = this.parseExprSubscripts();
            }
            return this.finishNode(node2, "Decorator");
          }
          parseMaybeDecoratorArguments(expr2) {
            if (this.eat(types$1.parenL)) {
              const node2 = this.startNodeAtNode(expr2);
              node2.callee = expr2;
              node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
              this.toReferencedList(node2.arguments);
              return this.finishNode(node2, "CallExpression");
            }
            return expr2;
          }
          parseBreakContinueStatement(node2, keyword) {
            const isBreak = keyword === "break";
            this.next();
            if (this.isLineTerminator()) {
              node2.label = null;
            } else {
              node2.label = this.parseIdentifier();
              this.semicolon();
            }
            this.verifyBreakContinue(node2, keyword);
            return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(node2, keyword) {
            const isBreak = keyword === "break";
            let i;
            for (i = 0; i < this.state.labels.length; ++i) {
              const lab = this.state.labels[i];
              if (node2.label == null || lab.name === node2.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop"))
                  break;
                if (node2.label && isBreak)
                  break;
              }
            }
            if (i === this.state.labels.length) {
              this.raise(node2.start, ErrorMessages.IllegalBreakContinue, keyword);
            }
          }
          parseDebuggerStatement(node2) {
            this.next();
            this.semicolon();
            return this.finishNode(node2, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(types$1.parenL);
            const val = this.parseExpression();
            this.expect(types$1.parenR);
            return val;
          }
          parseDoStatement(node2) {
            this.next();
            this.state.labels.push(loopLabel);
            node2.body = this.withTopicForbiddingContext(() => this.parseStatement("do"));
            this.state.labels.pop();
            this.expect(types$1._while);
            node2.test = this.parseHeaderExpression();
            this.eat(types$1.semi);
            return this.finishNode(node2, "DoWhileStatement");
          }
          parseForStatement(node2) {
            this.next();
            this.state.labels.push(loopLabel);
            let awaitAt = -1;
            if (this.isAwaitAllowed() && this.eatContextual("await")) {
              awaitAt = this.state.lastTokStart;
            }
            this.scope.enter(SCOPE_OTHER);
            this.expect(types$1.parenL);
            if (this.match(types$1.semi)) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
              return this.parseFor(node2, null);
            }
            const startsWithLet = this.isContextual("let");
            const isLet = startsWithLet && this.isLetKeyword();
            if (this.match(types$1._var) || this.match(types$1._const) || isLet) {
              const init3 = this.startNode();
              const kind = isLet ? "let" : this.state.value;
              this.next();
              this.parseVar(init3, true, kind);
              this.finishNode(init3, "VariableDeclaration");
              if ((this.match(types$1._in) || this.isContextual("of")) && init3.declarations.length === 1) {
                return this.parseForIn(node2, init3, awaitAt);
              }
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
              return this.parseFor(node2, init3);
            }
            const startsWithUnescapedName = this.match(types$1.name) && !this.state.containsEsc;
            const refExpressionErrors = new ExpressionErrors();
            const init2 = this.parseExpression(true, refExpressionErrors);
            const isForOf = this.isContextual("of");
            if (isForOf) {
              if (startsWithLet) {
                this.raise(init2.start, ErrorMessages.ForOfLet);
              } else if (awaitAt === -1 && startsWithUnescapedName && init2.type === "Identifier" && init2.name === "async") {
                this.raise(init2.start, ErrorMessages.ForOfAsync);
              }
            }
            if (isForOf || this.match(types$1._in)) {
              this.toAssignable(init2, true);
              const description = isForOf ? "for-of statement" : "for-in statement";
              this.checkLVal(init2, description);
              return this.parseForIn(node2, init2, awaitAt);
            } else {
              this.checkExpressionErrors(refExpressionErrors, true);
            }
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node2, init2);
          }
          parseFunctionStatement(node2, isAsync, declarationPosition) {
            this.next();
            return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
          }
          parseIfStatement(node2) {
            this.next();
            node2.test = this.parseHeaderExpression();
            node2.consequent = this.parseStatement("if");
            node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
            return this.finishNode(node2, "IfStatement");
          }
          parseReturnStatement(node2) {
            if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
              this.raise(this.state.start, ErrorMessages.IllegalReturn);
            }
            this.next();
            if (this.isLineTerminator()) {
              node2.argument = null;
            } else {
              node2.argument = this.parseExpression();
              this.semicolon();
            }
            return this.finishNode(node2, "ReturnStatement");
          }
          parseSwitchStatement(node2) {
            this.next();
            node2.discriminant = this.parseHeaderExpression();
            const cases = node2.cases = [];
            this.expect(types$1.braceL);
            this.state.labels.push(switchLabel);
            this.scope.enter(SCOPE_OTHER);
            let cur;
            for (let sawDefault; !this.match(types$1.braceR); ) {
              if (this.match(types$1._case) || this.match(types$1._default)) {
                const isCase = this.match(types$1._case);
                if (cur)
                  this.finishNode(cur, "SwitchCase");
                cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                if (isCase) {
                  cur.test = this.parseExpression();
                } else {
                  if (sawDefault) {
                    this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
                  }
                  sawDefault = true;
                  cur.test = null;
                }
                this.expect(types$1.colon);
              } else {
                if (cur) {
                  cur.consequent.push(this.parseStatement(null));
                } else {
                  this.unexpected();
                }
              }
            }
            this.scope.exit();
            if (cur)
              this.finishNode(cur, "SwitchCase");
            this.next();
            this.state.labels.pop();
            return this.finishNode(node2, "SwitchStatement");
          }
          parseThrowStatement(node2) {
            this.next();
            if (this.hasPrecedingLineBreak()) {
              this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
            }
            node2.argument = this.parseExpression();
            this.semicolon();
            return this.finishNode(node2, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const param = this.parseBindingAtom();
            const simple = param.type === "Identifier";
            this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLVal(param, "catch clause", BIND_LEXICAL);
            return param;
          }
          parseTryStatement(node2) {
            this.next();
            node2.block = this.parseBlock();
            node2.handler = null;
            if (this.match(types$1._catch)) {
              const clause = this.startNode();
              this.next();
              if (this.match(types$1.parenL)) {
                this.expect(types$1.parenL);
                clause.param = this.parseCatchClauseParam();
                this.expect(types$1.parenR);
              } else {
                clause.param = null;
                this.scope.enter(SCOPE_OTHER);
              }
              clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));
              this.scope.exit();
              node2.handler = this.finishNode(clause, "CatchClause");
            }
            node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
            if (!node2.handler && !node2.finalizer) {
              this.raise(node2.start, ErrorMessages.NoCatchOrFinally);
            }
            return this.finishNode(node2, "TryStatement");
          }
          parseVarStatement(node2, kind) {
            this.next();
            this.parseVar(node2, false, kind);
            this.semicolon();
            return this.finishNode(node2, "VariableDeclaration");
          }
          parseWhileStatement(node2) {
            this.next();
            node2.test = this.parseHeaderExpression();
            this.state.labels.push(loopLabel);
            node2.body = this.withTopicForbiddingContext(() => this.parseStatement("while"));
            this.state.labels.pop();
            return this.finishNode(node2, "WhileStatement");
          }
          parseWithStatement(node2) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictWith);
            }
            this.next();
            node2.object = this.parseHeaderExpression();
            node2.body = this.withTopicForbiddingContext(() => this.parseStatement("with"));
            return this.finishNode(node2, "WithStatement");
          }
          parseEmptyStatement(node2) {
            this.next();
            return this.finishNode(node2, "EmptyStatement");
          }
          parseLabeledStatement(node2, maybeName, expr2, context) {
            for (const label of this.state.labels) {
              if (label.name === maybeName) {
                this.raise(expr2.start, ErrorMessages.LabelRedeclaration, maybeName);
              }
            }
            const kind = this.state.type.isLoop ? "loop" : this.match(types$1._switch) ? "switch" : null;
            for (let i = this.state.labels.length - 1; i >= 0; i--) {
              const label = this.state.labels[i];
              if (label.statementStart === node2.start) {
                label.statementStart = this.state.start;
                label.kind = kind;
              } else {
                break;
              }
            }
            this.state.labels.push({name: maybeName, kind, statementStart: this.state.start});
            node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
            this.state.labels.pop();
            node2.label = expr2;
            return this.finishNode(node2, "LabeledStatement");
          }
          parseExpressionStatement(node2, expr2) {
            node2.expression = expr2;
            this.semicolon();
            return this.finishNode(node2, "ExpressionStatement");
          }
          parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
            if (allowDirectives === void 0) {
              allowDirectives = false;
            }
            if (createNewLexicalScope === void 0) {
              createNewLexicalScope = true;
            }
            const node2 = this.startNode();
            if (allowDirectives) {
              this.state.strictErrors.clear();
            }
            this.expect(types$1.braceL);
            if (createNewLexicalScope) {
              this.scope.enter(SCOPE_OTHER);
            }
            this.parseBlockBody(node2, allowDirectives, false, types$1.braceR, afterBlockParse);
            if (createNewLexicalScope) {
              this.scope.exit();
            }
            return this.finishNode(node2, "BlockStatement");
          }
          isValidDirective(stmt) {
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
          }
          parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
            const body = node2.body = [];
            const directives = node2.directives = [];
            this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
          }
          parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
            const oldStrict = this.state.strict;
            let hasStrictModeDirective = false;
            let parsedNonDirective = false;
            while (!this.match(end)) {
              const stmt = this.parseStatement(null, topLevel);
              if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                  const directive = this.stmtToDirective(stmt);
                  directives.push(directive);
                  if (!hasStrictModeDirective && directive.value.value === "use strict") {
                    hasStrictModeDirective = true;
                    this.setStrict(true);
                  }
                  continue;
                }
                parsedNonDirective = true;
                this.state.strictErrors.clear();
              }
              body.push(stmt);
            }
            if (afterBlockParse) {
              afterBlockParse.call(this, hasStrictModeDirective);
            }
            if (!oldStrict) {
              this.setStrict(false);
            }
            this.next();
          }
          parseFor(node2, init2) {
            node2.init = init2;
            this.semicolon(false);
            node2.test = this.match(types$1.semi) ? null : this.parseExpression();
            this.semicolon(false);
            node2.update = this.match(types$1.parenR) ? null : this.parseExpression();
            this.expect(types$1.parenR);
            node2.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
            this.scope.exit();
            this.state.labels.pop();
            return this.finishNode(node2, "ForStatement");
          }
          parseForIn(node2, init2, awaitAt) {
            const isForIn = this.match(types$1._in);
            this.next();
            if (isForIn) {
              if (awaitAt > -1)
                this.unexpected(awaitAt);
            } else {
              node2.await = awaitAt > -1;
            }
            if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.state.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
              this.raise(init2.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
            } else if (init2.type === "AssignmentPattern") {
              this.raise(init2.start, ErrorMessages.InvalidLhs, "for-loop");
            }
            node2.left = init2;
            node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
            this.expect(types$1.parenR);
            node2.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
            this.scope.exit();
            this.state.labels.pop();
            return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(node2, isFor, kind) {
            const declarations = node2.declarations = [];
            const isTypescript = this.hasPlugin("typescript");
            node2.kind = kind;
            for (; ; ) {
              const decl = this.startNode();
              this.parseVarId(decl, kind);
              if (this.eat(types$1.eq)) {
                decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
              } else {
                if (kind === "const" && !(this.match(types$1._in) || this.isContextual("of"))) {
                  if (!isTypescript) {
                    this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
                  }
                } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types$1._in) || this.isContextual("of")))) {
                  this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
                }
                decl.init = null;
              }
              declarations.push(this.finishNode(decl, "VariableDeclarator"));
              if (!this.eat(types$1.comma))
                break;
            }
            return node2;
          }
          parseVarId(decl, kind) {
            decl.id = this.parseBindingAtom();
            this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, void 0, kind !== "var");
          }
          parseFunction(node2, statement, isAsync) {
            if (statement === void 0) {
              statement = FUNC_NO_FLAGS;
            }
            if (isAsync === void 0) {
              isAsync = false;
            }
            const isStatement = statement & FUNC_STATEMENT;
            const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
            const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
            this.initFunction(node2, isAsync);
            if (this.match(types$1.star) && isHangingStatement) {
              this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
            }
            node2.generator = this.eat(types$1.star);
            if (isStatement) {
              node2.id = this.parseFunctionId(requireId);
            }
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = false;
            this.scope.enter(SCOPE_FUNCTION);
            this.prodParam.enter(functionFlags(isAsync, node2.generator));
            if (!isStatement) {
              node2.id = this.parseFunctionId();
            }
            this.parseFunctionParams(node2, false);
            this.withTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(node2, isStatement ? "FunctionDeclaration" : "FunctionExpression");
            });
            this.prodParam.exit();
            this.scope.exit();
            if (isStatement && !isHangingStatement) {
              this.registerFunctionStatementId(node2);
            }
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            return node2;
          }
          parseFunctionId(requireId) {
            return requireId || this.match(types$1.name) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(node2, allowModifiers) {
            this.expect(types$1.parenL);
            this.expressionScope.enter(newParameterDeclarationScope());
            node2.params = this.parseBindingList(types$1.parenR, 41, false, allowModifiers);
            this.expressionScope.exit();
          }
          registerFunctionStatementId(node2) {
            if (!node2.id)
              return;
            this.scope.declareName(node2.id.name, this.state.strict || node2.generator || node2.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node2.id.start);
          }
          parseClass(node2, isStatement, optionalId) {
            this.next();
            this.takeDecorators(node2);
            const oldStrict = this.state.strict;
            this.state.strict = true;
            this.parseClassId(node2, isStatement, optionalId);
            this.parseClassSuper(node2);
            node2.body = this.parseClassBody(!!node2.superClass, oldStrict);
            return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(types$1.eq) || this.match(types$1.semi) || this.match(types$1.braceR);
          }
          isClassMethod() {
            return this.match(types$1.parenL);
          }
          isNonstaticConstructor(method) {
            return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
          }
          parseClassBody(hadSuperClass, oldStrict) {
            this.classScope.enter();
            const state = {hadConstructor: false, hadSuperClass};
            let decorators = [];
            const classBody = this.startNode();
            classBody.body = [];
            this.expect(types$1.braceL);
            this.withTopicForbiddingContext(() => {
              while (!this.match(types$1.braceR)) {
                if (this.eat(types$1.semi)) {
                  if (decorators.length > 0) {
                    throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
                  }
                  continue;
                }
                if (this.match(types$1.at)) {
                  decorators.push(this.parseDecorator());
                  continue;
                }
                const member = this.startNode();
                if (decorators.length) {
                  member.decorators = decorators;
                  this.resetStartLocationFromNode(member, decorators[0]);
                  decorators = [];
                }
                this.parseClassMember(classBody, member, state);
                if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                  this.raise(member.start, ErrorMessages.DecoratorConstructor);
                }
              }
            });
            this.state.strict = oldStrict;
            this.next();
            if (decorators.length) {
              throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
            }
            this.classScope.exit();
            return this.finishNode(classBody, "ClassBody");
          }
          parseClassMemberFromModifier(classBody, member) {
            const key = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const method = member;
              method.kind = "method";
              method.computed = false;
              method.key = key;
              method.static = false;
              this.pushClassMethod(classBody, method, false, false, false, false);
              return true;
            } else if (this.isClassProperty()) {
              const prop2 = member;
              prop2.computed = false;
              prop2.key = key;
              prop2.static = false;
              classBody.body.push(this.parseClassProperty(prop2));
              return true;
            }
            return false;
          }
          parseClassMember(classBody, member, state) {
            const isStatic = this.isContextual("static");
            if (isStatic) {
              if (this.parseClassMemberFromModifier(classBody, member)) {
                return;
              }
              if (this.eat(types$1.braceL)) {
                this.parseClassStaticBlock(classBody, member);
                return;
              }
            }
            this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
          parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const publicMethod = member;
            const privateMethod = member;
            const publicProp = member;
            const privateProp = member;
            const method = publicMethod;
            const publicMember = publicMethod;
            member.static = isStatic;
            if (this.eat(types$1.star)) {
              method.kind = "method";
              this.parseClassElementName(method);
              if (this.isPrivateName(method.key)) {
                this.pushClassPrivateMethod(classBody, privateMethod, true, false);
                return;
              }
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
              }
              this.pushClassMethod(classBody, publicMethod, true, false, false, false);
              return;
            }
            const containsEsc = this.state.containsEsc;
            const key = this.parseClassElementName(member);
            const isPrivate = this.isPrivateName(key);
            const isSimple = key.type === "Identifier";
            const maybeQuestionTokenStart = this.state.start;
            this.parsePostMemberNameModifiers(publicMember);
            if (this.isClassMethod()) {
              method.kind = "method";
              if (isPrivate) {
                this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                return;
              }
              const isConstructor = this.isNonstaticConstructor(publicMethod);
              let allowsDirectSuper = false;
              if (isConstructor) {
                publicMethod.kind = "constructor";
                if (state.hadConstructor && !this.hasPlugin("typescript")) {
                  this.raise(key.start, ErrorMessages.DuplicateConstructor);
                }
                if (isConstructor && this.hasPlugin("typescript") && member.override) {
                  this.raise(key.start, ErrorMessages.OverrideOnConstructor);
                }
                state.hadConstructor = true;
                allowsDirectSuper = state.hadSuperClass;
              }
              this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
            } else if (this.isClassProperty()) {
              if (isPrivate) {
                this.pushClassPrivateProperty(classBody, privateProp);
              } else {
                this.pushClassProperty(classBody, publicProp);
              }
            } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
              const isGenerator = this.eat(types$1.star);
              if (publicMember.optional) {
                this.unexpected(maybeQuestionTokenStart);
              }
              method.kind = "method";
              this.parseClassElementName(method);
              this.parsePostMemberNameModifiers(publicMember);
              if (this.isPrivateName(method.key)) {
                this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
              } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                  this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
                }
                this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
              }
            } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types$1.star) && this.isLineTerminator())) {
              method.kind = key.name;
              this.parseClassElementName(publicMethod);
              if (this.isPrivateName(method.key)) {
                this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                  this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
                }
                this.pushClassMethod(classBody, publicMethod, false, false, false, false);
              }
              this.checkGetterSetterParams(publicMethod);
            } else if (this.isLineTerminator()) {
              if (isPrivate) {
                this.pushClassPrivateProperty(classBody, privateProp);
              } else {
                this.pushClassProperty(classBody, publicProp);
              }
            } else {
              this.unexpected();
            }
          }
          parseClassElementName(member) {
            const key = this.parsePropertyName(member, true);
            if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
              this.raise(key.start, ErrorMessages.StaticPrototype);
            }
            if (this.isPrivateName(key) && this.getPrivateNameSV(key) === "constructor") {
              this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);
            }
            return key;
          }
          parseClassStaticBlock(classBody, member) {
            var _member$decorators;
            this.expectPlugin("classStaticBlock", member.start);
            this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(PARAM);
            const body = member.body = [];
            this.parseBlockOrModuleBlockBody(body, void 0, false, types$1.braceR);
            this.prodParam.exit();
            this.scope.exit();
            this.state.labels = oldLabels;
            classBody.body.push(this.finishNode(member, "StaticBlock"));
            if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
              this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
            }
          }
          pushClassProperty(classBody, prop2) {
            if (!prop2.computed && (prop2.key.name === "constructor" || prop2.key.value === "constructor")) {
              this.raise(prop2.key.start, ErrorMessages.ConstructorClassField);
            }
            classBody.body.push(this.parseClassProperty(prop2));
          }
          pushClassPrivateProperty(classBody, prop2) {
            const node2 = this.parseClassPrivateProperty(prop2);
            classBody.body.push(node2);
            this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER, node2.key.start);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const node2 = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
            classBody.body.push(node2);
            const kind = node2.kind === "get" ? node2.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node2.kind === "set" ? node2.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
            this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.start);
          }
          parsePostMemberNameModifiers(methodOrProp) {
          }
          parseClassPrivateProperty(node2) {
            this.parseInitializer(node2);
            this.semicolon();
            return this.finishNode(node2, "ClassPrivateProperty");
          }
          parseClassProperty(node2) {
            this.parseInitializer(node2);
            this.semicolon();
            return this.finishNode(node2, "ClassProperty");
          }
          parseInitializer(node2) {
            this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
            this.expressionScope.enter(newExpressionScope());
            this.prodParam.enter(PARAM);
            node2.value = this.eat(types$1.eq) ? this.parseMaybeAssignAllowIn() : null;
            this.expressionScope.exit();
            this.prodParam.exit();
            this.scope.exit();
          }
          parseClassId(node2, isStatement, optionalId, bindingType) {
            if (bindingType === void 0) {
              bindingType = BIND_CLASS;
            }
            if (this.match(types$1.name)) {
              node2.id = this.parseIdentifier();
              if (isStatement) {
                this.checkLVal(node2.id, "class name", bindingType);
              }
            } else {
              if (optionalId || !isStatement) {
                node2.id = null;
              } else {
                this.unexpected(null, ErrorMessages.MissingClassName);
              }
            }
          }
          parseClassSuper(node2) {
            node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts() : null;
          }
          parseExport(node2) {
            const hasDefault = this.maybeParseExportDefaultSpecifier(node2);
            const parseAfterDefault = !hasDefault || this.eat(types$1.comma);
            const hasStar = parseAfterDefault && this.eatExportStar(node2);
            const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2);
            const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types$1.comma));
            const isFromRequired = hasDefault || hasStar;
            if (hasStar && !hasNamespace) {
              if (hasDefault)
                this.unexpected();
              this.parseExportFrom(node2, true);
              return this.finishNode(node2, "ExportAllDeclaration");
            }
            const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2);
            if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
              throw this.unexpected(null, types$1.braceL);
            }
            let hasDeclaration;
            if (isFromRequired || hasSpecifiers) {
              hasDeclaration = false;
              this.parseExportFrom(node2, isFromRequired);
            } else {
              hasDeclaration = this.maybeParseExportDeclaration(node2);
            }
            if (isFromRequired || hasSpecifiers || hasDeclaration) {
              this.checkExport(node2, true, false, !!node2.source);
              return this.finishNode(node2, "ExportNamedDeclaration");
            }
            if (this.eat(types$1._default)) {
              node2.declaration = this.parseExportDefaultExpression();
              this.checkExport(node2, true, true);
              return this.finishNode(node2, "ExportDefaultDeclaration");
            }
            throw this.unexpected(null, types$1.braceL);
          }
          eatExportStar(node2) {
            return this.eat(types$1.star);
          }
          maybeParseExportDefaultSpecifier(node2) {
            if (this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom");
              const specifier = this.startNode();
              specifier.exported = this.parseIdentifier(true);
              node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
              return true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(node2) {
            if (this.isContextual("as")) {
              if (!node2.specifiers)
                node2.specifiers = [];
              const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
              this.next();
              specifier.exported = this.parseModuleExportName();
              node2.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
              return true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(node2) {
            if (this.match(types$1.braceL)) {
              if (!node2.specifiers)
                node2.specifiers = [];
              node2.specifiers.push(...this.parseExportSpecifiers());
              node2.source = null;
              node2.declaration = null;
              return true;
            }
            return false;
          }
          maybeParseExportDeclaration(node2) {
            if (this.shouldParseExportDeclaration()) {
              node2.specifiers = [];
              node2.source = null;
              node2.declaration = this.parseExportDeclaration(node2);
              return true;
            }
            return false;
          }
          isAsyncFunction() {
            if (!this.isContextual("async"))
              return false;
            const next = this.nextTokenStart();
            return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
          }
          parseExportDefaultExpression() {
            const expr2 = this.startNode();
            const isAsync = this.isAsyncFunction();
            if (this.match(types$1._function) || isAsync) {
              this.next();
              if (isAsync) {
                this.next();
              }
              return this.parseFunction(expr2, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
            } else if (this.match(types$1._class)) {
              return this.parseClass(expr2, true, true);
            } else if (this.match(types$1.at)) {
              if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
              }
              this.parseDecorators(false);
              return this.parseClass(expr2, true, true);
            } else if (this.match(types$1._const) || this.match(types$1._var) || this.isLet()) {
              throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
            } else {
              const res = this.parseMaybeAssignAllowIn();
              this.semicolon();
              return res;
            }
          }
          parseExportDeclaration(node2) {
            return this.parseStatement(null);
          }
          isExportDefaultSpecifier() {
            if (this.match(types$1.name)) {
              const value = this.state.value;
              if (value === "async" && !this.state.containsEsc || value === "let") {
                return false;
              }
              if ((value === "type" || value === "interface") && !this.state.containsEsc) {
                const l = this.lookahead();
                if (l.type === types$1.name && l.value !== "from" || l.type === types$1.braceL) {
                  this.expectOnePlugin(["flow", "typescript"]);
                  return false;
                }
              }
            } else if (!this.match(types$1._default)) {
              return false;
            }
            const next = this.nextTokenStart();
            const hasFrom = this.isUnparsedContextual(next, "from");
            if (this.input.charCodeAt(next) === 44 || this.match(types$1.name) && hasFrom) {
              return true;
            }
            if (this.match(types$1._default) && hasFrom) {
              const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
              return nextAfterFrom === 34 || nextAfterFrom === 39;
            }
            return false;
          }
          parseExportFrom(node2, expect) {
            if (this.eatContextual("from")) {
              node2.source = this.parseImportSource();
              this.checkExport(node2);
              const assertions = this.maybeParseImportAssertions();
              if (assertions) {
                node2.assertions = assertions;
              }
            } else {
              if (expect) {
                this.unexpected();
              } else {
                node2.source = null;
              }
            }
            this.semicolon();
          }
          shouldParseExportDeclaration() {
            if (this.match(types$1.at)) {
              this.expectOnePlugin(["decorators", "decorators-legacy"]);
              if (this.hasPlugin("decorators")) {
                if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                  this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
                } else {
                  return true;
                }
              }
            }
            return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
          }
          checkExport(node2, checkNames, isDefault, isFrom) {
            if (checkNames) {
              if (isDefault) {
                this.checkDuplicateExports(node2, "default");
                if (this.hasPlugin("exportDefaultFrom")) {
                  var _declaration$extra;
                  const declaration = node2.declaration;
                  if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                    this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
                  }
                }
              } else if (node2.specifiers && node2.specifiers.length) {
                for (const specifier of node2.specifiers) {
                  const {exported} = specifier;
                  const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
                  this.checkDuplicateExports(specifier, exportedName);
                  if (!isFrom && specifier.local) {
                    const {local} = specifier;
                    if (local.type === "StringLiteral") {
                      this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
                    } else {
                      this.checkReservedWord(local.name, local.start, true, false);
                      this.scope.checkLocalExport(local);
                    }
                  }
                }
              } else if (node2.declaration) {
                if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
                  const id = node2.declaration.id;
                  if (!id)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(node2, id.name);
                } else if (node2.declaration.type === "VariableDeclaration") {
                  for (const declaration of node2.declaration.declarations) {
                    this.checkDeclaration(declaration.id);
                  }
                }
              }
            }
            const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            if (currentContextDecorators.length) {
              throw this.raise(node2.start, ErrorMessages.UnsupportedDecoratorExport);
            }
          }
          checkDeclaration(node2) {
            if (node2.type === "Identifier") {
              this.checkDuplicateExports(node2, node2.name);
            } else if (node2.type === "ObjectPattern") {
              for (const prop2 of node2.properties) {
                this.checkDeclaration(prop2);
              }
            } else if (node2.type === "ArrayPattern") {
              for (const elem of node2.elements) {
                if (elem) {
                  this.checkDeclaration(elem);
                }
              }
            } else if (node2.type === "ObjectProperty") {
              this.checkDeclaration(node2.value);
            } else if (node2.type === "RestElement") {
              this.checkDeclaration(node2.argument);
            } else if (node2.type === "AssignmentPattern") {
              this.checkDeclaration(node2.left);
            }
          }
          checkDuplicateExports(node2, name) {
            if (this.state.exportedIdentifiers.indexOf(name) > -1) {
              this.raise(node2.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
            }
            this.state.exportedIdentifiers.push(name);
          }
          parseExportSpecifiers() {
            const nodes = [];
            let first = true;
            this.expect(types$1.braceL);
            while (!this.eat(types$1.braceR)) {
              if (first) {
                first = false;
              } else {
                this.expect(types$1.comma);
                if (this.eat(types$1.braceR))
                  break;
              }
              const node2 = this.startNode();
              node2.local = this.parseModuleExportName();
              node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local.__clone();
              nodes.push(this.finishNode(node2, "ExportSpecifier"));
            }
            return nodes;
          }
          parseModuleExportName() {
            if (this.match(types$1.string)) {
              const result = this.parseLiteral(this.state.value, "StringLiteral");
              const surrogate = result.value.match(loneSurrogate);
              if (surrogate) {
                this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
              }
              return result;
            }
            return this.parseIdentifier(true);
          }
          parseImport(node2) {
            node2.specifiers = [];
            if (!this.match(types$1.string)) {
              const hasDefault = this.maybeParseDefaultImportSpecifier(node2);
              const parseNext = !hasDefault || this.eat(types$1.comma);
              const hasStar = parseNext && this.maybeParseStarImportSpecifier(node2);
              if (parseNext && !hasStar)
                this.parseNamedImportSpecifiers(node2);
              this.expectContextual("from");
            }
            node2.source = this.parseImportSource();
            const assertions = this.maybeParseImportAssertions();
            if (assertions) {
              node2.assertions = assertions;
            } else {
              const attributes = this.maybeParseModuleAttributes();
              if (attributes) {
                node2.attributes = attributes;
              }
            }
            this.semicolon();
            return this.finishNode(node2, "ImportDeclaration");
          }
          parseImportSource() {
            if (!this.match(types$1.string))
              this.unexpected();
            return this.parseExprAtom();
          }
          shouldParseDefaultImport(node2) {
            return this.match(types$1.name);
          }
          parseImportSpecifierLocal(node2, specifier, type2, contextDescription) {
            specifier.local = this.parseIdentifier();
            this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
            node2.specifiers.push(this.finishNode(specifier, type2));
          }
          parseAssertEntries() {
            const attrs = [];
            const attrNames = new Set();
            do {
              if (this.match(types$1.braceR)) {
                break;
              }
              const node2 = this.startNode();
              const keyName = this.state.value;
              if (this.match(types$1.string)) {
                node2.key = this.parseLiteral(keyName, "StringLiteral");
              } else {
                node2.key = this.parseIdentifier(true);
              }
              this.expect(types$1.colon);
              if (keyName !== "type") {
                this.raise(node2.key.start, ErrorMessages.ModuleAttributeDifferentFromType, keyName);
              }
              if (attrNames.has(keyName)) {
                this.raise(node2.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
              }
              attrNames.add(keyName);
              if (!this.match(types$1.string)) {
                throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
              }
              node2.value = this.parseLiteral(this.state.value, "StringLiteral");
              this.finishNode(node2, "ImportAttribute");
              attrs.push(node2);
            } while (this.eat(types$1.comma));
            return attrs;
          }
          maybeParseModuleAttributes() {
            if (this.match(types$1._with) && !this.hasPrecedingLineBreak()) {
              this.expectPlugin("moduleAttributes");
              this.next();
            } else {
              if (this.hasPlugin("moduleAttributes"))
                return [];
              return null;
            }
            const attrs = [];
            const attributes = new Set();
            do {
              const node2 = this.startNode();
              node2.key = this.parseIdentifier(true);
              if (node2.key.name !== "type") {
                this.raise(node2.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node2.key.name);
              }
              if (attributes.has(node2.key.name)) {
                this.raise(node2.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node2.key.name);
              }
              attributes.add(node2.key.name);
              this.expect(types$1.colon);
              if (!this.match(types$1.string)) {
                throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
              }
              node2.value = this.parseLiteral(this.state.value, "StringLiteral");
              this.finishNode(node2, "ImportAttribute");
              attrs.push(node2);
            } while (this.eat(types$1.comma));
            return attrs;
          }
          maybeParseImportAssertions() {
            if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
              this.expectPlugin("importAssertions");
              this.next();
            } else {
              if (this.hasPlugin("importAssertions"))
                return [];
              return null;
            }
            this.eat(types$1.braceL);
            const attrs = this.parseAssertEntries();
            this.eat(types$1.braceR);
            return attrs;
          }
          maybeParseDefaultImportSpecifier(node2) {
            if (this.shouldParseDefaultImport(node2)) {
              this.parseImportSpecifierLocal(node2, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
              return true;
            }
            return false;
          }
          maybeParseStarImportSpecifier(node2) {
            if (this.match(types$1.star)) {
              const specifier = this.startNode();
              this.next();
              this.expectContextual("as");
              this.parseImportSpecifierLocal(node2, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
              return true;
            }
            return false;
          }
          parseNamedImportSpecifiers(node2) {
            let first = true;
            this.expect(types$1.braceL);
            while (!this.eat(types$1.braceR)) {
              if (first) {
                first = false;
              } else {
                if (this.eat(types$1.colon)) {
                  throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
                }
                this.expect(types$1.comma);
                if (this.eat(types$1.braceR))
                  break;
              }
              this.parseImportSpecifier(node2);
            }
          }
          parseImportSpecifier(node2) {
            const specifier = this.startNode();
            specifier.imported = this.parseModuleExportName();
            if (this.eatContextual("as")) {
              specifier.local = this.parseIdentifier();
            } else {
              const {imported} = specifier;
              if (imported.type === "StringLiteral") {
                throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
              }
              this.checkReservedWord(imported.name, specifier.start, true, true);
              specifier.local = imported.__clone();
            }
            this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
            node2.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
          }
          isThisParam(param) {
            return param.type === "Identifier" && param.name === "this";
          }
        }
        class Parser extends StatementParser {
          constructor(options2, input) {
            options2 = getOptions(options2);
            super(options2, input);
            this.options = options2;
            this.initializeScopes();
            this.plugins = pluginsMap(this.options.plugins);
            this.filename = options2.sourceFilename;
          }
          getScopeHandler() {
            return ScopeHandler;
          }
          parse() {
            this.enterInitialScopes();
            const file = this.startNode();
            const program = this.startNode();
            this.nextToken();
            file.errors = null;
            this.parseTopLevel(file, program);
            file.errors = this.state.errors;
            return file;
          }
        }
        function pluginsMap(plugins) {
          const pluginMap = new Map();
          for (const plugin of plugins) {
            const [name, options2] = Array.isArray(plugin) ? plugin : [plugin, {}];
            if (!pluginMap.has(name))
              pluginMap.set(name, options2 || {});
          }
          return pluginMap;
        }
        function parse$1(input, options2) {
          var _options;
          if (((_options = options2) == null ? void 0 : _options.sourceType) === "unambiguous") {
            options2 = Object.assign({}, options2);
            try {
              options2.sourceType = "module";
              const parser2 = getParser(options2, input);
              const ast = parser2.parse();
              if (parser2.sawUnambiguousESM) {
                return ast;
              }
              if (parser2.ambiguousScriptDifferentAst) {
                try {
                  options2.sourceType = "script";
                  return getParser(options2, input).parse();
                } catch (_unused) {
                }
              } else {
                ast.program.sourceType = "script";
              }
              return ast;
            } catch (moduleError) {
              try {
                options2.sourceType = "script";
                return getParser(options2, input).parse();
              } catch (_unused2) {
              }
              throw moduleError;
            }
          } else {
            return getParser(options2, input).parse();
          }
        }
        function parseExpression(input, options2) {
          const parser2 = getParser(options2, input);
          if (parser2.options.strictMode) {
            parser2.state.strict = true;
          }
          return parser2.getExpression();
        }
        function getParser(options2, input) {
          let cls = Parser;
          if (options2 != null && options2.plugins) {
            validatePlugins(options2.plugins);
            cls = getParserClass(options2.plugins);
          }
          return new cls(options2, input);
        }
        const parserClassCache = {};
        function getParserClass(pluginsFromOptions) {
          const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
          const key = pluginList.join("/");
          let cls = parserClassCache[key];
          if (!cls) {
            cls = Parser;
            for (const plugin of pluginList) {
              cls = mixinPlugins[plugin](cls);
            }
            parserClassCache[key] = cls;
          }
          return cls;
        }
        var parse_1 = parse$1;
        var parseExpression_1 = parseExpression;
        var tokTypes = types$1;
        var lib = /* @__PURE__ */ Object.defineProperty({parse: parse_1, parseExpression: parseExpression_1, tokTypes}, "__esModule", {value: true});
        var babel = createCommonjsModule(function(module3, exports4) {
          Object.defineProperty(exports4, "__esModule", {value: true});
          exports4.parse = exports4.parser = void 0;
          var _babel_options_1 = tslib_1.__importDefault(_babel_options);
          exports4.parser = function() {
            try {
              return lib;
            } catch (e) {
              return require$$2__default["default"];
            }
          }();
          function parse(source, options2) {
            var babelOptions = _babel_options_1.default(options2);
            babelOptions.plugins.push("jsx", "flow");
            return exports4.parser.parse(source, babelOptions);
          }
          exports4.parse = parse;
        });
        function generateAST(source, options2) {
          return main.parse(source, Object.assign({parser: {parse: babel.parse}}, options2));
        }
        function findExportDefaultStatement(body) {
          return body.find(isExportDefaultStatement);
        }
        function findAllImportDeclarations(body) {
          return body.filter(isImportDeclaration);
        }
        function filterOutAllImportDeclarations(body) {
          return body.filter((n2) => !isImportDeclaration(n2));
        }
        function createDefaultExportFromLegacySyntax(body) {
          return builders.exportDefaultDeclaration(builders.functionDeclaration(builders.identifier(TAG_LOGIC_PROPERTY), [], builders.blockStatement([...filterOutAllImportDeclarations(body), builders.returnStatement(builders.thisExpression())])));
        }
        function filterNonExportDefaultStatements(body) {
          return body.filter((node2) => !isExportDefaultStatement(node2) && !isThisExpressionStatement(node2));
        }
        function getProgramBody(ast) {
          return ast.body || ast.program.body;
        }
        function extendTagProperty(ast, exportDefaultNode) {
          types$2.visit(ast, {visitProperty(path2) {
            if (path2.value.key.value === TAG_LOGIC_PROPERTY) {
              path2.value.value = exportDefaultNode.declaration;
              return false;
            }
            this.traverse(path2);
          }});
          return ast;
        }
        function javascript(sourceNode2, source, meta, ast) {
          const preprocessorName = getPreprocessorTypeByAttribute(sourceNode2);
          const javascriptNode = addLineOffset(sourceNode2.text.text, source, sourceNode2);
          const {options: options2} = meta;
          const preprocessorOutput = preprocess("javascript", preprocessorName, meta, Object.assign({}, sourceNode2, {text: javascriptNode}));
          const inputSourceMap = sourcemapAsJSON(preprocessorOutput.map);
          const generatedAst = generateAST(preprocessorOutput.code, {sourceFileName: options2.file, inputSourceMap: isEmptySourcemap(inputSourceMap) ? null : inputSourceMap});
          const generatedAstBody = getProgramBody(generatedAst);
          const exportDefaultNode = findExportDefaultStatement(generatedAstBody);
          const isLegacyRiotSyntax = isNil2(exportDefaultNode);
          const outputBody = getProgramBody(ast);
          if (exportDefaultNode && generatedAstBody.some(isThisExpressionStatement))
            throw new Error('You can	 use "export default {}" and root this statements in the same component');
          outputBody.unshift(...isLegacyRiotSyntax ? findAllImportDeclarations(generatedAstBody) : filterNonExportDefaultStatements(generatedAstBody));
          if (isLegacyRiotSyntax)
            extendTagProperty(ast, createDefaultExportFromLegacySyntax(generatedAstBody));
          if (exportDefaultNode)
            extendTagProperty(ast, exportDefaultNode);
          return ast;
        }
        const JAVASCRIPT_OUTPUT_NAME = "javascript";
        const CSS_OUTPUT_NAME = "css";
        const TEMPLATE_OUTPUT_NAME = "template";
        const JAVASCRIPT_TAG = "script";
        const STYLE_TAG = "style";
        const TEXTAREA_TAG = "textarea";
        const IS_RAW = "isRaw";
        const IS_SELF_CLOSING = "isSelfClosing";
        const IS_VOID = "isVoid";
        const IS_BOOLEAN = "isBoolean";
        const IS_CUSTOM = "isCustom";
        const IS_SPREAD = "isSpread";
        var c = /* @__PURE__ */ Object.freeze({__proto__: null, JAVASCRIPT_OUTPUT_NAME, CSS_OUTPUT_NAME, TEMPLATE_OUTPUT_NAME, JAVASCRIPT_TAG, STYLE_TAG, TEXTAREA_TAG, IS_RAW, IS_SELF_CLOSING, IS_VOID, IS_BOOLEAN, IS_CUSTOM, IS_SPREAD});
        const TAG2 = 1;
        const ATTR = 2;
        const TEXT2 = 3;
        const CDATA = 4;
        const COMMENT = 8;
        const DOCUMENT = 9;
        const DOCTYPE = 10;
        const DOCUMENT_FRAGMENT = 11;
        var types = /* @__PURE__ */ Object.freeze({__proto__: null, TAG: TAG2, ATTR, TEXT: TEXT2, CDATA, COMMENT, DOCUMENT, DOCTYPE, DOCUMENT_FRAGMENT});
        const rootTagNotFound = "Root tag not found.";
        const unclosedTemplateLiteral = "Unclosed ES6 template literal.";
        const unexpectedEndOfFile = "Unexpected end of file.";
        const unclosedComment = "Unclosed comment.";
        const unclosedNamedBlock = 'Unclosed "%1" block.';
        const duplicatedNamedTag = 'Multiple inline "<%1>" tags are not supported.';
        const unexpectedCharInExpression = "Unexpected character %1.";
        const unclosedExpression = "Unclosed expression.";
        const TAG_2C = /^(?:\/[a-zA-Z]|[a-zA-Z][^\s>/]?)/;
        const TAG_NAME = /(\/?[^\s>/]+)\s*(>)?/g;
        const ATTR_START = /(\S[^>/=\s]*)(?:\s*=\s*([^>/])?)?/g;
        const SPREAD_OPERATOR = /\.\.\./;
        const RE_SCRYLE = {script: /<\/script\s*>/gi, style: /<\/style\s*>/gi, textarea: /<\/textarea\s*>/gi};
        const RAW_TAGS = /^\/?(?:pre|textarea)$/;
        function addToCollection(collection, item) {
          if (collection === void 0) {
            collection = [];
          }
          collection.push(item);
          return collection;
        }
        function execFromPos(re, pos, string) {
          re.lastIndex = pos;
          return re.exec(string);
        }
        var escapeStr = (str) => str.replace(/(?=[-[\](){^*+?.$|\\])/g, "\\");
        function formatError(data, message, pos) {
          if (!pos) {
            pos = data.length;
          }
          const line = (data.slice(0, pos).match(/\r\n?|\n/g) || "").length + 1;
          let col = 0;
          while (--pos >= 0 && !/[\r\n]/.test(data[pos])) {
            ++col;
          }
          return `[${line},${col}]: ${message}`;
        }
        const $_ES6_BQ = "`";
        function skipES6TL(code, pos, stack) {
          const re = /[`$\\]/g;
          let c2;
          while (re.lastIndex = pos, re.exec(code)) {
            pos = re.lastIndex;
            c2 = code[pos - 1];
            if (c2 === "`") {
              return pos;
            }
            if (c2 === "$" && code[pos++] === "{") {
              stack.push($_ES6_BQ, "}");
              return pos;
            }
          }
          throw formatError(code, unclosedTemplateLiteral, pos);
        }
        function panic2(data, msg, pos) {
          const message = formatError(data, msg, pos);
          throw new Error(message);
        }
        const beforeReChars = "[{(,;:?=|&!^~>%*/";
        const beforeReSign = `${beforeReChars}+-`;
        const beforeReWords = ["case", "default", "do", "else", "in", "instanceof", "prefix", "return", "typeof", "void", "yield"];
        const wordsEndChar = beforeReWords.reduce((s, w) => s + w.slice(-1), "");
        const RE_LIT_REGEX = /^\/(?=[^*>/])[^[/\\]*(?:(?:\\.|\[(?:\\.|[^\]\\]*)*\])[^[\\/]*)*?\/[gimuy]*/;
        const RE_JS_VCHAR = /[$\w]/;
        const RE_DOT_CHAR = /.*/g;
        function _prev(code, pos) {
          while (--pos >= 0 && /\s/.test(code[pos]))
            ;
          return pos;
        }
        function skipRegex(code, start) {
          let pos = RE_DOT_CHAR.lastIndex = start++;
          const match = (RE_DOT_CHAR.exec(code) || " ")[0].match(RE_LIT_REGEX);
          if (match) {
            const next = pos + match[0].length;
            pos = _prev(code, pos);
            let c2 = code[pos];
            if (pos < 0 || beforeReChars.includes(c2)) {
              return next;
            }
            if (c2 === ".") {
              if (code[pos - 1] === ".") {
                start = next;
              }
            } else {
              if (c2 === "+" || c2 === "-") {
                if (code[--pos] !== c2 || (pos = _prev(code, pos)) < 0 || beforeReSign.includes(c2 = code[pos])) {
                  return next;
                }
              }
              if (wordsEndChar.includes(c2)) {
                const end = pos + 1;
                while (--pos >= 0 && RE_JS_VCHAR.test(code[pos]))
                  ;
                if (beforeReWords.includes(code.slice(pos + 1, end))) {
                  start = next;
                }
              }
            }
          }
          return start;
        }
        const S_SQ_STR = /'[^'\n\r\\]*(?:\\(?:\r\n?|[\S\s])[^'\n\r\\]*)*'/.source;
        const S_STRING = `${S_SQ_STR}|${S_SQ_STR.replace(/'/g, '"')}`;
        const reBr = {};
        function _regex(b) {
          let re = reBr[b];
          if (!re) {
            let s = escapeStr(b);
            if (b.length > 1) {
              s = `${s}|[`;
            } else {
              s = /[{}[\]()]/.test(b) ? "[" : `[${s}`;
            }
            reBr[b] = re = new RegExp(`${S_STRING}|${s}\`/\\{}[\\]()]`, "g");
          }
          return re;
        }
        function updateStack(stack, char, idx, code) {
          let index = 0;
          switch (char) {
            case "[":
            case "(":
            case "{":
              stack.push(char === "[" ? "]" : char === "(" ? ")" : "}");
              break;
            case ")":
            case "]":
            case "}":
              if (char !== stack.pop()) {
                panic2(code, unexpectedCharInExpression.replace("%1", char), index);
              }
              if (char === "}" && stack[stack.length - 1] === $_ES6_BQ) {
                char = stack.pop();
              }
              index = idx + 1;
              break;
            case "/":
              index = skipRegex(code, idx);
          }
          return {char, index};
        }
        function exprExtr(code, start, bp) {
          const [openingBraces, closingBraces] = bp;
          const offset = start + openingBraces.length;
          const stack = [];
          const re = _regex(closingBraces);
          re.lastIndex = offset;
          let end;
          let match;
          while (match = re.exec(code)) {
            const idx = match.index;
            const str = match[0];
            end = re.lastIndex;
            if (str === closingBraces && !stack.length) {
              return {text: code.slice(offset, idx), start, end};
            }
            const {char, index} = updateStack(stack, str[0], idx, code);
            end = index || end;
            re.lastIndex = char === $_ES6_BQ ? skipES6TL(code, end, stack) : end;
          }
          if (stack.length) {
            panic2(code, unclosedExpression, end);
          }
        }
        function flush(store) {
          const last2 = store.last;
          store.last = null;
          if (last2 && store.root) {
            store.builder.push(last2);
          }
        }
        function getChunk(source, start, end) {
          return source.slice(start, end);
        }
        function pushText(state, start, end, extra) {
          if (extra === void 0) {
            extra = {};
          }
          const text2 = getChunk(state.data, start, end);
          const expressions2 = extra.expressions;
          const unescape = extra.unescape;
          let q = state.last;
          state.pos = end;
          if (q && q.type === TEXT2) {
            q.text += text2;
            q.end = end;
          } else {
            flush(state);
            state.last = q = {type: TEXT2, text: text2, start, end};
          }
          if (expressions2 && expressions2.length) {
            q.expressions = (q.expressions || []).concat(expressions2);
          }
          if (unescape) {
            q.unescape = unescape;
          }
          return TEXT2;
        }
        function expr(state, node2, endingChars, start) {
          const re = b0re(state, endingChars);
          re.lastIndex = start;
          const {unescape, expressions: expressions2, end} = parseExpressions(state, re);
          if (node2) {
            if (unescape) {
              node2.unescape = unescape;
            }
            if (expressions2.length) {
              node2.expressions = expressions2;
            }
          } else {
            pushText(state, start, end, {expressions: expressions2, unescape});
          }
          return end;
        }
        function parseExpressions(state, re) {
          const {data, options: options2} = state;
          const {brackets} = options2;
          const expressions2 = [];
          let unescape, pos, match;
          while ((match = re.exec(data)) && !match[1]) {
            pos = match.index;
            if (data[pos - 1] === "\\") {
              unescape = match[0];
            } else {
              const tmpExpr = exprExtr(data, pos, brackets);
              if (tmpExpr) {
                expressions2.push(tmpExpr);
                re.lastIndex = tmpExpr.end;
              }
            }
          }
          if (!match) {
            panic2(data, unexpectedEndOfFile, pos);
          }
          return {unescape, expressions: expressions2, end: match.index};
        }
        function b0re(state, str) {
          const {brackets} = state.options;
          const re = state.regexCache[str];
          if (re)
            return re;
          const b0 = escapeStr(brackets[0]);
          Object.assign(state.regexCache, {[str]: new RegExp(`(${str})|${b0}`, "g")});
          return state.regexCache[str];
        }
        const uniq = (l) => l.filter((x, i, a) => a.indexOf(x) === i);
        const VOID_SVG_TAGS_LIST = ["circle", "ellipse", "line", "path", "polygon", "polyline", "rect", "stop", "use"];
        const HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_LIST = ["button", "data", "input", "select", "li", "meter", "option", "output", "progress", "textarea", "param"];
        const SVG_TAGS_LIST = uniq(["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "animation", "audio", "canvas", "clipPath", "color-profile", "cursor", "defs", "desc", "discard", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "handler", "hatch", "hatchpath", "hkern", "iframe", "image", "linearGradient", "listener", "marker", "mask", "mesh", "meshgradient", "meshpatch", "meshrow", "metadata", "missing-glyph", "mpath", "pattern", "prefetch", "radialGradient", "script", "set", "solidColor", "solidcolor", "style", "svg", "switch", "symbol", "tbreak", "text", "textArea", "textPath", "title", "tref", "tspan", "unknown", "video", "view", "vkern"].concat(VOID_SVG_TAGS_LIST)).sort();
        const VOID_HTML_TAGS_LIST = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"];
        const HTML_TAGS_LIST = uniq(["a", "abbr", "address", "article", "aside", "audio", "b", "bdi", "bdo", "blockquote", "body", "canvas", "caption", "cite", "code", "colgroup", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "html", "i", "iframe", "ins", "kbd", "label", "legend", "main", "map", "mark", "math", "menu", "nav", "noscript", "object", "ol", "optgroup", "p", "picture", "pre", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "tfoot", "th", "thead", "time", "title", "tr", "u", "ul", "var", "video"].concat(VOID_HTML_TAGS_LIST).concat(HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_LIST)).sort();
        const BOOLEAN_ATTRIBUTES_LIST = ["disabled", "visible", "checked", "readonly", "required", "allowfullscreen", "autofocus", "autoplay", "compact", "controls", "default", "formnovalidate", "hidden", "ismap", "itemscope", "loop", "multiple", "muted", "noresize", "noshade", "novalidate", "nowrap", "open", "reversed", "seamless", "selected", "sortable", "truespeed", "typemustmatch"];
        function joinWithPipe(list) {
          return list.join("|");
        }
        function listsToRegex() {
          for (var _len14 = arguments.length, lists = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
            lists[_key14] = arguments[_key14];
          }
          return new RegExp(`^/?(?:${joinWithPipe(lists.map(joinWithPipe))})$`, "i");
        }
        const HTML_TAGS_RE = listsToRegex(HTML_TAGS_LIST);
        const SVG_TAGS_RE = listsToRegex(SVG_TAGS_LIST);
        const VOID_HTML_TAGS_RE = listsToRegex(VOID_HTML_TAGS_LIST);
        const VOID_SVG_TAGS_RE = listsToRegex(VOID_SVG_TAGS_LIST);
        const HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_RE = listsToRegex(HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_LIST);
        const BOOLEAN_ATTRIBUTES_RE = listsToRegex(BOOLEAN_ATTRIBUTES_LIST);
        function isVoid(tag2) {
          return [VOID_HTML_TAGS_RE, VOID_SVG_TAGS_RE].some((r) => r.test(tag2));
        }
        function isCustom(tag2) {
          return [HTML_TAGS_RE, SVG_TAGS_RE].every((l) => !l.test(tag2));
        }
        function hasValueAttribute(tag2) {
          return HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_RE.test(tag2);
        }
        function isBoolAttribute(attribute) {
          return BOOLEAN_ATTRIBUTES_RE.test(attribute);
        }
        function memoize2(fn) {
          const cache = new WeakMap();
          return function() {
            if (cache.has(arguments.length <= 0 ? void 0 : arguments[0]))
              return cache.get(arguments.length <= 0 ? void 0 : arguments[0]);
            const ret = fn(...arguments);
            cache.set(arguments.length <= 0 ? void 0 : arguments[0], ret);
            return ret;
          };
        }
        const expressionsContentRe = memoize2((brackets) => RegExp(`(${brackets[0]}[^${brackets[1]}]*?${brackets[1]})`, "g"));
        const isSpreadAttribute$1 = (name) => SPREAD_OPERATOR.test(name);
        const isAttributeExpression = (name, brackets) => name[0] === brackets[0];
        const getAttributeEnd = (state, attr2) => expr(state, attr2, "[>/\\s]", attr2.start);
        function attr(state) {
          const {data, last: last2, pos, root} = state;
          const tag2 = last2;
          const _CH = /\S/g;
          const ch = execFromPos(_CH, pos, data);
          switch (true) {
            case !ch:
              state.pos = data.length;
              break;
            case ch[0] === ">":
              state.pos = tag2.end = _CH.lastIndex;
              if (tag2[IS_SELF_CLOSING]) {
                state.scryle = null;
                if (root && root.name === tag2.name) {
                  state.count--;
                }
              }
              return TEXT2;
            case ch[0] === "/":
              state.pos = _CH.lastIndex;
              tag2[IS_SELF_CLOSING] = true;
              break;
            default:
              delete tag2[IS_SELF_CLOSING];
              setAttribute(state, ch.index, tag2);
          }
          return ATTR;
        }
        function setAttribute(state, pos, tag2) {
          const {data} = state;
          const expressionContent = expressionsContentRe(state.options.brackets);
          const re = ATTR_START;
          const start = re.lastIndex = expressionContent.lastIndex = pos;
          const attrMatches = re.exec(data);
          const isExpressionName = isAttributeExpression(attrMatches[1], state.options.brackets);
          const match = isExpressionName ? [null, expressionContent.exec(data)[1], null] : attrMatches;
          if (match) {
            const end = re.lastIndex;
            const attr2 = parseAttribute(state, match, start, end, isExpressionName);
            state.pos = tag2.end = attr2.end;
            tag2.attributes = addToCollection(tag2.attributes, attr2);
          }
        }
        function parseNomalAttribute(state, attr2, quote) {
          const {data} = state;
          let {end} = attr2;
          if (isBoolAttribute(attr2.name)) {
            attr2[IS_BOOLEAN] = true;
          }
          if (quote) {
            let valueStart = end;
            if (quote !== '"' && quote !== "'") {
              quote = "";
              valueStart--;
            }
            end = expr(state, attr2, quote || "[>/\\s]", valueStart);
            return Object.assign(attr2, {value: getChunk(data, valueStart, end), valueStart, end: quote ? ++end : end});
          }
          return attr2;
        }
        function parseSpreadAttribute(state, attr2) {
          const end = getAttributeEnd(state, attr2);
          return {[IS_SPREAD]: true, start: attr2.start, expressions: attr2.expressions.map((expr2) => Object.assign(expr2, {text: expr2.text.replace(SPREAD_OPERATOR, "").trim()})), end};
        }
        function parseExpressionNameAttribute(state, attr2) {
          const end = getAttributeEnd(state, attr2);
          return {start: attr2.start, name: attr2.expressions[0].text.trim(), expressions: attr2.expressions, end};
        }
        function parseAttribute(state, match, start, end, isExpressionName) {
          const attr2 = {name: match[1], value: "", start, end};
          const quote = match[2];
          switch (true) {
            case isSpreadAttribute$1(attr2.name):
              return parseSpreadAttribute(state, attr2);
            case isExpressionName === true:
              return parseExpressionNameAttribute(state, attr2);
            default:
              return parseNomalAttribute(state, attr2, quote);
          }
        }
        function comment(state, data, start) {
          const pos = start + 2;
          const isLongComment = data.substr(pos, 2) === "--";
          const str = isLongComment ? "-->" : ">";
          const end = data.indexOf(str, pos);
          if (end < 0) {
            panic2(data, unclosedComment, start);
          }
          pushComment(state, start, end + str.length, data.substring(start, end + str.length));
          return TEXT2;
        }
        function pushComment(state, start, end, text2) {
          state.pos = end;
          if (state.options.comments === true) {
            flush(state);
            state.last = {type: COMMENT, start, end, text: text2};
          }
        }
        function pushTag(state, name, start, end) {
          const root = state.root;
          const last2 = {type: TAG2, name, start, end};
          if (isCustom(name)) {
            last2[IS_CUSTOM] = true;
          }
          if (isVoid(name)) {
            last2[IS_VOID] = true;
          }
          state.pos = end;
          if (root) {
            if (name === root.name) {
              state.count++;
            } else if (name === root.close) {
              state.count--;
            }
            flush(state);
          } else {
            state.root = {name: last2.name, close: `/${name}`};
            state.count = 1;
          }
          state.last = last2;
        }
        function tag(state) {
          const {pos, data} = state;
          const start = pos - 1;
          const str = data.substr(pos, 2);
          switch (true) {
            case str[0] === "!":
              return comment(state, data, start);
            case TAG_2C.test(str):
              return parseTag(state, start);
            default:
              return pushText(state, start, pos);
          }
        }
        function parseTag(state, start) {
          const {data, pos} = state;
          const re = TAG_NAME;
          const match = execFromPos(re, pos, data);
          const end = re.lastIndex;
          const name = match[1].toLowerCase();
          if (name in RE_SCRYLE) {
            state.scryle = name;
          }
          pushTag(state, name, start, end);
          if (!match[2]) {
            return ATTR;
          }
          return TEXT2;
        }
        function text(state) {
          const {pos, data, scryle} = state;
          switch (true) {
            case typeof scryle === "string": {
              const name = scryle;
              const re = RE_SCRYLE[name];
              const match = execFromPos(re, pos, data);
              if (!match) {
                panic2(data, unclosedNamedBlock.replace("%1", name), pos - 1);
              }
              const start = match.index;
              const end = re.lastIndex;
              state.scryle = null;
              if (start > pos) {
                parseSpecialTagsContent(state, name, match);
              }
              pushTag(state, `/${name}`, start, end);
              break;
            }
            case data[pos] === "<":
              state.pos++;
              return TAG2;
            default:
              expr(state, null, "<", pos);
          }
          return TEXT2;
        }
        function parseSpecialTagsContent(state, name, match) {
          const {pos} = state;
          const start = match.index;
          if (name === TEXTAREA_TAG) {
            expr(state, null, match[0], pos);
          } else {
            pushText(state, pos, start);
          }
        }
        function escapeReturn(string) {
          return string.replace(/\r/g, "\\r").replace(/\n/g, "\\n");
        }
        const hasSrcAttribute = (node2) => (node2.attributes || []).some((attr2) => attr2.name === "src");
        function escapeSlashes(string) {
          return string.replace(/\\/g, "\\\\");
        }
        function cleanSpaces(string) {
          return string.replace(/\s+/g, " ");
        }
        const TREE_BUILDER_STRUCT = Object.seal({
          get() {
            const store = this.store;
            return {[TEMPLATE_OUTPUT_NAME]: store.root.nodes[0], [CSS_OUTPUT_NAME]: store[STYLE_TAG], [JAVASCRIPT_OUTPUT_NAME]: store[JAVASCRIPT_TAG]};
          },
          push(node2) {
            const store = this.store;
            switch (node2.type) {
              case COMMENT:
                this.pushComment(store, node2);
                break;
              case TEXT2:
                this.pushText(store, node2);
                break;
              case TAG2: {
                const name = node2.name;
                const closingTagChar = "/";
                const [firstChar] = name;
                if (firstChar === closingTagChar && !node2.isVoid) {
                  this.closeTag(store, node2, name);
                } else if (firstChar !== closingTagChar) {
                  this.openTag(store, node2);
                }
                break;
              }
            }
          },
          pushComment(store, node2) {
            const parent = store.last;
            parent.nodes.push(node2);
          },
          closeTag(store, node2) {
            const last2 = store.scryle || store.last;
            last2.end = node2.end;
            if (store.root.nodes[0])
              store.root.nodes[0].end = node2.end;
            if (store.scryle) {
              store.scryle = null;
            } else {
              store.last = store.stack.pop();
            }
          },
          openTag(store, node2) {
            const name = node2.name;
            const attrs = node2.attributes;
            const isCoreTag = JAVASCRIPT_TAG === name && !hasSrcAttribute(node2) || name === STYLE_TAG;
            if (isCoreTag) {
              if (store[name]) {
                panic2(this.store.data, duplicatedNamedTag.replace("%1", name), node2.start);
              }
              store[name] = node2;
              store.scryle = store[name];
            } else {
              const lastTag = store.last;
              const newNode = node2;
              lastTag.nodes.push(newNode);
              if (lastTag[IS_RAW] || RAW_TAGS.test(name)) {
                node2[IS_RAW] = true;
              }
              if (!node2[IS_SELF_CLOSING] && !node2[IS_VOID]) {
                store.stack.push(lastTag);
                newNode.nodes = [];
                store.last = newNode;
              }
            }
            if (attrs) {
              this.attrs(attrs);
            }
          },
          attrs(attributes) {
            attributes.forEach((attr2) => {
              if (attr2.value) {
                this.split(attr2, attr2.value, attr2.valueStart, true);
              }
            });
          },
          pushText(store, node2) {
            const text2 = node2.text;
            const empty2 = !/\S/.test(text2);
            const scryle = store.scryle;
            if (!scryle) {
              const parent = store.last;
              const pack = this.compact && !parent[IS_RAW];
              if (pack && empty2) {
                return;
              }
              this.split(node2, text2, node2.start, pack);
              parent.nodes.push(node2);
            } else if (!empty2) {
              scryle.text = node2;
            }
          },
          split(node2, source, start, pack) {
            const expressions2 = node2.expressions;
            const parts = [];
            if (expressions2) {
              let pos = 0;
              expressions2.forEach((expr2) => {
                const text2 = source.slice(pos, expr2.start - start);
                const code = expr2.text;
                parts.push(this.sanitise(node2, text2, pack), escapeReturn(escapeSlashes(code).trim()));
                pos = expr2.end - start;
              });
              if (pos < node2.end) {
                parts.push(this.sanitise(node2, source.slice(pos), pack));
              }
            } else {
              parts[0] = this.sanitise(node2, source, pack);
            }
            node2.parts = parts.filter((p) => p);
          },
          sanitise(node2, text2, pack) {
            let rep = node2.unescape;
            if (rep) {
              let idx = 0;
              rep = `\\${rep}`;
              while ((idx = text2.indexOf(rep, idx)) !== -1) {
                text2 = text2.substr(0, idx) + text2.substr(idx + 1);
                idx++;
              }
            }
            text2 = escapeSlashes(text2);
            return pack ? cleanSpaces(text2) : escapeReturn(text2);
          }
        });
        function createTreeBuilder(data, options2) {
          const root = {type: TAG2, name: "", start: 0, end: 0, nodes: []};
          return Object.assign(Object.create(TREE_BUILDER_STRUCT), {compact: options2.compact !== false, store: {last: root, stack: [], scryle: null, root, style: null, script: null, data}});
        }
        function parser(options2, customBuilder) {
          const state = curry2(createParserState)(options2, customBuilder || createTreeBuilder);
          return {parse: (data) => _parse(state(data))};
        }
        function createParserState(userOptions, builder, data) {
          const options2 = Object.assign({brackets: ["{", "}"]}, userOptions);
          return {options: options2, regexCache: {}, pos: 0, count: -1, root: null, last: null, scryle: null, builder: builder(data, options2), data};
        }
        function _parse(state) {
          const {data} = state;
          walk(state);
          flush(state);
          if (state.count) {
            panic2(data, state.count > 0 ? unexpectedEndOfFile : rootTagNotFound, state.pos);
          }
          return {data, output: state.builder.get()};
        }
        function walk(state, type2) {
          const {data} = state;
          const length = data.length;
          if (state.pos < length && state.count) {
            walk(state, eat(state, type2));
          }
        }
        function eat(state, type2) {
          switch (type2) {
            case TAG2:
              return tag(state);
            case ATTR:
              return attr(state);
            default:
              return text(state);
          }
        }
        const constants = c;
        const nodeTypes = types;
        const BINDING_TYPES = "bindingTypes";
        const EACH_BINDING_TYPE = "EACH";
        const IF_BINDING_TYPE = "IF";
        const TAG_BINDING_TYPE = "TAG";
        const SLOT_BINDING_TYPE = "SLOT";
        const EXPRESSION_TYPES = "expressionTypes";
        const ATTRIBUTE_EXPRESSION_TYPE = "ATTRIBUTE";
        const VALUE_EXPRESSION_TYPE = "VALUE";
        const TEXT_EXPRESSION_TYPE = "TEXT";
        const EVENT_EXPRESSION_TYPE = "EVENT";
        const TEMPLATE_FN = "template";
        const SCOPE = "scope";
        const GET_COMPONENT_FN = "getComponent";
        const BINDING_SELECTOR_KEY = "selector";
        const BINDING_GET_COMPONENT_KEY = "getComponent";
        const BINDING_TEMPLATE_KEY = "template";
        const BINDING_TYPE_KEY = "type";
        const BINDING_REDUNDANT_ATTRIBUTE_KEY = "redundantAttribute";
        const BINDING_CONDITION_KEY = "condition";
        const BINDING_ITEM_NAME_KEY = "itemName";
        const BINDING_GET_KEY_KEY = "getKey";
        const BINDING_INDEX_NAME_KEY = "indexName";
        const BINDING_EVALUATE_KEY = "evaluate";
        const BINDING_NAME_KEY = "name";
        const BINDING_SLOTS_KEY = "slots";
        const BINDING_EXPRESSIONS_KEY = "expressions";
        const BINDING_CHILD_NODE_INDEX_KEY = "childNodeIndex";
        const BINDING_BINDINGS_KEY = "bindings";
        const BINDING_ID_KEY = "id";
        const BINDING_HTML_KEY = "html";
        const BINDING_ATTRIBUTES_KEY = "attributes";
        const IF_DIRECTIVE = "if";
        const EACH_DIRECTIVE = "each";
        const KEY_ATTRIBUTE = "key";
        const SLOT_ATTRIBUTE = "slot";
        const NAME_ATTRIBUTE = "name";
        const IS_DIRECTIVE2 = "is";
        const DEFAULT_SLOT_NAME = "default";
        const TEXT_NODE_EXPRESSION_PLACEHOLDER = " ";
        const BINDING_SELECTOR_PREFIX = "expr";
        const SLOT_TAG_NODE_NAME = "slot";
        const PROGRESS_TAG_NODE_NAME = "progress";
        const TEMPLATE_TAG_NODE_NAME = "template";
        constants.IS_RAW;
        const IS_VOID_NODE = constants.IS_VOID;
        const IS_CUSTOM_NODE = constants.IS_CUSTOM;
        const IS_BOOLEAN_ATTRIBUTE = constants.IS_BOOLEAN;
        const IS_SPREAD_ATTRIBUTE = constants.IS_SPREAD;
        function isStaticNode(node2) {
          return [hasExpressions, findEachAttribute, findIfAttribute, isCustomNode, isSlotNode].every((test) => !test(node2));
        }
        function isRemovableNode(node2) {
          return isTemplateNode(node2) && !isNil2(findAttribute(SLOT_ATTRIBUTE, node2)) && !hasEachAttribute(node2) && !hasIfAttribute(node2);
        }
        function isGlobal(_ref19) {
          let {scope: scope2, node: node2} = _ref19;
          if (node2.object) {
            return isGlobal({node: node2.object, scope: scope2});
          }
          return Boolean(isRaw(node2) || isBuiltinAPI(node2) || isBrowserAPI(node2) || isNewExpression(node2) || isNodeInScope(scope2, node2));
        }
        function isNodeInScope(scope2, node2) {
          const traverse = function traverse2(isInScope) {
            if (isInScope === void 0) {
              isInScope = false;
            }
            types$2.visit(node2, {visitIdentifier(path2) {
              if (scope2.lookup(getName2(path2.node))) {
                isInScope = true;
              }
              this.abort();
            }});
            return isInScope;
          };
          return traverse();
        }
        function isCustomNode(node2) {
          return !!(node2[IS_CUSTOM_NODE] || hasIsAttribute(node2));
        }
        function isSlotNode(node2) {
          return node2.name === SLOT_TAG_NODE_NAME;
        }
        function isVoidNode(node2) {
          return !!node2[IS_VOID_NODE];
        }
        function isTagNode(node2) {
          return node2.type === nodeTypes.TAG;
        }
        function isTextNode(node2) {
          return node2.type === nodeTypes.TEXT;
        }
        function isRootNode(node2) {
          return node2.isRoot;
        }
        function isSpreadAttribute(node2) {
          return node2[IS_SPREAD_ATTRIBUTE];
        }
        function isValueAttribute(node2) {
          return node2.name === "value";
        }
        function isProgressNode(node2) {
          return node2.name === PROGRESS_TAG_NODE_NAME;
        }
        function isTemplateNode(node2) {
          return node2.name === TEMPLATE_TAG_NODE_NAME;
        }
        const isEventAttribute = (() => {
          const EVENT_ATTR_RE = /^on/;
          return (node2) => EVENT_ATTR_RE.test(node2.name);
        })();
        function isCommentString(string) {
          return string.trim().indexOf("<!") === 0;
        }
        function hasExpressions(node2) {
          return !!(node2.expressions || getNodeAttributes(node2).some((attribute) => hasExpressions(attribute)) || node2.nodes && node2.nodes.some((node3) => isTextNode(node3) && hasExpressions(node3)));
        }
        function hasItsOwnTemplate(node2) {
          return [findEachAttribute, findIfAttribute, isCustomNode].some((test) => test(node2));
        }
        const hasIfAttribute = compose2(Boolean, findIfAttribute);
        const hasEachAttribute = compose2(Boolean, findEachAttribute);
        const hasIsAttribute = compose2(Boolean, findIsAttribute);
        compose2(Boolean, findKeyAttribute);
        function findAttribute(name, node2) {
          return node2.attributes && node2.attributes.find((attr2) => getName2(attr2) === name);
        }
        function findIfAttribute(node2) {
          return findAttribute(IF_DIRECTIVE, node2);
        }
        function findEachAttribute(node2) {
          return findAttribute(EACH_DIRECTIVE, node2);
        }
        function findKeyAttribute(node2) {
          return findAttribute(KEY_ATTRIBUTE, node2);
        }
        function findIsAttribute(node2) {
          return findAttribute(IS_DIRECTIVE2, node2);
        }
        function findStaticAttributes(node2) {
          return getNodeAttributes(node2).filter((attribute) => !hasExpressions(attribute));
        }
        function findDynamicAttributes(node2) {
          return getNodeAttributes(node2).filter(hasExpressions);
        }
        function createAttributeExpression(sourceNode2, sourceFile, sourceCode) {
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(ATTRIBUTE_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_NAME_KEY, isSpreadAttribute(sourceNode2) ? nullNode() : builders.literal(sourceNode2.name)), simplePropertyNode(BINDING_EVALUATE_KEY, createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode))]);
        }
        function createEventExpression(sourceNode2, sourceFile, sourceCode) {
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(EVENT_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_NAME_KEY, builders.literal(sourceNode2.name)), simplePropertyNode(BINDING_EVALUATE_KEY, createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode))]);
        }
        var quot = '"';
        var amp = "&";
        var apos = "'";
        var lt = "<";
        var gt = ">";
        var nbsp = "\xA0";
        var iexcl = "\xA1";
        var cent = "\xA2";
        var pound = "\xA3";
        var curren = "\xA4";
        var yen = "\xA5";
        var brvbar = "\xA6";
        var sect = "\xA7";
        var uml = "\xA8";
        var copy = "\xA9";
        var ordf = "\xAA";
        var laquo = "\xAB";
        var not = "\xAC";
        var shy = "\xAD";
        var reg = "\xAE";
        var macr = "\xAF";
        var deg = "\xB0";
        var plusmn = "\xB1";
        var sup2 = "\xB2";
        var sup3 = "\xB3";
        var acute = "\xB4";
        var micro = "\xB5";
        var para = "\xB6";
        var middot = "\xB7";
        var cedil = "\xB8";
        var sup1 = "\xB9";
        var ordm = "\xBA";
        var raquo = "\xBB";
        var frac14 = "\xBC";
        var frac12 = "\xBD";
        var frac34 = "\xBE";
        var iquest = "\xBF";
        var Agrave = "\xC0";
        var Aacute = "\xC1";
        var Acirc = "\xC2";
        var Atilde = "\xC3";
        var Auml = "\xC4";
        var Aring = "\xC5";
        var AElig = "\xC6";
        var Ccedil = "\xC7";
        var Egrave = "\xC8";
        var Eacute = "\xC9";
        var Ecirc = "\xCA";
        var Euml = "\xCB";
        var Igrave = "\xCC";
        var Iacute = "\xCD";
        var Icirc = "\xCE";
        var Iuml = "\xCF";
        var ETH = "\xD0";
        var Ntilde = "\xD1";
        var Ograve = "\xD2";
        var Oacute = "\xD3";
        var Ocirc = "\xD4";
        var Otilde = "\xD5";
        var Ouml = "\xD6";
        var times = "\xD7";
        var Oslash = "\xD8";
        var Ugrave = "\xD9";
        var Uacute = "\xDA";
        var Ucirc = "\xDB";
        var Uuml = "\xDC";
        var Yacute = "\xDD";
        var THORN = "\xDE";
        var szlig = "\xDF";
        var agrave = "\xE0";
        var aacute = "\xE1";
        var acirc = "\xE2";
        var atilde = "\xE3";
        var auml = "\xE4";
        var aring = "\xE5";
        var aelig = "\xE6";
        var ccedil = "\xE7";
        var egrave = "\xE8";
        var eacute = "\xE9";
        var ecirc = "\xEA";
        var euml = "\xEB";
        var igrave = "\xEC";
        var iacute = "\xED";
        var icirc = "\xEE";
        var iuml = "\xEF";
        var eth = "\xF0";
        var ntilde = "\xF1";
        var ograve = "\xF2";
        var oacute = "\xF3";
        var ocirc = "\xF4";
        var otilde = "\xF5";
        var ouml = "\xF6";
        var divide = "\xF7";
        var oslash = "\xF8";
        var ugrave = "\xF9";
        var uacute = "\xFA";
        var ucirc = "\xFB";
        var uuml = "\xFC";
        var yacute = "\xFD";
        var thorn = "\xFE";
        var yuml = "\xFF";
        var OElig = "\u0152";
        var oelig = "\u0153";
        var Scaron = "\u0160";
        var scaron = "\u0161";
        var Yuml = "\u0178";
        var fnof = "\u0192";
        var circ = "\u02C6";
        var tilde = "\u02DC";
        var Alpha = "\u0391";
        var Beta = "\u0392";
        var Gamma = "\u0393";
        var Delta = "\u0394";
        var Epsilon = "\u0395";
        var Zeta = "\u0396";
        var Eta = "\u0397";
        var Theta = "\u0398";
        var Iota = "\u0399";
        var Kappa = "\u039A";
        var Lambda = "\u039B";
        var Mu = "\u039C";
        var Nu = "\u039D";
        var Xi = "\u039E";
        var Omicron = "\u039F";
        var Pi = "\u03A0";
        var Rho = "\u03A1";
        var Sigma = "\u03A3";
        var Tau = "\u03A4";
        var Upsilon = "\u03A5";
        var Phi = "\u03A6";
        var Chi = "\u03A7";
        var Psi = "\u03A8";
        var Omega = "\u03A9";
        var alpha = "\u03B1";
        var beta = "\u03B2";
        var gamma = "\u03B3";
        var delta = "\u03B4";
        var epsilon = "\u03B5";
        var zeta = "\u03B6";
        var eta = "\u03B7";
        var theta = "\u03B8";
        var iota = "\u03B9";
        var kappa = "\u03BA";
        var lambda = "\u03BB";
        var mu = "\u03BC";
        var nu = "\u03BD";
        var xi = "\u03BE";
        var omicron = "\u03BF";
        var pi = "\u03C0";
        var rho = "\u03C1";
        var sigmaf = "\u03C2";
        var sigma = "\u03C3";
        var tau = "\u03C4";
        var upsilon = "\u03C5";
        var phi = "\u03C6";
        var chi = "\u03C7";
        var psi = "\u03C8";
        var omega = "\u03C9";
        var thetasym = "\u03D1";
        var upsih = "\u03D2";
        var piv = "\u03D6";
        var ensp = "\u2002";
        var emsp = "\u2003";
        var thinsp = "\u2009";
        var zwnj = "\u200C";
        var zwj = "\u200D";
        var lrm = "\u200E";
        var rlm = "\u200F";
        var ndash = "\u2013";
        var mdash = "\u2014";
        var lsquo = "\u2018";
        var rsquo = "\u2019";
        var sbquo = "\u201A";
        var ldquo = "\u201C";
        var rdquo = "\u201D";
        var bdquo = "\u201E";
        var dagger = "\u2020";
        var Dagger = "\u2021";
        var bull = "\u2022";
        var hellip = "\u2026";
        var permil = "\u2030";
        var prime = "\u2032";
        var Prime = "\u2033";
        var lsaquo = "\u2039";
        var rsaquo = "\u203A";
        var oline = "\u203E";
        var frasl = "\u2044";
        var euro = "\u20AC";
        var image = "\u2111";
        var weierp = "\u2118";
        var real = "\u211C";
        var trade = "\u2122";
        var alefsym = "\u2135";
        var larr = "\u2190";
        var uarr = "\u2191";
        var rarr = "\u2192";
        var darr = "\u2193";
        var harr = "\u2194";
        var crarr = "\u21B5";
        var lArr = "\u21D0";
        var uArr = "\u21D1";
        var rArr = "\u21D2";
        var dArr = "\u21D3";
        var hArr = "\u21D4";
        var forall = "\u2200";
        var part = "\u2202";
        var exist = "\u2203";
        var empty = "\u2205";
        var nabla = "\u2207";
        var isin = "\u2208";
        var notin = "\u2209";
        var ni = "\u220B";
        var prod = "\u220F";
        var sum = "\u2211";
        var minus = "\u2212";
        var lowast = "\u2217";
        var radic = "\u221A";
        var prop = "\u221D";
        var infin = "\u221E";
        var ang = "\u2220";
        var and = "\u2227";
        var or = "\u2228";
        var cap = "\u2229";
        var cup = "\u222A";
        var int = "\u222B";
        var there4 = "\u2234";
        var sim = "\u223C";
        var cong = "\u2245";
        var asymp = "\u2248";
        var ne = "\u2260";
        var equiv = "\u2261";
        var le = "\u2264";
        var ge = "\u2265";
        var sub = "\u2282";
        var sup = "\u2283";
        var nsub = "\u2284";
        var sube = "\u2286";
        var supe = "\u2287";
        var oplus = "\u2295";
        var otimes = "\u2297";
        var perp = "\u22A5";
        var sdot = "\u22C5";
        var lceil = "\u2308";
        var rceil = "\u2309";
        var lfloor = "\u230A";
        var rfloor = "\u230B";
        var lang = "\u2329";
        var rang = "\u232A";
        var loz = "\u25CA";
        var spades = "\u2660";
        var clubs = "\u2663";
        var hearts = "\u2665";
        var diams = "\u2666";
        var entities = {quot, amp, apos, lt, gt, nbsp, iexcl, cent, pound, curren, yen, brvbar, sect, uml, copy, ordf, laquo, not, shy, reg, macr, deg, plusmn, sup2, sup3, acute, micro, para, middot, cedil, sup1, ordm, raquo, frac14, frac12, frac34, iquest, Agrave, Aacute, Acirc, Atilde, Auml, Aring, AElig, Ccedil, Egrave, Eacute, Ecirc, Euml, Igrave, Iacute, Icirc, Iuml, ETH, Ntilde, Ograve, Oacute, Ocirc, Otilde, Ouml, times, Oslash, Ugrave, Uacute, Ucirc, Uuml, Yacute, THORN, szlig, agrave, aacute, acirc, atilde, auml, aring, aelig, ccedil, egrave, eacute, ecirc, euml, igrave, iacute, icirc, iuml, eth, ntilde, ograve, oacute, ocirc, otilde, ouml, divide, oslash, ugrave, uacute, ucirc, uuml, yacute, thorn, yuml, OElig, oelig, Scaron, scaron, Yuml, fnof, circ, tilde, Alpha, Beta, Gamma, Delta, Epsilon, Zeta, Eta, Theta, Iota, Kappa, Lambda, Mu, Nu, Xi, Omicron, Pi, Rho, Sigma, Tau, Upsilon, Phi, Chi, Psi, Omega, alpha, beta, gamma, delta, epsilon, zeta, eta, theta, iota, kappa, lambda, mu, nu, xi, omicron, pi, rho, sigmaf, sigma, tau, upsilon, phi, chi, psi, omega, thetasym, upsih, piv, ensp, emsp, thinsp, zwnj, zwj, lrm, rlm, ndash, mdash, lsquo, rsquo, sbquo, ldquo, rdquo, bdquo, dagger, Dagger, bull, hellip, permil, prime, Prime, lsaquo, rsaquo, oline, frasl, euro, image, weierp, real, trade, alefsym, larr, uarr, rarr, darr, harr, crarr, lArr, uArr, rArr, dArr, hArr, forall, part, exist, empty, nabla, isin, notin, ni, prod, sum, minus, lowast, radic, prop, infin, ang, and, or, cap, cup, int, there4, sim, cong, asymp, ne, equiv, le, ge, sub, sup, nsub, sube, supe, oplus, otimes, perp, sdot, lceil, rceil, lfloor, rfloor, lang, rang, loz, spades, clubs, hearts, diams};
        const HTMLEntityRe = /&(\S+);/g;
        const HEX_NUMBER = /^[\da-fA-F]+$/;
        const DECIMAL_NUMBER = /^\d+$/;
        function encodeHex(string) {
          const hex = string.substr(2);
          return HEX_NUMBER.test(hex) ? String.fromCodePoint(parseInt(hex, 16)) : string;
        }
        function encodeDecimal(string) {
          const nr = string.substr(1);
          return DECIMAL_NUMBER.test(nr) ? String.fromCodePoint(parseInt(nr, 10)) : string;
        }
        function encodeHTMLEntities(string) {
          return string.replace(HTMLEntityRe, (match, entity) => {
            const [firstChar, secondChar] = entity;
            if (firstChar === "#") {
              return secondChar === "x" ? encodeHex(entity) : encodeDecimal(entity);
            } else {
              return entities[entity] || entity;
            }
          });
        }
        function trimEnd(string) {
          return (string.trimEnd || string.trimRight).apply(string);
        }
        function trimStart(string) {
          return (string.trimStart || string.trimLeft).apply(string);
        }
        function unescapeChar(string, char) {
          return string.replace(RegExp(`\\\\${char}`, "gm"), char);
        }
        function generateLiteralStringChunksFromNode(node2, sourceCode) {
          return node2.expressions.reduce((chunks, expression, index) => {
            const start = index ? node2.expressions[index - 1].end : node2.start;
            const string = encodeHTMLEntities(sourceCode.substring(start, expression.start));
            chunks.push(index === 0 ? trimStart(string) : string);
            if (index === node2.expressions.length - 1)
              chunks.push(encodeHTMLEntities(trimEnd(sourceCode.substring(expression.end, node2.end))));
            return chunks;
          }, []).filter((str) => !isCommentString(str)).map((str) => node2.unescape ? unescapeChar(str, node2.unescape) : str);
        }
        function mergeNodeExpressions(node2, sourceFile, sourceCode) {
          if (node2.parts.length === 1)
            return transformExpression(node2.expressions[0], sourceFile, sourceCode);
          const pureStringChunks = generateLiteralStringChunksFromNode(node2, sourceCode);
          const stringsArray = pureStringChunks.reduce((acc, str, index) => {
            const expr2 = node2.expressions[index];
            return [...acc, builders.literal(str), expr2 ? transformExpression(expr2, sourceFile, sourceCode) : nullNode()];
          }, []).filter((expr2) => !isLiteral(expr2) || expr2.value);
          return createArrayString(stringsArray);
        }
        function createTextExpression(sourceNode2, sourceFile, sourceCode, childNodeIndex) {
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(TEXT_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_CHILD_NODE_INDEX_KEY, builders.literal(childNodeIndex)), simplePropertyNode(BINDING_EVALUATE_KEY, wrapASTInFunctionWithScope(mergeNodeExpressions(sourceNode2, sourceFile, sourceCode)))]);
        }
        function createValueExpression(sourceNode2, sourceFile, sourceCode) {
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(VALUE_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_EVALUATE_KEY, createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode))]);
        }
        function createExpression(sourceNode2, sourceFile, sourceCode, childNodeIndex, parentNode) {
          switch (true) {
            case isTextNode(sourceNode2):
              return createTextExpression(sourceNode2, sourceFile, sourceCode, childNodeIndex);
            case (isValueAttribute(sourceNode2) && hasValueAttribute(parentNode.name) && !isProgressNode(parentNode)):
              return createValueExpression(sourceNode2, sourceFile, sourceCode);
            case isEventAttribute(sourceNode2):
              return createEventExpression(sourceNode2, sourceFile, sourceCode);
            default:
              return createAttributeExpression(sourceNode2, sourceFile, sourceCode);
          }
        }
        function createAttributeExpressions(sourceNode2, sourceFile, sourceCode) {
          return findDynamicAttributes(sourceNode2).map((attribute) => createExpression(attribute, sourceFile, sourceCode, 0, sourceNode2));
        }
        const scope = builders.identifier(SCOPE);
        const getName2 = (node2) => node2 && node2.name ? node2.name : node2;
        function replacePathScope(path2, property) {
          path2.replace(builders.memberExpression(scope, property, false));
        }
        function updateNodeScope(path2) {
          if (!isGlobal(path2)) {
            replacePathScope(path2, path2.node);
            return false;
          }
          this.traverse(path2);
        }
        function visitMemberExpression(path2) {
          const traversePathObject = () => this.traverse(path2.get("object"));
          const currentObject = path2.node.object;
          switch (true) {
            case isGlobal(path2):
              if (currentObject.arguments && currentObject.arguments.length) {
                traversePathObject();
              }
              break;
            case (!path2.value.computed && isIdentifier(currentObject)):
              replacePathScope(path2, path2.node);
              break;
            default:
              this.traverse(path2);
          }
          return false;
        }
        function visitObjectProperty(path2) {
          const value = path2.node.value;
          const isShorthand = path2.node.shorthand;
          if (isIdentifier(value) || isMemberExpression(value) || isShorthand) {
            if (isShorthand)
              path2.node.shorthand = false;
            updateNodeScope.call(this, path2.get("value"));
          } else {
            this.traverse(path2.get("value"));
          }
          return false;
        }
        function visitThisExpression(path2) {
          path2.replace(scope);
          this.traverse(path2);
        }
        function visitIdentifier(path2) {
          const parentValue = path2.parent.value;
          if (!isMemberExpression(parentValue) || parentValue.computed) {
            updateNodeScope.call(this, path2);
          }
          return false;
        }
        function updateNodesScope(ast) {
          const ignorePath = () => false;
          types$2.visit(ast, {visitIdentifier, visitMemberExpression, visitObjectProperty, visitThisExpression, visitClassExpression: ignorePath});
          return ast;
        }
        function createASTFromExpression(expression, sourceFile, sourceCode) {
          const code = sourceFile ? addLineOffset(expression.text, sourceCode, expression) : expression.text;
          return generateAST(`(${code})`, {sourceFileName: sourceFile});
        }
        function createTemplateProperty(args) {
          return simplePropertyNode(BINDING_TEMPLATE_KEY, args ? callTemplateFunction(...args) : nullNode());
        }
        function getAttributeExpression(attribute) {
          return attribute.expressions ? attribute.expressions[0] : Object.assign({}, attribute, {text: attribute.value});
        }
        function wrapASTInFunctionWithScope(ast) {
          return builders.functionExpression(null, [scope], builders.blockStatement([builders.returnStatement(ast)]));
        }
        function toScopedFunction(expression, sourceFile, sourceCode) {
          return compose2(wrapASTInFunctionWithScope, transformExpression)(expression, sourceFile, sourceCode);
        }
        function transformExpression(expression, sourceFile, sourceCode) {
          return compose2(getExpressionAST, updateNodesScope, createASTFromExpression)(expression, sourceFile, sourceCode);
        }
        function getExpressionAST(sourceAST) {
          const astBody = sourceAST.program.body;
          return astBody[0] ? astBody[0].expression : astBody;
        }
        function callTemplateFunction(template2, bindings2) {
          return builders.callExpression(builders.identifier(TEMPLATE_FN), [template2 ? builders.literal(template2) : nullNode(), bindings2 ? builders.arrayExpression(bindings2) : nullNode()]);
        }
        const attributeNameToDOMQuerySelector = (attributeName) => `[${attributeName}]`;
        function createSelectorProperties(attributeName) {
          return attributeName ? [simplePropertyNode(BINDING_REDUNDANT_ATTRIBUTE_KEY, builders.literal(attributeName)), simplePropertyNode(BINDING_SELECTOR_KEY, compose2(builders.literal, attributeNameToDOMQuerySelector)(attributeName))] : [];
        }
        function cloneNodeWithoutSelectorAttribute(node2, selectorAttribute) {
          return Object.assign({}, node2, {attributes: getAttributesWithoutSelector(getNodeAttributes(node2), selectorAttribute)});
        }
        function getAttributesWithoutSelector(attributes, selectorAttribute) {
          if (selectorAttribute)
            return attributes.filter((attribute) => attribute.name !== selectorAttribute);
          return attributes;
        }
        function cleanAttributes(node2) {
          return getNodeAttributes(node2).filter((attribute) => ![IF_DIRECTIVE, EACH_DIRECTIVE, KEY_ATTRIBUTE, SLOT_ATTRIBUTE, IS_DIRECTIVE2].includes(attribute.name));
        }
        function rootNodeFactory(node2) {
          return {nodes: getChildrenNodes(node2), isRoot: true};
        }
        function createRootNode(node2) {
          return Object.assign({}, rootNodeFactory(node2), {attributes: compose2(transformStatiAttributesIntoExpressions, cleanAttributes)(node2)});
        }
        function createNestedRootNode(node2) {
          return Object.assign({}, rootNodeFactory(node2), {attributes: cleanAttributes(node2)});
        }
        function transformStatiAttributesIntoExpressions(attributes) {
          return attributes.map((attribute) => {
            if (attribute.expressions)
              return attribute;
            return Object.assign({}, attribute, {expressions: [{start: attribute.valueStart, end: attribute.end, text: `'${attribute.value || attribute.name}'`}]});
          });
        }
        function getChildrenNodes(node2) {
          return node2 && node2.nodes ? node2.nodes : [];
        }
        function getNodeAttributes(node2) {
          return node2.attributes ? node2.attributes : [];
        }
        function getCustomNodeNameAsExpression(node2) {
          const isAttribute = findIsAttribute(node2);
          const toRawString = (val) => `'${val}'`;
          if (isAttribute) {
            return isAttribute.expressions ? isAttribute.expressions[0] : Object.assign({}, isAttribute, {text: toRawString(isAttribute.value)});
          }
          return Object.assign({}, node2, {text: toRawString(getName2(node2))});
        }
        function staticAttributesToString(node2) {
          return findStaticAttributes(node2).map((attribute) => attribute[IS_BOOLEAN_ATTRIBUTE] || !attribute.value ? attribute.name : `${attribute.name}="${unescapeNode(attribute, "value").value}"`).join(" ");
        }
        function unescapeNode(node2, key) {
          if (node2.unescape) {
            return Object.assign({}, node2, {[key]: unescapeChar(node2[key], node2.unescape)});
          }
          return node2;
        }
        function nodeToString(node2) {
          const attributes = staticAttributesToString(node2);
          switch (true) {
            case isTagNode(node2):
              return `<${node2.name}${attributes ? ` ${attributes}` : ""}${isVoidNode(node2) ? "/" : ""}>`;
            case isTextNode(node2):
              return hasExpressions(node2) ? TEXT_NODE_EXPRESSION_PLACEHOLDER : unescapeNode(node2, "text").text;
            default:
              return node2.text || "";
          }
        }
        function closeTag(node2) {
          return node2.name ? `</${node2.name}>` : "";
        }
        function createArrayString(stringsArray) {
          return builders.callExpression(builders.memberExpression(builders.arrayExpression(stringsArray), builders.identifier("join"), false), [builders.literal("")]);
        }
        function mergeAttributeExpressions(node2, sourceFile, sourceCode) {
          if (!node2.parts || node2.parts.length === 1) {
            return transformExpression(node2.expressions[0], sourceFile, sourceCode);
          }
          const stringsArray = [...node2.parts.reduce((acc, str) => {
            const expression = node2.expressions.find((e) => e.text.trim() === str);
            return [...acc, expression ? transformExpression(expression, sourceFile, sourceCode) : builders.literal(encodeHTMLEntities(str))];
          }, [])].filter((expr2) => !isLiteral(expr2) || expr2.value);
          return createArrayString(stringsArray);
        }
        const createBindingSelector = function createSelector(id) {
          if (id === void 0) {
            id = 0;
          }
          return () => `${BINDING_SELECTOR_PREFIX}${id++}`;
        }();
        function createBindingAttributes(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
          return builders.arrayExpression([...compose2((attributes) => attributes.map((attribute) => createExpression(attribute, sourceFile, sourceCode, 0, sourceNode2)), (attributes) => attributes.filter(hasExpressions), (attributes) => getAttributesWithoutSelector(attributes, selectorAttribute), cleanAttributes)(sourceNode2)]);
        }
        function createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode) {
          return hasExpressions(sourceNode2) ? wrapASTInFunctionWithScope(mergeAttributeExpressions(sourceNode2, sourceFile, sourceCode)) : builders.functionExpression(null, [], builders.blockStatement([builders.returnStatement(builders.literal(sourceNode2.value || true))]));
        }
        function cloneDeep(source) {
          return JSON.parse(JSON.stringify(source));
        }
        const getEachItemName = (expression) => isSequenceExpression(expression.left) ? expression.left.expressions[0] : expression.left;
        const getEachIndexName = (expression) => isSequenceExpression(expression.left) ? expression.left.expressions[1] : null;
        const getEachValue = (expression) => expression.right;
        const nameToliteral = compose2(builders.literal, getName2);
        const generateEachItemNameKey = (expression) => simplePropertyNode(BINDING_ITEM_NAME_KEY, compose2(nameToliteral, getEachItemName)(expression));
        const generateEachIndexNameKey = (expression) => simplePropertyNode(BINDING_INDEX_NAME_KEY, compose2(nameToliteral, getEachIndexName)(expression));
        const generateEachEvaluateKey = (expression, eachExpression, sourceFile, sourceCode) => simplePropertyNode(BINDING_EVALUATE_KEY, compose2((e) => toScopedFunction(e, sourceFile, sourceCode), (e) => Object.assign({}, eachExpression, {text: generateJavascript(e).code}), getEachValue)(expression));
        function generateEachExpressionProperties(eachExpression, sourceFile, sourceCode) {
          const ast = createASTFromExpression(eachExpression, sourceFile, sourceCode);
          const body = ast.program.body;
          const firstNode = body[0];
          if (!isExpressionStatement(firstNode)) {
            panic$1(`The each directives supported should be of type "ExpressionStatement",you have provided a "${firstNode.type}"`);
          }
          const {expression} = firstNode;
          return [generateEachItemNameKey(expression), generateEachIndexNameKey(expression), generateEachEvaluateKey(expression, eachExpression, sourceFile, sourceCode)];
        }
        function createEachBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
          const [ifAttribute, eachAttribute, keyAttribute] = [findIfAttribute, findEachAttribute, findKeyAttribute].map((f) => f(sourceNode2));
          const attributeOrNull = (attribute) => attribute ? toScopedFunction(getAttributeExpression(attribute), sourceFile, sourceCode) : nullNode();
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(EACH_BINDING_TYPE), false)), simplePropertyNode(BINDING_GET_KEY_KEY, attributeOrNull(keyAttribute)), simplePropertyNode(BINDING_CONDITION_KEY, attributeOrNull(ifAttribute)), createTemplateProperty(createNestedBindings(sourceNode2, sourceFile, sourceCode, selectorAttribute)), ...createSelectorProperties(selectorAttribute), ...compose2(generateEachExpressionProperties, getAttributeExpression)(eachAttribute)]);
        }
        function createIfBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
          const ifAttribute = findIfAttribute(sourceNode2);
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(IF_BINDING_TYPE), false)), simplePropertyNode(BINDING_EVALUATE_KEY, toScopedFunction(ifAttribute.expressions[0], sourceFile, sourceCode)), ...createSelectorProperties(selectorAttribute), createTemplateProperty(createNestedBindings(sourceNode2, sourceFile, sourceCode, selectorAttribute))]);
        }
        function createTextNodeExpressions(sourceNode2, sourceFile, sourceCode) {
          const childrenNodes = getChildrenNodes(sourceNode2);
          return childrenNodes.filter(isTextNode).filter(hasExpressions).map((node2) => createExpression(node2, sourceFile, sourceCode, childrenNodes.indexOf(node2), sourceNode2));
        }
        function createSimpleBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
          return builders.objectExpression([
            ...isRemovableNode(sourceNode2) || isRootNode(sourceNode2) ? [] : createSelectorProperties(selectorAttribute),
            simplePropertyNode(BINDING_EXPRESSIONS_KEY, builders.arrayExpression([...createTextNodeExpressions(sourceNode2, sourceFile, sourceCode), ...createAttributeExpressions(sourceNode2, sourceFile, sourceCode)]))
          ]);
        }
        function createSlotBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
          const slotNameAttribute = findAttribute(NAME_ATTRIBUTE, sourceNode2);
          const slotName = slotNameAttribute ? slotNameAttribute.value : DEFAULT_SLOT_NAME;
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(SLOT_BINDING_TYPE), false)), simplePropertyNode(BINDING_ATTRIBUTES_KEY, createBindingAttributes(Object.assign({}, sourceNode2, {
            attributes: getNodeAttributes(sourceNode2).filter((attribute) => getName2(attribute) !== NAME_ATTRIBUTE)
          }), selectorAttribute, sourceFile, sourceCode)), simplePropertyNode(BINDING_NAME_KEY, builders.literal(slotName)), ...createSelectorProperties(selectorAttribute)]);
        }
        function groupSlots(sourceNode2) {
          return getChildrenNodes(sourceNode2).reduce((acc, node2) => {
            const slotAttribute = findSlotAttribute(node2);
            if (slotAttribute) {
              acc[slotAttribute.value] = node2;
            } else {
              acc.default = createNestedRootNode({nodes: [...getChildrenNodes(acc.default), node2]});
            }
            return acc;
          }, {default: null});
        }
        function buildSlot(id, sourceNode2, sourceFile, sourceCode) {
          const cloneNode = Object.assign({}, sourceNode2, {attributes: getNodeAttributes(sourceNode2)});
          const [html, bindings2] = build(cloneNode, sourceFile, sourceCode);
          return builders.objectExpression([simplePropertyNode(BINDING_ID_KEY, builders.literal(id)), simplePropertyNode(BINDING_HTML_KEY, builders.literal(html)), simplePropertyNode(BINDING_BINDINGS_KEY, builders.arrayExpression(bindings2))]);
        }
        function createSlotsArray(sourceNode2, sourceFile, sourceCode) {
          return builders.arrayExpression([...compose2((slots) => slots.map((_ref20) => {
            let [key, value] = _ref20;
            return buildSlot(key, value, sourceFile, sourceCode);
          }), (slots) => slots.filter((_ref21) => {
            let [, value] = _ref21;
            return value;
          }), Object.entries, groupSlots)(sourceNode2)]);
        }
        function findSlotAttribute(sourceNode2) {
          return getNodeAttributes(sourceNode2).find((attribute) => attribute.name === SLOT_ATTRIBUTE);
        }
        function createTagBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
          return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(TAG_BINDING_TYPE), false)), simplePropertyNode(BINDING_GET_COMPONENT_KEY, builders.identifier(GET_COMPONENT_FN)), simplePropertyNode(BINDING_EVALUATE_KEY, toScopedFunction(getCustomNodeNameAsExpression(sourceNode2), sourceFile, sourceCode)), simplePropertyNode(BINDING_SLOTS_KEY, createSlotsArray(sourceNode2, sourceFile, sourceCode)), simplePropertyNode(BINDING_ATTRIBUTES_KEY, createBindingAttributes(sourceNode2, selectorAttribute, sourceFile, sourceCode)), ...createSelectorProperties(selectorAttribute)]);
        }
        const BuildingState = Object.freeze({html: [], bindings: [], parent: null});
        function createBindingsTag(sourceNode2, bindingsSelector) {
          if (!bindingsSelector)
            return sourceNode2;
          return Object.assign({}, sourceNode2, {
            attributes: [{name: bindingsSelector, value: bindingsSelector}, ...getNodeAttributes(sourceNode2)]
          });
        }
        function createDynamicNode(sourceNode2, sourceFile, sourceCode, state) {
          switch (true) {
            case isTextNode(sourceNode2):
              return [nodeToString(sourceNode2), []];
            default:
              return createTagWithBindings(sourceNode2, sourceFile, sourceCode);
          }
        }
        function createTagWithBindings(sourceNode2, sourceFile, sourceCode) {
          const bindingsSelector = isRootNode(sourceNode2) ? null : createBindingSelector();
          const cloneNode = createBindingsTag(sourceNode2, bindingsSelector);
          const tagOpeningHTML = nodeToString(cloneNode);
          switch (true) {
            case hasEachAttribute(cloneNode):
              return [tagOpeningHTML, [createEachBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
            case hasIfAttribute(cloneNode):
              return [tagOpeningHTML, [createIfBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
            case isCustomNode(cloneNode):
              return [tagOpeningHTML, [createTagBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
            case isSlotNode(cloneNode):
              return [tagOpeningHTML, [createSlotBinding(cloneNode, bindingsSelector)]];
            default:
              return [tagOpeningHTML, [createSimpleBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
          }
        }
        function parseNode(sourceNode2, sourceFile, sourceCode, state) {
          if (isStaticNode(sourceNode2))
            return [nodeToString(sourceNode2), []];
          return createDynamicNode(sourceNode2, sourceFile, sourceCode);
        }
        function createNestedBindings(sourceNode2, sourceFile, sourceCode, selector) {
          const mightBeARiotComponent = isCustomNode(sourceNode2);
          const node2 = cloneNodeWithoutSelectorAttribute(sourceNode2, selector);
          return mightBeARiotComponent ? [null, [createTagBinding(node2, null, sourceFile, sourceCode)]] : build(createNestedRootNode(node2), sourceFile, sourceCode);
        }
        function build(sourceNode2, sourceFile, sourceCode, state) {
          if (!sourceNode2)
            panic$1("Something went wrong with your tag DOM parsing, your tag template can't be created");
          const [nodeHTML, nodeBindings] = parseNode(sourceNode2, sourceFile, sourceCode);
          const childrenNodes = getChildrenNodes(sourceNode2);
          const canRenderNodeHTML = isRemovableNode(sourceNode2) === false;
          const currentState = Object.assign({}, cloneDeep(BuildingState), state);
          canRenderNodeHTML && currentState.html.push(...nodeHTML);
          currentState.bindings.push(...nodeBindings);
          if (childrenNodes.length && !hasItsOwnTemplate(sourceNode2)) {
            childrenNodes.forEach((node2) => build(node2, sourceFile, sourceCode, Object.assign({parent: sourceNode2}, currentState)));
          }
          if (canRenderNodeHTML && isTagNode(sourceNode2) && !isVoidNode(sourceNode2)) {
            currentState.html.push(closeTag(sourceNode2));
          }
          return [currentState.html.join(""), currentState.bindings];
        }
        const templateFunctionArguments = [TEMPLATE_FN, EXPRESSION_TYPES, BINDING_TYPES, GET_COMPONENT_FN].map(builders.identifier);
        function createTemplateFunctionContent(sourceNode2, sourceFile, sourceCode) {
          return builders.blockStatement([builders.returnStatement(callTemplateFunction(...build(createRootNode(sourceNode2), sourceFile, sourceCode)))]);
        }
        function extendTemplateProperty(ast, sourceFile, sourceCode, sourceNode2) {
          types$2.visit(ast, {visitProperty(path2) {
            if (path2.value.key.value === TAG_TEMPLATE_PROPERTY) {
              path2.value.value = builders.functionExpression(null, templateFunctionArguments, createTemplateFunctionContent(sourceNode2, sourceFile, sourceCode));
              return false;
            }
            this.traverse(path2);
          }});
          return ast;
        }
        function template(sourceNode2, source, meta, ast) {
          const {options: options2} = meta;
          return extendTemplateProperty(ast, options2.file, source, sourceNode2);
        }
        const DEFAULT_OPTIONS = {template: "default", file: "[unknown-source-file]", scopedCss: true};
        function createInitialInput(_ref22) {
          let {tagName} = _ref22;
          return builders.program([builders.exportDefaultDeclaration(builders.objectExpression([simplePropertyNode(TAG_CSS_PROPERTY, nullNode()), simplePropertyNode(TAG_LOGIC_PROPERTY, nullNode()), simplePropertyNode(TAG_TEMPLATE_PROPERTY, nullNode()), simplePropertyNode(TAG_NAME_PROPERTY, builders.literal(tagName))]))]);
        }
        function normaliseInputSourceMap(map) {
          const inputSourceMap = sourcemapAsJSON(map);
          return isEmptySourcemap(inputSourceMap) ? null : inputSourceMap;
        }
        function overrideSourcemapContent(map, source) {
          return Object.assign({}, map, {sourcesContent: [source]});
        }
        function createMeta(source, options2) {
          return {tagName: null, fragments: null, options: Object.assign({}, DEFAULT_OPTIONS, options2), source};
        }
        function compile2(source, opts) {
          if (opts === void 0) {
            opts = {};
          }
          const meta = createMeta(source, opts);
          const {options: options2} = meta;
          const {code, map} = execute("template", options2.template, meta, source);
          const {parse} = parser(options2);
          const {template: template$1, css: css$1, javascript: javascript$1} = parse(code).output;
          if (hasHTMLOutsideRootNode(template$1 || css$1 || javascript$1, code, parse)) {
            throw new Error("Multiple HTML root nodes are not supported");
          }
          Object.assign(meta, {tagName: template$1.name, fragments: {template: template$1, css: css$1, javascript: javascript$1}});
          return compose2((result) => Object.assign({}, result, {meta}), (result) => execute$1(result, meta), (result) => Object.assign({}, result, {map: overrideSourcemapContent(result.map, source)}), (ast) => meta.ast = ast && generateJavascript(ast, {sourceMapName: `${options2.file}.map`, inputSourceMap: normaliseInputSourceMap(map)}), hookGenerator(template, template$1, code, meta), hookGenerator(javascript, javascript$1, code, meta), hookGenerator(css, css$1, code, meta))(createInitialInput(meta));
        }
        function hookGenerator(transformer, sourceNode2, source, meta) {
          if (!sourceNode2 || sourceNode2.nodes && !sourceNode2.nodes.length || !sourceNode2.nodes && !sourceNode2.text) {
            return (result) => result;
          }
          return curry2(transformer)(sourceNode2, source, meta);
        }
        const registerPreprocessor = register2;
        const registerPostprocessor = register$1;
        exports3.compile = compile2;
        exports3.createInitialInput = createInitialInput;
        exports3.registerPostprocessor = registerPostprocessor;
        exports3.registerPreprocessor = registerPreprocessor;
        Object.defineProperty(exports3, "__esModule", {value: true});
      });
    })(compiler$1, compiler$1.exports);
    var compiler = /* @__PURE__ */ getDefaultExportFromCjs2(compiler$1.exports);
    const GLOBAL_REGISTRY = "__riot_registry__";
    window[GLOBAL_REGISTRY] = {};
    function evaluate(js, url) {
      const node = document.createElement("script");
      const root = document.documentElement;
      if (url)
        node.text = `${js}
//# sourceURL=${url}.js`;
      root.appendChild(node);
      root.removeChild(node);
    }
    function transpile(code) {
      return `(function (global){${code}})(this)`.replace("export default", "return");
    }
    function inject(code, tagName, url) {
      evaluate(`window.${GLOBAL_REGISTRY}['${tagName}'] = ${transpile(code)}`, url);
      register(tagName, window[GLOBAL_REGISTRY][tagName]);
    }
    function compileFromString(string, options) {
      return compiler.compile(string, options);
    }
    async function compileFromUrl(url, options) {
      const response = await fetch(url);
      const code = await response.text();
      return compiler.compile(code, Object.assign({
        file: url
      }, options));
    }
    async function compile(options) {
      const scripts = $('script[type="riot"]');
      const urls = scripts.map((s) => get(s, "src") || get(s, "data-src"));
      const tags = await Promise.all(urls.map((url) => compileFromUrl(url, options)));
      tags.forEach((_ref, i) => {
        let {
          code,
          meta
        } = _ref;
        const url = urls[i];
        const {
          tagName
        } = meta;
        inject(code, tagName, url);
      });
    }
    var riot_compiler2 = Object.assign({}, riot2, {
      compile,
      inject,
      compileFromUrl,
      compileFromString,
      compiler
    });
    return riot_compiler2;
  });
})(riot_compiler);
var riotAndCompiler = /* @__PURE__ */ getDefaultExportFromCjs(riot_compiler.exports);
class SHandlebarsComponentInterface extends __SInterface {
}
SHandlebarsComponentInterface.definition = {
  source: {
    type: "String"
  }
};
const Component = {
  "css": ``,
  "exports": {
    $source: void 0,
    tagName: `riot-${uniqid()}`,
    state: {},
    async onBeforeMount() {
      this.component = new __SComponentUtils(this.root, this.props, {
        interface: SHandlebarsComponentInterface
      });
      if (this.component.props.source) {
        this.$source = document.querySelector(this.component.props.source);
      }
      let data = {};
      if (this.$source) {
        if (!this.$source.getData) {
          throw new Error(`<red>[s-handlebars]</red> Sorry but the spcified data source provider does not provide an "<yellow>getData</yellow>" api method`);
        }
        data = await this.$source.getData();
      }
      this.$template = this.root.querySelector("template");
      this._template = this.$template.innerHTML;
      let codeStr;
      if (!this._template.match(/<script(.*)?>/)) {
        this._template = `
              ${this._template}
              <script>
                  export default {
                      onBeforeMount() {
                          this.root.update = this.update.bind(this);
                      }
                  };
              </script>
          `;
      } else if (this._template.match(/onBeforeMount\(\)\s?\{/)) {
        this._template = this._template.replace(/onBeforeMount\(\)\s?\{/, `onBeforeMount() { this.root.update = this.update.bind(this); `);
      } else {
        this._template = this._template.replace(/export default\s?\{/, `export default {
              onBeforeMount() { this.root.update = this.update.bind(this); }, `);
      }
      codeStr = `
          <${this.tagName}>
              ${this._template}
          </${this.tagName}>
      `;
      const {code} = riotAndCompiler.compileFromString(codeStr);
      riotAndCompiler.inject(code, this.tagName, "index.html");
      const $tag = document.createElement(this.tagName);
      this.$template.parentNode.insertBefore($tag, this.$template.nextSibling);
      riotAndCompiler.mount(this.tagName);
      $tag.update({
        data
      });
      this.root.setData = this.setData.bind(this);
    },
    onMounted() {
      console.log("COCO");
    },
    setData(data) {
      console.log("data", data);
    }
  },
  "template": null,
  "name": "s-handlebars"
};
riot.register("s-handlebars", Component);
querySelectorLive("s-handlebars:not([s-mounted])", ($elm) => {
  const id = $elm.id || "s-handlebars-" + uniqid();
  $elm.setAttribute("id", id);
  riot.mount("#" + id);
});
Component.mount = () => {
  riot.mount("s-handlebars");
};
if (!window.env)
  window.env = {SUGAR: {}};
window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
export default Component;

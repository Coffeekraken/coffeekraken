import __SComponent from "@coffeekraken/s-component";

// src/components/MyComponent.lite.tsx

/**
 * @name                SInlineComponent
 * @as                  Inline
 * @namespace           js
 * @type                CustomElement
 * @interface           ./interface/SInlineComponentInterface.ts
 * @menu                Styleguide / UI              /styleguide/ui/s-inline
 * @platform            html
 * @status              beta
 *
 * This component represent the inline component that allows you to inline svgs for example.
 *
 * @support         chromium
 * @support         firefox
 * @support         safari
 * @support         edge
 *
 * @install           shell
 * npm i @coffeekraken/s-inline-component
 *
 * @install           js
 * import { define } from '@coffeekraken/s-inline-component/webcomponent';
 * define();
 *
 * @since           2.0.0
 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
 */
type Props = {
  src: string;
};

import "../../../../../src/css/s-inline.css";
import __SInlineComponentInterface from "../../../../../src/js/interface/SInlineComponentInterface";
const DEFAULT_PROPS = __SInlineComponentInterface.defaults();

/**
 * Usage:
 *
 *  <s-inline></s-inline>
 *
 */
export default class SInline extends HTMLElement {
  get _container() {
    return this._root.querySelector("[data-ref='SInline-container']");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      status: "idle",
      loaded: false,
      svgCode: null,
      load() {
        (async () => {
          const r = await fetch(self.props.src);
          const text = await r.text();
          const parser = new DOMParser();
          const svg = parser.parseFromString(text, "text/html").body.innerHTML;
          self.state.svgCode = svg;
          self.update();
          self.state.loaded = true;
          self.update();
          self._container.innerHTML = svg;
        })();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = ["src"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: "open" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, "");
      const regexp = new RegExp(jsVar, "i");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    // default props
    const defaultProps = __SComponent.getDefaultProps(
      this.tagName.toLowerCase()
    );
    this.props.src = this.props.src ?? defaultProps.src ?? DEFAULT_PROPS.src;

    this._root.innerHTML = `
                        
      <div class="s-inline" data-el="div-s-inline-1">
        <template data-el="show-s-inline">
          <div data-el="div-s-inline-2" data-ref="SInline-container"></div>
        </template>
      </div>`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    __SInlineComponentInterface;
    this.state.status = "mounted";
    this.update();
    this.state.load();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll("[data-el='div-s-inline-1']").forEach((el) => {
      el.setAttribute("status", this.state.status);

      el.setAttribute("loaded", this.state.loaded);
    });

    this._root.querySelectorAll("[data-el='show-s-inline']").forEach((el) => {
      const whenCondition = this.state.status === "mounted";
      if (whenCondition) {
        this.showContent(el);
      }
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}


                            export function define(
                                props = {},
                                tagName = 's-inline'
                            ) {
                                __SComponent.setDefaultProps(tagName, props);
                                customElements.define(tagName, class SInlineComponent extends SInline {});
                            }
                            

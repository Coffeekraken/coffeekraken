<s-request>

  <style type="postcss">
    :host {
      display: none;
    }
  </style>

  <script>
    import __SRequest from '@coffeekraken/s-request';
    import __SRequestComponentInterface from './interface/SRequestComponentInterface.ts';
    import __SComponentUtils from '@coffeekraken/s-component-utils';
    import __uniqid from '@coffeekraken/sugar/shared/string/uniqid';
    import __SCache from '@coffeekraken/s-cache';
    import __md5 from '@coffeekraken/sugar/shared/crypt/md5';

    export default {

      _inlineProxyObj: undefined,

      async onBeforeMount() {
        this.component = new __SComponentUtils(this.root, this.props, {
          interface: __SRequestComponentInterface
        });

        const $script = this.root.querySelector('script');
        if ($script) {
          const id = __uniqid();
          let scriptText = $script.innerText.trim();
          scriptText = scriptText.replace(/^export default /, `window['${`s-request-script-${id}`}'] = `);
          const $newScript = document.createElement('script');
          $newScript.text = scriptText;
          $script.parentNode.insertBefore($newScript, $script);
          $script.remove();
          this._inlineProxyObj = window[`s-request-script-${id}`];
        }

        // init cache if needed
        if (this.component.props.cache) {
          this._cache = new __SCache('s-request');
        }

        switch(this.component.props.trigger) {
          case 'event':
            // requested props (on, $targets)
            if (!this.component.props.on) throw new Error(`<red>[s-request${this.root.id ? `#${this.root.id}` : ''}]</red> When using the trigger "event", you MUST specify the "<yellow>on</yellow>" property to tell the component which event to listen to`);
            if (!this.component.$targets.length) throw new Error(`<red>[s-request${this.root.id ? `#${this.root.id}` : ''}]</red> When using the trigger "event", you MUST specify the "<yellow>target</yellow>" property to tell the component which other HTMLElement to listen to`);
            // listen for the event on the target
            this.component.addTargetsEventListener(this.component.props.on, async (e) => {
              const detail = Object.assign({}, e.detail);
              delete detail.onPing;
              delete detail.onResolve;
              const res = await this._request(detail);

              return res;
            });
          break;
        }

      },
      async _request(data) {

        let payload = {
          type: this.component.props.type ?? 'get',
          url: this.component.props.url,
          data,
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Expires': '0'
          }
        };

        if (this._inlineProxyObj?.request) {
          payload = this._inlineProxyObj.request(payload);
        }

        // calculate the cache hash
        const cacheHash = __md5.encrypt(payload);

        // check if a cache is available and activated
        // if (this.component.props.cache !== false) {
        //   let cachedValue = await this._cache.get(cacheHash);
        //   console.log(cachedValue);
        //   if (cachedValue) {
        //     if (this._inlineProxyObj?.response) {
        //       cachedValue = this._inlineProxyObj.response(cachedValue);
        //     }
        //     return cachedValue;
        //   }
        // }

        const request = new __SRequest(payload);
        let res = await request.send();

        // save in cache if needed
        for (let i = 0; i<2; i++) {
          try {
            if (this.component.props.cache !== false) {
              await this._cache.set(cacheHash, res.data, {
                ttl: typeof this.component.props.cache === 'string' ? this.component.props.cache : -1
              });
            }
            break;
          } catch(e) {
            this._cache.clear();
          }
        }

        if (this._inlineProxyObj?.response) {
          res = this._inlineProxyObj.response(res);
        }

        return res;
      },
      onMounted() {
      }
    }
  </script>
</s-request>
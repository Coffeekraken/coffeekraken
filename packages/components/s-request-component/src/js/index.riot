<s-request>

  <style type="postcss">
    :host {
      display: none;
    }
  </style>

  <script>
    import __SRequest from '@coffeekraken/s-request';
    import __SRequestComponentInterface from './interface/SRequestComponentInterface.ts';
    import __SComponentUtils from '@coffeekraken/s-component-utils';
    import __uniqid from '@coffeekraken/sugar/shared/string/uniqid';
    import __SCache from '@coffeekraken/s-cache';
    import __md5 from '@coffeekraken/sugar/shared/crypt/md5';

    export default {

      _inlineProxyObj: undefined,

      async onBeforeMount() {
        this.component = new __SComponentUtils(this.root, this.props, {
          interface: __SRequestComponentInterface
        });

        const $script = this.root.querySelector('script');
        if ($script) {
          const id = __uniqid();
          let scriptText = $script.innerText.trim();
          scriptText = scriptText.replace(/^export default /, `window['${`s-request-script-${id}`}'] = `);
          const $newScript = document.createElement('script');
          $newScript.text = scriptText;
          $script.parentNode.insertBefore($newScript, $script);
          $script.remove();
          this._inlineProxyObj = window[`s-request-script-${id}`];
        }

        // init cache if needed
        if (this.component.props.cache) {
          this._cache = new __SCache('s-request');
        }

        switch(this.component.props.trigger) {
          case 'event':
            // requested props (on, $targets)
            if (!this.component.props.on) throw new Error(`<red>[s-request${this.root.id ? `#${this.root.id}` : ''}]</red> When using the trigger "event", you MUST specify the "<yellow>on</yellow>" property to tell the component which event to listen to`);
            if (!this.component.$targets.length) throw new Error(`<red>[s-request${this.root.id ? `#${this.root.id}` : ''}]</red> When using the trigger "event", you MUST specify the "<yellow>target</yellow>" property to tell the component which other HTMLElement to listen to`);
            // listen for the event on the target
            this.component.addTargetsEventListener(this.component.props.on, async (e) => {

              const res = await this._request(e.detail);

              return res;
            });
          break;
        }

      },
      async _request(data) {

        const payload = {
          type: this.component.props.type,
          url: this.component.props.url,
          data,
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Expires': '0'
          }
        };

        // calculate the cache hash
        const cacheHash = __md5.encrypt(payload);

        // check if a cache is available and activated
        if (this.component.props.cache !== false) {
          let cachedValue = await this._cache.get(cacheHash);
          if (cachedValue) {
            if (this._inlineProxyObj?.response) {
              cachedValue = this._inlineProxyObj.response(cachedValue);
            }
            return cachedValue;
          }
        }
        
        if (this._inlineProxyObj?.request) {
          data = this._inlineProxyObj.request(data);
        }

        const request = new __SRequest(payload);
        let res = await request.send();

        // save in cache if needed
        if (this.component.props.cache !== false) {
          await this._cache.set(cacheHash, res.data, {
            ttl: typeof this.component.props.cache === 'string' ? this.component.props.cache : -1
          });
        }

        if (this._inlineProxyObj?.response) {
          res = this._inlineProxyObj.response(res);
        }
        return res;
      },
      onMounted() {
      }
    }
  </script>
</s-request>
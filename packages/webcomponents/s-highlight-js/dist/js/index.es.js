import e from"../../../../../node_modules/chalk/source/index.js";import t from"../../../../../node_modules/copy-to/index.js";import{highlight as r}from"../../../../../node_modules/cli-highlight/dist/index.js";import{decycle as s}from"../../../../../node_modules/json-cyclic/dist/index.js";import n from"../../../../../node_modules/is-class/is-class.js";import o from"../../../../../node_modules/lodash.clone/index.js";import i from"../../../../../node_modules/lodash.clonedeep/index.js";import a from"../../../../../node_modules/crypto-js/md5.js";import{get_current_component as l,SvelteElement as c,init as u,attribute_to_object as d,safe_not_equal as p,insert_dev as y,flush as h,dispatch_dev as g,validate_slots as f,assign as m,exclude_internal_props as b,element as w,noop as v,claim_element as _,children as j,detach_dev as S,add_location as $,attr_dev as O,append_dev as k,binding_callbacks as E}from"../../../../../node_modules/svelte/internal/index.mjs";import A from"../../../../../node_modules/prismjs/prism.js";import"../../../../../node_modules/prismjs/components/prism-javascript.js";import"../../../../../node_modules/prismjs/components/prism-css.js";import"../../../../../node_modules/prismjs/components/prism-markup.js";import"../../../../../node_modules/prismjs/components/prism-bash.js";import C from"../../../../../node_modules/mustache/mustache.mjs";import{onMount as T,beforeUpdate as x,afterUpdate as R,onDestroy as M,tick as I,getContext as D,hasContext as N,setContext as L}from"../../../../../node_modules/svelte/index.mjs";import{writable as B}from"../../../../../node_modules/svelte/store/index.mjs";import P from"../../../../../node_modules/is-glob/index.js";function F(e){Array.isArray(e)||(e=[e]);for(let t=0;t<e.length;t++)if(!n(e[t]))return!1;return!0}const H=function(e,t={}){const r={};F(e)||(e=e.constructor),!0===t.includeBaseClass&&(r[e.name]=e);let s=e;for(;s;){const e=Object.getPrototypeOf(s);if(!e||e===Object||!e.name)break;r[e.name]=e,s=e}return r};function W(e){return!!e&&("object"==typeof e&&((!e.constructor||"Object"===e.constructor.name)&&("[object Object]"===Object.prototype.toString.call(e)&&e===Object(e))))}function Y(e){const t=e.concat();for(let r=0;r<t.length;++r)for(let e=r+1;e<t.length;++e)t[r]===t[e]&&t.splice(e--,1);return t}function U(e,t={}){return(t=Object.assign({deep:!1},t)).deep?i(e):o(e)}function q(e,...t){const r={array:!1,object:!0,cloneChilds:!0};function s(e,t){for(const n of Object.keys(t))if(!0===r.array&&Array.isArray(e[n])&&Array.isArray(t[n])){const r=Y([...e[n],...t[n]]);e[n]=r}else!0===r.object&&W(e[n])&&W(t[n])?e[n]=s(e[n],t[n]):W(t[n])&&r.cloneChilds?e[n]=U(t[n],{deep:!0}):e[n]=t[n];return e}const n=t[t.length-1]||{};(n.array&&"boolean"==typeof n.array||n.object&&"boolean"==typeof n.object)&&(void 0!==n.array&&(r.array=n.array),void 0!==n.object&&(r.object=n.object),t.pop());for(let o=0;o<t.length;o++){s(e,t[o]||{})}return e}function z(...e){const r={array:!1,object:!0};function s(e,n){const o={};if(!e&&n)return n;if(!n&&e)return e;if(!e&&!n)return{};t(e).override(o);for(const i of Object.keys(n))if(!0===r.array&&Array.isArray(e[i])&&Array.isArray(n[i])){const t=Y([...e[i],...n[i]]);o[i]=t}else!0===r.object&&W(e[i])&&W(n[i])?o[i]=s(e[i],n[i]):t(n).pick(i).toCover(o);return o}const n=e[e.length-1]||{};(n.array&&"boolean"==typeof n.array||n.object&&"boolean"==typeof n.object)&&(void 0!==n.array&&(r.array=n.array),void 0!==n.object&&(r.object=n.object),e.pop());let o={};for(let t=0;t<e.length;t++){o=s(o,e[t]||{})}return o}function Z(e,t=['"',"'","”","`"]){return e=e.trim(),t.forEach((t=>{e.substr(0,1)!==t||e.substr(-1)!==t||(e=(e=e.substr(1)).substr(0,e.length-1))})),e}function J(e,t,r={}){if(r=Object.assign({},r),void 0!==e[t])return e[t];if(!t||""===t||"."===t)return e;const s=(t=(t=t.replace(/\[(\w+)\]/g,".$1")).replace(/^\./,"")).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((e=>Z(e)));let n=e;for(;s.length;){const e=s.shift();if("object"!=typeof n)return;if(!(e in n))return;n=n[e]}return n}function V(e,t,r={},s=[]){r=z({classInstances:!1,array:!0,privateProps:!1,cloneFirst:!0},r);const n=Array.isArray(e),o=n?[]:r.cloneFirst?Object.assign({},e):e;return Object.keys(e).forEach((i=>{if(!r.privateProps&&i.match(/^_/))return;if(W(e[i])||(a=e[i])&&"object"==typeof a&&(!a.constructor||"Object"!==a.constructor.name)&&"[object Object]"!==Object.prototype.toString.call(a)&&a.constructor!==Object&&r.classInstances||Array.isArray(e[i])&&r.array){const a=V(e[i],t,r,[...s,i]);return void(n?o.push(a):o[i]=a)}var a;const l=t({object:e,prop:i,value:e[i],path:[...s,i].join(".")});-1!==l&&(n?o.push(l):o[i]=l)})),o}function G(e){return e instanceof Map}function Q(e){return e&&"object"==typeof e&&e.constructor===Object}function K(e){const t={};for(let[r,s]of e)t[r]=s;return t}function X(t,n={}){if(n=z({beautify:!0,highlight:!0,verbose:!0,theme:{number:e.yellow,default:e.white,keyword:e.blue,regexp:e.red,string:e.whiteBright,class:e.yellow,function:e.yellow,comment:e.gray,variable:e.red,attr:e.green}},n),"string"==typeof t)return t;if(null===t)return"null";if(void 0===t)return"undefined";if(t instanceof Error){const e=t.toString();let r=t.stack;const s=t.message;return n.verbose?[`<red>${t.constructor.name||"Error"}</red>`,"",s,"",r].join("\n"):e}if(G(t)&&(t=K(t)),Q(t)||function(e){return e&&"object"==typeof e&&e.constructor===Array}(t)||function(e){try{const t=JSON.parse(e);return!!Object.keys(t).length}catch(t){return!1}return!0}(t)){try{t=s(t)}catch(i){}t=V(t,(({value:e})=>e instanceof Map?K(e):e));let e=JSON.stringify(t,null,n.beautify?4:0);return e=e.replace(/"([^"]+)":/g,"$1:").replace(/\uFFFF/g,'\\"'),n.highlight&&(e=r(e,{language:"js",theme:n.theme})),e}if(function(e){return"boolean"==typeof e}(t))return t?"true":"false";if(function(e){return e&&"[object Function]"==={}.toString.call(e)}(t))return""+t;let o="";try{t=s(t),o=JSON.stringify(t,null,n.beautify?4:0)}catch(i){try{o=t.toString()}catch(a){o=t}}return o}var ee=e=>{if("string"!=typeof e)return e;e=e.split("⠀").join("").trim();try{return Function(`\n      "use strict";\n      return (${e});\n    `)()}catch(t){return e}};const te={};var re=function(e){"string"!=typeof e&&(e=X(e));const t=a(e).toString();return te[t]=e,t};const se={},ne={};function oe(e,t){const r=function(e){const t=["yellow","cyan","green","magenta","red","blue","primary","secondary","grey","gray"];let r=t;return(e=Object.assign({excludeBasics:!1},null!=e?e:{})).excludeBasics&&(r=t.filter((e=>"white"!==e&&"black"!==e&&"grey"!==e&&"gray"!==e))),r}(t=z({scope:"default",excludeBasics:!0},null!=t?t:{})),s=re(t.scope),n=re(e);if(ne[`${s}.${n}`])return ne[`${s}.${n}`];if(se[s]||(se[s]=[]),se[s].length>=r.length){const e=(o=r)[Math.round(Math.random()*(o.length-1))];return ne[`${s}.${n}`]=e,e}for(let i=0;i<r.length;i++)if(-1===se[s].indexOf(r[i]))return se[s].push(r[i]),ne[`${s}.${n}`]=r[i],r[i];var o}var ie=(e,t,r,s={})=>{if(s=Object.assign({},s),!t||""===t||"."===t)return void(e=r);const n=Z(t=t.replace(/\[(\w+)\]/g,".[$1]")).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((e=>Z(e)));let o=e;for(;n.length-1;){const e=n.shift();e in o||(n[0].match(/^\[[0-9]+\]$/)?o[e]=[]:o[e]={}),o=o[e]}return n[0].match(/^\[[0-9]+\]$/)?(Array.isArray(o)||(o=[]),o.push(r)):o[n[0]]=r,J(e,t)};class ae{constructor(e={}){this._settings={},this._interfacesStack={},ce(this),fe(this,e),he(this),this.metas=le(this),Object.defineProperty(this,"metas",{enumerable:!0,value:le(this)})}get formattedName(){var e,t,r;let s=`<yellow>${(null===(e=this.metas)||void 0===e?void 0:e.name)||""}</yellow>`;return(null===(t=this.metas)||void 0===t?void 0:t.id)&&(s+=` <cyan>${null===(r=this.metas)||void 0===r?void 0:r.id}</cyan>`),s}static extends(e){return class extends e{constructor(e,...t){super(...t),this._settings={},this._interfacesStack={},ce(this),fe(this,e),he(this),this.metas=le(this),Object.defineProperty(this,"metas",{enumerable:!0,value:le(this)})}get formattedName(){let e=`<yellow>${this.name||""}</yellow>`;return this.id&&(e+=` <cyan>${this.id}</cyan>`),e}expose(e,t){return ue(this,e,t)}applyInterface(e,t){return ge(this,e,t)}getInterface(e){return ye(this,e)}toPlainObject(){return pe(this)}}}expose(e,t){return ue(this,e,t)}applyInterface(e,t){return ge(this,e,t)}getInterface(e){return ye(this,e)}toPlainObject(){return pe(this)}}function le(e){var t,r,s,n,o,i,a,l;let c=`<yellow>${(null===(t=e._settings.metas)||void 0===t?void 0:t.name)||""}</yellow>`;(null===(r=e._settings.metas)||void 0===r?void 0:r.id)&&(c+=` <cyan>${e._settings.metas.id}</cyan>`);return{id:null!==(n=null===(s=e._settings.metas)||void 0===s?void 0:s.id)&&void 0!==n?n:e.constructor.name,name:null!==(i=null===(o=e._settings.metas)||void 0===o?void 0:o.name)&&void 0!==i?i:e.constructor.name,formattedName:c,color:null!==(l=null===(a=e._settings.metas)||void 0===a?void 0:a.color)&&void 0!==l?l:"yellow"}}function ce(e){const t=H(e,{includeBaseClass:!0});Object.keys(t).forEach((r=>{const s=t[r];s.interfaces&&(e._interfacesStack[r]=s.interfaces)}))}function ue(e,t,r){(r=z({as:void 0,props:[]},r)).as&&"string"==typeof r.as&&(e[r.as]=t),r.props&&r.props.forEach((r=>{e[r]=t[r].bind(t)}))}function de(e,t){let r=J(e._interfacesStack,t);if(!r){const s=Object.keys(e._interfacesStack);for(let n=0;n<s.length;n++){const o=e._interfacesStack[s[n]];if(void 0!==o[t]){r=W(o[t])?o[t]:{apply:!0,on:"settings"===t?"_settings":"this"===t?e:void 0,class:o[t]};break}}}return"settings"===t&&void 0===r.on&&(void 0!==e.settings?r.on="settings":void 0!==e._settings&&(r.on="_settings")),r}function pe(e){return function(e){const t={};return V(e,(({value:e,path:r})=>(ie(t,r,e),e)),{privateProps:!1,classInstances:!0}),t}(e)}function ye(e,t){const r=de(e,t);return W(r)?r.class:r}function he(e){const t=Object.keys(e._interfacesStack);for(let r=t.length-1;r>=0;r--){const s=e._interfacesStack[t[r]],n=t[r];Object.keys(s).forEach((t=>{const r=s[t];let o;o=W(r)?Object.assign({},Object.assign({apply:!0,on:"settings"===t?"_settings":"this"===t?e:void 0},r)):Object.assign({},{apply:!0,on:"settings"===t?"_settings":"this"===t?e:void 0,class:r}),!0===o.apply&&o.on&&("string"==typeof o.on&&void 0!==J(e,o.on)||"object"==typeof o.on?ge(e,`${n}.${t}`,o.on):void 0!==e[t]&&ge(e,`${n}.${t}`))}))}}function ge(e,t,r=null){const s=de(e,`${t}`);if(!s)throw new Error(`You try to apply the interface named "<yellow>${t}</yellow>" on the context "<cyan>${e.name}</cyan>" but it does not exists...`);if(void 0!==r&&(s.on=r),!s)throw`Sorry the the asked interface "<yellow>${t}</yellow>" does not exists on the class "<cyan>${e.constructor.name}</cyan>"`;if(t.includes(".")&&(t=t.split(".").slice(1).join(".")),W(s)){let r;r=s.on&&"string"==typeof s.on?J(e,s.on):s.on&&"object"==typeof s.on?s.on:J(e,t);let n,o=e.constructor.name;if(e.id&&(o+=`(${e.id})`),t&&(o+=`.${t}`),s.on&&s.on.constructor&&(o+=`.${s.on.constructor.name}`),s.on&&s.on.id&&(o+=`(${s.on.id})`),"this"===t)return n=s.class.apply(r||{},{id:o,complete:!0,throw:!0}),q(e,n.value),e;if(n=s.class.apply(r,{id:o,complete:!0,throw:!0}),s.on&&"object"==typeof s.on){return q(s.on,n.value)}if(s.on&&"string"==typeof s.on)return q(J(e,s.on),n.value);if(void 0!==e[t])return e[t];if(!n.hasIssues())return n.value}}function fe(e,t={}){var r;e._settings=t,e._settings.metas||(e._settings.metas={}),(null===(r=e._settings.metas)||void 0===r?void 0:r.id)||(e._settings.metas.id=e.constructor.name),e.constructor.name.match(/^SConfig/)?e._settings.metas.color||(e._settings.metas.color="yellow"):e._settings.metas.color||(e._settings.metas.color=oe(e.constructor.name,{scope:"class"}))}class me extends ae{constructor(e,t){var r;super(z({svelteComponent:{classPrefix:"s-"}},t||{})),this.props={},this._styleStr="",this._currentComponent=l(),C.escape=function(e){return e};const s=null!==(r=this.svelteComponentSettings.interface)&&void 0!==r?r:this.constructor.interface,n={};if(Object.keys(e).forEach((t=>{n[function(e){let t="";return t=e.replace(/(?:^|[_-\s])(\w)/g,(function(e,t){return t?t.toUpperCase():""})),t=t.substr(0,1).toLowerCase()+t.slice(1),t.trim()}(t)]=e[t]})),s){s.definition=Object.assign(Object.assign({},s.definition),{noLnf:{type:{type:"Boolean",nullishAsTrue:!0},default:!1},noBare:{type:{type:"Boolean",nullishAsTrue:!0},default:!1},noStyle:{type:{type:"Boolean",nullishAsTrue:!0},default:!1}});const e=s.apply(null!=n?n:{});if(e.hasIssues())throw new Error(e.toString());Object.keys(e.value).forEach((t=>{let r=e.value[t];const s=B(e.value[t],(()=>()=>{}));s.subscribe((e=>{r=e})),Object.defineProperty(this.props,t,{enumerable:!0,get:()=>r,set(e){s.set(e)}})}))}this.onMount((()=>{this.props.noLnf&&this.rootElm.classList.add("s-no-lnf"),this.props.noBare&&this.rootElm.classList.add("s-no-bare"),this.props.noStyle||this._applyStyles()}))}get svelteComponentSettings(){return this._settings.svelteComponent}get styleStr(){return this._styleStr||(this._styleStr=function(e){let t=[];e instanceof StyleSheetList?Object.keys(e).forEach((r=>{t.push(e[r])})):Array.isArray(e)||t.push(e);let r="";return t.forEach((e=>{r+=e.cssRules?Array.from(e.cssRules).map((e=>{var t;return null!==(t=e.cssText)&&void 0!==t?t:""})).join("\n"):""})),r}(document.styleSheets)),this._styleStr}get rootElm(){for(let e=0;e<this._currentComponent.shadowRoot.children.length;e++){const t=this._currentComponent.shadowRoot.children[e];if("STYLE"!==t.tagName)return t}return this._currentComponent}get $elm(){return this._currentComponent}get styleElm(){for(let e=0;e<this._currentComponent.shadowRoot.children.length;e++){const t=this._currentComponent.shadowRoot.children[e];if("STYLE"===t.tagName)return t}}_applyStyles(){if(!this.styleElm)return;const e=this.styleElm.innerHTML.match(/[\.#]?[a-zA-Z0-9-_:>+*\s]+\{(.*\n?)content:"(s-style-[a-zA-Z0-9-_]+)"(.*\n?)\}/gm);if(e){let t=this.styleElm.innerHTML;t=t.replace(/content:\?"s-style-[a-zA-Z0-9-_]+"/,""),e.forEach((e=>{const r=e.split("{")[0],s=e.match(/content:"(.*)"/)[1],n=new RegExp(`.${s}.*{[^}]+}`,"gm"),o=this.styleStr.match(n);o&&o.forEach((e=>{const n=e.replace(`.${s}`,r);t+=n}))})),this.styleElm.innerHTML=t;const r=document.createElement("style");r.innerHTML=this.styleStr.replace(/--[a-zA-Z0-9-_]+:[^;]+;/gm,""),this._currentComponent.shadowRoot.prepend(r)}}compileMustache(e,t){return C.render(e,t)}className(e=""){return e.split(" ").map((e=>`${this.svelteComponentSettings.classPrefix}${this.svelteComponentSettings.classPrefix&&e&&!e.match(/^__/)?"-":""}${e}`)).join(" ")}onMount(e){T(e)}beforeUpdate(e){x(e)}afterUpdate(e){R(e)}onDestroy(e){M(e)}tick(){I()}getContext(e){D(e)}hasContext(e){N(e)}setContext(e,t){L(e,t)}}function be(e){return e.charAt(0).toUpperCase()+e.slice(1)}function we(e,t={}){let r;var s,n;t=z({of:!1,customClass:!0},t),Array.isArray(e)?r="Array":e instanceof Map?r="Map":null===e?r="Null":void 0===e?r="Undefined":"string"==typeof e?r="String":r="number"!=typeof(s=e)||isNaN(s)||(0|(n=parseFloat(s)))!==n?"number"==typeof e?"Number":"boolean"==typeof e?"Boolean":e instanceof RegExp?"RegExp":!0===t.customClass&&F(e)&&void 0!==e.name?be(e.name):!0===t.customClass&&void 0!==e.constructor&&void 0!==e.constructor.name?be(e.constructor.name):!1===t.customClass&&F(e)?"Class":"function"==typeof e?"Function":"object"==typeof e?"Object":"Unknown":"Integer";if(!0===t.of&&!["Null","Undefined","String","Integer","Number","Boolean","Unknown"].includes(r)){const s=Array.isArray(e)?[...e.keys()]:Object.keys(e),n=[];s.forEach((r=>{const s=we(e[r],{of:!1,customClass:t.customClass});n.includes(s)||n.push(s)})),r+=`<${n.join("|")}>`}return r}const ve=function(e,t,r={}){r=Object.assign({newStack:!1},r);const s=we(e).toLowerCase();let n;n="object"===s?Object.keys(e):"array"===s?Array.from(Array(e.length).keys()):"number"===s||"integer"===s?Array.from(Array(Math.round(e)).keys()):"string"===s||"set"===s?Array.from(e):Array.from(e.keys()),"string"!==s&&"number"!==s&&"integer"!==s&&"set"!==s||(r.newStack=!0);let o,i,a=[];"object"===s?a={}:"map"===s?a=new Map:"set"===s&&(a=new Set);const l=(e,t)=>{switch(we(e).toLowerCase()){case"array":case"object":return e[t];case"string":return t;case"number":case"integer":return t;case"map":return e.get(t);case"set":return t}},c=(e,t,s)=>{switch(we(e).toLowerCase()){case"array":!0===r.newStack?e.push(s):e[t]=s;break;case"object":e[t]=s;break;case"number":case"integer":case"string":e.push(s);break;case"map":e.set(t,s);break;case"set":e.add(s)}};for(let u=0;u<n.length;u++){const s=n[u];if(o=l(e,s),i=t({key:s,prop:s,value:o,i:u,idx:u}),-1===i)break;c(r.newStack?a:e,s,i)}return"string"===s?a.join(""):r.newStack?a:e};e.level=3;const _e={black:(t,r)=>e.black(r),red:(t,r)=>e.red(r),green:(t,r)=>e.green(r),yellow:(t,r)=>e.yellow(r),blue:(t,r)=>e.blue(r),magenta:(t,r)=>e.magenta(r),cyan:(t,r)=>e.cyan(r),white:(t,r)=>e.white(r),grey:(t,r)=>e.grey(r),bgBlack:(t,r)=>e.bgBlack(r),bgRed:(t,r)=>e.bgRed(r),bgGreen:(t,r)=>e.bgGreen(r),bgYellow:(t,r)=>e.bgYellow(r),bgBlue:(t,r)=>e.bgBlue(r),bgMagenta:(t,r)=>e.bgMagenta(r),bgCyan:(t,r)=>e.bgCyan(r),bgWhite:(t,r)=>e.bgWhite(r),bold:(t,r)=>e.bold(r),dim:(t,r)=>e.dim(r),italic:(t,r)=>e.italic(r),underline:(t,r)=>e.underline(r),strike:(t,r)=>e.strike(r),h1:(t,r)=>e.underline(e.bold(r))+"\n\n",h2:(t,r)=>e.bold(r)+"\n",date:(e,t)=>(new Date).getDate().toString().padStart("0",2)+"-"+((new Date).getMonth()+1).toString().padStart("0",2)+"-"+(new Date).getFullYear().toString().padStart("0",2),time:(e,t)=>(new Date).getHours().toString().padStart("0",2)+":"+(new Date).getMinutes().toString().padStart("0",2)+":"+(new Date).getMinutes().toString().padStart("0",2),day:(e,t)=>(new Date).getDate().toString().padStart("0",2),days:(e,t)=>(new Date).getDate().toString().padStart("0",2),month:(e,t)=>(new Date).getMonth().toString().padStart("0",2),months:(e,t)=>(new Date).getMonth().toString().padStart("0",2),year:(e,t)=>(new Date).getFullYear().toString().padStart("0",2),years:(e,t)=>(new Date).getFullYear().toString().padStart("0",2),hour:(e,t)=>(new Date).getHours().toString().padStart("0",2),hours:(e,t)=>(new Date).getHours().toString().padStart("0",2),minute:(e,t)=>(new Date).getMinutes().toString().padStart("0",2),minutes:(e,t)=>(new Date).getMinutes().toString().padStart("0",2),second:(e,t)=>(new Date).getSeconds().toString().padStart("0",2),seconds:(e,t)=>(new Date).getSeconds().toString().padStart("0",2),br:(e,t)=>"\n"};function je(e){let t=!1;return Array.isArray(e)?t=!0:e=[e],e=e.map((e=>function(e,t){e||(e="");let r=(e=X(e)).replace(/\r\n/g,"|rn|");return r=r.replace(/\n/g,"|n|"),r=r.replace(/\r/g,"|r|"),Object.keys(t).forEach((e=>{const s=new RegExp(`<s*${e}[^>]*>((.*?))<\\s*/\\s*${e}>`,"g"),n=r.match(s),o=new RegExp(`\\s?<${e}\\s?/>\\s?`,"g"),i=r.match(o);if(n)for(let a=0;a<n.length;a++){const s=n[a].match(`<\\s*${e}[^>]*>((.*?))<\\s*/\\s*${e}>`);if(!s)continue;const o=s[0],i=s[1];r=r.replace(o,t[e](e,i))}if(i)for(let a=0;a<i.length;a++){const s=i[a].match(`\\s?<${e}\\s?/>\\s?`);if(!s)continue;const n=s[0],o="";r=r.replace(n,t[e](e,o))}})),r=r.replace(/\|rn\|/g,"\r\n"),r=r.replace(/\|n\|/g,"\n"),r=r.replace(/\|r\|/g,"\r"),r}(e,_e))),t?e:e[0]}var Se=()=>"undefined"!=typeof process&&process.release&&"node"===process.release.name;class $e{constructor(e){this._data=e}get typeString(){return this._data.typeString}get value(){return this._data.value}get received(){return this._data.received}get expected(){return this._data.expected}get issues(){return this._data.issues}get settings(){return this._data.settings}hasIssues(){return!!this._data}toString(){return Se()?this.toConsole():'The method "toHtml" has not being integrated for now...'}toConsole(){const e=[`<underline><magenta>${this._data.settings.name}</magenta></underline>`,"","<underline>Received value</underline>","",`${X(this._data.value,{beautify:!0})}`,""],t=[];Object.keys(this._data.issues).forEach((e=>{const r=this._data.issues[e],s=[];r.expected.type&&s.push(`- Expected "<yellow>${r.expected.type}</yellow>"`),r.received.type&&s.push(`- Received "<red>${r.received.type}</red>"`),r.message&&s.push(["<underline>Details:</underline>",r.message].join("\n")),t.push(s.join("\n"))}));const r=["","<underline>Settings</underline>","",`${X(this._data.settings,{beautify:!0})}`];return je(`\n${e.join("\n")}\n${t.join("\n")}\n${this.settings.verbose?r.join("\n"):""}\n    `).trim()}}class Oe{constructor(e,t={}){if(this.typeString=e,e=e.toLowerCase().trim(),void 0!==this.constructor._instanciatedTypes[e])return this.constructor._instanciatedTypes[e];this.types=function(e){e=(e=(e=e.toLowerCase().trim()).split("|").map((e=>e.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/,"array<$1>"))).join("|")).split("|").map((e=>e.trim().replace(/^([a-zA-Z0-9-_]+)\{\}$/,"object<$1>"))).join("|");let t=[],r=!1,s="";for(let o=0;o<e.length;o++){const n=e[o];"<"===n?(r=!0,s+=n):">"===n?(r=!1,s+=n):"|"===n&&!1===r?(t.push(s),s=""):s+=n}t.push(s);const n=[];return t.forEach((e=>{n.push(function(e){let t="",r=e;const s=e.match(/<(.+)>$/gm);s&&s.length&&(t=s[0].replace("<","").replace(">","")),""!==t&&(r=r.replace(`<${t}>`,""));let n=""!==t?[t.toLowerCase()]:void 0;return void 0!==t&&t.includes("|")&&(n=t.split("|").map((e=>e.trim().toLowerCase()))),{type:r,of:n}}(e))})),{raw:e,types:n}}(e).types,this._settings=z({id:this.constructor.name,name:this.constructor.name,throw:!1,customTypes:!0,interfaces:!0,verbose:!1},t),this.constructor._instanciatedTypes[e]=this}static registerType(e){if(void 0===e.id||"string"!=typeof e.id)throw"Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...";this._registeredTypes[e.id]=e}is(e,t={}){const r=this.check(e,t);return!0===r||(!(r instanceof $e)||!r.hasIssues())}check(e,t={}){t=z(this._settings,t);const r={};for(let n=0;n<this.types.length;n++){const s=this.types[n],o=s.type,i=this._isType(e,o,t);if(!0===i){if(void 0===s.of)return!0;const n=we(e);if("Array"!==n&&"Object"!==n&&"Map"!==n){if(t.throw)throw`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${n}</cyan>" that does not support "child" value(s)...`;continue}const o="Object"===n?Object.keys(e):Array.from(e.keys());if(!o.length)return!0;for(let i=0;i<o.length;i++)for(let a=0;a<s.of.length;a++){const l=s.of[a],c=o[i],u="Map"===n?e.get(c):e[c];if(!0===this._isType(u,l,t))return!0;r[s.type]={expected:{type:s.type},received:{type:we(u),value:u}}}}else{const t={expected:{type:s.type},received:{type:we(e),value:e}};null!=i&&!1!==i&&i.toString&&"function"==typeof i.toString&&(t.message=i.toString()),r[s.type]=t}}const s=new $e({typeString:this.typeString,value:e,expected:{type:this.typeString},received:{type:we(e)},issues:r,settings:t});if(!0===t.throw)throw new Error(s.toString());return s}_isType(e,t,r={}){if(r=z(this._settings,r),void 0===this.constructor._registeredTypes[t.toLowerCase()]){if(!0===r.interfaces){const r=qe.getAvailableTypes();if(void 0!==r[t]){return r[t].apply(e,{})}}if(!0===r.customTypes){const r=we(e).toLowerCase(),s=Object.keys(H(e)).map((e=>e.toLowerCase()));if(t===r||-1!==s.indexOf(t))return!0}if(r.throw)throw`Sorry but you try to validate a value with the type "<yellow>${t}</yellow>" but this type is not registered...`;return!1}return this.constructor._registeredTypes[t.toLowerCase()].is(e)}cast(e,t,r){const s={value:e,issues:{},settings:r=z(this._settings,r)};for(let n=0;n<this.types.length;n++){const o=this.types[n],i=o.type,a=this.constructor._registeredTypes[i.toLowerCase()];if(void 0===a)continue;if(void 0===a.cast)continue;let l;if(l=a.cast(e,t),l instanceof Error)s.issues[i]=l.toString();else{if(void 0!==o.of&&!1===this.canHaveChilds(l)){const e=`Sorry but the passed type "<yellow>${i}</yellow>" has some child(s) dependencies "<green>${o.of.join("|")}</green>" but this type can not have child(s)`;if(!0===r.throw)throw je(e);s.issues[i]=e}else if(void 0!==o.of){const e=new Oe(o.of.join("|"));l=ve(l,(({value:s})=>e.cast(s,t,r)))}if(null===l&&"null"===a.id)return null;if(void 0===l&&"undefined"===a.id)return;if(null!=l)return l;s.issues[i]="Something goes wrong but no details are available... Sorry"}}if(r.throw){const t=[`Sorry but the value of type "<cyan>${we(e)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:\n`];throw Object.keys(s.issues).forEach((e=>{t.push(`- <red>${e}</red>: ${s.issues[e]}`)})),je(t.join("\n"))}return!0===r.verbose?new Error(s):new Error("Something goes wrong with the casting process but not details available sorry...")}canHaveChilds(e){const t=we(e);return"Array"===t||"Object"===t||"Map"===t}get name(){return this._settings.name}get id(){return this._settings.id}}Oe._instanciatedTypes={},Oe._registeredTypes={};const ke={name:"String",id:"string",is:e=>function(e){return"string"==typeof e||e instanceof String}(e),cast:e=>X(e,{beautify:!0})},Ee={name:"Map",id:"map",is:e=>G(e),cast:e=>{if(G(e))return e;const t=new Map;return t.set("value",e),t}},Ae={name:"Object",id:"object",is:e=>Q(e),cast:e=>Q(e)?e:{value:e}},Ce={name:"Array",id:"array",is:e=>Array.isArray(e),cast:(e,t={})=>(t.commaSplit&&"string"==typeof e&&(e=e.split(",").map((e=>e.trim()))),Array.isArray(e)?e:[e])},Te={name:"Integer",id:"integer",is:e=>Number.isInteger(e),cast:e=>{if("string"!=typeof e&&"number"!=typeof e)return new Error(`Sorry but only strings and numbers can be casted to integers... Passed value: ${e}`);const t=parseInt(e);return isNaN(t)?new Error(`Sorry but the conversion of "<yellow>${e}</yellow>" to a <green>Integer</green> does not work...`):t}},xe={name:"Number",id:"number",is:e=>"number"==typeof e,cast:e=>{if("string"!=typeof e)return new Error("Sorry but only strings can be casted to numbers...");const t=parseFloat(e);return isNaN(t)?new Error(`Sorry but the conversion of "<yellow>${e}</yellow>" to a <green>Number</green> does not work...`):t}},Re={name:"Boolean",id:"boolean",is:e=>"boolean"==typeof e,cast:(e,t={})=>!(!1===e||!t||!t.nullishAsTrue||e)||("boolean"==typeof e?e:null!=e&&("number"==typeof e?e>0:"string"==typeof e||Array.isArray(e)?e.length>0:"object"==typeof e?Object.keys(e).length>0:new Error(["Sorry but for now only these types can be casted to boolean:","- <yellow>null</yellow>: Will be casted as <red>false</red>","- <yellow>undefined</yellow>: Will be casted as <red>false</red>","- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise","- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise","- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise","- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"].join("\n"))))},Me={name:"Symbol",id:"symbol",is:e=>"symbol"==typeof e,cast:e=>"symbol"==typeof e?e:Symbol(e)},Ie={name:"Bigint",id:"bigint",is:e=>"bigint"==typeof e,cast:e=>{if("bigint"==typeof e)return e;if("string"!=typeof e&&"number"!=typeof e)return new Error("Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>");let t;try{t=BigInt(e)}catch(r){t=new Error(`It seem's that the passed value "<yellow>${e}</yellow>" can not be casted to a <green>BigInt</green>`)}return t}},De={name:"Date",id:"date",is:e=>e instanceof Date,cast:e=>{if("string"==typeof e)return new Date(e);if("number"==typeof e)return new Date(Math.round(e));if(W(e)){let t=(new Date).getFullYear(),r=0,s=1,n=0,o=0,i=0,a=0;return e.year&&"number"==typeof e.year&&(t=e.year),e.month&&"number"==typeof e.month&&(r=e.month),e.day&&"number"==typeof e.day&&(s=e.day),e.hours&&"number"==typeof e.hours&&(n=e.hours),e.minutes&&"number"==typeof e.minutes&&(o=e.minutes),e.seconds&&"number"==typeof e.seconds&&(i=e.seconds),e.milliseconds&&"number"==typeof e.milliseconds&&(a=e.milliseconds),new Date(t,r,s,n,o,i,a)}return new Error("Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date")}},Ne={name:"Function",id:"function",is:e=>"function"==typeof e,cast:e=>new Error("Sorry but nothing is castable to a Function")},Le={name:"WeakMap",id:"weakmap",is:e=>e instanceof WeakMap,cast:e=>new Error("Sorry but nothing can be casted to a WeakMap for now")},Be={name:"WeakSet",id:"weakset",is:e=>e instanceof WeakSet,cast:e=>new Error("Sorry but nothing can be casted to a WeakSet for now")},Pe={name:"Set",id:"set",is:e=>e instanceof Set,cast:e=>{if(e instanceof Set)return e;const t=new Set;return t.add(e),t}},Fe={name:"Class",id:"class",is:e=>F(e),cast:e=>new Error("Sorry but nothing is castable to a Class")};Oe.registerType(ke),Oe.registerType(Ee),Oe.registerType(Ae),Oe.registerType(Ce),Oe.registerType(Te),Oe.registerType(xe),Oe.registerType(Re),Oe.registerType({name:"Undefined",id:"undefined",is:e=>void 0===e,cast:e=>{}}),Oe.registerType({name:"Null",id:"null",is:e=>null===e,cast:e=>null}),Oe.registerType(Me),Oe.registerType(Ie),Oe.registerType(De),Oe.registerType(Ne),Oe.registerType(Le),Oe.registerType(Be),Oe.registerType(Pe),Oe.registerType(Fe);class He extends ae{constructor(e,t,r){super({}),this._issues={},this._descriptor=e,this._descriptorSettings=r;try{this._originalValue=U(t,{deep:!0})}catch(s){this._originalValue=t}this.value=t}hasIssues(){return Object.keys(this._issues).length>=1}add(e){e.__ruleObj.id&&(this._issues[e.__ruleObj.id]=e)}toString(){return Se()?this.toConsole():'The method "toHtml" has not being integrated for now...'}toConsole(){const e=[`<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,"",`${X(this.value,{beautify:!0})}`,""],t=[];Object.keys(this._issues).forEach((e=>{const r=this._issues[e];let s="";r.__error&&r.__error instanceof Error?s=r.__error.message:void 0!==r.__ruleObj.message&&"function"==typeof r.__ruleObj.message?s=r.__ruleObj.message(r):void 0!==r.__ruleObj.message&&"string"==typeof r.__ruleObj.message&&(s=r.__ruleObj.message),t.push(`-${"string"==typeof r.__propName?` [<magenta>${r.__propName}</magenta>]`:""} <red>${e}</red>: ${s}`)}));const r=["","<underline>Settings</underline>","",`${X(this._descriptorSettings,{beautify:!0})}`];return je(`\n${e.join("\n")}\n${t.join("\n")}\n${this._descriptorSettings.verbose?r.join("\n"):""}\n    `).trim()}}class We extends ae{constructor(e){super(z({descriptor:{rules:{},type:"Object",arrayAsValue:!1,throwOnMissingRule:!1,throw:!1,complete:!0,verbose:!1}},null!=e?e:{}))}static registerRule(e){if(void 0===e.id||"string"!=typeof e.id)throw"Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...";this._registeredRules[e.id]=e}get descriptorSettings(){return this._settings.descriptor}apply(e,t){const r=z(this.descriptorSettings,t||{});null==e&&(e={});const s={},n={};this._descriptorResult=new He(this,n,Object.assign({},r));const o=r.rules;if(!function(e,t,r={}){return r=Object.assign({verbose:!1},r),new Oe(t,r).is(e)}(e,r.type))throw`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${we(e)}</cyan>" but only "<green>${r.type}</green>"...`;if(Array.isArray(e)&&!r.arrayAsValue)throw new Error("Sorry but the support for arrays like values has not been integrated for not...");if("object"!=typeof e||null==e)throw console.warn(e),new Error("You can apply an <yellow>SDescriptor</yellow> only on an Object like value...");if(Object.keys(o).forEach((t=>{P(t)&&e||(s[t]=J(e,t))})),Object.keys(s).forEach((e=>{const t=o[e];if(void 0===s[e]&&r.complete&&void 0!==t.default&&(s[e]=t.default),void 0!==t.interface){const r=s[e],n=t.interface.apply(r||{},{complete:!0,throw:!1});if(n.hasIssues())throw new Error(n.toString());s[e]=n.value}const i=this._validate(s[e],e,t,r);null!=i&&ie(n,e,i)})),this._descriptorResult.hasIssues()&&r.throw)throw new Error(this._descriptorResult.toString());return this._descriptorResult}_validate(e,t,r,s){if(void 0===r)return e;if((void 0===r.required||!1===r.required)&&null==e)return e;let n=e;return Object.keys(r).forEach((e=>{if("default"===e)return;const o=r[e];if(void 0===this.constructor._registeredRules[e]){if(s.throwOnMissingRule)throw`Sorry but you try to validate a value using the "<yellow>${e}</yellow>" rule but this rule is not registered. Here's the available rules:\n              - ${Object.keys(this.constructor._registeredRules).join("\n- ")}`}else{const r=this.constructor._registeredRules[e],i=void 0!==r.processParams?r.processParams(o):o,a=void 0!==r.settings?r.settings:{};if(a.mapOnArray&&Array.isArray(n)){let e=[];n.forEach((n=>{const o=this._processRule(n,r,t,i,a,s);Array.isArray(o)?e=[...e,...o]:e.push(o)})),n=e}else{const e=this._processRule(n,r,t,i,a,s);n=e}}})),n}_processRule(e,t,r,s,n,o){const i=t.apply(e,s,n,Object.assign(Object.assign({},o),{propName:r,name:`${o.name}.${r}`}));if(s&&s.type&&"boolean"===s.type.toLowerCase()&&!0===i)return!0;if(!0===i)return e;if(i instanceof Error){const s={__error:i,__ruleObj:t,__propName:r};return this._descriptorResult.add(s),e}return i}}We._registeredRules={},We.rules={},We.type="Object";const Ye={name:"Type",id:"type",settings:{},processParams:e=>{var t,r;if(!(null==e?void 0:e.type)&&"string"!=typeof e)throw new Error('<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...');return Object.assign(Object.assign({},"string"!=typeof e?e:{}),{type:null!==(t=e.type)&&void 0!==t?t:e,cast:null===(r=e.cast)||void 0===r||r})},apply:(e,t,r,s)=>{const n=new Oe(t.type,{metas:{id:s.id}});return t.cast&&!n.is(e)&&(e=n.cast(e,t)),n.is(e)?e:new Error(`The value must be of type "<yellow>${t.type}</yellow>" but you've passed a value of type "<cyan>${typeof e}</cyan>"`)}};We.registerRule({name:"Required",id:"required",settings:{when:[void 0,null]},message:"This value is required",processParams:e=>({value:e}),apply:(e,t,r,s)=>!0!==t.value||-1===r.when.indexOf(e)}),We.registerRule(Ye),We.registerRule({name:"Min",id:"min",settings:{},accept:"Number",message:e=>`This value has to be minimum "<yellow>${e.min}</yellow>". Received "<red>${e.received}</red>"`,processParams:e=>({value:e}),apply:(e,t,r,s)=>!(e<t.value)||{min:t.value,received:e}}),We.registerRule({name:"Max",id:"max",settings:{},accept:"Number",message:e=>`This value has to be maximum "<yellow>${e.max}</yellow>". Received "<red>${e.received}</red>"`,processParams:e=>({value:e}),apply:(e,t,r,s)=>!(e>t.value)||{max:t.value,received:e}});class Ue{constructor(e={}){this._data={},this._data=z({},e)}get value(){var e,t;if(!this.hasIssues())return null===(t=null===(e=this._data)||void 0===e?void 0:e.descriptorResult)||void 0===t?void 0:t.value}hasIssues(){return!!this._data.descriptorResult&&this._data.descriptorResult.hasIssues()}toString(){return Se()?this.toConsole():'The method "toHtml" has not being integrated for now...'}toConsole(){const e=[];return this._data.descriptorResult&&e.push(this._data.descriptorResult.toConsole()),`\n${e.join("\n")}\n    `.trim()}}Se()?global._registeredInterfacesTypes={}:window._registeredInterfacesTypes={};class qe extends ae{constructor(e){super(z({interface:{throw:!0}},null!=e?e:{})),this._definition={},this._definition=this.constructor.definition}static get definition(){return this._definition.help||(this._definition.help={type:"Boolean",description:`Display the help for this "<yellow>${this.name}</yellow>" interface...`,default:!1}),this._definition}static set definition(e){this._definition=e}get interfaceSettings(){return this._settings.interface}static registerRenderer(e){if(!e.id)throw new Error(`Sorry but the interface renderer "<yellow>${e.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);this._registeredRenderers[e.id]=e}static override(e){class t extends(this){}return t.overridedName=`${this.name} (overrided)`,t.definition=z(this.definition,e),t}static getAvailableTypes(){return void 0!==global?global._registeredInterfacesTypes||{}:void 0!==window&&window._registeredInterfacesTypes||{}}static makeAvailableAsType(e=null){const t=(e||this.name).toLowerCase();void 0!==global?(global._registeredInterfacesTypes[t]=this,global._registeredInterfacesTypes[t.replace("interface","")]=this):void 0!==window&&(window._registeredInterfacesTypes[t]=this,window._registeredInterfacesTypes[t.replace("interface","")]=this)}static defaults(){const e=this.apply({},{throw:!1});return e.hasIssues()?{}:e.value}static apply(e,t){return new this({interface:null!=t?t:{}}).apply(e)}static render(e="terminal",t){const r=z({renderer:"terminal",exclude:["help"]},t);if(!this._registeredRenderers[e])throw new Error(`Sorry but the requested renderer "<yellow>${e}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);return new this._registeredRenderers[e](this,r).render()}apply(e,t){var r;const s=z(this.interfaceSettings,null!=t?t:{});let n=e;"string"==typeof e&&(n=function(e,t={}){t=z({throw:!0,defaultObj:{},cast:!0,valueQuote:void 0},t),e=e.trim();let r=t.valueQuote;if(!r){for(let t=0;t<e.length;t++){const s=e[t];if('"'===s||"`"===s||"'"===s){r=s;break}}r||(r='"')}let s=[],n=!1;if(e.match(/^\(/)&&e.match(/\)$/)){n=!0,e=e.slice(1,-1);let t="",o=!1,i=!1;for(let n=0;n<e.length;n++){const a=e[n],l=e[n-1]||e[0];a!==r||"\\"===l||i?a===r&&"\\"!==l&&i&&(i=!1):i=!0,i||"("!==a||o?i||")"!==a||(o=!1):o=!0,","===a?i||o?t+=a:(s.push(t.trim()),t=""):t+=a}s.push(t.trim())}else{let t="",n=!1;for(let o=0;o<e.length;o++){const i=e[o],a=e[o-1]||e[0];i!==r||"\\"===a||n?i===r&&"\\"!==a&&n&&(n=!1):n=!0," "===i?n?t+=i:(s.push(t.trim()),t=""):t+=i}s.push(t.trim())}s=s.map((e=>Z(e)));const o={};let i,a;return s=s.forEach(((e,t)=>{if(s.length,n||"--"!==e.slice(0,2)&&"-"!==e.slice(0,1)){let r;if(e&&"string"==typeof e&&(r=e.replace(/^\\\\\\`/,"").replace(/\\\\\\`$/,"").replace(/^'/,"").replace(/'$/,"").replace(/^"/,"").replace(/"$/,""),r.match(/^\$[a-zA-Z0-9-_]+\s?:.*/))){const t=e.split(":");i=t[0].trim().replace(/^\$/,""),r=t.slice(1).join(":").trim()}a=ee(r),void 0!==i?(void 0!==o[i]&&!0!==o[i]?(Array.isArray(o[i])||(o[i]=[o[i]]),o[i].push(a)):o[i]=a,a=void 0,i=void 0):o[t]=a}else void 0===a&&-1!==i&&i&&(o[i]=!0),i=e.replace(/^[-]{1,2}/,""),o[i]=!0})),o}(e),Object.keys(n).forEach((e=>{for(let t=0;t<Object.keys(this._definition).length;t++){const r=Object.keys(this._definition)[t],s=this._definition[r];s.alias&&(s.alias===e&&void 0===n[r]&&(n[r]=n[e],delete n[e]))}})),Object.keys(n).forEach(((e,t)=>{if(e===`${t}`){const r=Object.keys(this._definition);r[t]&&(n[r[t]]=n[e]),delete n[e]}})));const o=new We({descriptor:Object.assign({type:"Object",rules:this._definition,throw:!1},null!==(r=s.descriptor)&&void 0!==r?r:{})});s.baseObj&&(n=z(s.baseObj,n));const i=o.apply(n),a=new Ue({descriptorResult:i});if(a.hasIssues()&&s.throw)throw new Error(a.toString());return a}}qe._definition={},qe._registeredRenderers={};class ze extends qe{}ze.definition={theme:{type:"String",default:"https://gitcdn.link/repo/PrismJS/prism-themes/master/themes/prism-nord.css"},language:{type:"String",default:"javascript"}};const Ze="src/js/index.svelte";function Je(e){let t,r;const s={c:function(){t=w("pre"),r=w("code"),this.c=v,this.h()},l:function(e){t=_(e,"PRE",{class:!0});var s=j(t);r=_(s,"CODE",{}),j(r).forEach(S),s.forEach(S),this.h()},h:function(){$(r,Ze,35,1,1282),O(t,"class","language-"+e[1]),$(t,Ze,34,0,1247)},m:function(s,n){y(s,t,n),k(t,r),e[2](r)},p:v,i:v,o:v,d:function(r){r&&S(t),e[2](null)}};return g("SvelteRegisterBlock",{block:s,id:Je.name,type:"component",source:"",ctx:e}),s}function Ve(e,t,r){let{$$slots:s={},$$scope:n}=t;f("s-highlight-js",s,[]);class o extends me{constructor(e){super(e,{svelteComponent:{}})}}o.interface=ze,console.log("FFfffF");const i=new o(t);let a,{theme:l,language:c}=i.props;const u=document.querySelector("s-highlight-js").innerHTML;return i.onMount((()=>{const e=`@import url('${l}');`,t=document.createElement("style");t.type="text/css",t.appendChild(document.createTextNode(e));const s=A.highlight(u.trim(),A.languages.javascript,"javascript");console.log("c"),r(0,a.innerHTML=s,a),a.appendChild(t)})),e.$$set=e=>{r(7,t=m(m({},t),b(e)))},e.$capture_state=()=>({prism:A,__SSvelteComponent:me,__SHighlightJsComponentInterface:ze,MyCoolComponent:o,component:i,theme:l,language:c,codeElement:a,text:u}),e.$inject_state=e=>{r(7,t=m(m({},t),e)),"theme"in t&&(l=e.theme),"language"in t&&r(1,c=e.language),"codeElement"in t&&r(0,a=e.codeElement)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),t=b(t),[a,c,function(e){E[e?"unshift":"push"]((()=>{a=e,r(0,a)}))}]}class Ge extends c{constructor(e){super(),this.shadowRoot.innerHTML="<style>code{color:var(--s-theme-color-primary-default, #f2bc2b) !important}*{}</style>",u(this,{target:this.shadowRoot,props:d(this.attributes),customElement:!0},Ve,Je,p,{}),e&&(e.target&&y(e.target,this,e.anchor),e.props&&(this.$set(e.props),h()))}}customElements.define("s-highlight-js",Ge);export default Ge;

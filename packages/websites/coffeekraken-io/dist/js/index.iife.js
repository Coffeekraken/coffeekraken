var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
(function() {
  "use strict";
  /* Riot v5.4.2, @license MIT */
  function camelToDashCase(string) {
    return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function dashToCamelCase(string) {
    return string.replace(/-(\w)/g, (_, c) => c.toUpperCase());
  }
  function DOMattributesToObject(element) {
    return Array.from(element.attributes).reduce((acc, attribute) => {
      acc[dashToCamelCase(attribute.name)] = attribute.value;
      return acc;
    }, {});
  }
  function moveChildren(source, target) {
    if (source.firstChild) {
      target.appendChild(source.firstChild);
      moveChildren(source, target);
    }
  }
  function cleanNode(node) {
    clearChildren(node.childNodes);
  }
  function clearChildren(children) {
    Array.from(children).forEach(removeChild);
  }
  const removeChild = (node) => node && node.parentNode && node.parentNode.removeChild(node);
  const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);
  const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);
  const COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(), DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol("riot-component"), PLUGINS_SET$1 = new Set(), IS_DIRECTIVE = "is", VALUE_ATTRIBUTE = "value", MOUNT_METHOD_KEY = "mount", UPDATE_METHOD_KEY = "update", UNMOUNT_METHOD_KEY = "unmount", SHOULD_UPDATE_KEY = "shouldUpdate", ON_BEFORE_MOUNT_KEY = "onBeforeMount", ON_MOUNTED_KEY = "onMounted", ON_BEFORE_UPDATE_KEY = "onBeforeUpdate", ON_UPDATED_KEY = "onUpdated", ON_BEFORE_UNMOUNT_KEY = "onBeforeUnmount", ON_UNMOUNTED_KEY = "onUnmounted", PROPS_KEY = "props", STATE_KEY = "state", SLOTS_KEY = "slots", ROOT_KEY = "root", IS_PURE_SYMBOL = Symbol("pure"), IS_COMPONENT_UPDATING = Symbol("is_updating"), PARENT_KEY_SYMBOL = Symbol("parent"), ATTRIBUTES_KEY_SYMBOL = Symbol("attributes"), TEMPLATE_KEY_SYMBOL = Symbol("template");
  var globals = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,
    DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,
    PLUGINS_SET: PLUGINS_SET$1,
    IS_DIRECTIVE,
    VALUE_ATTRIBUTE,
    MOUNT_METHOD_KEY,
    UPDATE_METHOD_KEY,
    UNMOUNT_METHOD_KEY,
    SHOULD_UPDATE_KEY,
    ON_BEFORE_MOUNT_KEY,
    ON_MOUNTED_KEY,
    ON_BEFORE_UPDATE_KEY,
    ON_UPDATED_KEY,
    ON_BEFORE_UNMOUNT_KEY,
    ON_UNMOUNTED_KEY,
    PROPS_KEY,
    STATE_KEY,
    SLOTS_KEY,
    ROOT_KEY,
    IS_PURE_SYMBOL,
    IS_COMPONENT_UPDATING,
    PARENT_KEY_SYMBOL,
    ATTRIBUTES_KEY_SYMBOL,
    TEMPLATE_KEY_SYMBOL
  });
  const EACH = 0;
  const IF = 1;
  const SIMPLE = 2;
  const TAG = 3;
  const SLOT = 4;
  var bindingTypes = {
    EACH,
    IF,
    SIMPLE,
    TAG,
    SLOT
  };
  const ATTRIBUTE = 0;
  const EVENT = 1;
  const TEXT = 2;
  const VALUE = 3;
  var expressionTypes = {
    ATTRIBUTE,
    EVENT,
    TEXT,
    VALUE
  };
  const HEAD_SYMBOL = Symbol("head");
  const TAIL_SYMBOL = Symbol("tail");
  function createHeadTailPlaceholders() {
    const head = document.createComment("fragment head");
    const tail = document.createComment("fragment tail");
    head[HEAD_SYMBOL] = true;
    tail[TAIL_SYMBOL] = true;
    return {
      head,
      tail
    };
  }
  function createTemplateMeta(componentTemplate) {
    const fragment = componentTemplate.dom.cloneNode(true);
    const {
      head,
      tail
    } = createHeadTailPlaceholders();
    return {
      avoidDOMInjection: true,
      fragment,
      head,
      tail,
      children: [head, ...Array.from(fragment.childNodes), tail]
    };
  }
  function getFragmentChildren(_ref) {
    let {
      head,
      tail
    } = _ref;
    const nodes = walkNodes([head], head.nextSibling, (n) => n === tail, false);
    nodes.push(tail);
    return nodes;
  }
  function walkNodes(children, node, check, isFilterActive) {
    const {
      nextSibling
    } = node;
    if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {
      children.push(node);
    }
    if (!nextSibling || check(node))
      return children;
    return walkNodes(children, nextSibling, check, isFilterActive && !node[TAIL_SYMBOL] || nextSibling[HEAD_SYMBOL]);
  }
  function checkType(element, type) {
    return typeof element === type;
  }
  function isSvg(el) {
    const owner = el.ownerSVGElement;
    return !!owner || owner === null;
  }
  function isTemplate(el) {
    return !isNil(el.content);
  }
  function isFunction$4(value) {
    return checkType(value, "function");
  }
  function isBoolean$3(value) {
    return checkType(value, "boolean");
  }
  function isObject$5(value) {
    return !isNil(value) && value.constructor === Object;
  }
  function isNil(value) {
    return value === null || value === void 0;
  }
  var udomdiff = (a, b, get, before) => {
    const bLength = b.length;
    let aEnd = a.length;
    let bEnd = bLength;
    let aStart = 0;
    let bStart = 0;
    let map = null;
    while (aStart < aEnd || bStart < bEnd) {
      if (aEnd === aStart) {
        const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;
        while (bStart < bEnd)
          insertBefore(get(b[bStart++], 1), node);
      } else if (bEnd === bStart) {
        while (aStart < aEnd) {
          if (!map || !map.has(a[aStart]))
            removeChild(get(a[aStart], -1));
          aStart++;
        }
      } else if (a[aStart] === b[bStart]) {
        aStart++;
        bStart++;
      } else if (a[aEnd - 1] === b[bEnd - 1]) {
        aEnd--;
        bEnd--;
      } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
        const node = get(a[--aEnd], -1).nextSibling;
        insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);
        insertBefore(get(b[--bEnd], 1), node);
        a[aEnd] = b[bEnd];
      } else {
        if (!map) {
          map = new Map();
          let i = bStart;
          while (i < bEnd)
            map.set(b[i], i++);
        }
        if (map.has(a[aStart])) {
          const index = map.get(a[aStart]);
          if (bStart < index && index < bEnd) {
            let i = aStart;
            let sequence = 1;
            while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)
              sequence++;
            if (sequence > index - bStart) {
              const node = get(a[aStart], 0);
              while (bStart < index)
                insertBefore(get(b[bStart++], 1), node);
            } else {
              replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));
            }
          } else
            aStart++;
        } else
          removeChild(get(a[aStart++], -1));
      }
    }
    return b;
  };
  const UNMOUNT_SCOPE = Symbol("unmount");
  const EachBinding = {
    nodes: [],
    mount(scope, parentScope) {
      return this.update(scope, parentScope);
    },
    update(scope, parentScope) {
      const {
        placeholder,
        nodes,
        childrenMap
      } = this;
      const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);
      const items = collection ? Array.from(collection) : [];
      const {
        newChildrenMap,
        batches,
        futureNodes
      } = createPatch(items, scope, parentScope, this);
      udomdiff(nodes, futureNodes, patch$2(Array.from(childrenMap.values()), parentScope), placeholder);
      batches.forEach((fn) => fn());
      this.childrenMap = newChildrenMap;
      this.nodes = futureNodes;
      markEdgeNodes(this.nodes);
      return this;
    },
    unmount(scope, parentScope) {
      this.update(UNMOUNT_SCOPE, parentScope);
      return this;
    }
  };
  function patch$2(redundant, parentScope) {
    return (item, info) => {
      if (info < 0) {
        const element = redundant[redundant.length - 1];
        if (element) {
          const {
            template,
            nodes,
            context
          } = element;
          nodes.pop();
          if (nodes.length === 0) {
            redundant.pop();
            template.unmount(context, parentScope, null);
          }
        }
      }
      return item;
    };
  }
  function mustFilterItem(condition, context) {
    return condition ? Boolean(condition(context)) === false : false;
  }
  function extendScope(scope, _ref) {
    let {
      itemName,
      indexName,
      index,
      item
    } = _ref;
    scope[itemName] = item;
    if (indexName)
      scope[indexName] = index;
    return scope;
  }
  function markEdgeNodes(nodes) {
    const first = nodes[0];
    const last = nodes[nodes.length - 1];
    if (first)
      first[HEAD_SYMBOL] = true;
    if (last)
      last[TAIL_SYMBOL] = true;
  }
  function createPatch(items, scope, parentScope, binding) {
    const {
      condition,
      template,
      childrenMap,
      itemName,
      getKey,
      indexName,
      root,
      isTemplateTag
    } = binding;
    const newChildrenMap = new Map();
    const batches = [];
    const futureNodes = [];
    items.forEach((item, index) => {
      const context = extendScope(Object.create(scope), {
        itemName,
        indexName,
        index,
        item
      });
      const key = getKey ? getKey(context) : index;
      const oldItem = childrenMap.get(key);
      const nodes = [];
      if (mustFilterItem(condition, context)) {
        return;
      }
      const mustMount = !oldItem;
      const componentTemplate = oldItem ? oldItem.template : template.clone();
      const el = componentTemplate.el || root.cloneNode();
      const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;
      if (mustMount) {
        batches.push(() => componentTemplate.mount(el, context, parentScope, meta));
      } else {
        batches.push(() => componentTemplate.update(context, parentScope));
      }
      if (isTemplateTag) {
        nodes.push(...mustMount ? meta.children : getFragmentChildren(meta));
      } else {
        nodes.push(el);
      }
      childrenMap.delete(key);
      futureNodes.push(...nodes);
      newChildrenMap.set(key, {
        nodes,
        template: componentTemplate,
        context,
        index
      });
    });
    return {
      newChildrenMap,
      batches,
      futureNodes
    };
  }
  function create$6(node, _ref2) {
    let {
      evaluate,
      condition,
      itemName,
      indexName,
      getKey,
      template
    } = _ref2;
    const placeholder = document.createTextNode("");
    const root = node.cloneNode();
    insertBefore(placeholder, node);
    removeChild(node);
    return Object.assign({}, EachBinding, {
      childrenMap: new Map(),
      node,
      root,
      condition,
      evaluate,
      isTemplateTag: isTemplate(root),
      template: template.createDOM(node),
      getKey,
      indexName,
      itemName,
      placeholder
    });
  }
  const IfBinding = {
    mount(scope, parentScope) {
      return this.update(scope, parentScope);
    },
    update(scope, parentScope) {
      const value = !!this.evaluate(scope);
      const mustMount = !this.value && value;
      const mustUnmount = this.value && !value;
      const mount = () => {
        const pristine = this.node.cloneNode();
        insertBefore(pristine, this.placeholder);
        this.template = this.template.clone();
        this.template.mount(pristine, scope, parentScope);
      };
      switch (true) {
        case mustMount:
          mount();
          break;
        case mustUnmount:
          this.unmount(scope);
          break;
        default:
          if (value)
            this.template.update(scope, parentScope);
      }
      this.value = value;
      return this;
    },
    unmount(scope, parentScope) {
      this.template.unmount(scope, parentScope, true);
      return this;
    }
  };
  function create$5(node, _ref) {
    let {
      evaluate,
      template
    } = _ref;
    const placeholder = document.createTextNode("");
    insertBefore(placeholder, node);
    removeChild(node);
    return Object.assign({}, IfBinding, {
      node,
      evaluate,
      placeholder,
      template: template.createDOM(node)
    });
  }
  function panic(message) {
    throw new Error(message);
  }
  function memoize(fn) {
    const cache = new Map();
    const cached = (val) => {
      return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
    };
    cached.cache = cache;
    return cached;
  }
  function evaluateAttributeExpressions(attributes) {
    return attributes.reduce((acc, attribute) => {
      const {
        value,
        type
      } = attribute;
      switch (true) {
        case (!attribute.name && type === ATTRIBUTE):
          return Object.assign({}, acc, value);
        case type === VALUE:
          acc.value = attribute.value;
          break;
        default:
          acc[dashToCamelCase(attribute.name)] = attribute.value;
      }
      return acc;
    }, {});
  }
  const ElementProto$1 = typeof Element === "undefined" ? {} : Element.prototype;
  const isNativeHtmlProperty = memoize((name2) => ElementProto$1.hasOwnProperty(name2));
  function setAllAttributes(node, attributes) {
    Object.entries(attributes).forEach((_ref) => {
      let [name2, value] = _ref;
      return attributeExpression(node, {
        name: name2
      }, value);
    });
  }
  function removeAllAttributes(node, newAttributes, oldAttributes) {
    const newKeys = newAttributes ? Object.keys(newAttributes) : [];
    Object.keys(oldAttributes).filter((name2) => !newKeys.includes(name2)).forEach((attribute) => node.removeAttribute(attribute));
  }
  function canRenderAttribute(value) {
    return value === true || ["string", "number"].includes(typeof value);
  }
  function shouldRemoveAttribute(value) {
    return isNil(value) || value === false || value === "";
  }
  function attributeExpression(node, _ref2, value, oldValue) {
    let {
      name: name2
    } = _ref2;
    if (!name2) {
      if (oldValue) {
        removeAllAttributes(node, value, oldValue);
      }
      if (value) {
        setAllAttributes(node, value);
      }
      return;
    }
    if (!isNativeHtmlProperty(name2) && (isBoolean$3(value) || isObject$5(value) || isFunction$4(value))) {
      node[name2] = value;
    }
    if (shouldRemoveAttribute(value)) {
      node.removeAttribute(name2);
    } else if (canRenderAttribute(value)) {
      node.setAttribute(name2, normalizeValue(name2, value));
    }
  }
  function normalizeValue(name2, value) {
    if (value === true)
      return name2;
    return value;
  }
  const RE_EVENTS_PREFIX = /^on/;
  const getCallbackAndOptions = (value) => Array.isArray(value) ? value : [value, false];
  const EventListener = {
    handleEvent(event2) {
      this[event2.type](event2);
    }
  };
  const ListenersWeakMap = new WeakMap();
  const createListener = (node) => {
    const listener = Object.create(EventListener);
    ListenersWeakMap.set(node, listener);
    return listener;
  };
  function eventExpression(node, _ref, value) {
    let {
      name: name2
    } = _ref;
    const normalizedEventName = name2.replace(RE_EVENTS_PREFIX, "");
    const eventListener = ListenersWeakMap.get(node) || createListener(node);
    const [callback, options] = getCallbackAndOptions(value);
    const handler = eventListener[normalizedEventName];
    const mustRemoveEvent = handler && !callback;
    const mustAddEvent = callback && !handler;
    if (mustRemoveEvent) {
      node.removeEventListener(normalizedEventName, eventListener);
    }
    if (mustAddEvent) {
      node.addEventListener(normalizedEventName, eventListener, options);
    }
    eventListener[normalizedEventName] = callback;
  }
  function normalizeStringValue(value) {
    return isNil(value) ? "" : value;
  }
  const getTextNode = (node, childNodeIndex) => {
    const target = node.childNodes[childNodeIndex];
    if (target.nodeType === Node.COMMENT_NODE) {
      const textNode = document.createTextNode("");
      node.replaceChild(textNode, target);
      return textNode;
    }
    return target;
  };
  function textExpression(node, data, value) {
    node.data = normalizeStringValue(value);
  }
  function valueExpression(node, expression, value) {
    node.value = normalizeStringValue(value);
  }
  var expressions = {
    [ATTRIBUTE]: attributeExpression,
    [EVENT]: eventExpression,
    [TEXT]: textExpression,
    [VALUE]: valueExpression
  };
  const Expression = {
    mount(scope) {
      this.value = this.evaluate(scope);
      apply(this, this.value);
      return this;
    },
    update(scope) {
      const value = this.evaluate(scope);
      if (this.value !== value) {
        apply(this, value);
        this.value = value;
      }
      return this;
    },
    unmount() {
      if (this.type === EVENT)
        apply(this, null);
      return this;
    }
  };
  function apply(expression, value) {
    return expressions[expression.type](expression.node, expression, value, expression.value);
  }
  function create$4(node, data) {
    return Object.assign({}, Expression, data, {
      node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node
    });
  }
  function flattenCollectionMethods(collection, methods, context) {
    return methods.reduce((acc, method) => {
      return Object.assign({}, acc, {
        [method]: (scope) => {
          return collection.map((item) => item[method](scope)) && context;
        }
      });
    }, {});
  }
  function create$3(node, _ref) {
    let {
      expressions
    } = _ref;
    return Object.assign({}, flattenCollectionMethods(expressions.map((expression) => create$4(node, expression)), ["mount", "update", "unmount"]));
  }
  function extendParentScope(attributes, scope, parentScope) {
    if (!attributes || !attributes.length)
      return parentScope;
    const expressions = attributes.map((attr) => Object.assign({}, attr, {
      value: attr.evaluate(scope)
    }));
    return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));
  }
  const getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;
  const SlotBinding = {
    attributes: [],
    getTemplateScope(scope, parentScope) {
      return extendParentScope(this.attributes, scope, parentScope);
    },
    mount(scope, parentScope) {
      const templateData = scope.slots ? scope.slots.find((_ref) => {
        let {
          id
        } = _ref;
        return id === this.name;
      }) : false;
      const {
        parentNode
      } = this.node;
      const realParent = getRealParent(scope, parentScope);
      this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);
      if (this.template) {
        this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);
        this.template.children = Array.from(this.node.childNodes);
        moveSlotInnerContent(this.node);
      }
      removeChild(this.node);
      return this;
    },
    update(scope, parentScope) {
      if (this.template) {
        const realParent = getRealParent(scope, parentScope);
        this.template.update(this.getTemplateScope(scope, realParent), realParent);
      }
      return this;
    },
    unmount(scope, parentScope, mustRemoveRoot) {
      if (this.template) {
        this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);
      }
      return this;
    }
  };
  function moveSlotInnerContent(slot) {
    const child = slot && slot.firstChild;
    if (!child)
      return;
    insertBefore(child, slot);
    moveSlotInnerContent(slot);
  }
  function createSlot(node, _ref2) {
    let {
      name: name2,
      attributes
    } = _ref2;
    return Object.assign({}, SlotBinding, {
      attributes,
      node,
      name: name2
    });
  }
  function getTag(component, slots, attributes) {
    if (slots === void 0) {
      slots = [];
    }
    if (attributes === void 0) {
      attributes = [];
    }
    if (component) {
      return component({
        slots,
        attributes
      });
    }
    return create(slotsToMarkup(slots), [...slotBindings(slots), {
      expressions: attributes.map((attr) => {
        return Object.assign({
          type: ATTRIBUTE
        }, attr);
      })
    }]);
  }
  function slotBindings(slots) {
    return slots.reduce((acc, _ref) => {
      let {
        bindings
      } = _ref;
      return acc.concat(bindings);
    }, []);
  }
  function slotsToMarkup(slots) {
    return slots.reduce((acc, slot) => {
      return acc + slot.html;
    }, "");
  }
  const TagBinding = {
    mount(scope) {
      return this.update(scope);
    },
    update(scope, parentScope) {
      const name2 = this.evaluate(scope);
      if (name2 && name2 === this.name) {
        this.tag.update(scope);
      } else {
        this.unmount(scope, parentScope, true);
        this.name = name2;
        this.tag = getTag(this.getComponent(name2), this.slots, this.attributes);
        this.tag.mount(this.node, scope);
      }
      return this;
    },
    unmount(scope, parentScope, keepRootTag) {
      if (this.tag) {
        this.tag.unmount(keepRootTag);
      }
      return this;
    }
  };
  function create$2(node, _ref2) {
    let {
      evaluate,
      getComponent,
      slots,
      attributes
    } = _ref2;
    return Object.assign({}, TagBinding, {
      node,
      evaluate,
      slots,
      attributes,
      getComponent
    });
  }
  var bindings = {
    [IF]: create$5,
    [SIMPLE]: create$3,
    [EACH]: create$6,
    [TAG]: create$2,
    [SLOT]: createSlot
  };
  function fixTextExpressionsOffset(expressions, textExpressionsOffset) {
    return expressions.map((e) => e.type === TEXT ? Object.assign({}, e, {
      childNodeIndex: e.childNodeIndex + textExpressionsOffset
    }) : e);
  }
  function create$1(root, binding, templateTagOffset) {
    const {
      selector,
      type,
      redundantAttribute,
      expressions
    } = binding;
    const node = selector ? root.querySelector(selector) : root;
    if (redundantAttribute)
      node.removeAttribute(redundantAttribute);
    const bindingExpressions = expressions || [];
    return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {
      expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions
    }));
  }
  function createHTMLTree(html, root) {
    const template = isTemplate(root) ? root : document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function createSVGTree(html, container) {
    const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`, "application/xml").documentElement, true);
    return svgNode;
  }
  function createDOMTree(root, html) {
    if (isSvg(root))
      return createSVGTree(html, root);
    return createHTMLTree(html, root);
  }
  function injectDOM(el, dom) {
    switch (true) {
      case isSvg(el):
        moveChildren(dom, el);
        break;
      case isTemplate(el):
        el.parentNode.replaceChild(dom, el);
        break;
      default:
        el.appendChild(dom);
    }
  }
  function createTemplateDOM(el, html) {
    return html && (typeof html === "string" ? createDOMTree(el, html) : html);
  }
  const TemplateChunk = Object.freeze({
    createDOM(el) {
      this.dom = this.dom || createTemplateDOM(el, this.html);
      return this;
    },
    mount(el, scope, parentScope, meta) {
      if (meta === void 0) {
        meta = {};
      }
      if (!el)
        throw new Error("Please provide DOM node to mount properly your template");
      if (this.el)
        this.unmount(scope);
      const {
        fragment,
        children,
        avoidDOMInjection
      } = meta;
      const {
        parentNode
      } = children ? children[0] : el;
      const isTemplateTag = isTemplate(el);
      const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.childNodes).indexOf(el), 0) : null;
      this.isTemplateTag = isTemplateTag;
      this.createDOM(el);
      if (this.dom) {
        this.fragment = fragment || this.dom.cloneNode(true);
      }
      this.el = this.isTemplateTag ? parentNode : el;
      this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null;
      if (!avoidDOMInjection && this.fragment)
        injectDOM(el, this.fragment);
      this.bindings = this.bindingsData.map((binding) => create$1(this.el, binding, templateTagOffset));
      this.bindings.forEach((b) => b.mount(scope, parentScope));
      this.meta = meta;
      return this;
    },
    update(scope, parentScope) {
      this.bindings.forEach((b) => b.update(scope, parentScope));
      return this;
    },
    unmount(scope, parentScope, mustRemoveRoot) {
      if (this.el) {
        this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));
        switch (true) {
          case this.el[IS_PURE_SYMBOL]:
            break;
          case (this.children && mustRemoveRoot !== null):
            clearChildren(this.children);
            break;
          case mustRemoveRoot === true:
            removeChild(this.el);
            break;
          case mustRemoveRoot !== null:
            cleanNode(this.el);
            break;
        }
        this.el = null;
      }
      return this;
    },
    clone() {
      return Object.assign({}, this, {
        meta: {},
        el: null
      });
    }
  });
  function create(html, bindings) {
    if (bindings === void 0) {
      bindings = [];
    }
    return Object.assign({}, TemplateChunk, {
      html,
      bindingsData: bindings
    });
  }
  function noop$3() {
    return this;
  }
  function autobindMethods(source, methods) {
    methods.forEach((method) => {
      source[method] = source[method].bind(source);
    });
    return source;
  }
  function callOrAssign(source) {
    return isFunction$4(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;
  }
  function defineProperty(source, key, value, options) {
    if (options === void 0) {
      options = {};
    }
    Object.defineProperty(source, key, Object.assign({
      value,
      enumerable: false,
      writable: false,
      configurable: true
    }, options));
    return source;
  }
  function defineProperties(source, properties, options) {
    Object.entries(properties).forEach((_ref) => {
      let [key, value] = _ref;
      defineProperty(source, key, value, options);
    });
    return source;
  }
  function defineDefaults(source, defaults) {
    Object.entries(defaults).forEach((_ref2) => {
      let [key, value] = _ref2;
      if (!source[key])
        source[key] = value;
    });
    return source;
  }
  function domToArray(els) {
    if (!Array.isArray(els)) {
      if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === "number")
        return Array.from(els);
      else
        return [els];
    }
    return els;
  }
  function $(selector, ctx) {
    return domToArray(typeof selector === "string" ? (ctx || document).querySelectorAll(selector) : selector);
  }
  const normalize = (values) => values.length === 1 ? values[0] : values;
  function parseNodes(els, name2, method) {
    const names = typeof name2 === "string" ? [name2] : name2;
    return normalize(domToArray(els).map((el) => {
      return normalize(names.map((n) => el[method](n)));
    }));
  }
  function set$1(els, name2, value) {
    const attrs = typeof name2 === "object" ? name2 : {
      [name2]: value
    };
    const props = Object.keys(attrs);
    domToArray(els).forEach((el) => {
      props.forEach((prop) => el.setAttribute(prop, attrs[prop]));
    });
    return els;
  }
  function get$1(els, name2) {
    return parseNodes(els, name2, "getAttribute");
  }
  const CSS_BY_NAME = new Map();
  const STYLE_NODE_SELECTOR = "style[riot]";
  const getStyleNode = ((style) => {
    return () => {
      if (style)
        return style;
      style = $(STYLE_NODE_SELECTOR)[0] || document.createElement("style");
      set$1(style, "type", "text/css");
      if (!style.parentNode)
        document.head.appendChild(style);
      return style;
    };
  })();
  var cssManager = {
    CSS_BY_NAME,
    add(name2, css) {
      if (!CSS_BY_NAME.has(name2)) {
        CSS_BY_NAME.set(name2, css);
        this.inject();
      }
      return this;
    },
    inject() {
      getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join("\n");
      return this;
    },
    remove(name2) {
      if (CSS_BY_NAME.has(name2)) {
        CSS_BY_NAME.delete(name2);
        this.inject();
      }
      return this;
    }
  };
  function curry(fn) {
    for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      acc[_key - 1] = arguments[_key];
    }
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args = [...acc, ...args];
      return args.length < fn.length ? curry(fn, ...args) : fn(...args);
    };
  }
  function getName(element) {
    return get$1(element, IS_DIRECTIVE) || element.tagName.toLowerCase();
  }
  const COMPONENT_CORE_HELPERS = Object.freeze({
    $(selector) {
      return $(selector, this.root)[0];
    },
    $$(selector) {
      return $(selector, this.root);
    }
  });
  const PURE_COMPONENT_API = Object.freeze({
    [MOUNT_METHOD_KEY]: noop$3,
    [UPDATE_METHOD_KEY]: noop$3,
    [UNMOUNT_METHOD_KEY]: noop$3
  });
  const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
    [SHOULD_UPDATE_KEY]: noop$3,
    [ON_BEFORE_MOUNT_KEY]: noop$3,
    [ON_MOUNTED_KEY]: noop$3,
    [ON_BEFORE_UPDATE_KEY]: noop$3,
    [ON_UPDATED_KEY]: noop$3,
    [ON_BEFORE_UNMOUNT_KEY]: noop$3,
    [ON_UNMOUNTED_KEY]: noop$3
  });
  const MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {
    clone: noop$3,
    createDOM: noop$3
  });
  const memoizedCreateComponent = memoize(createComponent);
  function evaluateInitialProps(element, initialProps) {
    if (initialProps === void 0) {
      initialProps = {};
    }
    return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));
  }
  const bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component;
  function createCoreAPIMethods(mapFunction) {
    return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {
      acc[method] = mapFunction(method);
      return acc;
    }, {});
  }
  function componentTemplateFactory(template, componentShell) {
    const components = createSubcomponents(componentShell.exports ? componentShell.exports.components : {});
    return template(create, expressionTypes, bindingTypes, (name2) => {
      if (name2 === componentShell.name)
        return memoizedCreateComponent(componentShell);
      return components[name2] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name2);
    });
  }
  function createPureComponent(pureFactoryFunction, _ref) {
    let {
      slots,
      attributes,
      props,
      css,
      template
    } = _ref;
    if (template)
      panic("Pure components can not have html");
    if (css)
      panic("Pure components do not have css");
    const component = defineDefaults(pureFactoryFunction({
      slots,
      attributes,
      props
    }), PURE_COMPONENT_API);
    return createCoreAPIMethods((method) => function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (method === MOUNT_METHOD_KEY) {
        const [el] = args;
        el[IS_PURE_SYMBOL] = true;
        bindDOMNodeToComponentObject(el, component);
      }
      component[method](...args);
      return component;
    });
  }
  function createComponent(componentShell) {
    const {
      css,
      template,
      exports,
      name: name2
    } = componentShell;
    const templateFn = template ? componentTemplateFactory(template, componentShell) : MOCKED_TEMPLATE_INTERFACE;
    return (_ref2) => {
      let {
        slots,
        attributes,
        props
      } = _ref2;
      if (exports && exports[IS_PURE_SYMBOL])
        return createPureComponent(exports, {
          slots,
          attributes,
          props,
          css,
          template
        });
      const componentAPI = callOrAssign(exports) || {};
      const component = defineComponent({
        css,
        template: templateFn,
        componentAPI,
        name: name2
      })({
        slots,
        attributes,
        props
      });
      return {
        mount(element, parentScope, state) {
          return component.mount(element, state, parentScope);
        },
        update(parentScope, state) {
          return component.update(state, parentScope);
        },
        unmount(preserveRoot) {
          return component.unmount(preserveRoot);
        }
      };
    };
  }
  function defineComponent(_ref3) {
    let {
      css,
      template,
      componentAPI,
      name: name2
    } = _ref3;
    if (css && name2)
      cssManager.add(name2, css);
    return curry(enhanceComponentAPI)(defineProperties(defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {
      [PROPS_KEY]: {},
      [STATE_KEY]: {}
    })), Object.assign({
      [SLOTS_KEY]: null,
      [ROOT_KEY]: null
    }, COMPONENT_CORE_HELPERS, {
      name: name2,
      css,
      template
    })));
  }
  function createAttributeBindings(node, attributes) {
    if (attributes === void 0) {
      attributes = [];
    }
    const expressions = attributes.map((a) => create$4(node, a));
    const binding = {};
    return Object.assign(binding, Object.assign({
      expressions
    }, createCoreAPIMethods((method) => (scope) => {
      expressions.forEach((e) => e[method](scope));
      return binding;
    })));
  }
  function createSubcomponents(components) {
    if (components === void 0) {
      components = {};
    }
    return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {
      let [key, value] = _ref4;
      acc[camelToDashCase(key)] = createComponent(value);
      return acc;
    }, {});
  }
  function runPlugins(component) {
    return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);
  }
  function computeState(oldState, newState) {
    return Object.assign({}, oldState, callOrAssign(newState));
  }
  function addCssHook(element, name2) {
    if (getName(element) !== name2) {
      set$1(element, IS_DIRECTIVE, name2);
    }
  }
  function enhanceComponentAPI(component, _ref5) {
    let {
      slots,
      attributes,
      props
    } = _ref5;
    return autobindMethods(runPlugins(defineProperties(isObject$5(component) ? Object.create(component) : component, {
      mount(element, state, parentScope) {
        if (state === void 0) {
          state = {};
        }
        this[PARENT_KEY_SYMBOL] = parentScope;
        this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);
        defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));
        this[STATE_KEY] = computeState(this[STATE_KEY], state);
        this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();
        bindDOMNodeToComponentObject(element, this);
        component.name && addCssHook(element, component.name);
        defineProperty(this, ROOT_KEY, element);
        defineProperty(this, SLOTS_KEY, slots);
        this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
        this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);
        this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
        return this;
      },
      update(state, parentScope) {
        if (state === void 0) {
          state = {};
        }
        if (parentScope) {
          this[PARENT_KEY_SYMBOL] = parentScope;
          this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);
        }
        const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);
        if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false)
          return;
        defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));
        this[STATE_KEY] = computeState(this[STATE_KEY], state);
        this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);
        if (!this[IS_COMPONENT_UPDATING]) {
          this[IS_COMPONENT_UPDATING] = true;
          this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);
        }
        this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);
        this[IS_COMPONENT_UPDATING] = false;
        return this;
      },
      unmount(preserveRoot) {
        this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
        this[ATTRIBUTES_KEY_SYMBOL].unmount();
        this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);
        this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
        return this;
      }
    })), Object.keys(component).filter((prop) => isFunction$4(component[prop])));
  }
  function mountComponent(element, initialProps, componentName) {
    const name2 = componentName || getName(element);
    if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name2))
      panic(`The component named "${name2}" was never registered`);
    const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name2)({
      props: initialProps
    });
    return component.mount(element);
  }
  const {
    DOM_COMPONENT_INSTANCE_PROPERTY,
    COMPONENTS_IMPLEMENTATION_MAP,
    PLUGINS_SET
  } = globals;
  function register(name2, _ref) {
    let {
      css,
      template,
      exports
    } = _ref;
    if (COMPONENTS_IMPLEMENTATION_MAP.has(name2))
      panic(`The component "${name2}" was already registered`);
    COMPONENTS_IMPLEMENTATION_MAP.set(name2, createComponent({
      name: name2,
      css,
      template,
      exports
    }));
    return COMPONENTS_IMPLEMENTATION_MAP;
  }
  function mount(selector, initialProps, name2) {
    return $(selector).map((element) => mountComponent(element, initialProps, name2));
  }
  var commonjsGlobal$2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getAugmentedNamespace$2(n) {
    if (n.__esModule)
      return n;
    var a = Object.defineProperty({}, "__esModule", {value: true});
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var rngBrowser = {exports: {}};
  var getRandomValues$1 = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
  if (getRandomValues$1) {
    var rnds8$1 = new Uint8Array(16);
    rngBrowser.exports = function whatwgRNG() {
      getRandomValues$1(rnds8$1);
      return rnds8$1;
    };
  } else {
    var rnds = new Array(16);
    rngBrowser.exports = function mathRNG() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 3) === 0)
          r = Math.random() * 4294967296;
        rnds[i] = r >>> ((i & 3) << 3) & 255;
      }
      return rnds;
    };
  }
  var byteToHex$1 = [];
  for (var i$1 = 0; i$1 < 256; ++i$1) {
    byteToHex$1[i$1] = (i$1 + 256).toString(16).substr(1);
  }
  function bytesToUuid$2(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex$1;
    return [
      bth[buf[i++]],
      bth[buf[i++]],
      bth[buf[i++]],
      bth[buf[i++]],
      "-",
      bth[buf[i++]],
      bth[buf[i++]],
      "-",
      bth[buf[i++]],
      bth[buf[i++]],
      "-",
      bth[buf[i++]],
      bth[buf[i++]],
      "-",
      bth[buf[i++]],
      bth[buf[i++]],
      bth[buf[i++]],
      bth[buf[i++]],
      bth[buf[i++]],
      bth[buf[i++]]
    ].join("");
  }
  var bytesToUuid_1 = bytesToUuid$2;
  var rng$2 = rngBrowser.exports;
  var bytesToUuid$1 = bytesToUuid_1;
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1$1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = rng$2();
      if (node == null) {
        node = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5]
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf ? buf : bytesToUuid$1(b);
  }
  var v1_1 = v1$1;
  var rng$1 = rngBrowser.exports;
  var bytesToUuid = bytesToUuid_1;
  function v4$2(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng$1)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  var v4_1 = v4$2;
  var v1 = v1_1;
  var v4$1 = v4_1;
  var uuid = v4$1;
  uuid.v1 = v1;
  uuid.v4 = v4$1;
  var uuid_1 = uuid;
  function getMethods(toCheck) {
    let props = [];
    let obj = toCheck;
    do {
      const _props = Object.getOwnPropertyNames(obj);
      if (_props.indexOf("__defineGetter__") !== -1)
        continue;
      props = props.concat(_props);
    } while (obj = Object.getPrototypeOf(obj));
    return props.sort().filter(function(e, i, arr) {
      if (e != arr[i + 1] && typeof toCheck[e] == "function")
        return true;
    });
  }
  var isClass = {exports: {}};
  (function(module, exports) {
    (function(root) {
      const toString = Function.prototype.toString;
      function fnBody(fn) {
        return toString.call(fn).replace(/^[^{]*{\s*/, "").replace(/\s*}[^}]*$/, "");
      }
      function isClass(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (/^class[\s{]/.test(toString.call(fn))) {
          return true;
        }
        const body = fnBody(fn);
        return /classCallCheck\(/.test(body) || /TypeError\("Cannot call a class as a function"\)/.test(body);
      }
      {
        if (module.exports) {
          exports = module.exports = isClass;
        }
        exports.isClass = isClass;
      }
    })();
  })(isClass, isClass.exports);
  var __isClass = isClass.exports;
  function cls$1(cls) {
    if (!Array.isArray(cls))
      cls = [cls];
    for (let i = 0; i < cls.length; i++) {
      if (!__isClass(cls[i]))
        return false;
    }
    return true;
  }
  const fn$7 = function(cls, settings = {}) {
    const stack = {};
    if (!cls$1(cls)) {
      cls = cls.constructor;
    }
    if (settings.includeBaseClass === true) {
      stack[cls.name] = cls;
    }
    let baseClass = cls;
    while (baseClass) {
      const newBaseClass = Object.getPrototypeOf(baseClass);
      if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
        stack[newBaseClass.name] = newBaseClass;
        baseClass = newBaseClass;
      } else {
        break;
      }
    }
    return stack;
  };
  function plainObject$2(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function unique$2(array) {
    const a = array.concat();
    for (let i = 0; i < a.length; ++i) {
      for (let j = i + 1; j < a.length; ++j) {
        if (a[i] === a[j])
          a.splice(j--, 1);
      }
    }
    return a;
  }
  var lodash_clone = {exports: {}};
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal$2 == "object" && commonjsGlobal$2 && commonjsGlobal$2.Object === Object && commonjsGlobal$2;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function clone(value) {
      return baseClone(value, false, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = clone;
  })(lodash_clone, lodash_clone.exports);
  var __clone = lodash_clone.exports;
  var lodash_clonedeep = {exports: {}};
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal$2 == "object" && commonjsGlobal$2 && commonjsGlobal$2.Object === Object && commonjsGlobal$2;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  })(lodash_clonedeep, lodash_clonedeep.exports);
  var __deepClone = lodash_clonedeep.exports;
  function clone$4(object, settings = {}) {
    settings = Object.assign({deep: false}, settings);
    if (settings.deep) {
      return __deepClone(object);
    }
    return __clone(object);
  }
  function deepAssign(referenceObj, ...objects) {
    const settings = {
      array: false,
      object: true,
      cloneChilds: true
    };
    function merge(refObj, mixWithObj) {
      for (const key of Object.keys(mixWithObj)) {
        if (settings.array === true && Array.isArray(refObj[key]) && Array.isArray(mixWithObj[key])) {
          const newArray = unique$2([...refObj[key], ...mixWithObj[key]]);
          refObj[key] = newArray;
          continue;
        }
        if (settings.object === true && plainObject$2(refObj[key]) && plainObject$2(mixWithObj[key])) {
          refObj[key] = merge(refObj[key], mixWithObj[key]);
          continue;
        }
        if (plainObject$2(mixWithObj[key]) && settings.cloneChilds) {
          refObj[key] = clone$4(mixWithObj[key], {
            deep: true
          });
        } else {
          refObj[key] = mixWithObj[key];
        }
      }
      return refObj;
    }
    const potentialSettingsObj = objects[objects.length - 1] || {};
    if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
      if (potentialSettingsObj.array !== void 0)
        settings.array = potentialSettingsObj.array;
      if (potentialSettingsObj.object !== void 0)
        settings.object = potentialSettingsObj.object;
      objects.pop();
    }
    for (let i = 0; i < objects.length; i++) {
      const toMergeObj = objects[i] || {};
      merge(referenceObj, toMergeObj);
    }
    return referenceObj;
  }
  /*!
  * copy-to - index.js
  * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
  * MIT Licensed
  */
  var slice = Array.prototype.slice;
  var copyTo = Copy;
  function Copy(src, withAccess) {
    if (!(this instanceof Copy))
      return new Copy(src, withAccess);
    this.src = src;
    this._withAccess = withAccess;
  }
  Copy.prototype.withAccess = function(w) {
    this._withAccess = w !== false;
    return this;
  };
  Copy.prototype.pick = function(keys) {
    if (!Array.isArray(keys)) {
      keys = slice.call(arguments);
    }
    if (keys.length) {
      this.keys = keys;
    }
    return this;
  };
  Copy.prototype.to = function(to) {
    to = to || {};
    if (!this.src)
      return to;
    var keys = this.keys || Object.keys(this.src);
    if (!this._withAccess) {
      for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        if (to[key] !== void 0)
          continue;
        to[key] = this.src[key];
      }
      return to;
    }
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!notDefined(to, key))
        continue;
      var getter = this.src.__lookupGetter__(key);
      var setter = this.src.__lookupSetter__(key);
      if (getter)
        to.__defineGetter__(key, getter);
      if (setter)
        to.__defineSetter__(key, setter);
      if (!getter && !setter) {
        to[key] = this.src[key];
      }
    }
    return to;
  };
  Copy.prototype.toCover = function(to) {
    var keys = this.keys || Object.keys(this.src);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      delete to[key];
      var getter = this.src.__lookupGetter__(key);
      var setter = this.src.__lookupSetter__(key);
      if (getter)
        to.__defineGetter__(key, getter);
      if (setter)
        to.__defineSetter__(key, setter);
      if (!getter && !setter) {
        to[key] = this.src[key];
      }
    }
  };
  Copy.prototype.override = Copy.prototype.toCover;
  Copy.prototype.and = function(obj) {
    var src = {};
    this.to(src);
    this.src = obj;
    this.to(src);
    this.src = src;
    return this;
  };
  function notDefined(obj, key) {
    return obj[key] === void 0 && obj.__lookupGetter__(key) === void 0 && obj.__lookupSetter__(key) === void 0;
  }
  function deepMerge$2(...args) {
    const settings = {
      array: false,
      object: true
    };
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      copyTo(firstObj).override(newObj);
      for (const key of Object.keys(secondObj)) {
        if (settings.array === true && Array.isArray(firstObj[key]) && Array.isArray(secondObj[key])) {
          const newArray = unique$2([...firstObj[key], ...secondObj[key]]);
          newObj[key] = newArray;
          continue;
        } else if (settings.object === true && plainObject$2(firstObj[key]) && plainObject$2(secondObj[key])) {
          newObj[key] = merge(firstObj[key], secondObj[key]);
          continue;
        }
        copyTo(secondObj).pick(key).toCover(newObj);
      }
      return newObj;
    }
    const potentialSettingsObj = args[args.length - 1] || {};
    if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
      if (potentialSettingsObj.array !== void 0)
        settings.array = potentialSettingsObj.array;
      if (potentialSettingsObj.object !== void 0)
        settings.object = potentialSettingsObj.object;
      args.pop();
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i] || {};
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  function unquote(string, quotesToRemove = ['"', "'", "\u201D", "`"]) {
    string = string.trim();
    quotesToRemove.forEach((quote) => {
      if (string.substr(0, 1) === quote && string.substr(-1) === quote) {
        string = string.substr(1);
        string = string.substr(0, string.length - 1);
        return;
      }
    });
    return string;
  }
  function get(obj, path, settings = {}) {
    settings = Object.assign({}, settings);
    if (obj[path] !== void 0)
      return obj[path];
    if (!path || path === "" || path === ".")
      return obj;
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    let potentialPaths = [path.replace(/\?/gm, "")];
    const parts = path.split(".");
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i];
      if (part.match(/\?$/)) {
        const before = parts.slice(0, i);
        const after = parts.slice(i + 1);
        potentialPaths.push([...before, ...after].join("."));
        potentialPaths.push([...before, ...after.filter((a) => !a.match(/\?$/))].join("."));
      }
    }
    potentialPaths = unique$2(potentialPaths.map((s) => s.replace(/\?/gm, "")));
    for (let i = 0; i < potentialPaths.length; i++) {
      const path2 = potentialPaths[i];
      const result = __get(obj, path2, settings);
      if (result !== void 0)
        return result;
    }
  }
  function __get(obj, path, settings = {}) {
    settings = Object.assign({}, settings);
    if (obj[path] !== void 0)
      return obj[path];
    if (!path || path === "" || path === ".")
      return obj;
    const a = path.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p) => unquote(p));
    let o = obj;
    while (a.length) {
      const n = a.shift().replace(/\?$/, "");
      if (typeof o !== "object" || !(n in o)) {
        return;
      }
      o = o[n];
    }
    return o;
  }
  var md5$3 = {exports: {}};
  var core$3 = {exports: {}};
  var __viteBrowserExternal_crypto$2 = new Proxy({}, {
    get() {
      throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_crypto$3 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_crypto$2});
  var require$$0$6 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_crypto$3);
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal$2, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal$2 !== "undefined" && commonjsGlobal$2.crypto) {
          crypto2 = commonjsGlobal$2.crypto;
        }
        if (!crypto2 && typeof require === "function") {
          try {
            crypto2 = require$$0$6;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  })(core$3);
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(core$3.exports);
      }
    })(commonjsGlobal$2, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5$3);
  var md5$2 = md5$3.exports;
  var ansiStyles$1 = {exports: {}};
  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  const cssKeywords = colorName;
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert$3 = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  var conversions$2 = convert$3;
  for (const model of Object.keys(convert$3)) {
    if (!("channels" in convert$3[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$3[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$3[model].labels.length !== convert$3[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert$3[model];
    delete convert$3[model].channels;
    delete convert$3[model].labels;
    Object.defineProperty(convert$3[model], "channels", {value: channels});
    Object.defineProperty(convert$3[model], "labels", {value: labels});
  }
  convert$3.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert$3.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert$3.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert$3.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert$3.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return __pow(x[0] - y[0], 2) + __pow(x[1] - y[1], 2) + __pow(x[2] - y[2], 2);
  }
  convert$3.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert$3.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert$3.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? __pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? __pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? __pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert$3.rgb.lab = function(rgb) {
    const xyz = convert$3.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert$3.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert$3.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert$3.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert$3.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert$3.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert$3.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert$3.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * __pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * __pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * __pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert$3.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert$3.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = __pow(y, 3);
    const x2 = __pow(x, 3);
    const z2 = __pow(z, 3);
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert$3.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert$3.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert$3.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert$3.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert$3.hsv.ansi16 = function(args) {
    return convert$3.rgb.ansi16(convert$3.hsv.rgb(args), args[2]);
  };
  convert$3.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert$3.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert$3.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert$3.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert$3.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert$3.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert$3.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert$3.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert$3.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert$3.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert$3.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert$3.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert$3.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert$3.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert$3.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert$3.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert$3.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert$3.gray.hsv = convert$3.gray.hsl;
  convert$3.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert$3.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert$3.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert$3.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert$3.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  const conversions$1 = conversions$2;
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions$1);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions$1[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link$2(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions$1[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link$2(conversions$1[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  var route$1 = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  const conversions = conversions$2;
  const route = route$1;
  const convert$2 = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert$2[fromModel] = {};
    Object.defineProperty(convert$2[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert$2[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert$2[fromModel][toModel] = wrapRounded(fn);
      convert$2[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert$2;
  (function(module) {
    const wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    const wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    const wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    const setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    let colorConvert$1;
    const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert$1 === void 0) {
        colorConvert$1 = colorConvert;
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
        const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name2] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name2] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  })(ansiStyles$1);
  var browser = {
    stdout: false,
    stderr: false
  };
  const stringReplaceAll$1 = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var util$3 = {
    stringReplaceAll: stringReplaceAll$1,
    stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
  };
  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape$1(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name2, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape$1(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name2 = matches[1];
      if (matches[2]) {
        const args = parseArguments(name2, matches[2]);
        results.push([name2].concat(args));
      } else {
        results.push([name2]);
      }
    }
    return results;
  }
  function buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  var templates = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape$1(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
  const ansiStyles = ansiStyles$1.exports;
  const {stdout: stdoutColor, stderr: stderrColor} = browser;
  const {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = util$3;
  const {isArray: isArray$6} = Array;
  const levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  const styles = Object.create(null);
  const applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  class ChalkClass {
    constructor(options) {
      return chalkFactory(options);
    }
  }
  const chalkFactory = (options) => {
    const chalk = {};
    applyOptions(chalk, options);
    chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
    Object.setPrototypeOf(chalk, Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);
    chalk.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk.template.Instance = ChalkClass;
    return chalk.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {value: builder});
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", {value: builder});
      return builder;
    }
  };
  const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, __spreadProps(__spreadValues({}, styles), {
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  }));
  const createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  const createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray$6(arguments_[0]) && isArray$6(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto);
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  const applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === void 0) {
      return string;
    }
    const {openAll, closeAll} = styler;
    if (string.indexOf("") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  let template;
  const chalkTag = (chalk, ...strings) => {
    const [firstString] = strings;
    if (!isArray$6(firstString) || !isArray$6(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === void 0) {
      template = templates;
    }
    return template(chalk, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  const chalk = Chalk();
  chalk.supportsColor = stdoutColor;
  chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
  chalk.stderr.supportsColor = stderrColor;
  var source$2 = chalk;
  function classInstance$2(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name === "Object")
      return false;
    if (Object.prototype.toString.call(object) === "[object Object]")
      return false;
    if (object.constructor === Object)
      return false;
    return true;
  }
  function deepMap$2(objectOrArray, processor, settings = {}, _path = []) {
    settings = deepMerge$2({
      classInstances: false,
      array: true,
      privateProps: false,
      cloneFirst: true
    }, settings);
    const isArray = Array.isArray(objectOrArray);
    const newObject = isArray ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
    Object.keys(objectOrArray).forEach((prop) => {
      if (!settings.privateProps && prop.match(/^_/))
        return;
      if (plainObject$2(objectOrArray[prop]) || classInstance$2(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
        const res2 = deepMap$2(objectOrArray[prop], processor, settings, [
          ..._path,
          prop
        ]);
        if (isArray) {
          newObject.push(res2);
        } else {
          newObject[prop] = res2;
        }
        return;
      }
      const res = processor({
        object: objectOrArray,
        prop,
        value: objectOrArray[prop],
        path: [..._path, prop].join(".")
      });
      if (res === -1) {
        delete objectOrArray[prop];
        return;
      }
      if (isArray)
        newObject.push(res);
      else
        newObject[prop] = res;
    });
    return newObject;
  }
  function isMap$2(value) {
    return value instanceof Map;
  }
  function isArray$5(value) {
    return value && typeof value === "object" && value.constructor === Array;
  }
  function isBoolean$2(value) {
    return typeof value === "boolean";
  }
  function isFunction$3(value) {
    return value && {}.toString.call(value) === "[object Function]";
  }
  function isJson$2(value) {
    try {
      const res = JSON.parse(value);
      if (Object.keys(res).length)
        return true;
      return false;
    } catch (e) {
      return false;
    }
    return true;
  }
  function isObject$4(value) {
    return value && typeof value === "object" && value.constructor === Object;
  }
  function mapToObject$2(map) {
    const obj = {};
    for (const [k, v] of map)
      obj[k] = v;
    return obj;
  }
  var decycle_1;
  const isArray$4 = (e) => Array.isArray(e), isObject$3 = (e) => Object.prototype.toString.call(e).slice(8, -1) === "Object", validate$1 = (e) => {
    if (e === void 0)
      throw new Error("This method requires one parameter");
    if (!isArray$4(e) && !isObject$3(e))
      throw new TypeError("This method only accepts arrays and objects");
  }, isRef = (e) => isObject$3(e) && e.hasOwnProperty("$ref") && Object.keys(e).length === 1 && !!e.$ref && e.$ref.charAt(0) === "$", encycle = (arg) => {
    validate$1(arg);
    const recurs = (value) => isArray$4(value) || isObject$3(value) ? isArray$4(value) ? value.map((elem, i) => isRef(elem) ? (value[i] = eval("arg" + elem.$ref.slice(1)), value) : recurs(elem)) : Object.keys(value).reduce((accum, key) => (accum[key] = isRef(value[key]) ? eval("arg" + value[key].$ref.slice(1)) : recurs(value[key]), accum), value) : value;
    return recurs(arg);
  }, findRef = (e, r) => Object.keys(r).find((a) => r[a] === e), decycle = (e) => {
    validate$1(e);
    let r = {};
    const a = (e2, c = "$") => {
      const s = findRef(e2, r);
      return s ? {$ref: s} : isArray$4(e2) || isObject$3(e2) ? (r[c] = e2, isArray$4(e2) ? e2.map((e3, r2) => a(e3, `${c}[${r2}]`)) : Object.keys(e2).reduce((r2, s2) => (r2[s2] = a(e2[s2], `${c}.${s2}`), r2), {})) : e2;
    };
    return a(e);
  };
  decycle_1 = decycle, encycle;
  function fn$6(value, settings = {}) {
    settings = deepMerge$2({
      beautify: true,
      highlight: true,
      verbose: true,
      theme: {
        number: source$2.yellow,
        default: source$2.white,
        keyword: source$2.blue,
        regexp: source$2.red,
        string: source$2.whiteBright,
        class: source$2.yellow,
        function: source$2.yellow,
        comment: source$2.gray,
        variable: source$2.red,
        attr: source$2.green
      }
    }, settings);
    if (typeof value === "string")
      return value;
    if (value === null)
      return null;
    if (value === void 0)
      return void 0;
    if (value instanceof Error) {
      const errorStr = value.toString();
      const stackStr = value.stack;
      const messageStr = value.message;
      if (settings.verbose) {
        return [
          `<red>${value.constructor.name || "Error"}</red>`,
          "",
          messageStr,
          "",
          stackStr
        ].join("\n");
      }
      return errorStr;
    }
    if (isMap$2(value)) {
      value = mapToObject$2(value);
    }
    if (isObject$4(value) || isArray$5(value) || isJson$2(value)) {
      try {
        value = decycle_1(value);
      } catch (e) {
      }
      value = deepMap$2(value, ({value: value2}) => {
        if (value2 instanceof Map)
          return mapToObject$2(value2);
        return value2;
      });
      let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
      prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
      if (settings.highlight)
        ;
      return prettyString;
    }
    if (isBoolean$2(value)) {
      if (value)
        return "true";
      else
        return "false";
    }
    if (isFunction$3(value)) {
      return "" + value;
    }
    let returnString = "";
    try {
      value = decycle_1(value);
      returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    } catch (e) {
      try {
        returnString = value.toString();
      } catch (e2) {
        returnString = value;
      }
    }
    return returnString;
  }
  var __parse = (value) => {
    if (typeof value !== "string")
      return value;
    value = value.split("\u2800").join("").trim();
    try {
      return Function(`
      "use strict";
      return (${value});
    `)();
    } catch (e) {
      return value;
    }
  };
  const __encryptedMessages$2 = {};
  var __md5$2 = {
    encrypt: function(message) {
      if (typeof message !== "string")
        message = fn$6(message);
      const string = md5$2(message).toString();
      __encryptedMessages$2[string] = message;
      return string;
    },
    decrypt: function(message) {
      if (!__encryptedMessages$2[message]) {
        console.warn(`The message "${message}" cannot be decrypted...`);
        return;
      }
      const string = __encryptedMessages$2[message];
      delete __encryptedMessages$2[message];
      return __parse(string);
    }
  };
  function availableColors(settings) {
    settings = Object.assign({excludeBasics: false}, settings !== null && settings !== void 0 ? settings : {});
    const _colors = [
      "yellow",
      "cyan",
      "green",
      "magenta",
      "red",
      "blue",
      "grey",
      "gray"
    ];
    let colors = _colors;
    if (settings.excludeBasics) {
      colors = _colors.filter((c) => {
        return c !== "white" && c !== "black" && c !== "grey" && c !== "gray";
      });
    }
    return colors;
  }
  function pickRandom(array) {
    return array[Math.round(Math.random() * (array.length - 1))];
  }
  const _colorUsedByScope = {};
  const _colorsStack = {};
  function getColorFor(ref, settings) {
    settings = deepMerge$2({
      scope: "default",
      excludeBasics: true
    }, settings !== null && settings !== void 0 ? settings : {});
    const availableColors$1 = availableColors(settings);
    const scopeId = __md5$2.encrypt(settings.scope);
    const refId = __md5$2.encrypt(ref);
    if (_colorsStack[`${scopeId}.${refId}`])
      return _colorsStack[`${scopeId}.${refId}`];
    if (!_colorUsedByScope[scopeId])
      _colorUsedByScope[scopeId] = [];
    if (_colorUsedByScope[scopeId].length >= availableColors$1.length) {
      const color = pickRandom(availableColors$1);
      _colorsStack[`${scopeId}.${refId}`] = color;
      return color;
    } else {
      for (let i = 0; i < availableColors$1.length; i++) {
        if (_colorUsedByScope[scopeId].indexOf(availableColors$1[i]) === -1) {
          _colorUsedByScope[scopeId].push(availableColors$1[i]);
          _colorsStack[`${scopeId}.${refId}`] = availableColors$1[i];
          return availableColors$1[i];
        }
      }
    }
  }
  var __set = (obj, path, value, settings = {}) => {
    settings = Object.assign({}, settings);
    if (!path || path === "" || path === ".") {
      obj = value;
      return;
    }
    path = path.replace(/\[(\w+)\]/g, ".[$1]");
    const a = unquote(path).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p) => unquote(p));
    let o = obj;
    while (a.length - 1) {
      const n = a.shift();
      if (!(n in o)) {
        if (a[0].match(/^\[[0-9]+\]$/))
          o[n] = [];
        else
          o[n] = {};
      }
      o = o[n];
    }
    if (a[0].match(/^\[[0-9]+\]$/)) {
      if (!Array.isArray(o))
        o = [];
      o.push(value);
    } else {
      o[a[0]] = value;
    }
    return get(obj, path);
  };
  function toJson(object) {
    const newObj = {};
    deepMap$2(object, ({value, path}) => {
      __set(newObj, path, value);
      return value;
    }, {
      privateProps: false,
      classInstances: true
    });
    return newObj;
  }
  class SClass {
    constructor(settings = {}) {
      this._settings = {};
      this._interfacesStack = {};
      generateInterfacesStack(this);
      setSettings(this, settings);
      applyInterfaces(this);
      this.metas = getMetas(this);
      Object.defineProperty(this, "metas", {
        enumerable: true,
        value: getMetas(this)
      });
    }
    get formattedName() {
      var _a, _b, _c;
      let name2 = `<yellow>${((_a = this.metas) === null || _a === void 0 ? void 0 : _a.name) || ""}</yellow>`;
      if ((_b = this.metas) === null || _b === void 0 ? void 0 : _b.id) {
        name2 += ` <cyan>${(_c = this.metas) === null || _c === void 0 ? void 0 : _c.id}</cyan>`;
      }
      return name2;
    }
    static extends(Cls) {
      class SClass extends Cls {
        constructor(settings, ...args) {
          super(...args);
          this._settings = {};
          this._interfacesStack = {};
          generateInterfacesStack(this);
          setSettings(this, settings);
          applyInterfaces(this);
          this.metas = getMetas(this);
          Object.defineProperty(this, "metas", {
            enumerable: true,
            value: getMetas(this)
          });
        }
        get formattedName() {
          let name2 = `<yellow>${this.name || ""}</yellow>`;
          if (this.id) {
            name2 += ` <cyan>${this.id}</cyan>`;
          }
          return name2;
        }
        expose(instance, settings) {
          return expose(this, instance, settings);
        }
        applyInterface(name2, on) {
          return applyInterface(this, name2, on);
        }
        getInterface(name2) {
          return getInterface(this, name2);
        }
        toPlainObject() {
          return toPlainObject(this);
        }
      }
      return SClass;
    }
    expose(instance, settings) {
      return expose(this, instance, settings);
    }
    applyInterface(name2, on) {
      return applyInterface(this, name2, on);
    }
    getInterface(name2) {
      return getInterface(this, name2);
    }
    toPlainObject() {
      return toPlainObject(this);
    }
  }
  function getMetas(ctx) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let name2 = `<yellow>${((_a = ctx._settings.metas) === null || _a === void 0 ? void 0 : _a.name) || ""}</yellow>`;
    if ((_b = ctx._settings.metas) === null || _b === void 0 ? void 0 : _b.id) {
      name2 += ` <cyan>${ctx._settings.metas.id}</cyan>`;
    }
    const metasObj = {
      id: (_d = (_c = ctx._settings.metas) === null || _c === void 0 ? void 0 : _c.id) !== null && _d !== void 0 ? _d : ctx.constructor.name,
      name: (_f = (_e = ctx._settings.metas) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : ctx.constructor.name,
      formattedName: name2,
      color: (_h = (_g = ctx._settings.metas) === null || _g === void 0 ? void 0 : _g.color) !== null && _h !== void 0 ? _h : "yellow"
    };
    return metasObj;
  }
  function generateInterfacesStack(ctx) {
    const extendsStack = fn$7(ctx, {
      includeBaseClass: true
    });
    Object.keys(extendsStack).forEach((className) => {
      const cls = extendsStack[className];
      if (cls.interfaces) {
        ctx._interfacesStack[className] = cls.interfaces;
      }
    });
  }
  function expose(ctx, instance, settings) {
    settings = deepMerge$2({
      as: void 0,
      props: []
    }, settings);
    if (settings.as && typeof settings.as === "string") {
      ctx[settings.as] = instance;
    }
    if (settings.props) {
      settings.props.forEach((prop) => {
        if (instance[prop].bind && typeof instance[prop].bind === "function") {
          ctx[prop] = instance[prop].bind(instance);
        } else {
          ctx[prop] = instance[prop];
        }
      });
    }
  }
  function getInterfaceObj(ctx, name2) {
    let interfaceObj = get(ctx._interfacesStack, name2);
    if (!interfaceObj) {
      const keys = Object.keys(ctx._interfacesStack);
      for (let i = 0; i < keys.length; i++) {
        const interfacesObj = ctx._interfacesStack[keys[i]];
        if (interfacesObj[name2] !== void 0) {
          if (plainObject$2(interfacesObj[name2])) {
            interfaceObj = interfacesObj[name2];
          } else {
            interfaceObj = {
              apply: true,
              on: name2 === "settings" ? "_settings" : name2 === "this" ? ctx : void 0,
              class: interfacesObj[name2]
            };
          }
          break;
        }
      }
    }
    if (name2 === "settings" && interfaceObj.on === void 0) {
      if (ctx.settings !== void 0)
        interfaceObj.on = "settings";
      else if (ctx._settings !== void 0)
        interfaceObj.on = "_settings";
    }
    return interfaceObj;
  }
  function toPlainObject(ctx) {
    return toJson(ctx);
  }
  function getInterface(ctx, name2) {
    const interfaceObj = getInterfaceObj(ctx, name2);
    if (plainObject$2(interfaceObj))
      return interfaceObj.class;
    return interfaceObj;
  }
  function applyInterfaces(ctx) {
    const keys = Object.keys(ctx._interfacesStack);
    for (let i = keys.length - 1; i >= 0; i--) {
      const interfacesObj = ctx._interfacesStack[keys[i]];
      const className = keys[i];
      Object.keys(interfacesObj).forEach((name2) => {
        const interfaceObj = interfacesObj[name2];
        let settings;
        if (plainObject$2(interfaceObj)) {
          settings = Object.assign({}, Object.assign({apply: true, on: name2 === "settings" ? "_settings" : name2 === "this" ? ctx : void 0}, interfaceObj));
        } else {
          settings = Object.assign({}, {
            apply: true,
            on: name2 === "settings" ? "_settings" : name2 === "this" ? ctx : void 0,
            class: interfaceObj
          });
        }
        if (settings.apply !== true)
          return;
        if (settings.on) {
          if (typeof settings.on === "string" && get(ctx, settings.on) !== void 0) {
            applyInterface(ctx, `${className}.${name2}`, settings.on);
          } else if (typeof settings.on === "object") {
            applyInterface(ctx, `${className}.${name2}`, settings.on);
          } else if (ctx[name2] !== void 0) {
            applyInterface(ctx, `${className}.${name2}`);
          }
        }
      });
    }
  }
  function applyInterface(ctx, name2, on = null) {
    const interfaceObj = getInterfaceObj(ctx, `${name2}`);
    if (!interfaceObj) {
      throw new Error(`You try to apply the interface named "<yellow>${name2}</yellow>" on the context "<cyan>${ctx.name}</cyan>" but it does not exists...`);
    }
    if (on !== void 0)
      interfaceObj.on = on;
    if (!interfaceObj) {
      throw `Sorry the the asked interface "<yellow>${name2}</yellow>" does not exists on the class "<cyan>${ctx.constructor.name}</cyan>"`;
    }
    if (name2.includes(".")) {
      name2 = name2.split(".").slice(1).join(".");
    }
    if (plainObject$2(interfaceObj)) {
      let onValue;
      if (interfaceObj.on && typeof interfaceObj.on === "string") {
        onValue = get(ctx, interfaceObj.on);
      } else if (interfaceObj.on && typeof interfaceObj.on === "object") {
        onValue = interfaceObj.on;
      } else {
        onValue = get(ctx, name2);
      }
      let applyId = ctx.constructor.name;
      if (ctx.id)
        applyId += `(${ctx.id})`;
      if (name2)
        applyId += `.${name2}`;
      if (interfaceObj.on && interfaceObj.on.constructor)
        applyId += `.${interfaceObj.on.constructor.name}`;
      if (interfaceObj.on && interfaceObj.on.id)
        applyId += `(${interfaceObj.on.id})`;
      let res;
      if (name2 === "this") {
        res = interfaceObj.class.apply(onValue || {}, {
          id: applyId,
          complete: true,
          throw: true
        });
        deepAssign(ctx, res.value);
        return ctx;
      } else {
        res = interfaceObj.class.apply(onValue, {
          id: applyId,
          complete: true,
          throw: true
        });
        if (interfaceObj.on && typeof interfaceObj.on === "object") {
          const returnValue = deepAssign(interfaceObj.on, res);
          return returnValue;
        } else if (interfaceObj.on && typeof interfaceObj.on === "string") {
          return deepAssign(get(ctx, interfaceObj.on), res);
        } else if (ctx[name2] !== void 0) {
          return ctx[name2];
        } else {
          return res;
        }
      }
    }
  }
  function setSettings(ctx, settings = {}) {
    var _a;
    ctx._settings = settings;
    if (!ctx._settings.metas)
      ctx._settings.metas = {};
    if (!((_a = ctx._settings.metas) === null || _a === void 0 ? void 0 : _a.id))
      ctx._settings.metas.id = ctx.constructor.name;
    if (!ctx.constructor.name.match(/^SConfig/)) {
      if (!ctx._settings.metas.color)
        ctx._settings.metas.color = getColorFor(ctx.constructor.name, {
          scope: "class"
        });
    } else if (!ctx._settings.metas.color)
      ctx._settings.metas.color = "yellow";
  }
  var __viteBrowserExternal_path$2 = new Proxy({}, {
    get() {
      throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_path$3 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_path$2});
  var require$$3$1 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_path$3);
  var concatMap$1 = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray$3(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray$3 = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  var balancedMatch = balanced$1;
  function balanced$1(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced$1.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  var concatMap = concatMap$1;
  var balanced = balancedMatch;
  var braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand$1(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand$1(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand$1(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand$1(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand$1(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand$1(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand$1(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  var minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path$h = {sep: "/"};
  try {
    path$h = require$$3$1;
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = braceExpansion;
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter$1;
  function filter$1(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m = function minimatch(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path$h.sep !== "/") {
      pattern = pattern.split(path$h.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse$3;
  var SUBPARSE = {};
  function parse$3(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path$h.sep !== "/") {
      f = f.split(path$h.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {"this": this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify$4(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return stringify$4(rnds);
  }
  function uniqid$6() {
    return v4();
  }
  var ansiRegex$1 = ({onlyFirst = false} = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
  const ansiRegex = ansiRegex$1;
  var stripAnsi$1 = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  function stripAnsi(string) {
    return stripAnsi$1(string);
  }
  function isTestEnv() {
    var _a;
    return ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) === "test";
  }
  function isChildProcess() {
    if (isTestEnv())
      return false;
    return process.send !== void 0 || {}.IS_CHILD_PROCESS !== void 0;
  }
  var __awaiter$a = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SEventEmitter extends SClass {
    constructor(settings = {}) {
      super(deepMerge$2({
        eventEmitter: {
          emitter: void 0,
          asyncStart: false,
          defaultCallTime: {},
          bufferTimeout: 1e3,
          bufferedEvents: [],
          forceObject: ["log", "warn", "error"],
          defaults: {},
          bind: void 0
        }
      }, settings || {}));
      this._asyncStarted = false;
      this._buffer = [];
      this._eventsStacks = {};
      this._onStackById = {};
    }
    static pipe(sourceSEventEmitter, destSEventEmitter, settings) {
      const set = Object.assign({events: "*", prefixEvent: false, prefixValue: void 0, stripAnsi: false, trim: true, keepLineBreak: true, overrideEmitter: "bind", processor: void 0, exclude: ["finally", "resolve", "reject", "cancel", "catch"], filter: void 0}, settings !== null && settings !== void 0 ? settings : {});
      if (!sourceSEventEmitter || !sourceSEventEmitter.on || typeof sourceSEventEmitter.on !== "function")
        return sourceSEventEmitter;
      sourceSEventEmitter.on(set.events || "*", (value, metas) => __awaiter$a(this, void 0, void 0, function* () {
        if (metas.event.match(/^answer\..*/)) {
          return;
        }
        if (set.exclude && set.exclude.indexOf(metas.event) !== -1)
          return;
        if (set.filter && !set.filter(value, metas))
          return;
        if (set.stripAnsi) {
          if (value && value.value && typeof value.value === "string")
            value.value = stripAnsi(value.value);
          else if (typeof value === "string")
            value = stripAnsi(value);
        }
        if (set.trim) {
          if (value && value.value && typeof value.value === "string")
            value.value = value.value.trim();
          else if (typeof value === "string")
            value = value.trim();
        }
        if (set.keepLineBreak === false) {
          if (value && value.value && typeof value.value === "string")
            value.value = value.value.replace(/\r?\n|\r/g, "");
          else if (typeof value === "string")
            value = value.replace(/\r?\n|\r/g, "");
        }
        if (set.processor) {
          const res = set.processor(value, metas);
          if (Array.isArray(res) && res.length === 2) {
            value = res[0];
            metas = res[1];
          } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
            value = res.value;
            metas = res.metas;
          } else {
            value = res;
          }
        }
        if (set.prefixValue) {
          if (value && value.value && typeof value.value === "string") {
            value.value = `${set.prefixValue}${value.value}`;
          } else if (typeof value === "string") {
            value = `${set.prefixValue}${value}`;
          }
        }
        if (metas && metas.event) {
          let emitStack = metas.event;
          if (!metas.emitter) {
            metas.emitter = this;
          }
          if (set.prefixEvent) {
            if (typeof set.prefixEvent === "string") {
              emitStack = `${set.prefixEvent}.${metas.event}`;
            } else {
              emitStack = `${metas.name}`;
            }
            metas.event = emitStack;
          }
          if (metas.askId) {
            destSEventEmitter.on(`${metas.event}:1`, (value2, onMetas) => {
              sourceSEventEmitter.emit(`answer.${metas.askId}`, value2);
            });
          }
          const emitMetas = Object.assign(Object.assign({}, metas), {level: metas && metas.level ? metas.level + 1 : 1});
          if (destSEventEmitter instanceof SEventEmitter) {
            if (set.overrideEmitter === "bind" && destSEventEmitter.eventEmitterSettings.bind) {
              emitMetas.emitter = destSEventEmitter.eventEmitterSettings.bind;
            } else if (set.overrideEmitter === true) {
              emitMetas.emitter = destSEventEmitter;
            }
          }
          if (destSEventEmitter === process && isChildProcess() && process.send) {
            if (value.value && value.value instanceof Error) {
              value.value = fn$6(value.value);
            }
            process.send({
              value,
              metas: emitMetas
            });
          } else {
            destSEventEmitter.emit(metas.event, value, emitMetas);
          }
        }
      }));
    }
    get eventEmitterSettings() {
      return this._settings.eventEmitter;
    }
    pipe(input, settings) {
      SEventEmitter.pipe(input, this, settings);
      return input;
    }
    pipeFrom(input, settings) {
      return this.pipe(input, settings);
    }
    pipeTo(dest, settings) {
      SEventEmitter.pipe(this, dest, settings);
      return this;
    }
    start() {
      if (!this.eventEmitterSettings.asyncStart)
        return;
      this._asyncStarted = true;
      this._processBuffer();
    }
    emit(event2, value, metas) {
      return new Promise((resolve, reject) => __awaiter$a(this, void 0, void 0, function* () {
        const finalMetas = Object.assign({}, metas || {});
        const isFirstLevel = !finalMetas.level;
        if ((this.eventEmitterSettings.forceObject === true || Array.isArray(this.eventEmitterSettings.forceObject) && this.eventEmitterSettings.forceObject.indexOf(event2) !== -1) && !plainObject$2(value)) {
          value = {
            value
          };
        }
        if (plainObject$2(value)) {
          Object.keys(this.eventEmitterSettings.defaults).forEach((key) => {
            var _a;
            const parts = key.split(",").map((l) => l.trim());
            if (parts.indexOf(event2) === -1 && parts.indexOf("*") === -1)
              return;
            value = deepMerge$2(value, (_a = this.eventEmitterSettings.defaults) === null || _a === void 0 ? void 0 : _a[key]);
          });
        }
        if (!finalMetas.askId && isFirstLevel) {
          if (value && value.ask === true || event2 === "ask") {
            finalMetas.askId = uniqid$6();
            finalMetas.ask = true;
          }
        }
        if (isFirstLevel && finalMetas.askId) {
          this.on(`answer.${finalMetas.askId}:1`, (value2) => {
            resolve(value2);
          });
          this._emitEvents(event2, value, finalMetas);
        } else {
          const res = yield this._emitEvents(event2, value, finalMetas);
          return resolve(res);
        }
      }));
    }
    _registerNewEventsStacks(events) {
      if (typeof events === "string")
        events = events.split(",").map((s) => s.trim());
      events.forEach((event2) => {
        if (!this._eventsStacks[event2]) {
          this._eventsStacks[event2] = {
            buffer: [],
            callStack: []
          };
        }
      });
    }
    _registerCallbackInEventStack(event2, callback, settings = {}) {
      settings = Object.assign({callNumber: void 0, filter: void 0, processor: void 0, id: void 0}, settings);
      if (settings.id) {
        if (!this._onStackById[settings.id])
          this._onStackById[settings.id] = [];
        this._onStackById[settings.id].push({
          event: event2,
          callback,
          settings
        });
      }
      if (!this._eventsStacks[event2]) {
        this._registerNewEventsStacks(event2);
      }
      const eventStackObj = this._eventsStacks[event2];
      let callNumber = settings.callNumber;
      if (callNumber === void 0 && this.eventEmitterSettings.defaultCallTime[event2] !== void 0) {
        callNumber = this.eventEmitterSettings.defaultCallTime[event2];
      } else if (callNumber === void 0) {
        callNumber = -1;
      }
      if (typeof callback === "function")
        eventStackObj.callStack.push({
          callback,
          callNumber,
          filter: settings.filter,
          processor: settings.processor,
          called: 0
        });
      this._processBuffer();
      return this;
    }
    _processBuffer() {
      if (this._buffer.length > 0) {
        setTimeout(() => {
          this._buffer = this._buffer.filter((item) => {
            this.emit(item.event, item.value);
            return false;
          });
        }, this.eventEmitterSettings.bufferTimeout);
      }
    }
    _emitEventStack(event2, initialValue, metas) {
      var _a, _b, _c;
      return __awaiter$a(this, void 0, void 0, function* () {
        let currentCallbackReturnedValue = initialValue;
        if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
          return currentCallbackReturnedValue;
        if (!this._asyncStarted && this.eventEmitterSettings.asyncStart) {
          this._buffer.push({
            event: event2,
            value: initialValue
          });
          return initialValue;
        }
        if (!this._eventsStacks[event2]) {
          this._registerNewEventsStacks(event2);
        }
        let eventStackArray = [];
        const eventStackObj = this._eventsStacks[event2];
        if (eventStackObj && eventStackObj.callStack) {
          eventStackArray = [...eventStackArray, ...eventStackObj.callStack];
        }
        Object.keys(this._eventsStacks).forEach((stackName) => {
          if (stackName === event2)
            return;
          if (minimatch_1(event2, stackName) && this._eventsStacks[stackName] !== void 0) {
            eventStackArray = [
              ...eventStackArray,
              ...this._eventsStacks[stackName].callStack
            ];
          }
        });
        if (eventStackArray.length === 0) {
          for (let i = 0; i < this.eventEmitterSettings.bufferedEvents.length; i++) {
            const bufferedStack = this.eventEmitterSettings.bufferedEvents[i];
            if (bufferedStack && minimatch_1(event2, bufferedStack)) {
              this._buffer.push({
                event: event2,
                value: initialValue
              });
            }
          }
          return initialValue;
        }
        eventStackArray.map((item) => item.called++);
        eventStackArray = eventStackArray.filter((item) => {
          if (item.callNumber === -1)
            return true;
          if (item.called <= item.callNumber)
            return true;
          return false;
        });
        let metasObj = deepMerge$2({
          event: event2,
          name: event2,
          emitter: (_b = (_a = this.eventEmitterSettings.bind) !== null && _a !== void 0 ? _a : metas === null || metas === void 0 ? void 0 : metas.emitter) !== null && _b !== void 0 ? _b : this,
          originalEmitter: (_c = metas === null || metas === void 0 ? void 0 : metas.originalEmitter) !== null && _c !== void 0 ? _c : this,
          time: Date.now(),
          level: 1,
          id: uniqid$6()
        }, metas);
        for (let i = 0; i < eventStackArray.length; i++) {
          const item = eventStackArray[i];
          if (!item.callback)
            return currentCallbackReturnedValue;
          if (item.filter && !item.filter(currentCallbackReturnedValue, metasObj))
            continue;
          if (item.processor) {
            const res = item.processor(currentCallbackReturnedValue, metasObj);
            if (Array.isArray(res) && res.length === 2) {
              currentCallbackReturnedValue = res[0];
              metasObj = res[1];
            } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
              currentCallbackReturnedValue = res.value;
              metasObj = res.metas;
            } else {
              currentCallbackReturnedValue = res;
            }
          }
          const callbackResult = yield item.callback(currentCallbackReturnedValue, metasObj);
          if (callbackResult !== void 0) {
            currentCallbackReturnedValue = callbackResult;
          }
        }
        if (!eventStackArray.length && metasObj.askId) {
          this.emit(`answer.${metasObj.askId}`, currentCallbackReturnedValue);
        }
        return currentCallbackReturnedValue;
      });
    }
    _emitEvents(events, initialValue, metas) {
      return new Promise((resolve, reject) => __awaiter$a(this, void 0, void 0, function* () {
        if (!events)
          return this;
        if (typeof events === "string")
          events = events.split(",").map((s) => s.trim());
        let currentStackResult = initialValue;
        for (let i = 0; i < events.length; i++) {
          const stackResult = yield this._emitEventStack(events[i], currentStackResult, metas);
          if (stackResult !== void 0) {
            currentStackResult = stackResult;
          }
        }
        resolve(currentStackResult);
      }));
    }
    on(events, callback, settings) {
      const set = deepMerge$2({
        filter: void 0,
        processor: void 0,
        id: void 0
      }, settings);
      if (typeof events === "string")
        events = events.split(",").map((s) => s.trim());
      events.forEach((name2) => {
        const splitedName = name2.split(":");
        let callNumber = -1;
        if (splitedName.length === 2) {
          name2 = splitedName[0];
          callNumber = parseInt(splitedName[1]);
        }
        this._registerCallbackInEventStack(name2, callback, {
          callNumber,
          filter: set.filter,
          processor: set.processor,
          id: set.id
        });
      });
      return this;
    }
    off(event2, callback) {
      if (!callback) {
        if (this._eventsStacks[event2]) {
          delete this._eventsStacks[event2];
        } else if (this._onStackById[event2]) {
          this._onStackById[event2].forEach((onStackByIdObj) => {
            this.off(onStackByIdObj.event, onStackByIdObj.callback);
          });
          delete this._onStackById[event2];
        }
        return this;
      }
      const eventStackObj = this._eventsStacks[event2];
      if (!eventStackObj)
        return this;
      eventStackObj.callStack = eventStackObj.callStack.filter((item) => {
        if (item.callback === callback)
          return false;
        return true;
      });
      this._eventsStacks[event2] = eventStackObj;
      return this;
    }
    destroy() {
      this._eventsStacks = {};
    }
  }
  SEventEmitter.usableAsMixin = true;
  function plainObject$1(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function unique$1(array) {
    const a = array.concat();
    for (let i = 0; i < a.length; ++i) {
      for (let j = i + 1; j < a.length; ++j) {
        if (a[i] === a[j])
          a.splice(j--, 1);
      }
    }
    return a;
  }
  function deepMerge$1(...args) {
    const settings = {
      array: false,
      object: true
    };
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      copyTo(firstObj).override(newObj);
      for (const key of Object.keys(secondObj)) {
        if (settings.array === true && Array.isArray(firstObj[key]) && Array.isArray(secondObj[key])) {
          const newArray = unique$1([...firstObj[key], ...secondObj[key]]);
          newObj[key] = newArray;
          continue;
        } else if (settings.object === true && plainObject$1(firstObj[key]) && plainObject$1(secondObj[key])) {
          newObj[key] = merge(firstObj[key], secondObj[key]);
          continue;
        }
        copyTo(secondObj).pick(key).toCover(newObj);
      }
      return newObj;
    }
    const potentialSettingsObj = args[args.length - 1] || {};
    if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
      if (potentialSettingsObj.array !== void 0)
        settings.array = potentialSettingsObj.array;
      if (potentialSettingsObj.object !== void 0)
        settings.object = potentialSettingsObj.object;
      args.pop();
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i] || {};
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  function wait$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, timeout);
    });
  }
  const fn$5 = function treatAsValue(promise, settings = {}) {
    settings = Object.assign({during: -1}, settings);
    let during = settings.during || -1;
    try {
      const proxy = Proxy.revocable(promise, {
        get(target, prop, receiver) {
          if (prop === "then") {
            return target;
          }
          if (during > 0)
            during--;
          else if (during === 0) {
            proxy.revoke();
          }
          return Reflect.get(...arguments);
        }
      });
      proxy.proxy.restorePromiseBehavior = () => {
        proxy.revoke();
        return promise;
      };
      return proxy.proxy;
    } catch (e) {
      return promise;
    }
  };
  var __awaiter$9 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SPromise extends SClass.extends(Promise) {
    constructor(executorFnOrSettings = {}, settings) {
      let executorFn, resolvers = {};
      super(deepMerge$1({
        promise: {
          treatCancelAs: "resolve",
          destroyTimeout: 1,
          preventRejectOnThrow: true,
          emitErrorEventOnThrow: true,
          proxies: {
            resolve: [],
            reject: []
          }
        }
      }, typeof executorFnOrSettings === "object" ? executorFnOrSettings : {}, settings !== null && settings !== void 0 ? settings : {}), (resolve, reject) => {
        resolvers.resolve = resolve;
        new Promise((rejectPromiseResolve, rejectPromiseReject) => {
          resolvers.reject = (...args) => {
            rejectPromiseReject(...args);
            if (this.promiseSettings.preventRejectOnThrow) {
              resolve(...args);
            } else {
              reject(...args);
            }
          };
        }).catch((e) => {
          this.emit("catch", e);
        });
      });
      this._promiseState = "pending";
      this._eventEmitter = new SEventEmitter(deepMerge$1({
        metas: this.metas,
        eventEmitter: {}
      }, this._settings));
      this.expose(this._eventEmitter, {
        as: "eventEmitter",
        props: ["on", "off", "emit", "pipe", "pipeFrom", "pipeTo", "eventEmitterSettings"]
      });
      this._resolvers = resolvers;
      if (this._settings.promise.destroyTimeout !== -1) {
        this.on("finally", (v, m) => {
          setTimeout(() => {
            this.destroy();
          }, this._settings.promise.destroyTimeout);
        });
      }
      executorFn = typeof executorFnOrSettings === "function" ? executorFnOrSettings : null;
      if (executorFn) {
        const api = {};
        getMethods(this).forEach((func) => {
          if (func.slice(0, 1) === "_")
            return;
          api[func] = this[func].bind(this);
        });
        (() => __awaiter$9(this, void 0, void 0, function* () {
          yield wait$1(0);
          try {
            yield executorFn(api);
          } catch (e) {
            if (this.promiseSettings.emitErrorEventOnThrow) {
              this.emit("error", e);
            }
            this.reject(e);
          }
        }))();
      }
    }
    static treatAsValue(promise, settings = {}) {
      return fn$5(promise, settings);
    }
    get promiseSettings() {
      return this._settings.promise;
    }
    static get [Symbol.species]() {
      return Promise;
    }
    get [Symbol.toStringTag]() {
      return "SPromise";
    }
    get promiseState() {
      return this._promiseState;
    }
    treatAsValue(settings = {}) {
      return fn$5(this, settings);
    }
    registerProxy(point, proxy) {
      const ar = point.split(",").map((l) => l.trim());
      ar.forEach((a) => {
        this._settings.promise.proxies[a].push(proxy);
      });
    }
    is(status) {
      const statusArray = status.split(",").map((l) => l.trim());
      if (statusArray.indexOf(this._promiseState) !== -1)
        return true;
      return false;
    }
    isPending() {
      return this._promiseState === "pending";
    }
    isResolved() {
      return this._promiseState === "resolved";
    }
    isRejected() {
      return this._promiseState === "rejected";
    }
    isCanceled() {
      return this._promiseState === "canceled";
    }
    isDestroyed() {
      return this._promiseState === "destroyed";
    }
    resolve(arg, stacksOrder = "resolve,finally") {
      return this._resolve(arg, stacksOrder);
    }
    _resolve(arg, stacksOrder = "resolve,finally") {
      return __awaiter$9(this, void 0, void 0, function* () {
        if (this._promiseState === "destroyed")
          return;
        this._promiseState = "resolved";
        let stacksResult = yield this.eventEmitter._emitEvents(stacksOrder, arg);
        for (const proxyFn of this._settings.promise.proxies.resolve || []) {
          stacksResult = yield proxyFn(stacksResult);
        }
        this._resolvers.resolve(stacksResult);
        return stacksResult;
      });
    }
    reject(arg, stacksOrder = `catch,reject,finally`) {
      return this._reject(arg, stacksOrder);
    }
    _reject(arg, stacksOrder = `catch,reject,finally`) {
      return __awaiter$9(this, void 0, void 0, function* () {
        if (this._promiseState === "destroyed")
          return;
        this._promiseState = "rejected";
        let stacksResult = yield this.eventEmitter._emitEvents(stacksOrder, arg);
        for (const proxyFn of this._settings.promise.proxies.reject || []) {
          stacksResult = yield proxyFn(stacksResult);
        }
        this._resolvers.reject(stacksResult);
        return stacksResult;
      });
    }
    cancel(arg, stacksOrder = "cancel,finally") {
      return this._cancel(arg, stacksOrder);
    }
    _cancel(arg, stacksOrder = "cancel,finally") {
      if (this._promiseState === "destroyed")
        return;
      return new Promise((resolve, reject) => __awaiter$9(this, void 0, void 0, function* () {
        this._promiseState = "canceled";
        const stacksResult = yield this.eventEmitter._emitEvents(stacksOrder, arg);
        if (this._settings.promise.treatCancelAs === "reject") {
          this._resolvers.reject(stacksResult);
        } else {
          this._resolvers.resolve(stacksResult);
        }
        resolve(stacksResult);
      }));
    }
    catch(...args) {
      super.catch(...args);
      return this.on("catch", ...args);
    }
    finally(...args) {
      return this.on("finally", ...args);
    }
    destroy() {
      this._eventEmitter.destroy();
      this._promiseState = "destroyed";
    }
  }
  function isInteger(data) {
    return typeof data === "number" && !isNaN(data) && function(x) {
      return (x | 0) === x;
    }(parseFloat(data));
  }
  function upperFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  function typeOf(value, settings = {}) {
    settings = deepMerge$2({
      of: false,
      customClass: true
    }, settings);
    let type;
    if (Array.isArray(value))
      type = "Array";
    else if (value instanceof Map)
      type = "Map";
    else if (value === null)
      type = "Null";
    else if (value === void 0)
      type = "Undefined";
    else if (typeof value === "string")
      type = "String";
    else if (isInteger(value))
      type = "Integer";
    else if (typeof value === "number")
      type = "Number";
    else if (typeof value === "boolean")
      type = "Boolean";
    else if (value instanceof RegExp)
      type = "RegExp";
    else if (settings.customClass === true && cls$1(value) && value.name !== void 0) {
      type = upperFirst(value.name);
    } else if (settings.customClass === true && value.constructor !== void 0 && value.constructor.name !== void 0) {
      type = upperFirst(value.constructor.name);
    } else if (settings.customClass === false && cls$1(value)) {
      type = "Class";
    } else if (typeof value === "function")
      type = "Function";
    else if (typeof value === "object")
      type = "Object";
    else
      type = "Unknown";
    const avoidTypes = [
      "Null",
      "Undefined",
      "String",
      "Integer",
      "Number",
      "Boolean",
      "Unknown"
    ];
    if (settings.of === true && !avoidTypes.includes(type)) {
      const loopOn = Array.isArray(value) ? [...value.keys()] : Object.keys(value);
      const receivedTypes = [];
      loopOn.forEach((valueIndex) => {
        const valueToCheck = value[valueIndex];
        const childType = typeOf(valueToCheck, {
          of: false,
          customClass: settings.customClass
        });
        if (!receivedTypes.includes(childType)) {
          receivedTypes.push(childType);
        }
      });
      type += `<${receivedTypes.join("|")}>`;
    }
    return type;
  }
  const fn$4 = function(stack, callback, settings = {}) {
    settings = Object.assign({newStack: false}, settings);
    const stackType = typeOf(stack).toLowerCase();
    let loopOnKeys;
    if (stackType === "object")
      loopOnKeys = Object.keys(stack);
    else if (stackType === "array")
      loopOnKeys = Array.from(Array(stack.length).keys());
    else if (stackType === "number" || stackType === "integer")
      loopOnKeys = Array.from(Array(Math.round(stack)).keys());
    else if (stackType === "string")
      loopOnKeys = Array.from(stack);
    else if (stackType === "set")
      loopOnKeys = Array.from(stack);
    else
      loopOnKeys = Array.from(stack.keys());
    if (stackType === "string" || stackType === "number" || stackType === "integer" || stackType === "set")
      settings.newStack = true;
    let newStack = [];
    if (stackType === "object")
      newStack = {};
    else if (stackType === "map")
      newStack = new Map();
    else if (stackType === "set")
      newStack = new Set();
    let value;
    let newValue;
    const _get = (s, k) => {
      switch (typeOf(s).toLowerCase()) {
        case "array":
        case "object":
          return s[k];
        case "string":
          return k;
        case "number":
        case "integer":
          return k;
        case "map":
          return s.get(k);
        case "set":
          return k;
      }
    };
    const _set = (s, k, v) => {
      switch (typeOf(s).toLowerCase()) {
        case "array":
          if (settings.newStack === true)
            s.push(v);
          else
            s[k] = v;
          break;
        case "object":
          s[k] = v;
          break;
        case "number":
        case "integer":
        case "string":
          s.push(v);
          break;
        case "map":
          s.set(k, v);
          break;
        case "set":
          s.add(v);
          break;
      }
    };
    for (let i = 0; i < loopOnKeys.length; i++) {
      const key = loopOnKeys[i];
      value = _get(stack, key);
      newValue = callback({key, prop: key, value, i, idx: i});
      if (newValue === -1)
        break;
      _set(settings.newStack ? newStack : stack, key, newValue);
    }
    if (stackType === "string") {
      return newStack.join("");
    }
    return settings.newStack ? newStack : stack;
  };
  source$2.level = 3;
  const tagsMap = {
    black: (tag, content) => source$2.black(content),
    red: (tag, content) => source$2.red(content),
    green: (tag, content) => source$2.green(content),
    yellow: (tag, content) => source$2.yellow(content),
    blue: (tag, content) => source$2.blue(content),
    magenta: (tag, content) => source$2.magenta(content),
    cyan: (tag, content) => source$2.cyan(content),
    white: (tag, content) => source$2.white(content),
    grey: (tag, content) => source$2.grey(content),
    bgBlack: (tag, content) => source$2.bgBlack(content),
    bgRed: (tag, content) => source$2.bgRed(content),
    bgGreen: (tag, content) => source$2.bgGreen(content),
    bgYellow: (tag, content) => source$2.bgYellow(content),
    bgBlue: (tag, content) => source$2.bgBlue(content),
    bgMagenta: (tag, content) => source$2.bgMagenta(content),
    bgCyan: (tag, content) => source$2.bgCyan(content),
    bgWhite: (tag, content) => source$2.bgWhite(content),
    bold: (tag, content) => source$2.bold(content),
    dim: (tag, content) => source$2.dim(content),
    italic: (tag, content) => source$2.italic(content),
    underline: (tag, content) => source$2.underline(content),
    strike: (tag, content) => source$2.strike(content),
    h1: (tag, content) => {
      return source$2.underline(source$2.bold(content)) + "\n\n";
    },
    h2: (tag, content) => {
      return source$2.bold(content) + "\n";
    },
    date: (tag, content) => new Date().getDate().toString().padStart("0", 2) + "-" + (new Date().getMonth() + 1).toString().padStart("0", 2) + "-" + new Date().getFullYear().toString().padStart("0", 2),
    time: (tag, content) => new Date().getHours().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2),
    day: (tag, content) => new Date().getDate().toString().padStart("0", 2),
    days: (tag, content) => new Date().getDate().toString().padStart("0", 2),
    month: (tag, content) => new Date().getMonth().toString().padStart("0", 2),
    months: (tag, content) => new Date().getMonth().toString().padStart("0", 2),
    year: (tag, content) => new Date().getFullYear().toString().padStart("0", 2),
    years: (tag, content) => new Date().getFullYear().toString().padStart("0", 2),
    hour: (tag, content) => new Date().getHours().toString().padStart("0", 2),
    hours: (tag, content) => new Date().getHours().toString().padStart("0", 2),
    minute: (tag, content) => new Date().getMinutes().toString().padStart("0", 2),
    minutes: (tag, content) => new Date().getMinutes().toString().padStart("0", 2),
    second: (tag, content) => new Date().getSeconds().toString().padStart("0", 2),
    seconds: (tag, content) => new Date().getSeconds().toString().padStart("0", 2),
    br: (tag, content) => "\n"
  };
  function replaceTags(text, tags) {
    if (!text)
      text = "";
    text = fn$6(text);
    let oneLineText = text.replace(/\r\n/g, "|rn|");
    oneLineText = oneLineText.replace(/\n/g, "|n|");
    oneLineText = oneLineText.replace(/\r/g, "|r|");
    Object.keys(tags).forEach((tagName) => {
      const reg = new RegExp(`<s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`, "g");
      const tagsArray = oneLineText.match(reg);
      const singleReg = new RegExp(`\\s?<${tagName}\\s?/>\\s?`, "g");
      const singleTagsArray = oneLineText.match(singleReg);
      if (tagsArray) {
        for (let i = 0; i < tagsArray.length; i++) {
          const t = tagsArray[i];
          const tagArgs = t.match(`<\\s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`);
          if (!tagArgs)
            continue;
          const tagToReplace = tagArgs[0];
          const tagContent = tagArgs[1];
          oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
        }
      }
      if (singleTagsArray) {
        for (let i = 0; i < singleTagsArray.length; i++) {
          const t = singleTagsArray[i];
          const tagArgs = t.match(`\\s?<${tagName}\\s?/>\\s?`);
          if (!tagArgs)
            continue;
          const tagToReplace = tagArgs[0];
          const tagContent = "";
          oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
        }
      }
    });
    oneLineText = oneLineText.replace(/\|rn\|/g, "\r\n");
    oneLineText = oneLineText.replace(/\|n\|/g, "\n");
    oneLineText = oneLineText.replace(/\|r\|/g, "\r");
    return oneLineText;
  }
  function parseHtml(message) {
    let isArray = false;
    if (Array.isArray(message)) {
      isArray = true;
    } else {
      message = [message];
    }
    message = message.map((m) => {
      return replaceTags(m, tagsMap);
    });
    if (isArray)
      return message;
    return message[0];
  }
  var parseHtml$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": parseHtml});
  function parseSingleTypeString(typeString) {
    let ofStr = "", typeStr = typeString;
    const ofPartsString = typeString.match(/<(.+)>$/gm);
    if (ofPartsString && ofPartsString.length) {
      ofStr = ofPartsString[0].replace("<", "").replace(">", "");
    }
    if (ofStr !== "") {
      typeStr = typeStr.replace(`<${ofStr}>`, "");
    }
    let ofTypes = ofStr !== "" ? [ofStr.toLowerCase()] : void 0;
    if (ofStr !== void 0 && ofStr.includes("|")) {
      ofTypes = ofStr.split("|").map((t) => t.trim().toLowerCase());
    }
    return {
      type: typeStr,
      of: ofTypes
    };
  }
  const fn$3 = function parseTypeString(typeString) {
    typeString = typeString.toLowerCase().trim();
    typeString = typeString.split("|").map((part) => {
      part = part.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, "array<$1>");
      return part;
    }).join("|");
    typeString = typeString.split("|").map((part) => {
      part = part.trim().replace(/^([a-zA-Z0-9-_]+)\{\}$/, "object<$1>");
      return part;
    }).join("|");
    let types = [], inGroup = false, currentStr = "";
    for (let i = 0; i < typeString.length; i++) {
      const char = typeString[i];
      if (char === "<") {
        inGroup = true;
        currentStr += char;
      } else if (char === ">") {
        inGroup = false;
        currentStr += char;
      } else if (char === "|") {
        if (inGroup === false) {
          types.push(currentStr);
          currentStr = "";
        } else {
          currentStr += char;
        }
      } else {
        currentStr += char;
      }
    }
    types.push(currentStr);
    const finalTypes = [];
    types.forEach((type) => {
      finalTypes.push(parseSingleTypeString(type));
    });
    const res = {
      raw: typeString,
      types: finalTypes
    };
    return res;
  };
  var __isNode$1 = () => {
    return typeof process !== "undefined" && process.release && process.release.name === "node";
  };
  class STypeResult {
    constructor(data) {
      this._data = data;
    }
    get typeString() {
      return this._data.typeString;
    }
    get value() {
      return this._data.value;
    }
    get received() {
      return this._data.received;
    }
    get expected() {
      return this._data.expected;
    }
    get issues() {
      return this._data.issues;
    }
    get settings() {
      return this._data.settings;
    }
    hasIssues() {
      if (this._data)
        return true;
      return false;
    }
    toString() {
      if (__isNode$1()) {
        return this.toConsole();
      } else {
        return `The method "toHtml" has not being integrated for now...`;
      }
    }
    toConsole() {
      const headerArray = [
        `<underline><magenta>${this._data.settings.name}</magenta></underline>`,
        "",
        "<underline>Received value</underline>",
        "",
        `${fn$6(this._data.value, {
          beautify: true
        })}`,
        ""
      ];
      const issuesArray = [];
      Object.keys(this._data.issues).forEach((ruleId) => {
        const issueObj = this._data.issues[ruleId];
        const message = [];
        if (issueObj.expected.type) {
          message.push(`- Expected "<yellow>${issueObj.expected.type}</yellow>"`);
        }
        if (issueObj.received.type) {
          message.push(`- Received "<red>${issueObj.received.type}</red>"`);
        }
        if (issueObj.message) {
          message.push(["<underline>Details:</underline>", issueObj.message].join("\n"));
        }
        issuesArray.push(message.join("\n"));
      });
      const settingsArray = [
        "",
        `<underline>Settings</underline>`,
        "",
        `${fn$6(this._data.settings, {
          beautify: true
        })}`
      ];
      return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${this.settings.verbose ? settingsArray.join("\n") : ""}
    `).trim();
    }
  }
  class SType {
    constructor(typeString, settings = {}) {
      this.typeString = typeString;
      typeString = typeString.toLowerCase().trim();
      if (this.constructor._instanciatedTypes[typeString] !== void 0)
        return this.constructor._instanciatedTypes[typeString];
      this.types = fn$3(typeString).types;
      this._settings = deepMerge$2({
        id: this.constructor.name,
        name: this.constructor.name,
        customTypes: true,
        interfaces: true
      }, settings);
      this.constructor._instanciatedTypes[typeString] = this;
    }
    static registerType(type) {
      if (type.id === void 0 || typeof type.id !== "string") {
        throw new Error(`Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...`);
      }
      this._registeredTypes[type.id] = type;
    }
    is(value, settings = {}) {
      const res = this.check(value, settings);
      if (res === true)
        return true;
      else if (res instanceof STypeResult)
        return !res.hasIssues();
      return true;
    }
    check(value, settings = {}) {
      settings = deepMerge$2(this._settings, settings);
      const issues = {};
      for (let i = 0; i < this.types.length; i++) {
        const typeObj = this.types[i], typeId = typeObj.type;
        const res2 = this._isType(value, typeId, settings);
        if (res2 === true) {
          if (typeObj.of === void 0)
            return true;
          const typeOf$1 = typeOf(value);
          if (typeOf$1 !== "Array" && typeOf$1 !== "Object" && typeOf$1 !== "Map") {
            throw new Error(`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${typeOf$1}</cyan>" that does not support "child" value(s)...`);
          }
          const loopOn = typeOf$1 === "Object" ? Object.keys(value) : Array.from(value.keys());
          if (!loopOn.length)
            return true;
          for (let k = 0; k < loopOn.length; k++) {
            for (let j = 0; j < typeObj.of.length; j++) {
              const type = typeObj.of[j];
              const idx = loopOn[k];
              const v = typeOf$1 === "Map" ? value.get(idx) : value[idx];
              const ofRes = this._isType(v, type, settings);
              if (ofRes !== true) {
                issues[typeObj.type] = {
                  expected: {
                    type: typeObj.type
                  },
                  received: {
                    type: typeOf(v),
                    value: v
                  }
                };
              } else {
                return true;
              }
            }
          }
        } else {
          const issueObj = {
            expected: {
              type: typeObj.type
            },
            received: {
              type: typeOf(value),
              value
            }
          };
          if (res2 !== void 0 && res2 !== null && res2 !== false && res2.toString && typeof res2.toString === "function") {
            issueObj.message = res2.toString();
          }
          issues[typeObj.type] = issueObj;
        }
      }
      const res = new STypeResult({
        typeString: this.typeString,
        value,
        expected: {
          type: this.typeString
        },
        received: {
          type: typeOf(value)
        },
        issues,
        settings
      });
      return res;
    }
    _isType(value, type, settings = {}) {
      settings = deepMerge$2(this._settings, settings);
      if (this.constructor._registeredTypes[type.toLowerCase()] === void 0) {
        if (settings.interfaces === true) {
          const availableInterfaceTypes = SInterface.getAvailableTypes();
          if (availableInterfaceTypes[type] !== void 0) {
            const res = availableInterfaceTypes[type].apply(value, {});
            return res;
          }
        }
        if (settings.customTypes === true) {
          const typeOf$1 = typeOf(value).toLowerCase();
          const extendsStack = Object.keys(fn$7(value)).map((s) => s.toLowerCase());
          if (type === typeOf$1 || extendsStack.indexOf(type) !== -1)
            return true;
        }
        throw new Error(`Sorry but you try to validate a value with the type "<yellow>${type}</yellow>" but this type is not registered...`);
      }
      return this.constructor._registeredTypes[type.toLowerCase()].is(value);
    }
    cast(value, params, settings) {
      settings = deepMerge$2(this._settings, settings);
      const verboseObj = {
        value,
        issues: {},
        settings,
        toString() {
          const strAr = Object.entries(this.issues);
          return strAr.map((l) => l[1]).join("\n");
        }
      };
      if (this.is(value)) {
        return value;
      }
      for (let i = 0; i < this.types.length; i++) {
        const typeObj = this.types[i], typeId = typeObj.type;
        const descriptorObj = this.constructor._registeredTypes[typeId.toLowerCase()];
        if (descriptorObj === void 0) {
          continue;
        }
        if (descriptorObj.cast === void 0)
          continue;
        let castedValue;
        castedValue = descriptorObj.cast(value, params);
        if (castedValue instanceof Error) {
          verboseObj.issues[typeId] = castedValue.toString();
          continue;
        }
        if (typeObj.of !== void 0 && this.canHaveChilds(castedValue) === false) {
          const issueStr = `Sorry but the passed type "<yellow>${typeId}</yellow>" has some child(s) dependencies "<green>${typeObj.of.join("|")}</green>" but this type can not have child(s)`;
          throw new Error(parseHtml(issueStr));
        } else if (typeObj.of !== void 0) {
          const sTypeInstance = new SType(typeObj.of.join("|"));
          castedValue = fn$4(castedValue, ({value: value2}) => {
            return sTypeInstance.cast(value2, params, settings);
          });
        }
        if (castedValue === null && descriptorObj.id === "null")
          return null;
        if (castedValue === void 0 && descriptorObj.id === "undefined")
          return void 0;
        if (castedValue !== null && castedValue !== void 0)
          return castedValue;
        verboseObj.issues[typeId] = `Something goes wrong but no details are available... Sorry`;
      }
      const stack = [
        `Sorry but the value of type "<cyan>${typeOf(value)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:
`
      ];
      Object.keys(verboseObj.issues).forEach((descriptorId) => {
        stack.push(`- <red>${descriptorId}</red>: ${verboseObj.issues[descriptorId]}`);
      });
      throw new Error(parseHtml(stack.join("\n")));
    }
    canHaveChilds(value) {
      const type = typeOf(value);
      return type === "Array" || type === "Object" || type === "Map";
    }
    get name() {
      return this._settings.name;
    }
    get id() {
      return this._settings.id;
    }
  }
  SType._instanciatedTypes = {};
  SType._registeredTypes = {};
  function isString$1(value) {
    return typeof value === "string" || value instanceof String;
  }
  const descriptor$g = {
    name: "String",
    id: "string",
    is: (value) => isString$1(value),
    cast: (value) => fn$6(value, {
      beautify: true
    })
  };
  const descriptor$f = {
    name: "Map",
    id: "map",
    is: (value) => isMap$2(value),
    cast: (value) => {
      if (isMap$2(value))
        return value;
      const map = new Map();
      map.set("value", value);
      return map;
    }
  };
  const descriptor$e = {
    name: "Object",
    id: "object",
    is: (value) => isObject$4(value),
    cast: (value) => {
      if (isObject$4(value))
        return value;
      return {
        value
      };
    }
  };
  const descriptor$d = {
    name: "Array",
    id: "array",
    is: (value) => {
      return Array.isArray(value);
    },
    cast: (value, params = {}) => {
      if (!value)
        return [];
      if (params.splitChars && Array.isArray(params.splitChars)) {
        value = value.split(new RegExp(`(${params.splitChars.join("|")})`, "gm")).filter((l) => l.trim() !== "" && params.splitChars.indexOf(l) === -1);
      }
      if (Array.isArray(value))
        return value;
      return [value];
    }
  };
  const descriptor$c = {
    name: "Integer",
    id: "integer",
    is: (value) => Number.isInteger(value),
    cast: (value) => {
      if (typeof value !== "string" && typeof value !== "number") {
        return new Error(`Sorry but only strings and numbers can be casted to integers... Passed value: ${value}`);
      }
      const res = parseInt(value);
      if (isNaN(res))
        return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Integer</green> does not work...`);
      return res;
    }
  };
  const descriptor$b = {
    name: "Number",
    id: "number",
    is: (value) => typeof value === "number",
    cast: (value) => {
      if (typeof value !== "string") {
        return new Error(`Sorry but only strings can be casted to numbers...`);
      }
      const res = parseFloat(value);
      if (isNaN(res))
        return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Number</green> does not work...`);
      return res;
    }
  };
  const descriptor$a = {
    name: "Boolean",
    id: "boolean",
    is: (value) => typeof value === "boolean",
    cast: (value, params = {}) => {
      if (value !== false && params && params.nullishAsTrue && !value) {
        return true;
      }
      if (typeof value === "boolean")
        return value;
      if (value === null || value === void 0)
        return false;
      if (typeof value === "number") {
        if (value > 0)
          return true;
        return false;
      }
      if (typeof value === "string") {
        return value.length > 0 ? true : false;
      }
      if (Array.isArray(value)) {
        if (value.length > 0)
          return true;
        return false;
      }
      if (typeof value === "object") {
        return Object.keys(value).length > 0 ? true : false;
      }
      return new Error([
        `Sorry but for now only these types can be casted to boolean:`,
        "- <yellow>null</yellow>: Will be casted as <red>false</red>",
        "- <yellow>undefined</yellow>: Will be casted as <red>false</red>",
        "- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise",
        "- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise",
        "- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise",
        "- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"
      ].join("\n"));
    }
  };
  const descriptor$9 = {
    name: "Undefined",
    id: "undefined",
    is: (value) => value === void 0,
    cast: (value) => {
      return void 0;
    }
  };
  const descriptor$8 = {
    name: "Null",
    id: "null",
    is: (value) => value === null,
    cast: (value) => {
      return null;
    }
  };
  const descriptor$7 = {
    name: "Symbol",
    id: "symbol",
    is: (value) => typeof value === "symbol",
    cast: (value) => {
      if (typeof value === "symbol")
        return value;
      return Symbol(value);
    }
  };
  const descriptor$6 = {
    name: "Bigint",
    id: "bigint",
    is: (value) => typeof value === "bigint",
    cast: (value) => {
      if (typeof value === "bigint")
        return value;
      if (typeof value !== "string" && typeof value !== "number") {
        return new Error(`Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>`);
      }
      let res;
      try {
        res = BigInt(value);
      } catch (e) {
        res = new Error(`It seem's that the passed value "<yellow>${value}</yellow>" can not be casted to a <green>BigInt</green>`);
      }
      return res;
    }
  };
  const descriptor$5 = {
    name: "Date",
    id: "date",
    is: (value) => value instanceof Date,
    cast: (value) => {
      if (typeof value === "string") {
        return new Date(value);
      }
      if (typeof value === "number") {
        return new Date(Math.round(value));
      }
      if (plainObject$2(value)) {
        const now = new Date();
        let year = now.getFullYear(), month = 0, day = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
        if (value.year && typeof value.year === "number") {
          year = value.year;
        }
        if (value.month && typeof value.month === "number") {
          month = value.month;
        }
        if (value.day && typeof value.day === "number") {
          day = value.day;
        }
        if (value.hours && typeof value.hours === "number") {
          hours = value.hours;
        }
        if (value.minutes && typeof value.minutes === "number") {
          minutes = value.minutes;
        }
        if (value.seconds && typeof value.seconds === "number") {
          seconds = value.seconds;
        }
        if (value.milliseconds && typeof value.milliseconds === "number") {
          milliseconds = value.milliseconds;
        }
        return new Date(year, month, day, hours, minutes, seconds, milliseconds);
      }
      return new Error(`Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date`);
    }
  };
  const descriptor$4 = {
    name: "Function",
    id: "function",
    is: (value) => typeof value === "function",
    cast: (value) => {
      return new Error(`Sorry but nothing is castable to a Function`);
    }
  };
  const descriptor$3 = {
    name: "WeakMap",
    id: "weakmap",
    is: (value) => value instanceof WeakMap,
    cast: (value) => {
      return new Error(`Sorry but nothing can be casted to a WeakMap for now`);
    }
  };
  const descriptor$2 = {
    name: "WeakSet",
    id: "weakset",
    is: (value) => value instanceof WeakSet,
    cast: (value) => {
      return new Error(`Sorry but nothing can be casted to a WeakSet for now`);
    }
  };
  const descriptor$1 = {
    name: "Set",
    id: "set",
    is: (value) => value instanceof Set,
    cast: (value) => {
      if (value instanceof Set)
        return value;
      const set = new Set();
      set.add(value);
      return set;
    }
  };
  const descriptor = {
    name: "Class",
    id: "class",
    is: (value) => cls$1(value),
    cast: (value) => {
      return new Error(`Sorry but nothing is castable to a Class`);
    }
  };
  SType.registerType(descriptor$g);
  SType.registerType(descriptor$f);
  SType.registerType(descriptor$e);
  SType.registerType(descriptor$d);
  SType.registerType(descriptor$c);
  SType.registerType(descriptor$b);
  SType.registerType(descriptor$a);
  SType.registerType(descriptor$9);
  SType.registerType(descriptor$8);
  SType.registerType(descriptor$7);
  SType.registerType(descriptor$6);
  SType.registerType(descriptor$5);
  SType.registerType(descriptor$4);
  SType.registerType(descriptor$3);
  SType.registerType(descriptor$2);
  SType.registerType(descriptor$1);
  SType.registerType(descriptor);
  function ofType(value, typeString, settings = {}) {
    settings = Object.assign({verbose: false}, settings);
    const typeInstance = new SType(typeString, settings);
    const res = typeInstance.is(value);
    return res;
  }
  class SDescriptorResult extends SClass {
    constructor(descriptor, value, descriptorSettings) {
      super({});
      this._issues = {};
      this._descriptor = descriptor;
      this._descriptorSettings = descriptorSettings;
      try {
        this._originalValue = clone$4(value, {deep: true});
      } catch (e) {
        this._originalValue = value;
      }
      this.value = value;
    }
    hasIssues() {
      return Object.keys(this._issues).length >= 1;
    }
    add(ruleResult) {
      if (!ruleResult.__ruleObj.id)
        return;
      this._issues[ruleResult.__ruleObj.id] = ruleResult;
    }
    toString() {
      if (__isNode$1()) {
        return this.toConsole();
      } else {
        return `The method "toHtml" has not being integrated for now...`;
      }
    }
    toConsole() {
      const headerArray = [
        `<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,
        "",
        `${fn$6(this.value, {
          beautify: true
        })}`,
        ""
      ];
      const issuesArray = [];
      Object.keys(this._issues).forEach((ruleId) => {
        const ruleResult = this._issues[ruleId];
        let message = "";
        if (ruleResult.__error && ruleResult.__error instanceof Error) {
          message = ruleResult.__error.message;
        } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "function") {
          message = ruleResult.__ruleObj.message(ruleResult);
        } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "string") {
          message = ruleResult.__ruleObj.message;
        }
        issuesArray.push(`-${typeof ruleResult.__propName === "string" ? ` [<magenta>${ruleResult.__propName}</magenta>]` : ""} <red>${ruleId}</red>: ${message}`);
      });
      const settingsArray = [
        "",
        `<underline>Settings</underline>`,
        "",
        `${fn$6(this._descriptorSettings, {
          beautify: true
        })}`
      ];
      return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${settingsArray.join("\n")}
    `).trim();
    }
  }
  /*!
  * is-extglob <https://github.com/jonschlinkert/is-extglob>
  *
  * Copyright (c) 2014-2016, Jon Schlinkert.
  * Licensed under the MIT License.
  */
  var isExtglob$1 = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
  /*!
  * is-glob <https://github.com/jonschlinkert/is-glob>
  *
  * Copyright (c) 2014-2017, Jon Schlinkert.
  * Released under the MIT License.
  */
  var isExtglob = isExtglob$1;
  var chars = {"{": "}", "(": ")", "[": "]"};
  var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
  var isGlob = function isGlob(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var regex = strictRegex;
    var match;
    if (options && options.strict === false) {
      regex = relaxedRegex;
    }
    while (match = regex.exec(str)) {
      if (match[2])
        return true;
      var idx = match.index + match[0].length;
      var open = match[1];
      var close = open ? chars[open] : null;
      if (open && close) {
        var n = str.indexOf(close, idx);
        if (n !== -1) {
          idx = n + 1;
        }
      }
      str = str.slice(idx);
    }
    return false;
  };
  var __isGlob = (string) => {
    return isGlob(string);
  };
  class SDescriptor extends SClass {
    constructor(settings) {
      super(deepMerge$2({
        descriptor: {
          rules: {},
          type: "Object",
          arrayAsValue: false,
          throwOnMissingRule: false,
          complete: true
        }
      }, settings !== null && settings !== void 0 ? settings : {}));
    }
    static registerRule(rule) {
      if (rule.id === void 0 || typeof rule.id !== "string") {
        throw new Error(`Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...`);
      }
      this._registeredRules[rule.id] = rule;
    }
    get descriptorSettings() {
      return this._settings.descriptor;
    }
    apply(value, settings) {
      const set = deepMerge$2(this.descriptorSettings, settings || {});
      if (value === void 0 || value === null)
        value = {};
      const valuesObjToProcess = {}, finalValuesObj = {};
      this._descriptorResult = new SDescriptorResult(this, finalValuesObj, Object.assign({}, set));
      const rules = set.rules;
      if (!ofType(value, set.type)) {
        throw new Error(`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${typeOf(value)}</cyan>" but only "<green>${set.type}</green>"...`);
      }
      if (Array.isArray(value) && !set.arrayAsValue) {
        throw new Error(`Sorry but the support for arrays like values has not been integrated for not...`);
      } else if (typeof value === "object" && value !== null && value !== void 0) {
        Object.keys(rules).forEach((propName) => {
          if (__isGlob(propName) && value)
            ;
          else {
            valuesObjToProcess[propName] = get(value, propName);
          }
        });
        Object.keys(valuesObjToProcess).forEach((propName) => {
          const ruleObj = rules[propName];
          if (valuesObjToProcess[propName] === void 0 && set.complete && ruleObj.default !== void 0) {
            valuesObjToProcess[propName] = ruleObj.default;
          }
          if (ruleObj.interface !== void 0) {
            const interfaceValue = valuesObjToProcess[propName];
            valuesObjToProcess[propName] = ruleObj.interface.apply(interfaceValue || {}, {
              complete: true
            });
          }
          const validationResult = this._validate(valuesObjToProcess[propName], propName, ruleObj, set);
          if (validationResult !== void 0 && validationResult !== null) {
            __set(finalValuesObj, propName, validationResult);
          }
        });
      } else {
        console.warn(value);
        throw new Error(`You can apply an <yellow>SDescriptor</yellow> only on an Object like value...`);
      }
      if (this._descriptorResult.hasIssues()) {
        throw new Error(this._descriptorResult.toString());
      }
      return this._descriptorResult;
    }
    _validate(value, propName, rulesObj, settings) {
      if (rulesObj === void 0)
        return value;
      if (rulesObj.required === void 0 || rulesObj.required === false) {
        if (value === void 0 || value === null)
          return value;
      }
      let rulesNamesInOrder = Object.keys(rulesObj).filter((l) => l !== "default");
      rulesNamesInOrder = rulesNamesInOrder.sort((a, b) => {
        const objA = this.constructor._registeredRules[a];
        const objB = this.constructor._registeredRules[b];
        if (!objA)
          return -1;
        if (!objB)
          return 1;
        if (objA.priority === void 0)
          objA.priority = 9999999999;
        if (objB.priority === void 0)
          objB.priority = 9999999999;
        return objA.priotity - objB.priority;
      }).reverse();
      let resultValue = value;
      rulesNamesInOrder.forEach((ruleName) => {
        const ruleValue = rulesObj[ruleName];
        if (this.constructor._registeredRules[ruleName] === void 0) {
          if (settings.throwOnMissingRule) {
            throw new Error(`Sorry but you try to validate a value using the "<yellow>${ruleName}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ${Object.keys(this.constructor._registeredRules).join("\n- ")}`);
          }
        } else {
          const ruleObj = this.constructor._registeredRules[ruleName];
          const params = ruleObj.processParams !== void 0 ? ruleObj.processParams(ruleValue) : ruleValue;
          const ruleSettings = ruleObj.settings !== void 0 ? ruleObj.settings : {};
          if (ruleSettings.mapOnArray && Array.isArray(resultValue)) {
            let newResultValue = [];
            resultValue.forEach((v) => {
              const processedValue = this._processRule(v, ruleObj, propName, params, ruleSettings, settings);
              if (Array.isArray(processedValue)) {
                newResultValue = [...newResultValue, ...processedValue];
              } else {
                newResultValue.push(processedValue);
              }
            });
            resultValue = newResultValue;
          } else {
            const processedValue = this._processRule(resultValue, ruleObj, propName, params, ruleSettings, settings);
            resultValue = processedValue;
          }
        }
      });
      return resultValue;
    }
    _processRule(value, ruleObj, propName, params, ruleSettings, settings) {
      const ruleResult = ruleObj.apply(value, params, ruleSettings, Object.assign(Object.assign({}, settings), {propName, name: `${settings.name}.${propName}`}));
      if (params && params.type && params.type.toLowerCase() === "boolean" && ruleResult === true) {
        return true;
      }
      if (ruleResult instanceof Error) {
        const obj = {
          __error: ruleResult,
          __ruleObj: ruleObj,
          __propName: propName
        };
        if (this._descriptorResult) {
          this._descriptorResult.add(obj);
          throw new Error(this._descriptorResult.toString());
        }
      } else {
        return ruleResult;
      }
    }
  }
  SDescriptor._registeredRules = {};
  SDescriptor.rules = {};
  SDescriptor.type = "Object";
  const ruleObj$3 = {
    priority: 1,
    name: "Required",
    id: "required",
    settings: {
      when: [void 0, null]
    },
    message: "This value is required",
    processParams: (params) => {
      return {value: params};
    },
    apply: (value, params, ruleSettings, settings) => {
      if (params.value === true) {
        if (ruleSettings.when.indexOf(value) !== -1) {
          return new Error("This property is <yellow>required</yellow>");
        }
      }
      return value;
    }
  };
  const ruleObj$2 = {
    prority: 10,
    name: "Type",
    id: "type",
    settings: {},
    processParams: (params) => {
      var _a, _b;
      if (!(params === null || params === void 0 ? void 0 : params.type) && typeof params !== "string") {
        throw new Error(`<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...`);
      }
      return Object.assign(Object.assign({}, typeof params !== "string" ? params : {}), {type: (_a = params.type) !== null && _a !== void 0 ? _a : params, cast: (_b = params.cast) !== null && _b !== void 0 ? _b : true});
    },
    apply: (value, params, ruleSettings, settings) => {
      const type = new SType(params.type, {
        metas: {
          id: settings.id
        }
      });
      if (params.cast && !type.is(value)) {
        value = type.cast(value, params);
      }
      if (!type.is(value)) {
        return new Error(`The value must be of type "<yellow>${params.type}</yellow>" but you've passed a value of type "<cyan>${typeof value}</cyan>"`);
      }
      return value;
    }
  };
  const ruleObj$1 = {
    name: "Min",
    id: "min",
    settings: {},
    accept: "Number",
    message: (resultObj) => {
      return `This value has to be minimum "<yellow>${resultObj.min}</yellow>". Received "<red>${resultObj.received}</red>"`;
    },
    processParams: (params) => {
      return {value: params};
    },
    apply: (value, params, ruleSettings, settings) => {
      if (value < params.value) {
        return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be greater or equal at <cyan>${params.value}</cyan>`);
      }
      return value;
    }
  };
  const ruleObj = {
    name: "Max",
    id: "max",
    settings: {},
    accept: "Number",
    message: (resultObj) => {
      return `This value has to be maximum "<yellow>${resultObj.max}</yellow>". Received "<red>${resultObj.received}</red>"`;
    },
    processParams: (params) => {
      return {value: params};
    },
    apply: (value, params, ruleSettings, settings) => {
      if (value > params.value) {
        return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be lower or equal at <cyan>${params.value}</cyan>`);
      }
      return value;
    }
  };
  SDescriptor.registerRule(ruleObj$3);
  SDescriptor.registerRule(ruleObj$2);
  SDescriptor.registerRule(ruleObj$1);
  SDescriptor.registerRule(ruleObj);
  function parseArgs(string, settings = {}) {
    settings = deepMerge$2({
      throw: true,
      defaultObj: {},
      cast: true,
      valueQuote: void 0
    }, settings);
    string = string.trim();
    string = string.replace(/(["'`])--/gm, "$1--\xA7 --");
    let valueQuote = settings.valueQuote;
    if (!valueQuote) {
      for (let i = 0; i < string.length; i++) {
        const char = string[i];
        if (char === '"' || char === "`" || char === "'") {
          valueQuote = char;
          break;
        }
      }
      if (!valueQuote)
        valueQuote = '"';
    }
    let stringArray = [];
    let isFunctionStyle = false;
    if (string.match(/^\(/) && string.match(/\)$/)) {
      isFunctionStyle = true;
      string = string.slice(1, -1);
      let currentStr = "";
      let parenthesisCount = 0;
      let quotesCount = 0;
      for (let i = 0; i < string.length; i++) {
        const char = string[i];
        const previousChar = string[i - 1] || string[0];
        if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
          quotesCount++;
        } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
          quotesCount--;
        }
        if (!quotesCount && char === "(") {
          parenthesisCount++;
        } else if (!quotesCount && char === ")") {
          parenthesisCount--;
        }
        if (char === ",") {
          if (quotesCount || parenthesisCount) {
            currentStr += char;
          } else {
            stringArray.push(currentStr.trim());
            currentStr = "";
          }
        } else {
          currentStr += char;
        }
      }
      if (parenthesisCount)
        currentStr += ")".repeat(parenthesisCount);
      stringArray.push(currentStr.trim());
    } else {
      let currentStr = "";
      let quotesCount = false;
      for (let i = 0; i < string.length; i++) {
        const char = string[i];
        const previousChar = string[i - 1] || string[0];
        if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
          quotesCount = true;
        } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
          quotesCount = false;
        }
        if (char === " ") {
          if (quotesCount) {
            currentStr += char;
          } else {
            stringArray.push(currentStr.trim());
            currentStr = "";
          }
        } else {
          currentStr += char;
        }
      }
      stringArray.push(currentStr.trim());
    }
    stringArray = stringArray.map((item) => unquote(item));
    const argsObj = {};
    let currentArgName = void 0;
    let currentValue;
    stringArray = stringArray.forEach((part, i) => {
      if (!isFunctionStyle && !part.includes(" ") && (part.slice(0, 2) === "--" || part.slice(0, 1) === "-")) {
        if (currentValue === void 0 && currentArgName !== -1 && currentArgName && argsObj[currentArgName] === void 0) {
          argsObj[currentArgName] = true;
        }
        currentArgName = part.replace(/^[-]{1,2}/, "");
        if (argsObj[currentArgName] === void 0) {
          argsObj[currentArgName] = true;
        }
      } else {
        let value;
        if (part && typeof part === "string") {
          value = part.replace(/^\\\\\\`/, "").replace(/\\\\\\`$/, "").replace(/^'/, "").replace(/'$/, "").replace(/^"/, "").replace(/"$/, "");
          if (value.match(/^\$[a-zA-Z0-9-_]+\s?:.*/)) {
            const parts = part.split(":");
            currentArgName = parts[0].trim().replace(/^\$/, "");
            value = parts.slice(1).join(":").trim();
          }
        }
        currentValue = __parse(value);
        if (typeof currentValue === "string") {
          currentValue = currentValue.replace("--\xA7 ", "");
        }
        if (currentArgName !== void 0) {
          if (argsObj[currentArgName] !== void 0 && argsObj[currentArgName] !== true) {
            if (!Array.isArray(argsObj[currentArgName])) {
              argsObj[currentArgName] = [argsObj[currentArgName]];
            }
            argsObj[currentArgName].push(currentValue);
          } else {
            argsObj[currentArgName] = currentValue;
          }
          currentValue = void 0;
          currentArgName = void 0;
        } else {
          argsObj[i] = currentValue;
        }
      }
    });
    Object.keys(argsObj).forEach((key) => {
      const value = argsObj[key];
      if (value === void 0)
        delete argsObj[key];
    });
    return argsObj;
  }
  function getAvailableInterfaceTypes() {
    if (global !== void 0)
      return global._registeredInterfacesTypes || {};
    else if (window !== void 0)
      return window._registeredInterfacesTypes || {};
    else
      return {};
  }
  if (__isNode$1())
    global._registeredInterfacesTypes = {};
  else
    window._registeredInterfacesTypes = {};
  class SInterface extends SClass {
    constructor(settings) {
      super(deepMerge$2({
        interface: {}
      }, settings !== null && settings !== void 0 ? settings : {}));
      this._definition = {};
      this._definition = this.constructor.definition;
    }
    static get definition() {
      if (!this._definition.help) {
        this._definition.help = {
          type: "Boolean",
          description: `Display the help for this "<yellow>${this.name}</yellow>" interface...`,
          default: false
        };
      }
      return this._definition;
    }
    static set definition(value) {
      this._definition = value;
    }
    get interfaceSettings() {
      return this._settings.interface;
    }
    static registerRenderer(rendererClass) {
      if (!rendererClass.id) {
        throw new Error(`Sorry but the interface renderer "<yellow>${rendererClass.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);
      }
      this._registeredRenderers[rendererClass.id] = rendererClass;
    }
    static override(definition) {
      const _this = this;
      class SInterfaceOverrided extends this {
      }
      SInterfaceOverrided.overridedName = `${_this.name} (overrided)`;
      SInterfaceOverrided.definition = deepMerge$2(_this.definition, definition);
      return SInterfaceOverrided;
    }
    static getAvailableTypes() {
      return getAvailableInterfaceTypes();
    }
    static makeAvailableAsType(name2 = null) {
      const n = (name2 || this.name).toLowerCase();
      if (global !== void 0) {
        global._registeredInterfacesTypes[n] = this;
        global._registeredInterfacesTypes[n.replace("interface", "")] = this;
      } else if (window !== void 0) {
        window._registeredInterfacesTypes[n] = this;
        window._registeredInterfacesTypes[n.replace("interface", "")] = this;
      }
    }
    static defaults() {
      var _a;
      return (_a = this.apply({}, {})) !== null && _a !== void 0 ? _a : {};
    }
    static apply(objectOrString, settings) {
      const int = new this({
        interface: settings !== null && settings !== void 0 ? settings : {}
      });
      return int.apply(objectOrString);
    }
    static render(renderer = "terminal", settings) {
      const set = deepMerge$2({
        renderer: "terminal",
        exclude: ["help"]
      }, settings);
      if (!this._registeredRenderers[renderer]) {
        throw new Error(`Sorry but the requested renderer "<yellow>${renderer}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);
      }
      const rendererInstance = new this._registeredRenderers[renderer](this, set);
      return rendererInstance.render();
    }
    apply(objectOrString, settings) {
      var _a;
      const set = deepMerge$2(this.interfaceSettings, settings !== null && settings !== void 0 ? settings : {});
      let objectOnWhichToApplyInterface = objectOrString;
      if (typeof objectOrString === "string") {
        objectOnWhichToApplyInterface = parseArgs(objectOrString);
        Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
          for (let i = 0; i < Object.keys(this._definition).length; i++) {
            const defArgName = Object.keys(this._definition)[i];
            const obj = this._definition[defArgName];
            if (obj.explicit) {
              if (obj.alias && ` ${objectOrString} `.match(new RegExp(`\\s-${obj.alias}\\s`)))
                return;
              else if (` ${objectOrString} `.match(new RegExp(`\\s--${argName}\\s`)))
                return;
              delete objectOnWhichToApplyInterface[argName];
            }
          }
        });
        Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
          for (let i = 0; i < Object.keys(this._definition).length; i++) {
            const defArgName = Object.keys(this._definition)[i];
            const obj = this._definition[defArgName];
            if (!obj.alias)
              continue;
            if (obj.alias === argName && objectOnWhichToApplyInterface[defArgName] === void 0) {
              objectOnWhichToApplyInterface[defArgName] = objectOnWhichToApplyInterface[argName];
              delete objectOnWhichToApplyInterface[argName];
            }
          }
        });
        Object.keys(objectOnWhichToApplyInterface).forEach((argName, i) => {
          if (argName === `${i}`) {
            const definitionKeys = Object.keys(this._definition);
            if (definitionKeys[i]) {
              objectOnWhichToApplyInterface[definitionKeys[i]] = objectOnWhichToApplyInterface[argName];
            }
            delete objectOnWhichToApplyInterface[argName];
          }
        });
      }
      const descriptor = new SDescriptor({
        descriptor: Object.assign({type: "Object", rules: this._definition}, (_a = set.descriptor) !== null && _a !== void 0 ? _a : {})
      });
      if (set.baseObj) {
        objectOnWhichToApplyInterface = deepMerge$2(set.baseObj, objectOnWhichToApplyInterface);
      }
      const descriptorResult = descriptor.apply(objectOnWhichToApplyInterface);
      if (descriptorResult.hasIssues()) {
        throw new Error(descriptorResult.toString());
      }
      return descriptorResult.value;
    }
  }
  SInterface._definition = {};
  SInterface._registeredRenderers = {};
  function uniqid$5() {
    return uuid_1.v4();
  }
  function matches$6(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer$6;
  const _selectors$6 = {};
  function querySelectorLive$6(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid$5()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors$6[selector]) {
      _selectors$6[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors$6[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors$6[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors$6[obj.selector];
          });
        });
      }
      if (!_observer$6) {
        _observer$6 = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid$5()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors$6);
                selectors.forEach((sel) => {
                  if (matches$6(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors$6);
              selectors.forEach((sel) => {
                if (matches$6(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer$6.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  class SDocblockToHtmlComponentInterface extends SInterface {
  }
  SDocblockToHtmlComponentInterface.definition = {
    src: {
      type: "String",
      required: true,
      alias: "s"
    }
  };
  const Component$5 = {
    "css": ``,
    "exports": {
      onBeforeMount() {
        return __async(this, null, function* () {
          this.$props = SDocblockToHtmlComponentInterface.apply(this.props);
          const response = yield fetch(this.$props.src);
          const value = yield response.text();
          this.root.innerHTML = value;
        });
      }
    },
    "template": null,
    "name": "s-inline-svg"
  };
  register("s-inline-svg", Component$5);
  querySelectorLive$6("s-inline-svg:not([s-mounted])", ($elm) => {
    const id = $elm.id || "s-inline-svg-" + uniqid$5();
    $elm.setAttribute("id", id);
    mount("#" + id);
  });
  Component$5.mount = () => {
    mount("s-inline-svg");
  };
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  function camelize$1(text) {
    let res = "";
    const reg = /(?:^|[_-\s])(\w)/g;
    res = text.replace(reg, function(_, c) {
      return c ? c.toUpperCase() : "";
    });
    res = res.substr(0, 1).toLowerCase() + res.slice(1);
    return res.trim();
  }
  function camelCase(text) {
    return camelize$1(text);
  }
  function whenInViewport(elm, settings = {}) {
    settings = Object.assign({offset: 50}, settings);
    return new Promise((resolve) => {
      const options = {
        root: null,
        rootMargin: `${settings.offset}px`,
        threshold: 1
      };
      function onChange(changes, observer2) {
        changes.forEach((change) => {
          if (change.intersectionRatio > 0) {
            observer2.disconnect();
            resolve(elm);
          }
        });
      }
      const observer = new IntersectionObserver(onChange, options);
      observer.observe(elm);
    });
  }
  var __awaiter$8 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SComponentUtilsDefaultInterface extends SInterface {
  }
  SComponentUtilsDefaultInterface.definition = {
    mountWhen: {
      type: "String",
      values: ["directly", "inViewport"],
      default: "directly"
    },
    adoptStyles: {
      type: "Boolean",
      default: true
    },
    defaultStyle: {
      type: "Boolean",
      default: false
    }
  };
  class SComponentUtils extends SClass {
    constructor(name2, node, props, settings = {}) {
      var _a, _b, _c, _d, _e, _f, _g;
      super(deepMerge$2({}, settings));
      this.$targets = [];
      this.shouldUpdate = false;
      this.name = name2;
      this.node = node;
      if (!this.node.tagName)
        this.node = this.node.parentNode;
      if (((_b = (_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === this.name) {
        this.node = node.parentNode;
      }
      const defaultProps = deepMerge$2((_d = (_c = this._settings.interface) === null || _c === void 0 ? void 0 : _c.defaults()) !== null && _d !== void 0 ? _d : {}, (_e = this._settings.defaultProps) !== null && _e !== void 0 ? _e : {}, (_f = this.constructor._defaultProps["*"]) !== null && _f !== void 0 ? _f : {}, (_g = this.constructor._defaultProps[this.name]) !== null && _g !== void 0 ? _g : {});
      let passedProps = {};
      if (props.constructor.name === "NamedNodeMap") {
        Object.keys(props).forEach((key) => {
          var _a2, _b2, _c2;
          let value;
          if (((_a2 = props[key]) === null || _a2 === void 0 ? void 0 : _a2.nodeValue) !== void 0) {
            if (props[key].nodeValue === "")
              value = true;
            else
              value = props[key].nodeValue;
          }
          if (!value)
            return;
          passedProps[camelCase((_c2 = (_b2 = props[key]) === null || _b2 === void 0 ? void 0 : _b2.name) !== null && _c2 !== void 0 ? _c2 : key)] = value;
        });
      } else {
        passedProps = props;
      }
      this.props = deepMerge$2(defaultProps, passedProps);
      if (!this.node.shouldUpdate) {
        this.node.shouldUpdate = () => {
          return this.shouldUpdate;
        };
      }
      switch (this.props.mountWhen) {
        case "inViewport":
          (() => __awaiter$8(this, void 0, void 0, function* () {
            yield whenInViewport(this.node);
            this.mount();
          }))();
          break;
        case "directly":
        default:
          this.mount();
          break;
      }
    }
    static setDefaultProps(selector, props) {
      this._defaultProps[selector] = props;
    }
    mount() {
      var _a, _b;
      return __awaiter$8(this, void 0, void 0, function* () {
        this.shouldUpdate = true;
        (_b = (_a = this.node).requestUpdate) === null || _b === void 0 ? void 0 : _b.call(_a);
        yield wait$1();
        if (this.props.adoptStyles)
          this._adoptStyles();
        yield wait$1();
        this.node.setAttribute("s-mounted", true);
      });
    }
    _adoptStyles() {
      const $links = document.querySelectorAll('link[rel="stylesheet"]');
      if ($links && this.node.shadowRoot) {
        Array.from($links).forEach(($link) => __awaiter$8(this, void 0, void 0, function* () {
          var _a, _b;
          if (Array.isArray(this.props.adoptStyles) && this.props.adoptStyles.indexOf((_a = $link.id) !== null && _a !== void 0 ? _a : "") === -1) {
            return;
          }
          if ($link._stylesheet) {
            this.node.shadowRoot.adoptedStyleSheets = [...this.node.shadowRoot.adoptedStyleSheets, $link._stylesheet];
            return;
          }
          (_b = this.node.shadowRoot) === null || _b === void 0 ? void 0 : _b.appendChild($link.cloneNode());
          if (this.constructor._styleNodes.indexOf($link) !== -1)
            return;
          this.constructor._styleNodes.push($link);
          const res = yield fetch($link.href, {
            headers: {
              Accept: "text/css,*/*;q=0.1"
            }
          });
          let cssStr = yield res.text();
          const stylesheet = new CSSStyleSheet();
          stylesheet.replace(cssStr);
          $link._stylesheet = stylesheet;
        }));
      }
      const $styles = document.querySelectorAll("style");
      if ($styles && this.node.shadowRoot) {
        Array.from($styles).forEach(($style) => {
          var _a;
          if (Array.isArray(this.props.adoptStyles) && this.props.adoptStyles.indexOf((_a = $style.id) !== null && _a !== void 0 ? _a : "") === -1) {
            return;
          }
          if ($style._stylesheet) {
            this.node.shadowRoot.adoptedStyleSheets = [...this.node.shadowRoot.adoptedStyleSheets, $style._stylesheet];
            return;
          }
          const stylesheet = new CSSStyleSheet();
          stylesheet.replace($style.innerHTML);
          $style._stylesheet = stylesheet;
          this.node.shadowRoot.adoptedStyleSheets = [...this.node.shadowRoot.adoptedStyleSheets, $style._stylesheet];
        });
      }
    }
    exposeApi(apiObj) {
      setTimeout(() => {
        var _a;
        let $on = this.node;
        if ((_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a._component) {
          $on = this.node.parentNode;
        }
        Object.keys(apiObj).forEach((apiFnName) => {
          const apiFn = apiObj[apiFnName];
          $on[apiFnName] = apiFn;
        });
      });
    }
    className(cls = "", style = "") {
      let clsString = cls.split(" ").map((clsName) => `${this.name}${clsName && !clsName.match(/^__/) ? "-" : ""}${clsName}`).join(" ");
      if (style && this.props.defaultStyle) {
        clsString += ` ${style}`;
      }
      return clsString;
    }
    decodeHtml(input) {
      const e = document.createElement("textarea");
      e.innerHTML = input;
      return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }
    dispatchSyncEvent(name2, details) {
      return new Promise((resolve, reject) => {
        let hasListeners = false;
        this.node.dispatchEvent(new CustomEvent(name2, {
          detail: Object.assign(Object.assign({}, details), {
            onPing() {
              hasListeners = true;
            },
            onResolve(data) {
              resolve(data);
            }
          })
        }));
        setTimeout(() => {
          if (!hasListeners)
            reject();
        });
      });
    }
    addSyncEventListener(name2, handler) {
      this.node.addEventListener(name2, (e) => __awaiter$8(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = e.detail) === null || _a === void 0 ? void 0 : _a.onPing))
          return handler(e);
        e.detail.onPing();
        const res = yield handler(e);
        e.detail.onResolve(res);
      }));
    }
    addSyncEventListenerOn($targets, name2, handler) {
      $targets.forEach(($target) => {
        $target.addEventListener(name2, (e) => __awaiter$8(this, void 0, void 0, function* () {
          var _a;
          if (!((_a = e.detail) === null || _a === void 0 ? void 0 : _a.onPing))
            return handler(e);
          e.detail.onPing();
          const res = yield handler(e);
          e.detail.onResolve(res);
        }));
      });
    }
    addTargetsEventListener(name2, handler) {
      this.$targets.forEach(($target) => {
        $target.addEventListener(name2, (e) => __awaiter$8(this, void 0, void 0, function* () {
          var _a;
          if (!((_a = e.detail) === null || _a === void 0 ? void 0 : _a.onPing))
            return handler(e);
          e.detail.onPing();
          const res = yield handler(e);
          e.detail.onResolve(res);
        }));
      });
    }
  }
  SComponentUtils._defaultProps = {};
  SComponentUtils._styleNodes = [];
  function uniqid$4() {
    return uuid_1.v4();
  }
  function matches$5(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer$5;
  const _selectors$5 = {};
  function querySelectorLive$5(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid$4()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors$5[selector]) {
      _selectors$5[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors$5[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors$5[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors$5[obj.selector];
          });
        });
      }
      if (!_observer$5) {
        _observer$5 = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid$4()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors$5);
                selectors.forEach((sel) => {
                  if (matches$5(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors$5);
              selectors.forEach((sel) => {
                if (matches$5(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer$5.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  class SActivateComponentInterface$1 extends SInterface {
  }
  SActivateComponentInterface$1.definition = {
    target: {
      type: "String"
    },
    group: {
      type: "String"
    },
    toggle: {
      type: {
        type: "Boolean",
        nullishAsTrue: true
      },
      default: false
    },
    history: {
      type: {
        type: "Boolean",
        nullishAsTrue: true
      },
      default: false
    },
    active: {
      type: {
        type: "Boolean",
        nullishAsTrue: true
      },
      default: false
    },
    saveState: {
      type: "Boolean",
      default: false
    },
    trigger: {
      type: {
        type: "Array<String>",
        splitChars: [","]
      },
      default: ["click"]
    }
  };
  const Component$4 = {
    "css": ``,
    "exports": {
      $targets: void 0,
      $groupElements: void 0,
      targetSelector: void 0,
      onBeforeMount() {
        this.component = new SComponentUtils(this.root, this.props, {
          interface: SActivateComponentInterface$1
        });
        if (this.component.props.saveState) {
          if (!this.root.id)
            throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
          this.component.props.active = localStorage.getItem(`s-activate-state-${this.root.id}`) !== null;
        }
        if (this.component.props.target) {
          if (!this.component.props.target.match(/^(\.|\[])/)) {
            this.targetSelector = `#${this.component.props.target}`;
          } else {
            this.targetSelector = this.component.props.target;
          }
        }
      },
      onMounted() {
        const targets = Array.from(document.querySelectorAll(this.targetSelector));
        if (targets.length)
          this.$targets = targets;
        if (this.component.props.group) {
          this.$groupElements = Array.from(document.querySelectorAll(`s-activate[group="${this.component.props.group}"]`));
        }
        this.component.props.trigger.forEach((trigger) => {
          switch (trigger) {
            case "click":
              this.root.addEventListener("click", (e) => {
                if (this.isActive() && this.component.props.toggle) {
                  this.unactivate();
                } else {
                  this.activate();
                }
              });
              break;
            case "anchor":
              if (document.location.hash === this.targetSelector) {
                this.activate();
              }
              window.addEventListener("hashchange", (e) => {
                if (document.location.hash === this.targetSelector) {
                  this.activate();
                }
              });
              break;
          }
        });
        this.root.activate = this.activate.bind(this);
        this.root.unactivate = this.unactivate.bind(this);
        this.root.isActive = this.isActive.bind(this);
        if (this.component.props.active) {
          this.activate(true);
        }
      },
      isActive() {
        return this.root.hasAttribute("active");
      },
      activate(force = false) {
        if (!force && this.isActive())
          return;
        if (this.component.props.saveState) {
          if (!this.root.id)
            throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
          localStorage.setItem(`s-activate-state-${this.root.id}`, true);
        }
        if (this.component.props.history) {
          document.location.hash = this.targetSelector;
        }
        if (this.$groupElements) {
          this.$groupElements.forEach(($element) => {
            if ($element === this.root)
              return;
            try {
              $element.unactivate();
            } catch (e) {
            }
          });
        }
        this.root.setAttribute("active", true);
        if (this.$targets) {
          this.$targets.forEach(($target) => {
            $target.classList.add("active");
          });
        }
      },
      unactivate() {
        if (!this.isActive())
          return;
        if (this.component.props.saveState) {
          if (!this.root.id)
            throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
          localStorage.removeItem(`s-activate-state-${this.root.id}`);
        }
        this.root.removeAttribute("active");
        if (this.$targets) {
          this.$targets.forEach(($target) => {
            $target.classList.remove("active");
          });
        }
      }
    },
    "template": null,
    "name": "s-activate"
  };
  register("s-activate", Component$4);
  querySelectorLive$5("s-activate:not([s-mounted])", ($elm) => {
    const id = $elm.id || "s-activate-" + uniqid$4();
    $elm.setAttribute("id", id);
    mount("#" + id);
  });
  Component$4.mount = () => {
    mount("s-activate");
  };
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  function uniqid$3() {
    return uuid_1.v4();
  }
  function matches$4(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer$4;
  const _selectors$4 = {};
  function querySelectorLive$4(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid$3()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors$4[selector]) {
      _selectors$4[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors$4[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors$4[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors$4[obj.selector];
          });
        });
      }
      if (!_observer$4) {
        _observer$4 = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid$3()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors$4);
                selectors.forEach((sel) => {
                  if (matches$4(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors$4);
              selectors.forEach((sel) => {
                if (matches$4(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer$4.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  const Component$3 = {
    "css": null,
    "exports": {
      onBeforeMount() {
        this.component = new SComponentUtils(this.root, {});
      },
      setInnerHTML() {
        this.root.innerHTML = this.component.decodeHtml(this.props.html);
      },
      onMounted() {
        this.setInnerHTML();
      },
      onUpdated() {
        this.setInnerHTML();
      }
    },
    "template": null,
    "name": "s-raw-html"
  };
  register("s-raw-html", Component$3);
  querySelectorLive$4("s-raw-html:not([s-mounted])", ($elm) => {
    const id = $elm.id || "s-raw-html-" + uniqid$3();
    $elm.setAttribute("id", id);
    mount("#" + id);
  });
  Component$3.mount = () => {
    mount("s-raw-html");
  };
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  var react = {exports: {}};
  var react_development = {};
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  /** @license React v17.0.2
  * react.development.js
  *
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
  (function(exports) {
    {
      (function() {
        var _assign = objectAssign;
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          symbolFor("react.scope");
          symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentName(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape2("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (render.displayName == null) {
                  render.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (type.displayName == null) {
                  type.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name2 = getComponentName(ReactCurrentOwner.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            new Map([[frozenObject, null]]);
            new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.version = ReactVersion;
      })();
    }
  })(react_development);
  {
    react.exports = react_development;
  }
  var React = react.exports;
  function uniqid$2() {
    return uuid_1.v4();
  }
  function matches$3(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer$3;
  const _selectors$3 = {};
  function querySelectorLive$3(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid$2()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors$3[selector]) {
      _selectors$3[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors$3[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors$3[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors$3[obj.selector];
          });
        });
      }
      if (!_observer$3) {
        _observer$3 = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid$2()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors$3);
                selectors.forEach((sel) => {
                  if (matches$3(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors$3);
              selectors.forEach((sel) => {
                if (matches$3(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer$3.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  class SHighlightJsComponentInterface$2 extends SInterface {
  }
  SHighlightJsComponentInterface$2.definition = {
    value: {
      type: "String",
      default: ""
    },
    noItemText: {
      type: "String",
      default: "No item to display"
    },
    filtrable: {
      type: {
        type: "Array<String>",
        splitChars: [","]
      },
      default: []
    },
    closeTimeout: {
      type: "Number",
      default: 200
    },
    interactive: {
      type: "Boolean",
      default: false
    },
    notSelectable: {
      type: "Boolean",
      default: false
    },
    maxItems: {
      type: "Number",
      default: 25
    }
  };
  function clone$3(object, settings = {}) {
    settings = Object.assign({deep: false}, settings);
    if (settings.deep) {
      return __deepClone(object);
    }
    return __clone(object);
  }
  function scrollTop() {
    return window.pageYOffset || document.scrollTop || document.body.scrollTop;
  }
  function offset(elm) {
    const box = elm.getBoundingClientRect(), body = document.body, docEl = document.documentElement, scrollTop2 = window.pageYOffset || docEl.scrollTop || body.scrollTop, scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft, clientTop = docEl.clientTop || body.clientTop || 0, clientLeft = docEl.clientLeft || body.clientLeft || 0, top = box.top + scrollTop2 - clientTop, left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  }
  function fromElementTopToViewportBottom(elm) {
    const offsets = offset(elm);
    const scrollTop$1 = scrollTop();
    const viewportHeight = window.innerHeight;
    const distance = viewportHeight - offsets.top + scrollTop$1;
    return distance;
  }
  function camelize(text) {
    let res = "";
    const reg = /(?:^|[_-\s])(\w)/g;
    res = text.replace(reg, function(_, c) {
      return c ? c.toUpperCase() : "";
    });
    res = res.substr(0, 1).toLowerCase() + res.slice(1);
    return res.trim();
  }
  function autoCast(string) {
    if (typeof string !== "string")
      return string;
    if (string.substr(0, 1) === "'" && string.substr(-1) === "'") {
      return string.substr(1, string.length - 2);
    }
    const presumedNumber = parseFloat(string);
    if (!isNaN(presumedNumber)) {
      if (presumedNumber.toString() === string) {
        return presumedNumber;
      }
    }
    if (window[string]) {
      return string;
    }
    try {
      const obj = eval(`(${string})`);
      return obj;
    } catch (e) {
      return string;
    }
  }
  function getStyleProperty(elm, property) {
    setTimeout(() => {
      elm._sComputedStyle = null;
    });
    const computed = elm._sComputedStyle || window.getComputedStyle(elm);
    elm._sComputedStyle = computed;
    const prefixes = ["", "webkit-", "moz-", "ms-", "o-", "khtml-"];
    for (let i = 0; i < prefixes.length; i++) {
      const prefix = prefixes[i];
      const value = computed[camelize(`${prefix}${property}`)];
      if (value && value.trim() !== "")
        return autoCast(value);
    }
    return null;
  }
  function fromElementTopToViewportTop(elm) {
    const offsets = offset(elm);
    const scrollTop$1 = scrollTop();
    return offsets.top - scrollTop$1;
  }
  /*!
  * hotkeys-js v3.8.5
  * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
  * 
  * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
  * http://jaywcjlove.github.io/hotkeys
  * 
  * Licensed under the MIT license.
  */
  var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
  function addEvent(object, event2, method) {
    if (object.addEventListener) {
      object.addEventListener(event2, method, false);
    } else if (object.attachEvent) {
      object.attachEvent("on".concat(event2), function() {
        method(window.event);
      });
    }
  }
  function getMods(modifier, key) {
    var mods = key.slice(0, key.length - 1);
    for (var i = 0; i < mods.length; i++) {
      mods[i] = modifier[mods[i].toLowerCase()];
    }
    return mods;
  }
  function getKeys(key) {
    if (typeof key !== "string")
      key = "";
    key = key.replace(/\s/g, "");
    var keys = key.split(",");
    var index = keys.lastIndexOf("");
    for (; index >= 0; ) {
      keys[index - 1] += ",";
      keys.splice(index, 1);
      index = keys.lastIndexOf("");
    }
    return keys;
  }
  function compareArray(a1, a2) {
    var arr1 = a1.length >= a2.length ? a1 : a2;
    var arr2 = a1.length >= a2.length ? a2 : a1;
    var isIndex = true;
    for (var i = 0; i < arr1.length; i++) {
      if (arr2.indexOf(arr1[i]) === -1)
        isIndex = false;
    }
    return isIndex;
  }
  var _keyMap = {
    backspace: 8,
    tab: 9,
    clear: 12,
    enter: 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "\u21EA": 20,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "-": isff ? 173 : 189,
    "=": isff ? 61 : 187,
    ";": isff ? 59 : 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "\\": 220
  };
  var _modifier = {
    "\u21E7": 16,
    shift: 16,
    "\u2325": 18,
    alt: 18,
    option: 18,
    "\u2303": 17,
    ctrl: 17,
    control: 17,
    "\u2318": 91,
    cmd: 91,
    command: 91
  };
  var modifierMap = {
    16: "shiftKey",
    18: "altKey",
    17: "ctrlKey",
    91: "metaKey",
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  };
  var _mods = {
    16: false,
    18: false,
    17: false,
    91: false
  };
  var _handlers = {};
  for (var k = 1; k < 20; k++) {
    _keyMap["f".concat(k)] = 111 + k;
  }
  var _downKeys = [];
  var _scope = "all";
  var elementHasBindEvent = [];
  var code = function code2(x) {
    return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
  };
  function setScope(scope) {
    _scope = scope || "all";
  }
  function getScope() {
    return _scope || "all";
  }
  function getPressedKeyCodes() {
    return _downKeys.slice(0);
  }
  function filter(event2) {
    var target = event2.target || event2.srcElement;
    var tagName = target.tagName;
    var flag = true;
    if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
      flag = false;
    }
    return flag;
  }
  function isPressed(keyCode) {
    if (typeof keyCode === "string") {
      keyCode = code(keyCode);
    }
    return _downKeys.indexOf(keyCode) !== -1;
  }
  function deleteScope(scope, newScope) {
    var handlers;
    var i;
    if (!scope)
      scope = getScope();
    for (var key in _handlers) {
      if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
        handlers = _handlers[key];
        for (i = 0; i < handlers.length; ) {
          if (handlers[i].scope === scope)
            handlers.splice(i, 1);
          else
            i++;
        }
      }
    }
    if (getScope() === scope)
      setScope(newScope || "all");
  }
  function clearModifier(event2) {
    var key = event2.keyCode || event2.which || event2.charCode;
    var i = _downKeys.indexOf(key);
    if (i >= 0) {
      _downKeys.splice(i, 1);
    }
    if (event2.key && event2.key.toLowerCase() === "meta") {
      _downKeys.splice(0, _downKeys.length);
    }
    if (key === 93 || key === 224)
      key = 91;
    if (key in _mods) {
      _mods[key] = false;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = false;
      }
    }
  }
  function unbind(keysInfo) {
    if (!keysInfo) {
      Object.keys(_handlers).forEach(function(key) {
        return delete _handlers[key];
      });
    } else if (Array.isArray(keysInfo)) {
      keysInfo.forEach(function(info) {
        if (info.key)
          eachUnbind(info);
      });
    } else if (typeof keysInfo === "object") {
      if (keysInfo.key)
        eachUnbind(keysInfo);
    } else if (typeof keysInfo === "string") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var scope = args[0], method = args[1];
      if (typeof scope === "function") {
        method = scope;
        scope = "";
      }
      eachUnbind({
        key: keysInfo,
        scope,
        method,
        splitKey: "+"
      });
    }
  }
  var eachUnbind = function eachUnbind2(_ref) {
    var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
    var multipleKeys = getKeys(key);
    multipleKeys.forEach(function(originKey) {
      var unbindKeys = originKey.split(splitKey);
      var len = unbindKeys.length;
      var lastKey = unbindKeys[len - 1];
      var keyCode = lastKey === "*" ? "*" : code(lastKey);
      if (!_handlers[keyCode])
        return;
      if (!scope)
        scope = getScope();
      var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
      _handlers[keyCode] = _handlers[keyCode].map(function(record) {
        var isMatchingMethod = method ? record.method === method : true;
        if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
          return {};
        }
        return record;
      });
    });
  };
  function eventHandler(event2, handler, scope) {
    var modifiersMatch;
    if (handler.scope === scope || handler.scope === "all") {
      modifiersMatch = handler.mods.length > 0;
      for (var y in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, y)) {
          if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
            modifiersMatch = false;
          }
        }
      }
      if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
        if (handler.method(event2, handler) === false) {
          if (event2.preventDefault)
            event2.preventDefault();
          else
            event2.returnValue = false;
          if (event2.stopPropagation)
            event2.stopPropagation();
          if (event2.cancelBubble)
            event2.cancelBubble = true;
        }
      }
    }
  }
  function dispatch(event2) {
    var asterisk = _handlers["*"];
    var key = event2.keyCode || event2.which || event2.charCode;
    if (!hotkeys.filter.call(this, event2))
      return;
    if (key === 93 || key === 224)
      key = 91;
    if (_downKeys.indexOf(key) === -1 && key !== 229)
      _downKeys.push(key);
    ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
      var keyNum = modifierMap[keyName];
      if (event2[keyName] && _downKeys.indexOf(keyNum) === -1) {
        _downKeys.push(keyNum);
      } else if (!event2[keyName] && _downKeys.indexOf(keyNum) > -1) {
        _downKeys.splice(_downKeys.indexOf(keyNum), 1);
      } else if (keyName === "metaKey" && event2[keyName] && _downKeys.length === 3) {
        if (!(event2.ctrlKey || event2.shiftKey || event2.altKey)) {
          _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
        }
      }
    });
    if (key in _mods) {
      _mods[key] = true;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = true;
      }
      if (!asterisk)
        return;
    }
    for (var e in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, e)) {
        _mods[e] = event2[modifierMap[e]];
      }
    }
    if (event2.getModifierState && !(event2.altKey && !event2.ctrlKey) && event2.getModifierState("AltGraph")) {
      if (_downKeys.indexOf(17) === -1) {
        _downKeys.push(17);
      }
      if (_downKeys.indexOf(18) === -1) {
        _downKeys.push(18);
      }
      _mods[17] = true;
      _mods[18] = true;
    }
    var scope = getScope();
    if (asterisk) {
      for (var i = 0; i < asterisk.length; i++) {
        if (asterisk[i].scope === scope && (event2.type === "keydown" && asterisk[i].keydown || event2.type === "keyup" && asterisk[i].keyup)) {
          eventHandler(event2, asterisk[i], scope);
        }
      }
    }
    if (!(key in _handlers))
      return;
    for (var _i = 0; _i < _handlers[key].length; _i++) {
      if (event2.type === "keydown" && _handlers[key][_i].keydown || event2.type === "keyup" && _handlers[key][_i].keyup) {
        if (_handlers[key][_i].key) {
          var record = _handlers[key][_i];
          var splitKey = record.splitKey;
          var keyShortcut = record.key.split(splitKey);
          var _downKeysCurrent = [];
          for (var a2 = 0; a2 < keyShortcut.length; a2++) {
            _downKeysCurrent.push(code(keyShortcut[a2]));
          }
          if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
            eventHandler(event2, record, scope);
          }
        }
      }
    }
  }
  function isElementBind(element) {
    return elementHasBindEvent.indexOf(element) > -1;
  }
  function hotkeys(key, option, method) {
    _downKeys = [];
    var keys = getKeys(key);
    var mods = [];
    var scope = "all";
    var element = document;
    var i = 0;
    var keyup = false;
    var keydown = true;
    var splitKey = "+";
    if (method === void 0 && typeof option === "function") {
      method = option;
    }
    if (Object.prototype.toString.call(option) === "[object Object]") {
      if (option.scope)
        scope = option.scope;
      if (option.element)
        element = option.element;
      if (option.keyup)
        keyup = option.keyup;
      if (option.keydown !== void 0)
        keydown = option.keydown;
      if (typeof option.splitKey === "string")
        splitKey = option.splitKey;
    }
    if (typeof option === "string")
      scope = option;
    for (; i < keys.length; i++) {
      key = keys[i].split(splitKey);
      mods = [];
      if (key.length > 1)
        mods = getMods(_modifier, key);
      key = key[key.length - 1];
      key = key === "*" ? "*" : code(key);
      if (!(key in _handlers))
        _handlers[key] = [];
      _handlers[key].push({
        keyup,
        keydown,
        scope,
        mods,
        shortcut: keys[i],
        method,
        key: keys[i],
        splitKey
      });
    }
    if (typeof element !== "undefined" && !isElementBind(element) && window) {
      elementHasBindEvent.push(element);
      addEvent(element, "keydown", function(e) {
        dispatch(e);
      });
      addEvent(window, "focus", function() {
        _downKeys = [];
      });
      addEvent(element, "keyup", function(e) {
        dispatch(e);
        clearModifier(e);
      });
    }
  }
  var _api = {
    setScope,
    getScope,
    deleteScope,
    getPressedKeyCodes,
    isPressed,
    filter,
    unbind
  };
  for (var a in _api) {
    if (Object.prototype.hasOwnProperty.call(_api, a)) {
      hotkeys[a] = _api[a];
    }
  }
  if (typeof window !== "undefined") {
    var _hotkeys = window.hotkeys;
    hotkeys.noConflict = function(deep) {
      if (deep && window.hotkeys === hotkeys) {
        window.hotkeys = _hotkeys;
      }
      return hotkeys;
    };
    window.hotkeys = hotkeys;
  }
  var hotkeys_common = hotkeys;
  hotkeys_common.filter = function() {
    return true;
  };
  function hotkey(hotkey2, settings = {}) {
    return new SPromise(({resolve, reject, emit, cancel}) => {
      settings = Object.assign({element: null, keyup: false, keydown: true, once: false, splitKey: "+"}, settings);
      hotkeys_common(hotkey2, settings, (e, h) => {
        emit("press", e);
        if (settings.once)
          cancel();
      });
    }, {
      id: "hotkey"
    }).on("finally", () => {
      hotkeys_common.unbind(hotkey2);
    });
  }
  function stripTags(html) {
    const tmp = document.createElement("div");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
  }
  function onScrollEnd$1($elm, callback, settings) {
    const finalSettings = Object.assign({offset: 20, once: false, times: -1}, settings !== null && settings !== void 0 ? settings : {});
    let isBody = false;
    let $scrollListenedElm = $elm;
    let $scrollHeightElm = $elm;
    if ($elm === window.document.body) {
      isBody = true;
      $scrollListenedElm = document;
      $scrollHeightElm = window.document.body;
    } else if ($elm === window.document) {
      isBody = true;
      $elm = window.document.body;
      $scrollHeightElm = window.document.body;
    }
    let active = true, count = 0;
    const internalCallback = (e) => {
      let fullHeight, viewportHeight, scrollTop2;
      if (isBody) {
        viewportHeight = window.innerHeight;
        scrollTop2 = $scrollHeightElm.scrollTop;
        fullHeight = Math.max(window.document.body.scrollHeight, window.document.documentElement.scrollHeight, window.document.body.offsetHeight, window.document.documentElement.offsetHeight, window.document.body.clientHeight, window.document.documentElement.clientHeight);
      } else {
        viewportHeight = $scrollHeightElm.scrollHeight;
        scrollTop2 = $scrollHeightElm.scrollTop;
        fullHeight = $scrollHeightElm.scrollHeight;
      }
      if (active && scrollTop2 + viewportHeight >= fullHeight - finalSettings.offset) {
        callback();
        count++;
        if (finalSettings.once) {
          $scrollListenedElm.removeEventListener("scroll", internalCallback);
          active = false;
        } else if (finalSettings.times > 0 && count >= finalSettings.times) {
          $scrollListenedElm.removeEventListener("scroll", internalCallback);
          active = false;
        }
      } else if ($scrollHeightElm.offsetHeight + $scrollHeightElm.scrollTop < $scrollHeightElm.scrollHeight - finalSettings.offset) {
        active = true;
      }
    };
    $scrollListenedElm.addEventListener("scroll", internalCallback);
  }
  const Component$2 = {
    "css": ``,
    "exports": {
      $container: void 0,
      $list: void 0,
      $input: void 0,
      $itemTemplateElm: void 0,
      $noItemTemplateElm: void 0,
      $loadingTemplateElm: void 0,
      state: {
        itemTemplate: void 0,
        noItemTemplate: void 0,
        loadingTemplate: void 0,
        preselectedItemIdx: -1,
        selectedItemIdx: -1,
        displayedMaxItems: 0,
        value: "",
        isActive: false,
        isLoading: false,
        items: [],
        filteredItems: []
      },
      onBeforeMount() {
        this.component = new SComponentUtils(this.root, this.props, {
          interface: SHighlightJsComponentInterface$2
        });
        this.state.displayedMaxItems = this.component.props.maxItems;
        this.$itemTemplateElm = this.$("template#item");
        this.$noItemTemplateElm = this.$("template#no-item");
        this.$loadingTemplateElm = this.$("template#loading");
        this.$input = this.$("input");
        if (this.component.props.defaultStyle) {
          this.$input.classList.add("s-form-input");
        }
        if (this.$loadingTemplateElm) {
          this.state.loadingTemplate = this.$loadingTemplateElm.innerHTML;
        } else {
          this.state.loadingTemplate = `
              <div class="${this.component.className("__loading")}">
                  {{value}}
              </div>
          `;
        }
        if (this.$itemTemplateElm) {
          this.state.itemTemplate = this.$itemTemplateElm.innerHTML;
        } else {
          this.state.itemTemplate = `
              <div class="${this.component.className("__item")}">
                  {{value}}
              </div>
          `;
        }
        if (this.$noItemTemplateElm) {
          this.state.noItemTemplate = this.$noItemTemplateElm.innerHTML;
        } else {
          this.state.noItemTemplate = `
              <div class="${this.component.className("__no-item")}"> 
                  ${this.component.props.noItemText}
              </div>
          `;
        }
        if (!this.$input) {
          throw new Error(`<red>[s-filtrable-input]</red> In order to work you MUST have a valid input tag inside your s-filtrable-input component`);
        }
        this.$input.addEventListener("keyup", (e) => {
          const value = e.target.value;
          this.update({
            value,
            displayedMaxItems: this.component.props.maxItems
          });
          this.filterItems();
        });
        this.$input.classList.add(this.component.className("__input"));
        this.root.innerHTML = "";
      },
      onMounted() {
        this.$container = this.root.children[0];
        this.$list = this.root.querySelector("ul");
        this.root.prepend(this.$input);
        this.filterItems();
        Component$3.mount();
        document.addEventListener("scroll", this._updateListSizeAndPosition);
        this.$input.addEventListener("focus", (e) => {
          this.update({
            isActive: true
          });
          this.filterItems();
          this._updateListSizeAndPosition();
        });
        this._updateListSizeAndPosition();
        onScrollEnd$1(this.$list, () => {
          var _a;
          this.update({
            displayedMaxItems: ((_a = this.state.displayedMaxItems) != null ? _a : 0) + this.component.props.maxItems
          });
          this.filterItems(false);
        });
        hotkey("escape").on("press", (e) => {
          e.preventDefault();
          if (!this.state.isActive)
            return;
          this.close();
        });
        hotkey("up").on("press", (e) => {
          e.preventDefault();
          if (!this.state.isActive)
            return;
          this.update({
            preselectedItemIdx: this.state.preselectedItemIdx > 0 ? this.state.preselectedItemIdx - 1 : 0
          });
          const $item = this.$list.children[this.state.preselectedItemIdx];
          $item.focus();
        });
        hotkey("down").on("press", (e) => {
          e.preventDefault();
          if (!this.state.isActive)
            return;
          this.update({
            preselectedItemIdx: this.state.preselectedItemIdx >= this.state.filteredItems.length - 1 ? this.state.filteredItems.length - 1 : this.state.preselectedItemIdx + 1
          });
          const $item = this.$list.children[this.state.preselectedItemIdx];
          $item.focus();
        });
        hotkey("return").on("press", (e) => {
          if (!this.state.isActive)
            return;
          this._validateAndClose();
        });
      },
      get selectedItem() {
        if (this.state.selectedItemIdx === -1)
          return;
        return this.state.filteredItems[this.state.selectedItemIdx];
      },
      get preselectedItem() {
        if (this.state.preselectedItemIdx === -1)
          return;
        return this.state.filteredItems[this.state.preselectedItemIdx];
      },
      _validateAndClose() {
        if (!this.preselectedItem)
          return;
        if (this.preselectedItem && !this.preselectedItem[this.component.props.value]) {
          throw new Error(`<red>[s-filtrable-input]</red> Sorry but the property "<yellow>${this.component.props.value}</yellow>" does not exists on your selected item`);
        }
        this.$input.value = stripTags(this.preselectedItem[this.component.props.value]);
        this.update({
          selectedItemIdx: this.state.preselectedItemIdx,
          value: this.$input.value
        });
        setTimeout(() => {
          this.close();
        }, this.component.props.closeTimeout);
      },
      close() {
        this.$input.focus();
        this.$input.blur();
        this.update({
          isActive: false
        });
      },
      _selectAndValidate(idx) {
        this._setPreselectedItemIdx(idx);
        this._validateAndClose();
      },
      _setPreselectedItemIdx(idx) {
        if (this.component.props.notSelectable)
          return;
        this.update({
          preselectedItemIdx: idx
        });
      },
      _updateListSizeAndPosition() {
        if (!this.state.isActive)
          return;
        const marginTop = getStyleProperty(this.$list, "marginTop");
        getStyleProperty(this.$list, "marginLeft");
        getStyleProperty(this.$list, "marginRight");
        const marginBottom = getStyleProperty(this.$list, "marginBottom");
        const distanceTop = fromElementTopToViewportTop(this.$input);
        const distanceBottom = fromElementTopToViewportBottom(this.$input) - this.$input.clientHeight;
        let maxHeight;
        if (distanceTop > distanceBottom) {
          this.$container.classList.add("s-filtrable-input--top");
          this.$list.style.top = `auto`;
          this.$list.style.bottom = `calc(100% - ${marginBottom})`;
          maxHeight = distanceTop - parseInt(marginTop);
        } else {
          this.$container.classList.remove("s-filtrable-input--top");
          this.$list.style.bottom = `auto`;
          this.$list.style.top = `calc(100% - ${marginTop})`;
          maxHeight = distanceBottom - parseInt(marginBottom);
        }
        this.$list.style.maxHeight = `${maxHeight}px`;
      },
      filterItems(needUpdate = true) {
        return __async(this, null, function* () {
          let items = this.state.items;
          if (needUpdate) {
            try {
              this.update({
                isLoading: true
              });
              const res = yield this.component.dispatchSyncEvent("update", {
                value: this.$input.value
              });
              if (res && res.length)
                items = res;
              this.update({
                items: res,
                isLoading: false
              });
            } catch (e) {
            }
          }
          let matchedItemsCount = 0;
          const filteredItems = items.map((item) => clone$3(item)).filter((item) => {
            if (matchedItemsCount >= this.state.displayedMaxItems)
              return false;
            if (!this.component.props.filtrable.length)
              return true;
            let matchFilter = false;
            for (let i = 0; i < Object.keys(item).length; i++) {
              const propName = Object.keys(item)[i], propValue = item[propName];
              if (typeof propValue !== "string")
                continue;
              if (this.component.props.filtrable.indexOf(propName) !== -1) {
                const reg = new RegExp(this.state.value, "gi");
                if (propValue.match(reg)) {
                  matchFilter = true;
                  if (this.state.value && this.state.value !== "") {
                    const reg2 = new RegExp(this.state.value, "gi");
                    const finalString = propValue.replace(reg2, (str) => {
                      return `<span class="${this.component.className("__list-item-highlight")} s-highlight">${str}</span>`;
                    });
                    item[propName] = finalString;
                  }
                }
              }
            }
            if (matchFilter) {
              matchedItemsCount++;
            }
            return matchFilter;
          });
          this.update({
            filteredItems
          });
        });
      }
    },
    "template": function(template, expressionTypes, bindingTypes, getComponent) {
      return template('<ul expr0="expr0"><li expr1="expr1"></li><li expr3="expr3"></li><li expr5="expr5" hoverable></li></ul>', [
        {
          "expressions": [
            {
              "type": expressionTypes.ATTRIBUTE,
              "name": "interactive",
              "evaluate": function(scope) {
                return scope.component.props.interactive;
              }
            },
            {
              "type": expressionTypes.ATTRIBUTE,
              "name": "not-selectable",
              "evaluate": function(scope) {
                return scope.component.props.notSelectable;
              }
            }
          ]
        },
        {
          "redundantAttribute": "expr0",
          "selector": "[expr0]",
          "expressions": [
            {
              "type": expressionTypes.ATTRIBUTE,
              "name": "class",
              "evaluate": function(scope) {
                return scope.component.className("__list", "s-list:interactive");
              }
            }
          ]
        },
        {
          "type": bindingTypes.IF,
          "evaluate": function(scope) {
            return scope.state.isLoading;
          },
          "redundantAttribute": "expr1",
          "selector": "[expr1]",
          "template": template('<s-raw-html expr2="expr2"></s-raw-html>', [
            {
              "expressions": [
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "class",
                  "evaluate": function(scope) {
                    return scope.component.className("__list-item __list-loading");
                  }
                }
              ]
            },
            {
              "type": bindingTypes.TAG,
              "getComponent": getComponent,
              "evaluate": function(scope) {
                return "s-raw-html";
              },
              "slots": [],
              "attributes": [
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "html",
                  "evaluate": function(scope) {
                    return scope.component.compileMustache(scope.state.loadingTemplate, {
                      value: scope.state.value
                    });
                  }
                }
              ],
              "redundantAttribute": "expr2",
              "selector": "[expr2]"
            }
          ])
        },
        {
          "type": bindingTypes.IF,
          "evaluate": function(scope) {
            return !scope.state.isLoading && scope.state.filteredItems.length <= 0;
          },
          "redundantAttribute": "expr3",
          "selector": "[expr3]",
          "template": template('<s-raw-html expr4="expr4"></s-raw-html>', [
            {
              "expressions": [
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "class",
                  "evaluate": function(scope) {
                    return scope.component.className("__list-item __list-no-item");
                  }
                }
              ]
            },
            {
              "type": bindingTypes.TAG,
              "getComponent": getComponent,
              "evaluate": function(scope) {
                return "s-raw-html";
              },
              "slots": [],
              "attributes": [
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "html",
                  "evaluate": function(scope) {
                    return scope.component.compileMustache(scope.state.noItemTemplate, {
                      value: scope.state.value
                    });
                  }
                }
              ],
              "redundantAttribute": "expr4",
              "selector": "[expr4]"
            }
          ])
        },
        {
          "type": bindingTypes.EACH,
          "getKey": null,
          "condition": function(scope) {
            return !scope.state.isLoading && scope.state.filteredItems.length;
          },
          "template": template('<s-raw-html expr6="expr6"></s-raw-html>', [
            {
              "expressions": [
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "style",
                  "evaluate": function(scope) {
                    return [
                      "z-index: ",
                      999999999 - scope.idx
                    ].join("");
                  }
                },
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "tabindex",
                  "evaluate": function(scope) {
                    return scope.state.isActive ? scope.idx : -1;
                  }
                },
                {
                  "type": expressionTypes.EVENT,
                  "name": "onfocus",
                  "evaluate": function(scope) {
                    return () => scope._setPreselectedItemIdx(scope.idx);
                  }
                },
                {
                  "type": expressionTypes.EVENT,
                  "name": "ondblclick",
                  "evaluate": function(scope) {
                    return () => scope._selectAndValidate(scope.idx);
                  }
                },
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "class",
                  "evaluate": function(scope) {
                    return scope.component.className("__list-item") + " " + (scope.state.selectedItemIdx === scope.idx ? "active" : "");
                  }
                }
              ]
            },
            {
              "type": bindingTypes.TAG,
              "getComponent": getComponent,
              "evaluate": function(scope) {
                return "s-raw-html";
              },
              "slots": [],
              "attributes": [
                {
                  "type": expressionTypes.ATTRIBUTE,
                  "name": "html",
                  "evaluate": function(scope) {
                    return scope.component.renderHandlebars(scope.state.itemTemplate, scope.item);
                  }
                }
              ],
              "redundantAttribute": "expr6",
              "selector": "[expr6]"
            }
          ]),
          "redundantAttribute": "expr5",
          "selector": "[expr5]",
          "itemName": "item",
          "indexName": "idx",
          "evaluate": function(scope) {
            return scope.state.filteredItems;
          }
        }
      ]);
    },
    "name": "s-filtrable-input"
  };
  register("s-filtrable-input", Component$2);
  querySelectorLive$3("s-filtrable-input:not([s-mounted])", ($elm) => {
    const id = $elm.id || "s-filtrable-input-" + uniqid$2();
    $elm.setAttribute("id", id);
    mount("#" + id);
  });
  Component$2.mount = () => {
    mount("s-filtrable-input");
  };
  class MyComponent extends React.Component {
    render() {
      return /* @__PURE__ */ React.createElement("s-filtrable-input", __spreadValues({}, this.props), this.props.children);
    }
    componentDidMount() {
      Component$2.mount();
    }
  }
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  var axios$2 = {exports: {}};
  var bind$2 = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString$1 = Object.prototype.toString;
  function isArray$2(val) {
    return toString$1.call(val) === "[object Array]";
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString$1.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject$2(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (toString$1.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString$1.call(val) === "[object Date]";
  }
  function isFile$1(val) {
    return toString$1.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString$1.call(val) === "[object Blob]";
  }
  function isFunction$2(val) {
    return toString$1.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject$2(val) && isFunction$2(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.replace(/^\s*/, "").replace(/\s*$/, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$2(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge$1() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge$1(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge$1({}, val);
      } else if (isArray$2(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend$1(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  var utils$e = {
    isArray: isArray$2,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject: isObject$2,
    isPlainObject,
    isUndefined,
    isDate,
    isFile: isFile$1,
    isBlob,
    isFunction: isFunction$2,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge: merge$1,
    extend: extend$1,
    trim,
    stripBOM
  };
  var utils$d = utils$e;
  function encode$1(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$d.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$d.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$d.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$d.forEach(val, function parseValue(v) {
          if (utils$d.isDate(v)) {
            v = v.toISOString();
          } else if (utils$d.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode$1(key) + "=" + encode$1(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  var utils$c = utils$e;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled,
      rejected
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach(fn) {
    utils$c.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$b = utils$e;
  var transformData$1 = function transformData(data, headers, fns) {
    utils$b.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };
  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
  var utils$a = utils$e;
  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$a.forEach(headers, function processHeader(value, name2) {
      if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name2];
      }
    });
  };
  var enhanceError$1 = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
  var enhanceError = enhanceError$1;
  var createError$2 = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };
  var createError$1 = createError$2;
  var settle$1 = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
  };
  var utils$9 = utils$e;
  var cookies$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils$9.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$9.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$9.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  var isAbsoluteURL$1 = function isAbsoluteURL(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  var isAbsoluteURL = isAbsoluteURL$1;
  var combineURLs = combineURLs$1;
  var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  };
  var utils$8 = utils$e;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils$8.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils$8.trim(line.substr(0, i)).toLowerCase();
      val = utils$8.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  var utils$7 = utils$e;
  var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      var parsed = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();
  var utils$6 = utils$e;
  var settle = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath = buildFullPath$1;
  var parseHeaders = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var createError = createError$2;
  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      if (utils$6.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(resolve, reject, response);
        request = null;
      };
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(createError("Request aborted", config, "ECONNABORTED", request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(createError("Network Error", config, null, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
        request = null;
      };
      if (utils$6.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request) {
        utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request.setRequestHeader(key, val);
          }
        });
      }
      if (!utils$6.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          if (config.responseType !== "json") {
            throw e;
          }
        }
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }
          request.abort();
          reject(cancel);
          request = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request.send(requestData);
    });
  };
  var utils$5 = utils$e;
  var normalizeHeaderName = normalizeHeaderName$1;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = xhr;
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = xhr;
    }
    return adapter;
  }
  var defaults$3 = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, "Accept");
      normalizeHeaderName(headers, "Content-Type");
      if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
        return data;
      }
      if (utils$5.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$5.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils$5.isObject(data)) {
        setContentTypeIfUnset(headers, "application/json;charset=utf-8");
        return JSON.stringify(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch (e) {
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults$3.headers = {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  };
  utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;
  var utils$4 = utils$e;
  var transformData = transformData$1;
  var isCancel = isCancel$1;
  var defaults$2 = defaults_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData(config.data, config.headers, config.transformRequest);
    config.headers = utils$4.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$4.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$2.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$3 = utils$e;
  var mergeConfig$2 = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source) {
      if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source)) {
        return utils$3.merge(target, source);
      } else if (utils$3.isPlainObject(source)) {
        return utils$3.merge({}, source);
      } else if (utils$3.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils$3.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils$3.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils$3.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils$3.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils$3.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
  var utils$2 = utils$e;
  var buildURL = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var chain = [dispatchRequest, void 0];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    Axios$1.prototype[method] = function(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data
      }));
    };
  });
  var Axios_1 = Axios$1;
  function Cancel$1(message) {
    this.message = message;
  }
  Cancel$1.prototype.toString = function toString() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel$1.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel$1;
  var Cancel = Cancel_1;
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  var CancelToken_1 = CancelToken;
  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  var isAxiosError = function isAxiosError(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  var utils$1 = utils$e;
  var bind = bind$2;
  var Axios = Axios_1;
  var mergeConfig = mergeConfig$2;
  var defaults$1 = defaults_1;
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    utils$1.extend(instance, Axios.prototype, context);
    utils$1.extend(instance, context);
    return instance;
  }
  var axios$1 = createInstance(defaults$1);
  axios$1.Axios = Axios;
  axios$1.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
  };
  axios$1.Cancel = Cancel_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1;
  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$1.spread = spread;
  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1;
  axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  function strToHtml(string) {
    if (document !== void 0 && document.createElement !== void 0) {
      const cont = document.createElement("div");
      cont.innerHTML = string;
      if (cont.children.length === 1) {
        return cont.children[0];
      } else {
        return cont;
      }
    }
    return string;
  }
  function toStringFn(html, deep = true) {
    if (document !== void 0 && document.createElement !== void 0) {
      const cont = document.createElement("div");
      cont.appendChild(html.cloneNode(deep));
      return cont.innerHTML;
    }
    return html;
  }
  function convert$1(from, to = "ms") {
    let fromMs = from;
    if (typeof from === "string") {
      const fromNumber = parseFloat(from);
      const fromLength = fromNumber.toString().length;
      const fromString = from.slice(fromLength);
      if (fromString === "ms" || fromString === "millisecond" || fromString === "milliseconds") {
        fromMs = fromNumber;
      } else if (fromString === "s" || fromString === "second" || fromString === "seconds") {
        fromMs = fromNumber * 1e3;
      } else if (fromString === "m" || fromString === "minute" || fromString === "minutes") {
        fromMs = fromNumber * 60 * 1e3;
      } else if (fromString === "h" || fromString === "hour" || fromString === "hours") {
        fromMs = fromNumber * 60 * 60 * 1e3;
      } else if (fromString === "d" || fromString === "day" || fromString === "days") {
        fromMs = fromNumber * 24 * 60 * 60 * 1e3;
      } else if (fromString === "w" || fromString === "week" || fromString === "weeks") {
        fromMs = fromNumber * 7 * 24 * 60 * 60 * 1e3;
      } else if (fromString === "month" || fromString === "months") {
        fromMs = fromNumber * 31 * 24 * 60 * 60 * 1e3;
      } else if (fromString === "y" || fromString === "year" || fromString === "years") {
        fromMs = fromNumber * 365 * 24 * 60 * 60 * 1e3;
      }
    }
    switch (to) {
      case "ms":
      case "millisecond":
      case "milliseconds":
        return fromMs;
      case "s":
      case "second":
      case "seconds":
        return fromMs / 1e3;
      case "m":
      case "minute":
      case "minutes":
        return fromMs / 1e3 / 60;
      case "h":
      case "hour":
      case "hours":
        return fromMs / 1e3 / 60 / 60;
      case "d":
      case "day":
      case "days":
        return fromMs / 1e3 / 60 / 60 / 24;
      case "w":
      case "week":
      case "weeks":
        return fromMs / 1e3 / 60 / 60 / 24 / 7;
      case "month":
      case "months":
        return fromMs / 1e3 / 60 / 60 / 24 / 31;
      case "y":
      case "year":
      case "years":
        return fromMs / 1e3 / 60 / 60 / 24 / 365;
      default:
        throw new Error(`You try to convert "${from}" to "${to}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`);
    }
  }
  convert$1.MILLISECOND = "ms";
  convert$1.SECOND = "s";
  convert$1.MINUTE = "m";
  convert$1.HOUR = "h";
  convert$1.DAY = "d";
  convert$1.WEEK = "w";
  convert$1.MONTH = "month";
  convert$1.YEAR = "y";
  class SRequestConfig {
    constructor(params) {
      this.url = null;
      this.baseURL = null;
      this.method = "GET";
      this.headers = {};
      this.params = {};
      this.data = {};
      this.timeout = 0;
      this.sendInterval = 1e3;
      this.sendCount = 1;
      this.everyResponse = null;
      this.responseType = "json";
      if (params.timeout && typeof params.timeout === "string")
        params.timeout = convert$1(params.timeout, "ms");
      if (params.sendInterval && typeof params.sendInterval === "string")
        params.sendInterval = convert$1(params.sendInterval, "ms");
      Object.assign(this, params);
    }
  }
  class SRequest extends SClass {
    constructor(request, settings) {
      super(deepMerge$2({
        request: {}
      }, settings !== null && settings !== void 0 ? settings : {}));
      this._defaultRequestSettings = {};
      this._currentRequestSettings = {};
      this._requestsCount = 0;
      if (!(request instanceof SRequestConfig)) {
        this._defaultRequestSettings = new SRequestConfig(request);
      } else {
        this._defaultRequestSettings = request;
      }
    }
    get requestSettings() {
      return this._settings.request;
    }
    _onSuccess(response) {
      let finalResponse = response.data;
      const contentType = response.headers["content-type"] || "text/plain";
      const hash = this._currentRequestSettings.url.indexOf("#") !== -1 ? this._currentRequestSettings.url.split("#")[1] : false;
      if (contentType === "text/html" && hash !== false && document !== void 0 && document.querySelector !== void 0) {
        const $html = strToHtml(response.data);
        if ($html.id === hash) {
          finalResponse = toStringFn($html);
        } else {
          const $part = $html.querySelector(`#${hash}`);
          if ($part) {
            finalResponse = toStringFn($part);
          }
        }
      } else if (contentType === "application/json") {
        finalResponse = JSON.parse(response.data);
      }
      response.data = finalResponse;
      delete response.config;
      delete response.request;
      this._responsesArray.push(response);
      if (this._currentRequestSettings.everyResponse) {
        this._currentRequestSettings.everyResponse(Object.assign({}, response), this._requestsCount);
      }
      if (this._requestsCount >= this._currentRequestSettings.sendCount) {
        this._resolve(this._responsesArray.length <= 1 ? this._responsesArray[0] : this._responsesArray);
      } else {
        this._send();
      }
    }
    _onError(error) {
      console.log("EEE", error);
      this._reject(error);
    }
    _send(requestSettings = {}) {
      this._requestsCount++;
      requestSettings = deepMerge$2(this._defaultRequestSettings, requestSettings);
      if (requestSettings.beforeSend) {
        requestSettings = requestSettings.beforeSend(requestSettings, this._requestsCount);
      }
      this._currentRequestSettings = Object.assign(requestSettings);
      axios(requestSettings).then(this._onSuccess.bind(this)).catch(this._onError.bind(this));
    }
    retry() {
      return this.send();
    }
    send(requestSettings = {}) {
      return new Promise((resolve, reject) => {
        this._requestsCount = 0;
        this._responsesArray = [];
        this._resolve = resolve;
        this._reject = reject;
        this._send(requestSettings);
      });
    }
  }
  let scriptRel;
  const seen = {};
  const __vitePreload = function preload(baseModule, deps) {
    if (true) {
      return baseModule();
    }
    if (scriptRel === void 0) {
      const relList = document.createElement("link").relList;
      scriptRel = relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
    }
    return Promise.all(deps.map((dep) => {
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", rej);
        });
      }
    })).then(() => baseModule());
  };
  function classInstance$1(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name === "Object")
      return false;
    if (Object.prototype.toString.call(object) === "[object Object]")
      return false;
    if (object.constructor === Object)
      return false;
    return true;
  }
  function deepMap$1(objectOrArray, processor, settings = {}, _path = []) {
    settings = deepMerge$1({
      classInstances: false,
      array: true,
      privateProps: false,
      cloneFirst: true
    }, settings);
    const isArray = Array.isArray(objectOrArray);
    const newObject = isArray ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
    Object.keys(objectOrArray).forEach((prop) => {
      if (!settings.privateProps && prop.match(/^_/))
        return;
      if (plainObject$1(objectOrArray[prop]) || classInstance$1(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
        const res2 = deepMap$1(objectOrArray[prop], processor, settings, [
          ..._path,
          prop
        ]);
        if (isArray) {
          newObject.push(res2);
        } else {
          newObject[prop] = res2;
        }
        return;
      }
      const res = processor({
        object: objectOrArray,
        prop,
        value: objectOrArray[prop],
        path: [..._path, prop].join(".")
      });
      if (res === -1) {
        delete objectOrArray[prop];
        return;
      }
      if (isArray)
        newObject.push(res);
      else
        newObject[prop] = res;
    });
    return newObject;
  }
  function isMap$1(value) {
    return value instanceof Map;
  }
  function isArray$1(value) {
    return value && typeof value === "object" && value.constructor === Array;
  }
  function isBoolean$1(value) {
    return typeof value === "boolean";
  }
  function isFunction$1(value) {
    return value && {}.toString.call(value) === "[object Function]";
  }
  function isJson$1(value) {
    try {
      const res = JSON.parse(value);
      if (Object.keys(res).length)
        return true;
      return false;
    } catch (e) {
      return false;
    }
    return true;
  }
  function isObject$1(value) {
    return value && typeof value === "object" && value.constructor === Object;
  }
  function mapToObject$1(map) {
    const obj = {};
    for (const [k, v] of map)
      obj[k] = v;
    return obj;
  }
  function fn$2(value, settings = {}) {
    settings = deepMerge$1({
      beautify: true,
      highlight: true,
      verbose: true,
      theme: {
        number: source$2.yellow,
        default: source$2.white,
        keyword: source$2.blue,
        regexp: source$2.red,
        string: source$2.whiteBright,
        class: source$2.yellow,
        function: source$2.yellow,
        comment: source$2.gray,
        variable: source$2.red,
        attr: source$2.green
      }
    }, settings);
    if (typeof value === "string")
      return value;
    if (value === null)
      return null;
    if (value === void 0)
      return void 0;
    if (value instanceof Error) {
      const errorStr = value.toString();
      const stackStr = value.stack;
      const messageStr = value.message;
      if (settings.verbose) {
        return [
          `<red>${value.constructor.name || "Error"}</red>`,
          "",
          messageStr,
          "",
          stackStr
        ].join("\n");
      }
      return errorStr;
    }
    if (isMap$1(value)) {
      value = mapToObject$1(value);
    }
    if (isObject$1(value) || isArray$1(value) || isJson$1(value)) {
      try {
        value = decycle_1(value);
      } catch (e) {
      }
      value = deepMap$1(value, ({value: value2}) => {
        if (value2 instanceof Map)
          return mapToObject$1(value2);
        return value2;
      });
      let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
      prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
      if (settings.highlight)
        ;
      return prettyString;
    }
    if (isBoolean$1(value)) {
      if (value)
        return "true";
      else
        return "false";
    }
    if (isFunction$1(value)) {
      return "" + value;
    }
    let returnString = "";
    try {
      value = decycle_1(value);
      returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    } catch (e) {
      try {
        returnString = value.toString();
      } catch (e2) {
        returnString = value;
      }
    }
    return returnString;
  }
  var parse$2 = (value) => {
    if (typeof value !== "string")
      return value;
    value = value.split("\u2800").join("").trim();
    try {
      return Function(`
      "use strict";
      return (${value});
    `)();
    } catch (e) {
      return value;
    }
  };
  const __encryptedMessages$1 = {};
  var __md5$1 = {
    encrypt: function(message) {
      if (typeof message !== "string")
        message = fn$2(message);
      const string = md5$2(message).toString();
      __encryptedMessages$1[string] = message;
      return string;
    },
    decrypt: function(message) {
      if (!__encryptedMessages$1[message]) {
        console.warn(`The message "${message}" cannot be decrypted...`);
        return;
      }
      const string = __encryptedMessages$1[message];
      delete __encryptedMessages$1[message];
      return parse$2(string);
    }
  };
  function cls(cls) {
    if (!Array.isArray(cls))
      cls = [cls];
    for (let i = 0; i < cls.length; i++) {
      if (!__isClass(cls[i]))
        return false;
    }
    return true;
  }
  function convert(from, to = "ms") {
    let fromMs = from;
    if (typeof from === "string") {
      const fromNumber = parseFloat(from);
      const fromLength = fromNumber.toString().length;
      const fromString = from.slice(fromLength);
      if (fromString === "ms" || fromString === "millisecond" || fromString === "milliseconds") {
        fromMs = fromNumber;
      } else if (fromString === "s" || fromString === "second" || fromString === "seconds") {
        fromMs = fromNumber * 1e3;
      } else if (fromString === "m" || fromString === "minute" || fromString === "minutes") {
        fromMs = fromNumber * 60 * 1e3;
      } else if (fromString === "h" || fromString === "hour" || fromString === "hours") {
        fromMs = fromNumber * 60 * 60 * 1e3;
      } else if (fromString === "d" || fromString === "day" || fromString === "days") {
        fromMs = fromNumber * 24 * 60 * 60 * 1e3;
      } else if (fromString === "w" || fromString === "week" || fromString === "weeks") {
        fromMs = fromNumber * 7 * 24 * 60 * 60 * 1e3;
      } else if (fromString === "month" || fromString === "months") {
        fromMs = fromNumber * 31 * 24 * 60 * 60 * 1e3;
      } else if (fromString === "y" || fromString === "year" || fromString === "years") {
        fromMs = fromNumber * 365 * 24 * 60 * 60 * 1e3;
      }
    }
    switch (to) {
      case "ms":
      case "millisecond":
      case "milliseconds":
        return fromMs;
      case "s":
      case "second":
      case "seconds":
        return fromMs / 1e3;
      case "m":
      case "minute":
      case "minutes":
        return fromMs / 1e3 / 60;
      case "h":
      case "hour":
      case "hours":
        return fromMs / 1e3 / 60 / 60;
      case "d":
      case "day":
      case "days":
        return fromMs / 1e3 / 60 / 60 / 24;
      case "w":
      case "week":
      case "weeks":
        return fromMs / 1e3 / 60 / 60 / 24 / 7;
      case "month":
      case "months":
        return fromMs / 1e3 / 60 / 60 / 24 / 31;
      case "y":
      case "year":
      case "years":
        return fromMs / 1e3 / 60 / 60 / 24 / 365;
      default:
        throw new Error(`You try to convert "${from}" to "${to}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`);
    }
  }
  convert.MILLISECOND = "ms";
  convert.SECOND = "s";
  convert.MINUTE = "m";
  convert.HOUR = "h";
  convert.DAY = "d";
  convert.WEEK = "w";
  convert.MONTH = "month";
  convert.YEAR = "y";
  class SCacheAdapter$1 extends SClass {
    constructor(settings = {}) {
      super(deepMerge$1({
        cacheAdapter: {}
      }, settings));
    }
    setCache(cache) {
      this.cache = cache;
    }
  }
  var __awaiter$7 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SCacheLsAdapter extends SCacheAdapter$1 {
    constructor(settings = {}) {
      super(deepMerge$1({}, settings));
    }
    set(name2, value) {
      return __awaiter$7(this, void 0, void 0, function* () {
        window.localStorage.setItem(`${this.cache.id}.${name2}`, value);
        return true;
      });
    }
    get(name2) {
      return __awaiter$7(this, void 0, void 0, function* () {
        return window.localStorage.getItem(`${this.cache.id}.${name2}`);
      });
    }
    delete(name2) {
      return __awaiter$7(this, void 0, void 0, function* () {
        window.localStorage.removeItem(`${this.cache.id}.${name2}`);
        return true;
      });
    }
    clear() {
      return __awaiter$7(this, void 0, void 0, function* () {
        const keys = Object.keys(window.localStorage);
        const keysToDelete = keys.filter((key) => {
          return key.startsWith(`${this.cache.id}.`);
        });
        keysToDelete.forEach((k) => {
          window.localStorage.removeItem(k);
        });
        return true;
      });
    }
    keys() {
      return __awaiter$7(this, void 0, void 0, function* () {
        const keys = Object.keys(window.localStorage);
        const cacheKeys = keys.filter((key) => {
          return key.startsWith(`${this.cache.id}.`);
        });
        return cacheKeys;
      });
    }
  }
  SCacheLsAdapter.id = "ls";
  var __isNode = () => {
    return typeof process !== "undefined" && process.release && process.release.name === "node";
  };
  class SCacheSettingsInterface extends SInterface {
  }
  SCacheSettingsInterface.definition = {
    name: {
      type: "String",
      required: true,
      default: "SCache"
    },
    ttl: {
      type: "Number",
      required: true,
      default: -1
    },
    deleteOnExpire: {
      type: "Boolean",
      required: true,
      default: true
    },
    adapter: {
      type: "String",
      required: true,
      default: __isNode() ? "fs" : "ls"
    },
    parse: {
      type: "Function",
      required: true,
      default: JSON.parse
    },
    stringify: {
      type: "Function",
      required: true,
      default: JSON.stringify
    }
  };
  var __awaiter$6 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SCache extends SClass {
    constructor(id, settings = {}) {
      super(deepMerge$1({
        cache: {
          clearOnExit: false
        }
      }, settings));
      this.id = id;
      (() => __awaiter$6(this, void 0, void 0, function* () {
        if (__isNode$1()) {
          this.constructor.registerAdapter((yield __vitePreload(() => Promise.resolve().then(function() {
            return SCacheFsAdapter$1;
          }), false ? "__VITE_PRELOAD__" : void 0)).default);
          if (this.cacheSettings.clearOnExit) {
            const {default: __onProcessExit} = yield __vitePreload(() => Promise.resolve().then(function() {
              return onProcessExit$1;
            }), false ? "__VITE_PRELOAD__" : void 0);
            const {default: __parseHtml} = yield __vitePreload(() => Promise.resolve().then(function() {
              return parseHtml$1;
            }), false ? "__VITE_PRELOAD__" : void 0);
            __onProcessExit(() => __awaiter$6(this, void 0, void 0, function* () {
              console.log(__parseHtml(`<yellow>[${this.constructor.name}.${this.id}]</yellow> Clearing the cache`));
              yield this.clear();
            }));
          }
        } else {
          this.constructor.registerAdapter(SCacheLsAdapter);
        }
      }))();
      if (!id) {
        throw new Error(`The SCache instance need an id. To set it, pass the "id" as the first argument of the constructor...`);
      }
      if (!/^[a-zA-Z0-9-_\.]+$/.test(id)) {
        throw new Error(`The name of an SCache instance can contain only letters like <green>[a-zA-Z0-9_-.]</green> but you've passed "<red>${name}</red>"...`);
      }
    }
    get cacheSettings() {
      return this._settings.cache;
    }
    static registerAdapter(adapter, id) {
      if (this.registeredAdapters[id || adapter.id])
        return;
      this.registeredAdapters[id || adapter.id] = adapter;
    }
    get adapter() {
      if (this._adapter)
        return this._adapter;
      const adptr = this.constructor.registeredAdapters[this.cacheSettings.adapter];
      if (!adptr) {
        throw `Sorry but it seems that the requested SCache adapter "<yellow>${this.cacheSettings.adapter}</yellow>" does not exists...`;
      }
      if (cls(adptr)) {
        this._adapter = new adptr();
      } else if (adptr !== void 0) {
        this._adapter = adptr;
      }
      this._adapter && this._adapter.setCache(this);
      return this._adapter;
    }
    get(name2, settings) {
      return __awaiter$6(this, void 0, void 0, function* () {
        const set = Object.assign({valueOnly: true}, settings || {});
        if (typeof name2 !== "string") {
          name2 = __md5$1.encrypt(fn$2(name2));
        }
        const adapter = this.adapter;
        const rawValue = yield adapter.get(name2);
        if (!rawValue || typeof rawValue !== "string")
          return null;
        const value = adapter.parse ? adapter.parse(rawValue) : this._parse(rawValue);
        let contextHash = void 0;
        if (set.context !== void 0)
          contextHash = __md5$1.encrypt(set.context);
        if (contextHash && value.contextHash !== void 0 && contextHash !== value.contextHash) {
          yield adapter.delete(name2);
          return null;
        }
        if (value.deleteAt !== -1 && value.deleteAt < new Date().getTime()) {
          if (value.deleteOnExpire)
            yield adapter.delete(name2);
          return null;
        }
        if (set.valueOnly)
          return value.value;
        return value;
      });
    }
    set(name2, value, settings) {
      return __awaiter$6(this, void 0, void 0, function* () {
        const set = Object.assign({}, settings || {});
        if (typeof name2 !== "string") {
          name2 = __md5$1.encrypt(fn$2(name2)).toString();
        }
        let contextHash = null;
        if (set.context !== void 0) {
          contextHash = __md5$1.encrypt(set.context);
        }
        const adapter = this.adapter;
        const existingValue = yield this.get(name2, Object.assign(Object.assign({}, set), {valueOnly: false}));
        const finalSettings = deepMerge$1({
          ttl: this.cacheSettings.ttl,
          deleteOnExpire: this.cacheSettings.deleteOnExpire
        }, set);
        const deleteAt = finalSettings.ttl === -1 ? -1 : new Date().getTime() + convert(typeof finalSettings.ttl === "number" ? `${finalSettings.ttl}s` : finalSettings.ttl, "ms");
        const valueToSave = {
          name: name2,
          value,
          contextHash,
          created: existingValue ? existingValue.created : new Date().getTime(),
          updated: new Date().getTime(),
          deleteAt,
          settings: finalSettings
        };
        const stringifiedValueToSave = adapter.stringify ? adapter.stringify(valueToSave) : this._stringify(valueToSave);
        return adapter.set(name2, stringifiedValueToSave);
      });
    }
    exists(name2) {
      return __awaiter$6(this, void 0, void 0, function* () {
        const value = yield this.get(name2);
        if (value)
          return true;
        return false;
      });
    }
    delete(name2) {
      return __awaiter$6(this, void 0, void 0, function* () {
        const adapter = this.adapter;
        return adapter.delete(name2);
      });
    }
    clear() {
      return __awaiter$6(this, void 0, void 0, function* () {
        const adapter = this.adapter;
        return adapter.clear();
      });
    }
    _parse(rawValue) {
      return this.cacheSettings.parse(rawValue);
    }
    _stringify(object) {
      return this.cacheSettings.stringify(object);
    }
  }
  SCache.interfaces = {
    settings: {
      apply: true,
      on: "_settings.cache",
      class: SCacheSettingsInterface
    }
  };
  SCache.registeredAdapters = {};
  function uniqid$1() {
    return uuid_1.v4();
  }
  function matches$2(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer$2;
  const _selectors$2 = {};
  function querySelectorLive$2(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid$1()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors$2[selector]) {
      _selectors$2[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors$2[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors$2[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors$2[obj.selector];
          });
        });
      }
      if (!_observer$2) {
        _observer$2 = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid$1()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors$2);
                selectors.forEach((sel) => {
                  if (matches$2(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors$2);
              selectors.forEach((sel) => {
                if (matches$2(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer$2.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  class SActivateComponentInterface extends SInterface {
  }
  SActivateComponentInterface.definition = {
    method: {
      type: "String",
      values: ["get", "post"],
      default: "get"
    },
    url: {
      type: "String",
      required: true
    },
    trigger: {
      type: "String",
      values: ["event"],
      default: "event"
    },
    on: {
      type: "String"
    },
    cache: {
      type: "String|Boolean",
      default: false
    }
  };
  var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getAugmentedNamespace$1(n) {
    if (n.__esModule)
      return n;
    var a = Object.defineProperty({}, "__esModule", {value: true});
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var md5$1 = {exports: {}};
  var core$2 = {exports: {}};
  var __viteBrowserExternal_crypto = new Proxy({}, {
    get() {
      throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_crypto$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_crypto});
  var require$$0$5 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_crypto$1);
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal$1, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal$1 !== "undefined" && commonjsGlobal$1.crypto) {
          crypto2 = commonjsGlobal$1.crypto;
        }
        if (!crypto2 && typeof require === "function") {
          try {
            crypto2 = require$$0$5;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  })(core$2);
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(core$2.exports);
      }
    })(commonjsGlobal$1, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5$1);
  var md5 = md5$1.exports;
  function plainObject(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function unique(array) {
    const a = array.concat();
    for (let i = 0; i < a.length; ++i) {
      for (let j = i + 1; j < a.length; ++j) {
        if (a[i] === a[j])
          a.splice(j--, 1);
      }
    }
    return a;
  }
  function deepMerge(...args) {
    const settings = {
      array: false,
      object: true
    };
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      copyTo(firstObj).override(newObj);
      for (const key of Object.keys(secondObj)) {
        if (settings.array === true && Array.isArray(firstObj[key]) && Array.isArray(secondObj[key])) {
          const newArray = unique([...firstObj[key], ...secondObj[key]]);
          newObj[key] = newArray;
          continue;
        } else if (settings.object === true && plainObject(firstObj[key]) && plainObject(secondObj[key])) {
          newObj[key] = merge(firstObj[key], secondObj[key]);
          continue;
        }
        copyTo(secondObj).pick(key).toCover(newObj);
      }
      return newObj;
    }
    const potentialSettingsObj = args[args.length - 1] || {};
    if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
      if (potentialSettingsObj.array !== void 0)
        settings.array = potentialSettingsObj.array;
      if (potentialSettingsObj.object !== void 0)
        settings.object = potentialSettingsObj.object;
      args.pop();
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i] || {};
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  function classInstance(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name === "Object")
      return false;
    if (Object.prototype.toString.call(object) === "[object Object]")
      return false;
    if (object.constructor === Object)
      return false;
    return true;
  }
  function deepMap(objectOrArray, processor, settings = {}, _path = []) {
    settings = deepMerge({
      classInstances: false,
      array: true,
      privateProps: false,
      cloneFirst: true
    }, settings);
    const isArray2 = Array.isArray(objectOrArray);
    const newObject = isArray2 ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
    Object.keys(objectOrArray).forEach((prop) => {
      if (!settings.privateProps && prop.match(/^_/))
        return;
      if (plainObject(objectOrArray[prop]) || classInstance(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
        const res2 = deepMap(objectOrArray[prop], processor, settings, [
          ..._path,
          prop
        ]);
        if (isArray2) {
          newObject.push(res2);
        } else {
          newObject[prop] = res2;
        }
        return;
      }
      const res = processor({
        object: objectOrArray,
        prop,
        value: objectOrArray[prop],
        path: [..._path, prop].join(".")
      });
      if (res === -1) {
        delete objectOrArray[prop];
        return;
      }
      if (isArray2)
        newObject.push(res);
      else
        newObject[prop] = res;
    });
    return newObject;
  }
  function isMap(value) {
    return value instanceof Map;
  }
  function isArray(value) {
    return value && typeof value === "object" && value.constructor === Array;
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isFunction(value) {
    return value && {}.toString.call(value) === "[object Function]";
  }
  function isJson(value) {
    try {
      const res = JSON.parse(value);
      if (Object.keys(res).length)
        return true;
      return false;
    } catch (e) {
      return false;
    }
    return true;
  }
  function isObject(value) {
    return value && typeof value === "object" && value.constructor === Object;
  }
  function mapToObject(map) {
    const obj = {};
    for (const [k, v] of map)
      obj[k] = v;
    return obj;
  }
  function fn$1(value, settings = {}) {
    settings = deepMerge({
      beautify: true,
      highlight: true,
      verbose: true,
      theme: {
        number: source$2.yellow,
        default: source$2.white,
        keyword: source$2.blue,
        regexp: source$2.red,
        string: source$2.whiteBright,
        class: source$2.yellow,
        function: source$2.yellow,
        comment: source$2.gray,
        variable: source$2.red,
        attr: source$2.green
      }
    }, settings);
    if (typeof value === "string")
      return value;
    if (value === null)
      return null;
    if (value === void 0)
      return void 0;
    if (value instanceof Error) {
      const errorStr = value.toString();
      const stackStr = value.stack;
      const messageStr = value.message;
      if (settings.verbose) {
        return [
          `<red>${value.constructor.name || "Error"}</red>`,
          "",
          messageStr,
          "",
          stackStr
        ].join("\n");
      }
      return errorStr;
    }
    if (isMap(value)) {
      value = mapToObject(value);
    }
    if (isObject(value) || isArray(value) || isJson(value)) {
      try {
        value = decycle_1(value);
      } catch (e) {
      }
      value = deepMap(value, ({value: value2}) => {
        if (value2 instanceof Map)
          return mapToObject(value2);
        return value2;
      });
      let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
      prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
      if (settings.highlight)
        ;
      return prettyString;
    }
    if (isBoolean(value)) {
      if (value)
        return "true";
      else
        return "false";
    }
    if (isFunction(value)) {
      return "" + value;
    }
    let returnString = "";
    try {
      value = decycle_1(value);
      returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    } catch (e) {
      try {
        returnString = value.toString();
      } catch (e2) {
        returnString = value;
      }
    }
    return returnString;
  }
  var parse$1 = (value) => {
    if (typeof value !== "string")
      return value;
    value = value.split("\u2800").join("").trim();
    try {
      return Function(`
      "use strict";
      return (${value});
    `)();
    } catch (e) {
      return value;
    }
  };
  const __encryptedMessages = {};
  var __md5 = {
    encrypt: function(message) {
      if (typeof message !== "string")
        message = fn$1(message);
      const string = md5(message).toString();
      __encryptedMessages[string] = message;
      return string;
    },
    decrypt: function(message) {
      if (!__encryptedMessages[message]) {
        console.warn(`The message "${message}" cannot be decrypted...`);
        return;
      }
      const string = __encryptedMessages[message];
      delete __encryptedMessages[message];
      return parse$1(string);
    }
  };
  const Component$1 = {
    "css": ``,
    "exports": {
      _inlineProxyObj: void 0,
      onBeforeMount() {
        return __async(this, null, function* () {
          this.component = new SComponentUtils(this.root, this.props, {
            interface: SActivateComponentInterface
          });
          const $script = this.root.querySelector("script");
          if ($script) {
            const id = uniqid$1();
            let scriptText = $script.innerText.trim();
            scriptText = scriptText.replace(/^export default /, `window['${`s-request-script-${id}`}'] = `);
            const $newScript = document.createElement("script");
            $newScript.text = scriptText;
            $script.parentNode.insertBefore($newScript, $script);
            $script.remove();
            this._inlineProxyObj = window[`s-request-script-${id}`];
          }
          if (this.component.props.cache) {
            this._cache = new SCache("s-request");
          }
          this.root.request = this.request.bind(this);
          this.root.getData = this.getData.bind(this);
        });
      },
      getData(payload) {
        return __async(this, null, function* () {
          return this.request(payload);
        });
      },
      request(data) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          let payload = {
            type: (_a = this.component.props.type) != null ? _a : "get",
            url: this.component.props.url,
            data,
            headers: {
              "Cache-Control": "no-cache",
              "Pragma": "no-cache",
              "Expires": "0"
            }
          };
          if ((_b = this._inlineProxyObj) == null ? void 0 : _b.request) {
            payload = this._inlineProxyObj.request(payload);
          }
          const cacheHash = __md5.encrypt(payload);
          const request = new SRequest(payload);
          let res = yield request.send();
          for (let i = 0; i < 2; i++) {
            try {
              if (this.component.props.cache !== false) {
                yield this._cache.set(cacheHash, res.data, {
                  ttl: typeof this.component.props.cache === "string" ? this.component.props.cache : -1
                });
              }
              break;
            } catch (e) {
              this._cache.clear();
            }
          }
          if ((_c = this._inlineProxyObj) == null ? void 0 : _c.response) {
            res = this._inlineProxyObj.response(res);
          }
          if (res.data && res.status && res.headers)
            res = res.data;
          return res;
        });
      },
      onMounted() {
      }
    },
    "template": null,
    "name": "s-request"
  };
  register("s-request", Component$1);
  querySelectorLive$2("s-request:not([s-mounted])", ($elm) => {
    const id = $elm.id || "s-request-" + uniqid$1();
    $elm.setAttribute("id", id);
    mount("#" + id);
  });
  Component$1.mount = () => {
    mount("s-request");
  };
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
  const removeNodes = (container, start, end = null) => {
    while (start !== end) {
      const n = start.nextSibling;
      container.removeChild(start);
      start = n;
    }
  };
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
  const nodeMarker = `<!--${marker}-->`;
  const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
  const boundAttributeSuffix = "$lit$";
  class Template {
    constructor(result, element) {
      this.parts = [];
      this.element = element;
      const nodesToRemove = [];
      const stack = [];
      const walker = document.createTreeWalker(element.content, 133, null, false);
      let lastPartIndex = 0;
      let index = -1;
      let partIndex = 0;
      const {strings, values: {length}} = result;
      while (partIndex < length) {
        const node = walker.nextNode();
        if (node === null) {
          walker.currentNode = stack.pop();
          continue;
        }
        index++;
        if (node.nodeType === 1) {
          if (node.hasAttributes()) {
            const attributes = node.attributes;
            const {length: length2} = attributes;
            let count = 0;
            for (let i = 0; i < length2; i++) {
              if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                count++;
              }
            }
            while (count-- > 0) {
              const stringForPart = strings[partIndex];
              const name2 = lastAttributeNameRegex.exec(stringForPart)[2];
              const attributeLookupName = name2.toLowerCase() + boundAttributeSuffix;
              const attributeValue = node.getAttribute(attributeLookupName);
              node.removeAttribute(attributeLookupName);
              const statics = attributeValue.split(markerRegex);
              this.parts.push({type: "attribute", index, name: name2, strings: statics});
              partIndex += statics.length - 1;
            }
          }
          if (node.tagName === "TEMPLATE") {
            stack.push(node);
            walker.currentNode = node.content;
          }
        } else if (node.nodeType === 3) {
          const data = node.data;
          if (data.indexOf(marker) >= 0) {
            const parent = node.parentNode;
            const strings2 = data.split(markerRegex);
            const lastIndex = strings2.length - 1;
            for (let i = 0; i < lastIndex; i++) {
              let insert;
              let s = strings2[i];
              if (s === "") {
                insert = createMarker();
              } else {
                const match = lastAttributeNameRegex.exec(s);
                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                  s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                }
                insert = document.createTextNode(s);
              }
              parent.insertBefore(insert, node);
              this.parts.push({type: "node", index: ++index});
            }
            if (strings2[lastIndex] === "") {
              parent.insertBefore(createMarker(), node);
              nodesToRemove.push(node);
            } else {
              node.data = strings2[lastIndex];
            }
            partIndex += lastIndex;
          }
        } else if (node.nodeType === 8) {
          if (node.data === marker) {
            const parent = node.parentNode;
            if (node.previousSibling === null || index === lastPartIndex) {
              index++;
              parent.insertBefore(createMarker(), node);
            }
            lastPartIndex = index;
            this.parts.push({type: "node", index});
            if (node.nextSibling === null) {
              node.data = "";
            } else {
              nodesToRemove.push(node);
              index--;
            }
            partIndex++;
          } else {
            let i = -1;
            while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
              this.parts.push({type: "node", index: -1});
              partIndex++;
            }
          }
        }
      }
      for (const n of nodesToRemove) {
        n.parentNode.removeChild(n);
      }
    }
  }
  const endsWith = (str, suffix) => {
    const index = str.length - suffix.length;
    return index >= 0 && str.slice(index) === suffix;
  };
  const isTemplatePartActive = (part) => part.index !== -1;
  const createMarker = () => document.createComment("");
  const lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const walkerNodeFilter = 133;
  function removeNodesFromTemplate(template, nodesToRemove) {
    const {element: {content}, parts} = template;
    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
    let partIndex = nextActiveIndexInTemplateParts(parts);
    let part = parts[partIndex];
    let nodeIndex = -1;
    let removeCount = 0;
    const nodesToRemoveInTemplate = [];
    let currentRemovingNode = null;
    while (walker.nextNode()) {
      nodeIndex++;
      const node = walker.currentNode;
      if (node.previousSibling === currentRemovingNode) {
        currentRemovingNode = null;
      }
      if (nodesToRemove.has(node)) {
        nodesToRemoveInTemplate.push(node);
        if (currentRemovingNode === null) {
          currentRemovingNode = node;
        }
      }
      if (currentRemovingNode !== null) {
        removeCount++;
      }
      while (part !== void 0 && part.index === nodeIndex) {
        part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
        partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
        part = parts[partIndex];
      }
    }
    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
  }
  const countNodes = (node) => {
    let count = node.nodeType === 11 ? 0 : 1;
    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
    while (walker.nextNode()) {
      count++;
    }
    return count;
  };
  const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
    for (let i = startIndex + 1; i < parts.length; i++) {
      const part = parts[i];
      if (isTemplatePartActive(part)) {
        return i;
      }
    }
    return -1;
  };
  function insertNodeIntoTemplate(template, node, refNode = null) {
    const {element: {content}, parts} = template;
    if (refNode === null || refNode === void 0) {
      content.appendChild(node);
      return;
    }
    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
    let partIndex = nextActiveIndexInTemplateParts(parts);
    let insertCount = 0;
    let walkerIndex = -1;
    while (walker.nextNode()) {
      walkerIndex++;
      const walkerNode = walker.currentNode;
      if (walkerNode === refNode) {
        insertCount = countNodes(node);
        refNode.parentNode.insertBefore(node, refNode);
      }
      while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
        if (insertCount > 0) {
          while (partIndex !== -1) {
            parts[partIndex].index += insertCount;
            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
          }
          return;
        }
        partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
      }
    }
  }
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const directives = new WeakMap();
  const isDirective = (o) => {
    return typeof o === "function" && directives.has(o);
  };
  /**
  * @license
  * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const noChange = {};
  const nothing = {};
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  class TemplateInstance {
    constructor(template, processor, options) {
      this.__parts = [];
      this.template = template;
      this.processor = processor;
      this.options = options;
    }
    update(values) {
      let i = 0;
      for (const part of this.__parts) {
        if (part !== void 0) {
          part.setValue(values[i]);
        }
        i++;
      }
      for (const part of this.__parts) {
        if (part !== void 0) {
          part.commit();
        }
      }
    }
    _clone() {
      const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
      const stack = [];
      const parts = this.template.parts;
      const walker = document.createTreeWalker(fragment, 133, null, false);
      let partIndex = 0;
      let nodeIndex = 0;
      let part;
      let node = walker.nextNode();
      while (partIndex < parts.length) {
        part = parts[partIndex];
        if (!isTemplatePartActive(part)) {
          this.__parts.push(void 0);
          partIndex++;
          continue;
        }
        while (nodeIndex < part.index) {
          nodeIndex++;
          if (node.nodeName === "TEMPLATE") {
            stack.push(node);
            walker.currentNode = node.content;
          }
          if ((node = walker.nextNode()) === null) {
            walker.currentNode = stack.pop();
            node = walker.nextNode();
          }
        }
        if (part.type === "node") {
          const part2 = this.processor.handleTextExpression(this.options);
          part2.insertAfterNode(node.previousSibling);
          this.__parts.push(part2);
        } else {
          this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
        }
        partIndex++;
      }
      if (isCEPolyfill) {
        document.adoptNode(fragment);
        customElements.upgrade(fragment);
      }
      return fragment;
    }
  }
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", {createHTML: (s) => s});
  const commentMarker = ` ${marker} `;
  class TemplateResult {
    constructor(strings, values, type, processor) {
      this.strings = strings;
      this.values = values;
      this.type = type;
      this.processor = processor;
    }
    getHTML() {
      const l = this.strings.length - 1;
      let html = "";
      let isCommentBinding = false;
      for (let i = 0; i < l; i++) {
        const s = this.strings[i];
        const commentOpen = s.lastIndexOf("<!--");
        isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf("-->", commentOpen + 1) === -1;
        const attributeMatch = lastAttributeNameRegex.exec(s);
        if (attributeMatch === null) {
          html += s + (isCommentBinding ? commentMarker : nodeMarker);
        } else {
          html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
        }
      }
      html += this.strings[l];
      return html;
    }
    getTemplateElement() {
      const template = document.createElement("template");
      let value = this.getHTML();
      if (policy !== void 0) {
        value = policy.createHTML(value);
      }
      template.innerHTML = value;
      return template;
    }
  }
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const isPrimitive = (value) => {
    return value === null || !(typeof value === "object" || typeof value === "function");
  };
  const isIterable = (value) => {
    return Array.isArray(value) || !!(value && value[Symbol.iterator]);
  };
  class AttributeCommitter {
    constructor(element, name2, strings) {
      this.dirty = true;
      this.element = element;
      this.name = name2;
      this.strings = strings;
      this.parts = [];
      for (let i = 0; i < strings.length - 1; i++) {
        this.parts[i] = this._createPart();
      }
    }
    _createPart() {
      return new AttributePart(this);
    }
    _getValue() {
      const strings = this.strings;
      const l = strings.length - 1;
      const parts = this.parts;
      if (l === 1 && strings[0] === "" && strings[1] === "") {
        const v = parts[0].value;
        if (typeof v === "symbol") {
          return String(v);
        }
        if (typeof v === "string" || !isIterable(v)) {
          return v;
        }
      }
      let text = "";
      for (let i = 0; i < l; i++) {
        text += strings[i];
        const part = parts[i];
        if (part !== void 0) {
          const v = part.value;
          if (isPrimitive(v) || !isIterable(v)) {
            text += typeof v === "string" ? v : String(v);
          } else {
            for (const t of v) {
              text += typeof t === "string" ? t : String(t);
            }
          }
        }
      }
      text += strings[l];
      return text;
    }
    commit() {
      if (this.dirty) {
        this.dirty = false;
        this.element.setAttribute(this.name, this._getValue());
      }
    }
  }
  class AttributePart {
    constructor(committer) {
      this.value = void 0;
      this.committer = committer;
    }
    setValue(value) {
      if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
        this.value = value;
        if (!isDirective(value)) {
          this.committer.dirty = true;
        }
      }
    }
    commit() {
      while (isDirective(this.value)) {
        const directive = this.value;
        this.value = noChange;
        directive(this);
      }
      if (this.value === noChange) {
        return;
      }
      this.committer.commit();
    }
  }
  class NodePart {
    constructor(options) {
      this.value = void 0;
      this.__pendingValue = void 0;
      this.options = options;
    }
    appendInto(container) {
      this.startNode = container.appendChild(createMarker());
      this.endNode = container.appendChild(createMarker());
    }
    insertAfterNode(ref) {
      this.startNode = ref;
      this.endNode = ref.nextSibling;
    }
    appendIntoPart(part) {
      part.__insert(this.startNode = createMarker());
      part.__insert(this.endNode = createMarker());
    }
    insertAfterPart(ref) {
      ref.__insert(this.startNode = createMarker());
      this.endNode = ref.endNode;
      ref.endNode = this.startNode;
    }
    setValue(value) {
      this.__pendingValue = value;
    }
    commit() {
      if (this.startNode.parentNode === null) {
        return;
      }
      while (isDirective(this.__pendingValue)) {
        const directive = this.__pendingValue;
        this.__pendingValue = noChange;
        directive(this);
      }
      const value = this.__pendingValue;
      if (value === noChange) {
        return;
      }
      if (isPrimitive(value)) {
        if (value !== this.value) {
          this.__commitText(value);
        }
      } else if (value instanceof TemplateResult) {
        this.__commitTemplateResult(value);
      } else if (value instanceof Node) {
        this.__commitNode(value);
      } else if (isIterable(value)) {
        this.__commitIterable(value);
      } else if (value === nothing) {
        this.value = nothing;
        this.clear();
      } else {
        this.__commitText(value);
      }
    }
    __insert(node) {
      this.endNode.parentNode.insertBefore(node, this.endNode);
    }
    __commitNode(value) {
      if (this.value === value) {
        return;
      }
      this.clear();
      this.__insert(value);
      this.value = value;
    }
    __commitText(value) {
      const node = this.startNode.nextSibling;
      value = value == null ? "" : value;
      const valueAsString = typeof value === "string" ? value : String(value);
      if (node === this.endNode.previousSibling && node.nodeType === 3) {
        node.data = valueAsString;
      } else {
        this.__commitNode(document.createTextNode(valueAsString));
      }
      this.value = value;
    }
    __commitTemplateResult(value) {
      const template = this.options.templateFactory(value);
      if (this.value instanceof TemplateInstance && this.value.template === template) {
        this.value.update(value.values);
      } else {
        const instance = new TemplateInstance(template, value.processor, this.options);
        const fragment = instance._clone();
        instance.update(value.values);
        this.__commitNode(fragment);
        this.value = instance;
      }
    }
    __commitIterable(value) {
      if (!Array.isArray(this.value)) {
        this.value = [];
        this.clear();
      }
      const itemParts = this.value;
      let partIndex = 0;
      let itemPart;
      for (const item of value) {
        itemPart = itemParts[partIndex];
        if (itemPart === void 0) {
          itemPart = new NodePart(this.options);
          itemParts.push(itemPart);
          if (partIndex === 0) {
            itemPart.appendIntoPart(this);
          } else {
            itemPart.insertAfterPart(itemParts[partIndex - 1]);
          }
        }
        itemPart.setValue(item);
        itemPart.commit();
        partIndex++;
      }
      if (partIndex < itemParts.length) {
        itemParts.length = partIndex;
        this.clear(itemPart && itemPart.endNode);
      }
    }
    clear(startNode = this.startNode) {
      removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
    }
  }
  class BooleanAttributePart {
    constructor(element, name2, strings) {
      this.value = void 0;
      this.__pendingValue = void 0;
      if (strings.length !== 2 || strings[0] !== "" || strings[1] !== "") {
        throw new Error("Boolean attributes can only contain a single expression");
      }
      this.element = element;
      this.name = name2;
      this.strings = strings;
    }
    setValue(value) {
      this.__pendingValue = value;
    }
    commit() {
      while (isDirective(this.__pendingValue)) {
        const directive = this.__pendingValue;
        this.__pendingValue = noChange;
        directive(this);
      }
      if (this.__pendingValue === noChange) {
        return;
      }
      const value = !!this.__pendingValue;
      if (this.value !== value) {
        if (value) {
          this.element.setAttribute(this.name, "");
        } else {
          this.element.removeAttribute(this.name);
        }
        this.value = value;
      }
      this.__pendingValue = noChange;
    }
  }
  class PropertyCommitter extends AttributeCommitter {
    constructor(element, name2, strings) {
      super(element, name2, strings);
      this.single = strings.length === 2 && strings[0] === "" && strings[1] === "";
    }
    _createPart() {
      return new PropertyPart(this);
    }
    _getValue() {
      if (this.single) {
        return this.parts[0].value;
      }
      return super._getValue();
    }
    commit() {
      if (this.dirty) {
        this.dirty = false;
        this.element[this.name] = this._getValue();
      }
    }
  }
  class PropertyPart extends AttributePart {
  }
  let eventOptionsSupported = false;
  (() => {
    try {
      const options = {
        get capture() {
          eventOptionsSupported = true;
          return false;
        }
      };
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (_e) {
    }
  })();
  class EventPart {
    constructor(element, eventName, eventContext) {
      this.value = void 0;
      this.__pendingValue = void 0;
      this.element = element;
      this.eventName = eventName;
      this.eventContext = eventContext;
      this.__boundHandleEvent = (e) => this.handleEvent(e);
    }
    setValue(value) {
      this.__pendingValue = value;
    }
    commit() {
      while (isDirective(this.__pendingValue)) {
        const directive = this.__pendingValue;
        this.__pendingValue = noChange;
        directive(this);
      }
      if (this.__pendingValue === noChange) {
        return;
      }
      const newListener = this.__pendingValue;
      const oldListener = this.value;
      const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
      const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
      if (shouldRemoveListener) {
        this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
      }
      if (shouldAddListener) {
        this.__options = getOptions(newListener);
        this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
      }
      this.value = newListener;
      this.__pendingValue = noChange;
    }
    handleEvent(event2) {
      if (typeof this.value === "function") {
        this.value.call(this.eventContext || this.element, event2);
      } else {
        this.value.handleEvent(event2);
      }
    }
  }
  const getOptions = (o) => o && (eventOptionsSupported ? {capture: o.capture, passive: o.passive, once: o.once} : o.capture);
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  function templateFactory(result) {
    let templateCache = templateCaches.get(result.type);
    if (templateCache === void 0) {
      templateCache = {
        stringsArray: new WeakMap(),
        keyString: new Map()
      };
      templateCaches.set(result.type, templateCache);
    }
    let template = templateCache.stringsArray.get(result.strings);
    if (template !== void 0) {
      return template;
    }
    const key = result.strings.join(marker);
    template = templateCache.keyString.get(key);
    if (template === void 0) {
      template = new Template(result, result.getTemplateElement());
      templateCache.keyString.set(key, template);
    }
    templateCache.stringsArray.set(result.strings, template);
    return template;
  }
  const templateCaches = new Map();
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const parts = new WeakMap();
  const render$1 = (result, container, options) => {
    let part = parts.get(container);
    if (part === void 0) {
      removeNodes(container, container.firstChild);
      parts.set(container, part = new NodePart(Object.assign({templateFactory}, options)));
      part.appendInto(container);
    }
    part.setValue(result);
    part.commit();
  };
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  class DefaultTemplateProcessor {
    handleAttributeExpressions(element, name2, strings, options) {
      const prefix = name2[0];
      if (prefix === ".") {
        const committer2 = new PropertyCommitter(element, name2.slice(1), strings);
        return committer2.parts;
      }
      if (prefix === "@") {
        return [new EventPart(element, name2.slice(1), options.eventContext)];
      }
      if (prefix === "?") {
        return [new BooleanAttributePart(element, name2.slice(1), strings)];
      }
      const committer = new AttributeCommitter(element, name2, strings);
      return committer.parts;
    }
    handleTextExpression(options) {
      return new NodePart(options);
    }
  }
  const defaultTemplateProcessor = new DefaultTemplateProcessor();
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  if (typeof window !== "undefined") {
    (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
  }
  const html = (strings, ...values) => new TemplateResult(strings, values, "html", defaultTemplateProcessor);
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
  let compatibleShadyCSSVersion = true;
  if (typeof window.ShadyCSS === "undefined") {
    compatibleShadyCSSVersion = false;
  } else if (typeof window.ShadyCSS.prepareTemplateDom === "undefined") {
    console.warn(`Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`);
    compatibleShadyCSSVersion = false;
  }
  const shadyTemplateFactory = (scopeName) => (result) => {
    const cacheKey = getTemplateCacheKey(result.type, scopeName);
    let templateCache = templateCaches.get(cacheKey);
    if (templateCache === void 0) {
      templateCache = {
        stringsArray: new WeakMap(),
        keyString: new Map()
      };
      templateCaches.set(cacheKey, templateCache);
    }
    let template = templateCache.stringsArray.get(result.strings);
    if (template !== void 0) {
      return template;
    }
    const key = result.strings.join(marker);
    template = templateCache.keyString.get(key);
    if (template === void 0) {
      const element = result.getTemplateElement();
      if (compatibleShadyCSSVersion) {
        window.ShadyCSS.prepareTemplateDom(element, scopeName);
      }
      template = new Template(result, element);
      templateCache.keyString.set(key, template);
    }
    templateCache.stringsArray.set(result.strings, template);
    return template;
  };
  const TEMPLATE_TYPES = ["html", "svg"];
  const removeStylesFromLitTemplates = (scopeName) => {
    TEMPLATE_TYPES.forEach((type) => {
      const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
      if (templates !== void 0) {
        templates.keyString.forEach((template) => {
          const {element: {content}} = template;
          const styles = new Set();
          Array.from(content.querySelectorAll("style")).forEach((s) => {
            styles.add(s);
          });
          removeNodesFromTemplate(template, styles);
        });
      }
    });
  };
  const shadyRenderSet = new Set();
  const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
    shadyRenderSet.add(scopeName);
    const templateElement = !!template ? template.element : document.createElement("template");
    const styles = renderedDOM.querySelectorAll("style");
    const {length} = styles;
    if (length === 0) {
      window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
      return;
    }
    const condensedStyle = document.createElement("style");
    for (let i = 0; i < length; i++) {
      const style2 = styles[i];
      style2.parentNode.removeChild(style2);
      condensedStyle.textContent += style2.textContent;
    }
    removeStylesFromLitTemplates(scopeName);
    const content = templateElement.content;
    if (!!template) {
      insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
    } else {
      content.insertBefore(condensedStyle, content.firstChild);
    }
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    const style = content.querySelector("style");
    if (window.ShadyCSS.nativeShadow && style !== null) {
      renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
    } else if (!!template) {
      content.insertBefore(condensedStyle, content.firstChild);
      const removes = new Set();
      removes.add(condensedStyle);
      removeNodesFromTemplate(template, removes);
    }
  };
  const render = (result, container, options) => {
    if (!options || typeof options !== "object" || !options.scopeName) {
      throw new Error("The `scopeName` option is required.");
    }
    const scopeName = options.scopeName;
    const hasRendered = parts.has(container);
    const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
    render$1(result, renderContainer, Object.assign({templateFactory: shadyTemplateFactory(scopeName)}, options));
    if (firstScopeRender) {
      const part = parts.get(renderContainer);
      parts.delete(renderContainer);
      const template = part.value instanceof TemplateInstance ? part.value.template : void 0;
      prepareTemplateStyles(scopeName, renderContainer, template);
      removeNodes(container, container.firstChild);
      container.appendChild(renderContainer);
      parts.set(container, part);
    }
    if (!hasRendered && needsScoping) {
      window.ShadyCSS.styleElement(container.host);
    }
  };
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  var _a$1;
  window.JSCompiler_renameProperty = (prop, _obj) => prop;
  const defaultConverter = {
    toAttribute(value, type) {
      switch (type) {
        case Boolean:
          return value ? "" : null;
        case Object:
        case Array:
          return value == null ? value : JSON.stringify(value);
      }
      return value;
    },
    fromAttribute(value, type) {
      switch (type) {
        case Boolean:
          return value !== null;
        case Number:
          return value === null ? null : Number(value);
        case Object:
        case Array:
          return JSON.parse(value);
      }
      return value;
    }
  };
  const notEqual = (value, old) => {
    return old !== value && (old === old || value === value);
  };
  const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual
  };
  const STATE_HAS_UPDATED = 1;
  const STATE_UPDATE_REQUESTED = 1 << 2;
  const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
  const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
  const finalized = "finalized";
  class UpdatingElement extends HTMLElement {
    constructor() {
      super();
      this.initialize();
    }
    static get observedAttributes() {
      this.finalize();
      const attributes = [];
      this._classProperties.forEach((v, p) => {
        const attr = this._attributeNameForProperty(p, v);
        if (attr !== void 0) {
          this._attributeToPropertyMap.set(attr, p);
          attributes.push(attr);
        }
      });
      return attributes;
    }
    static _ensureClassProperties() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
        this._classProperties = new Map();
        const superProperties = Object.getPrototypeOf(this)._classProperties;
        if (superProperties !== void 0) {
          superProperties.forEach((v, k) => this._classProperties.set(k, v));
        }
      }
    }
    static createProperty(name2, options = defaultPropertyDeclaration) {
      this._ensureClassProperties();
      this._classProperties.set(name2, options);
      if (options.noAccessor || this.prototype.hasOwnProperty(name2)) {
        return;
      }
      const key = typeof name2 === "symbol" ? Symbol() : `__${name2}`;
      const descriptor = this.getPropertyDescriptor(name2, key, options);
      if (descriptor !== void 0) {
        Object.defineProperty(this.prototype, name2, descriptor);
      }
    }
    static getPropertyDescriptor(name2, key, options) {
      return {
        get() {
          return this[key];
        },
        set(value) {
          const oldValue = this[name2];
          this[key] = value;
          this.requestUpdateInternal(name2, oldValue, options);
        },
        configurable: true,
        enumerable: true
      };
    }
    static getPropertyOptions(name2) {
      return this._classProperties && this._classProperties.get(name2) || defaultPropertyDeclaration;
    }
    static finalize() {
      const superCtor = Object.getPrototypeOf(this);
      if (!superCtor.hasOwnProperty(finalized)) {
        superCtor.finalize();
      }
      this[finalized] = true;
      this._ensureClassProperties();
      this._attributeToPropertyMap = new Map();
      if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
        const props = this.properties;
        const propKeys = [
          ...Object.getOwnPropertyNames(props),
          ...typeof Object.getOwnPropertySymbols === "function" ? Object.getOwnPropertySymbols(props) : []
        ];
        for (const p of propKeys) {
          this.createProperty(p, props[p]);
        }
      }
    }
    static _attributeNameForProperty(name2, options) {
      const attribute = options.attribute;
      return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name2 === "string" ? name2.toLowerCase() : void 0;
    }
    static _valueHasChanged(value, old, hasChanged = notEqual) {
      return hasChanged(value, old);
    }
    static _propertyValueFromAttribute(value, options) {
      const type = options.type;
      const converter = options.converter || defaultConverter;
      const fromAttribute = typeof converter === "function" ? converter : converter.fromAttribute;
      return fromAttribute ? fromAttribute(value, type) : value;
    }
    static _propertyValueToAttribute(value, options) {
      if (options.reflect === void 0) {
        return;
      }
      const type = options.type;
      const converter = options.converter;
      const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
      return toAttribute(value, type);
    }
    initialize() {
      this._updateState = 0;
      this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);
      this._changedProperties = new Map();
      this._saveInstanceProperties();
      this.requestUpdateInternal();
    }
    _saveInstanceProperties() {
      this.constructor._classProperties.forEach((_v, p) => {
        if (this.hasOwnProperty(p)) {
          const value = this[p];
          delete this[p];
          if (!this._instanceProperties) {
            this._instanceProperties = new Map();
          }
          this._instanceProperties.set(p, value);
        }
      });
    }
    _applyInstanceProperties() {
      this._instanceProperties.forEach((v, p) => this[p] = v);
      this._instanceProperties = void 0;
    }
    connectedCallback() {
      this.enableUpdating();
    }
    enableUpdating() {
      if (this._enableUpdatingResolver !== void 0) {
        this._enableUpdatingResolver();
        this._enableUpdatingResolver = void 0;
      }
    }
    disconnectedCallback() {
    }
    attributeChangedCallback(name2, old, value) {
      if (old !== value) {
        this._attributeToProperty(name2, value);
      }
    }
    _propertyToAttribute(name2, value, options = defaultPropertyDeclaration) {
      const ctor = this.constructor;
      const attr = ctor._attributeNameForProperty(name2, options);
      if (attr !== void 0) {
        const attrValue = ctor._propertyValueToAttribute(value, options);
        if (attrValue === void 0) {
          return;
        }
        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
        if (attrValue == null) {
          this.removeAttribute(attr);
        } else {
          this.setAttribute(attr, attrValue);
        }
        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
      }
    }
    _attributeToProperty(name2, value) {
      if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
        return;
      }
      const ctor = this.constructor;
      const propName = ctor._attributeToPropertyMap.get(name2);
      if (propName !== void 0) {
        const options = ctor.getPropertyOptions(propName);
        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
        this[propName] = ctor._propertyValueFromAttribute(value, options);
        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
      }
    }
    requestUpdateInternal(name2, oldValue, options) {
      let shouldRequestUpdate = true;
      if (name2 !== void 0) {
        const ctor = this.constructor;
        options = options || ctor.getPropertyOptions(name2);
        if (ctor._valueHasChanged(this[name2], oldValue, options.hasChanged)) {
          if (!this._changedProperties.has(name2)) {
            this._changedProperties.set(name2, oldValue);
          }
          if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
            if (this._reflectingProperties === void 0) {
              this._reflectingProperties = new Map();
            }
            this._reflectingProperties.set(name2, options);
          }
        } else {
          shouldRequestUpdate = false;
        }
      }
      if (!this._hasRequestedUpdate && shouldRequestUpdate) {
        this._updatePromise = this._enqueueUpdate();
      }
    }
    requestUpdate(name2, oldValue) {
      this.requestUpdateInternal(name2, oldValue);
      return this.updateComplete;
    }
    _enqueueUpdate() {
      return __async(this, null, function* () {
        this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
        try {
          yield this._updatePromise;
        } catch (e) {
        }
        const result = this.performUpdate();
        if (result != null) {
          yield result;
        }
        return !this._hasRequestedUpdate;
      });
    }
    get _hasRequestedUpdate() {
      return this._updateState & STATE_UPDATE_REQUESTED;
    }
    get hasUpdated() {
      return this._updateState & STATE_HAS_UPDATED;
    }
    performUpdate() {
      if (!this._hasRequestedUpdate) {
        return;
      }
      if (this._instanceProperties) {
        this._applyInstanceProperties();
      }
      let shouldUpdate = false;
      const changedProperties = this._changedProperties;
      try {
        shouldUpdate = this.shouldUpdate(changedProperties);
        if (shouldUpdate) {
          this.update(changedProperties);
        } else {
          this._markUpdated();
        }
      } catch (e) {
        shouldUpdate = false;
        this._markUpdated();
        throw e;
      }
      if (shouldUpdate) {
        if (!(this._updateState & STATE_HAS_UPDATED)) {
          this._updateState = this._updateState | STATE_HAS_UPDATED;
          this.firstUpdated(changedProperties);
        }
        this.updated(changedProperties);
      }
    }
    _markUpdated() {
      this._changedProperties = new Map();
      this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
    }
    get updateComplete() {
      return this._getUpdateComplete();
    }
    _getUpdateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._updatePromise;
    }
    shouldUpdate(_changedProperties) {
      return true;
    }
    update(_changedProperties) {
      if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
        this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
        this._reflectingProperties = void 0;
      }
      this._markUpdated();
    }
    updated(_changedProperties) {
    }
    firstUpdated(_changedProperties) {
    }
  }
  _a$1 = finalized;
  UpdatingElement[_a$1] = true;
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  const standardProperty = (options, element) => {
    if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
      return Object.assign(Object.assign({}, element), {finisher(clazz) {
        clazz.createProperty(element.key, options);
      }});
    } else {
      return {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        initializer() {
          if (typeof element.initializer === "function") {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };
  const legacyProperty = (options, proto, name2) => {
    proto.constructor.createProperty(name2, options);
  };
  function property(options) {
    return (protoOrDescriptor, name2) => name2 !== void 0 ? legacyProperty(options, protoOrDescriptor, name2) : standardProperty(options, protoOrDescriptor);
  }
  function query(selector, cache) {
    return (protoOrDescriptor, name2) => {
      const descriptor = {
        get() {
          return this.renderRoot.querySelector(selector);
        },
        enumerable: true,
        configurable: true
      };
      if (cache) {
        const prop = name2 !== void 0 ? name2 : protoOrDescriptor.key;
        const key = typeof prop === "symbol" ? Symbol() : `__${prop}`;
        descriptor.get = function() {
          if (this[key] === void 0) {
            this[key] = this.renderRoot.querySelector(selector);
          }
          return this[key];
        };
      }
      return name2 !== void 0 ? legacyQuery(descriptor, protoOrDescriptor, name2) : standardQuery(descriptor, protoOrDescriptor);
    };
  }
  const legacyQuery = (descriptor, proto, name2) => {
    Object.defineProperty(proto, name2, descriptor);
  };
  const standardQuery = (descriptor, element) => ({
    kind: "method",
    placement: "prototype",
    key: element.key,
    descriptor
  });
  const ElementProto = Element.prototype;
  const legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
  function queryAssignedNodes(slotName = "", flatten = false, selector = "") {
    return (protoOrDescriptor, name2) => {
      const descriptor = {
        get() {
          const slotSelector = `slot${slotName ? `[name=${slotName}]` : ":not([name])"}`;
          const slot = this.renderRoot.querySelector(slotSelector);
          let nodes = slot && slot.assignedNodes({flatten});
          if (nodes && selector) {
            nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && (node.matches ? node.matches(selector) : legacyMatches.call(node, selector)));
          }
          return nodes;
        },
        enumerable: true,
        configurable: true
      };
      return name2 !== void 0 ? legacyQuery(descriptor, protoOrDescriptor, name2) : standardQuery(descriptor, protoOrDescriptor);
    };
  }
  /**
  @license
  Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  */
  const supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  const constructionToken = Symbol();
  class CSSResult {
    constructor(cssText, safeToken) {
      if (safeToken !== constructionToken) {
        throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      }
      this.cssText = cssText;
    }
    get styleSheet() {
      if (this._styleSheet === void 0) {
        if (supportsAdoptingStyleSheets) {
          this._styleSheet = new CSSStyleSheet();
          this._styleSheet.replaceSync(this.cssText);
        } else {
          this._styleSheet = null;
        }
      }
      return this._styleSheet;
    }
    toString() {
      return this.cssText;
    }
  }
  const unsafeCSS = (value) => {
    return new CSSResult(String(value), constructionToken);
  };
  const textFromCSSResult = (value) => {
    if (value instanceof CSSResult) {
      return value.cssText;
    } else if (typeof value === "number") {
      return value;
    } else {
      throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
    }
  };
  const css = (strings, ...values) => {
    const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
    return new CSSResult(cssText, constructionToken);
  };
  /**
  * @license
  * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  * This code may only be used under the BSD style license found at
  * http://polymer.github.io/LICENSE.txt
  * The complete set of authors may be found at
  * http://polymer.github.io/AUTHORS.txt
  * The complete set of contributors may be found at
  * http://polymer.github.io/CONTRIBUTORS.txt
  * Code distributed by Google as part of the polymer project is also
  * subject to an additional IP rights grant found at
  * http://polymer.github.io/PATENTS.txt
  */
  (window["litElementVersions"] || (window["litElementVersions"] = [])).push("2.5.1");
  const renderNotImplemented = {};
  class LitElement extends UpdatingElement {
    static getStyles() {
      return this.styles;
    }
    static _getUniqueStyles() {
      if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
        return;
      }
      const userStyles = this.getStyles();
      if (Array.isArray(userStyles)) {
        const addStyles = (styles2, set2) => styles2.reduceRight((set3, s) => Array.isArray(s) ? addStyles(s, set3) : (set3.add(s), set3), set2);
        const set = addStyles(userStyles, new Set());
        const styles = [];
        set.forEach((v) => styles.unshift(v));
        this._styles = styles;
      } else {
        this._styles = userStyles === void 0 ? [] : [userStyles];
      }
      this._styles = this._styles.map((s) => {
        if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
          const cssText = Array.prototype.slice.call(s.cssRules).reduce((css, rule) => css + rule.cssText, "");
          return unsafeCSS(cssText);
        }
        return s;
      });
    }
    initialize() {
      super.initialize();
      this.constructor._getUniqueStyles();
      this.renderRoot = this.createRenderRoot();
      if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
        this.adoptStyles();
      }
    }
    createRenderRoot() {
      return this.attachShadow(this.constructor.shadowRootOptions);
    }
    adoptStyles() {
      const styles = this.constructor._styles;
      if (styles.length === 0) {
        return;
      }
      if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
        window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
      } else if (supportsAdoptingStyleSheets) {
        this.renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
      } else {
        this._needsShimAdoptedStyleSheets = true;
      }
    }
    connectedCallback() {
      super.connectedCallback();
      if (this.hasUpdated && window.ShadyCSS !== void 0) {
        window.ShadyCSS.styleElement(this);
      }
    }
    update(changedProperties) {
      const templateResult = this.render();
      super.update(changedProperties);
      if (templateResult !== renderNotImplemented) {
        this.constructor.render(templateResult, this.renderRoot, {scopeName: this.localName, eventContext: this});
      }
      if (this._needsShimAdoptedStyleSheets) {
        this._needsShimAdoptedStyleSheets = false;
        this.constructor._styles.forEach((s) => {
          const style = document.createElement("style");
          style.textContent = s.cssText;
          this.renderRoot.appendChild(style);
        });
      }
    }
    render() {
      return renderNotImplemented;
    }
  }
  LitElement["finalized"] = true;
  LitElement.render = render;
  LitElement.shadowRootOptions = {mode: "open"};
  /*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var clipboardCopy_1 = clipboardCopy;
  function makeError() {
    return new DOMException("The request is not allowed", "NotAllowedError");
  }
  function copyClipboardApi(text) {
    return __async(this, null, function* () {
      if (!navigator.clipboard) {
        throw makeError();
      }
      return navigator.clipboard.writeText(text);
    });
  }
  function copyExecCommand(text) {
    return __async(this, null, function* () {
      const span = document.createElement("span");
      span.textContent = text;
      span.style.whiteSpace = "pre";
      span.style.webkitUserSelect = "auto";
      span.style.userSelect = "all";
      document.body.appendChild(span);
      const selection = window.getSelection();
      const range = window.document.createRange();
      selection.removeAllRanges();
      range.selectNode(span);
      selection.addRange(range);
      let success = false;
      try {
        success = window.document.execCommand("copy");
      } finally {
        selection.removeAllRanges();
        window.document.body.removeChild(span);
      }
      if (!success)
        throw makeError();
    });
  }
  function clipboardCopy(text) {
    return __async(this, null, function* () {
      try {
        yield copyClipboardApi(text);
      } catch (err) {
        try {
          yield copyExecCommand(text);
        } catch (err2) {
          throw err2 || err || makeError();
        }
      }
    });
  }
  class SHighlightJsComponentInterface$1 extends SInterface {
  }
  SHighlightJsComponentInterface$1.definition = {
    successTimeout: {
      type: "Number",
      default: 1500
    },
    errorTimeout: {
      type: "Number",
      default: 3e3
    }
  };
  function copy$3(text) {
    return clipboardCopy_1(text);
  }
  var __css$1 = '.root {\n    display: inline-block;\n    width: 1em; height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .root[state="pending"] .icon-copy {\n            opacity: 1;\n        }\n\n    .root[state="copy"] .icon-copy {\n            opacity: 1;\n        }\n\n    .root[state="success"] {\n        color: hsl(calc(var(--s833dc3705a8, 0) + var(--s43390be2316 ,0)),calc((var(--s86b6f84158f, 0) + var(--sd9f744147cd, 0)) * 1%),calc((var(--s5c48a669ecf, 0) + var(--s2c04907cda0, 0)) * 1%));\n    }\n\n    .root[state="success"] .icon-success {\n            opacity: 1;\n        }\n\n    .root[state="error"] {\n        color: hsl(calc(var(--s9f4a69aa425, 0) + var(--s8345c7f8e61 ,0)),calc((var(--s88f927582b5, 0) + var(--se4a503962ac, 0)) * 1%),calc((var(--s6f3a4577631, 0) + var(--se8457b43571, 0)) * 1%));\n    }\n\n    .root[state="error"] .icon-error {\n            opacity: 1;\n        }\n\nsvg {\n    position: absolute;\n    top: 50%; left: 50%;\n    transform: translate(-50%, -50%);\n    display: block;\n    width: 1em;\n    height: 1em;\n    background-size:contain;\n    opacity: 0;\n    pointer-events: none;\n}';
  var __decorate$3 = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  class SClipboardCopy extends LitElement {
    constructor() {
      super();
      this._component = void 0;
      this._state = "pending";
      this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
        interface: SHighlightJsComponentInterface$1,
        defaultProps: {}
      });
    }
    static get styles() {
      return css`${unsafeCSS(__css$1)}`;
    }
    firstUpdated() {
    }
    copy(text) {
      this._state = "copy";
      copy$3(text).then(() => {
        this._state = "success";
        setTimeout(() => {
          this._state = "pending";
        }, this._component.props.successTimeout);
      }).catch((e) => {
        this._state = "error";
        setTimeout(() => {
          this._state = "pending";
        }, this._component.props.errorTimeout);
      });
    }
    render() {
      return html`
            <div class="root" ref="root" state="${this._state}">

                <svg ref="svg" class="icon-copy" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <g clip-path="url(#clip0)">
                    <path d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z" fill="currentColor" />
                    <path d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z" fill="currentColor" />
                    <path d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z" fill="currentColor" />
                    </g>
                    <defs>
                    <clipPath id="clip0">
                    <rect width="20" height="20" fill="currentColor"/>
                    </clipPath>
                    </defs>
                </svg>
                <svg class="icon-success" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                <svg class="icon-error" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>

            </div>
        `;
    }
  }
  __decorate$3([
    property()
  ], SClipboardCopy.prototype, "_state", void 0);
  function webcomponent$3(tagName = "s-clipboard-copy") {
    customElements.define(tagName, SClipboardCopy);
  }
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  function wait(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, timeout);
    });
  }
  var deepFreezeEs6 = {exports: {}};
  function deepFreeze(obj) {
    if (obj instanceof Map) {
      obj.clear = obj.delete = obj.set = function() {
        throw new Error("map is read-only");
      };
    } else if (obj instanceof Set) {
      obj.add = obj.clear = obj.delete = function() {
        throw new Error("set is read-only");
      };
    }
    Object.freeze(obj);
    Object.getOwnPropertyNames(obj).forEach(function(name2) {
      var prop = obj[name2];
      if (typeof prop == "object" && !Object.isFrozen(prop)) {
        deepFreeze(prop);
      }
    });
    return obj;
  }
  deepFreezeEs6.exports = deepFreeze;
  deepFreezeEs6.exports.default = deepFreeze;
  var deepFreeze$1 = deepFreezeEs6.exports;
  class Response {
    constructor(mode) {
      if (mode.data === void 0)
        mode.data = {};
      this.data = mode.data;
      this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  }
  function escapeHTML(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function inherit$1(original, ...objects) {
    const result = Object.create(null);
    for (const key in original) {
      result[key] = original[key];
    }
    objects.forEach(function(obj) {
      for (const key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }
  const SPAN_CLOSE = "</span>";
  const emitsWrappingTags = (node) => {
    return !!node.kind;
  };
  const expandScopeName = (name2, {prefix}) => {
    if (name2.includes(".")) {
      const pieces = name2.split(".");
      return [
        `${prefix}${pieces.shift()}`,
        ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
      ].join(" ");
    }
    return `${prefix}${name2}`;
  };
  class HTMLRenderer {
    constructor(parseTree, options) {
      this.buffer = "";
      this.classPrefix = options.classPrefix;
      parseTree.walk(this);
    }
    addText(text) {
      this.buffer += escapeHTML(text);
    }
    openNode(node) {
      if (!emitsWrappingTags(node))
        return;
      let scope = node.kind;
      if (node.sublanguage) {
        scope = `language-${scope}`;
      } else {
        scope = expandScopeName(scope, {prefix: this.classPrefix});
      }
      this.span(scope);
    }
    closeNode(node) {
      if (!emitsWrappingTags(node))
        return;
      this.buffer += SPAN_CLOSE;
    }
    value() {
      return this.buffer;
    }
    span(className) {
      this.buffer += `<span class="${className}">`;
    }
  }
  class TokenTree {
    constructor() {
      this.rootNode = {children: []};
      this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    add(node) {
      this.top.children.push(node);
    }
    openNode(kind) {
      const node = {kind, children: []};
      this.add(node);
      this.stack.push(node);
    }
    closeNode() {
      if (this.stack.length > 1) {
        return this.stack.pop();
      }
      return void 0;
    }
    closeAllNodes() {
      while (this.closeNode())
        ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    walk(builder) {
      return this.constructor._walk(builder, this.rootNode);
    }
    static _walk(builder, node) {
      if (typeof node === "string") {
        builder.addText(node);
      } else if (node.children) {
        builder.openNode(node);
        node.children.forEach((child) => this._walk(builder, child));
        builder.closeNode(node);
      }
      return builder;
    }
    static _collapse(node) {
      if (typeof node === "string")
        return;
      if (!node.children)
        return;
      if (node.children.every((el) => typeof el === "string")) {
        node.children = [node.children.join("")];
      } else {
        node.children.forEach((child) => {
          TokenTree._collapse(child);
        });
      }
    }
  }
  class TokenTreeEmitter extends TokenTree {
    constructor(options) {
      super();
      this.options = options;
    }
    addKeyword(text, kind) {
      if (text === "") {
        return;
      }
      this.openNode(kind);
      this.addText(text);
      this.closeNode();
    }
    addText(text) {
      if (text === "") {
        return;
      }
      this.add(text);
    }
    addSublanguage(emitter, name2) {
      const node = emitter.root;
      node.kind = name2;
      node.sublanguage = true;
      this.add(node);
    }
    toHTML() {
      const renderer = new HTMLRenderer(this, this.options);
      return renderer.value();
    }
    finalize() {
      return true;
    }
  }
  function source$1(re) {
    if (!re)
      return null;
    if (typeof re === "string")
      return re;
    return re.source;
  }
  function lookahead$1(re) {
    return concat$1("(?=", re, ")");
  }
  function concat$1(...args) {
    const joined = args.map((x) => source$1(x)).join("");
    return joined;
  }
  function stripOptionsFromArgs(args) {
    const opts = args[args.length - 1];
    if (typeof opts === "object" && opts.constructor === Object) {
      args.splice(args.length - 1, 1);
      return opts;
    } else {
      return {};
    }
  }
  function either(...args) {
    const opts = stripOptionsFromArgs(args);
    const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source$1(x)).join("|") + ")";
    return joined;
  }
  function countMatchGroups(re) {
    return new RegExp(re.toString() + "|").exec("").length - 1;
  }
  function startsWith(re, lexeme) {
    const match = re && re.exec(lexeme);
    return match && match.index === 0;
  }
  const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function _rewriteBackreferences(regexps, {joinWith}) {
    let numCaptures = 0;
    return regexps.map((regex) => {
      numCaptures += 1;
      const offset = numCaptures;
      let re = source$1(regex);
      let out = "";
      while (re.length > 0) {
        const match = BACKREF_RE.exec(re);
        if (!match) {
          out += re;
          break;
        }
        out += re.substring(0, match.index);
        re = re.substring(match.index + match[0].length);
        if (match[0][0] === "\\" && match[1]) {
          out += "\\" + String(Number(match[1]) + offset);
        } else {
          out += match[0];
          if (match[0] === "(") {
            numCaptures++;
          }
        }
      }
      return out;
    }).map((re) => `(${re})`).join(joinWith);
  }
  const MATCH_NOTHING_RE = /\b\B/;
  const IDENT_RE$1 = "[a-zA-Z]\\w*";
  const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
  const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
  const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
  const BINARY_NUMBER_RE = "\\b(0b[01]+)";
  const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
  const SHEBANG = (opts = {}) => {
    const beginShebang = /^#![ ]*\//;
    if (opts.binary) {
      opts.begin = concat$1(beginShebang, /.*\b/, opts.binary, /\b.*/);
    }
    return inherit$1({
      scope: "meta",
      begin: beginShebang,
      end: /$/,
      relevance: 0,
      "on:begin": (m, resp) => {
        if (m.index !== 0)
          resp.ignoreMatch();
      }
    }, opts);
  };
  const BACKSLASH_ESCAPE = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  };
  const APOS_STRING_MODE = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const QUOTE_STRING_MODE = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  const COMMENT = function(begin, end, modeOptions = {}) {
    const mode = inherit$1({
      scope: "comment",
      begin,
      end,
      contains: []
    }, modeOptions);
    mode.contains.push({
      scope: "doctag",
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: true,
      relevance: 0
    });
    const ENGLISH_WORD = either("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
    mode.contains.push({
      begin: concat$1(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}")
    });
    return mode;
  };
  const C_LINE_COMMENT_MODE = COMMENT("//", "$");
  const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
  const HASH_COMMENT_MODE = COMMENT("#", "$");
  const NUMBER_MODE = {
    scope: "number",
    begin: NUMBER_RE,
    relevance: 0
  };
  const C_NUMBER_MODE = {
    scope: "number",
    begin: C_NUMBER_RE,
    relevance: 0
  };
  const BINARY_NUMBER_MODE = {
    scope: "number",
    begin: BINARY_NUMBER_RE,
    relevance: 0
  };
  const REGEXP_MODE = {
    begin: /(?=\/[^/\n]*\/)/,
    contains: [{
      scope: "regexp",
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    }]
  };
  const TITLE_MODE = {
    scope: "title",
    begin: IDENT_RE$1,
    relevance: 0
  };
  const UNDERSCORE_TITLE_MODE = {
    scope: "title",
    begin: UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const METHOD_GUARD = {
    begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const END_SAME_AS_BEGIN = function(mode) {
    return Object.assign(mode, {
      "on:begin": (m, resp) => {
        resp.data._beginMatch = m[1];
      },
      "on:end": (m, resp) => {
        if (resp.data._beginMatch !== m[1])
          resp.ignoreMatch();
      }
    });
  };
  var MODES = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE,
    IDENT_RE: IDENT_RE$1,
    UNDERSCORE_IDENT_RE,
    NUMBER_RE,
    C_NUMBER_RE,
    BINARY_NUMBER_RE,
    RE_STARTERS_RE,
    SHEBANG,
    BACKSLASH_ESCAPE,
    APOS_STRING_MODE,
    QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE,
    COMMENT,
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE,
    NUMBER_MODE,
    C_NUMBER_MODE,
    BINARY_NUMBER_MODE,
    REGEXP_MODE,
    TITLE_MODE,
    UNDERSCORE_TITLE_MODE,
    METHOD_GUARD,
    END_SAME_AS_BEGIN
  });
  function skipIfHasPrecedingDot(match, response) {
    const before = match.input[match.index - 1];
    if (before === ".") {
      response.ignoreMatch();
    }
  }
  function scopeClassName(mode, _parent) {
    if (mode.className !== void 0) {
      mode.scope = mode.className;
      delete mode.className;
    }
  }
  function beginKeywords(mode, parent) {
    if (!parent)
      return;
    if (!mode.beginKeywords)
      return;
    mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
    mode.__beforeBegin = skipIfHasPrecedingDot;
    mode.keywords = mode.keywords || mode.beginKeywords;
    delete mode.beginKeywords;
    if (mode.relevance === void 0)
      mode.relevance = 0;
  }
  function compileIllegal(mode, _parent) {
    if (!Array.isArray(mode.illegal))
      return;
    mode.illegal = either(...mode.illegal);
  }
  function compileMatch(mode, _parent) {
    if (!mode.match)
      return;
    if (mode.begin || mode.end)
      throw new Error("begin & end are not supported with match");
    mode.begin = mode.match;
    delete mode.match;
  }
  function compileRelevance(mode, _parent) {
    if (mode.relevance === void 0)
      mode.relevance = 1;
  }
  const beforeMatchExt = (mode, parent) => {
    if (!mode.beforeMatch)
      return;
    if (mode.starts)
      throw new Error("beforeMatch cannot be used with starts");
    const originalMode = Object.assign({}, mode);
    Object.keys(mode).forEach((key) => {
      delete mode[key];
    });
    mode.keywords = originalMode.keywords;
    mode.begin = concat$1(originalMode.beforeMatch, lookahead$1(originalMode.begin));
    mode.starts = {
      relevance: 0,
      contains: [
        Object.assign(originalMode, {endsParent: true})
      ]
    };
    mode.relevance = 0;
    delete originalMode.beforeMatch;
  };
  const COMMON_KEYWORDS = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    "list",
    "value"
  ];
  const DEFAULT_KEYWORD_SCOPE = "keyword";
  function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
    const compiledKeywords = Object.create(null);
    if (typeof rawKeywords === "string") {
      compileList(scopeName, rawKeywords.split(" "));
    } else if (Array.isArray(rawKeywords)) {
      compileList(scopeName, rawKeywords);
    } else {
      Object.keys(rawKeywords).forEach(function(scopeName2) {
        Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
      });
    }
    return compiledKeywords;
    function compileList(scopeName2, keywordList) {
      if (caseInsensitive) {
        keywordList = keywordList.map((x) => x.toLowerCase());
      }
      keywordList.forEach(function(keyword) {
        const pair = keyword.split("|");
        compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }
  function scoreForKeyword(keyword, providedScore) {
    if (providedScore) {
      return Number(providedScore);
    }
    return commonKeyword(keyword) ? 0 : 1;
  }
  function commonKeyword(keyword) {
    return COMMON_KEYWORDS.includes(keyword.toLowerCase());
  }
  const seenDeprecations = {};
  const error = (message) => {
    console.error(message);
  };
  const warn = (message, ...args) => {
    console.log(`WARN: ${message}`, ...args);
  };
  const deprecated = (version2, message) => {
    if (seenDeprecations[`${version2}/${message}`])
      return;
    console.log(`Deprecated as of ${version2}. ${message}`);
    seenDeprecations[`${version2}/${message}`] = true;
  };
  const MultiClassError = new Error();
  function remapScopeNames(mode, regexes, {key}) {
    let offset = 0;
    const scopeNames = mode[key];
    const emit = {};
    const positions = {};
    for (let i = 1; i <= regexes.length; i++) {
      positions[i + offset] = scopeNames[i];
      emit[i + offset] = true;
      offset += countMatchGroups(regexes[i - 1]);
    }
    mode[key] = positions;
    mode[key]._emit = emit;
    mode[key]._multi = true;
  }
  function beginMultiClass(mode) {
    if (!Array.isArray(mode.begin))
      return;
    if (mode.skip || mode.excludeBegin || mode.returnBegin) {
      error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
      error("beginScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.begin, {key: "beginScope"});
    mode.begin = _rewriteBackreferences(mode.begin, {joinWith: ""});
  }
  function endMultiClass(mode) {
    if (!Array.isArray(mode.end))
      return;
    if (mode.skip || mode.excludeEnd || mode.returnEnd) {
      error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.endScope !== "object" || mode.endScope === null) {
      error("endScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.end, {key: "endScope"});
    mode.end = _rewriteBackreferences(mode.end, {joinWith: ""});
  }
  function scopeSugar(mode) {
    if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
      mode.beginScope = mode.scope;
      delete mode.scope;
    }
  }
  function MultiClass(mode) {
    scopeSugar(mode);
    if (typeof mode.beginScope === "string") {
      mode.beginScope = {_wrap: mode.beginScope};
    }
    if (typeof mode.endScope === "string") {
      mode.endScope = {_wrap: mode.endScope};
    }
    beginMultiClass(mode);
    endMultiClass(mode);
  }
  function compileLanguage(language) {
    function langRe(value, global2) {
      return new RegExp(source$1(value), "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : ""));
    }
    class MultiRegex {
      constructor() {
        this.matchIndexes = {};
        this.regexes = [];
        this.matchAt = 1;
        this.position = 0;
      }
      addRule(re, opts) {
        opts.position = this.position++;
        this.matchIndexes[this.matchAt] = opts;
        this.regexes.push([opts, re]);
        this.matchAt += countMatchGroups(re) + 1;
      }
      compile() {
        if (this.regexes.length === 0) {
          this.exec = () => null;
        }
        const terminators = this.regexes.map((el) => el[1]);
        this.matcherRe = langRe(_rewriteBackreferences(terminators, {joinWith: "|"}), true);
        this.lastIndex = 0;
      }
      exec(s) {
        this.matcherRe.lastIndex = this.lastIndex;
        const match = this.matcherRe.exec(s);
        if (!match) {
          return null;
        }
        const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
        const matchData = this.matchIndexes[i];
        match.splice(0, i);
        return Object.assign(match, matchData);
      }
    }
    class ResumableMultiRegex {
      constructor() {
        this.rules = [];
        this.multiRegexes = [];
        this.count = 0;
        this.lastIndex = 0;
        this.regexIndex = 0;
      }
      getMatcher(index) {
        if (this.multiRegexes[index])
          return this.multiRegexes[index];
        const matcher = new MultiRegex();
        this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
        matcher.compile();
        this.multiRegexes[index] = matcher;
        return matcher;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      addRule(re, opts) {
        this.rules.push([re, opts]);
        if (opts.type === "begin")
          this.count++;
      }
      exec(s) {
        const m = this.getMatcher(this.regexIndex);
        m.lastIndex = this.lastIndex;
        let result = m.exec(s);
        if (this.resumingScanAtSamePosition()) {
          if (result && result.index === this.lastIndex)
            ;
          else {
            const m2 = this.getMatcher(0);
            m2.lastIndex = this.lastIndex + 1;
            result = m2.exec(s);
          }
        }
        if (result) {
          this.regexIndex += result.position + 1;
          if (this.regexIndex === this.count) {
            this.considerAll();
          }
        }
        return result;
      }
    }
    function buildModeRegex(mode) {
      const mm = new ResumableMultiRegex();
      mode.contains.forEach((term) => mm.addRule(term.begin, {rule: term, type: "begin"}));
      if (mode.terminatorEnd) {
        mm.addRule(mode.terminatorEnd, {type: "end"});
      }
      if (mode.illegal) {
        mm.addRule(mode.illegal, {type: "illegal"});
      }
      return mm;
    }
    function compileMode(mode, parent) {
      const cmode = mode;
      if (mode.isCompiled)
        return cmode;
      [
        scopeClassName,
        compileMatch,
        MultiClass,
        beforeMatchExt
      ].forEach((ext) => ext(mode, parent));
      language.compilerExtensions.forEach((ext) => ext(mode, parent));
      mode.__beforeBegin = null;
      [
        beginKeywords,
        compileIllegal,
        compileRelevance
      ].forEach((ext) => ext(mode, parent));
      mode.isCompiled = true;
      let keywordPattern = null;
      if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
        mode.keywords = Object.assign({}, mode.keywords);
        keywordPattern = mode.keywords.$pattern;
        delete mode.keywords.$pattern;
      }
      keywordPattern = keywordPattern || /\w+/;
      if (mode.keywords) {
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
      }
      cmode.keywordPatternRe = langRe(keywordPattern, true);
      if (parent) {
        if (!mode.begin)
          mode.begin = /\B|\b/;
        cmode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent)
          mode.end = /\B|\b/;
        if (mode.end)
          cmode.endRe = langRe(mode.end);
        cmode.terminatorEnd = source$1(mode.end) || "";
        if (mode.endsWithParent && parent.terminatorEnd) {
          cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
        }
      }
      if (mode.illegal)
        cmode.illegalRe = langRe(mode.illegal);
      if (!mode.contains)
        mode.contains = [];
      mode.contains = [].concat(...mode.contains.map(function(c) {
        return expandOrCloneMode(c === "self" ? mode : c);
      }));
      mode.contains.forEach(function(c) {
        compileMode(c, cmode);
      });
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }
      cmode.matcher = buildModeRegex(cmode);
      return cmode;
    }
    if (!language.compilerExtensions)
      language.compilerExtensions = [];
    if (language.contains && language.contains.includes("self")) {
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    }
    language.classNameAliases = inherit$1(language.classNameAliases || {});
    return compileMode(language);
  }
  function dependencyOnParent(mode) {
    if (!mode)
      return false;
    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }
  function expandOrCloneMode(mode) {
    if (mode.variants && !mode.cachedVariants) {
      mode.cachedVariants = mode.variants.map(function(variant) {
        return inherit$1(mode, {variants: null}, variant);
      });
    }
    if (mode.cachedVariants) {
      return mode.cachedVariants;
    }
    if (dependencyOnParent(mode)) {
      return inherit$1(mode, {starts: mode.starts ? inherit$1(mode.starts) : null});
    }
    if (Object.isFrozen(mode)) {
      return inherit$1(mode);
    }
    return mode;
  }
  var version$1 = "11.1.0";
  const escape$2 = escapeHTML;
  const inherit = inherit$1;
  const NO_MATCH = Symbol("nomatch");
  const MAX_KEYWORD_HITS = 7;
  const HLJS = function(hljs) {
    const languages = Object.create(null);
    const aliases = Object.create(null);
    const plugins = [];
    let SAFE_MODE = true;
    const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
    const PLAINTEXT_LANGUAGE = {disableAutodetect: true, name: "Plain text", contains: []};
    let options = {
      ignoreUnescapedHTML: false,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      __emitter: TokenTreeEmitter
    };
    function shouldNotHighlight(languageName) {
      return options.noHighlightRe.test(languageName);
    }
    function blockLanguage(block) {
      let classes = block.className + " ";
      classes += block.parentNode ? block.parentNode.className : "";
      const match = options.languageDetectRe.exec(classes);
      if (match) {
        const language = getLanguage(match[1]);
        if (!language) {
          warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
          warn("Falling back to no-highlight mode for this block.", block);
        }
        return language ? match[1] : "no-highlight";
      }
      return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
    }
    function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
      let code = "";
      let languageName = "";
      if (typeof optionsOrCode === "object") {
        code = codeOrLanguageName;
        ignoreIllegals = optionsOrCode.ignoreIllegals;
        languageName = optionsOrCode.language;
      } else {
        deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
        deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
        languageName = codeOrLanguageName;
        code = optionsOrCode;
      }
      if (ignoreIllegals === void 0) {
        ignoreIllegals = true;
      }
      const context = {
        code,
        language: languageName
      };
      fire("before:highlight", context);
      const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
      result.code = context.code;
      fire("after:highlight", result);
      return result;
    }
    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
      const keywordHits = Object.create(null);
      function keywordData(mode, matchText) {
        return mode.keywords[matchText];
      }
      function processKeywords() {
        if (!top.keywords) {
          emitter.addText(modeBuffer);
          return;
        }
        let lastIndex = 0;
        top.keywordPatternRe.lastIndex = 0;
        let match = top.keywordPatternRe.exec(modeBuffer);
        let buf = "";
        while (match) {
          buf += modeBuffer.substring(lastIndex, match.index);
          const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
          const data = keywordData(top, word);
          if (data) {
            const [kind, keywordRelevance] = data;
            emitter.addText(buf);
            buf = "";
            keywordHits[word] = (keywordHits[word] || 0) + 1;
            if (keywordHits[word] <= MAX_KEYWORD_HITS)
              relevance += keywordRelevance;
            if (kind.startsWith("_")) {
              buf += match[0];
            } else {
              const cssClass = language.classNameAliases[kind] || kind;
              emitter.addKeyword(match[0], cssClass);
            }
          } else {
            buf += match[0];
          }
          lastIndex = top.keywordPatternRe.lastIndex;
          match = top.keywordPatternRe.exec(modeBuffer);
        }
        buf += modeBuffer.substr(lastIndex);
        emitter.addText(buf);
      }
      function processSubLanguage() {
        if (modeBuffer === "")
          return;
        let result2 = null;
        if (typeof top.subLanguage === "string") {
          if (!languages[top.subLanguage]) {
            emitter.addText(modeBuffer);
            return;
          }
          result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
          continuations[top.subLanguage] = result2._top;
        } else {
          result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
        }
        if (top.relevance > 0) {
          relevance += result2.relevance;
        }
        emitter.addSublanguage(result2._emitter, result2.language);
      }
      function processBuffer() {
        if (top.subLanguage != null) {
          processSubLanguage();
        } else {
          processKeywords();
        }
        modeBuffer = "";
      }
      function emitMultiClass(scope, match) {
        let i = 1;
        while (match[i] !== void 0) {
          if (!scope._emit[i]) {
            i++;
            continue;
          }
          const klass = language.classNameAliases[scope[i]] || scope[i];
          const text = match[i];
          if (klass) {
            emitter.addKeyword(text, klass);
          } else {
            modeBuffer = text;
            processKeywords();
            modeBuffer = "";
          }
          i++;
        }
      }
      function startNewMode(mode, match) {
        if (mode.scope && typeof mode.scope === "string") {
          emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
        }
        if (mode.beginScope) {
          if (mode.beginScope._wrap) {
            emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
            modeBuffer = "";
          } else if (mode.beginScope._multi) {
            emitMultiClass(mode.beginScope, match);
            modeBuffer = "";
          }
        }
        top = Object.create(mode, {parent: {value: top}});
        return top;
      }
      function endOfMode(mode, match, matchPlusRemainder) {
        let matched = startsWith(mode.endRe, matchPlusRemainder);
        if (matched) {
          if (mode["on:end"]) {
            const resp = new Response(mode);
            mode["on:end"](match, resp);
            if (resp.isMatchIgnored)
              matched = false;
          }
          if (matched) {
            while (mode.endsParent && mode.parent) {
              mode = mode.parent;
            }
            return mode;
          }
        }
        if (mode.endsWithParent) {
          return endOfMode(mode.parent, match, matchPlusRemainder);
        }
      }
      function doIgnore(lexeme) {
        if (top.matcher.regexIndex === 0) {
          modeBuffer += lexeme[0];
          return 1;
        } else {
          resumeScanAtSamePosition = true;
          return 0;
        }
      }
      function doBeginMatch(match) {
        const lexeme = match[0];
        const newMode = match.rule;
        const resp = new Response(newMode);
        const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
        for (const cb of beforeCallbacks) {
          if (!cb)
            continue;
          cb(match, resp);
          if (resp.isMatchIgnored)
            return doIgnore(lexeme);
        }
        if (newMode.skip) {
          modeBuffer += lexeme;
        } else {
          if (newMode.excludeBegin) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (!newMode.returnBegin && !newMode.excludeBegin) {
            modeBuffer = lexeme;
          }
        }
        startNewMode(newMode, match);
        return newMode.returnBegin ? 0 : lexeme.length;
      }
      function doEndMatch(match) {
        const lexeme = match[0];
        const matchPlusRemainder = codeToHighlight.substr(match.index);
        const endMode = endOfMode(top, match, matchPlusRemainder);
        if (!endMode) {
          return NO_MATCH;
        }
        const origin = top;
        if (top.endScope && top.endScope._wrap) {
          processBuffer();
          emitter.addKeyword(lexeme, top.endScope._wrap);
        } else if (top.endScope && top.endScope._multi) {
          processBuffer();
          emitMultiClass(top.endScope, match);
        } else if (origin.skip) {
          modeBuffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            modeBuffer = lexeme;
          }
        }
        do {
          if (top.scope && !top.isMultiClass) {
            emitter.closeNode();
          }
          if (!top.skip && !top.subLanguage) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== endMode.parent);
        if (endMode.starts) {
          startNewMode(endMode.starts, match);
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }
      function processContinuations() {
        const list = [];
        for (let current = top; current !== language; current = current.parent) {
          if (current.scope) {
            list.unshift(current.scope);
          }
        }
        list.forEach((item) => emitter.openNode(item));
      }
      let lastMatch = {};
      function processLexeme(textBeforeMatch, match) {
        const lexeme = match && match[0];
        modeBuffer += textBeforeMatch;
        if (lexeme == null) {
          processBuffer();
          return 0;
        }
        if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
          modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
          if (!SAFE_MODE) {
            const err = new Error(`0 width match regex (${languageName})`);
            err.languageName = languageName;
            err.badRule = lastMatch.rule;
            throw err;
          }
          return 1;
        }
        lastMatch = match;
        if (match.type === "begin") {
          return doBeginMatch(match);
        } else if (match.type === "illegal" && !ignoreIllegals) {
          const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
          err.mode = top;
          throw err;
        } else if (match.type === "end") {
          const processed = doEndMatch(match);
          if (processed !== NO_MATCH) {
            return processed;
          }
        }
        if (match.type === "illegal" && lexeme === "") {
          return 1;
        }
        if (iterations > 1e5 && iterations > match.index * 3) {
          const err = new Error("potential infinite loop, way more iterations than matches");
          throw err;
        }
        modeBuffer += lexeme;
        return lexeme.length;
      }
      const language = getLanguage(languageName);
      if (!language) {
        error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
        throw new Error('Unknown language: "' + languageName + '"');
      }
      const md = compileLanguage(language);
      let result = "";
      let top = continuation || md;
      const continuations = {};
      const emitter = new options.__emitter(options);
      processContinuations();
      let modeBuffer = "";
      let relevance = 0;
      let index = 0;
      let iterations = 0;
      let resumeScanAtSamePosition = false;
      try {
        top.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top.matcher.considerAll();
          }
          top.matcher.lastIndex = index;
          const match = top.matcher.exec(codeToHighlight);
          if (!match)
            break;
          const beforeMatch = codeToHighlight.substring(index, match.index);
          const processedCount = processLexeme(beforeMatch, match);
          index = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substr(index));
        emitter.closeAllNodes();
        emitter.finalize();
        result = emitter.toHTML();
        return {
          language: languageName,
          value: result,
          relevance,
          illegal: false,
          _emitter: emitter,
          _top: top
        };
      } catch (err) {
        if (err.message && err.message.includes("Illegal")) {
          return {
            language: languageName,
            value: escape$2(codeToHighlight),
            illegal: true,
            relevance: 0,
            _illegalBy: {
              message: err.message,
              index,
              context: codeToHighlight.slice(index - 100, index + 100),
              mode: err.mode,
              resultSoFar: result
            },
            _emitter: emitter
          };
        } else if (SAFE_MODE) {
          return {
            language: languageName,
            value: escape$2(codeToHighlight),
            illegal: false,
            relevance: 0,
            errorRaised: err,
            _emitter: emitter,
            _top: top
          };
        } else {
          throw err;
        }
      }
    }
    function justTextHighlightResult(code) {
      const result = {
        value: escape$2(code),
        illegal: false,
        relevance: 0,
        _top: PLAINTEXT_LANGUAGE,
        _emitter: new options.__emitter(options)
      };
      result._emitter.addText(code);
      return result;
    }
    function highlightAuto(code, languageSubset) {
      languageSubset = languageSubset || options.languages || Object.keys(languages);
      const plaintext = justTextHighlightResult(code);
      const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name2) => _highlight(name2, code, false));
      results.unshift(plaintext);
      const sorted = results.sort((a, b) => {
        if (a.relevance !== b.relevance)
          return b.relevance - a.relevance;
        if (a.language && b.language) {
          if (getLanguage(a.language).supersetOf === b.language) {
            return 1;
          } else if (getLanguage(b.language).supersetOf === a.language) {
            return -1;
          }
        }
        return 0;
      });
      const [best, secondBest] = sorted;
      const result = best;
      result.secondBest = secondBest;
      return result;
    }
    function updateClassName(element, currentLang, resultLang) {
      const language = currentLang && aliases[currentLang] || resultLang;
      element.classList.add("hljs");
      element.classList.add(`language-${language}`);
    }
    function highlightElement(element) {
      let node = null;
      const language = blockLanguage(element);
      if (shouldNotHighlight(language))
        return;
      fire("before:highlightElement", {el: element, language});
      if (!options.ignoreUnescapedHTML && element.children.length > 0) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/issues/2886");
        console.warn(element);
      }
      node = element;
      const text = node.textContent;
      const result = language ? highlight2(text, {language, ignoreIllegals: true}) : highlightAuto(text);
      element.innerHTML = result.value;
      updateClassName(element, language, result.language);
      element.result = {
        language: result.language,
        re: result.relevance,
        relevance: result.relevance
      };
      if (result.secondBest) {
        element.secondBest = {
          language: result.secondBest.language,
          relevance: result.secondBest.relevance
        };
      }
      fire("after:highlightElement", {el: element, result, text});
    }
    function configure(userOptions) {
      options = inherit(options, userOptions);
    }
    const initHighlighting = () => {
      highlightAll();
      deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function initHighlightingOnLoad() {
      highlightAll();
      deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let wantsHighlight = false;
    function highlightAll() {
      if (document.readyState === "loading") {
        wantsHighlight = true;
        return;
      }
      const blocks = document.querySelectorAll(options.cssSelector);
      blocks.forEach(highlightElement);
    }
    function boot() {
      if (wantsHighlight)
        highlightAll();
    }
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("DOMContentLoaded", boot, false);
    }
    function registerLanguage(languageName, languageDefinition) {
      let lang = null;
      try {
        lang = languageDefinition(hljs);
      } catch (error$1) {
        error("Language definition for '{}' could not be registered.".replace("{}", languageName));
        if (!SAFE_MODE) {
          throw error$1;
        } else {
          error(error$1);
        }
        lang = PLAINTEXT_LANGUAGE;
      }
      if (!lang.name)
        lang.name = languageName;
      languages[languageName] = lang;
      lang.rawDefinition = languageDefinition.bind(null, hljs);
      if (lang.aliases) {
        registerAliases(lang.aliases, {languageName});
      }
    }
    function unregisterLanguage(languageName) {
      delete languages[languageName];
      for (const alias of Object.keys(aliases)) {
        if (aliases[alias] === languageName) {
          delete aliases[alias];
        }
      }
    }
    function listLanguages() {
      return Object.keys(languages);
    }
    function getLanguage(name2) {
      name2 = (name2 || "").toLowerCase();
      return languages[name2] || languages[aliases[name2]];
    }
    function registerAliases(aliasList, {languageName}) {
      if (typeof aliasList === "string") {
        aliasList = [aliasList];
      }
      aliasList.forEach((alias) => {
        aliases[alias.toLowerCase()] = languageName;
      });
    }
    function autoDetection(name2) {
      const lang = getLanguage(name2);
      return lang && !lang.disableAutodetect;
    }
    function upgradePluginAPI(plugin) {
      if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
        plugin["before:highlightElement"] = (data) => {
          plugin["before:highlightBlock"](Object.assign({block: data.el}, data));
        };
      }
      if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
        plugin["after:highlightElement"] = (data) => {
          plugin["after:highlightBlock"](Object.assign({block: data.el}, data));
        };
      }
    }
    function addPlugin(plugin) {
      upgradePluginAPI(plugin);
      plugins.push(plugin);
    }
    function fire(event2, args) {
      const cb = event2;
      plugins.forEach(function(plugin) {
        if (plugin[cb]) {
          plugin[cb](args);
        }
      });
    }
    function deprecateHighlightBlock(el) {
      deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
      deprecated("10.7.0", "Please use highlightElement now.");
      return highlightElement(el);
    }
    Object.assign(hljs, {
      highlight: highlight2,
      highlightAuto,
      highlightAll,
      highlightElement,
      highlightBlock: deprecateHighlightBlock,
      configure,
      initHighlighting,
      initHighlightingOnLoad,
      registerLanguage,
      unregisterLanguage,
      listLanguages,
      getLanguage,
      registerAliases,
      autoDetection,
      inherit,
      addPlugin
    });
    hljs.debugMode = function() {
      SAFE_MODE = false;
    };
    hljs.safeMode = function() {
      SAFE_MODE = true;
    };
    hljs.versionString = version$1;
    for (const key in MODES) {
      if (typeof MODES[key] === "object") {
        deepFreeze$1(MODES[key]);
      }
    }
    Object.assign(hljs, MODES);
    return hljs;
  };
  var highlight = HLJS({});
  var core$1 = highlight;
  const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
  const KEYWORDS = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ];
  const LITERALS = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ];
  const TYPES = [
    "Intl",
    "DataView",
    "Number",
    "Math",
    "Date",
    "String",
    "RegExp",
    "Object",
    "Function",
    "Boolean",
    "Error",
    "Symbol",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "Proxy",
    "Reflect",
    "JSON",
    "Promise",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Float32Array",
    "Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "ArrayBuffer",
    "BigInt64Array",
    "BigUint64Array",
    "BigInt"
  ];
  const ERROR_TYPES = [
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ];
  const BUILT_IN_GLOBALS = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  const BUILT_IN_VARIABLES = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "module",
    "global"
  ];
  const BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
  function source(re) {
    if (!re)
      return null;
    if (typeof re === "string")
      return re;
    return re.source;
  }
  function lookahead(re) {
    return concat("(?=", re, ")");
  }
  function concat(...args) {
    const joined = args.map((x) => source(x)).join("");
    return joined;
  }
  function javascript(hljs) {
    const hasClosingTag = (match, {after}) => {
      const tag = "</" + match[0].slice(1);
      const pos = match.input.indexOf(tag, after);
      return pos !== -1;
    };
    const IDENT_RE$12 = IDENT_RE;
    const FRAGMENT = {
      begin: "<>",
      end: "</>"
    };
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (match, response) => {
        const afterMatchIndex = match[0].length + match.index;
        const nextChar = match.input[afterMatchIndex];
        if (nextChar === "<") {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match, {after: afterMatchIndex})) {
            response.ignoreMatch();
          }
        }
      }
    };
    const KEYWORDS$1 = {
      $pattern: IDENT_RE,
      keyword: KEYWORDS,
      literal: LITERALS,
      built_in: BUILT_INS,
      "variable.language": BUILT_IN_VARIABLES
    };
    const decimalDigits = "[0-9](_?[0-9])*";
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER = {
      className: "number",
      variants: [
        {begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b`},
        {begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b`},
        {begin: `\\b(0|[1-9](_?[0-9])*)n\\b`},
        {begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},
        {begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"},
        {begin: "\\b0[oO][0-7](_?[0-7])*n?\\b"},
        {begin: "\\b0[0-7]+n?\\b"}
      ],
      relevance: 0
    };
    const SUBST = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: KEYWORDS$1,
      contains: []
    };
    const HTML_TEMPLATE = {
      begin: "html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "xml"
      }
    };
    const CSS_TEMPLATE = {
      begin: "css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "css"
      }
    };
    const TEMPLATE_STRING = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    });
    const COMMENT2 = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      NUMBER,
      hljs.REGEXP_MODE
    ];
    SUBST.contains = SUBST_INTERNALS.concat({
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
    const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1,
      contains: PARAMS_CONTAINS
    };
    const CLASS_OR_EXTENDS = {
      variants: [
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$12
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        },
        {
          match: [
            /extends/,
            /\s+/,
            concat(IDENT_RE$12, "(", concat(/\./, IDENT_RE$12), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class.inherited"
          }
        }
      ]
    };
    const CLASS_REFERENCE = {
      relevance: 0,
      match: /\b[A-Z][a-z]+([A-Z][a-z]+)*/,
      className: "title.class",
      keywords: {
        _: [
          ...TYPES,
          ...ERROR_TYPES
        ]
      }
    };
    const USE_STRICT = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    };
    const FUNCTION_DEFINITION = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            IDENT_RE$12,
            /(?=\s*\()/
          ]
        },
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [PARAMS],
      illegal: /%/
    };
    const UPPER_CASE_CONSTANT = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function noneOf(list) {
      return concat("(?!", list.join("|"), ")");
    }
    const FUNCTION_CALL = {
      match: concat(/\b/, noneOf([
        ...BUILT_IN_GLOBALS,
        "super"
      ]), IDENT_RE$12, lookahead(/\(/)),
      className: "title.function",
      relevance: 0
    };
    const PROPERTY_ACCESS = {
      begin: concat(/\./, lookahead(concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/))),
      end: IDENT_RE$12,
      excludeBegin: true,
      keywords: "prototype",
      className: "property",
      relevance: 0
    };
    const GETTER_OR_SETTER = {
      match: [
        /get|set/,
        /\s+/,
        IDENT_RE$12,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          begin: /\(\)/
        },
        PARAMS
      ]
    };
    const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
    const FUNCTION_VARIABLE = {
      match: [
        /const|var|let/,
        /\s+/,
        IDENT_RE$12,
        /\s*/,
        /=\s*/,
        lookahead(FUNC_LEAD_IN_RE)
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        PARAMS
      ]
    };
    return {
      name: "Javascript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: KEYWORDS$1,
      exports: {PARAMS_CONTAINS},
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        USE_STRICT,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT2,
        NUMBER,
        CLASS_REFERENCE,
        {
          className: "attr",
          begin: IDENT_RE$12 + lookahead(":"),
          relevance: 0
        },
        FUNCTION_VARIABLE,
        {
          begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            COMMENT2,
            hljs.REGEXP_MODE,
            {
              className: "function",
              begin: FUNC_LEAD_IN_RE,
              returnBegin: true,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: hljs.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              variants: [
                {begin: FRAGMENT.begin, end: FRAGMENT.end},
                {
                  begin: XML_TAG.begin,
                  "on:begin": XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        FUNCTION_DEFINITION,
        {
          beginKeywords: "while if switch catch for"
        },
        {
          begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          returnBegin: true,
          label: "func.def",
          contains: [
            PARAMS,
            hljs.inherit(hljs.TITLE_MODE, {begin: IDENT_RE$12, className: "title.function"})
          ]
        },
        {
          match: /\.\.\./,
          relevance: 0
        },
        PROPERTY_ACCESS,
        {
          match: "\\$" + IDENT_RE$12,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: {1: "title.function"},
          contains: [PARAMS]
        },
        FUNCTION_CALL,
        UPPER_CASE_CONSTANT,
        CLASS_OR_EXTENDS,
        GETTER_OR_SETTER,
        {
          match: /\$[(.]/
        }
      ]
    };
  }
  var __css = '.hljs {\n  display: block;\n  overflow: hidden;\n  padding: var(--sd01316575b3, 36px);\n    background-color: hsl(calc(var(--s7b534edb88a, 0) + var(--sa80402b0d8e ,0)),calc((var(--sc7a52dcde08, 0) + var(--s1d1113224ce, 0)) * 1%),calc((var(--s5c150a822d7, 0) + var(--sd4879157327, 0)) * 1%));\n    line-height: 1.5 !important;\n}\n\n    .hljs,\n    .hljs.hljs-subst {\n        color: hsl(calc(var(--s7b534edb88a, 0) + var(--sc39354d1af2 ,0)),calc((var(--sc7a52dcde08, 0) + var(--s09c08b260e1, 0)) * 1%),calc((var(--s5c150a822d7, 0) + var(--s50ab8e66b2c, 0)) * 1%));\n    }\n\n    .hljs .hljs-selector-tag {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-selector-id {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n        font-weight: bold;\n    }\n\n    .hljs .hljs-selector-class {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-selector-attr {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-selector-pseudo {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-addition {\n        background-color: rgba(163, 190, 140, 0.5);\n    }\n\n    .hljs .hljs-deletion {\n        background-color: rgba(191, 97, 106, 0.5);\n    }\n\n    .hljs .hljs-built_in,\n    .hljs .hljs-type {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-class {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-function {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-function > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-keyword,\n    .hljs .hljs-literal,\n    .hljs .hljs-symbol {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-number {\n        color: #B48EAD;\n    }\n\n    .hljs .hljs-regexp {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,0)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-string {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,0)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-title {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-params {\n        color: hsl(calc(var(--s23a18b2a895, 0) + var(--s3e498f0051f ,0)),calc((var(--s717cbee6455, 0) + var(--s3a350fde854, 0)) * 1%),calc((var(--s97f83997c61, 0) + var(--sd8400ed1cd2, 0)) * 1%));\n    }\n\n    .hljs .hljs-bullet {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-code {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-emphasis {\n        font-style: italic;\n    }\n\n    .hljs .hljs-formula {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-strong {\n        font-weight: bold;\n    }\n\n    .hljs .hljs-link:hover {\n        text-decoration: underline;\n    }\n\n    .hljs .hljs-quote {\n        color: hsl(calc(var(--s7b534edb88a, 0) + var(--sc39354d1af2 ,0)),calc((var(--sc7a52dcde08, 0) + var(--s09c08b260e1, 0)) * 1%),calc((var(--s5c150a822d7, 0) + var(--s50ab8e66b2c, 0)) * 1%));\n    }\n\n    .hljs .hljs-comment {\n        color: hsl(calc(var(--s7b534edb88a, 0) + var(--sc39354d1af2 ,0)),calc((var(--sc7a52dcde08, 0) + var(--s09c08b260e1, 0)) * 1%),calc((var(--s5c150a822d7, 0) + var(--s50ab8e66b2c, 0)) * 1%));\n    }\n\n    .hljs .hljs-doctag {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-meta,\n    .hljs .hljs-meta-keyword {\n        color: #5E81AC;\n    }\n\n    .hljs .hljs-meta-string {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,0)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-attr {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs .hljs-attribute {\n        color: hsl(calc(var(--s23a18b2a895, 0) + var(--s3e498f0051f ,0)),calc((var(--s717cbee6455, 0) + var(--s3a350fde854, 0)) * 1%),calc((var(--s97f83997c61, 0) + var(--sd8400ed1cd2, 0)) * 1%));\n    }\n\n    .hljs .hljs-builtin-name {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-name {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-section {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-tag {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs .hljs-variable {\n        color: hsl(calc(var(--s23a18b2a895, 0) + var(--s3e498f0051f ,0)),calc((var(--s717cbee6455, 0) + var(--s3a350fde854, 0)) * 1%),calc((var(--s97f83997c61, 0) + var(--sd8400ed1cd2, 0)) * 1%));\n    }\n\n    .hljs .hljs-template-variable {\n        color: hsl(calc(var(--s23a18b2a895, 0) + var(--s3e498f0051f ,0)),calc((var(--s717cbee6455, 0) + var(--s3a350fde854, 0)) * 1%),calc((var(--s97f83997c61, 0) + var(--sd8400ed1cd2, 0)) * 1%));\n    }\n\n    .hljs .hljs-template-tag {\n        color: #5E81AC;\n    }\n\n    .hljs.abnf .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.abnf .hljs-symbol {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,0)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs.apache .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.apache .hljs-section {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs.arduino .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.aspectj .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.aspectj > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs.bnf .hljs-attribute {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs.clojure .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.clojure .hljs-symbol {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,0)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs.coq .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.cpp .hljs-meta-string {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs.css .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.css .hljs-keyword {\n        color: #D08770;\n    }\n\n    .hljs.diff .hljs-meta {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs.ebnf .hljs-attribute {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs.glsl .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.groovy .hljs-meta:not(:first-child) {\n        color: #D08770;\n    }\n\n    .hljs.haxe .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.java .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.ldif .hljs-attribute {\n        color: hsl(calc(var(--sffeaf450a8d, 0) + var(--s39128950653 ,0)),calc((var(--s4e68fd1fdd3, 0) + var(--s5917f772977, 0)) * 1%),calc((var(--s4453219ff01, 0) + var(--s48280348eb7, 0)) * 1%));\n    }\n\n    .hljs.lisp .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.lua .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.moonscript .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-section {\n        color: #5E81AC;\n    }\n\n    .hljs.pf .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.processing .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.scss .hljs-keyword {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs.stylus .hljs-keyword {\n        color: hsl(calc(var(--se1bfb3b758c, 0) + var(--s316562e3fed ,340)),calc((var(--s445835177de, 0) + var(--s1373b5284cd, 0)) * 1%),calc((var(--s9cd72d9418e, 0) + var(--s84f63a9bd98, 0)) * 1%));\n    }\n\n    .hljs.swift .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.vim .hljs-built_in {\n        color: #88C0D0;\n        font-style: italic;\n    }\n\n    .hljs.yaml .hljs-meta {\n        color: #D08770;\n    }\n\n:host {  \n    display: block;\n    border-radius: var(--s08aadeccb61, 10px);\n    border: hsl(calc(var(--s7b534edb88a, 0) + var(--sa5e55e502c3 ,0)),calc((var(--sc7a52dcde08, 0) + var(--s251d3c4171d, 0)) * 1%),calc((var(--s5c150a822d7, 0) + var(--sc94e47021cd, 0)) * 1%)) solid 1px;\n    overflow: hidden;\n}\n\n  .s-code-example__slot {\n    display: none;\n  }\n\n  .s-code-example__nav {\n    position: relative;\n  }\n\n  .s-code-example__tabs {\n    display: flex;\n    list-style: none;\n    border-bottom-left-radius: 0 !important;\n    border-bottom-right-radius: 0 !important;\n  }\n  .s-code-example__tab {\n\n  }\n\n  .s-code-example__content {\n    overflow: hidden;\n    position: relative;\n  }\n\n  .s-code-example__code {\n    display: none;\n    border-top-left-radius: 0 !important;\n    border-top-right-radius: 0 !important;\n    overflow: hidden;\n    line-height: 0;\n  }\n\n  .s-code-example__code[active] {\n      display: block;\n    }\n\n  .s-code-example__code > code {\n      line-height: 1;\n    }\n\n  .s-code-example__toolbar {\n    position: absolute;\n    right: var(--s93aeae3f06c, 24px);\n    top: var(--s93aeae3f06c, 24px);\n    z-index: 10;\n  }\n\n  .s-code-example__toolbar > * {\n      font-size: 20px;\n      opacity: 0.5;\n    }\n\n  .s-code-example__toolbar > *:hover {\n        opacity: 1;\n      }\n\n  [toolbar-position="nav"] .s-code-example__toolbar {\n      right: var(--s93aeae3f06c, 24px);\n      top: 50%;\n      transform: translate(0, -50%);\n    }';
  class SHighlightJsComponentInterface extends SInterface {
  }
  SHighlightJsComponentInterface.definition = __spreadProps(__spreadValues({}, SComponentUtilsDefaultInterface.definition), {
    theme: {
      type: "String",
      default: "https://gitcdn.link/repo/PrismJS/prism-themes/master/themes/prism-nord.css"
    },
    active: {
      type: "String"
    },
    toolbar: {
      type: "Array<String>",
      values: ["copy"],
      default: ["copy"]
    },
    toolbarPosition: {
      type: "String",
      values: ["content", "nav"],
      default: "content"
    },
    defaultStyleClasses: {
      type: "Object",
      default: {
        main: "s-tabs"
      }
    }
  });
  var __decorate$2 = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __awaiter$5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  core$1.registerLanguage("javascript", javascript);
  webcomponent$3();
  class SCodeExample extends LitElement {
    constructor() {
      super();
      this._component = void 0;
      this._$copy = void 0;
      this._items = [];
      this._activeTabId = void 0;
      this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
        interface: SHighlightJsComponentInterface,
        defaultProps: {}
      });
    }
    static get styles() {
      return css`${unsafeCSS(__css)}`;
    }
    firstUpdated() {
      this.$templates.forEach(($template) => {
        var _a, _b, _c;
        if (!$template.getAttribute)
          return;
        this._items = [...this._items, {
          id: (_b = (_a = $template.getAttribute("id")) !== null && _a !== void 0 ? _a : $template.getAttribute("language")) !== null && _b !== void 0 ? _b : $template.getAttribute("lang"),
          lang: (_c = $template.getAttribute("language")) !== null && _c !== void 0 ? _c : $template.getAttribute("lang"),
          code: $template.innerHTML
        }];
        $template.remove();
      });
      if (this.active) {
        this.setActiveTab(this.active);
      } else {
        this.setActiveTab(this._items[0].id);
      }
    }
    render() {
      var _a, _b, _c, _d;
      return html`
            <div class="${(_a = this._component) === null || _a === void 0 ? void 0 : _a.className()}" toolbar-position="${(_b = this._component) === null || _b === void 0 ? void 0 : _b.props.toolbarPosition}">

            <div class="templates">
                <slot></slot>
            </div>

            ${this._component ? html`<header class="${this._component.className("__nav")}">
                <ol class="${this._component.className("__tabs", this._component.props.defaultStyleClasses.main)}">
                    ${((_c = this._items) !== null && _c !== void 0 ? _c : []).map((item) => html`
                        <li class="${this._component.className("__tab")}"
                            id="${item.id}"
                            ?active="${this._activeTabId === item.id}"
                            @click="${this.setActiveTabByTab}">
                            ${item.lang}
                        </li>
                    `)}
                </ol>
                ${this._component.props.toolbarPosition === "nav" ? html`
                    <div class="${this._component.className("__toolbar")}">
                        <s-clipboard-copy @click="${this.copy}"></s-clipboard-copy>
                    </div>
                ` : ""}
            </header>` : ""}
            ${this._component ? html`
                <div class="${this._component.className("__content")}">
                    ${this._component.props.toolbarPosition !== "nav" ? html`
                        <div class="${this._component.className("__toolbar")}">
                            <s-clipboard-copy @click="${this.copy}"></s-clipboard-copy>
                        </div>
                    ` : ""}
                    ${((_d = this._items) !== null && _d !== void 0 ? _d : []).map((item) => {
        var _a2, _b2;
        return html`
                        <pre class="${this._component.className("__code")}"
                            style="line-height:0;"   
                            id="${(_a2 = item.id) !== null && _a2 !== void 0 ? _a2 : item.lang}"
                            ?active="${this._activeTabId === ((_b2 = item.id) !== null && _b2 !== void 0 ? _b2 : item.lang)}">
                            <code class="language-${item.lang} ${item.lang} ${this._component.props.defaultStyle ? "hljs" : ""}">
                                ${item.code}
                            </code>
                        </pre>
                    `;
      })}
                </div>
            ` : ""}
        </div>
        `;
    }
    setActiveTabByTab(e) {
      this.setActiveTab(e.target.id);
    }
    setActiveTab(id) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield wait();
        this._activeTabId = id;
        this.initPrismOnTab(id);
      });
    }
    initPrismOnTab(id) {
      const $content = this.shadowRoot.querySelector(`pre#${id} code`);
      if ($content.hasAttribute("inited"))
        return;
      $content.setAttribute("inited", true);
      const highlightedCode = core$1.highlight($content === null || $content === void 0 ? void 0 : $content.innerHTML, {language: "js"}).value.trim();
      $content === null || $content === void 0 ? void 0 : $content.innerHTML = highlightedCode;
    }
    copy() {
      const id = this._activeTabId;
      const item = this._items.filter((i) => i.id === id)[0];
      this.$copy.copy(item.code);
    }
  }
  __decorate$2([
    property()
  ], SCodeExample.prototype, "_items", void 0);
  __decorate$2([
    property()
  ], SCodeExample.prototype, "_activeTabId", void 0);
  __decorate$2([
    property({
      type: String
    })
  ], SCodeExample.prototype, "active", void 0);
  __decorate$2([
    property()
  ], SCodeExample.prototype, "props", void 0);
  __decorate$2([
    query("s-clipboard-copy")
  ], SCodeExample.prototype, "$copy", void 0);
  __decorate$2([
    query(".templates")
  ], SCodeExample.prototype, "$templatesContainer", void 0);
  __decorate$2([
    queryAssignedNodes()
  ], SCodeExample.prototype, "$templates", void 0);
  function webcomponent$2(tagName = "s-code-example") {
    customElements.define(tagName, SCodeExample);
  }
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  function uniqid() {
    return uuid_1.v4();
  }
  function matches$1(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer$1;
  const _selectors$1 = {};
  function querySelectorLive$1(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors$1[selector]) {
      _selectors$1[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors$1[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors$1[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors$1[obj.selector];
          });
        });
      }
      if (!_observer$1) {
        _observer$1 = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors$1);
                selectors.forEach((sel) => {
                  if (matches$1(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors$1);
              selectors.forEach((sel) => {
                if (matches$1(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer$1.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var a = Object.defineProperty({}, "__esModule", {value: true});
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var riot_compiler = {exports: {}};
  var __viteBrowserExternal_fs$1 = new Proxy({}, {
    get() {
      throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_fs$1$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_fs$1});
  var require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_fs$1$1);
  var __viteBrowserExternal_path = new Proxy({}, {
    get() {
      throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_path$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_path});
  var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_path$1);
  /* Riot v5.4.2, @license MIT */
  (function(module, exports) {
    (function(global2, factory) {
      module.exports = factory(require$$0$4, require$$1$1);
    })(commonjsGlobal, function() {
      function camelToDashCase(string) {
        return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
      function dashToCamelCase(string) {
        return string.replace(/-(\w)/g, (_, c) => c.toUpperCase());
      }
      function DOMattributesToObject(element) {
        return Array.from(element.attributes).reduce((acc, attribute) => {
          acc[dashToCamelCase(attribute.name)] = attribute.value;
          return acc;
        }, {});
      }
      function moveChildren(source, target) {
        if (source.firstChild) {
          target.appendChild(source.firstChild);
          moveChildren(source, target);
        }
      }
      function cleanNode(node) {
        clearChildren(node.childNodes);
      }
      function clearChildren(children) {
        Array.from(children).forEach(removeChild);
      }
      const removeChild = (node) => node && node.parentNode && node.parentNode.removeChild(node);
      const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);
      const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);
      const COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(), DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol("riot-component"), PLUGINS_SET$1 = new Set(), IS_DIRECTIVE = "is", VALUE_ATTRIBUTE = "value", MOUNT_METHOD_KEY = "mount", UPDATE_METHOD_KEY = "update", UNMOUNT_METHOD_KEY = "unmount", SHOULD_UPDATE_KEY = "shouldUpdate", ON_BEFORE_MOUNT_KEY = "onBeforeMount", ON_MOUNTED_KEY = "onMounted", ON_BEFORE_UPDATE_KEY = "onBeforeUpdate", ON_UPDATED_KEY = "onUpdated", ON_BEFORE_UNMOUNT_KEY = "onBeforeUnmount", ON_UNMOUNTED_KEY = "onUnmounted", PROPS_KEY = "props", STATE_KEY = "state", SLOTS_KEY = "slots", ROOT_KEY = "root", IS_PURE_SYMBOL = Symbol("pure"), IS_COMPONENT_UPDATING = Symbol("is_updating"), PARENT_KEY_SYMBOL = Symbol("parent"), ATTRIBUTES_KEY_SYMBOL = Symbol("attributes"), TEMPLATE_KEY_SYMBOL = Symbol("template");
      var globals = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,
        DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,
        PLUGINS_SET: PLUGINS_SET$1,
        IS_DIRECTIVE,
        VALUE_ATTRIBUTE,
        MOUNT_METHOD_KEY,
        UPDATE_METHOD_KEY,
        UNMOUNT_METHOD_KEY,
        SHOULD_UPDATE_KEY,
        ON_BEFORE_MOUNT_KEY,
        ON_MOUNTED_KEY,
        ON_BEFORE_UPDATE_KEY,
        ON_UPDATED_KEY,
        ON_BEFORE_UNMOUNT_KEY,
        ON_UNMOUNTED_KEY,
        PROPS_KEY,
        STATE_KEY,
        SLOTS_KEY,
        ROOT_KEY,
        IS_PURE_SYMBOL,
        IS_COMPONENT_UPDATING,
        PARENT_KEY_SYMBOL,
        ATTRIBUTES_KEY_SYMBOL,
        TEMPLATE_KEY_SYMBOL
      });
      const EACH = 0;
      const IF = 1;
      const SIMPLE = 2;
      const TAG = 3;
      const SLOT = 4;
      var bindingTypes = {
        EACH,
        IF,
        SIMPLE,
        TAG,
        SLOT
      };
      const ATTRIBUTE = 0;
      const EVENT = 1;
      const TEXT = 2;
      const VALUE = 3;
      var expressionTypes = {
        ATTRIBUTE,
        EVENT,
        TEXT,
        VALUE
      };
      const HEAD_SYMBOL = Symbol("head");
      const TAIL_SYMBOL = Symbol("tail");
      function createHeadTailPlaceholders() {
        const head = document.createComment("fragment head");
        const tail = document.createComment("fragment tail");
        head[HEAD_SYMBOL] = true;
        tail[TAIL_SYMBOL] = true;
        return {
          head,
          tail
        };
      }
      function createTemplateMeta(componentTemplate) {
        const fragment = componentTemplate.dom.cloneNode(true);
        const {
          head,
          tail
        } = createHeadTailPlaceholders();
        return {
          avoidDOMInjection: true,
          fragment,
          head,
          tail,
          children: [head, ...Array.from(fragment.childNodes), tail]
        };
      }
      function getFragmentChildren(_ref) {
        let {
          head,
          tail
        } = _ref;
        const nodes = walkNodes([head], head.nextSibling, (n) => n === tail, false);
        nodes.push(tail);
        return nodes;
      }
      function walkNodes(children, node, check, isFilterActive) {
        const {
          nextSibling
        } = node;
        if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {
          children.push(node);
        }
        if (!nextSibling || check(node))
          return children;
        return walkNodes(children, nextSibling, check, isFilterActive && !node[TAIL_SYMBOL] || nextSibling[HEAD_SYMBOL]);
      }
      function checkType(element, type) {
        return typeof element === type;
      }
      function isSvg(el) {
        const owner = el.ownerSVGElement;
        return !!owner || owner === null;
      }
      function isTemplate(el) {
        return !isNil(el.content);
      }
      function isFunction(value) {
        return checkType(value, "function");
      }
      function isBoolean(value) {
        return checkType(value, "boolean");
      }
      function isObject(value) {
        return !isNil(value) && value.constructor === Object;
      }
      function isNil(value) {
        return value === null || value === void 0;
      }
      var udomdiff = (a, b, get2, before) => {
        const bLength = b.length;
        let aEnd = a.length;
        let bEnd = bLength;
        let aStart = 0;
        let bStart = 0;
        let map = null;
        while (aStart < aEnd || bStart < bEnd) {
          if (aEnd === aStart) {
            const node = bEnd < bLength ? bStart ? get2(b[bStart - 1], -0).nextSibling : get2(b[bEnd - bStart], 0) : before;
            while (bStart < bEnd)
              insertBefore(get2(b[bStart++], 1), node);
          } else if (bEnd === bStart) {
            while (aStart < aEnd) {
              if (!map || !map.has(a[aStart]))
                removeChild(get2(a[aStart], -1));
              aStart++;
            }
          } else if (a[aStart] === b[bStart]) {
            aStart++;
            bStart++;
          } else if (a[aEnd - 1] === b[bEnd - 1]) {
            aEnd--;
            bEnd--;
          } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
            const node = get2(a[--aEnd], -1).nextSibling;
            insertBefore(get2(b[bStart++], 1), get2(a[aStart++], -1).nextSibling);
            insertBefore(get2(b[--bEnd], 1), node);
            a[aEnd] = b[bEnd];
          } else {
            if (!map) {
              map = new Map();
              let i = bStart;
              while (i < bEnd)
                map.set(b[i], i++);
            }
            if (map.has(a[aStart])) {
              const index = map.get(a[aStart]);
              if (bStart < index && index < bEnd) {
                let i = aStart;
                let sequence = 1;
                while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)
                  sequence++;
                if (sequence > index - bStart) {
                  const node = get2(a[aStart], 0);
                  while (bStart < index)
                    insertBefore(get2(b[bStart++], 1), node);
                } else {
                  replaceChild(get2(b[bStart++], 1), get2(a[aStart++], -1));
                }
              } else
                aStart++;
            } else
              removeChild(get2(a[aStart++], -1));
          }
        }
        return b;
      };
      const UNMOUNT_SCOPE = Symbol("unmount");
      const EachBinding = {
        nodes: [],
        mount(scope, parentScope) {
          return this.update(scope, parentScope);
        },
        update(scope, parentScope) {
          const {
            placeholder,
            nodes,
            childrenMap
          } = this;
          const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);
          const items = collection ? Array.from(collection) : [];
          const {
            newChildrenMap,
            batches,
            futureNodes
          } = createPatch(items, scope, parentScope, this);
          udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder);
          batches.forEach((fn) => fn());
          this.childrenMap = newChildrenMap;
          this.nodes = futureNodes;
          markEdgeNodes(this.nodes);
          return this;
        },
        unmount(scope, parentScope) {
          this.update(UNMOUNT_SCOPE, parentScope);
          return this;
        }
      };
      function patch(redundant, parentScope) {
        return (item, info) => {
          if (info < 0) {
            const element = redundant[redundant.length - 1];
            if (element) {
              const {
                template,
                nodes,
                context
              } = element;
              nodes.pop();
              if (nodes.length === 0) {
                redundant.pop();
                template.unmount(context, parentScope, null);
              }
            }
          }
          return item;
        };
      }
      function mustFilterItem(condition, context) {
        return condition ? Boolean(condition(context)) === false : false;
      }
      function extendScope(scope, _ref) {
        let {
          itemName,
          indexName,
          index,
          item
        } = _ref;
        scope[itemName] = item;
        if (indexName)
          scope[indexName] = index;
        return scope;
      }
      function markEdgeNodes(nodes) {
        const first = nodes[0];
        const last = nodes[nodes.length - 1];
        if (first)
          first[HEAD_SYMBOL] = true;
        if (last)
          last[TAIL_SYMBOL] = true;
      }
      function createPatch(items, scope, parentScope, binding) {
        const {
          condition,
          template,
          childrenMap,
          itemName,
          getKey,
          indexName,
          root,
          isTemplateTag
        } = binding;
        const newChildrenMap = new Map();
        const batches = [];
        const futureNodes = [];
        items.forEach((item, index) => {
          const context = extendScope(Object.create(scope), {
            itemName,
            indexName,
            index,
            item
          });
          const key = getKey ? getKey(context) : index;
          const oldItem = childrenMap.get(key);
          const nodes = [];
          if (mustFilterItem(condition, context)) {
            return;
          }
          const mustMount = !oldItem;
          const componentTemplate = oldItem ? oldItem.template : template.clone();
          const el = componentTemplate.el || root.cloneNode();
          const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;
          if (mustMount) {
            batches.push(() => componentTemplate.mount(el, context, parentScope, meta));
          } else {
            batches.push(() => componentTemplate.update(context, parentScope));
          }
          if (isTemplateTag) {
            nodes.push(...mustMount ? meta.children : getFragmentChildren(meta));
          } else {
            nodes.push(el);
          }
          childrenMap.delete(key);
          futureNodes.push(...nodes);
          newChildrenMap.set(key, {
            nodes,
            template: componentTemplate,
            context,
            index
          });
        });
        return {
          newChildrenMap,
          batches,
          futureNodes
        };
      }
      function create$6(node, _ref2) {
        let {
          evaluate: evaluate2,
          condition,
          itemName,
          indexName,
          getKey,
          template
        } = _ref2;
        const placeholder = document.createTextNode("");
        const root = node.cloneNode();
        insertBefore(placeholder, node);
        removeChild(node);
        return Object.assign({}, EachBinding, {
          childrenMap: new Map(),
          node,
          root,
          condition,
          evaluate: evaluate2,
          isTemplateTag: isTemplate(root),
          template: template.createDOM(node),
          getKey,
          indexName,
          itemName,
          placeholder
        });
      }
      const IfBinding = {
        mount(scope, parentScope) {
          return this.update(scope, parentScope);
        },
        update(scope, parentScope) {
          const value = !!this.evaluate(scope);
          const mustMount = !this.value && value;
          const mustUnmount = this.value && !value;
          const mount2 = () => {
            const pristine = this.node.cloneNode();
            insertBefore(pristine, this.placeholder);
            this.template = this.template.clone();
            this.template.mount(pristine, scope, parentScope);
          };
          switch (true) {
            case mustMount:
              mount2();
              break;
            case mustUnmount:
              this.unmount(scope);
              break;
            default:
              if (value)
                this.template.update(scope, parentScope);
          }
          this.value = value;
          return this;
        },
        unmount(scope, parentScope) {
          this.template.unmount(scope, parentScope, true);
          return this;
        }
      };
      function create$5(node, _ref) {
        let {
          evaluate: evaluate2,
          template
        } = _ref;
        const placeholder = document.createTextNode("");
        insertBefore(placeholder, node);
        removeChild(node);
        return Object.assign({}, IfBinding, {
          node,
          evaluate: evaluate2,
          placeholder,
          template: template.createDOM(node)
        });
      }
      function panic(message) {
        throw new Error(message);
      }
      function memoize(fn) {
        const cache = new Map();
        const cached = (val) => {
          return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
        };
        cached.cache = cache;
        return cached;
      }
      function evaluateAttributeExpressions(attributes) {
        return attributes.reduce((acc, attribute) => {
          const {
            value,
            type
          } = attribute;
          switch (true) {
            case (!attribute.name && type === ATTRIBUTE):
              return Object.assign({}, acc, value);
            case type === VALUE:
              acc.value = attribute.value;
              break;
            default:
              acc[dashToCamelCase(attribute.name)] = attribute.value;
          }
          return acc;
        }, {});
      }
      const ElementProto = typeof Element === "undefined" ? {} : Element.prototype;
      const isNativeHtmlProperty = memoize((name2) => ElementProto.hasOwnProperty(name2));
      function setAllAttributes(node, attributes) {
        Object.entries(attributes).forEach((_ref) => {
          let [name2, value] = _ref;
          return attributeExpression(node, {
            name: name2
          }, value);
        });
      }
      function removeAllAttributes(node, newAttributes, oldAttributes) {
        const newKeys = newAttributes ? Object.keys(newAttributes) : [];
        Object.keys(oldAttributes).filter((name2) => !newKeys.includes(name2)).forEach((attribute) => node.removeAttribute(attribute));
      }
      function canRenderAttribute(value) {
        return value === true || ["string", "number"].includes(typeof value);
      }
      function shouldRemoveAttribute(value) {
        return isNil(value) || value === false || value === "";
      }
      function attributeExpression(node, _ref2, value, oldValue) {
        let {
          name: name2
        } = _ref2;
        if (!name2) {
          if (oldValue) {
            removeAllAttributes(node, value, oldValue);
          }
          if (value) {
            setAllAttributes(node, value);
          }
          return;
        }
        if (!isNativeHtmlProperty(name2) && (isBoolean(value) || isObject(value) || isFunction(value))) {
          node[name2] = value;
        }
        if (shouldRemoveAttribute(value)) {
          node.removeAttribute(name2);
        } else if (canRenderAttribute(value)) {
          node.setAttribute(name2, normalizeValue(name2, value));
        }
      }
      function normalizeValue(name2, value) {
        if (value === true)
          return name2;
        return value;
      }
      const RE_EVENTS_PREFIX = /^on/;
      const getCallbackAndOptions = (value) => Array.isArray(value) ? value : [value, false];
      const EventListener = {
        handleEvent(event2) {
          this[event2.type](event2);
        }
      };
      const ListenersWeakMap = new WeakMap();
      const createListener = (node) => {
        const listener = Object.create(EventListener);
        ListenersWeakMap.set(node, listener);
        return listener;
      };
      function eventExpression(node, _ref, value) {
        let {
          name: name2
        } = _ref;
        const normalizedEventName = name2.replace(RE_EVENTS_PREFIX, "");
        const eventListener = ListenersWeakMap.get(node) || createListener(node);
        const [callback, options] = getCallbackAndOptions(value);
        const handler = eventListener[normalizedEventName];
        const mustRemoveEvent = handler && !callback;
        const mustAddEvent = callback && !handler;
        if (mustRemoveEvent) {
          node.removeEventListener(normalizedEventName, eventListener);
        }
        if (mustAddEvent) {
          node.addEventListener(normalizedEventName, eventListener, options);
        }
        eventListener[normalizedEventName] = callback;
      }
      function normalizeStringValue(value) {
        return isNil(value) ? "" : value;
      }
      const getTextNode = (node, childNodeIndex) => {
        const target = node.childNodes[childNodeIndex];
        if (target.nodeType === Node.COMMENT_NODE) {
          const textNode = document.createTextNode("");
          node.replaceChild(textNode, target);
          return textNode;
        }
        return target;
      };
      function textExpression(node, data, value) {
        node.data = normalizeStringValue(value);
      }
      function valueExpression(node, expression, value) {
        node.value = normalizeStringValue(value);
      }
      var expressions = {
        [ATTRIBUTE]: attributeExpression,
        [EVENT]: eventExpression,
        [TEXT]: textExpression,
        [VALUE]: valueExpression
      };
      const Expression = {
        mount(scope) {
          this.value = this.evaluate(scope);
          apply(this, this.value);
          return this;
        },
        update(scope) {
          const value = this.evaluate(scope);
          if (this.value !== value) {
            apply(this, value);
            this.value = value;
          }
          return this;
        },
        unmount() {
          if (this.type === EVENT)
            apply(this, null);
          return this;
        }
      };
      function apply(expression, value) {
        return expressions[expression.type](expression.node, expression, value, expression.value);
      }
      function create$4(node, data) {
        return Object.assign({}, Expression, data, {
          node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node
        });
      }
      function flattenCollectionMethods(collection, methods, context) {
        return methods.reduce((acc, method) => {
          return Object.assign({}, acc, {
            [method]: (scope) => {
              return collection.map((item) => item[method](scope)) && context;
            }
          });
        }, {});
      }
      function create$3(node, _ref) {
        let {
          expressions: expressions2
        } = _ref;
        return Object.assign({}, flattenCollectionMethods(expressions2.map((expression) => create$4(node, expression)), ["mount", "update", "unmount"]));
      }
      function extendParentScope(attributes, scope, parentScope) {
        if (!attributes || !attributes.length)
          return parentScope;
        const expressions2 = attributes.map((attr) => Object.assign({}, attr, {
          value: attr.evaluate(scope)
        }));
        return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions2));
      }
      const getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;
      const SlotBinding = {
        attributes: [],
        getTemplateScope(scope, parentScope) {
          return extendParentScope(this.attributes, scope, parentScope);
        },
        mount(scope, parentScope) {
          const templateData = scope.slots ? scope.slots.find((_ref) => {
            let {
              id
            } = _ref;
            return id === this.name;
          }) : false;
          const {
            parentNode
          } = this.node;
          const realParent = getRealParent(scope, parentScope);
          this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);
          if (this.template) {
            this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);
            this.template.children = Array.from(this.node.childNodes);
            moveSlotInnerContent(this.node);
          }
          removeChild(this.node);
          return this;
        },
        update(scope, parentScope) {
          if (this.template) {
            const realParent = getRealParent(scope, parentScope);
            this.template.update(this.getTemplateScope(scope, realParent), realParent);
          }
          return this;
        },
        unmount(scope, parentScope, mustRemoveRoot) {
          if (this.template) {
            this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);
          }
          return this;
        }
      };
      function moveSlotInnerContent(slot) {
        const child = slot && slot.firstChild;
        if (!child)
          return;
        insertBefore(child, slot);
        moveSlotInnerContent(slot);
      }
      function createSlot(node, _ref2) {
        let {
          name: name2,
          attributes
        } = _ref2;
        return Object.assign({}, SlotBinding, {
          attributes,
          node,
          name: name2
        });
      }
      function getTag(component2, slots, attributes) {
        if (slots === void 0) {
          slots = [];
        }
        if (attributes === void 0) {
          attributes = [];
        }
        if (component2) {
          return component2({
            slots,
            attributes
          });
        }
        return create(slotsToMarkup(slots), [...slotBindings(slots), {
          expressions: attributes.map((attr) => {
            return Object.assign({
              type: ATTRIBUTE
            }, attr);
          })
        }]);
      }
      function slotBindings(slots) {
        return slots.reduce((acc, _ref) => {
          let {
            bindings: bindings2
          } = _ref;
          return acc.concat(bindings2);
        }, []);
      }
      function slotsToMarkup(slots) {
        return slots.reduce((acc, slot) => {
          return acc + slot.html;
        }, "");
      }
      const TagBinding = {
        mount(scope) {
          return this.update(scope);
        },
        update(scope, parentScope) {
          const name2 = this.evaluate(scope);
          if (name2 && name2 === this.name) {
            this.tag.update(scope);
          } else {
            this.unmount(scope, parentScope, true);
            this.name = name2;
            this.tag = getTag(this.getComponent(name2), this.slots, this.attributes);
            this.tag.mount(this.node, scope);
          }
          return this;
        },
        unmount(scope, parentScope, keepRootTag) {
          if (this.tag) {
            this.tag.unmount(keepRootTag);
          }
          return this;
        }
      };
      function create$2(node, _ref2) {
        let {
          evaluate: evaluate2,
          getComponent,
          slots,
          attributes
        } = _ref2;
        return Object.assign({}, TagBinding, {
          node,
          evaluate: evaluate2,
          slots,
          attributes,
          getComponent
        });
      }
      var bindings = {
        [IF]: create$5,
        [SIMPLE]: create$3,
        [EACH]: create$6,
        [TAG]: create$2,
        [SLOT]: createSlot
      };
      function fixTextExpressionsOffset(expressions2, textExpressionsOffset) {
        return expressions2.map((e) => e.type === TEXT ? Object.assign({}, e, {
          childNodeIndex: e.childNodeIndex + textExpressionsOffset
        }) : e);
      }
      function create$1(root, binding, templateTagOffset) {
        const {
          selector,
          type,
          redundantAttribute,
          expressions: expressions2
        } = binding;
        const node = selector ? root.querySelector(selector) : root;
        if (redundantAttribute)
          node.removeAttribute(redundantAttribute);
        const bindingExpressions = expressions2 || [];
        return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {
          expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions
        }));
      }
      function createHTMLTree(html, root) {
        const template = isTemplate(root) ? root : document.createElement("template");
        template.innerHTML = html;
        return template.content;
      }
      function createSVGTree(html, container) {
        const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`, "application/xml").documentElement, true);
        return svgNode;
      }
      function createDOMTree(root, html) {
        if (isSvg(root))
          return createSVGTree(html, root);
        return createHTMLTree(html, root);
      }
      function injectDOM(el, dom) {
        switch (true) {
          case isSvg(el):
            moveChildren(dom, el);
            break;
          case isTemplate(el):
            el.parentNode.replaceChild(dom, el);
            break;
          default:
            el.appendChild(dom);
        }
      }
      function createTemplateDOM(el, html) {
        return html && (typeof html === "string" ? createDOMTree(el, html) : html);
      }
      const TemplateChunk = Object.freeze({
        createDOM(el) {
          this.dom = this.dom || createTemplateDOM(el, this.html);
          return this;
        },
        mount(el, scope, parentScope, meta) {
          if (meta === void 0) {
            meta = {};
          }
          if (!el)
            throw new Error("Please provide DOM node to mount properly your template");
          if (this.el)
            this.unmount(scope);
          const {
            fragment,
            children,
            avoidDOMInjection
          } = meta;
          const {
            parentNode
          } = children ? children[0] : el;
          const isTemplateTag = isTemplate(el);
          const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.childNodes).indexOf(el), 0) : null;
          this.isTemplateTag = isTemplateTag;
          this.createDOM(el);
          if (this.dom) {
            this.fragment = fragment || this.dom.cloneNode(true);
          }
          this.el = this.isTemplateTag ? parentNode : el;
          this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null;
          if (!avoidDOMInjection && this.fragment)
            injectDOM(el, this.fragment);
          this.bindings = this.bindingsData.map((binding) => create$1(this.el, binding, templateTagOffset));
          this.bindings.forEach((b) => b.mount(scope, parentScope));
          this.meta = meta;
          return this;
        },
        update(scope, parentScope) {
          this.bindings.forEach((b) => b.update(scope, parentScope));
          return this;
        },
        unmount(scope, parentScope, mustRemoveRoot) {
          if (this.el) {
            this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));
            switch (true) {
              case this.el[IS_PURE_SYMBOL]:
                break;
              case (this.children && mustRemoveRoot !== null):
                clearChildren(this.children);
                break;
              case mustRemoveRoot === true:
                removeChild(this.el);
                break;
              case mustRemoveRoot !== null:
                cleanNode(this.el);
                break;
            }
            this.el = null;
          }
          return this;
        },
        clone() {
          return Object.assign({}, this, {
            meta: {},
            el: null
          });
        }
      });
      function create(html, bindings2) {
        if (bindings2 === void 0) {
          bindings2 = [];
        }
        return Object.assign({}, TemplateChunk, {
          html,
          bindingsData: bindings2
        });
      }
      var DOMBindings = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        template: create,
        createBinding: create$1,
        createExpression: create$4,
        bindingTypes,
        expressionTypes
      });
      function noop() {
        return this;
      }
      function autobindMethods(source, methods) {
        methods.forEach((method) => {
          source[method] = source[method].bind(source);
        });
        return source;
      }
      function callOrAssign(source) {
        return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;
      }
      function defineProperty(source, key, value, options) {
        if (options === void 0) {
          options = {};
        }
        Object.defineProperty(source, key, Object.assign({
          value,
          enumerable: false,
          writable: false,
          configurable: true
        }, options));
        return source;
      }
      function defineProperties(source, properties, options) {
        Object.entries(properties).forEach((_ref) => {
          let [key, value] = _ref;
          defineProperty(source, key, value, options);
        });
        return source;
      }
      function defineDefaults(source, defaults) {
        Object.entries(defaults).forEach((_ref2) => {
          let [key, value] = _ref2;
          if (!source[key])
            source[key] = value;
        });
        return source;
      }
      function domToArray(els) {
        if (!Array.isArray(els)) {
          if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === "number")
            return Array.from(els);
          else
            return [els];
        }
        return els;
      }
      function $(selector, ctx) {
        return domToArray(typeof selector === "string" ? (ctx || document).querySelectorAll(selector) : selector);
      }
      const normalize = (values) => values.length === 1 ? values[0] : values;
      function parseNodes(els, name2, method) {
        const names = typeof name2 === "string" ? [name2] : name2;
        return normalize(domToArray(els).map((el) => {
          return normalize(names.map((n) => el[method](n)));
        }));
      }
      function set(els, name2, value) {
        const attrs = typeof name2 === "object" ? name2 : {
          [name2]: value
        };
        const props = Object.keys(attrs);
        domToArray(els).forEach((el) => {
          props.forEach((prop) => el.setAttribute(prop, attrs[prop]));
        });
        return els;
      }
      function get(els, name2) {
        return parseNodes(els, name2, "getAttribute");
      }
      const CSS_BY_NAME = new Map();
      const STYLE_NODE_SELECTOR = "style[riot]";
      const getStyleNode = ((style) => {
        return () => {
          if (style)
            return style;
          style = $(STYLE_NODE_SELECTOR)[0] || document.createElement("style");
          set(style, "type", "text/css");
          if (!style.parentNode)
            document.head.appendChild(style);
          return style;
        };
      })();
      var cssManager = {
        CSS_BY_NAME,
        add(name2, css) {
          if (!CSS_BY_NAME.has(name2)) {
            CSS_BY_NAME.set(name2, css);
            this.inject();
          }
          return this;
        },
        inject() {
          getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join("\n");
          return this;
        },
        remove(name2) {
          if (CSS_BY_NAME.has(name2)) {
            CSS_BY_NAME.delete(name2);
            this.inject();
          }
          return this;
        }
      };
      function curry(fn) {
        for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          acc[_key - 1] = arguments[_key];
        }
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          args = [...acc, ...args];
          return args.length < fn.length ? curry(fn, ...args) : fn(...args);
        };
      }
      function getName(element) {
        return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();
      }
      const COMPONENT_CORE_HELPERS = Object.freeze({
        $(selector) {
          return $(selector, this.root)[0];
        },
        $$(selector) {
          return $(selector, this.root);
        }
      });
      const PURE_COMPONENT_API = Object.freeze({
        [MOUNT_METHOD_KEY]: noop,
        [UPDATE_METHOD_KEY]: noop,
        [UNMOUNT_METHOD_KEY]: noop
      });
      const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
        [SHOULD_UPDATE_KEY]: noop,
        [ON_BEFORE_MOUNT_KEY]: noop,
        [ON_MOUNTED_KEY]: noop,
        [ON_BEFORE_UPDATE_KEY]: noop,
        [ON_UPDATED_KEY]: noop,
        [ON_BEFORE_UNMOUNT_KEY]: noop,
        [ON_UNMOUNTED_KEY]: noop
      });
      const MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {
        clone: noop,
        createDOM: noop
      });
      const memoizedCreateComponent = memoize(createComponent);
      function evaluateInitialProps(element, initialProps) {
        if (initialProps === void 0) {
          initialProps = {};
        }
        return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));
      }
      const bindDOMNodeToComponentObject = (node, component2) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component2;
      function createCoreAPIMethods(mapFunction) {
        return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {
          acc[method] = mapFunction(method);
          return acc;
        }, {});
      }
      function componentTemplateFactory(template, componentShell) {
        const components = createSubcomponents(componentShell.exports ? componentShell.exports.components : {});
        return template(create, expressionTypes, bindingTypes, (name2) => {
          if (name2 === componentShell.name)
            return memoizedCreateComponent(componentShell);
          return components[name2] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name2);
        });
      }
      function createPureComponent(pureFactoryFunction, _ref) {
        let {
          slots,
          attributes,
          props,
          css,
          template
        } = _ref;
        if (template)
          panic("Pure components can not have html");
        if (css)
          panic("Pure components do not have css");
        const component2 = defineDefaults(pureFactoryFunction({
          slots,
          attributes,
          props
        }), PURE_COMPONENT_API);
        return createCoreAPIMethods((method) => function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (method === MOUNT_METHOD_KEY) {
            const [el] = args;
            el[IS_PURE_SYMBOL] = true;
            bindDOMNodeToComponentObject(el, component2);
          }
          component2[method](...args);
          return component2;
        });
      }
      function createComponent(componentShell) {
        const {
          css,
          template,
          exports: exports2,
          name: name2
        } = componentShell;
        const templateFn = template ? componentTemplateFactory(template, componentShell) : MOCKED_TEMPLATE_INTERFACE;
        return (_ref2) => {
          let {
            slots,
            attributes,
            props
          } = _ref2;
          if (exports2 && exports2[IS_PURE_SYMBOL])
            return createPureComponent(exports2, {
              slots,
              attributes,
              props,
              css,
              template
            });
          const componentAPI = callOrAssign(exports2) || {};
          const component2 = defineComponent({
            css,
            template: templateFn,
            componentAPI,
            name: name2
          })({
            slots,
            attributes,
            props
          });
          return {
            mount(element, parentScope, state) {
              return component2.mount(element, state, parentScope);
            },
            update(parentScope, state) {
              return component2.update(state, parentScope);
            },
            unmount(preserveRoot) {
              return component2.unmount(preserveRoot);
            }
          };
        };
      }
      function defineComponent(_ref3) {
        let {
          css,
          template,
          componentAPI,
          name: name2
        } = _ref3;
        if (css && name2)
          cssManager.add(name2, css);
        return curry(enhanceComponentAPI)(defineProperties(defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {
          [PROPS_KEY]: {},
          [STATE_KEY]: {}
        })), Object.assign({
          [SLOTS_KEY]: null,
          [ROOT_KEY]: null
        }, COMPONENT_CORE_HELPERS, {
          name: name2,
          css,
          template
        })));
      }
      function createAttributeBindings(node, attributes) {
        if (attributes === void 0) {
          attributes = [];
        }
        const expressions2 = attributes.map((a) => create$4(node, a));
        const binding = {};
        return Object.assign(binding, Object.assign({
          expressions: expressions2
        }, createCoreAPIMethods((method) => (scope) => {
          expressions2.forEach((e) => e[method](scope));
          return binding;
        })));
      }
      function createSubcomponents(components) {
        if (components === void 0) {
          components = {};
        }
        return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {
          let [key, value] = _ref4;
          acc[camelToDashCase(key)] = createComponent(value);
          return acc;
        }, {});
      }
      function runPlugins(component2) {
        return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component2);
      }
      function computeState(oldState, newState) {
        return Object.assign({}, oldState, callOrAssign(newState));
      }
      function addCssHook(element, name2) {
        if (getName(element) !== name2) {
          set(element, IS_DIRECTIVE, name2);
        }
      }
      function enhanceComponentAPI(component2, _ref5) {
        let {
          slots,
          attributes,
          props
        } = _ref5;
        return autobindMethods(runPlugins(defineProperties(isObject(component2) ? Object.create(component2) : component2, {
          mount(element, state, parentScope) {
            if (state === void 0) {
              state = {};
            }
            this[PARENT_KEY_SYMBOL] = parentScope;
            this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);
            defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));
            this[STATE_KEY] = computeState(this[STATE_KEY], state);
            this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();
            bindDOMNodeToComponentObject(element, this);
            component2.name && addCssHook(element, component2.name);
            defineProperty(this, ROOT_KEY, element);
            defineProperty(this, SLOTS_KEY, slots);
            this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
            this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);
            this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
            return this;
          },
          update(state, parentScope) {
            if (state === void 0) {
              state = {};
            }
            if (parentScope) {
              this[PARENT_KEY_SYMBOL] = parentScope;
              this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);
            }
            const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);
            if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false)
              return;
            defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));
            this[STATE_KEY] = computeState(this[STATE_KEY], state);
            this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);
            if (!this[IS_COMPONENT_UPDATING]) {
              this[IS_COMPONENT_UPDATING] = true;
              this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);
            }
            this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);
            this[IS_COMPONENT_UPDATING] = false;
            return this;
          },
          unmount(preserveRoot) {
            this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
            this[ATTRIBUTES_KEY_SYMBOL].unmount();
            this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);
            this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
            return this;
          }
        })), Object.keys(component2).filter((prop) => isFunction(component2[prop])));
      }
      function mountComponent(element, initialProps, componentName) {
        const name2 = componentName || getName(element);
        if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name2))
          panic(`The component named "${name2}" was never registered`);
        const component2 = COMPONENTS_IMPLEMENTATION_MAP$1.get(name2)({
          props: initialProps
        });
        return component2.mount(element);
      }
      function compose() {
        for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          fns[_key2] = arguments[_key2];
        }
        return fns.reduce((f, g) => function() {
          return f(g(...arguments));
        });
      }
      const {
        DOM_COMPONENT_INSTANCE_PROPERTY,
        COMPONENTS_IMPLEMENTATION_MAP,
        PLUGINS_SET
      } = globals;
      function register(name2, _ref) {
        let {
          css,
          template,
          exports: exports2
        } = _ref;
        if (COMPONENTS_IMPLEMENTATION_MAP.has(name2))
          panic(`The component "${name2}" was already registered`);
        COMPONENTS_IMPLEMENTATION_MAP.set(name2, createComponent({
          name: name2,
          css,
          template,
          exports: exports2
        }));
        return COMPONENTS_IMPLEMENTATION_MAP;
      }
      function unregister(name2) {
        if (!COMPONENTS_IMPLEMENTATION_MAP.has(name2))
          panic(`The component "${name2}" was never registered`);
        COMPONENTS_IMPLEMENTATION_MAP.delete(name2);
        cssManager.remove(name2);
        return COMPONENTS_IMPLEMENTATION_MAP;
      }
      function mount(selector, initialProps, name2) {
        return $(selector).map((element) => mountComponent(element, initialProps, name2));
      }
      function unmount(selector, keepRootElement) {
        return $(selector).map((element) => {
          if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {
            element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);
          }
          return element;
        });
      }
      function install(plugin) {
        if (!isFunction(plugin))
          panic("Plugins must be of type function");
        if (PLUGINS_SET.has(plugin))
          panic("This plugin was already installed");
        PLUGINS_SET.add(plugin);
        return PLUGINS_SET;
      }
      function uninstall(plugin) {
        if (!PLUGINS_SET.has(plugin))
          panic("This plugin was never installed");
        PLUGINS_SET.delete(plugin);
        return PLUGINS_SET;
      }
      function component(implementation) {
        return function(el, props, _temp) {
          let {
            slots,
            attributes,
            parentScope
          } = _temp === void 0 ? {} : _temp;
          return compose((c) => c.mount(el, parentScope), (c) => c({
            props,
            slots,
            attributes
          }), createComponent)(implementation);
        };
      }
      function pure(func) {
        if (!isFunction(func))
          panic('riot.pure accepts only arguments of type "function"');
        func[IS_PURE_SYMBOL] = true;
        return func;
      }
      const version = "v5.4.2";
      const __ = {
        cssManager,
        DOMBindings,
        createComponent,
        defineComponent,
        globals
      };
      var riot2 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        register,
        unregister,
        mount,
        unmount,
        install,
        uninstall,
        component,
        pure,
        version,
        __
      });
      var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs2(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var compiler$1 = {exports: {}};
      var require$$02 = void 0;
      var require$$12 = void 0;
      var require$$2 = void 0;
      (function(module2, exports2) {
        (function(global2, factory) {
          factory(exports2, require$$02, require$$12, require$$2);
        })(commonjsGlobal$1, function(exports3, require$$0$2, require$$1$1, require$$22) {
          var global2 = window;
          function _interopDefaultLegacy(e) {
            return e && typeof e === "object" && "default" in e ? e : {"default": e};
          }
          var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0$2);
          var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1$1);
          var require$$2__default = /* @__PURE__ */ _interopDefaultLegacy(require$$22);
          const TAG_LOGIC_PROPERTY = "exports";
          const TAG_CSS_PROPERTY = "css";
          const TAG_TEMPLATE_PROPERTY = "template";
          const TAG_NAME_PROPERTY = "name";
          function getAugmentedNamespace2(n2) {
            if (n2.__esModule)
              return n2;
            var a = Object.defineProperty({}, "__esModule", {value: true});
            Object.keys(n2).forEach(function(k) {
              var d = Object.getOwnPropertyDescriptor(n2, k);
              Object.defineProperty(a, k, d.get ? d : {enumerable: true, get: function get2() {
                return n2[k];
              }});
            });
            return a;
          }
          function createCommonjsModule(fn) {
            var module3 = {exports: {}};
            return fn(module3, module3.exports), module3.exports;
          }
          /*! *****************************************************************************
            	Copyright (c) Microsoft Corporation.
          
            	Permission to use, copy, modify, and/or distribute this software for any
            	purpose with or without fee is hereby granted.
          
            	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            	PERFORMANCE OF THIS SOFTWARE.
            	***************************************************************************** */
          var _extendStatics = function extendStatics(d, b) {
            _extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return _extendStatics(d, b);
          };
          function __extends(d, b) {
            _extendStatics(d, b);
            function __2() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
          }
          var _assign = function __assign() {
            _assign = Object.assign || function __assign2(t) {
              for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
                s = arguments[i];
                for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
              }
              return t;
            };
            return _assign.apply(this, arguments);
          };
          function __rest(s, e) {
            var t = {};
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
            if (s != null && typeof Object.getOwnPropertySymbols === "function")
              for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
              }
            return t;
          }
          function __decorate(decorators, target, key, desc) {
            var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
            if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                  r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
            return c2 > 3 && r && Object.defineProperty(target, key, r), r;
          }
          function __param(paramIndex, decorator) {
            return function(target, key) {
              decorator(target, key, paramIndex);
            };
          }
          function __metadata(metadataKey, metadataValue) {
            if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
              return Reflect.metadata(metadataKey, metadataValue);
          }
          function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          }
          function __generator(thisArg, body) {
            var _ = {label: 0, sent: function sent() {
              if (t[0] & 1)
                throw t[1];
              return t[1];
            }, trys: [], ops: []}, f, y, t, g;
            return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
              return this;
            }), g;
            function verb(n2) {
              return function(v) {
                return step([n2, v]);
              };
            }
            function step(op) {
              if (f)
                throw new TypeError("Generator is already executing.");
              while (_)
                try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                    return t;
                  if (y = 0, t)
                    op = [op[0] & 2, t.value];
                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op;
                      break;
                    case 4:
                      _.label++;
                      return {value: op[1], done: false};
                    case 5:
                      _.label++;
                      y = op[1];
                      op = [0];
                      continue;
                    case 7:
                      op = _.ops.pop();
                      _.trys.pop();
                      continue;
                    default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                      }
                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                      }
                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                      }
                      if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                      }
                      if (t[2])
                        _.ops.pop();
                      _.trys.pop();
                      continue;
                  }
                  op = body.call(thisArg, _);
                } catch (e) {
                  op = [6, e];
                  y = 0;
                } finally {
                  f = t = 0;
                }
              if (op[0] & 5)
                throw op[1];
              return {value: op[0] ? op[1] : void 0, done: true};
            }
          }
          var __createBinding = Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            Object.defineProperty(o, k2, {enumerable: true, get: function get2() {
              return m[k];
            }});
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          };
          function __exportStar(m, o) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
          }
          function __values(o) {
            var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
            if (m)
              return m.call(o);
            if (o && typeof o.length === "number")
              return {next: function next() {
                if (o && i >= o.length)
                  o = void 0;
                return {value: o && o[i++], done: !o};
              }};
            throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function __read(o, n2) {
            var m = typeof Symbol === "function" && o[Symbol.iterator];
            if (!m)
              return o;
            var i = m.call(o), r, ar = [], e;
            try {
              while ((n2 === void 0 || n2-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
            } catch (error) {
              e = {error};
            } finally {
              try {
                if (r && !r.done && (m = i["return"]))
                  m.call(i);
              } finally {
                if (e)
                  throw e.error;
              }
            }
            return ar;
          }
          function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++)
              ar = ar.concat(__read(arguments[i]));
            return ar;
          }
          function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++)
              s += arguments[i].length;
            for (var r = Array(s), k = 0, i = 0; i < il; i++)
              for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
            return r;
          }
          function __await(v) {
            return this instanceof __await ? (this.v = v, this) : new __await(v);
          }
          function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var g = generator.apply(thisArg, _arguments || []), i, q = [];
            return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
              return this;
            }, i;
            function verb(n2) {
              if (g[n2])
                i[n2] = function(v) {
                  return new Promise(function(a, b) {
                    q.push([n2, v, a, b]) > 1 || resume(n2, v);
                  });
                };
            }
            function resume(n2, v) {
              try {
                step(g[n2](v));
              } catch (e) {
                settle(q[0][3], e);
              }
            }
            function step(r) {
              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            }
            function fulfill(value) {
              resume("next", value);
            }
            function reject(value) {
              resume("throw", value);
            }
            function settle(f, v) {
              if (f(v), q.shift(), q.length)
                resume(q[0][0], q[0][1]);
            }
          }
          function __asyncDelegator(o) {
            var i, p;
            return i = {}, verb("next"), verb("throw", function(e) {
              throw e;
            }), verb("return"), i[Symbol.iterator] = function() {
              return this;
            }, i;
            function verb(n2, f) {
              i[n2] = o[n2] ? function(v) {
                return (p = !p) ? {value: __await(o[n2](v)), done: n2 === "return"} : f ? f(v) : v;
              } : f;
            }
          }
          function __asyncValues(o) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var m = o[Symbol.asyncIterator], i;
            return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
              return this;
            }, i);
            function verb(n2) {
              i[n2] = o[n2] && function(v) {
                return new Promise(function(resolve, reject) {
                  v = o[n2](v), settle(resolve, reject, v.done, v.value);
                });
              };
            }
            function settle(resolve, reject, d, v) {
              Promise.resolve(v).then(function(v2) {
                resolve({value: v2, done: d});
              }, reject);
            }
          }
          function __makeTemplateObject(cooked, raw) {
            if (Object.defineProperty) {
              Object.defineProperty(cooked, "raw", {value: raw});
            } else {
              cooked.raw = raw;
            }
            return cooked;
          }
          var __setModuleDefault = Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {enumerable: true, value: v});
          } : function(o, v) {
            o["default"] = v;
          };
          function __importStar(mod) {
            if (mod && mod.__esModule)
              return mod;
            var result = {};
            if (mod != null) {
              for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                  __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
          }
          function __importDefault(mod) {
            return mod && mod.__esModule ? mod : {default: mod};
          }
          function __classPrivateFieldGet(receiver, privateMap) {
            if (!privateMap.has(receiver)) {
              throw new TypeError("attempted to get private field on non-instance");
            }
            return privateMap.get(receiver);
          }
          function __classPrivateFieldSet(receiver, privateMap, value) {
            if (!privateMap.has(receiver)) {
              throw new TypeError("attempted to set private field on non-instance");
            }
            privateMap.set(receiver, value);
            return value;
          }
          var tslib_es6 = /* @__PURE__ */ Object.freeze({__proto__: null, __extends, get __assign() {
            return _assign;
          }, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet});
          var tslib_1 = /* @__PURE__ */ getAugmentedNamespace2(tslib_es6);
          var types$4 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.Def = void 0;
            var Op = Object.prototype;
            var objToStr = Op.toString;
            var hasOwn2 = Op.hasOwnProperty;
            var BaseType = function() {
              function BaseType2() {
              }
              BaseType2.prototype.assert = function(value, deep) {
                if (!this.check(value, deep)) {
                  var str = shallowStringify(value);
                  throw new Error(str + " does not match type " + this);
                }
                return true;
              };
              BaseType2.prototype.arrayOf = function() {
                var elemType = this;
                return new ArrayType(elemType);
              };
              return BaseType2;
            }();
            var ArrayType = function(_super) {
              tslib_1.__extends(ArrayType2, _super);
              function ArrayType2(elemType) {
                var _this = _super.call(this) || this;
                _this.elemType = elemType;
                _this.kind = "ArrayType";
                return _this;
              }
              ArrayType2.prototype.toString = function() {
                return "[" + this.elemType + "]";
              };
              ArrayType2.prototype.check = function(value, deep) {
                var _this = this;
                return Array.isArray(value) && value.every(function(elem) {
                  return _this.elemType.check(elem, deep);
                });
              };
              return ArrayType2;
            }(BaseType);
            var IdentityType = function(_super) {
              tslib_1.__extends(IdentityType2, _super);
              function IdentityType2(value) {
                var _this = _super.call(this) || this;
                _this.value = value;
                _this.kind = "IdentityType";
                return _this;
              }
              IdentityType2.prototype.toString = function() {
                return String(this.value);
              };
              IdentityType2.prototype.check = function(value, deep) {
                var result = value === this.value;
                if (!result && typeof deep === "function") {
                  deep(this, value);
                }
                return result;
              };
              return IdentityType2;
            }(BaseType);
            var ObjectType = function(_super) {
              tslib_1.__extends(ObjectType2, _super);
              function ObjectType2(fields) {
                var _this = _super.call(this) || this;
                _this.fields = fields;
                _this.kind = "ObjectType";
                return _this;
              }
              ObjectType2.prototype.toString = function() {
                return "{ " + this.fields.join(", ") + " }";
              };
              ObjectType2.prototype.check = function(value, deep) {
                return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
                  return field.type.check(value[field.name], deep);
                });
              };
              return ObjectType2;
            }(BaseType);
            var OrType = function(_super) {
              tslib_1.__extends(OrType2, _super);
              function OrType2(types2) {
                var _this = _super.call(this) || this;
                _this.types = types2;
                _this.kind = "OrType";
                return _this;
              }
              OrType2.prototype.toString = function() {
                return this.types.join(" | ");
              };
              OrType2.prototype.check = function(value, deep) {
                return this.types.some(function(type2) {
                  return type2.check(value, deep);
                });
              };
              return OrType2;
            }(BaseType);
            var PredicateType = function(_super) {
              tslib_1.__extends(PredicateType2, _super);
              function PredicateType2(name2, predicate) {
                var _this = _super.call(this) || this;
                _this.name = name2;
                _this.predicate = predicate;
                _this.kind = "PredicateType";
                return _this;
              }
              PredicateType2.prototype.toString = function() {
                return this.name;
              };
              PredicateType2.prototype.check = function(value, deep) {
                var result = this.predicate(value, deep);
                if (!result && typeof deep === "function") {
                  deep(this, value);
                }
                return result;
              };
              return PredicateType2;
            }(BaseType);
            var Def = function() {
              function Def2(type2, typeName) {
                this.type = type2;
                this.typeName = typeName;
                this.baseNames = [];
                this.ownFields = Object.create(null);
                this.allSupertypes = Object.create(null);
                this.supertypeList = [];
                this.allFields = Object.create(null);
                this.fieldNames = [];
                this.finalized = false;
                this.buildable = false;
                this.buildParams = [];
              }
              Def2.prototype.isSupertypeOf = function(that) {
                if (that instanceof Def2) {
                  if (this.finalized !== true || that.finalized !== true) {
                    throw new Error("");
                  }
                  return hasOwn2.call(that.allSupertypes, this.typeName);
                } else {
                  throw new Error(that + " is not a Def");
                }
              };
              Def2.prototype.checkAllFields = function(value, deep) {
                var allFields = this.allFields;
                if (this.finalized !== true) {
                  throw new Error("" + this.typeName);
                }
                function checkFieldByName(name2) {
                  var field = allFields[name2];
                  var type2 = field.type;
                  var child = field.getValue(value);
                  return type2.check(child, deep);
                }
                return value !== null && typeof value === "object" && Object.keys(allFields).every(checkFieldByName);
              };
              Def2.prototype.bases = function() {
                var supertypeNames = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  supertypeNames[_i] = arguments[_i];
                }
                var bases = this.baseNames;
                if (this.finalized) {
                  if (supertypeNames.length !== bases.length) {
                    throw new Error("");
                  }
                  for (var i = 0; i < supertypeNames.length; i++) {
                    if (supertypeNames[i] !== bases[i]) {
                      throw new Error("");
                    }
                  }
                  return this;
                }
                supertypeNames.forEach(function(baseName) {
                  if (bases.indexOf(baseName) < 0) {
                    bases.push(baseName);
                  }
                });
                return this;
              };
              return Def2;
            }();
            exports4.Def = Def;
            var Field = function() {
              function Field2(name2, type2, defaultFn, hidden) {
                this.name = name2;
                this.type = type2;
                this.defaultFn = defaultFn;
                this.hidden = !!hidden;
              }
              Field2.prototype.toString = function() {
                return JSON.stringify(this.name) + ": " + this.type;
              };
              Field2.prototype.getValue = function(obj) {
                var value = obj[this.name];
                if (typeof value !== "undefined") {
                  return value;
                }
                if (typeof this.defaultFn === "function") {
                  value = this.defaultFn.call(obj);
                }
                return value;
              };
              return Field2;
            }();
            function shallowStringify(value) {
              if (Array.isArray(value)) {
                return "[" + value.map(shallowStringify).join(", ") + "]";
              }
              if (value && typeof value === "object") {
                return "{ " + Object.keys(value).map(function(key) {
                  return key + ": " + value[key];
                }).join(", ") + " }";
              }
              return JSON.stringify(value);
            }
            function typesPlugin(_fork) {
              var Type = {
                or: function or2() {
                  var types2 = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    types2[_i] = arguments[_i];
                  }
                  return new OrType(types2.map(function(type2) {
                    return Type.from(type2);
                  }));
                },
                from: function from2(value, name2) {
                  if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {
                    return value;
                  }
                  if (value instanceof Def) {
                    return value.type;
                  }
                  if (isArray2.check(value)) {
                    if (value.length !== 1) {
                      throw new Error("only one element type is permitted for typed arrays");
                    }
                    return new ArrayType(Type.from(value[0]));
                  }
                  if (isObject3.check(value)) {
                    return new ObjectType(Object.keys(value).map(function(name22) {
                      return new Field(name22, Type.from(value[name22], name22));
                    }));
                  }
                  if (typeof value === "function") {
                    var bicfIndex = builtInCtorFns.indexOf(value);
                    if (bicfIndex >= 0) {
                      return builtInCtorTypes[bicfIndex];
                    }
                    if (typeof name2 !== "string") {
                      throw new Error("missing name");
                    }
                    return new PredicateType(name2, value);
                  }
                  return new IdentityType(value);
                },
                def: function def(typeName) {
                  return hasOwn2.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
                },
                hasDef: function hasDef(typeName) {
                  return hasOwn2.call(defCache, typeName);
                }
              };
              var builtInCtorFns = [];
              var builtInCtorTypes = [];
              function defBuiltInType(name2, example) {
                var objStr = objToStr.call(example);
                var type2 = new PredicateType(name2, function(value) {
                  return objToStr.call(value) === objStr;
                });
                if (example && typeof example.constructor === "function") {
                  builtInCtorFns.push(example.constructor);
                  builtInCtorTypes.push(type2);
                }
                return type2;
              }
              var isString2 = defBuiltInType("string", "truthy");
              var isFunction3 = defBuiltInType("function", function() {
              });
              var isArray2 = defBuiltInType("array", []);
              var isObject3 = defBuiltInType("object", {});
              var isRegExp2 = defBuiltInType("RegExp", /./);
              var isDate2 = defBuiltInType("Date", new Date());
              var isNumber2 = defBuiltInType("number", 3);
              var isBoolean3 = defBuiltInType("boolean", true);
              var isNull2 = defBuiltInType("null", null);
              var isUndefined2 = defBuiltInType("undefined", void 0);
              var builtInTypes = {string: isString2, function: isFunction3, array: isArray2, object: isObject3, RegExp: isRegExp2, Date: isDate2, number: isNumber2, boolean: isBoolean3, null: isNull2, undefined: isUndefined2};
              var defCache = Object.create(null);
              function defFromValue(value) {
                if (value && typeof value === "object") {
                  var type2 = value.type;
                  if (typeof type2 === "string" && hasOwn2.call(defCache, type2)) {
                    var d = defCache[type2];
                    if (d.finalized) {
                      return d;
                    }
                  }
                }
                return null;
              }
              var DefImpl = function(_super) {
                tslib_1.__extends(DefImpl2, _super);
                function DefImpl2(typeName) {
                  var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
                    return _this.check(value, deep);
                  }), typeName) || this;
                  return _this;
                }
                DefImpl2.prototype.check = function(value, deep) {
                  if (this.finalized !== true) {
                    throw new Error("prematurely checking unfinalized type " + this.typeName);
                  }
                  if (value === null || typeof value !== "object") {
                    return false;
                  }
                  var vDef = defFromValue(value);
                  if (!vDef) {
                    if (this.typeName === "SourceLocation" || this.typeName === "Position") {
                      return this.checkAllFields(value, deep);
                    }
                    return false;
                  }
                  if (deep && vDef === this) {
                    return this.checkAllFields(value, deep);
                  }
                  if (!this.isSupertypeOf(vDef)) {
                    return false;
                  }
                  if (!deep) {
                    return true;
                  }
                  return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
                };
                DefImpl2.prototype.build = function() {
                  var _this = this;
                  var buildParams = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    buildParams[_i] = arguments[_i];
                  }
                  this.buildParams = buildParams;
                  if (this.buildable) {
                    return this;
                  }
                  this.field("type", String, function() {
                    return _this.typeName;
                  });
                  this.buildable = true;
                  var addParam = function addParam2(built, param, arg, isArgAvailable) {
                    if (hasOwn2.call(built, param))
                      return;
                    var all = _this.allFields;
                    if (!hasOwn2.call(all, param)) {
                      throw new Error("" + param);
                    }
                    var field = all[param];
                    var type2 = field.type;
                    var value;
                    if (isArgAvailable) {
                      value = arg;
                    } else if (field.defaultFn) {
                      value = field.defaultFn.call(built);
                    } else {
                      var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name2) {
                        return all[name2];
                      }).join(", ") + ")";
                      throw new Error(message);
                    }
                    if (!type2.check(value)) {
                      throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
                    }
                    built[param] = value;
                  };
                  var builder = function builder2() {
                    var args = [];
                    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                      args[_i2] = arguments[_i2];
                    }
                    var argc = args.length;
                    if (!_this.finalized) {
                      throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
                    }
                    var built = Object.create(nodePrototype);
                    _this.buildParams.forEach(function(param, i) {
                      if (i < argc) {
                        addParam(built, param, args[i], true);
                      } else {
                        addParam(built, param, null, false);
                      }
                    });
                    Object.keys(_this.allFields).forEach(function(param) {
                      addParam(built, param, null, false);
                    });
                    if (built.type !== _this.typeName) {
                      throw new Error("");
                    }
                    return built;
                  };
                  builder.from = function(obj) {
                    if (!_this.finalized) {
                      throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
                    }
                    var built = Object.create(nodePrototype);
                    Object.keys(_this.allFields).forEach(function(param) {
                      if (hasOwn2.call(obj, param)) {
                        addParam(built, param, obj[param], true);
                      } else {
                        addParam(built, param, null, false);
                      }
                    });
                    if (built.type !== _this.typeName) {
                      throw new Error("");
                    }
                    return built;
                  };
                  Object.defineProperty(builders2, getBuilderName(this.typeName), {enumerable: true, value: builder});
                  return this;
                };
                DefImpl2.prototype.field = function(name2, type2, defaultFn, hidden) {
                  if (this.finalized) {
                    console.error("Ignoring attempt to redefine field " + JSON.stringify(name2) + " of finalized type " + JSON.stringify(this.typeName));
                    return this;
                  }
                  this.ownFields[name2] = new Field(name2, Type.from(type2), defaultFn, hidden);
                  return this;
                };
                DefImpl2.prototype.finalize = function() {
                  var _this = this;
                  if (!this.finalized) {
                    var allFields = this.allFields;
                    var allSupertypes = this.allSupertypes;
                    this.baseNames.forEach(function(name2) {
                      var def = defCache[name2];
                      if (def instanceof Def) {
                        def.finalize();
                        extend(allFields, def.allFields);
                        extend(allSupertypes, def.allSupertypes);
                      } else {
                        var message = "unknown supertype name " + JSON.stringify(name2) + " for subtype " + JSON.stringify(_this.typeName);
                        throw new Error(message);
                      }
                    });
                    extend(allFields, this.ownFields);
                    allSupertypes[this.typeName] = this;
                    this.fieldNames.length = 0;
                    for (var fieldName in allFields) {
                      if (hasOwn2.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                        this.fieldNames.push(fieldName);
                      }
                    }
                    Object.defineProperty(namedTypes2, this.typeName, {enumerable: true, value: this.type});
                    this.finalized = true;
                    populateSupertypeList(this.typeName, this.supertypeList);
                    if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) {
                      wrapExpressionBuilderWithStatement(this.typeName);
                    }
                  }
                };
                return DefImpl2;
              }(Def);
              function getSupertypeNames(typeName) {
                if (!hasOwn2.call(defCache, typeName)) {
                  throw new Error("");
                }
                var d = defCache[typeName];
                if (d.finalized !== true) {
                  throw new Error("");
                }
                return d.supertypeList.slice(1);
              }
              function computeSupertypeLookupTable(candidates) {
                var table = {};
                var typeNames = Object.keys(defCache);
                var typeNameCount = typeNames.length;
                for (var i = 0; i < typeNameCount; ++i) {
                  var typeName = typeNames[i];
                  var d = defCache[typeName];
                  if (d.finalized !== true) {
                    throw new Error("" + typeName);
                  }
                  for (var j = 0; j < d.supertypeList.length; ++j) {
                    var superTypeName = d.supertypeList[j];
                    if (hasOwn2.call(candidates, superTypeName)) {
                      table[typeName] = superTypeName;
                      break;
                    }
                  }
                }
                return table;
              }
              var builders2 = Object.create(null);
              var nodePrototype = {};
              function defineMethod(name2, func) {
                var old = nodePrototype[name2];
                if (isUndefined2.check(func)) {
                  delete nodePrototype[name2];
                } else {
                  isFunction3.assert(func);
                  Object.defineProperty(nodePrototype, name2, {enumerable: true, configurable: true, value: func});
                }
                return old;
              }
              function getBuilderName(typeName) {
                return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
                  var len = upperCasePrefix.length;
                  switch (len) {
                    case 0:
                      return "";
                    case 1:
                      return upperCasePrefix.toLowerCase();
                    default:
                      return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
                  }
                });
              }
              function getStatementBuilderName(typeName) {
                typeName = getBuilderName(typeName);
                return typeName.replace(/(Expression)?$/, "Statement");
              }
              var namedTypes2 = {};
              function getFieldNames(object2) {
                var d = defFromValue(object2);
                if (d) {
                  return d.fieldNames.slice(0);
                }
                if ("type" in object2) {
                  throw new Error("did not recognize object of type " + JSON.stringify(object2.type));
                }
                return Object.keys(object2);
              }
              function getFieldValue(object2, fieldName) {
                var d = defFromValue(object2);
                if (d) {
                  var field = d.allFields[fieldName];
                  if (field) {
                    return field.getValue(object2);
                  }
                }
                return object2 && object2[fieldName];
              }
              function eachField(object2, callback, context) {
                getFieldNames(object2).forEach(function(name2) {
                  callback.call(this, name2, getFieldValue(object2, name2));
                }, context);
              }
              function someField(object2, callback, context) {
                return getFieldNames(object2).some(function(name2) {
                  return callback.call(this, name2, getFieldValue(object2, name2));
                }, context);
              }
              function wrapExpressionBuilderWithStatement(typeName) {
                var wrapperName = getStatementBuilderName(typeName);
                if (builders2[wrapperName])
                  return;
                var wrapped = builders2[getBuilderName(typeName)];
                if (!wrapped)
                  return;
                var builder = function builder2() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  return builders2.expressionStatement(wrapped.apply(builders2, args));
                };
                builder.from = function() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  return builders2.expressionStatement(wrapped.from.apply(builders2, args));
                };
                builders2[wrapperName] = builder;
              }
              function populateSupertypeList(typeName, list) {
                list.length = 0;
                list.push(typeName);
                var lastSeen = Object.create(null);
                for (var pos = 0; pos < list.length; ++pos) {
                  typeName = list[pos];
                  var d = defCache[typeName];
                  if (d.finalized !== true) {
                    throw new Error("");
                  }
                  if (hasOwn2.call(lastSeen, typeName)) {
                    delete list[lastSeen[typeName]];
                  }
                  lastSeen[typeName] = pos;
                  list.push.apply(list, d.baseNames);
                }
                for (var to = 0, from2 = to, len = list.length; from2 < len; ++from2) {
                  if (hasOwn2.call(list, from2)) {
                    list[to++] = list[from2];
                  }
                }
                list.length = to;
              }
              function extend(into, from2) {
                Object.keys(from2).forEach(function(name2) {
                  into[name2] = from2[name2];
                });
                return into;
              }
              function finalize() {
                Object.keys(defCache).forEach(function(name2) {
                  defCache[name2].finalize();
                });
              }
              return {Type, builtInTypes, getSupertypeNames, computeSupertypeLookupTable, builders: builders2, defineMethod, getBuilderName, getStatementBuilderName, namedTypes: namedTypes2, getFieldNames, getFieldValue, eachField, someField, finalize};
            }
            exports4.default = typesPlugin;
          });
          var path = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var Op = Object.prototype;
            var hasOwn2 = Op.hasOwnProperty;
            function pathPlugin(fork2) {
              var types2 = fork2.use(types_1.default);
              var isArray2 = types2.builtInTypes.array;
              var isNumber2 = types2.builtInTypes.number;
              var Path = function Path2(value, parentPath, name2) {
                if (!(this instanceof Path2)) {
                  throw new Error("Path constructor cannot be invoked without 'new'");
                }
                if (parentPath) {
                  if (!(parentPath instanceof Path2)) {
                    throw new Error("");
                  }
                } else {
                  parentPath = null;
                  name2 = null;
                }
                this.value = value;
                this.parentPath = parentPath;
                this.name = name2;
                this.__childCache = null;
              };
              var Pp = Path.prototype;
              function getChildCache(path2) {
                return path2.__childCache || (path2.__childCache = Object.create(null));
              }
              function getChildPath(path2, name2) {
                var cache = getChildCache(path2);
                var actualChildValue = path2.getValueProperty(name2);
                var childPath = cache[name2];
                if (!hasOwn2.call(cache, name2) || childPath.value !== actualChildValue) {
                  childPath = cache[name2] = new path2.constructor(actualChildValue, path2, name2);
                }
                return childPath;
              }
              Pp.getValueProperty = function getValueProperty(name2) {
                return this.value[name2];
              };
              Pp.get = function get2() {
                var names = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  names[_i] = arguments[_i];
                }
                var path2 = this;
                var count = names.length;
                for (var i = 0; i < count; ++i) {
                  path2 = getChildPath(path2, names[i]);
                }
                return path2;
              };
              Pp.each = function each(callback, context) {
                var childPaths = [];
                var len = this.value.length;
                var i = 0;
                for (var i = 0; i < len; ++i) {
                  if (hasOwn2.call(this.value, i)) {
                    childPaths[i] = this.get(i);
                  }
                }
                context = context || this;
                for (i = 0; i < len; ++i) {
                  if (hasOwn2.call(childPaths, i)) {
                    callback.call(context, childPaths[i]);
                  }
                }
              };
              Pp.map = function map(callback, context) {
                var result = [];
                this.each(function(childPath) {
                  result.push(callback.call(this, childPath));
                }, context);
                return result;
              };
              Pp.filter = function filter(callback, context) {
                var result = [];
                this.each(function(childPath) {
                  if (callback.call(this, childPath)) {
                    result.push(childPath);
                  }
                }, context);
                return result;
              };
              function emptyMoves() {
              }
              function getMoves(path2, offset, start, end) {
                isArray2.assert(path2.value);
                if (offset === 0) {
                  return emptyMoves;
                }
                var length = path2.value.length;
                if (length < 1) {
                  return emptyMoves;
                }
                var argc = arguments.length;
                if (argc === 2) {
                  start = 0;
                  end = length;
                } else if (argc === 3) {
                  start = Math.max(start, 0);
                  end = length;
                } else {
                  start = Math.max(start, 0);
                  end = Math.min(end, length);
                }
                isNumber2.assert(start);
                isNumber2.assert(end);
                var moves = Object.create(null);
                var cache = getChildCache(path2);
                for (var i = start; i < end; ++i) {
                  if (hasOwn2.call(path2.value, i)) {
                    var childPath = path2.get(i);
                    if (childPath.name !== i) {
                      throw new Error("");
                    }
                    var newIndex = i + offset;
                    childPath.name = newIndex;
                    moves[newIndex] = childPath;
                    delete cache[i];
                  }
                }
                delete cache.length;
                return function() {
                  for (var newIndex2 in moves) {
                    var childPath2 = moves[newIndex2];
                    if (childPath2.name !== +newIndex2) {
                      throw new Error("");
                    }
                    cache[newIndex2] = childPath2;
                    path2.value[newIndex2] = childPath2.value;
                  }
                };
              }
              Pp.shift = function shift() {
                var move = getMoves(this, -1);
                var result = this.value.shift();
                move();
                return result;
              };
              Pp.unshift = function unshift() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                var move = getMoves(this, args.length);
                var result = this.value.unshift.apply(this.value, args);
                move();
                return result;
              };
              Pp.push = function push() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                isArray2.assert(this.value);
                delete getChildCache(this).length;
                return this.value.push.apply(this.value, args);
              };
              Pp.pop = function pop() {
                isArray2.assert(this.value);
                var cache = getChildCache(this);
                delete cache[this.value.length - 1];
                delete cache.length;
                return this.value.pop();
              };
              Pp.insertAt = function insertAt(index) {
                var argc = arguments.length;
                var move = getMoves(this, argc - 1, index);
                if (move === emptyMoves && argc <= 1) {
                  return this;
                }
                index = Math.max(index, 0);
                for (var i = 1; i < argc; ++i) {
                  this.value[index + i - 1] = arguments[i];
                }
                move();
                return this;
              };
              Pp.insertBefore = function insertBefore2() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                var pp = this.parentPath;
                var argc = args.length;
                var insertAtArgs = [this.name];
                for (var i = 0; i < argc; ++i) {
                  insertAtArgs.push(args[i]);
                }
                return pp.insertAt.apply(pp, insertAtArgs);
              };
              Pp.insertAfter = function insertAfter() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                var pp = this.parentPath;
                var argc = args.length;
                var insertAtArgs = [this.name + 1];
                for (var i = 0; i < argc; ++i) {
                  insertAtArgs.push(args[i]);
                }
                return pp.insertAt.apply(pp, insertAtArgs);
              };
              function repairRelationshipWithParent(path2) {
                if (!(path2 instanceof Path)) {
                  throw new Error("");
                }
                var pp = path2.parentPath;
                if (!pp) {
                  return path2;
                }
                var parentValue = pp.value;
                var parentCache = getChildCache(pp);
                if (parentValue[path2.name] === path2.value) {
                  parentCache[path2.name] = path2;
                } else if (isArray2.check(parentValue)) {
                  var i = parentValue.indexOf(path2.value);
                  if (i >= 0) {
                    parentCache[path2.name = i] = path2;
                  }
                } else {
                  parentValue[path2.name] = path2.value;
                  parentCache[path2.name] = path2;
                }
                if (parentValue[path2.name] !== path2.value) {
                  throw new Error("");
                }
                if (path2.parentPath.get(path2.name) !== path2) {
                  throw new Error("");
                }
                return path2;
              }
              Pp.replace = function replace(replacement) {
                var results = [];
                var parentValue = this.parentPath.value;
                var parentCache = getChildCache(this.parentPath);
                var count = arguments.length;
                repairRelationshipWithParent(this);
                if (isArray2.check(parentValue)) {
                  var originalLength = parentValue.length;
                  var move = getMoves(this.parentPath, count - 1, this.name + 1);
                  var spliceArgs = [this.name, 1];
                  for (var i = 0; i < count; ++i) {
                    spliceArgs.push(arguments[i]);
                  }
                  var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
                  if (splicedOut[0] !== this.value) {
                    throw new Error("");
                  }
                  if (parentValue.length !== originalLength - 1 + count) {
                    throw new Error("");
                  }
                  move();
                  if (count === 0) {
                    delete this.value;
                    delete parentCache[this.name];
                    this.__childCache = null;
                  } else {
                    if (parentValue[this.name] !== replacement) {
                      throw new Error("");
                    }
                    if (this.value !== replacement) {
                      this.value = replacement;
                      this.__childCache = null;
                    }
                    for (i = 0; i < count; ++i) {
                      results.push(this.parentPath.get(this.name + i));
                    }
                    if (results[0] !== this) {
                      throw new Error("");
                    }
                  }
                } else if (count === 1) {
                  if (this.value !== replacement) {
                    this.__childCache = null;
                  }
                  this.value = parentValue[this.name] = replacement;
                  results.push(this);
                } else if (count === 0) {
                  delete parentValue[this.name];
                  delete this.value;
                  this.__childCache = null;
                } else {
                  throw new Error("Could not replace path");
                }
                return results;
              };
              return Path;
            }
            exports4.default = pathPlugin;
            module3.exports = exports4["default"];
          });
          var scope$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var hasOwn2 = Object.prototype.hasOwnProperty;
            function scopePlugin(fork2) {
              var types2 = fork2.use(types_1.default);
              var Type = types2.Type;
              var namedTypes2 = types2.namedTypes;
              var Node3 = namedTypes2.Node;
              var Expression2 = namedTypes2.Expression;
              var isArray2 = types2.builtInTypes.array;
              var b = types2.builders;
              var Scope2 = function Scope3(path2, parentScope) {
                if (!(this instanceof Scope3)) {
                  throw new Error("Scope constructor cannot be invoked without 'new'");
                }
                ScopeType.assert(path2.value);
                var depth;
                if (parentScope) {
                  if (!(parentScope instanceof Scope3)) {
                    throw new Error("");
                  }
                  depth = parentScope.depth + 1;
                } else {
                  parentScope = null;
                  depth = 0;
                }
                Object.defineProperties(this, {path: {value: path2}, node: {value: path2.value}, isGlobal: {value: !parentScope, enumerable: true}, depth: {value: depth}, parent: {value: parentScope}, bindings: {value: {}}, types: {value: {}}});
              };
              var scopeTypes = [
                namedTypes2.Program,
                namedTypes2.Function,
                namedTypes2.CatchClause
              ];
              var ScopeType = Type.or.apply(Type, scopeTypes);
              Scope2.isEstablishedBy = function(node2) {
                return ScopeType.check(node2);
              };
              var Sp = Scope2.prototype;
              Sp.didScan = false;
              Sp.declares = function(name2) {
                this.scan();
                return hasOwn2.call(this.bindings, name2);
              };
              Sp.declaresType = function(name2) {
                this.scan();
                return hasOwn2.call(this.types, name2);
              };
              Sp.declareTemporary = function(prefix2) {
                if (prefix2) {
                  if (!/^[a-z$_]/i.test(prefix2)) {
                    throw new Error("");
                  }
                } else {
                  prefix2 = "t$";
                }
                prefix2 += this.depth.toString(36) + "$";
                this.scan();
                var index = 0;
                while (this.declares(prefix2 + index)) {
                  ++index;
                }
                var name2 = prefix2 + index;
                return this.bindings[name2] = types2.builders.identifier(name2);
              };
              Sp.injectTemporary = function(identifier, init2) {
                identifier || (identifier = this.declareTemporary());
                var bodyPath = this.path.get("body");
                if (namedTypes2.BlockStatement.check(bodyPath.value)) {
                  bodyPath = bodyPath.get("body");
                }
                bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init2 || null)]));
                return identifier;
              };
              Sp.scan = function(force) {
                if (force || !this.didScan) {
                  for (var name2 in this.bindings) {
                    delete this.bindings[name2];
                  }
                  scanScope(this.path, this.bindings, this.types);
                  this.didScan = true;
                }
              };
              Sp.getBindings = function() {
                this.scan();
                return this.bindings;
              };
              Sp.getTypes = function() {
                this.scan();
                return this.types;
              };
              function scanScope(path2, bindings2, scopeTypes2) {
                var node2 = path2.value;
                ScopeType.assert(node2);
                if (namedTypes2.CatchClause.check(node2)) {
                  var param = path2.get("param");
                  if (param.value) {
                    addPattern(param, bindings2);
                  }
                } else {
                  recursiveScanScope(path2, bindings2, scopeTypes2);
                }
              }
              function recursiveScanScope(path2, bindings2, scopeTypes2) {
                var node2 = path2.value;
                if (path2.parent && namedTypes2.FunctionExpression.check(path2.parent.node) && path2.parent.node.id) {
                  addPattern(path2.parent.get("id"), bindings2);
                }
                if (!node2)
                  ;
                else if (isArray2.check(node2)) {
                  path2.each(function(childPath) {
                    recursiveScanChild(childPath, bindings2, scopeTypes2);
                  });
                } else if (namedTypes2.Function.check(node2)) {
                  path2.get("params").each(function(paramPath) {
                    addPattern(paramPath, bindings2);
                  });
                  recursiveScanChild(path2.get("body"), bindings2, scopeTypes2);
                } else if (namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node2) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node2) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node2) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node2)) {
                  addTypePattern(path2.get("id"), scopeTypes2);
                } else if (namedTypes2.VariableDeclarator.check(node2)) {
                  addPattern(path2.get("id"), bindings2);
                  recursiveScanChild(path2.get("init"), bindings2, scopeTypes2);
                } else if (node2.type === "ImportSpecifier" || node2.type === "ImportNamespaceSpecifier" || node2.type === "ImportDefaultSpecifier") {
                  addPattern(path2.get(node2.local ? "local" : node2.name ? "name" : "id"), bindings2);
                } else if (Node3.check(node2) && !Expression2.check(node2)) {
                  types2.eachField(node2, function(name2, child) {
                    var childPath = path2.get(name2);
                    if (!pathHasValue(childPath, child)) {
                      throw new Error("");
                    }
                    recursiveScanChild(childPath, bindings2, scopeTypes2);
                  });
                }
              }
              function pathHasValue(path2, value) {
                if (path2.value === value) {
                  return true;
                }
                if (Array.isArray(path2.value) && path2.value.length === 0 && Array.isArray(value) && value.length === 0) {
                  return true;
                }
                return false;
              }
              function recursiveScanChild(path2, bindings2, scopeTypes2) {
                var node2 = path2.value;
                if (!node2 || Expression2.check(node2))
                  ;
                else if (namedTypes2.FunctionDeclaration.check(node2) && node2.id !== null) {
                  addPattern(path2.get("id"), bindings2);
                } else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node2)) {
                  addPattern(path2.get("id"), bindings2);
                } else if (ScopeType.check(node2)) {
                  if (namedTypes2.CatchClause.check(node2) && namedTypes2.Identifier.check(node2.param)) {
                    var catchParamName = node2.param.name;
                    var hadBinding = hasOwn2.call(bindings2, catchParamName);
                    recursiveScanScope(path2.get("body"), bindings2, scopeTypes2);
                    if (!hadBinding) {
                      delete bindings2[catchParamName];
                    }
                  }
                } else {
                  recursiveScanScope(path2, bindings2, scopeTypes2);
                }
              }
              function addPattern(patternPath, bindings2) {
                var pattern = patternPath.value;
                namedTypes2.Pattern.assert(pattern);
                if (namedTypes2.Identifier.check(pattern)) {
                  if (hasOwn2.call(bindings2, pattern.name)) {
                    bindings2[pattern.name].push(patternPath);
                  } else {
                    bindings2[pattern.name] = [patternPath];
                  }
                } else if (namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern)) {
                  addPattern(patternPath.get("left"), bindings2);
                } else if (namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern)) {
                  patternPath.get("properties").each(function(propertyPath) {
                    var property = propertyPath.value;
                    if (namedTypes2.Pattern.check(property)) {
                      addPattern(propertyPath, bindings2);
                    } else if (namedTypes2.Property.check(property)) {
                      addPattern(propertyPath.get("value"), bindings2);
                    } else if (namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property)) {
                      addPattern(propertyPath.get("argument"), bindings2);
                    }
                  });
                } else if (namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern)) {
                  patternPath.get("elements").each(function(elementPath) {
                    var element = elementPath.value;
                    if (namedTypes2.Pattern.check(element)) {
                      addPattern(elementPath, bindings2);
                    } else if (namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element)) {
                      addPattern(elementPath.get("argument"), bindings2);
                    }
                  });
                } else if (namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern)) {
                  addPattern(patternPath.get("pattern"), bindings2);
                } else if (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.RestElement && namedTypes2.RestElement.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) {
                  addPattern(patternPath.get("argument"), bindings2);
                }
              }
              function addTypePattern(patternPath, types3) {
                var pattern = patternPath.value;
                namedTypes2.Pattern.assert(pattern);
                if (namedTypes2.Identifier.check(pattern)) {
                  if (hasOwn2.call(types3, pattern.name)) {
                    types3[pattern.name].push(patternPath);
                  } else {
                    types3[pattern.name] = [patternPath];
                  }
                }
              }
              Sp.lookup = function(name2) {
                for (var scope2 = this; scope2; scope2 = scope2.parent)
                  if (scope2.declares(name2))
                    break;
                return scope2;
              };
              Sp.lookupType = function(name2) {
                for (var scope2 = this; scope2; scope2 = scope2.parent)
                  if (scope2.declaresType(name2))
                    break;
                return scope2;
              };
              Sp.getGlobalScope = function() {
                var scope2 = this;
                while (!scope2.isGlobal)
                  scope2 = scope2.parent;
                return scope2;
              };
              return Scope2;
            }
            exports4.default = scopePlugin;
            module3.exports = exports4["default"];
          });
          var nodePath = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var path_1 = tslib_1.__importDefault(path);
            var scope_1 = tslib_1.__importDefault(scope$1);
            function nodePathPlugin(fork2) {
              var types2 = fork2.use(types_1.default);
              var n2 = types2.namedTypes;
              var b = types2.builders;
              var isNumber2 = types2.builtInTypes.number;
              var isArray2 = types2.builtInTypes.array;
              var Path = fork2.use(path_1.default);
              var Scope2 = fork2.use(scope_1.default);
              var NodePath = function NodePath2(value, parentPath, name2) {
                if (!(this instanceof NodePath2)) {
                  throw new Error("NodePath constructor cannot be invoked without 'new'");
                }
                Path.call(this, value, parentPath, name2);
              };
              var NPp = NodePath.prototype = Object.create(Path.prototype, {constructor: {value: NodePath, enumerable: false, writable: true, configurable: true}});
              Object.defineProperties(NPp, {node: {get: function get2() {
                Object.defineProperty(this, "node", {configurable: true, value: this._computeNode()});
                return this.node;
              }}, parent: {get: function get2() {
                Object.defineProperty(this, "parent", {configurable: true, value: this._computeParent()});
                return this.parent;
              }}, scope: {get: function get2() {
                Object.defineProperty(this, "scope", {configurable: true, value: this._computeScope()});
                return this.scope;
              }}});
              NPp.replace = function() {
                delete this.node;
                delete this.parent;
                delete this.scope;
                return Path.prototype.replace.apply(this, arguments);
              };
              NPp.prune = function() {
                var remainingNodePath = this.parent;
                this.replace();
                return cleanUpNodesAfterPrune(remainingNodePath);
              };
              NPp._computeNode = function() {
                var value = this.value;
                if (n2.Node.check(value)) {
                  return value;
                }
                var pp = this.parentPath;
                return pp && pp.node || null;
              };
              NPp._computeParent = function() {
                var value = this.value;
                var pp = this.parentPath;
                if (!n2.Node.check(value)) {
                  while (pp && !n2.Node.check(pp.value)) {
                    pp = pp.parentPath;
                  }
                  if (pp) {
                    pp = pp.parentPath;
                  }
                }
                while (pp && !n2.Node.check(pp.value)) {
                  pp = pp.parentPath;
                }
                return pp || null;
              };
              NPp._computeScope = function() {
                var value = this.value;
                var pp = this.parentPath;
                var scope2 = pp && pp.scope;
                if (n2.Node.check(value) && Scope2.isEstablishedBy(value)) {
                  scope2 = new Scope2(this, scope2);
                }
                return scope2 || null;
              };
              NPp.getValueProperty = function(name2) {
                return types2.getFieldValue(this.value, name2);
              };
              NPp.needsParens = function(assumeExpressionContext) {
                var pp = this.parentPath;
                if (!pp) {
                  return false;
                }
                var node2 = this.value;
                if (!n2.Expression.check(node2)) {
                  return false;
                }
                if (node2.type === "Identifier") {
                  return false;
                }
                while (!n2.Node.check(pp.value)) {
                  pp = pp.parentPath;
                  if (!pp) {
                    return false;
                  }
                }
                var parent = pp.value;
                switch (node2.type) {
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                    return parent.type === "MemberExpression" && this.name === "object" && parent.object === node2;
                  case "BinaryExpression":
                  case "LogicalExpression":
                    switch (parent.type) {
                      case "CallExpression":
                        return this.name === "callee" && parent.callee === node2;
                      case "UnaryExpression":
                      case "SpreadElement":
                      case "SpreadProperty":
                        return true;
                      case "MemberExpression":
                        return this.name === "object" && parent.object === node2;
                      case "BinaryExpression":
                      case "LogicalExpression": {
                        var n_1 = node2;
                        var po = parent.operator;
                        var pp_1 = PRECEDENCE2[po];
                        var no = n_1.operator;
                        var np = PRECEDENCE2[no];
                        if (pp_1 > np) {
                          return true;
                        }
                        if (pp_1 === np && this.name === "right") {
                          if (parent.right !== n_1) {
                            throw new Error("Nodes must be equal");
                          }
                          return true;
                        }
                      }
                      default:
                        return false;
                    }
                  case "SequenceExpression":
                    switch (parent.type) {
                      case "ForStatement":
                        return false;
                      case "ExpressionStatement":
                        return this.name !== "expression";
                      default:
                        return true;
                    }
                  case "YieldExpression":
                    switch (parent.type) {
                      case "BinaryExpression":
                      case "LogicalExpression":
                      case "UnaryExpression":
                      case "SpreadElement":
                      case "SpreadProperty":
                      case "CallExpression":
                      case "MemberExpression":
                      case "NewExpression":
                      case "ConditionalExpression":
                      case "YieldExpression":
                        return true;
                      default:
                        return false;
                    }
                  case "Literal":
                    return parent.type === "MemberExpression" && isNumber2.check(node2.value) && this.name === "object" && parent.object === node2;
                  case "AssignmentExpression":
                  case "ConditionalExpression":
                    switch (parent.type) {
                      case "UnaryExpression":
                      case "SpreadElement":
                      case "SpreadProperty":
                      case "BinaryExpression":
                      case "LogicalExpression":
                        return true;
                      case "CallExpression":
                        return this.name === "callee" && parent.callee === node2;
                      case "ConditionalExpression":
                        return this.name === "test" && parent.test === node2;
                      case "MemberExpression":
                        return this.name === "object" && parent.object === node2;
                      default:
                        return false;
                    }
                  default:
                    if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node2) {
                      return containsCallExpression2(node2);
                    }
                }
                if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
                  return true;
                return false;
              };
              function isBinary2(node2) {
                return n2.BinaryExpression.check(node2) || n2.LogicalExpression.check(node2);
              }
              var PRECEDENCE2 = {};
              [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"]].forEach(function(tier, i) {
                tier.forEach(function(op) {
                  PRECEDENCE2[op] = i;
                });
              });
              function containsCallExpression2(node2) {
                if (n2.CallExpression.check(node2)) {
                  return true;
                }
                if (isArray2.check(node2)) {
                  return node2.some(containsCallExpression2);
                }
                if (n2.Node.check(node2)) {
                  return types2.someField(node2, function(_name, child) {
                    return containsCallExpression2(child);
                  });
                }
                return false;
              }
              NPp.canBeFirstInStatement = function() {
                var node2 = this.node;
                return !n2.FunctionExpression.check(node2) && !n2.ObjectExpression.check(node2);
              };
              NPp.firstInStatement = function() {
                return firstInStatement(this);
              };
              function firstInStatement(path2) {
                for (var node2, parent; path2.parent; path2 = path2.parent) {
                  node2 = path2.node;
                  parent = path2.parent.node;
                  if (n2.BlockStatement.check(parent) && path2.parent.name === "body" && path2.name === 0) {
                    if (parent.body[0] !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    return true;
                  }
                  if (n2.ExpressionStatement.check(parent) && path2.name === "expression") {
                    if (parent.expression !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    return true;
                  }
                  if (n2.SequenceExpression.check(parent) && path2.parent.name === "expressions" && path2.name === 0) {
                    if (parent.expressions[0] !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    continue;
                  }
                  if (n2.CallExpression.check(parent) && path2.name === "callee") {
                    if (parent.callee !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    continue;
                  }
                  if (n2.MemberExpression.check(parent) && path2.name === "object") {
                    if (parent.object !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    continue;
                  }
                  if (n2.ConditionalExpression.check(parent) && path2.name === "test") {
                    if (parent.test !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    continue;
                  }
                  if (isBinary2(parent) && path2.name === "left") {
                    if (parent.left !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    continue;
                  }
                  if (n2.UnaryExpression.check(parent) && !parent.prefix && path2.name === "argument") {
                    if (parent.argument !== node2) {
                      throw new Error("Nodes must be equal");
                    }
                    continue;
                  }
                  return false;
                }
                return true;
              }
              function cleanUpNodesAfterPrune(remainingNodePath) {
                if (n2.VariableDeclaration.check(remainingNodePath.node)) {
                  var declarations = remainingNodePath.get("declarations").value;
                  if (!declarations || declarations.length === 0) {
                    return remainingNodePath.prune();
                  }
                } else if (n2.ExpressionStatement.check(remainingNodePath.node)) {
                  if (!remainingNodePath.get("expression").value) {
                    return remainingNodePath.prune();
                  }
                } else if (n2.IfStatement.check(remainingNodePath.node)) {
                  cleanUpIfStatementAfterPrune(remainingNodePath);
                }
                return remainingNodePath;
              }
              function cleanUpIfStatementAfterPrune(ifStatement) {
                var testExpression = ifStatement.get("test").value;
                var alternate = ifStatement.get("alternate").value;
                var consequent = ifStatement.get("consequent").value;
                if (!consequent && !alternate) {
                  var testExpressionStatement = b.expressionStatement(testExpression);
                  ifStatement.replace(testExpressionStatement);
                } else if (!consequent && alternate) {
                  var negatedTestExpression = b.unaryExpression("!", testExpression, true);
                  if (n2.UnaryExpression.check(testExpression) && testExpression.operator === "!") {
                    negatedTestExpression = testExpression.argument;
                  }
                  ifStatement.get("test").replace(negatedTestExpression);
                  ifStatement.get("consequent").replace(alternate);
                  ifStatement.get("alternate").replace();
                }
              }
              return NodePath;
            }
            exports4.default = nodePathPlugin;
            module3.exports = exports4["default"];
          });
          var pathVisitor = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var node_path_1 = tslib_1.__importDefault(nodePath);
            var hasOwn2 = Object.prototype.hasOwnProperty;
            function pathVisitorPlugin(fork2) {
              var types2 = fork2.use(types_1.default);
              var NodePath = fork2.use(node_path_1.default);
              var isArray2 = types2.builtInTypes.array;
              var isObject3 = types2.builtInTypes.object;
              var isFunction3 = types2.builtInTypes.function;
              var undefined$1;
              var PathVisitor = function PathVisitor2() {
                if (!(this instanceof PathVisitor2)) {
                  throw new Error("PathVisitor constructor cannot be invoked without 'new'");
                }
                this._reusableContextStack = [];
                this._methodNameTable = computeMethodNameTable(this);
                this._shouldVisitComments = hasOwn2.call(this._methodNameTable, "Block") || hasOwn2.call(this._methodNameTable, "Line");
                this.Context = makeContextConstructor(this);
                this._visiting = false;
                this._changeReported = false;
              };
              function computeMethodNameTable(visitor) {
                var typeNames = Object.create(null);
                for (var methodName in visitor) {
                  if (/^visit[A-Z]/.test(methodName)) {
                    typeNames[methodName.slice("visit".length)] = true;
                  }
                }
                var supertypeTable = types2.computeSupertypeLookupTable(typeNames);
                var methodNameTable = Object.create(null);
                var typeNameKeys = Object.keys(supertypeTable);
                var typeNameCount = typeNameKeys.length;
                for (var i = 0; i < typeNameCount; ++i) {
                  var typeName = typeNameKeys[i];
                  methodName = "visit" + supertypeTable[typeName];
                  if (isFunction3.check(visitor[methodName])) {
                    methodNameTable[typeName] = methodName;
                  }
                }
                return methodNameTable;
              }
              PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
                if (methods instanceof PathVisitor) {
                  return methods;
                }
                if (!isObject3.check(methods)) {
                  return new PathVisitor();
                }
                var Visitor = function Visitor2() {
                  if (!(this instanceof Visitor2)) {
                    throw new Error("Visitor constructor cannot be invoked without 'new'");
                  }
                  PathVisitor.call(this);
                };
                var Vp = Visitor.prototype = Object.create(PVp);
                Vp.constructor = Visitor;
                extend(Vp, methods);
                extend(Visitor, PathVisitor);
                isFunction3.assert(Visitor.fromMethodsObject);
                isFunction3.assert(Visitor.visit);
                return new Visitor();
              };
              function extend(target, source) {
                for (var property in source) {
                  if (hasOwn2.call(source, property)) {
                    target[property] = source[property];
                  }
                }
                return target;
              }
              PathVisitor.visit = function visit(node2, methods) {
                return PathVisitor.fromMethodsObject(methods).visit(node2);
              };
              var PVp = PathVisitor.prototype;
              PVp.visit = function() {
                if (this._visiting) {
                  throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
                }
                this._visiting = true;
                this._changeReported = false;
                this._abortRequested = false;
                var argc = arguments.length;
                var args = new Array(argc);
                for (var i = 0; i < argc; ++i) {
                  args[i] = arguments[i];
                }
                if (!(args[0] instanceof NodePath)) {
                  args[0] = new NodePath({root: args[0]}).get("root");
                }
                this.reset.apply(this, args);
                var didNotThrow;
                try {
                  var root = this.visitWithoutReset(args[0]);
                  didNotThrow = true;
                } finally {
                  this._visiting = false;
                  if (!didNotThrow && this._abortRequested) {
                    return args[0].value;
                  }
                }
                return root;
              };
              PVp.AbortRequest = function AbortRequest() {
              };
              PVp.abort = function() {
                var visitor = this;
                visitor._abortRequested = true;
                var request = new visitor.AbortRequest();
                request.cancel = function() {
                  visitor._abortRequested = false;
                };
                throw request;
              };
              PVp.reset = function(_path) {
              };
              PVp.visitWithoutReset = function(path2) {
                if (this instanceof this.Context) {
                  return this.visitor.visitWithoutReset(path2);
                }
                if (!(path2 instanceof NodePath)) {
                  throw new Error("");
                }
                var value = path2.value;
                var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
                if (methodName) {
                  var context = this.acquireContext(path2);
                  try {
                    return context.invokeVisitorMethod(methodName);
                  } finally {
                    this.releaseContext(context);
                  }
                } else {
                  return visitChildren(path2, this);
                }
              };
              function visitChildren(path2, visitor) {
                if (!(path2 instanceof NodePath)) {
                  throw new Error("");
                }
                if (!(visitor instanceof PathVisitor)) {
                  throw new Error("");
                }
                var value = path2.value;
                if (isArray2.check(value)) {
                  path2.each(visitor.visitWithoutReset, visitor);
                } else if (!isObject3.check(value))
                  ;
                else {
                  var childNames = types2.getFieldNames(value);
                  if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) {
                    childNames.push("comments");
                  }
                  var childCount = childNames.length;
                  var childPaths = [];
                  for (var i = 0; i < childCount; ++i) {
                    var childName = childNames[i];
                    if (!hasOwn2.call(value, childName)) {
                      value[childName] = types2.getFieldValue(value, childName);
                    }
                    childPaths.push(path2.get(childName));
                  }
                  for (var i = 0; i < childCount; ++i) {
                    visitor.visitWithoutReset(childPaths[i]);
                  }
                }
                return path2.value;
              }
              PVp.acquireContext = function(path2) {
                if (this._reusableContextStack.length === 0) {
                  return new this.Context(path2);
                }
                return this._reusableContextStack.pop().reset(path2);
              };
              PVp.releaseContext = function(context) {
                if (!(context instanceof this.Context)) {
                  throw new Error("");
                }
                this._reusableContextStack.push(context);
                context.currentPath = null;
              };
              PVp.reportChanged = function() {
                this._changeReported = true;
              };
              PVp.wasChangeReported = function() {
                return this._changeReported;
              };
              function makeContextConstructor(visitor) {
                function Context(path2) {
                  if (!(this instanceof Context)) {
                    throw new Error("");
                  }
                  if (!(this instanceof PathVisitor)) {
                    throw new Error("");
                  }
                  if (!(path2 instanceof NodePath)) {
                    throw new Error("");
                  }
                  Object.defineProperty(this, "visitor", {value: visitor, writable: false, enumerable: true, configurable: false});
                  this.currentPath = path2;
                  this.needToCallTraverse = true;
                  Object.seal(this);
                }
                if (!(visitor instanceof PathVisitor)) {
                  throw new Error("");
                }
                var Cp = Context.prototype = Object.create(visitor);
                Cp.constructor = Context;
                extend(Cp, sharedContextProtoMethods);
                return Context;
              }
              var sharedContextProtoMethods = Object.create(null);
              sharedContextProtoMethods.reset = function reset(path2) {
                if (!(this instanceof this.Context)) {
                  throw new Error("");
                }
                if (!(path2 instanceof NodePath)) {
                  throw new Error("");
                }
                this.currentPath = path2;
                this.needToCallTraverse = true;
                return this;
              };
              sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
                if (!(this instanceof this.Context)) {
                  throw new Error("");
                }
                if (!(this.currentPath instanceof NodePath)) {
                  throw new Error("");
                }
                var result = this.visitor[methodName].call(this, this.currentPath);
                if (result === false) {
                  this.needToCallTraverse = false;
                } else if (result !== undefined$1) {
                  this.currentPath = this.currentPath.replace(result)[0];
                  if (this.needToCallTraverse) {
                    this.traverse(this.currentPath);
                  }
                }
                if (this.needToCallTraverse !== false) {
                  throw new Error("Must either call this.traverse or return false in " + methodName);
                }
                var path2 = this.currentPath;
                return path2 && path2.value;
              };
              sharedContextProtoMethods.traverse = function traverse(path2, newVisitor) {
                if (!(this instanceof this.Context)) {
                  throw new Error("");
                }
                if (!(path2 instanceof NodePath)) {
                  throw new Error("");
                }
                if (!(this.currentPath instanceof NodePath)) {
                  throw new Error("");
                }
                this.needToCallTraverse = false;
                return visitChildren(path2, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
              };
              sharedContextProtoMethods.visit = function visit(path2, newVisitor) {
                if (!(this instanceof this.Context)) {
                  throw new Error("");
                }
                if (!(path2 instanceof NodePath)) {
                  throw new Error("");
                }
                if (!(this.currentPath instanceof NodePath)) {
                  throw new Error("");
                }
                this.needToCallTraverse = false;
                return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path2);
              };
              sharedContextProtoMethods.reportChanged = function reportChanged() {
                this.visitor.reportChanged();
              };
              sharedContextProtoMethods.abort = function abort() {
                this.needToCallTraverse = false;
                this.visitor.abort();
              };
              return PathVisitor;
            }
            exports4.default = pathVisitorPlugin;
            module3.exports = exports4["default"];
          });
          var equiv$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            function default_1(fork2) {
              var types2 = fork2.use(types_1.default);
              var getFieldNames = types2.getFieldNames;
              var getFieldValue = types2.getFieldValue;
              var isArray2 = types2.builtInTypes.array;
              var isObject3 = types2.builtInTypes.object;
              var isDate2 = types2.builtInTypes.Date;
              var isRegExp2 = types2.builtInTypes.RegExp;
              var hasOwn2 = Object.prototype.hasOwnProperty;
              function astNodesAreEquivalent(a, b, problemPath) {
                if (isArray2.check(problemPath)) {
                  problemPath.length = 0;
                } else {
                  problemPath = null;
                }
                return areEquivalent(a, b, problemPath);
              }
              astNodesAreEquivalent.assert = function(a, b) {
                var problemPath = [];
                if (!astNodesAreEquivalent(a, b, problemPath)) {
                  if (problemPath.length === 0) {
                    if (a !== b) {
                      throw new Error("Nodes must be equal");
                    }
                  } else {
                    throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
                  }
                }
              };
              function subscriptForProperty(property) {
                if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
                  return "." + property;
                }
                return "[" + JSON.stringify(property) + "]";
              }
              function areEquivalent(a, b, problemPath) {
                if (a === b) {
                  return true;
                }
                if (isArray2.check(a)) {
                  return arraysAreEquivalent(a, b, problemPath);
                }
                if (isObject3.check(a)) {
                  return objectsAreEquivalent(a, b, problemPath);
                }
                if (isDate2.check(a)) {
                  return isDate2.check(b) && +a === +b;
                }
                if (isRegExp2.check(a)) {
                  return isRegExp2.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;
                }
                return a == b;
              }
              function arraysAreEquivalent(a, b, problemPath) {
                isArray2.assert(a);
                var aLength = a.length;
                if (!isArray2.check(b) || b.length !== aLength) {
                  if (problemPath) {
                    problemPath.push("length");
                  }
                  return false;
                }
                for (var i = 0; i < aLength; ++i) {
                  if (problemPath) {
                    problemPath.push(i);
                  }
                  if (i in a !== i in b) {
                    return false;
                  }
                  if (!areEquivalent(a[i], b[i], problemPath)) {
                    return false;
                  }
                  if (problemPath) {
                    var problemPathTail = problemPath.pop();
                    if (problemPathTail !== i) {
                      throw new Error("" + problemPathTail);
                    }
                  }
                }
                return true;
              }
              function objectsAreEquivalent(a, b, problemPath) {
                isObject3.assert(a);
                if (!isObject3.check(b)) {
                  return false;
                }
                if (a.type !== b.type) {
                  if (problemPath) {
                    problemPath.push("type");
                  }
                  return false;
                }
                var aNames = getFieldNames(a);
                var aNameCount = aNames.length;
                var bNames = getFieldNames(b);
                var bNameCount = bNames.length;
                if (aNameCount === bNameCount) {
                  for (var i = 0; i < aNameCount; ++i) {
                    var name2 = aNames[i];
                    var aChild = getFieldValue(a, name2);
                    var bChild = getFieldValue(b, name2);
                    if (problemPath) {
                      problemPath.push(name2);
                    }
                    if (!areEquivalent(aChild, bChild, problemPath)) {
                      return false;
                    }
                    if (problemPath) {
                      var problemPathTail = problemPath.pop();
                      if (problemPathTail !== name2) {
                        throw new Error("" + problemPathTail);
                      }
                    }
                  }
                  return true;
                }
                if (!problemPath) {
                  return false;
                }
                var seenNames = Object.create(null);
                for (i = 0; i < aNameCount; ++i) {
                  seenNames[aNames[i]] = true;
                }
                for (i = 0; i < bNameCount; ++i) {
                  name2 = bNames[i];
                  if (!hasOwn2.call(seenNames, name2)) {
                    problemPath.push(name2);
                    return false;
                  }
                  delete seenNames[name2];
                }
                for (name2 in seenNames) {
                  problemPath.push(name2);
                  break;
                }
                return false;
              }
              return astNodesAreEquivalent;
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var fork = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var path_visitor_1 = tslib_1.__importDefault(pathVisitor);
            var equiv_1 = tslib_1.__importDefault(equiv$1);
            var path_1 = tslib_1.__importDefault(path);
            var node_path_1 = tslib_1.__importDefault(nodePath);
            function default_1(defs) {
              var fork2 = createFork();
              var types2 = fork2.use(types_1.default);
              defs.forEach(fork2.use);
              types2.finalize();
              var PathVisitor = fork2.use(path_visitor_1.default);
              return {Type: types2.Type, builtInTypes: types2.builtInTypes, namedTypes: types2.namedTypes, builders: types2.builders, defineMethod: types2.defineMethod, getFieldNames: types2.getFieldNames, getFieldValue: types2.getFieldValue, eachField: types2.eachField, someField: types2.someField, getSupertypeNames: types2.getSupertypeNames, getBuilderName: types2.getBuilderName, astNodesAreEquivalent: fork2.use(equiv_1.default), finalize: types2.finalize, Path: fork2.use(path_1.default), NodePath: fork2.use(node_path_1.default), PathVisitor, use: fork2.use, visit: PathVisitor.visit};
            }
            exports4.default = default_1;
            function createFork() {
              var used = [];
              var usedResult = [];
              function use(plugin) {
                var idx = used.indexOf(plugin);
                if (idx === -1) {
                  idx = used.length;
                  used.push(plugin);
                  usedResult[idx] = plugin(fork2);
                }
                return usedResult[idx];
              }
              var fork2 = {use};
              return fork2;
            }
            module3.exports = exports4["default"];
          });
          var coreOperators = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.LogicalOperators = exports4.AssignmentOperators = exports4.BinaryOperators = void 0;
            exports4.BinaryOperators = ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "&", "|", "^", "in", "instanceof"];
            exports4.AssignmentOperators = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="];
            exports4.LogicalOperators = ["||", "&&"];
          });
          var shared = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            function default_1(fork2) {
              var types2 = fork2.use(types_1.default);
              var Type = types2.Type;
              var builtin2 = types2.builtInTypes;
              var isNumber2 = builtin2.number;
              function geq(than) {
                return Type.from(function(value) {
                  return isNumber2.check(value) && value >= than;
                }, isNumber2 + " >= " + than);
              }
              var defaults = {
                "null": function _null() {
                  return null;
                },
                "emptyArray": function emptyArray() {
                  return [];
                },
                "false": function _false() {
                  return false;
                },
                "true": function _true() {
                  return true;
                },
                "undefined": function undefined$1() {
                },
                "use strict": function useStrict() {
                  return "use strict";
                }
              };
              var naiveIsPrimitive = Type.or(builtin2.string, builtin2.number, builtin2.boolean, builtin2.null, builtin2.undefined);
              var isPrimitive2 = Type.from(function(value) {
                if (value === null)
                  return true;
                var type2 = typeof value;
                if (type2 === "object" || type2 === "function") {
                  return false;
                }
                return true;
              }, naiveIsPrimitive.toString());
              return {geq, defaults, isPrimitive: isPrimitive2};
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var core = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              var types2 = fork2.use(types_1.default);
              var Type = types2.Type;
              var def = Type.def;
              var or2 = Type.or;
              var shared2 = fork2.use(shared_1.default);
              var defaults = shared2.defaults;
              var geq = shared2.geq;
              def("Printable").field("loc", or2(def("SourceLocation"), null), defaults["null"], true);
              def("Node").bases("Printable").field("type", String).field("comments", or2([def("Comment")], null), defaults["null"], true);
              def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or2(String, null), defaults["null"]);
              def("Position").field("line", geq(1)).field("column", geq(0));
              def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or2(String, null), defaults["null"]);
              def("Program").bases("Node").build("body").field("body", [def("Statement")]);
              def("Function").bases("Node").field("id", or2(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]);
              def("Statement").bases("Node");
              def("EmptyStatement").bases("Statement").build();
              def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
              def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
              def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or2(def("Statement"), null), defaults["null"]);
              def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
              def("BreakStatement").bases("Statement").build("label").field("label", or2(def("Identifier"), null), defaults["null"]);
              def("ContinueStatement").bases("Statement").build("label").field("label", or2(def("Identifier"), null), defaults["null"]);
              def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
              def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults["false"]);
              def("ReturnStatement").bases("Statement").build("argument").field("argument", or2(def("Expression"), null));
              def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
              def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or2(def("CatchClause"), null), function() {
                return this.handlers && this.handlers[0] || null;
              }).field("handlers", [def("CatchClause")], function() {
                return this.handler ? [this.handler] : [];
              }, true).field("guardedHandlers", [def("CatchClause")], defaults.emptyArray).field("finalizer", or2(def("BlockStatement"), null), defaults["null"]);
              def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or2(def("Expression"), null), defaults["null"]).field("body", def("BlockStatement"));
              def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
              def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
              def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or2(def("VariableDeclaration"), def("Expression"), null)).field("test", or2(def("Expression"), null)).field("update", or2(def("Expression"), null)).field("body", def("Statement"));
              def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or2(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
              def("DebuggerStatement").bases("Statement").build();
              def("Declaration").bases("Statement");
              def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
              def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
              def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or2("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
              def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or2(def("Expression"), null), defaults["null"]);
              def("Expression").bases("Node");
              def("ThisExpression").bases("Expression").build();
              def("ArrayExpression").bases("Expression").build("elements").field("elements", [or2(def("Expression"), null)]);
              def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
              def("Property").bases("Node").build("kind", "key", "value").field("kind", or2("init", "get", "set")).field("key", or2(def("Literal"), def("Identifier"))).field("value", def("Expression"));
              def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
              var UnaryOperator = or2("-", "+", "!", "~", "typeof", "void", "delete");
              def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults["true"]);
              var BinaryOperator = or2.apply(void 0, coreOperators.BinaryOperators);
              def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
              var AssignmentOperator = or2.apply(void 0, coreOperators.AssignmentOperators);
              def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or2(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
              var UpdateOperator = or2("++", "--");
              def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
              var LogicalOperator = or2.apply(void 0, coreOperators.LogicalOperators);
              def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
              def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
              def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
              def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
              def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or2(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
                var type2 = this.property.type;
                if (type2 === "Literal" || type2 === "MemberExpression" || type2 === "BinaryExpression") {
                  return true;
                }
                return false;
              });
              def("Pattern").bases("Node");
              def("SwitchCase").bases("Node").build("test", "consequent").field("test", or2(def("Expression"), null)).field("consequent", [def("Statement")]);
              def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults["false"]);
              def("Literal").bases("Expression").build("value").field("value", or2(String, Boolean, null, Number, RegExp)).field("regex", or2({pattern: String, flags: String}, null), function() {
                if (this.value instanceof RegExp) {
                  var flags = "";
                  if (this.value.ignoreCase)
                    flags += "i";
                  if (this.value.multiline)
                    flags += "m";
                  if (this.value.global)
                    flags += "g";
                  return {pattern: this.value.source, flags};
                }
                return null;
              });
              def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults["true"]).field("trailing", Boolean, defaults["false"]);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var es6 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var core_1 = tslib_1.__importDefault(core);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(core_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var defaults = fork2.use(shared_1.default).defaults;
              def("Function").field("generator", Boolean, defaults["false"]).field("expression", Boolean, defaults["false"]).field("defaults", [or2(def("Expression"), null)], defaults.emptyArray).field("rest", or2(def("Identifier"), null), defaults["null"]);
              def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field("typeAnnotation", or2(def("TypeAnnotation"), def("TSTypeAnnotation"), null), defaults["null"]);
              def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
              def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or2(def("Identifier"), null));
              def("FunctionExpression").build("id", "params", "body", "generator", "expression");
              def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults["null"]).field("body", or2(def("BlockStatement"), def("Expression"))).field("generator", false, defaults["false"]);
              def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or2(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement"));
              def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or2(def("Expression"), null)).field("delegate", Boolean, defaults["false"]);
              def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or2(def("Expression"), null));
              def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or2(def("Expression"), null));
              def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
              def("Property").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("value", or2(def("Expression"), def("Pattern"))).field("method", Boolean, defaults["false"]).field("shorthand", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]);
              def("ObjectProperty").field("shorthand", Boolean, defaults["false"]);
              def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults["false"]);
              def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or2(def("PropertyPattern"), def("Property"))]);
              def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or2(def("Pattern"), null)]);
              def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
              def("ArrayExpression").field("elements", [or2(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
              def("NewExpression").field("arguments", [or2(def("Expression"), def("SpreadElement"))]);
              def("CallExpression").field("arguments", [or2(def("Expression"), def("SpreadElement"))]);
              def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
              def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or2("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]);
              var ClassBodyElement = or2(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
              def("ClassProperty").bases("Declaration").build("key").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults["false"]);
              def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
              def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
              def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or2(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or2(def("Expression"), null), defaults["null"]);
              def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or2(def("Identifier"), null), defaults["null"]).field("body", def("ClassBody")).field("superClass", or2(def("Expression"), null), defaults["null"]);
              def("Super").bases("Expression").build();
              def("Specifier").bases("Node");
              def("ModuleSpecifier").bases("Specifier").field("local", or2(def("Identifier"), null), defaults["null"]).field("id", or2(def("Identifier"), null), defaults["null"]).field("name", or2(def("Identifier"), null), defaults["null"]);
              def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
              def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
              def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
              def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or2(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults.emptyArray).field("source", def("Literal")).field("importKind", or2("value", "type"), function() {
                return "value";
              });
              def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or2(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults.emptyArray).field("source", or2(def("Literal"), null), defaults["null"]);
              def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
              def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or2(def("Declaration"), def("Expression")));
              def("ExportAllDeclaration").bases("Declaration").build("source").field("source", def("Literal"));
              def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
              def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
              def("TemplateElement").bases("Node").build("value", "tail").field("value", {"cooked": String, "raw": String}).field("tail", Boolean);
              def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var es2016 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es6_1 = tslib_1.__importDefault(es6);
            var types_1 = tslib_1.__importDefault(types$4);
            function default_1(fork2) {
              fork2.use(es6_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var BinaryOperator = or2.apply(void 0, tslib_1.__spreadArrays(coreOperators.BinaryOperators, ["**"]));
              def("BinaryExpression").field("operator", BinaryOperator);
              var AssignmentOperator = or2.apply(void 0, tslib_1.__spreadArrays(coreOperators.AssignmentOperators, ["**="]));
              def("AssignmentExpression").field("operator", AssignmentOperator);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var es2017$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es2016_1 = tslib_1.__importDefault(es2016);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es2016_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var defaults = fork2.use(shared_1.default).defaults;
              def("Function").field("async", Boolean, defaults["false"]);
              def("AwaitExpression").bases("Expression").build("argument").field("argument", def("Expression"));
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var es2018 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es2017_1 = tslib_1.__importDefault(es2017$1);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es2017_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var defaults = fork2.use(shared_1.default).defaults;
              def("ForOfStatement").field("await", Boolean, defaults["false"]);
              def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
              def("ObjectExpression").field("properties", [or2(def("Property"), def("SpreadProperty"), def("SpreadElement"))]);
              def("TemplateElement").field("value", {"cooked": or2(String, null), "raw": String});
              def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
              def("ObjectPattern").field("properties", [or2(def("PropertyPattern"), def("Property"), def("RestElement"), def("SpreadPropertyPattern"))]);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var es2019 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es2018_1 = tslib_1.__importDefault(es2018);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es2018_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var defaults = fork2.use(shared_1.default).defaults;
              def("CatchClause").field("param", or2(def("Pattern"), null), defaults["null"]);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var es2020$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es2019_1 = tslib_1.__importDefault(es2019);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es2019_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var shared2 = fork2.use(shared_1.default);
              var defaults = shared2.defaults;
              def("ImportExpression").bases("Expression").build("source").field("source", def("Expression"));
              def("ExportAllDeclaration").build("source", "exported").field("source", def("Literal")).field("exported", or2(def("Identifier"), null));
              def("ChainElement").bases("Node").field("optional", Boolean, defaults["false"]);
              def("CallExpression").bases("Expression", "ChainElement");
              def("MemberExpression").bases("Expression", "ChainElement");
              def("ChainExpression").bases("Expression").build("expression").field("expression", def("ChainElement"));
              def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults["true"]);
              def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults["true"]);
              var LogicalOperator = or2.apply(void 0, tslib_1.__spreadArrays(coreOperators.LogicalOperators, ["??"]));
              def("LogicalExpression").field("operator", LogicalOperator);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var jsx$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es2020_1 = tslib_1.__importDefault(es2020$1);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es2020_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var defaults = fork2.use(shared_1.default).defaults;
              def("JSXAttribute").bases("Node").build("name", "value").field("name", or2(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or2(def("Literal"), def("JSXExpressionContainer"), def("JSXElement"), def("JSXFragment"), null), defaults["null"]);
              def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
              def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
              def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or2(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults.false);
              var JSXElementName = or2(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
              def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
              var JSXAttributes = [or2(def("JSXAttribute"), def("JSXSpreadAttribute"))];
              def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or2(def("Expression"), def("JSXEmptyExpression")));
              var JSXChildren = [or2(def("JSXText"), def("JSXExpressionContainer"), def("JSXSpreadChild"), def("JSXElement"), def("JSXFragment"), def("Literal"))];
              def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or2(def("JSXClosingElement"), null), defaults["null"]).field("children", JSXChildren, defaults.emptyArray).field("name", JSXElementName, function() {
                return this.openingElement.name;
              }, true).field("selfClosing", Boolean, function() {
                return this.openingElement.selfClosing;
              }, true).field("attributes", JSXAttributes, function() {
                return this.openingElement.attributes;
              }, true);
              def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults.emptyArray).field("selfClosing", Boolean, defaults["false"]);
              def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
              def("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def("JSXOpeningFragment")).field("closingFragment", def("JSXClosingFragment")).field("children", JSXChildren, defaults.emptyArray);
              def("JSXOpeningFragment").bases("Node").build();
              def("JSXClosingFragment").bases("Node").build();
              def("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
                return this.value;
              });
              def("JSXEmptyExpression").bases("Node").build();
              def("JSXSpreadChild").bases("Node").build("expression").field("expression", def("Expression"));
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var esProposals = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            var es2020_1 = tslib_1.__importDefault(es2020$1);
            function default_1(fork2) {
              fork2.use(es2020_1.default);
              var types2 = fork2.use(types_1.default);
              var Type = types2.Type;
              var def = types2.Type.def;
              var or2 = Type.or;
              var shared2 = fork2.use(shared_1.default);
              var defaults = shared2.defaults;
              def("AwaitExpression").build("argument", "all").field("argument", or2(def("Expression"), null)).field("all", Boolean, defaults["false"]);
              def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
              def("Property").field("decorators", or2([def("Decorator")], null), defaults["null"]);
              def("MethodDefinition").field("decorators", or2([def("Decorator")], null), defaults["null"]);
              def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier"));
              def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or2(def("Expression"), null), defaults["null"]);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var typeAnnotations = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var defaults = fork2.use(shared_1.default).defaults;
              var TypeAnnotation = or2(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
              var TypeParamDecl = or2(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
              def("Identifier").field("typeAnnotation", TypeAnnotation, defaults["null"]);
              def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults["null"]);
              def("Function").field("returnType", TypeAnnotation, defaults["null"]).field("typeParameters", TypeParamDecl, defaults["null"]);
              def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or2(def("Expression"), null)).field("static", Boolean, defaults["false"]).field("typeAnnotation", TypeAnnotation, defaults["null"]);
              ["ClassDeclaration", "ClassExpression"].forEach(function(typeName) {
                def(typeName).field("typeParameters", TypeParamDecl, defaults["null"]).field("superTypeParameters", or2(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults["null"]).field("implements", or2([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults.emptyArray);
              });
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var flow$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es_proposals_1 = tslib_1.__importDefault(esProposals);
            var type_annotations_1 = tslib_1.__importDefault(typeAnnotations);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es_proposals_1.default);
              fork2.use(type_annotations_1.default);
              var types2 = fork2.use(types_1.default);
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var defaults = fork2.use(shared_1.default).defaults;
              def("Flow").bases("Node");
              def("FlowType").bases("Flow");
              def("AnyTypeAnnotation").bases("FlowType").build();
              def("EmptyTypeAnnotation").bases("FlowType").build();
              def("MixedTypeAnnotation").bases("FlowType").build();
              def("VoidTypeAnnotation").bases("FlowType").build();
              def("SymbolTypeAnnotation").bases("FlowType").build();
              def("NumberTypeAnnotation").bases("FlowType").build();
              def("BigIntTypeAnnotation").bases("FlowType").build();
              def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
              def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
              def("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String);
              def("StringTypeAnnotation").bases("FlowType").build();
              def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
              def("BooleanTypeAnnotation").bases("FlowType").build();
              def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
              def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
              def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
              def("NullLiteralTypeAnnotation").bases("FlowType").build();
              def("NullTypeAnnotation").bases("FlowType").build();
              def("ThisTypeAnnotation").bases("FlowType").build();
              def("ExistsTypeAnnotation").bases("FlowType").build();
              def("ExistentialTypeParam").bases("FlowType").build();
              def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or2(def("FunctionTypeParam"), null)).field("typeParameters", or2(def("TypeParameterDeclaration"), null));
              def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or2(def("Identifier"), null)).field("typeAnnotation", def("FlowType")).field("optional", Boolean);
              def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType"));
              def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [or2(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))]).field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray).field("inexact", or2(Boolean, void 0), defaults["undefined"]).field("exact", Boolean, defaults["false"]).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults.emptyArray);
              def("Variance").bases("Node").build("kind").field("kind", or2("plus", "minus"));
              var LegacyVariance = or2(def("Variance"), "plus", "minus", null);
              def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or2(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults["null"]);
              def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults["null"]).field("static", Boolean, defaults["false"]);
              def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults["false"]);
              def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or2(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
              def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or2(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or2(def("TypeParameterInstantiation"), null));
              def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or2(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
              def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
              def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
              def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType"));
              def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType"));
              def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
              def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
              def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]);
              def("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults["null"]).field("bound", or2(def("TypeAnnotation"), null), defaults["null"]).field("default", or2(def("FlowType"), null), defaults["null"]);
              def("ClassProperty").field("variance", LegacyVariance, defaults["null"]);
              def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or2(def("Expression"), null), defaults["null"]).field("typeParameters", or2(def("TypeParameterInstantiation"), null), defaults["null"]);
              def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or2([def("InterfaceExtends")], null), defaults["null"]);
              def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterDeclaration"), null), defaults["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
              def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
              def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterInstantiation"), null), defaults["null"]);
              def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterDeclaration"), null)).field("right", def("FlowType"));
              def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
              def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or2(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", or2(def("FlowType"), null));
              def("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or2(def("FlowType"), null));
              def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
              def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
              def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
              def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier")).field("predicate", or2(def("FlowPredicate"), null), defaults["null"]);
              def("DeclareClass").bases("InterfaceDeclaration").build("id");
              def("DeclareModule").bases("Statement").build("id", "body").field("id", or2(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
              def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation"));
              def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or2(def("DeclareVariable"), def("DeclareFunction"), def("DeclareClass"), def("FlowType"), def("TypeAlias"), def("DeclareOpaqueType"), def("InterfaceDeclaration"), null)).field("specifiers", [or2(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or2(def("Literal"), null), defaults["null"]);
              def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or2(def("Literal"), null), defaults["null"]);
              def("ImportDeclaration").field("importKind", or2("value", "type", "typeof"), function() {
                return "value";
              });
              def("FlowPredicate").bases("Flow");
              def("InferredPredicate").bases("FlowPredicate").build();
              def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression"));
              def("Function").field("predicate", or2(def("FlowPredicate"), null), defaults["null"]);
              def("CallExpression").field("typeArguments", or2(null, def("TypeParameterInstantiation")), defaults["null"]);
              def("NewExpression").field("typeArguments", or2(null, def("TypeParameterInstantiation")), defaults["null"]);
              def("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def("Identifier")).field("body", or2(def("EnumBooleanBody"), def("EnumNumberBody"), def("EnumStringBody"), def("EnumSymbolBody")));
              def("EnumBooleanBody").build("members", "explicitType").field("members", [def("EnumBooleanMember")]).field("explicitType", Boolean);
              def("EnumNumberBody").build("members", "explicitType").field("members", [def("EnumNumberMember")]).field("explicitType", Boolean);
              def("EnumStringBody").build("members", "explicitType").field("members", or2([def("EnumStringMember")], [def("EnumDefaultedMember")])).field("explicitType", Boolean);
              def("EnumSymbolBody").build("members").field("members", [def("EnumDefaultedMember")]);
              def("EnumBooleanMember").build("id", "init").field("id", def("Identifier")).field("init", or2(def("Literal"), Boolean));
              def("EnumNumberMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
              def("EnumStringMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
              def("EnumDefaultedMember").build("id").field("id", def("Identifier"));
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var esprima$2 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es2020_1 = tslib_1.__importDefault(es2020$1);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es2020_1.default);
              var types2 = fork2.use(types_1.default);
              var defaults = fork2.use(shared_1.default).defaults;
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              def("VariableDeclaration").field("declarations", [or2(def("VariableDeclarator"), def("Identifier"))]);
              def("Property").field("value", or2(def("Expression"), def("Pattern")));
              def("ArrayPattern").field("elements", [or2(def("Pattern"), def("SpreadElement"), null)]);
              def("ObjectPattern").field("properties", [or2(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"))]);
              def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
              def("ExportBatchSpecifier").bases("Specifier").build();
              def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or2(def("Declaration"), def("Expression"), null)).field("specifiers", [or2(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or2(def("Literal"), null), defaults["null"]);
              def("Block").bases("Comment").build("value", "leading", "trailing");
              def("Line").bases("Comment").build("value", "leading", "trailing");
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var babelCore = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var es_proposals_1 = tslib_1.__importDefault(esProposals);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(es_proposals_1.default);
              var types2 = fork2.use(types_1.default);
              var defaults = fork2.use(shared_1.default).defaults;
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              def("Noop").bases("Statement").build();
              def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
              def("BindExpression").bases("Expression").build("object", "callee").field("object", or2(def("Expression"), null)).field("callee", def("Expression"));
              def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
              def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
              def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
              def("CommentBlock").bases("Comment").build("value", "leading", "trailing");
              def("CommentLine").bases("Comment").build("value", "leading", "trailing");
              def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
              def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults["use strict"]);
              def("InterpreterDirective").bases("Node").build("value").field("value", String);
              def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray);
              def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray).field("interpreter", or2(def("InterpreterDirective"), null), defaults["null"]);
              def("StringLiteral").bases("Literal").build("value").field("value", String);
              def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or2(String, null), defaults["null"]).field("extra", {rawValue: Number, raw: String}, function getDefault() {
                return {rawValue: this.value, raw: this.value + ""};
              });
              def("BigIntLiteral").bases("Literal").build("value").field("value", or2(String, Number)).field("extra", {rawValue: String, raw: String}, function getDefault() {
                return {rawValue: String(this.value), raw: this.value + "n"};
              });
              def("NullLiteral").bases("Literal").build().field("value", null, defaults["null"]);
              def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
              def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
                return new RegExp(this.pattern, this.flags);
              });
              var ObjectExpressionProperty = or2(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
              def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
              def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or2("method", "get", "set")).field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("accessibility", or2(def("Literal"), null), defaults["null"]).field("decorators", or2([def("Decorator")], null), defaults["null"]);
              def("ObjectProperty").bases("Node").build("key", "value").field("key", or2(def("Literal"), def("Identifier"), def("Expression"))).field("value", or2(def("Expression"), def("Pattern"))).field("accessibility", or2(def("Literal"), null), defaults["null"]).field("computed", Boolean, defaults["false"]);
              var ClassBodyElement = or2(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"));
              def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
              def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or2(def("Literal"), def("Identifier"), def("Expression")));
              def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName"));
              ["ClassMethod", "ClassPrivateMethod"].forEach(function(typeName) {
                def(typeName).field("kind", or2("get", "set", "method", "constructor"), function() {
                  return "method";
                }).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("static", or2(Boolean, null), defaults["null"]).field("abstract", or2(Boolean, null), defaults["null"]).field("access", or2("public", "private", "protected", null), defaults["null"]).field("accessibility", or2("public", "private", "protected", null), defaults["null"]).field("decorators", or2([def("Decorator")], null), defaults["null"]).field("optional", or2(Boolean, null), defaults["null"]);
              });
              var ObjectPatternProperty = or2(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"), def("ObjectProperty"), def("RestProperty"));
              def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or2([def("Decorator")], null), defaults["null"]);
              def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
              def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
              def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or2(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
              def("Import").bases("Expression").build();
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var babel$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var babel_core_1 = tslib_1.__importDefault(babelCore);
            var flow_1 = tslib_1.__importDefault(flow$1);
            function default_1(fork2) {
              fork2.use(babel_core_1.default);
              fork2.use(flow_1.default);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var typescript$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            var babel_core_1 = tslib_1.__importDefault(babelCore);
            var type_annotations_1 = tslib_1.__importDefault(typeAnnotations);
            var types_1 = tslib_1.__importDefault(types$4);
            var shared_1 = tslib_1.__importDefault(shared);
            function default_1(fork2) {
              fork2.use(babel_core_1.default);
              fork2.use(type_annotations_1.default);
              var types2 = fork2.use(types_1.default);
              var n2 = types2.namedTypes;
              var def = types2.Type.def;
              var or2 = types2.Type.or;
              var defaults = fork2.use(shared_1.default).defaults;
              var StringLiteral = types2.Type.from(function(value, deep) {
                if (n2.StringLiteral && n2.StringLiteral.check(value, deep)) {
                  return true;
                }
                if (n2.Literal && n2.Literal.check(value, deep) && typeof value.value === "string") {
                  return true;
                }
                return false;
              }, "StringLiteral");
              def("TSType").bases("Node");
              var TSEntityName = or2(def("Identifier"), def("TSQualifiedName"));
              def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
              def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or2(def("TSTypeParameterInstantiation"), null), defaults["null"]);
              def("TSHasOptionalTypeParameters").field("typeParameters", or2(def("TSTypeParameterDeclaration"), null, void 0), defaults["null"]);
              def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or2(def("TSTypeAnnotation"), null), defaults["null"]);
              def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
              def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or2({parenthesized: Boolean}, null), defaults["null"]);
              def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression"));
              ["TSAnyKeyword", "TSBigIntKeyword", "TSBooleanKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword", "TSThisType"].forEach(function(keywordType) {
                def(keywordType).bases("TSType").build();
              });
              def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType"));
              def("TSLiteralType").bases("TSType").build("literal").field("literal", or2(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression")));
              ["TSUnionType", "TSIntersectionType"].forEach(function(typeName) {
                def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
              });
              def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType"));
              def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter"));
              def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
              var ParametersType = [or2(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
              ["TSFunctionType", "TSConstructorType"].forEach(function(typeName) {
                def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
              });
              def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("id", or2(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("returnType", or2(def("TSTypeAnnotation"), def("Noop"), null), defaults["null"]);
              def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("params", [def("Pattern")]).field("abstract", Boolean, defaults["false"]).field("accessibility", or2("public", "private", "protected", void 0), defaults["undefined"]).field("static", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("key", or2(def("Identifier"), def("StringLiteral"), def("NumericLiteral"), def("Expression"))).field("kind", or2("get", "set", "method", "constructor"), function getDefault() {
                return "method";
              }).field("access", or2("public", "private", "protected", void 0), defaults["undefined"]).field("decorators", or2([def("Decorator")], null), defaults["null"]).field("returnType", or2(def("TSTypeAnnotation"), def("Noop"), null), defaults["null"]);
              def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or2(Boolean, "+", "-"), defaults["false"]).field("typeParameter", def("TSTypeParameter")).field("optional", or2(Boolean, "+", "-"), defaults["false"]).field("typeAnnotation", or2(def("TSType"), null), defaults["null"]);
              def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or2(def("TSType"), def("TSNamedTupleMember"))]);
              def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults["false"]).field("elementType", def("TSType"));
              def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
              def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
              def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType"));
              def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType"));
              def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or2(def("TSType"), def("TSTypeAnnotation")));
              def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults["false"]);
              def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("readonly", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("initializer", or2(def("Expression"), null), defaults["null"]);
              def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("parameters", ParametersType);
              def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or2(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or2(def("TSTypeAnnotation"), null), defaults["null"]).field("asserts", Boolean, defaults["false"]);
              ["TSCallSignatureDeclaration", "TSConstructSignatureDeclaration"].forEach(function(typeName) {
                def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
              });
              def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or2(def("Identifier"), StringLiteral)).field("initializer", or2(def("Expression"), null), defaults["null"]);
              def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or2(TSEntityName, def("TSImportType")));
              var TSTypeMember = or2(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
              def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
              def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", String).field("constraint", or2(def("TSType"), void 0), defaults["undefined"]).field("default", or2(def("TSType"), void 0), defaults["undefined"]);
              def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or2({parenthesized: Boolean}, null), defaults["null"]);
              def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]);
              def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]);
              def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults["false"]).field("declare", Boolean, defaults["false"]).field("members", [def("TSEnumMember")]).field("initializer", or2(def("Expression"), null), defaults["null"]);
              def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults["false"]).field("typeAnnotation", def("TSType"));
              def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]);
              def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or2(StringLiteral, TSEntityName)).field("declare", Boolean, defaults["false"]).field("global", Boolean, defaults["false"]).field("body", or2(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults["null"]);
              def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or2(TSEntityName, void 0), defaults["undefined"]);
              def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults["false"]).field("moduleReference", or2(TSEntityName, def("TSExternalModuleReference")));
              def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
              def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression"));
              def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier"));
              def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
              def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
              def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults["false"]).field("extends", or2([def("TSExpressionWithTypeArguments")], null), defaults["null"]).field("body", def("TSInterfaceBody"));
              def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or2("public", "private", "protected", void 0), defaults["undefined"]).field("readonly", Boolean, defaults["false"]).field("parameter", or2(def("Identifier"), def("AssignmentPattern")));
              def("ClassProperty").field("access", or2("public", "private", "protected", void 0), defaults["undefined"]);
              def("ClassBody").field("body", [or2(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("TSDeclareMethod"), TSTypeMember)]);
            }
            exports4.default = default_1;
            module3.exports = exports4["default"];
          });
          var namedTypes_1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.namedTypes = void 0;
            (function(namedTypes2) {
            })(exports4.namedTypes || (exports4.namedTypes = {}));
          });
          var main$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.visit = exports4.use = exports4.Type = exports4.someField = exports4.PathVisitor = exports4.Path = exports4.NodePath = exports4.namedTypes = exports4.getSupertypeNames = exports4.getFieldValue = exports4.getFieldNames = exports4.getBuilderName = exports4.finalize = exports4.eachField = exports4.defineMethod = exports4.builtInTypes = exports4.builders = exports4.astNodesAreEquivalent = void 0;
            var fork_1 = tslib_1.__importDefault(fork);
            var core_1 = tslib_1.__importDefault(core);
            var es6_1 = tslib_1.__importDefault(es6);
            var es2016_1 = tslib_1.__importDefault(es2016);
            var es2017_1 = tslib_1.__importDefault(es2017$1);
            var es2018_1 = tslib_1.__importDefault(es2018);
            var es2019_1 = tslib_1.__importDefault(es2019);
            var es2020_1 = tslib_1.__importDefault(es2020$1);
            var jsx_1 = tslib_1.__importDefault(jsx$1);
            var flow_1 = tslib_1.__importDefault(flow$1);
            var esprima_1 = tslib_1.__importDefault(esprima$2);
            var babel_1 = tslib_1.__importDefault(babel$1);
            var typescript_1 = tslib_1.__importDefault(typescript$1);
            var es_proposals_1 = tslib_1.__importDefault(esProposals);
            Object.defineProperty(exports4, "namedTypes", {enumerable: true, get: function get2() {
              return namedTypes_1.namedTypes;
            }});
            var _a = fork_1.default([
              core_1.default,
              es6_1.default,
              es2016_1.default,
              es2017_1.default,
              es2018_1.default,
              es2019_1.default,
              es2020_1.default,
              jsx_1.default,
              flow_1.default,
              esprima_1.default,
              babel_1.default,
              typescript_1.default,
              es_proposals_1.default
            ]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders2 = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n2 = _a.namedTypes, NodePath = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type = _a.Type, use = _a.use, visit = _a.visit;
            exports4.astNodesAreEquivalent = astNodesAreEquivalent;
            exports4.builders = builders2;
            exports4.builtInTypes = builtInTypes;
            exports4.defineMethod = defineMethod;
            exports4.eachField = eachField;
            exports4.finalize = finalize;
            exports4.getBuilderName = getBuilderName;
            exports4.getFieldNames = getFieldNames;
            exports4.getFieldValue = getFieldValue;
            exports4.getSupertypeNames = getSupertypeNames;
            exports4.NodePath = NodePath;
            exports4.Path = Path;
            exports4.PathVisitor = PathVisitor;
            exports4.someField = someField;
            exports4.Type = Type;
            exports4.use = use;
            exports4.visit = visit;
            Object.assign(namedTypes_1.namedTypes, n2);
          });
          var lookup = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
          var inited = false;
          function init() {
            inited = true;
            var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (var i = 0, len = code.length; i < len; ++i) {
              lookup[i] = code[i];
              revLookup[code.charCodeAt(i)] = i;
            }
            revLookup["-".charCodeAt(0)] = 62;
            revLookup["_".charCodeAt(0)] = 63;
          }
          function toByteArray(b64) {
            if (!inited) {
              init();
            }
            var i, j, l, tmp, placeHolders, arr;
            var len = b64.length;
            if (len % 4 > 0) {
              throw new Error("Invalid string. Length must be a multiple of 4");
            }
            placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
            arr = new Arr(len * 3 / 4 - placeHolders);
            l = placeHolders > 0 ? len - 4 : len;
            var L = 0;
            for (i = 0, j = 0; i < l; i += 4, j += 3) {
              tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
              arr[L++] = tmp >> 16 & 255;
              arr[L++] = tmp >> 8 & 255;
              arr[L++] = tmp & 255;
            }
            if (placeHolders === 2) {
              tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
              arr[L++] = tmp & 255;
            } else if (placeHolders === 1) {
              tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
              arr[L++] = tmp >> 8 & 255;
              arr[L++] = tmp & 255;
            }
            return arr;
          }
          function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
          }
          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i = start; i < end; i += 3) {
              tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
              output.push(tripletToBase64(tmp));
            }
            return output.join("");
          }
          function fromByteArray(uint8) {
            if (!inited) {
              init();
            }
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            var output = "";
            var parts = [];
            var maxChunkLength = 16383;
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
              parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
            }
            if (extraBytes === 1) {
              tmp = uint8[len - 1];
              output += lookup[tmp >> 2];
              output += lookup[tmp << 4 & 63];
              output += "==";
            } else if (extraBytes === 2) {
              tmp = (uint8[len - 2] << 8) + uint8[len - 1];
              output += lookup[tmp >> 10];
              output += lookup[tmp >> 4 & 63];
              output += lookup[tmp << 2 & 63];
              output += "=";
            }
            parts.push(output);
            return parts.join("");
          }
          function read(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }
            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          }
          function write(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c2;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c2 = Math.pow(2, -e)) < 1) {
                e--;
                c2 *= 2;
              }
              if (e + eBias >= 1) {
                value += rt / c2;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c2 >= 2) {
                e++;
                c2 /= 2;
              }
              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c2 - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }
            for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
            }
            e = e << mLen | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
            }
            buffer[offset + i - d] |= s * 128;
          }
          var toString = {}.toString;
          var isArray$2 = Array.isArray || function(arr) {
            return toString.call(arr) == "[object Array]";
          };
          /*!
          * The buffer module from node.js, for the browser.
          *
          * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
          * @license  MIT
          */
          var INSPECT_MAX_BYTES = 50;
          Buffer2.TYPED_ARRAY_SUPPORT = global2.TYPED_ARRAY_SUPPORT !== void 0 ? global2.TYPED_ARRAY_SUPPORT : true;
          function kMaxLength() {
            return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function createBuffer(that, length) {
            if (kMaxLength() < length) {
              throw new RangeError("Invalid typed array length");
            }
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              that = new Uint8Array(length);
              that.__proto__ = Buffer2.prototype;
            } else {
              if (that === null) {
                that = new Buffer2(length);
              }
              that.length = length;
            }
            return that;
          }
          function Buffer2(arg, encodingOrOffset, length) {
            if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
              return new Buffer2(arg, encodingOrOffset, length);
            }
            if (typeof arg === "number") {
              if (typeof encodingOrOffset === "string") {
                throw new Error("If encoding is specified then the first argument must be a string");
              }
              return allocUnsafe(this, arg);
            }
            return from(this, arg, encodingOrOffset, length);
          }
          Buffer2.poolSize = 8192;
          Buffer2._augment = function(arr) {
            arr.__proto__ = Buffer2.prototype;
            return arr;
          };
          function from(that, value, encodingOrOffset, length) {
            if (typeof value === "number") {
              throw new TypeError('"value" argument must not be a number');
            }
            if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
              return fromArrayBuffer(that, value, encodingOrOffset, length);
            }
            if (typeof value === "string") {
              return fromString(that, value, encodingOrOffset);
            }
            return fromObject(that, value);
          }
          Buffer2.from = function(value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length);
          };
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            Buffer2.prototype.__proto__ = Uint8Array.prototype;
            Buffer2.__proto__ = Uint8Array;
          }
          function assertSize(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number');
            } else if (size < 0) {
              throw new RangeError('"size" argument must not be negative');
            }
          }
          function alloc(that, size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(that, size);
            }
            if (fill !== void 0) {
              return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
            }
            return createBuffer(that, size);
          }
          Buffer2.alloc = function(size, fill, encoding) {
            return alloc(null, size, fill, encoding);
          };
          function allocUnsafe(that, size) {
            assertSize(size);
            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
            if (!Buffer2.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < size; ++i) {
                that[i] = 0;
              }
            }
            return that;
          }
          Buffer2.allocUnsafe = function(size) {
            return allocUnsafe(null, size);
          };
          Buffer2.allocUnsafeSlow = function(size) {
            return allocUnsafe(null, size);
          };
          function fromString(that, string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }
            if (!Buffer2.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding');
            }
            var length = byteLength(string, encoding) | 0;
            that = createBuffer(that, length);
            var actual = that.write(string, encoding);
            if (actual !== length) {
              that = that.slice(0, actual);
            }
            return that;
          }
          function fromArrayLike(that, array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            that = createBuffer(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromArrayBuffer(that, array, byteOffset, length) {
            array.byteLength;
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError("'offset' is out of bounds");
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError("'length' is out of bounds");
            }
            if (byteOffset === void 0 && length === void 0) {
              array = new Uint8Array(array);
            } else if (length === void 0) {
              array = new Uint8Array(array, byteOffset);
            } else {
              array = new Uint8Array(array, byteOffset, length);
            }
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              that = array;
              that.__proto__ = Buffer2.prototype;
            } else {
              that = fromArrayLike(that, array);
            }
            return that;
          }
          function fromObject(that, obj) {
            if (internalIsBuffer(obj)) {
              var len = checked(obj.length) | 0;
              that = createBuffer(that, len);
              if (that.length === 0) {
                return that;
              }
              obj.copy(that, 0, 0, len);
              return that;
            }
            if (obj) {
              if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                if (typeof obj.length !== "number" || isnan(obj.length)) {
                  return createBuffer(that, 0);
                }
                return fromArrayLike(that, obj);
              }
              if (obj.type === "Buffer" && isArray$2(obj.data)) {
                return fromArrayLike(that, obj.data);
              }
            }
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
          }
          function checked(length) {
            if (length >= kMaxLength()) {
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
            }
            return length | 0;
          }
          Buffer2.isBuffer = isBuffer;
          function internalIsBuffer(b) {
            return !!(b != null && b._isBuffer);
          }
          Buffer2.compare = function compare2(a, b) {
            if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
              throw new TypeError("Arguments must be Buffers");
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer2.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          Buffer2.concat = function concat(list, length) {
            if (!isArray$2(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer2.alloc(0);
            }
            var i;
            if (length === void 0) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }
            var buffer = Buffer2.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (!internalIsBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (internalIsBuffer(string)) {
              return string.length;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== "string") {
              string = "" + string;
            }
            var len = string.length;
            if (len === 0)
              return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                case void 0:
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase)
                    return utf8ToBytes(string).length;
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer2.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === void 0 || start < 0) {
              start = 0;
            }
            if (start > this.length) {
              return "";
            }
            if (end === void 0 || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return "";
            }
            if (!encoding)
              encoding = "utf8";
            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer2.prototype._isBuffer = true;
          function swap$1(b, n2, m) {
            var i = b[n2];
            b[n2] = b[m];
            b[m] = i;
          }
          Buffer2.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
              swap$1(this, i, i + 1);
            }
            return this;
          };
          Buffer2.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
              swap$1(this, i, i + 3);
              swap$1(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer2.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
              swap$1(this, i, i + 7);
              swap$1(this, i + 1, i + 6);
              swap$1(this, i + 2, i + 5);
              swap$1(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer2.prototype.toString = function toString2() {
            var length = this.length | 0;
            if (length === 0)
              return "";
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer2.prototype.equals = function equals(b) {
            if (!internalIsBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b)
              return true;
            return Buffer2.compare(this, b) === 0;
          };
          Buffer2.prototype.inspect = function inspect2() {
            var str = "";
            var max = INSPECT_MAX_BYTES;
            if (this.length > 0) {
              str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
              if (this.length > max)
                str += " ... ";
            }
            return "<Buffer " + str + ">";
          };
          Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
            if (!internalIsBuffer(target)) {
              throw new TypeError("Argument must be a Buffer");
            }
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = target ? target.length : 0;
            }
            if (thisStart === void 0) {
              thisStart = 0;
            }
            if (thisEnd === void 0) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target)
              return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0)
              return -1;
            if (typeof byteOffset === "string") {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 2147483647) {
              byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
              byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (isNaN(byteOffset)) {
              byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0)
              byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir)
                return -1;
              else
                byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir)
                byteOffset = 0;
              else
                return -1;
            }
            if (typeof val === "string") {
              val = Buffer2.from(val, encoding);
            }
            if (internalIsBuffer(val)) {
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
              val = val & 255;
              if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== void 0) {
              encoding = String(encoding).toLowerCase();
              if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read2(buf, i2) {
              if (indexSize === 1) {
                return buf[i2];
              } else {
                return buf.readUInt16BE(i2 * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1)
                    i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength)
                byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read2(arr, i + j) !== read2(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found)
                  return i;
              }
            }
            return -1;
          }
          Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (strLen % 2 !== 0)
              throw new TypeError("Invalid hex string");
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed))
                return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer2.prototype.write = function write2(string, offset, length, encoding) {
            if (offset === void 0) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset | 0;
              if (isFinite(length)) {
                length = length | 0;
                if (encoding === void 0)
                  encoding = "utf8";
              } else {
                encoding = length;
                length = void 0;
              }
            } else {
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding)
              encoding = "utf8";
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                  return asciiWrite(this, string, offset, length);
                case "latin1":
                case "binary":
                  return latin1Write(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer2.prototype.toJSON = function toJSON() {
            return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)};
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return fromByteArray(buf);
            } else {
              return fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                      if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = "";
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer2.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf;
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer2.prototype;
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer2(sliceLen, void 0);
              for (var i = 0; i < sliceLen; ++i) {
                newBuf[i] = this[i + start];
              }
            }
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert) {
              checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while (byteLength2 > 0 && (mul *= 256)) {
              val += this[offset + --byteLength2] * mul;
            }
            return val;
          };
          Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var i = byteLength2;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return read(this, offset, true, 23, 4);
          };
          Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return read(this, offset, false, 23, 4);
          };
          Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return read(this, offset, true, 52, 8);
          };
          Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!internalIsBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
          }
          Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer2.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            this[offset] = value & 255;
            return offset + 1;
          };
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
              buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }
          Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
              buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
          }
          Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub2 = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
                sub2 = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub2 & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            var sub2 = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
                sub2 = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub2 & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer2.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
            if (offset < 0)
              throw new RangeError("Index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4);
            }
            write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8);
            }
            write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length)
              throw new RangeError("sourceStart out of bounds");
            if (end < 0)
              throw new RangeError("sourceEnd out of bounds");
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) {
              for (i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
              for (i = 0; i < len; ++i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
            }
            return len;
          };
          Buffer2.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = this.length;
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (code < 256) {
                  val = code;
                }
              }
              if (encoding !== void 0 && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
            } else if (typeof val === "number") {
              val = val & 255;
            }
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError("Out of range index");
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === void 0 ? this.length : end >>> 0;
            if (!val)
              val = 0;
            var i;
            if (typeof val === "number") {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
              var len = bytes.length;
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };
          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, "");
            if (str.length < 2)
              return "";
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }
          function stringtrim(str) {
            if (str.trim)
              return str.trim();
            return str.replace(/^\s+|\s+$/g, "");
          }
          function toHex(n2) {
            if (n2 < 16)
              return "0" + n2.toString(16);
            return n2.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else {
                throw new Error("Invalid code point");
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c2, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0)
                break;
              c2 = str.charCodeAt(i);
              hi = c2 >> 8;
              lo = c2 % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
          function isnan(val) {
            return val !== val;
          }
          function isBuffer(obj) {
            return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
          }
          function isFastBuffer(obj) {
            return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
          }
          function isSlowBuffer(obj) {
            return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
          }
          var inherits;
          if (typeof Object.create === "function") {
            inherits = function inherits2(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {constructor: {value: ctor, enumerable: false, writable: true, configurable: true}});
            };
          } else {
            inherits = function inherits2(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function TempCtor2() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
          var inherits$1 = inherits;
          function inspect$1(obj, opts) {
            var ctx = {seen: [], stylize: stylizeNoColor};
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean2(opts)) {
              ctx.showHidden = opts;
            } else if (opts) {
              _extend(ctx, opts);
            }
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          inspect$1.colors = {"bold": [1, 22], "italic": [3, 23], "underline": [4, 24], "inverse": [7, 27], "white": [37, 39], "grey": [90, 39], "black": [30, 39], "blue": [34, 39], "cyan": [36, 39], "green": [32, 39], "magenta": [35, 39], "red": [31, 39], "yellow": [33, 39]};
          inspect$1.styles = {
            "special": "cyan",
            "number": "yellow",
            "boolean": "yellow",
            "undefined": "grey",
            "null": "bold",
            "string": "green",
            "date": "magenta",
            "regexp": "red"
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect$1.styles[styleType];
            if (style) {
              return "[" + inspect$1.colors[style][0] + "m" + str + "[" + inspect$1.colors[style][1] + "m";
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== inspect$1 && !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }
            if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
              return formatError$1(value);
            }
            if (keys.length === 0) {
              if (isFunction2(value)) {
                var name2 = value.name ? ": " + value.name : "";
                return ctx.stylize("[Function" + name2 + "]", "special");
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), "date");
              }
              if (isError(value)) {
                return formatError$1(value);
              }
            }
            var base = "", array = false, braces = ["{", "}"];
            if (isArray$1(value)) {
              array = true;
              braces = ["[", "]"];
            }
            if (isFunction2(value)) {
              var n2 = value.name ? ": " + value.name : "";
              base = " [Function" + n2 + "]";
            }
            if (isRegExp(value)) {
              base = " " + RegExp.prototype.toString.call(value);
            }
            if (isDate(value)) {
              base = " " + Date.prototype.toUTCString.call(value);
            }
            if (isError(value)) {
              base = " " + formatError$1(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              } else {
                return ctx.stylize("[Object]", "special");
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize("undefined", "undefined");
            if (isString(value)) {
              var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return ctx.stylize(simple, "string");
            }
            if (isNumber$1(value))
              return ctx.stylize("" + value, "number");
            if (isBoolean2(value))
              return ctx.stylize("" + value, "boolean");
            if (isNull(value))
              return ctx.stylize("null", "null");
          }
          function formatError$1(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty$1(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push("");
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name2, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize("[Getter/Setter]", "special");
              } else {
                str = ctx.stylize("[Getter]", "special");
              }
            } else {
              if (desc.set) {
                str = ctx.stylize("[Setter]", "special");
              }
            }
            if (!hasOwnProperty$1(visibleKeys, key)) {
              name2 = "[" + key + "]";
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf("\n") > -1) {
                  if (array) {
                    str = str.split("\n").map(function(line) {
                      return "  " + line;
                    }).join("\n").substr(2);
                  } else {
                    str = "\n" + str.split("\n").map(function(line) {
                      return "   " + line;
                    }).join("\n");
                  }
                }
              } else {
                str = ctx.stylize("[Circular]", "special");
              }
            }
            if (isUndefined(name2)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name2 = JSON.stringify("" + key);
              if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name2 = name2.substr(1, name2.length - 2);
                name2 = ctx.stylize(name2, "name");
              } else {
                name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name2 = ctx.stylize(name2, "string");
              }
            }
            return name2 + ": " + str;
          }
          function reduceToSingleString(output, base, braces) {
            var length = output.reduce(function(prev, cur) {
              if (cur.indexOf("\n") >= 0)
                ;
              return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            if (length > 60) {
              return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
            }
            return braces[0] + base + " " + output.join(", ") + " " + braces[1];
          }
          function isArray$1(ar) {
            return Array.isArray(ar);
          }
          function isBoolean2(arg) {
            return typeof arg === "boolean";
          }
          function isNull(arg) {
            return arg === null;
          }
          function isNumber$1(arg) {
            return typeof arg === "number";
          }
          function isString(arg) {
            return typeof arg === "string";
          }
          function isUndefined(arg) {
            return arg === void 0;
          }
          function isRegExp(re) {
            return isObject$1(re) && objectToString(re) === "[object RegExp]";
          }
          function isObject$1(arg) {
            return typeof arg === "object" && arg !== null;
          }
          function isDate(d) {
            return isObject$1(d) && objectToString(d) === "[object Date]";
          }
          function isError(e) {
            return isObject$1(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
          }
          function isFunction2(arg) {
            return typeof arg === "function";
          }
          function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
          }
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function _extend(origin, add) {
            if (!add || !isObject$1(add))
              return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          }
          function hasOwnProperty$1(obj, prop2) {
            return Object.prototype.hasOwnProperty.call(obj, prop2);
          }
          function compare(a, b) {
            if (a === b) {
              return 0;
            }
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y) {
              return -1;
            }
            if (y < x) {
              return 1;
            }
            return 0;
          }
          var hasOwn = Object.prototype.hasOwnProperty;
          var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj) {
              if (hasOwn.call(obj, key))
                keys.push(key);
            }
            return keys;
          };
          var pSlice = Array.prototype.slice;
          var _functionsHaveNames;
          function functionsHaveNames() {
            if (typeof _functionsHaveNames !== "undefined") {
              return _functionsHaveNames;
            }
            return _functionsHaveNames = function() {
              return function foo() {
              }.name === "foo";
            }();
          }
          function pToString(obj) {
            return Object.prototype.toString.call(obj);
          }
          function isView(arrbuf) {
            if (isBuffer(arrbuf)) {
              return false;
            }
            if (typeof global2.ArrayBuffer !== "function") {
              return false;
            }
            if (typeof ArrayBuffer.isView === "function") {
              return ArrayBuffer.isView(arrbuf);
            }
            if (!arrbuf) {
              return false;
            }
            if (arrbuf instanceof DataView) {
              return true;
            }
            if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
              return true;
            }
            return false;
          }
          function assert$1(value, message) {
            if (!value)
              fail(value, true, message, "==", ok);
          }
          var regex = /\s*function\s+([^\(\s]*)\s*/;
          function getName$1(func) {
            if (!isFunction2(func)) {
              return;
            }
            if (functionsHaveNames()) {
              return func.name;
            }
            var str = func.toString();
            var match = str.match(regex);
            return match && match[1];
          }
          assert$1.AssertionError = AssertionError;
          function AssertionError(options2) {
            this.name = "AssertionError";
            this.actual = options2.actual;
            this.expected = options2.expected;
            this.operator = options2.operator;
            if (options2.message) {
              this.message = options2.message;
              this.generatedMessage = false;
            } else {
              this.message = getMessage(this);
              this.generatedMessage = true;
            }
            var stackStartFunction = options2.stackStartFunction || fail;
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, stackStartFunction);
            } else {
              var err = new Error();
              if (err.stack) {
                var out = err.stack;
                var fn_name = getName$1(stackStartFunction);
                var idx = out.indexOf("\n" + fn_name);
                if (idx >= 0) {
                  var next_line = out.indexOf("\n", idx + 1);
                  out = out.substring(next_line + 1);
                }
                this.stack = out;
              }
            }
          }
          inherits$1(AssertionError, Error);
          function truncate(s, n2) {
            if (typeof s === "string") {
              return s.length < n2 ? s : s.slice(0, n2);
            } else {
              return s;
            }
          }
          function inspect(something) {
            if (functionsHaveNames() || !isFunction2(something)) {
              return inspect$1(something);
            }
            var rawname = getName$1(something);
            var name2 = rawname ? ": " + rawname : "";
            return "[Function" + name2 + "]";
          }
          function getMessage(self2) {
            return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
          }
          function fail(actual, expected, message, operator, stackStartFunction) {
            throw new AssertionError({message, actual, expected, operator, stackStartFunction});
          }
          assert$1.fail = fail;
          function ok(value, message) {
            if (!value)
              fail(value, true, message, "==", ok);
          }
          assert$1.ok = ok;
          assert$1.equal = equal;
          function equal(actual, expected, message) {
            if (actual != expected)
              fail(actual, expected, message, "==", equal);
          }
          assert$1.notEqual = notEqual;
          function notEqual(actual, expected, message) {
            if (actual == expected) {
              fail(actual, expected, message, "!=", notEqual);
            }
          }
          assert$1.deepEqual = deepEqual;
          function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, "deepEqual", deepEqual);
            }
          }
          assert$1.deepStrictEqual = deepStrictEqual;
          function deepStrictEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
            }
          }
          function _deepEqual(actual, expected, strict, memos) {
            if (actual === expected) {
              return true;
            } else if (isBuffer(actual) && isBuffer(expected)) {
              return compare(actual, expected) === 0;
            } else if (isDate(actual) && isDate(expected)) {
              return actual.getTime() === expected.getTime();
            } else if (isRegExp(actual) && isRegExp(expected)) {
              return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
            } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
              return strict ? actual === expected : actual == expected;
            } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
              return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
            } else if (isBuffer(actual) !== isBuffer(expected)) {
              return false;
            } else {
              memos = memos || {actual: [], expected: []};
              var actualIndex = memos.actual.indexOf(actual);
              if (actualIndex !== -1) {
                if (actualIndex === memos.expected.indexOf(expected)) {
                  return true;
                }
              }
              memos.actual.push(actual);
              memos.expected.push(expected);
              return objEquiv(actual, expected, strict, memos);
            }
          }
          function isArguments(object2) {
            return Object.prototype.toString.call(object2) == "[object Arguments]";
          }
          function objEquiv(a, b, strict, actualVisitedObjects) {
            if (a === null || a === void 0 || b === null || b === void 0)
              return false;
            if (isPrimitive(a) || isPrimitive(b))
              return a === b;
            if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
              return false;
            var aIsArgs = isArguments(a);
            var bIsArgs = isArguments(b);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
              return false;
            if (aIsArgs) {
              a = pSlice.call(a);
              b = pSlice.call(b);
              return _deepEqual(a, b, strict);
            }
            var ka = objectKeys(a);
            var kb = objectKeys(b);
            var key, i;
            if (ka.length !== kb.length)
              return false;
            ka.sort();
            kb.sort();
            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] !== kb[i])
                return false;
            }
            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
                return false;
            }
            return true;
          }
          assert$1.notDeepEqual = notDeepEqual;
          function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, "notDeepEqual", notDeepEqual);
            }
          }
          assert$1.notDeepStrictEqual = notDeepStrictEqual;
          function notDeepStrictEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
            }
          }
          assert$1.strictEqual = strictEqual;
          function strictEqual(actual, expected, message) {
            if (actual !== expected) {
              fail(actual, expected, message, "===", strictEqual);
            }
          }
          assert$1.notStrictEqual = notStrictEqual;
          function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
              fail(actual, expected, message, "!==", notStrictEqual);
            }
          }
          function expectedException(actual, expected) {
            if (!actual || !expected) {
              return false;
            }
            if (Object.prototype.toString.call(expected) == "[object RegExp]") {
              return expected.test(actual);
            }
            try {
              if (actual instanceof expected) {
                return true;
              }
            } catch (e) {
            }
            if (Error.isPrototypeOf(expected)) {
              return false;
            }
            return expected.call({}, actual) === true;
          }
          function _tryBlock(block) {
            var error;
            try {
              block();
            } catch (e) {
              error = e;
            }
            return error;
          }
          function _throws(shouldThrow, block, expected, message) {
            var actual;
            if (typeof block !== "function") {
              throw new TypeError('"block" argument must be a function');
            }
            if (typeof expected === "string") {
              message = expected;
              expected = null;
            }
            actual = _tryBlock(block);
            message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
            if (shouldThrow && !actual) {
              fail(actual, expected, "Missing expected exception" + message);
            }
            var userProvidedMessage = typeof message === "string";
            var isUnwantedException = !shouldThrow && isError(actual);
            var isUnexpectedException = !shouldThrow && actual && !expected;
            if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
              fail(actual, expected, "Got unwanted exception" + message);
            }
            if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
              throw actual;
            }
          }
          assert$1.throws = throws;
          function throws(block, error, message) {
            _throws(true, block, error, message);
          }
          assert$1.doesNotThrow = doesNotThrow;
          function doesNotThrow(block, error, message) {
            _throws(false, block, error, message);
          }
          assert$1.ifError = ifError;
          function ifError(err) {
            if (err)
              throw err;
          }
          var assert$2 = /* @__PURE__ */ Object.freeze({__proto__: null, "default": assert$1, AssertionError, fail, ok, assert: ok, equal, notEqual, deepEqual, deepStrictEqual, notDeepEqual, notDeepStrictEqual, strictEqual, notStrictEqual, throws, doesNotThrow, ifError});
          var intToCharMap$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
          var encode$3 = function encode$32(number) {
            if (0 <= number && number < intToCharMap$1.length) {
              return intToCharMap$1[number];
            }
            throw new TypeError("Must be between 0 and 63: " + number);
          };
          var decode$1 = function decode$12(charCode) {
            var bigA = 65;
            var bigZ = 90;
            var littleA = 97;
            var littleZ = 122;
            var zero = 48;
            var nine = 57;
            var plus = 43;
            var slash = 47;
            var littleOffset = 26;
            var numberOffset = 52;
            if (bigA <= charCode && charCode <= bigZ) {
              return charCode - bigA;
            }
            if (littleA <= charCode && charCode <= littleZ) {
              return charCode - littleA + littleOffset;
            }
            if (zero <= charCode && charCode <= nine) {
              return charCode - zero + numberOffset;
            }
            if (charCode == plus) {
              return 62;
            }
            if (charCode == slash) {
              return 63;
            }
            return -1;
          };
          var base64$1 = {encode: encode$3, decode: decode$1};
          var VLQ_BASE_SHIFT$1 = 5;
          var VLQ_BASE$1 = 1 << VLQ_BASE_SHIFT$1;
          var VLQ_BASE_MASK$1 = VLQ_BASE$1 - 1;
          var VLQ_CONTINUATION_BIT$1 = VLQ_BASE$1;
          function toVLQSigned$1(aValue) {
            return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
          }
          function fromVLQSigned(aValue) {
            var isNegative = (aValue & 1) === 1;
            var shifted = aValue >> 1;
            return isNegative ? -shifted : shifted;
          }
          var encode$2 = function base64VLQ_encode(aValue) {
            var encoded = "";
            var digit;
            var vlq = toVLQSigned$1(aValue);
            do {
              digit = vlq & VLQ_BASE_MASK$1;
              vlq >>>= VLQ_BASE_SHIFT$1;
              if (vlq > 0) {
                digit |= VLQ_CONTINUATION_BIT$1;
              }
              encoded += base64$1.encode(digit);
            } while (vlq > 0);
            return encoded;
          };
          var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
            var strLen = aStr.length;
            var result = 0;
            var shift = 0;
            var continuation, digit;
            do {
              if (aIndex >= strLen) {
                throw new Error("Expected more digits in base 64 VLQ value.");
              }
              digit = base64$1.decode(aStr.charCodeAt(aIndex++));
              if (digit === -1) {
                throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
              }
              continuation = !!(digit & VLQ_CONTINUATION_BIT$1);
              digit &= VLQ_BASE_MASK$1;
              result = result + (digit << shift);
              shift += VLQ_BASE_SHIFT$1;
            } while (continuation);
            aOutParam.value = fromVLQSigned(result);
            aOutParam.rest = aIndex;
          };
          var base64Vlq$1 = {encode: encode$2, decode};
          var util$3 = createCommonjsModule(function(module3, exports4) {
            function getArg(aArgs, aName, aDefaultValue) {
              if (aName in aArgs) {
                return aArgs[aName];
              } else if (arguments.length === 3) {
                return aDefaultValue;
              } else {
                throw new Error('"' + aName + '" is a required argument.');
              }
            }
            exports4.getArg = getArg;
            var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
            var dataUrlRegexp = /^data:.+\,.+$/;
            function urlParse(aUrl) {
              var match = aUrl.match(urlRegexp);
              if (!match) {
                return null;
              }
              return {scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5]};
            }
            exports4.urlParse = urlParse;
            function urlGenerate(aParsedUrl) {
              var url = "";
              if (aParsedUrl.scheme) {
                url += aParsedUrl.scheme + ":";
              }
              url += "//";
              if (aParsedUrl.auth) {
                url += aParsedUrl.auth + "@";
              }
              if (aParsedUrl.host) {
                url += aParsedUrl.host;
              }
              if (aParsedUrl.port) {
                url += ":" + aParsedUrl.port;
              }
              if (aParsedUrl.path) {
                url += aParsedUrl.path;
              }
              return url;
            }
            exports4.urlGenerate = urlGenerate;
            function normalize3(aPath) {
              var path2 = aPath;
              var url = urlParse(aPath);
              if (url) {
                if (!url.path) {
                  return aPath;
                }
                path2 = url.path;
              }
              var isAbsolute = exports4.isAbsolute(path2);
              var parts = path2.split(/\/+/);
              for (var part2, up = 0, i = parts.length - 1; i >= 0; i--) {
                part2 = parts[i];
                if (part2 === ".") {
                  parts.splice(i, 1);
                } else if (part2 === "..") {
                  up++;
                } else if (up > 0) {
                  if (part2 === "") {
                    parts.splice(i + 1, up);
                    up = 0;
                  } else {
                    parts.splice(i, 2);
                    up--;
                  }
                }
              }
              path2 = parts.join("/");
              if (path2 === "") {
                path2 = isAbsolute ? "/" : ".";
              }
              if (url) {
                url.path = path2;
                return urlGenerate(url);
              }
              return path2;
            }
            exports4.normalize = normalize3;
            function join(aRoot, aPath) {
              if (aRoot === "") {
                aRoot = ".";
              }
              if (aPath === "") {
                aPath = ".";
              }
              var aPathUrl = urlParse(aPath);
              var aRootUrl = urlParse(aRoot);
              if (aRootUrl) {
                aRoot = aRootUrl.path || "/";
              }
              if (aPathUrl && !aPathUrl.scheme) {
                if (aRootUrl) {
                  aPathUrl.scheme = aRootUrl.scheme;
                }
                return urlGenerate(aPathUrl);
              }
              if (aPathUrl || aPath.match(dataUrlRegexp)) {
                return aPath;
              }
              if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                aRootUrl.host = aPath;
                return urlGenerate(aRootUrl);
              }
              var joined = aPath.charAt(0) === "/" ? aPath : normalize3(aRoot.replace(/\/+$/, "") + "/" + aPath);
              if (aRootUrl) {
                aRootUrl.path = joined;
                return urlGenerate(aRootUrl);
              }
              return joined;
            }
            exports4.join = join;
            exports4.isAbsolute = function(aPath) {
              return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
            };
            function relative(aRoot, aPath) {
              if (aRoot === "") {
                aRoot = ".";
              }
              aRoot = aRoot.replace(/\/$/, "");
              var level = 0;
              while (aPath.indexOf(aRoot + "/") !== 0) {
                var index = aRoot.lastIndexOf("/");
                if (index < 0) {
                  return aPath;
                }
                aRoot = aRoot.slice(0, index);
                if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                  return aPath;
                }
                ++level;
              }
              return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
            }
            exports4.relative = relative;
            var supportsNullProto = function() {
              var obj = Object.create(null);
              return !("__proto__" in obj);
            }();
            function identity(s) {
              return s;
            }
            function toSetString(aStr) {
              if (isProtoString(aStr)) {
                return "$" + aStr;
              }
              return aStr;
            }
            exports4.toSetString = supportsNullProto ? identity : toSetString;
            function fromSetString(aStr) {
              if (isProtoString(aStr)) {
                return aStr.slice(1);
              }
              return aStr;
            }
            exports4.fromSetString = supportsNullProto ? identity : fromSetString;
            function isProtoString(s) {
              if (!s) {
                return false;
              }
              var length = s.length;
              if (length < 9) {
                return false;
              }
              if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
                return false;
              }
              for (var i = length - 10; i >= 0; i--) {
                if (s.charCodeAt(i) !== 36) {
                  return false;
                }
              }
              return true;
            }
            function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
              var cmp = strcmp(mappingA.source, mappingB.source);
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0 || onlyCompareOriginal) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              return strcmp(mappingA.name, mappingB.name);
            }
            exports4.compareByOriginalPositions = compareByOriginalPositions;
            function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
              var cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0 || onlyCompareGenerated) {
                return cmp;
              }
              cmp = strcmp(mappingA.source, mappingB.source);
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0) {
                return cmp;
              }
              return strcmp(mappingA.name, mappingB.name);
            }
            exports4.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
            function strcmp(aStr1, aStr2) {
              if (aStr1 === aStr2) {
                return 0;
              }
              if (aStr1 === null) {
                return 1;
              }
              if (aStr2 === null) {
                return -1;
              }
              if (aStr1 > aStr2) {
                return 1;
              }
              return -1;
            }
            function compareByGeneratedPositionsInflated(mappingA, mappingB) {
              var cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = strcmp(mappingA.source, mappingB.source);
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0) {
                return cmp;
              }
              return strcmp(mappingA.name, mappingB.name);
            }
            exports4.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
            function parseSourceMapInput(str) {
              return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
            }
            exports4.parseSourceMapInput = parseSourceMapInput;
            function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
              sourceURL = sourceURL || "";
              if (sourceRoot) {
                if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
                  sourceRoot += "/";
                }
                sourceURL = sourceRoot + sourceURL;
              }
              if (sourceMapURL) {
                var parsed = urlParse(sourceMapURL);
                if (!parsed) {
                  throw new Error("sourceMapURL could not be parsed");
                }
                if (parsed.path) {
                  var index = parsed.path.lastIndexOf("/");
                  if (index >= 0) {
                    parsed.path = parsed.path.substring(0, index + 1);
                  }
                }
                sourceURL = join(urlGenerate(parsed), sourceURL);
              }
              return normalize3(sourceURL);
            }
            exports4.computeSourceURL = computeSourceURL;
          });
          var has = Object.prototype.hasOwnProperty;
          var hasNativeMap = typeof Map !== "undefined";
          function ArraySet$4() {
            this._array = [];
            this._set = hasNativeMap ? new Map() : Object.create(null);
          }
          ArraySet$4.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
            var set2 = new ArraySet$4();
            for (var i = 0, len = aArray.length; i < len; i++) {
              set2.add(aArray[i], aAllowDuplicates);
            }
            return set2;
          };
          ArraySet$4.prototype.size = function ArraySet_size() {
            return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
          };
          ArraySet$4.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
            var sStr = hasNativeMap ? aStr : util$3.toSetString(aStr);
            var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
            var idx = this._array.length;
            if (!isDuplicate || aAllowDuplicates) {
              this._array.push(aStr);
            }
            if (!isDuplicate) {
              if (hasNativeMap) {
                this._set.set(aStr, idx);
              } else {
                this._set[sStr] = idx;
              }
            }
          };
          ArraySet$4.prototype.has = function ArraySet_has(aStr) {
            if (hasNativeMap) {
              return this._set.has(aStr);
            } else {
              var sStr = util$3.toSetString(aStr);
              return has.call(this._set, sStr);
            }
          };
          ArraySet$4.prototype.indexOf = function ArraySet_indexOf(aStr) {
            if (hasNativeMap) {
              var idx = this._set.get(aStr);
              if (idx >= 0) {
                return idx;
              }
            } else {
              var sStr = util$3.toSetString(aStr);
              if (has.call(this._set, sStr)) {
                return this._set[sStr];
              }
            }
            throw new Error('"' + aStr + '" is not in the set.');
          };
          ArraySet$4.prototype.at = function ArraySet_at(aIdx) {
            if (aIdx >= 0 && aIdx < this._array.length) {
              return this._array[aIdx];
            }
            throw new Error("No element indexed by " + aIdx);
          };
          ArraySet$4.prototype.toArray = function ArraySet_toArray() {
            return this._array.slice();
          };
          var ArraySet_1$1 = ArraySet$4;
          var arraySet$1 = {ArraySet: ArraySet_1$1};
          function generatedPositionAfter$1(mappingA, mappingB) {
            var lineA = mappingA.generatedLine;
            var lineB = mappingB.generatedLine;
            var columnA = mappingA.generatedColumn;
            var columnB = mappingB.generatedColumn;
            return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
          }
          function MappingList$3() {
            this._array = [];
            this._sorted = true;
            this._last = {generatedLine: -1, generatedColumn: 0};
          }
          MappingList$3.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
            this._array.forEach(aCallback, aThisArg);
          };
          MappingList$3.prototype.add = function MappingList_add(aMapping) {
            if (generatedPositionAfter$1(this._last, aMapping)) {
              this._last = aMapping;
              this._array.push(aMapping);
            } else {
              this._sorted = false;
              this._array.push(aMapping);
            }
          };
          MappingList$3.prototype.toArray = function MappingList_toArray() {
            if (!this._sorted) {
              this._array.sort(util$3.compareByGeneratedPositionsInflated);
              this._sorted = true;
            }
            return this._array;
          };
          var MappingList_1$1 = MappingList$3;
          var mappingList$1 = {MappingList: MappingList_1$1};
          var ArraySet$3 = arraySet$1.ArraySet;
          var MappingList$2 = mappingList$1.MappingList;
          function SourceMapGenerator$4(aArgs) {
            if (!aArgs) {
              aArgs = {};
            }
            this._file = util$3.getArg(aArgs, "file", null);
            this._sourceRoot = util$3.getArg(aArgs, "sourceRoot", null);
            this._skipValidation = util$3.getArg(aArgs, "skipValidation", false);
            this._sources = new ArraySet$3();
            this._names = new ArraySet$3();
            this._mappings = new MappingList$2();
            this._sourcesContents = null;
          }
          SourceMapGenerator$4.prototype._version = 3;
          SourceMapGenerator$4.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
            var sourceRoot = aSourceMapConsumer.sourceRoot;
            var generator = new SourceMapGenerator$4({file: aSourceMapConsumer.file, sourceRoot});
            aSourceMapConsumer.eachMapping(function(mapping2) {
              var newMapping = {generated: {line: mapping2.generatedLine, column: mapping2.generatedColumn}};
              if (mapping2.source != null) {
                newMapping.source = mapping2.source;
                if (sourceRoot != null) {
                  newMapping.source = util$3.relative(sourceRoot, newMapping.source);
                }
                newMapping.original = {line: mapping2.originalLine, column: mapping2.originalColumn};
                if (mapping2.name != null) {
                  newMapping.name = mapping2.name;
                }
              }
              generator.addMapping(newMapping);
            });
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var sourceRelative = sourceFile;
              if (sourceRoot !== null) {
                sourceRelative = util$3.relative(sourceRoot, sourceFile);
              }
              if (!generator._sources.has(sourceRelative)) {
                generator._sources.add(sourceRelative);
              }
              var content = aSourceMapConsumer.sourceContentFor(sourceFile);
              if (content != null) {
                generator.setSourceContent(sourceFile, content);
              }
            });
            return generator;
          };
          SourceMapGenerator$4.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
            var generated = util$3.getArg(aArgs, "generated");
            var original = util$3.getArg(aArgs, "original", null);
            var source = util$3.getArg(aArgs, "source", null);
            var name2 = util$3.getArg(aArgs, "name", null);
            if (!this._skipValidation) {
              this._validateMapping(generated, original, source, name2);
            }
            if (source != null) {
              source = String(source);
              if (!this._sources.has(source)) {
                this._sources.add(source);
              }
            }
            if (name2 != null) {
              name2 = String(name2);
              if (!this._names.has(name2)) {
                this._names.add(name2);
              }
            }
            this._mappings.add({generatedLine: generated.line, generatedColumn: generated.column, originalLine: original != null && original.line, originalColumn: original != null && original.column, source, name: name2});
          };
          SourceMapGenerator$4.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
            var source = aSourceFile;
            if (this._sourceRoot != null) {
              source = util$3.relative(this._sourceRoot, source);
            }
            if (aSourceContent != null) {
              if (!this._sourcesContents) {
                this._sourcesContents = Object.create(null);
              }
              this._sourcesContents[util$3.toSetString(source)] = aSourceContent;
            } else if (this._sourcesContents) {
              delete this._sourcesContents[util$3.toSetString(source)];
              if (Object.keys(this._sourcesContents).length === 0) {
                this._sourcesContents = null;
              }
            }
          };
          SourceMapGenerator$4.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
            var sourceFile = aSourceFile;
            if (aSourceFile == null) {
              if (aSourceMapConsumer.file == null) {
                throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
              }
              sourceFile = aSourceMapConsumer.file;
            }
            var sourceRoot = this._sourceRoot;
            if (sourceRoot != null) {
              sourceFile = util$3.relative(sourceRoot, sourceFile);
            }
            var newSources = new ArraySet$3();
            var newNames = new ArraySet$3();
            this._mappings.unsortedForEach(function(mapping2) {
              if (mapping2.source === sourceFile && mapping2.originalLine != null) {
                var original = aSourceMapConsumer.originalPositionFor({line: mapping2.originalLine, column: mapping2.originalColumn});
                if (original.source != null) {
                  mapping2.source = original.source;
                  if (aSourceMapPath != null) {
                    mapping2.source = util$3.join(aSourceMapPath, mapping2.source);
                  }
                  if (sourceRoot != null) {
                    mapping2.source = util$3.relative(sourceRoot, mapping2.source);
                  }
                  mapping2.originalLine = original.line;
                  mapping2.originalColumn = original.column;
                  if (original.name != null) {
                    mapping2.name = original.name;
                  }
                }
              }
              var source = mapping2.source;
              if (source != null && !newSources.has(source)) {
                newSources.add(source);
              }
              var name2 = mapping2.name;
              if (name2 != null && !newNames.has(name2)) {
                newNames.add(name2);
              }
            }, this);
            this._sources = newSources;
            this._names = newNames;
            aSourceMapConsumer.sources.forEach(function(sourceFile2) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
              if (content != null) {
                if (aSourceMapPath != null) {
                  sourceFile2 = util$3.join(aSourceMapPath, sourceFile2);
                }
                if (sourceRoot != null) {
                  sourceFile2 = util$3.relative(sourceRoot, sourceFile2);
                }
                this.setSourceContent(sourceFile2, content);
              }
            }, this);
          };
          SourceMapGenerator$4.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
            if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
              throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
            }
            if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
              return;
            } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
              return;
            } else {
              throw new Error("Invalid mapping: " + JSON.stringify({generated: aGenerated, source: aSource, original: aOriginal, name: aName}));
            }
          };
          SourceMapGenerator$4.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
            var previousGeneratedColumn = 0;
            var previousGeneratedLine = 1;
            var previousOriginalColumn = 0;
            var previousOriginalLine = 0;
            var previousName = 0;
            var previousSource = 0;
            var result = "";
            var next;
            var mapping2;
            var nameIdx;
            var sourceIdx;
            var mappings = this._mappings.toArray();
            for (var i = 0, len = mappings.length; i < len; i++) {
              mapping2 = mappings[i];
              next = "";
              if (mapping2.generatedLine !== previousGeneratedLine) {
                previousGeneratedColumn = 0;
                while (mapping2.generatedLine !== previousGeneratedLine) {
                  next += ";";
                  previousGeneratedLine++;
                }
              } else {
                if (i > 0) {
                  if (!util$3.compareByGeneratedPositionsInflated(mapping2, mappings[i - 1])) {
                    continue;
                  }
                  next += ",";
                }
              }
              next += base64Vlq$1.encode(mapping2.generatedColumn - previousGeneratedColumn);
              previousGeneratedColumn = mapping2.generatedColumn;
              if (mapping2.source != null) {
                sourceIdx = this._sources.indexOf(mapping2.source);
                next += base64Vlq$1.encode(sourceIdx - previousSource);
                previousSource = sourceIdx;
                next += base64Vlq$1.encode(mapping2.originalLine - 1 - previousOriginalLine);
                previousOriginalLine = mapping2.originalLine - 1;
                next += base64Vlq$1.encode(mapping2.originalColumn - previousOriginalColumn);
                previousOriginalColumn = mapping2.originalColumn;
                if (mapping2.name != null) {
                  nameIdx = this._names.indexOf(mapping2.name);
                  next += base64Vlq$1.encode(nameIdx - previousName);
                  previousName = nameIdx;
                }
              }
              result += next;
            }
            return result;
          };
          SourceMapGenerator$4.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
            return aSources.map(function(source) {
              if (!this._sourcesContents) {
                return null;
              }
              if (aSourceRoot != null) {
                source = util$3.relative(aSourceRoot, source);
              }
              var key = util$3.toSetString(source);
              return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
            }, this);
          };
          SourceMapGenerator$4.prototype.toJSON = function SourceMapGenerator_toJSON() {
            var map = {version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings()};
            if (this._file != null) {
              map.file = this._file;
            }
            if (this._sourceRoot != null) {
              map.sourceRoot = this._sourceRoot;
            }
            if (this._sourcesContents) {
              map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
            }
            return map;
          };
          SourceMapGenerator$4.prototype.toString = function SourceMapGenerator_toString() {
            return JSON.stringify(this.toJSON());
          };
          var SourceMapGenerator_1$1 = SourceMapGenerator$4;
          var sourceMapGenerator$1 = {SourceMapGenerator: SourceMapGenerator_1$1};
          var binarySearch = createCommonjsModule(function(module3, exports4) {
            exports4.GREATEST_LOWER_BOUND = 1;
            exports4.LEAST_UPPER_BOUND = 2;
            function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
              var mid = Math.floor((aHigh - aLow) / 2) + aLow;
              var cmp = aCompare(aNeedle, aHaystack[mid], true);
              if (cmp === 0) {
                return mid;
              } else if (cmp > 0) {
                if (aHigh - mid > 1) {
                  return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
                }
                if (aBias == exports4.LEAST_UPPER_BOUND) {
                  return aHigh < aHaystack.length ? aHigh : -1;
                } else {
                  return mid;
                }
              } else {
                if (mid - aLow > 1) {
                  return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
                }
                if (aBias == exports4.LEAST_UPPER_BOUND) {
                  return mid;
                } else {
                  return aLow < 0 ? -1 : aLow;
                }
              }
            }
            exports4.search = function search(aNeedle, aHaystack, aCompare, aBias) {
              if (aHaystack.length === 0) {
                return -1;
              }
              var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports4.GREATEST_LOWER_BOUND);
              if (index < 0) {
                return -1;
              }
              while (index - 1 >= 0) {
                if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                  break;
                }
                --index;
              }
              return index;
            };
          });
          function swap(ary, x, y) {
            var temp = ary[x];
            ary[x] = ary[y];
            ary[y] = temp;
          }
          function randomIntInRange(low, high) {
            return Math.round(low + Math.random() * (high - low));
          }
          function doQuickSort(ary, comparator, p, r) {
            if (p < r) {
              var pivotIndex = randomIntInRange(p, r);
              var i = p - 1;
              swap(ary, pivotIndex, r);
              var pivot = ary[r];
              for (var j = p; j < r; j++) {
                if (comparator(ary[j], pivot) <= 0) {
                  i += 1;
                  swap(ary, i, j);
                }
              }
              swap(ary, i + 1, j);
              var q = i + 1;
              doQuickSort(ary, comparator, p, q - 1);
              doQuickSort(ary, comparator, q + 1, r);
            }
          }
          var quickSort_1 = function quickSort_12(ary, comparator) {
            doQuickSort(ary, comparator, 0, ary.length - 1);
          };
          var quickSort$1 = {quickSort: quickSort_1};
          var ArraySet$2 = arraySet$1.ArraySet;
          var quickSort = quickSort$1.quickSort;
          function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
            var sourceMap2 = aSourceMap;
            if (typeof aSourceMap === "string") {
              sourceMap2 = util$3.parseSourceMapInput(aSourceMap);
            }
            return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
          }
          SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
            return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
          };
          SourceMapConsumer$1.prototype._version = 3;
          SourceMapConsumer$1.prototype.__generatedMappings = null;
          Object.defineProperty(SourceMapConsumer$1.prototype, "_generatedMappings", {configurable: true, enumerable: true, get: function get2() {
            if (!this.__generatedMappings) {
              this._parseMappings(this._mappings, this.sourceRoot);
            }
            return this.__generatedMappings;
          }});
          SourceMapConsumer$1.prototype.__originalMappings = null;
          Object.defineProperty(SourceMapConsumer$1.prototype, "_originalMappings", {configurable: true, enumerable: true, get: function get2() {
            if (!this.__originalMappings) {
              this._parseMappings(this._mappings, this.sourceRoot);
            }
            return this.__originalMappings;
          }});
          SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
            var c2 = aStr.charAt(index);
            return c2 === ";" || c2 === ",";
          };
          SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            throw new Error("Subclasses must implement _parseMappings");
          };
          SourceMapConsumer$1.GENERATED_ORDER = 1;
          SourceMapConsumer$1.ORIGINAL_ORDER = 2;
          SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
          SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;
          SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
            var context = aContext || null;
            var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
            var mappings;
            switch (order) {
              case SourceMapConsumer$1.GENERATED_ORDER:
                mappings = this._generatedMappings;
                break;
              case SourceMapConsumer$1.ORIGINAL_ORDER:
                mappings = this._originalMappings;
                break;
              default:
                throw new Error("Unknown order of iteration.");
            }
            var sourceRoot = this.sourceRoot;
            mappings.map(function(mapping2) {
              var source = mapping2.source === null ? null : this._sources.at(mapping2.source);
              source = util$3.computeSourceURL(sourceRoot, source, this._sourceMapURL);
              return {source, generatedLine: mapping2.generatedLine, generatedColumn: mapping2.generatedColumn, originalLine: mapping2.originalLine, originalColumn: mapping2.originalColumn, name: mapping2.name === null ? null : this._names.at(mapping2.name)};
            }, this).forEach(aCallback, context);
          };
          SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
            var line = util$3.getArg(aArgs, "line");
            var needle = {source: util$3.getArg(aArgs, "source"), originalLine: line, originalColumn: util$3.getArg(aArgs, "column", 0)};
            needle.source = this._findSourceIndex(needle.source);
            if (needle.source < 0) {
              return [];
            }
            var mappings = [];
            var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$3.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
            if (index >= 0) {
              var mapping2 = this._originalMappings[index];
              if (aArgs.column === void 0) {
                var originalLine = mapping2.originalLine;
                while (mapping2 && mapping2.originalLine === originalLine) {
                  mappings.push({line: util$3.getArg(mapping2, "generatedLine", null), column: util$3.getArg(mapping2, "generatedColumn", null), lastColumn: util$3.getArg(mapping2, "lastGeneratedColumn", null)});
                  mapping2 = this._originalMappings[++index];
                }
              } else {
                var originalColumn = mapping2.originalColumn;
                while (mapping2 && mapping2.originalLine === line && mapping2.originalColumn == originalColumn) {
                  mappings.push({line: util$3.getArg(mapping2, "generatedLine", null), column: util$3.getArg(mapping2, "generatedColumn", null), lastColumn: util$3.getArg(mapping2, "lastGeneratedColumn", null)});
                  mapping2 = this._originalMappings[++index];
                }
              }
            }
            return mappings;
          };
          var SourceMapConsumer_1 = SourceMapConsumer$1;
          function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap2 = aSourceMap;
            if (typeof aSourceMap === "string") {
              sourceMap2 = util$3.parseSourceMapInput(aSourceMap);
            }
            var version2 = util$3.getArg(sourceMap2, "version");
            var sources = util$3.getArg(sourceMap2, "sources");
            var names = util$3.getArg(sourceMap2, "names", []);
            var sourceRoot = util$3.getArg(sourceMap2, "sourceRoot", null);
            var sourcesContent = util$3.getArg(sourceMap2, "sourcesContent", null);
            var mappings = util$3.getArg(sourceMap2, "mappings");
            var file = util$3.getArg(sourceMap2, "file", null);
            if (version2 != this._version) {
              throw new Error("Unsupported version: " + version2);
            }
            if (sourceRoot) {
              sourceRoot = util$3.normalize(sourceRoot);
            }
            sources = sources.map(String).map(util$3.normalize).map(function(source) {
              return sourceRoot && util$3.isAbsolute(sourceRoot) && util$3.isAbsolute(source) ? util$3.relative(sourceRoot, source) : source;
            });
            this._names = ArraySet$2.fromArray(names.map(String), true);
            this._sources = ArraySet$2.fromArray(sources, true);
            this._absoluteSources = this._sources.toArray().map(function(s) {
              return util$3.computeSourceURL(sourceRoot, s, aSourceMapURL);
            });
            this.sourceRoot = sourceRoot;
            this.sourcesContent = sourcesContent;
            this._mappings = mappings;
            this._sourceMapURL = aSourceMapURL;
            this.file = file;
          }
          BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
          BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;
          BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
            var relativeSource = aSource;
            if (this.sourceRoot != null) {
              relativeSource = util$3.relative(this.sourceRoot, relativeSource);
            }
            if (this._sources.has(relativeSource)) {
              return this._sources.indexOf(relativeSource);
            }
            var i;
            for (i = 0; i < this._absoluteSources.length; ++i) {
              if (this._absoluteSources[i] == aSource) {
                return i;
              }
            }
            return -1;
          };
          BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
            var smc = Object.create(BasicSourceMapConsumer.prototype);
            var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
            var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
            smc.sourceRoot = aSourceMap._sourceRoot;
            smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
            smc.file = aSourceMap._file;
            smc._sourceMapURL = aSourceMapURL;
            smc._absoluteSources = smc._sources.toArray().map(function(s) {
              return util$3.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
            });
            var generatedMappings = aSourceMap._mappings.toArray().slice();
            var destGeneratedMappings = smc.__generatedMappings = [];
            var destOriginalMappings = smc.__originalMappings = [];
            for (var i = 0, length = generatedMappings.length; i < length; i++) {
              var srcMapping = generatedMappings[i];
              var destMapping = new Mapping$1();
              destMapping.generatedLine = srcMapping.generatedLine;
              destMapping.generatedColumn = srcMapping.generatedColumn;
              if (srcMapping.source) {
                destMapping.source = sources.indexOf(srcMapping.source);
                destMapping.originalLine = srcMapping.originalLine;
                destMapping.originalColumn = srcMapping.originalColumn;
                if (srcMapping.name) {
                  destMapping.name = names.indexOf(srcMapping.name);
                }
                destOriginalMappings.push(destMapping);
              }
              destGeneratedMappings.push(destMapping);
            }
            quickSort(smc.__originalMappings, util$3.compareByOriginalPositions);
            return smc;
          };
          BasicSourceMapConsumer.prototype._version = 3;
          Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {get: function get2() {
            return this._absoluteSources.slice();
          }});
          function Mapping$1() {
            this.generatedLine = 0;
            this.generatedColumn = 0;
            this.source = null;
            this.originalLine = null;
            this.originalColumn = null;
            this.name = null;
          }
          BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            var generatedLine = 1;
            var previousGeneratedColumn = 0;
            var previousOriginalLine = 0;
            var previousOriginalColumn = 0;
            var previousSource = 0;
            var previousName = 0;
            var length = aStr.length;
            var index = 0;
            var cachedSegments = {};
            var temp = {};
            var originalMappings = [];
            var generatedMappings = [];
            var mapping2, str, segment, end, value;
            while (index < length) {
              if (aStr.charAt(index) === ";") {
                generatedLine++;
                index++;
                previousGeneratedColumn = 0;
              } else if (aStr.charAt(index) === ",") {
                index++;
              } else {
                mapping2 = new Mapping$1();
                mapping2.generatedLine = generatedLine;
                for (end = index; end < length; end++) {
                  if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                  }
                }
                str = aStr.slice(index, end);
                segment = cachedSegments[str];
                if (segment) {
                  index += str.length;
                } else {
                  segment = [];
                  while (index < end) {
                    base64Vlq$1.decode(aStr, index, temp);
                    value = temp.value;
                    index = temp.rest;
                    segment.push(value);
                  }
                  if (segment.length === 2) {
                    throw new Error("Found a source, but no line and column");
                  }
                  if (segment.length === 3) {
                    throw new Error("Found a source and line, but no column");
                  }
                  cachedSegments[str] = segment;
                }
                mapping2.generatedColumn = previousGeneratedColumn + segment[0];
                previousGeneratedColumn = mapping2.generatedColumn;
                if (segment.length > 1) {
                  mapping2.source = previousSource + segment[1];
                  previousSource += segment[1];
                  mapping2.originalLine = previousOriginalLine + segment[2];
                  previousOriginalLine = mapping2.originalLine;
                  mapping2.originalLine += 1;
                  mapping2.originalColumn = previousOriginalColumn + segment[3];
                  previousOriginalColumn = mapping2.originalColumn;
                  if (segment.length > 4) {
                    mapping2.name = previousName + segment[4];
                    previousName += segment[4];
                  }
                }
                generatedMappings.push(mapping2);
                if (typeof mapping2.originalLine === "number") {
                  originalMappings.push(mapping2);
                }
              }
            }
            quickSort(generatedMappings, util$3.compareByGeneratedPositionsDeflated);
            this.__generatedMappings = generatedMappings;
            quickSort(originalMappings, util$3.compareByOriginalPositions);
            this.__originalMappings = originalMappings;
          };
          BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
            if (aNeedle[aLineName] <= 0) {
              throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
            }
            if (aNeedle[aColumnName] < 0) {
              throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
            }
            return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
          };
          BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
            for (var index = 0; index < this._generatedMappings.length; ++index) {
              var mapping2 = this._generatedMappings[index];
              if (index + 1 < this._generatedMappings.length) {
                var nextMapping = this._generatedMappings[index + 1];
                if (mapping2.generatedLine === nextMapping.generatedLine) {
                  mapping2.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                  continue;
                }
              }
              mapping2.lastGeneratedColumn = Infinity;
            }
          };
          BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {generatedLine: util$3.getArg(aArgs, "line"), generatedColumn: util$3.getArg(aArgs, "column")};
            var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$3.compareByGeneratedPositionsDeflated, util$3.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
            if (index >= 0) {
              var mapping2 = this._generatedMappings[index];
              if (mapping2.generatedLine === needle.generatedLine) {
                var source = util$3.getArg(mapping2, "source", null);
                if (source !== null) {
                  source = this._sources.at(source);
                  source = util$3.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
                }
                var name2 = util$3.getArg(mapping2, "name", null);
                if (name2 !== null) {
                  name2 = this._names.at(name2);
                }
                return {source, line: util$3.getArg(mapping2, "originalLine", null), column: util$3.getArg(mapping2, "originalColumn", null), name: name2};
              }
            }
            return {source: null, line: null, column: null, name: null};
          };
          BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
            if (!this.sourcesContent) {
              return false;
            }
            return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
              return sc == null;
            });
          };
          BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
            if (!this.sourcesContent) {
              return null;
            }
            var index = this._findSourceIndex(aSource);
            if (index >= 0) {
              return this.sourcesContent[index];
            }
            var relativeSource = aSource;
            if (this.sourceRoot != null) {
              relativeSource = util$3.relative(this.sourceRoot, relativeSource);
            }
            var url;
            if (this.sourceRoot != null && (url = util$3.urlParse(this.sourceRoot))) {
              var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
              if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
                return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
              }
              if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
                return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
              }
            }
            if (nullOnMissing) {
              return null;
            } else {
              throw new Error('"' + relativeSource + '" is not in the SourceMap.');
            }
          };
          BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
            var source = util$3.getArg(aArgs, "source");
            source = this._findSourceIndex(source);
            if (source < 0) {
              return {line: null, column: null, lastColumn: null};
            }
            var needle = {source, originalLine: util$3.getArg(aArgs, "line"), originalColumn: util$3.getArg(aArgs, "column")};
            var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$3.compareByOriginalPositions, util$3.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
            if (index >= 0) {
              var mapping2 = this._originalMappings[index];
              if (mapping2.source === needle.source) {
                return {line: util$3.getArg(mapping2, "generatedLine", null), column: util$3.getArg(mapping2, "generatedColumn", null), lastColumn: util$3.getArg(mapping2, "lastGeneratedColumn", null)};
              }
            }
            return {line: null, column: null, lastColumn: null};
          };
          var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;
          function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap2 = aSourceMap;
            if (typeof aSourceMap === "string") {
              sourceMap2 = util$3.parseSourceMapInput(aSourceMap);
            }
            var version2 = util$3.getArg(sourceMap2, "version");
            var sections = util$3.getArg(sourceMap2, "sections");
            if (version2 != this._version) {
              throw new Error("Unsupported version: " + version2);
            }
            this._sources = new ArraySet$2();
            this._names = new ArraySet$2();
            var lastOffset = {line: -1, column: 0};
            this._sections = sections.map(function(s) {
              if (s.url) {
                throw new Error("Support for url field in sections not implemented.");
              }
              var offset = util$3.getArg(s, "offset");
              var offsetLine = util$3.getArg(offset, "line");
              var offsetColumn = util$3.getArg(offset, "column");
              if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
                throw new Error("Section offsets must be ordered and non-overlapping.");
              }
              lastOffset = offset;
              return {generatedOffset: {
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1
              }, consumer: new SourceMapConsumer$1(util$3.getArg(s, "map"), aSourceMapURL)};
            });
          }
          IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
          IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
          IndexedSourceMapConsumer.prototype._version = 3;
          Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {get: function get2() {
            var sources = [];
            for (var i = 0; i < this._sections.length; i++) {
              for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
                sources.push(this._sections[i].consumer.sources[j]);
              }
            }
            return sources;
          }});
          IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {generatedLine: util$3.getArg(aArgs, "line"), generatedColumn: util$3.getArg(aArgs, "column")};
            var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
              var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
              if (cmp) {
                return cmp;
              }
              return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
            });
            var section = this._sections[sectionIndex];
            if (!section) {
              return {source: null, line: null, column: null, name: null};
            }
            return section.consumer.originalPositionFor({line: needle.generatedLine - (section.generatedOffset.generatedLine - 1), column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), bias: aArgs.bias});
          };
          IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
            return this._sections.every(function(s) {
              return s.consumer.hasContentsOfAllSources();
            });
          };
          IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];
              var content = section.consumer.sourceContentFor(aSource, true);
              if (content) {
                return content;
              }
            }
            if (nullOnMissing) {
              return null;
            } else {
              throw new Error('"' + aSource + '" is not in the SourceMap.');
            }
          };
          IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];
              if (section.consumer._findSourceIndex(util$3.getArg(aArgs, "source")) === -1) {
                continue;
              }
              var generatedPosition = section.consumer.generatedPositionFor(aArgs);
              if (generatedPosition) {
                var ret = {line: generatedPosition.line + (section.generatedOffset.generatedLine - 1), column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)};
                return ret;
              }
            }
            return {line: null, column: null};
          };
          IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];
              var sectionMappings = section.consumer._generatedMappings;
              for (var j = 0; j < sectionMappings.length; j++) {
                var mapping2 = sectionMappings[j];
                var source = section.consumer._sources.at(mapping2.source);
                source = util$3.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
                this._sources.add(source);
                source = this._sources.indexOf(source);
                var name2 = null;
                if (mapping2.name) {
                  name2 = section.consumer._names.at(mapping2.name);
                  this._names.add(name2);
                  name2 = this._names.indexOf(name2);
                }
                var adjustedMapping = {source, generatedLine: mapping2.generatedLine + (section.generatedOffset.generatedLine - 1), generatedColumn: mapping2.generatedColumn + (section.generatedOffset.generatedLine === mapping2.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), originalLine: mapping2.originalLine, originalColumn: mapping2.originalColumn, name: name2};
                this.__generatedMappings.push(adjustedMapping);
                if (typeof adjustedMapping.originalLine === "number") {
                  this.__originalMappings.push(adjustedMapping);
                }
              }
            }
            quickSort(this.__generatedMappings, util$3.compareByGeneratedPositionsDeflated);
            quickSort(this.__originalMappings, util$3.compareByOriginalPositions);
          };
          var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;
          var sourceMapConsumer = {SourceMapConsumer: SourceMapConsumer_1, BasicSourceMapConsumer: BasicSourceMapConsumer_1, IndexedSourceMapConsumer: IndexedSourceMapConsumer_1};
          var SourceMapGenerator$3 = sourceMapGenerator$1.SourceMapGenerator;
          var REGEX_NEWLINE = /(\r?\n)/;
          var NEWLINE_CODE = 10;
          var isSourceNode = "$$$isSourceNode$$$";
          function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
            this.children = [];
            this.sourceContents = {};
            this.line = aLine == null ? null : aLine;
            this.column = aColumn == null ? null : aColumn;
            this.source = aSource == null ? null : aSource;
            this.name = aName == null ? null : aName;
            this[isSourceNode] = true;
            if (aChunks != null)
              this.add(aChunks);
          }
          SourceNode$1.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
            var node2 = new SourceNode$1();
            var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
            var remainingLinesIndex = 0;
            var shiftNextLine = function shiftNextLine2() {
              var lineContents = getNextLine();
              var newLine = getNextLine() || "";
              return lineContents + newLine;
              function getNextLine() {
                return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
              }
            };
            var lastGeneratedLine = 1, lastGeneratedColumn = 0;
            var lastMapping = null;
            aSourceMapConsumer.eachMapping(function(mapping2) {
              if (lastMapping !== null) {
                if (lastGeneratedLine < mapping2.generatedLine) {
                  addMappingWithCode(lastMapping, shiftNextLine());
                  lastGeneratedLine++;
                  lastGeneratedColumn = 0;
                } else {
                  var nextLine = remainingLines[remainingLinesIndex] || "";
                  var code = nextLine.substr(0, mapping2.generatedColumn - lastGeneratedColumn);
                  remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn - lastGeneratedColumn);
                  lastGeneratedColumn = mapping2.generatedColumn;
                  addMappingWithCode(lastMapping, code);
                  lastMapping = mapping2;
                  return;
                }
              }
              while (lastGeneratedLine < mapping2.generatedLine) {
                node2.add(shiftNextLine());
                lastGeneratedLine++;
              }
              if (lastGeneratedColumn < mapping2.generatedColumn) {
                var nextLine = remainingLines[remainingLinesIndex] || "";
                node2.add(nextLine.substr(0, mapping2.generatedColumn));
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn);
                lastGeneratedColumn = mapping2.generatedColumn;
              }
              lastMapping = mapping2;
            }, this);
            if (remainingLinesIndex < remainingLines.length) {
              if (lastMapping) {
                addMappingWithCode(lastMapping, shiftNextLine());
              }
              node2.add(remainingLines.splice(remainingLinesIndex).join(""));
            }
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile);
              if (content != null) {
                if (aRelativePath != null) {
                  sourceFile = util$3.join(aRelativePath, sourceFile);
                }
                node2.setSourceContent(sourceFile, content);
              }
            });
            return node2;
            function addMappingWithCode(mapping2, code) {
              if (mapping2 === null || mapping2.source === void 0) {
                node2.add(code);
              } else {
                var source = aRelativePath ? util$3.join(aRelativePath, mapping2.source) : mapping2.source;
                node2.add(new SourceNode$1(mapping2.originalLine, mapping2.originalColumn, source, code, mapping2.name));
              }
            }
          };
          SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
            if (Array.isArray(aChunk)) {
              aChunk.forEach(function(chunk) {
                this.add(chunk);
              }, this);
            } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
              if (aChunk) {
                this.children.push(aChunk);
              }
            } else {
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            }
            return this;
          };
          SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
            if (Array.isArray(aChunk)) {
              for (var i = aChunk.length - 1; i >= 0; i--) {
                this.prepend(aChunk[i]);
              }
            } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
              this.children.unshift(aChunk);
            } else {
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            }
            return this;
          };
          SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
            var chunk;
            for (var i = 0, len = this.children.length; i < len; i++) {
              chunk = this.children[i];
              if (chunk[isSourceNode]) {
                chunk.walk(aFn);
              } else {
                if (chunk !== "") {
                  aFn(chunk, {source: this.source, line: this.line, column: this.column, name: this.name});
                }
              }
            }
          };
          SourceNode$1.prototype.join = function SourceNode_join(aSep) {
            var newChildren;
            var i;
            var len = this.children.length;
            if (len > 0) {
              newChildren = [];
              for (i = 0; i < len - 1; i++) {
                newChildren.push(this.children[i]);
                newChildren.push(aSep);
              }
              newChildren.push(this.children[i]);
              this.children = newChildren;
            }
            return this;
          };
          SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
            var lastChild = this.children[this.children.length - 1];
            if (lastChild[isSourceNode]) {
              lastChild.replaceRight(aPattern, aReplacement);
            } else if (typeof lastChild === "string") {
              this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
            } else {
              this.children.push("".replace(aPattern, aReplacement));
            }
            return this;
          };
          SourceNode$1.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
            this.sourceContents[util$3.toSetString(aSourceFile)] = aSourceContent;
          };
          SourceNode$1.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
            for (var i = 0, len = this.children.length; i < len; i++) {
              if (this.children[i][isSourceNode]) {
                this.children[i].walkSourceContents(aFn);
              }
            }
            var sources = Object.keys(this.sourceContents);
            for (var i = 0, len = sources.length; i < len; i++) {
              aFn(util$3.fromSetString(sources[i]), this.sourceContents[sources[i]]);
            }
          };
          SourceNode$1.prototype.toString = function SourceNode_toString() {
            var str = "";
            this.walk(function(chunk) {
              str += chunk;
            });
            return str;
          };
          SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
            var generated = {code: "", line: 1, column: 0};
            var map = new SourceMapGenerator$3(aArgs);
            var sourceMappingActive = false;
            var lastOriginalSource = null;
            var lastOriginalLine = null;
            var lastOriginalColumn = null;
            var lastOriginalName = null;
            this.walk(function(chunk, original) {
              generated.code += chunk;
              if (original.source !== null && original.line !== null && original.column !== null) {
                if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                  map.addMapping({source: original.source, original: {line: original.line, column: original.column}, generated: {line: generated.line, column: generated.column}, name: original.name});
                }
                lastOriginalSource = original.source;
                lastOriginalLine = original.line;
                lastOriginalColumn = original.column;
                lastOriginalName = original.name;
                sourceMappingActive = true;
              } else if (sourceMappingActive) {
                map.addMapping({generated: {line: generated.line, column: generated.column}});
                lastOriginalSource = null;
                sourceMappingActive = false;
              }
              for (var idx = 0, length = chunk.length; idx < length; idx++) {
                if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                  generated.line++;
                  generated.column = 0;
                  if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                  } else if (sourceMappingActive) {
                    map.addMapping({source: original.source, original: {line: original.line, column: original.column}, generated: {line: generated.line, column: generated.column}, name: original.name});
                  }
                } else {
                  generated.column++;
                }
              }
            });
            this.walkSourceContents(function(sourceFile, sourceContent) {
              map.setSourceContent(sourceFile, sourceContent);
            });
            return {code: generated.code, map};
          };
          var SourceNode_1 = SourceNode$1;
          var sourceNode = {SourceNode: SourceNode_1};
          var SourceMapGenerator$2 = sourceMapGenerator$1.SourceMapGenerator;
          var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
          var SourceNode = sourceNode.SourceNode;
          var sourceMap = {SourceMapGenerator: SourceMapGenerator$2, SourceMapConsumer, SourceNode};
          var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace2(assert$2);
          var util$2 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.isTrailingCommaEnabled = exports4.getParentExportDeclaration = exports4.isExportDeclaration = exports4.fixFaultyLocations = exports4.getTrueLoc = exports4.composeSourceMaps = exports4.copyPos = exports4.comparePos = exports4.getUnionOfKeys = exports4.getOption = void 0;
            var assert_12 = tslib_1.__importDefault(require$$0$1);
            var types2 = tslib_1.__importStar(main$1);
            var n2 = types2.namedTypes;
            var source_map_1 = tslib_1.__importDefault(sourceMap);
            var SourceMapConsumer2 = source_map_1.default.SourceMapConsumer;
            var SourceMapGenerator2 = source_map_1.default.SourceMapGenerator;
            var hasOwn2 = Object.prototype.hasOwnProperty;
            function getOption(options2, key, defaultValue) {
              if (options2 && hasOwn2.call(options2, key)) {
                return options2[key];
              }
              return defaultValue;
            }
            exports4.getOption = getOption;
            function getUnionOfKeys() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var result = {};
              var argc = args.length;
              for (var i = 0; i < argc; ++i) {
                var keys = Object.keys(args[i]);
                var keyCount = keys.length;
                for (var j = 0; j < keyCount; ++j) {
                  result[keys[j]] = true;
                }
              }
              return result;
            }
            exports4.getUnionOfKeys = getUnionOfKeys;
            function comparePos(pos1, pos2) {
              return pos1.line - pos2.line || pos1.column - pos2.column;
            }
            exports4.comparePos = comparePos;
            function copyPos(pos) {
              return {line: pos.line, column: pos.column};
            }
            exports4.copyPos = copyPos;
            function composeSourceMaps(formerMap, latterMap) {
              if (formerMap) {
                if (!latterMap) {
                  return formerMap;
                }
              } else {
                return latterMap || null;
              }
              var smcFormer = new SourceMapConsumer2(formerMap);
              var smcLatter = new SourceMapConsumer2(latterMap);
              var smg = new SourceMapGenerator2({file: latterMap.file, sourceRoot: latterMap.sourceRoot});
              var sourcesToContents = {};
              smcLatter.eachMapping(function(mapping2) {
                var origPos = smcFormer.originalPositionFor({line: mapping2.originalLine, column: mapping2.originalColumn});
                var sourceName = origPos.source;
                if (sourceName === null) {
                  return;
                }
                smg.addMapping({source: sourceName, original: copyPos(origPos), generated: {line: mapping2.generatedLine, column: mapping2.generatedColumn}, name: mapping2.name});
                var sourceContent = smcFormer.sourceContentFor(sourceName);
                if (sourceContent && !hasOwn2.call(sourcesToContents, sourceName)) {
                  sourcesToContents[sourceName] = sourceContent;
                  smg.setSourceContent(sourceName, sourceContent);
                }
              });
              return smg.toJSON();
            }
            exports4.composeSourceMaps = composeSourceMaps;
            function getTrueLoc(node2, lines2) {
              if (!node2.loc) {
                return null;
              }
              var result = {start: node2.loc.start, end: node2.loc.end};
              function include(node3) {
                expandLoc(result, node3.loc);
              }
              if (node2.declaration && node2.declaration.decorators && isExportDeclaration(node2)) {
                node2.declaration.decorators.forEach(include);
              }
              if (comparePos(result.start, result.end) < 0) {
                result.start = copyPos(result.start);
                lines2.skipSpaces(result.start, false, true);
                if (comparePos(result.start, result.end) < 0) {
                  result.end = copyPos(result.end);
                  lines2.skipSpaces(result.end, true, true);
                }
              }
              if (node2.comments) {
                node2.comments.forEach(include);
              }
              return result;
            }
            exports4.getTrueLoc = getTrueLoc;
            function expandLoc(parentLoc, childLoc) {
              if (parentLoc && childLoc) {
                if (comparePos(childLoc.start, parentLoc.start) < 0) {
                  parentLoc.start = childLoc.start;
                }
                if (comparePos(parentLoc.end, childLoc.end) < 0) {
                  parentLoc.end = childLoc.end;
                }
              }
            }
            function fixFaultyLocations(node2, lines2) {
              var loc = node2.loc;
              if (loc) {
                if (loc.start.line < 1) {
                  loc.start.line = 1;
                }
                if (loc.end.line < 1) {
                  loc.end.line = 1;
                }
              }
              if (node2.type === "File") {
                loc.start = lines2.firstPos();
                loc.end = lines2.lastPos();
              }
              fixForLoopHead(node2, lines2);
              fixTemplateLiteral(node2, lines2);
              if (loc && node2.decorators) {
                node2.decorators.forEach(function(decorator) {
                  expandLoc(loc, decorator.loc);
                });
              } else if (node2.declaration && isExportDeclaration(node2)) {
                node2.declaration.loc = null;
                var decorators = node2.declaration.decorators;
                if (decorators) {
                  decorators.forEach(function(decorator) {
                    expandLoc(loc, decorator.loc);
                  });
                }
              } else if (n2.MethodDefinition && n2.MethodDefinition.check(node2) || n2.Property.check(node2) && (node2.method || node2.shorthand)) {
                node2.value.loc = null;
                if (n2.FunctionExpression.check(node2.value)) {
                  node2.value.id = null;
                }
              } else if (node2.type === "ObjectTypeProperty") {
                var loc_1 = node2.loc;
                var end = loc_1 && loc_1.end;
                if (end) {
                  end = copyPos(end);
                  if (lines2.prevPos(end) && lines2.charAt(end) === ",") {
                    if (end = lines2.skipSpaces(end, true, true)) {
                      loc_1.end = end;
                    }
                  }
                }
              }
            }
            exports4.fixFaultyLocations = fixFaultyLocations;
            function fixForLoopHead(node2, lines2) {
              if (node2.type !== "ForStatement") {
                return;
              }
              function fix(child) {
                var loc = child && child.loc;
                var start = loc && loc.start;
                var end = loc && copyPos(loc.end);
                while (start && end && comparePos(start, end) < 0) {
                  lines2.prevPos(end);
                  if (lines2.charAt(end) === ";") {
                    loc.end.line = end.line;
                    loc.end.column = end.column;
                  } else {
                    break;
                  }
                }
              }
              fix(node2.init);
              fix(node2.test);
              fix(node2.update);
            }
            function fixTemplateLiteral(node2, lines2) {
              if (node2.type !== "TemplateLiteral") {
                return;
              }
              if (node2.quasis.length === 0) {
                return;
              }
              if (node2.loc) {
                var afterLeftBackTickPos = copyPos(node2.loc.start);
                assert_12.default.strictEqual(lines2.charAt(afterLeftBackTickPos), "`");
                assert_12.default.ok(lines2.nextPos(afterLeftBackTickPos));
                var firstQuasi = node2.quasis[0];
                if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
                  firstQuasi.loc.start = afterLeftBackTickPos;
                }
                var rightBackTickPos = copyPos(node2.loc.end);
                assert_12.default.ok(lines2.prevPos(rightBackTickPos));
                assert_12.default.strictEqual(lines2.charAt(rightBackTickPos), "`");
                var lastQuasi = node2.quasis[node2.quasis.length - 1];
                if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
                  lastQuasi.loc.end = rightBackTickPos;
                }
              }
              node2.expressions.forEach(function(expr2, i) {
                var dollarCurlyPos = lines2.skipSpaces(expr2.loc.start, true, false);
                if (lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "{" && lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "$") {
                  var quasiBefore = node2.quasis[i];
                  if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
                    quasiBefore.loc.end = dollarCurlyPos;
                  }
                }
                var rightCurlyPos = lines2.skipSpaces(expr2.loc.end, false, false);
                if (lines2.charAt(rightCurlyPos) === "}") {
                  assert_12.default.ok(lines2.nextPos(rightCurlyPos));
                  var quasiAfter = node2.quasis[i + 1];
                  if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
                    quasiAfter.loc.start = rightCurlyPos;
                  }
                }
              });
            }
            function isExportDeclaration(node2) {
              if (node2)
                switch (node2.type) {
                  case "ExportDeclaration":
                  case "ExportDefaultDeclaration":
                  case "ExportDefaultSpecifier":
                  case "DeclareExportDeclaration":
                  case "ExportNamedDeclaration":
                  case "ExportAllDeclaration":
                    return true;
                }
              return false;
            }
            exports4.isExportDeclaration = isExportDeclaration;
            function getParentExportDeclaration(path2) {
              var parentNode = path2.getParentNode();
              if (path2.getName() === "declaration" && isExportDeclaration(parentNode)) {
                return parentNode;
              }
              return null;
            }
            exports4.getParentExportDeclaration = getParentExportDeclaration;
            function isTrailingCommaEnabled(options2, context) {
              var trailingComma = options2.trailingComma;
              if (typeof trailingComma === "object") {
                return !!trailingComma[context];
              }
              return !!trailingComma;
            }
            exports4.isTrailingCommaEnabled = isTrailingCommaEnabled;
          });
          var esprima$1 = createCommonjsModule(function(module3, exports4) {
            (function webpackUniversalModuleDefinition(root, factory) {
              module3.exports = factory();
            })(this, function() {
              return function(modules) {
                var installedModules = {};
                function __webpack_require__(moduleId) {
                  if (installedModules[moduleId])
                    return installedModules[moduleId].exports;
                  var module4 = installedModules[moduleId] = {exports: {}, id: moduleId, loaded: false};
                  modules[moduleId].call(module4.exports, module4, module4.exports, __webpack_require__);
                  module4.loaded = true;
                  return module4.exports;
                }
                __webpack_require__.m = modules;
                __webpack_require__.c = installedModules;
                __webpack_require__.p = "";
                return __webpack_require__(0);
              }([function(module4, exports5, __webpack_require__) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var comment_handler_1 = __webpack_require__(1);
                var jsx_parser_1 = __webpack_require__(3);
                var parser_1 = __webpack_require__(8);
                var tokenizer_1 = __webpack_require__(15);
                function parse(code, options2, delegate) {
                  var commentHandler = null;
                  var proxyDelegate = function proxyDelegate2(node2, metadata) {
                    if (delegate) {
                      delegate(node2, metadata);
                    }
                    if (commentHandler) {
                      commentHandler.visit(node2, metadata);
                    }
                  };
                  var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
                  var collectComment = false;
                  if (options2) {
                    collectComment = typeof options2.comment === "boolean" && options2.comment;
                    var attachComment = typeof options2.attachComment === "boolean" && options2.attachComment;
                    if (collectComment || attachComment) {
                      commentHandler = new comment_handler_1.CommentHandler();
                      commentHandler.attach = attachComment;
                      options2.comment = true;
                      parserDelegate = proxyDelegate;
                    }
                  }
                  var isModule = false;
                  if (options2 && typeof options2.sourceType === "string") {
                    isModule = options2.sourceType === "module";
                  }
                  var parser2;
                  if (options2 && typeof options2.jsx === "boolean" && options2.jsx) {
                    parser2 = new jsx_parser_1.JSXParser(code, options2, parserDelegate);
                  } else {
                    parser2 = new parser_1.Parser(code, options2, parserDelegate);
                  }
                  var program = isModule ? parser2.parseModule() : parser2.parseScript();
                  var ast = program;
                  if (collectComment && commentHandler) {
                    ast.comments = commentHandler.comments;
                  }
                  if (parser2.config.tokens) {
                    ast.tokens = parser2.tokens;
                  }
                  if (parser2.config.tolerant) {
                    ast.errors = parser2.errorHandler.errors;
                  }
                  return ast;
                }
                exports5.parse = parse;
                function parseModule(code, options2, delegate) {
                  var parsingOptions = options2 || {};
                  parsingOptions.sourceType = "module";
                  return parse(code, parsingOptions, delegate);
                }
                exports5.parseModule = parseModule;
                function parseScript(code, options2, delegate) {
                  var parsingOptions = options2 || {};
                  parsingOptions.sourceType = "script";
                  return parse(code, parsingOptions, delegate);
                }
                exports5.parseScript = parseScript;
                function tokenize(code, options2, delegate) {
                  var tokenizer = new tokenizer_1.Tokenizer(code, options2);
                  var tokens;
                  tokens = [];
                  try {
                    while (true) {
                      var token = tokenizer.getNextToken();
                      if (!token) {
                        break;
                      }
                      if (delegate) {
                        token = delegate(token);
                      }
                      tokens.push(token);
                    }
                  } catch (e) {
                    tokenizer.errorHandler.tolerate(e);
                  }
                  if (tokenizer.errorHandler.tolerant) {
                    tokens.errors = tokenizer.errors();
                  }
                  return tokens;
                }
                exports5.tokenize = tokenize;
                var syntax_1 = __webpack_require__(2);
                exports5.Syntax = syntax_1.Syntax;
                exports5.version = "4.0.1";
              }, function(module4, exports5, __webpack_require__) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var syntax_1 = __webpack_require__(2);
                var CommentHandler = function() {
                  function CommentHandler2() {
                    this.attach = false;
                    this.comments = [];
                    this.stack = [];
                    this.leading = [];
                    this.trailing = [];
                  }
                  CommentHandler2.prototype.insertInnerComments = function(node2, metadata) {
                    if (node2.type === syntax_1.Syntax.BlockStatement && node2.body.length === 0) {
                      var innerComments = [];
                      for (var i = this.leading.length - 1; i >= 0; --i) {
                        var entry = this.leading[i];
                        if (metadata.end.offset >= entry.start) {
                          innerComments.unshift(entry.comment);
                          this.leading.splice(i, 1);
                          this.trailing.splice(i, 1);
                        }
                      }
                      if (innerComments.length) {
                        node2.innerComments = innerComments;
                      }
                    }
                  };
                  CommentHandler2.prototype.findTrailingComments = function(metadata) {
                    var trailingComments = [];
                    if (this.trailing.length > 0) {
                      for (var i = this.trailing.length - 1; i >= 0; --i) {
                        var entry_1 = this.trailing[i];
                        if (entry_1.start >= metadata.end.offset) {
                          trailingComments.unshift(entry_1.comment);
                        }
                      }
                      this.trailing.length = 0;
                      return trailingComments;
                    }
                    var entry = this.stack[this.stack.length - 1];
                    if (entry && entry.node.trailingComments) {
                      var firstComment = entry.node.trailingComments[0];
                      if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                        trailingComments = entry.node.trailingComments;
                        delete entry.node.trailingComments;
                      }
                    }
                    return trailingComments;
                  };
                  CommentHandler2.prototype.findLeadingComments = function(metadata) {
                    var leadingComments = [];
                    var target;
                    while (this.stack.length > 0) {
                      var entry = this.stack[this.stack.length - 1];
                      if (entry && entry.start >= metadata.start.offset) {
                        target = entry.node;
                        this.stack.pop();
                      } else {
                        break;
                      }
                    }
                    if (target) {
                      var count = target.leadingComments ? target.leadingComments.length : 0;
                      for (var i = count - 1; i >= 0; --i) {
                        var comment2 = target.leadingComments[i];
                        if (comment2.range[1] <= metadata.start.offset) {
                          leadingComments.unshift(comment2);
                          target.leadingComments.splice(i, 1);
                        }
                      }
                      if (target.leadingComments && target.leadingComments.length === 0) {
                        delete target.leadingComments;
                      }
                      return leadingComments;
                    }
                    for (var i = this.leading.length - 1; i >= 0; --i) {
                      var entry = this.leading[i];
                      if (entry.start <= metadata.start.offset) {
                        leadingComments.unshift(entry.comment);
                        this.leading.splice(i, 1);
                      }
                    }
                    return leadingComments;
                  };
                  CommentHandler2.prototype.visitNode = function(node2, metadata) {
                    if (node2.type === syntax_1.Syntax.Program && node2.body.length > 0) {
                      return;
                    }
                    this.insertInnerComments(node2, metadata);
                    var trailingComments = this.findTrailingComments(metadata);
                    var leadingComments = this.findLeadingComments(metadata);
                    if (leadingComments.length > 0) {
                      node2.leadingComments = leadingComments;
                    }
                    if (trailingComments.length > 0) {
                      node2.trailingComments = trailingComments;
                    }
                    this.stack.push({node: node2, start: metadata.start.offset});
                  };
                  CommentHandler2.prototype.visitComment = function(node2, metadata) {
                    var type2 = node2.type[0] === "L" ? "Line" : "Block";
                    var comment2 = {type: type2, value: node2.value};
                    if (node2.range) {
                      comment2.range = node2.range;
                    }
                    if (node2.loc) {
                      comment2.loc = node2.loc;
                    }
                    this.comments.push(comment2);
                    if (this.attach) {
                      var entry = {comment: {type: type2, value: node2.value, range: [metadata.start.offset, metadata.end.offset]}, start: metadata.start.offset};
                      if (node2.loc) {
                        entry.comment.loc = node2.loc;
                      }
                      node2.type = type2;
                      this.leading.push(entry);
                      this.trailing.push(entry);
                    }
                  };
                  CommentHandler2.prototype.visit = function(node2, metadata) {
                    if (node2.type === "LineComment") {
                      this.visitComment(node2, metadata);
                    } else if (node2.type === "BlockComment") {
                      this.visitComment(node2, metadata);
                    } else if (this.attach) {
                      this.visitNode(node2, metadata);
                    }
                  };
                  return CommentHandler2;
                }();
                exports5.CommentHandler = CommentHandler;
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                exports5.Syntax = {AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DoWhileStatement: "DoWhileStatement", DebuggerStatement: "DebuggerStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForOfStatement: "ForOfStatement", ForInStatement: "ForInStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchCase: "SwitchCase", SwitchStatement: "SwitchStatement", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression"};
              }, function(module4, exports5, __webpack_require__) {
                var __extends2 = this && this.__extends || function() {
                  var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d, b) {
                    d.__proto__ = b;
                  } || function(d, b) {
                    for (var p in b)
                      if (b.hasOwnProperty(p))
                        d[p] = b[p];
                  };
                  return function(d, b) {
                    extendStatics(d, b);
                    function __2() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
                  };
                }();
                Object.defineProperty(exports5, "__esModule", {value: true});
                var character_1 = __webpack_require__(4);
                var JSXNode = __webpack_require__(5);
                var jsx_syntax_1 = __webpack_require__(6);
                var Node3 = __webpack_require__(7);
                var parser_1 = __webpack_require__(8);
                var token_1 = __webpack_require__(13);
                var xhtml_entities_1 = __webpack_require__(14);
                token_1.TokenName[100] = "JSXIdentifier";
                token_1.TokenName[101] = "JSXText";
                function getQualifiedElementName(elementName) {
                  var qualifiedName;
                  switch (elementName.type) {
                    case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                      var id = elementName;
                      qualifiedName = id.name;
                      break;
                    case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                      var ns = elementName;
                      qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                      break;
                    case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                      var expr2 = elementName;
                      qualifiedName = getQualifiedElementName(expr2.object) + "." + getQualifiedElementName(expr2.property);
                      break;
                  }
                  return qualifiedName;
                }
                var JSXParser = function(_super) {
                  __extends2(JSXParser2, _super);
                  function JSXParser2(code, options2, delegate) {
                    return _super.call(this, code, options2, delegate) || this;
                  }
                  JSXParser2.prototype.parsePrimaryExpression = function() {
                    return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
                  };
                  JSXParser2.prototype.startJSX = function() {
                    this.scanner.index = this.startMarker.index;
                    this.scanner.lineNumber = this.startMarker.line;
                    this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
                  };
                  JSXParser2.prototype.finishJSX = function() {
                    this.nextToken();
                  };
                  JSXParser2.prototype.reenterJSX = function() {
                    this.startJSX();
                    this.expectJSX("}");
                    if (this.config.tokens) {
                      this.tokens.pop();
                    }
                  };
                  JSXParser2.prototype.createJSXNode = function() {
                    this.collectComments();
                    return {index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                  };
                  JSXParser2.prototype.createJSXChildNode = function() {
                    return {index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                  };
                  JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                    var result = "&";
                    var valid = true;
                    var terminated = false;
                    var numeric = false;
                    var hex = false;
                    while (!this.scanner.eof() && valid && !terminated) {
                      var ch = this.scanner.source[this.scanner.index];
                      if (ch === quote) {
                        break;
                      }
                      terminated = ch === ";";
                      result += ch;
                      ++this.scanner.index;
                      if (!terminated) {
                        switch (result.length) {
                          case 2:
                            numeric = ch === "#";
                            break;
                          case 3:
                            if (numeric) {
                              hex = ch === "x";
                              valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                              numeric = numeric && !hex;
                            }
                            break;
                          default:
                            valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                            valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                            break;
                        }
                      }
                    }
                    if (valid && terminated && result.length > 2) {
                      var str = result.substr(1, result.length - 2);
                      if (numeric && str.length > 1) {
                        result = String.fromCharCode(parseInt(str.substr(1), 10));
                      } else if (hex && str.length > 2) {
                        result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                      } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                        result = xhtml_entities_1.XHTMLEntities[str];
                      }
                    }
                    return result;
                  };
                  JSXParser2.prototype.lexJSX = function() {
                    var cp = this.scanner.source.charCodeAt(this.scanner.index);
                    if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                      var value = this.scanner.source[this.scanner.index++];
                      return {type: 7, value, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index - 1, end: this.scanner.index};
                    }
                    if (cp === 34 || cp === 39) {
                      var start = this.scanner.index;
                      var quote = this.scanner.source[this.scanner.index++];
                      var str = "";
                      while (!this.scanner.eof()) {
                        var ch = this.scanner.source[this.scanner.index++];
                        if (ch === quote) {
                          break;
                        } else if (ch === "&") {
                          str += this.scanXHTMLEntity(quote);
                        } else {
                          str += ch;
                        }
                      }
                      return {type: 8, value: str, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                    }
                    if (cp === 46) {
                      var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                      var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                      var value = n1 === 46 && n2 === 46 ? "..." : ".";
                      var start = this.scanner.index;
                      this.scanner.index += value.length;
                      return {type: 7, value, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                    }
                    if (cp === 96) {
                      return {type: 10, value: "", lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index, end: this.scanner.index};
                    }
                    if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                      var start = this.scanner.index;
                      ++this.scanner.index;
                      while (!this.scanner.eof()) {
                        var ch = this.scanner.source.charCodeAt(this.scanner.index);
                        if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                          ++this.scanner.index;
                        } else if (ch === 45) {
                          ++this.scanner.index;
                        } else {
                          break;
                        }
                      }
                      var id = this.scanner.source.slice(start, this.scanner.index);
                      return {type: 100, value: id, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                    }
                    return this.scanner.lex();
                  };
                  JSXParser2.prototype.nextJSXToken = function() {
                    this.collectComments();
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = this.lexJSX();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    if (this.config.tokens) {
                      this.tokens.push(this.convertToken(token));
                    }
                    return token;
                  };
                  JSXParser2.prototype.nextJSXText = function() {
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var start = this.scanner.index;
                    var text2 = "";
                    while (!this.scanner.eof()) {
                      var ch = this.scanner.source[this.scanner.index];
                      if (ch === "{" || ch === "<") {
                        break;
                      }
                      ++this.scanner.index;
                      text2 += ch;
                      if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        ++this.scanner.lineNumber;
                        if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                          ++this.scanner.index;
                        }
                        this.scanner.lineStart = this.scanner.index;
                      }
                    }
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = {type: 101, value: text2, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start, end: this.scanner.index};
                    if (text2.length > 0 && this.config.tokens) {
                      this.tokens.push(this.convertToken(token));
                    }
                    return token;
                  };
                  JSXParser2.prototype.peekJSXToken = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.lexJSX();
                    this.scanner.restoreState(state);
                    return next;
                  };
                  JSXParser2.prototype.expectJSX = function(value) {
                    var token = this.nextJSXToken();
                    if (token.type !== 7 || token.value !== value) {
                      this.throwUnexpectedToken(token);
                    }
                  };
                  JSXParser2.prototype.matchJSX = function(value) {
                    var next = this.peekJSXToken();
                    return next.type === 7 && next.value === value;
                  };
                  JSXParser2.prototype.parseJSXIdentifier = function() {
                    var node2 = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 100) {
                      this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node2, new JSXNode.JSXIdentifier(token.value));
                  };
                  JSXParser2.prototype.parseJSXElementName = function() {
                    var node2 = this.createJSXNode();
                    var elementName = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                      var namespace = elementName;
                      this.expectJSX(":");
                      var name_1 = this.parseJSXIdentifier();
                      elementName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_1));
                    } else if (this.matchJSX(".")) {
                      while (this.matchJSX(".")) {
                        var object2 = elementName;
                        this.expectJSX(".");
                        var property = this.parseJSXIdentifier();
                        elementName = this.finalize(node2, new JSXNode.JSXMemberExpression(object2, property));
                      }
                    }
                    return elementName;
                  };
                  JSXParser2.prototype.parseJSXAttributeName = function() {
                    var node2 = this.createJSXNode();
                    var attributeName;
                    var identifier = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                      var namespace = identifier;
                      this.expectJSX(":");
                      var name_2 = this.parseJSXIdentifier();
                      attributeName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_2));
                    } else {
                      attributeName = identifier;
                    }
                    return attributeName;
                  };
                  JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                    var node2 = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 8) {
                      this.throwUnexpectedToken(token);
                    }
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node2, new Node3.Literal(token.value, raw));
                  };
                  JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("{");
                    this.finishJSX();
                    if (this.match("}")) {
                      this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                    }
                    var expression = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
                  };
                  JSXParser2.prototype.parseJSXAttributeValue = function() {
                    return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
                  };
                  JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                    var node2 = this.createJSXNode();
                    var name2 = this.parseJSXAttributeName();
                    var value = null;
                    if (this.matchJSX("=")) {
                      this.expectJSX("=");
                      value = this.parseJSXAttributeValue();
                    }
                    return this.finalize(node2, new JSXNode.JSXAttribute(name2, value));
                  };
                  JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("{");
                    this.expectJSX("...");
                    this.finishJSX();
                    var argument = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node2, new JSXNode.JSXSpreadAttribute(argument));
                  };
                  JSXParser2.prototype.parseJSXAttributes = function() {
                    var attributes = [];
                    while (!this.matchJSX("/") && !this.matchJSX(">")) {
                      var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                      attributes.push(attribute);
                    }
                    return attributes;
                  };
                  JSXParser2.prototype.parseJSXOpeningElement = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("<");
                    var name2 = this.parseJSXElementName();
                    var attributes = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                      this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
                  };
                  JSXParser2.prototype.parseJSXBoundaryElement = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("<");
                    if (this.matchJSX("/")) {
                      this.expectJSX("/");
                      var name_3 = this.parseJSXElementName();
                      this.expectJSX(">");
                      return this.finalize(node2, new JSXNode.JSXClosingElement(name_3));
                    }
                    var name2 = this.parseJSXElementName();
                    var attributes = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                      this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
                  };
                  JSXParser2.prototype.parseJSXEmptyExpression = function() {
                    var node2 = this.createJSXChildNode();
                    this.collectComments();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    return this.finalize(node2, new JSXNode.JSXEmptyExpression());
                  };
                  JSXParser2.prototype.parseJSXExpressionContainer = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("{");
                    var expression;
                    if (this.matchJSX("}")) {
                      expression = this.parseJSXEmptyExpression();
                      this.expectJSX("}");
                    } else {
                      this.finishJSX();
                      expression = this.parseAssignmentExpression();
                      this.reenterJSX();
                    }
                    return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
                  };
                  JSXParser2.prototype.parseJSXChildren = function() {
                    var children = [];
                    while (!this.scanner.eof()) {
                      var node2 = this.createJSXChildNode();
                      var token = this.nextJSXText();
                      if (token.start < token.end) {
                        var raw = this.getTokenRaw(token);
                        var child = this.finalize(node2, new JSXNode.JSXText(token.value, raw));
                        children.push(child);
                      }
                      if (this.scanner.source[this.scanner.index] === "{") {
                        var container = this.parseJSXExpressionContainer();
                        children.push(container);
                      } else {
                        break;
                      }
                    }
                    return children;
                  };
                  JSXParser2.prototype.parseComplexJSXElement = function(el) {
                    var stack = [];
                    while (!this.scanner.eof()) {
                      el.children = el.children.concat(this.parseJSXChildren());
                      var node2 = this.createJSXChildNode();
                      var element = this.parseJSXBoundaryElement();
                      if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                        var opening = element;
                        if (opening.selfClosing) {
                          var child = this.finalize(node2, new JSXNode.JSXElement(opening, [], null));
                          el.children.push(child);
                        } else {
                          stack.push(el);
                          el = {node: node2, opening, closing: null, children: []};
                        }
                      }
                      if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                        el.closing = element;
                        var open_1 = getQualifiedElementName(el.opening.name);
                        var close_1 = getQualifiedElementName(el.closing.name);
                        if (open_1 !== close_1) {
                          this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                        }
                        if (stack.length > 0) {
                          var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                          el = stack[stack.length - 1];
                          el.children.push(child);
                          stack.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    return el;
                  };
                  JSXParser2.prototype.parseJSXElement = function() {
                    var node2 = this.createJSXNode();
                    var opening = this.parseJSXOpeningElement();
                    var children = [];
                    var closing = null;
                    if (!opening.selfClosing) {
                      var el = this.parseComplexJSXElement({node: node2, opening, closing, children});
                      children = el.children;
                      closing = el.closing;
                    }
                    return this.finalize(node2, new JSXNode.JSXElement(opening, children, closing));
                  };
                  JSXParser2.prototype.parseJSXRoot = function() {
                    if (this.config.tokens) {
                      this.tokens.pop();
                    }
                    this.startJSX();
                    var element = this.parseJSXElement();
                    this.finishJSX();
                    return element;
                  };
                  JSXParser2.prototype.isStartOfExpression = function() {
                    return _super.prototype.isStartOfExpression.call(this) || this.match("<");
                  };
                  return JSXParser2;
                }(parser_1.Parser);
                exports5.JSXParser = JSXParser;
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var Regex = {
                  NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                  NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
                };
                exports5.Character = {
                  fromCodePoint: function fromCodePoint(cp) {
                    return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
                  },
                  isWhiteSpace: function isWhiteSpace(cp) {
                    return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
                  },
                  isLineTerminator: function isLineTerminator(cp) {
                    return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
                  },
                  isIdentifierStart: function isIdentifierStart2(cp) {
                    return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports5.Character.fromCodePoint(cp));
                  },
                  isIdentifierPart: function isIdentifierPart(cp) {
                    return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports5.Character.fromCodePoint(cp));
                  },
                  isDecimalDigit: function isDecimalDigit(cp) {
                    return cp >= 48 && cp <= 57;
                  },
                  isHexDigit: function isHexDigit(cp) {
                    return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
                  },
                  isOctalDigit: function isOctalDigit(cp) {
                    return cp >= 48 && cp <= 55;
                  }
                };
              }, function(module4, exports5, __webpack_require__) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var jsx_syntax_1 = __webpack_require__(6);
                var JSXClosingElement = function() {
                  function JSXClosingElement2(name2) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                    this.name = name2;
                  }
                  return JSXClosingElement2;
                }();
                exports5.JSXClosingElement = JSXClosingElement;
                var JSXElement = function() {
                  function JSXElement2(openingElement, children, closingElement) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                    this.openingElement = openingElement;
                    this.children = children;
                    this.closingElement = closingElement;
                  }
                  return JSXElement2;
                }();
                exports5.JSXElement = JSXElement;
                var JSXEmptyExpression = function() {
                  function JSXEmptyExpression2() {
                    this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
                  }
                  return JSXEmptyExpression2;
                }();
                exports5.JSXEmptyExpression = JSXEmptyExpression;
                var JSXExpressionContainer = function() {
                  function JSXExpressionContainer2(expression) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                    this.expression = expression;
                  }
                  return JSXExpressionContainer2;
                }();
                exports5.JSXExpressionContainer = JSXExpressionContainer;
                var JSXIdentifier = function() {
                  function JSXIdentifier2(name2) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                    this.name = name2;
                  }
                  return JSXIdentifier2;
                }();
                exports5.JSXIdentifier = JSXIdentifier;
                var JSXMemberExpression = function() {
                  function JSXMemberExpression2(object2, property) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                    this.object = object2;
                    this.property = property;
                  }
                  return JSXMemberExpression2;
                }();
                exports5.JSXMemberExpression = JSXMemberExpression;
                var JSXAttribute = function() {
                  function JSXAttribute2(name2, value) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                    this.name = name2;
                    this.value = value;
                  }
                  return JSXAttribute2;
                }();
                exports5.JSXAttribute = JSXAttribute;
                var JSXNamespacedName = function() {
                  function JSXNamespacedName2(namespace, name2) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                    this.namespace = namespace;
                    this.name = name2;
                  }
                  return JSXNamespacedName2;
                }();
                exports5.JSXNamespacedName = JSXNamespacedName;
                var JSXOpeningElement = function() {
                  function JSXOpeningElement2(name2, selfClosing, attributes) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                    this.name = name2;
                    this.selfClosing = selfClosing;
                    this.attributes = attributes;
                  }
                  return JSXOpeningElement2;
                }();
                exports5.JSXOpeningElement = JSXOpeningElement;
                var JSXSpreadAttribute = function() {
                  function JSXSpreadAttribute2(argument) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                    this.argument = argument;
                  }
                  return JSXSpreadAttribute2;
                }();
                exports5.JSXSpreadAttribute = JSXSpreadAttribute;
                var JSXText = function() {
                  function JSXText2(value, raw) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXText;
                    this.value = value;
                    this.raw = raw;
                  }
                  return JSXText2;
                }();
                exports5.JSXText = JSXText;
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                exports5.JSXSyntax = {JSXAttribute: "JSXAttribute", JSXClosingElement: "JSXClosingElement", JSXElement: "JSXElement", JSXEmptyExpression: "JSXEmptyExpression", JSXExpressionContainer: "JSXExpressionContainer", JSXIdentifier: "JSXIdentifier", JSXMemberExpression: "JSXMemberExpression", JSXNamespacedName: "JSXNamespacedName", JSXOpeningElement: "JSXOpeningElement", JSXSpreadAttribute: "JSXSpreadAttribute", JSXText: "JSXText"};
              }, function(module4, exports5, __webpack_require__) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var syntax_1 = __webpack_require__(2);
                var ArrayExpression = function() {
                  function ArrayExpression2(elements) {
                    this.type = syntax_1.Syntax.ArrayExpression;
                    this.elements = elements;
                  }
                  return ArrayExpression2;
                }();
                exports5.ArrayExpression = ArrayExpression;
                var ArrayPattern = function() {
                  function ArrayPattern2(elements) {
                    this.type = syntax_1.Syntax.ArrayPattern;
                    this.elements = elements;
                  }
                  return ArrayPattern2;
                }();
                exports5.ArrayPattern = ArrayPattern;
                var ArrowFunctionExpression = function() {
                  function ArrowFunctionExpression2(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = false;
                  }
                  return ArrowFunctionExpression2;
                }();
                exports5.ArrowFunctionExpression = ArrowFunctionExpression;
                var AssignmentExpression = function() {
                  function AssignmentExpression2(operator, left, right) {
                    this.type = syntax_1.Syntax.AssignmentExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                  }
                  return AssignmentExpression2;
                }();
                exports5.AssignmentExpression = AssignmentExpression;
                var AssignmentPattern = function() {
                  function AssignmentPattern2(left, right) {
                    this.type = syntax_1.Syntax.AssignmentPattern;
                    this.left = left;
                    this.right = right;
                  }
                  return AssignmentPattern2;
                }();
                exports5.AssignmentPattern = AssignmentPattern;
                var AsyncArrowFunctionExpression = function() {
                  function AsyncArrowFunctionExpression2(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = true;
                  }
                  return AsyncArrowFunctionExpression2;
                }();
                exports5.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
                var AsyncFunctionDeclaration = function() {
                  function AsyncFunctionDeclaration2(id, params, body) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                  }
                  return AsyncFunctionDeclaration2;
                }();
                exports5.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
                var AsyncFunctionExpression = function() {
                  function AsyncFunctionExpression2(id, params, body) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                  }
                  return AsyncFunctionExpression2;
                }();
                exports5.AsyncFunctionExpression = AsyncFunctionExpression;
                var AwaitExpression = function() {
                  function AwaitExpression2(argument) {
                    this.type = syntax_1.Syntax.AwaitExpression;
                    this.argument = argument;
                  }
                  return AwaitExpression2;
                }();
                exports5.AwaitExpression = AwaitExpression;
                var BinaryExpression = function() {
                  function BinaryExpression2(operator, left, right) {
                    var logical = operator === "||" || operator === "&&";
                    this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                  }
                  return BinaryExpression2;
                }();
                exports5.BinaryExpression = BinaryExpression;
                var BlockStatement = function() {
                  function BlockStatement2(body) {
                    this.type = syntax_1.Syntax.BlockStatement;
                    this.body = body;
                  }
                  return BlockStatement2;
                }();
                exports5.BlockStatement = BlockStatement;
                var BreakStatement = function() {
                  function BreakStatement2(label) {
                    this.type = syntax_1.Syntax.BreakStatement;
                    this.label = label;
                  }
                  return BreakStatement2;
                }();
                exports5.BreakStatement = BreakStatement;
                var CallExpression = function() {
                  function CallExpression2(callee, args) {
                    this.type = syntax_1.Syntax.CallExpression;
                    this.callee = callee;
                    this.arguments = args;
                  }
                  return CallExpression2;
                }();
                exports5.CallExpression = CallExpression;
                var CatchClause = function() {
                  function CatchClause2(param, body) {
                    this.type = syntax_1.Syntax.CatchClause;
                    this.param = param;
                    this.body = body;
                  }
                  return CatchClause2;
                }();
                exports5.CatchClause = CatchClause;
                var ClassBody = function() {
                  function ClassBody2(body) {
                    this.type = syntax_1.Syntax.ClassBody;
                    this.body = body;
                  }
                  return ClassBody2;
                }();
                exports5.ClassBody = ClassBody;
                var ClassDeclaration = function() {
                  function ClassDeclaration2(id, superClass, body) {
                    this.type = syntax_1.Syntax.ClassDeclaration;
                    this.id = id;
                    this.superClass = superClass;
                    this.body = body;
                  }
                  return ClassDeclaration2;
                }();
                exports5.ClassDeclaration = ClassDeclaration;
                var ClassExpression = function() {
                  function ClassExpression2(id, superClass, body) {
                    this.type = syntax_1.Syntax.ClassExpression;
                    this.id = id;
                    this.superClass = superClass;
                    this.body = body;
                  }
                  return ClassExpression2;
                }();
                exports5.ClassExpression = ClassExpression;
                var ComputedMemberExpression = function() {
                  function ComputedMemberExpression2(object2, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = true;
                    this.object = object2;
                    this.property = property;
                  }
                  return ComputedMemberExpression2;
                }();
                exports5.ComputedMemberExpression = ComputedMemberExpression;
                var ConditionalExpression = function() {
                  function ConditionalExpression2(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.ConditionalExpression;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                  }
                  return ConditionalExpression2;
                }();
                exports5.ConditionalExpression = ConditionalExpression;
                var ContinueStatement = function() {
                  function ContinueStatement2(label) {
                    this.type = syntax_1.Syntax.ContinueStatement;
                    this.label = label;
                  }
                  return ContinueStatement2;
                }();
                exports5.ContinueStatement = ContinueStatement;
                var DebuggerStatement = function() {
                  function DebuggerStatement2() {
                    this.type = syntax_1.Syntax.DebuggerStatement;
                  }
                  return DebuggerStatement2;
                }();
                exports5.DebuggerStatement = DebuggerStatement;
                var Directive = function() {
                  function Directive2(expression, directive) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                    this.directive = directive;
                  }
                  return Directive2;
                }();
                exports5.Directive = Directive;
                var DoWhileStatement = function() {
                  function DoWhileStatement2(body, test) {
                    this.type = syntax_1.Syntax.DoWhileStatement;
                    this.body = body;
                    this.test = test;
                  }
                  return DoWhileStatement2;
                }();
                exports5.DoWhileStatement = DoWhileStatement;
                var EmptyStatement = function() {
                  function EmptyStatement2() {
                    this.type = syntax_1.Syntax.EmptyStatement;
                  }
                  return EmptyStatement2;
                }();
                exports5.EmptyStatement = EmptyStatement;
                var ExportAllDeclaration = function() {
                  function ExportAllDeclaration2(source) {
                    this.type = syntax_1.Syntax.ExportAllDeclaration;
                    this.source = source;
                  }
                  return ExportAllDeclaration2;
                }();
                exports5.ExportAllDeclaration = ExportAllDeclaration;
                var ExportDefaultDeclaration = function() {
                  function ExportDefaultDeclaration2(declaration) {
                    this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                    this.declaration = declaration;
                  }
                  return ExportDefaultDeclaration2;
                }();
                exports5.ExportDefaultDeclaration = ExportDefaultDeclaration;
                var ExportNamedDeclaration = function() {
                  function ExportNamedDeclaration2(declaration, specifiers, source) {
                    this.type = syntax_1.Syntax.ExportNamedDeclaration;
                    this.declaration = declaration;
                    this.specifiers = specifiers;
                    this.source = source;
                  }
                  return ExportNamedDeclaration2;
                }();
                exports5.ExportNamedDeclaration = ExportNamedDeclaration;
                var ExportSpecifier = function() {
                  function ExportSpecifier2(local, exported) {
                    this.type = syntax_1.Syntax.ExportSpecifier;
                    this.exported = exported;
                    this.local = local;
                  }
                  return ExportSpecifier2;
                }();
                exports5.ExportSpecifier = ExportSpecifier;
                var ExpressionStatement = function() {
                  function ExpressionStatement2(expression) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                  }
                  return ExpressionStatement2;
                }();
                exports5.ExpressionStatement = ExpressionStatement;
                var ForInStatement = function() {
                  function ForInStatement2(left, right, body) {
                    this.type = syntax_1.Syntax.ForInStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                    this.each = false;
                  }
                  return ForInStatement2;
                }();
                exports5.ForInStatement = ForInStatement;
                var ForOfStatement = function() {
                  function ForOfStatement2(left, right, body) {
                    this.type = syntax_1.Syntax.ForOfStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                  }
                  return ForOfStatement2;
                }();
                exports5.ForOfStatement = ForOfStatement;
                var ForStatement = function() {
                  function ForStatement2(init2, test, update, body) {
                    this.type = syntax_1.Syntax.ForStatement;
                    this.init = init2;
                    this.test = test;
                    this.update = update;
                    this.body = body;
                  }
                  return ForStatement2;
                }();
                exports5.ForStatement = ForStatement;
                var FunctionDeclaration = function() {
                  function FunctionDeclaration2(id, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                  }
                  return FunctionDeclaration2;
                }();
                exports5.FunctionDeclaration = FunctionDeclaration;
                var FunctionExpression = function() {
                  function FunctionExpression2(id, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                  }
                  return FunctionExpression2;
                }();
                exports5.FunctionExpression = FunctionExpression;
                var Identifier = function() {
                  function Identifier2(name2) {
                    this.type = syntax_1.Syntax.Identifier;
                    this.name = name2;
                  }
                  return Identifier2;
                }();
                exports5.Identifier = Identifier;
                var IfStatement = function() {
                  function IfStatement2(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.IfStatement;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                  }
                  return IfStatement2;
                }();
                exports5.IfStatement = IfStatement;
                var ImportDeclaration = function() {
                  function ImportDeclaration2(specifiers, source) {
                    this.type = syntax_1.Syntax.ImportDeclaration;
                    this.specifiers = specifiers;
                    this.source = source;
                  }
                  return ImportDeclaration2;
                }();
                exports5.ImportDeclaration = ImportDeclaration;
                var ImportDefaultSpecifier = function() {
                  function ImportDefaultSpecifier2(local) {
                    this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                    this.local = local;
                  }
                  return ImportDefaultSpecifier2;
                }();
                exports5.ImportDefaultSpecifier = ImportDefaultSpecifier;
                var ImportNamespaceSpecifier = function() {
                  function ImportNamespaceSpecifier2(local) {
                    this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                    this.local = local;
                  }
                  return ImportNamespaceSpecifier2;
                }();
                exports5.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
                var ImportSpecifier = function() {
                  function ImportSpecifier2(local, imported) {
                    this.type = syntax_1.Syntax.ImportSpecifier;
                    this.local = local;
                    this.imported = imported;
                  }
                  return ImportSpecifier2;
                }();
                exports5.ImportSpecifier = ImportSpecifier;
                var LabeledStatement = function() {
                  function LabeledStatement2(label, body) {
                    this.type = syntax_1.Syntax.LabeledStatement;
                    this.label = label;
                    this.body = body;
                  }
                  return LabeledStatement2;
                }();
                exports5.LabeledStatement = LabeledStatement;
                var Literal = function() {
                  function Literal2(value, raw) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                  }
                  return Literal2;
                }();
                exports5.Literal = Literal;
                var MetaProperty = function() {
                  function MetaProperty2(meta, property) {
                    this.type = syntax_1.Syntax.MetaProperty;
                    this.meta = meta;
                    this.property = property;
                  }
                  return MetaProperty2;
                }();
                exports5.MetaProperty = MetaProperty;
                var MethodDefinition = function() {
                  function MethodDefinition2(key, computed, value, kind, isStatic) {
                    this.type = syntax_1.Syntax.MethodDefinition;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.static = isStatic;
                  }
                  return MethodDefinition2;
                }();
                exports5.MethodDefinition = MethodDefinition;
                var Module = function() {
                  function Module2(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "module";
                  }
                  return Module2;
                }();
                exports5.Module = Module;
                var NewExpression = function() {
                  function NewExpression2(callee, args) {
                    this.type = syntax_1.Syntax.NewExpression;
                    this.callee = callee;
                    this.arguments = args;
                  }
                  return NewExpression2;
                }();
                exports5.NewExpression = NewExpression;
                var ObjectExpression = function() {
                  function ObjectExpression2(properties) {
                    this.type = syntax_1.Syntax.ObjectExpression;
                    this.properties = properties;
                  }
                  return ObjectExpression2;
                }();
                exports5.ObjectExpression = ObjectExpression;
                var ObjectPattern = function() {
                  function ObjectPattern2(properties) {
                    this.type = syntax_1.Syntax.ObjectPattern;
                    this.properties = properties;
                  }
                  return ObjectPattern2;
                }();
                exports5.ObjectPattern = ObjectPattern;
                var Property = function() {
                  function Property2(kind, key, computed, value, method, shorthand) {
                    this.type = syntax_1.Syntax.Property;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.method = method;
                    this.shorthand = shorthand;
                  }
                  return Property2;
                }();
                exports5.Property = Property;
                var RegexLiteral = function() {
                  function RegexLiteral2(value, raw, pattern, flags) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                    this.regex = {pattern, flags};
                  }
                  return RegexLiteral2;
                }();
                exports5.RegexLiteral = RegexLiteral;
                var RestElement = function() {
                  function RestElement2(argument) {
                    this.type = syntax_1.Syntax.RestElement;
                    this.argument = argument;
                  }
                  return RestElement2;
                }();
                exports5.RestElement = RestElement;
                var ReturnStatement = function() {
                  function ReturnStatement2(argument) {
                    this.type = syntax_1.Syntax.ReturnStatement;
                    this.argument = argument;
                  }
                  return ReturnStatement2;
                }();
                exports5.ReturnStatement = ReturnStatement;
                var Script = function() {
                  function Script2(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "script";
                  }
                  return Script2;
                }();
                exports5.Script = Script;
                var SequenceExpression = function() {
                  function SequenceExpression2(expressions2) {
                    this.type = syntax_1.Syntax.SequenceExpression;
                    this.expressions = expressions2;
                  }
                  return SequenceExpression2;
                }();
                exports5.SequenceExpression = SequenceExpression;
                var SpreadElement = function() {
                  function SpreadElement2(argument) {
                    this.type = syntax_1.Syntax.SpreadElement;
                    this.argument = argument;
                  }
                  return SpreadElement2;
                }();
                exports5.SpreadElement = SpreadElement;
                var StaticMemberExpression = function() {
                  function StaticMemberExpression2(object2, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = false;
                    this.object = object2;
                    this.property = property;
                  }
                  return StaticMemberExpression2;
                }();
                exports5.StaticMemberExpression = StaticMemberExpression;
                var Super = function() {
                  function Super2() {
                    this.type = syntax_1.Syntax.Super;
                  }
                  return Super2;
                }();
                exports5.Super = Super;
                var SwitchCase = function() {
                  function SwitchCase2(test, consequent) {
                    this.type = syntax_1.Syntax.SwitchCase;
                    this.test = test;
                    this.consequent = consequent;
                  }
                  return SwitchCase2;
                }();
                exports5.SwitchCase = SwitchCase;
                var SwitchStatement = function() {
                  function SwitchStatement2(discriminant, cases) {
                    this.type = syntax_1.Syntax.SwitchStatement;
                    this.discriminant = discriminant;
                    this.cases = cases;
                  }
                  return SwitchStatement2;
                }();
                exports5.SwitchStatement = SwitchStatement;
                var TaggedTemplateExpression = function() {
                  function TaggedTemplateExpression2(tag2, quasi) {
                    this.type = syntax_1.Syntax.TaggedTemplateExpression;
                    this.tag = tag2;
                    this.quasi = quasi;
                  }
                  return TaggedTemplateExpression2;
                }();
                exports5.TaggedTemplateExpression = TaggedTemplateExpression;
                var TemplateElement = function() {
                  function TemplateElement2(value, tail) {
                    this.type = syntax_1.Syntax.TemplateElement;
                    this.value = value;
                    this.tail = tail;
                  }
                  return TemplateElement2;
                }();
                exports5.TemplateElement = TemplateElement;
                var TemplateLiteral = function() {
                  function TemplateLiteral2(quasis, expressions2) {
                    this.type = syntax_1.Syntax.TemplateLiteral;
                    this.quasis = quasis;
                    this.expressions = expressions2;
                  }
                  return TemplateLiteral2;
                }();
                exports5.TemplateLiteral = TemplateLiteral;
                var ThisExpression = function() {
                  function ThisExpression2() {
                    this.type = syntax_1.Syntax.ThisExpression;
                  }
                  return ThisExpression2;
                }();
                exports5.ThisExpression = ThisExpression;
                var ThrowStatement = function() {
                  function ThrowStatement2(argument) {
                    this.type = syntax_1.Syntax.ThrowStatement;
                    this.argument = argument;
                  }
                  return ThrowStatement2;
                }();
                exports5.ThrowStatement = ThrowStatement;
                var TryStatement = function() {
                  function TryStatement2(block, handler, finalizer) {
                    this.type = syntax_1.Syntax.TryStatement;
                    this.block = block;
                    this.handler = handler;
                    this.finalizer = finalizer;
                  }
                  return TryStatement2;
                }();
                exports5.TryStatement = TryStatement;
                var UnaryExpression = function() {
                  function UnaryExpression2(operator, argument) {
                    this.type = syntax_1.Syntax.UnaryExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = true;
                  }
                  return UnaryExpression2;
                }();
                exports5.UnaryExpression = UnaryExpression;
                var UpdateExpression = function() {
                  function UpdateExpression2(operator, argument, prefix2) {
                    this.type = syntax_1.Syntax.UpdateExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = prefix2;
                  }
                  return UpdateExpression2;
                }();
                exports5.UpdateExpression = UpdateExpression;
                var VariableDeclaration = function() {
                  function VariableDeclaration2(declarations, kind) {
                    this.type = syntax_1.Syntax.VariableDeclaration;
                    this.declarations = declarations;
                    this.kind = kind;
                  }
                  return VariableDeclaration2;
                }();
                exports5.VariableDeclaration = VariableDeclaration;
                var VariableDeclarator = function() {
                  function VariableDeclarator2(id, init2) {
                    this.type = syntax_1.Syntax.VariableDeclarator;
                    this.id = id;
                    this.init = init2;
                  }
                  return VariableDeclarator2;
                }();
                exports5.VariableDeclarator = VariableDeclarator;
                var WhileStatement = function() {
                  function WhileStatement2(test, body) {
                    this.type = syntax_1.Syntax.WhileStatement;
                    this.test = test;
                    this.body = body;
                  }
                  return WhileStatement2;
                }();
                exports5.WhileStatement = WhileStatement;
                var WithStatement = function() {
                  function WithStatement2(object2, body) {
                    this.type = syntax_1.Syntax.WithStatement;
                    this.object = object2;
                    this.body = body;
                  }
                  return WithStatement2;
                }();
                exports5.WithStatement = WithStatement;
                var YieldExpression = function() {
                  function YieldExpression2(argument, delegate) {
                    this.type = syntax_1.Syntax.YieldExpression;
                    this.argument = argument;
                    this.delegate = delegate;
                  }
                  return YieldExpression2;
                }();
                exports5.YieldExpression = YieldExpression;
              }, function(module4, exports5, __webpack_require__) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var assert_12 = __webpack_require__(9);
                var error_handler_1 = __webpack_require__(10);
                var messages_1 = __webpack_require__(11);
                var Node3 = __webpack_require__(7);
                var scanner_1 = __webpack_require__(12);
                var syntax_1 = __webpack_require__(2);
                var token_1 = __webpack_require__(13);
                var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
                var Parser2 = function() {
                  function Parser3(code, options2, delegate) {
                    if (options2 === void 0) {
                      options2 = {};
                    }
                    this.config = {range: typeof options2.range === "boolean" && options2.range, loc: typeof options2.loc === "boolean" && options2.loc, source: null, tokens: typeof options2.tokens === "boolean" && options2.tokens, comment: typeof options2.comment === "boolean" && options2.comment, tolerant: typeof options2.tolerant === "boolean" && options2.tolerant};
                    if (this.config.loc && options2.source && options2.source !== null) {
                      this.config.source = String(options2.source);
                    }
                    this.delegate = delegate;
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = this.config.tolerant;
                    this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                    this.scanner.trackComment = this.config.comment;
                    this.operatorPrecedence = {")": 0, ";": 0, ",": 0, "=": 0, "]": 0, "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 11, "/": 11, "%": 11};
                    this.lookahead = {type: 2, value: "", lineNumber: this.scanner.lineNumber, lineStart: 0, start: 0, end: 0};
                    this.hasLineTerminator = false;
                    this.context = {isModule: false, await: false, allowIn: true, allowStrictDirective: true, allowYield: true, firstCoverInitializedNameError: null, isAssignmentTarget: false, isBindingElement: false, inFunctionBody: false, inIteration: false, inSwitch: false, labelSet: {}, strict: false};
                    this.tokens = [];
                    this.startMarker = {index: 0, line: this.scanner.lineNumber, column: 0};
                    this.lastMarker = {index: 0, line: this.scanner.lineNumber, column: 0};
                    this.nextToken();
                    this.lastMarker = {index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                  }
                  Parser3.prototype.throwError = function(messageFormat) {
                    var values = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                      values[_i - 1] = arguments[_i];
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                      assert_12.assert(idx < args.length, "Message reference must be in range");
                      return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.lastMarker.line;
                    var column = this.lastMarker.column + 1;
                    throw this.errorHandler.createError(index, line, column, msg);
                  };
                  Parser3.prototype.tolerateError = function(messageFormat) {
                    var values = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                      values[_i - 1] = arguments[_i];
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                      assert_12.assert(idx < args.length, "Message reference must be in range");
                      return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.scanner.lineNumber;
                    var column = this.lastMarker.column + 1;
                    this.errorHandler.tolerateError(index, line, column, msg);
                  };
                  Parser3.prototype.unexpectedTokenError = function(token, message) {
                    var msg = message || messages_1.Messages.UnexpectedToken;
                    var value;
                    if (token) {
                      if (!message) {
                        msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                        if (token.type === 4) {
                          if (this.scanner.isFutureReservedWord(token.value)) {
                            msg = messages_1.Messages.UnexpectedReserved;
                          } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                            msg = messages_1.Messages.StrictReservedWord;
                          }
                        }
                      }
                      value = token.value;
                    } else {
                      value = "ILLEGAL";
                    }
                    msg = msg.replace("%0", value);
                    if (token && typeof token.lineNumber === "number") {
                      var index = token.start;
                      var line = token.lineNumber;
                      var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                      var column = token.start - lastMarkerLineStart + 1;
                      return this.errorHandler.createError(index, line, column, msg);
                    } else {
                      var index = this.lastMarker.index;
                      var line = this.lastMarker.line;
                      var column = this.lastMarker.column + 1;
                      return this.errorHandler.createError(index, line, column, msg);
                    }
                  };
                  Parser3.prototype.throwUnexpectedToken = function(token, message) {
                    throw this.unexpectedTokenError(token, message);
                  };
                  Parser3.prototype.tolerateUnexpectedToken = function(token, message) {
                    this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
                  };
                  Parser3.prototype.collectComments = function() {
                    if (!this.config.comment) {
                      this.scanner.scanComments();
                    } else {
                      var comments2 = this.scanner.scanComments();
                      if (comments2.length > 0 && this.delegate) {
                        for (var i = 0; i < comments2.length; ++i) {
                          var e = comments2[i];
                          var node2 = void 0;
                          node2 = {type: e.multiLine ? "BlockComment" : "LineComment", value: this.scanner.source.slice(e.slice[0], e.slice[1])};
                          if (this.config.range) {
                            node2.range = e.range;
                          }
                          if (this.config.loc) {
                            node2.loc = e.loc;
                          }
                          var metadata = {start: {line: e.loc.start.line, column: e.loc.start.column, offset: e.range[0]}, end: {line: e.loc.end.line, column: e.loc.end.column, offset: e.range[1]}};
                          this.delegate(node2, metadata);
                        }
                      }
                    }
                  };
                  Parser3.prototype.getTokenRaw = function(token) {
                    return this.scanner.source.slice(token.start, token.end);
                  };
                  Parser3.prototype.convertToken = function(token) {
                    var t = {type: token_1.TokenName[token.type], value: this.getTokenRaw(token)};
                    if (this.config.range) {
                      t.range = [token.start, token.end];
                    }
                    if (this.config.loc) {
                      t.loc = {start: {line: this.startMarker.line, column: this.startMarker.column}, end: {line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart}};
                    }
                    if (token.type === 9) {
                      var pattern = token.pattern;
                      var flags = token.flags;
                      t.regex = {pattern, flags};
                    }
                    return t;
                  };
                  Parser3.prototype.nextToken = function() {
                    var token = this.lookahead;
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    this.collectComments();
                    if (this.scanner.index !== this.startMarker.index) {
                      this.startMarker.index = this.scanner.index;
                      this.startMarker.line = this.scanner.lineNumber;
                      this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    }
                    var next = this.scanner.lex();
                    this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                    if (next && this.context.strict && next.type === 3) {
                      if (this.scanner.isStrictModeReservedWord(next.value)) {
                        next.type = 4;
                      }
                    }
                    this.lookahead = next;
                    if (this.config.tokens && next.type !== 2) {
                      this.tokens.push(this.convertToken(next));
                    }
                    return token;
                  };
                  Parser3.prototype.nextRegexToken = function() {
                    this.collectComments();
                    var token = this.scanner.scanRegExp();
                    if (this.config.tokens) {
                      this.tokens.pop();
                      this.tokens.push(this.convertToken(token));
                    }
                    this.lookahead = token;
                    this.nextToken();
                    return token;
                  };
                  Parser3.prototype.createNode = function() {
                    return {index: this.startMarker.index, line: this.startMarker.line, column: this.startMarker.column};
                  };
                  Parser3.prototype.startNode = function(token, lastLineStart) {
                    if (lastLineStart === void 0) {
                      lastLineStart = 0;
                    }
                    var column = token.start - token.lineStart;
                    var line = token.lineNumber;
                    if (column < 0) {
                      column += lastLineStart;
                      line--;
                    }
                    return {index: token.start, line, column};
                  };
                  Parser3.prototype.finalize = function(marker, node2) {
                    if (this.config.range) {
                      node2.range = [marker.index, this.lastMarker.index];
                    }
                    if (this.config.loc) {
                      node2.loc = {start: {line: marker.line, column: marker.column}, end: {line: this.lastMarker.line, column: this.lastMarker.column}};
                      if (this.config.source) {
                        node2.loc.source = this.config.source;
                      }
                    }
                    if (this.delegate) {
                      var metadata = {start: {line: marker.line, column: marker.column, offset: marker.index}, end: {line: this.lastMarker.line, column: this.lastMarker.column, offset: this.lastMarker.index}};
                      this.delegate(node2, metadata);
                    }
                    return node2;
                  };
                  Parser3.prototype.expect = function(value) {
                    var token = this.nextToken();
                    if (token.type !== 7 || token.value !== value) {
                      this.throwUnexpectedToken(token);
                    }
                  };
                  Parser3.prototype.expectCommaSeparator = function() {
                    if (this.config.tolerant) {
                      var token = this.lookahead;
                      if (token.type === 7 && token.value === ",") {
                        this.nextToken();
                      } else if (token.type === 7 && token.value === ";") {
                        this.nextToken();
                        this.tolerateUnexpectedToken(token);
                      } else {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                      }
                    } else {
                      this.expect(",");
                    }
                  };
                  Parser3.prototype.expectKeyword = function(keyword) {
                    var token = this.nextToken();
                    if (token.type !== 4 || token.value !== keyword) {
                      this.throwUnexpectedToken(token);
                    }
                  };
                  Parser3.prototype.match = function(value) {
                    return this.lookahead.type === 7 && this.lookahead.value === value;
                  };
                  Parser3.prototype.matchKeyword = function(keyword) {
                    return this.lookahead.type === 4 && this.lookahead.value === keyword;
                  };
                  Parser3.prototype.matchContextualKeyword = function(keyword) {
                    return this.lookahead.type === 3 && this.lookahead.value === keyword;
                  };
                  Parser3.prototype.matchAssign = function() {
                    if (this.lookahead.type !== 7) {
                      return false;
                    }
                    var op = this.lookahead.value;
                    return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
                  };
                  Parser3.prototype.isolateCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result = parseFunction.call(this);
                    if (this.context.firstCoverInitializedNameError !== null) {
                      this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                    }
                    this.context.isBindingElement = previousIsBindingElement;
                    this.context.isAssignmentTarget = previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                    return result;
                  };
                  Parser3.prototype.inheritCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result = parseFunction.call(this);
                    this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                    this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                    return result;
                  };
                  Parser3.prototype.consumeSemicolon = function() {
                    if (this.match(";")) {
                      this.nextToken();
                    } else if (!this.hasLineTerminator) {
                      if (this.lookahead.type !== 2 && !this.match("}")) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      this.lastMarker.index = this.startMarker.index;
                      this.lastMarker.line = this.startMarker.line;
                      this.lastMarker.column = this.startMarker.column;
                    }
                  };
                  Parser3.prototype.parsePrimaryExpression = function() {
                    var node2 = this.createNode();
                    var expr2;
                    var token, raw;
                    switch (this.lookahead.type) {
                      case 3:
                        if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                          this.tolerateUnexpectedToken(this.lookahead);
                        }
                        expr2 = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node2, new Node3.Identifier(this.nextToken().value));
                        break;
                      case 6:
                      case 8:
                        if (this.context.strict && this.lookahead.octal) {
                          this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                        }
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        token = this.nextToken();
                        raw = this.getTokenRaw(token);
                        expr2 = this.finalize(node2, new Node3.Literal(token.value, raw));
                        break;
                      case 1:
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        token = this.nextToken();
                        raw = this.getTokenRaw(token);
                        expr2 = this.finalize(node2, new Node3.Literal(token.value === "true", raw));
                        break;
                      case 5:
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        token = this.nextToken();
                        raw = this.getTokenRaw(token);
                        expr2 = this.finalize(node2, new Node3.Literal(null, raw));
                        break;
                      case 10:
                        expr2 = this.parseTemplateLiteral();
                        break;
                      case 7:
                        switch (this.lookahead.value) {
                          case "(":
                            this.context.isBindingElement = false;
                            expr2 = this.inheritCoverGrammar(this.parseGroupExpression);
                            break;
                          case "[":
                            expr2 = this.inheritCoverGrammar(this.parseArrayInitializer);
                            break;
                          case "{":
                            expr2 = this.inheritCoverGrammar(this.parseObjectInitializer);
                            break;
                          case "/":
                          case "/=":
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            this.scanner.index = this.startMarker.index;
                            token = this.nextRegexToken();
                            raw = this.getTokenRaw(token);
                            expr2 = this.finalize(node2, new Node3.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                            break;
                          default:
                            expr2 = this.throwUnexpectedToken(this.nextToken());
                        }
                        break;
                      case 4:
                        if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                          expr2 = this.parseIdentifierName();
                        } else if (!this.context.strict && this.matchKeyword("let")) {
                          expr2 = this.finalize(node2, new Node3.Identifier(this.nextToken().value));
                        } else {
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                          if (this.matchKeyword("function")) {
                            expr2 = this.parseFunctionExpression();
                          } else if (this.matchKeyword("this")) {
                            this.nextToken();
                            expr2 = this.finalize(node2, new Node3.ThisExpression());
                          } else if (this.matchKeyword("class")) {
                            expr2 = this.parseClassExpression();
                          } else {
                            expr2 = this.throwUnexpectedToken(this.nextToken());
                          }
                        }
                        break;
                      default:
                        expr2 = this.throwUnexpectedToken(this.nextToken());
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseSpreadElement = function() {
                    var node2 = this.createNode();
                    this.expect("...");
                    var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    return this.finalize(node2, new Node3.SpreadElement(arg));
                  };
                  Parser3.prototype.parseArrayInitializer = function() {
                    var node2 = this.createNode();
                    var elements = [];
                    this.expect("[");
                    while (!this.match("]")) {
                      if (this.match(",")) {
                        this.nextToken();
                        elements.push(null);
                      } else if (this.match("...")) {
                        var element = this.parseSpreadElement();
                        if (!this.match("]")) {
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                          this.expect(",");
                        }
                        elements.push(element);
                      } else {
                        elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        if (!this.match("]")) {
                          this.expect(",");
                        }
                      }
                    }
                    this.expect("]");
                    return this.finalize(node2, new Node3.ArrayExpression(elements));
                  };
                  Parser3.prototype.parsePropertyMethod = function(params) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = params.simple;
                    var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                    if (this.context.strict && params.firstRestricted) {
                      this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                    }
                    if (this.context.strict && params.stricted) {
                      this.tolerateUnexpectedToken(params.stricted, params.message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    return body;
                  };
                  Parser3.prototype.parsePropertyMethodFunction = function() {
                    var isGenerator = false;
                    var node2 = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node3.FunctionExpression(null, params.params, method, isGenerator));
                  };
                  Parser3.prototype.parsePropertyMethodAsyncFunction = function() {
                    var node2 = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = false;
                    this.context.await = true;
                    var params = this.parseFormalParameters();
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                    return this.finalize(node2, new Node3.AsyncFunctionExpression(null, params.params, method));
                  };
                  Parser3.prototype.parseObjectPropertyKey = function() {
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    var key;
                    switch (token.type) {
                      case 8:
                      case 6:
                        if (this.context.strict && token.octal) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                        }
                        var raw = this.getTokenRaw(token);
                        key = this.finalize(node2, new Node3.Literal(token.value, raw));
                        break;
                      case 3:
                      case 1:
                      case 5:
                      case 4:
                        key = this.finalize(node2, new Node3.Identifier(token.value));
                        break;
                      case 7:
                        if (token.value === "[") {
                          key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          this.expect("]");
                        } else {
                          key = this.throwUnexpectedToken(token);
                        }
                        break;
                      default:
                        key = this.throwUnexpectedToken(token);
                    }
                    return key;
                  };
                  Parser3.prototype.isPropertyKey = function(key, value) {
                    return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
                  };
                  Parser3.prototype.parseObjectProperty = function(hasProto) {
                    var node2 = this.createNode();
                    var token = this.lookahead;
                    var kind;
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method = false;
                    var shorthand = false;
                    var isAsync = false;
                    if (token.type === 3) {
                      var id = token.value;
                      this.nextToken();
                      computed = this.match("[");
                      isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                      key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node2, new Node3.Identifier(id));
                    } else if (this.match("*")) {
                      this.nextToken();
                    } else {
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                      kind = "get";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      this.context.allowYield = false;
                      value = this.parseGetterMethod();
                    } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                      kind = "set";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      value = this.parseSetterMethod();
                    } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                      kind = "init";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      value = this.parseGeneratorMethod();
                      method = true;
                    } else {
                      if (!key) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      kind = "init";
                      if (this.match(":") && !isAsync) {
                        if (!computed && this.isPropertyKey(key, "__proto__")) {
                          if (hasProto.value) {
                            this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                          }
                          hasProto.value = true;
                        }
                        this.nextToken();
                        value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                      } else if (this.match("(")) {
                        value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                        method = true;
                      } else if (token.type === 3) {
                        var id = this.finalize(node2, new Node3.Identifier(token.value));
                        if (this.match("=")) {
                          this.context.firstCoverInitializedNameError = this.lookahead;
                          this.nextToken();
                          shorthand = true;
                          var init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          value = this.finalize(node2, new Node3.AssignmentPattern(id, init2));
                        } else {
                          shorthand = true;
                          value = id;
                        }
                      } else {
                        this.throwUnexpectedToken(this.nextToken());
                      }
                    }
                    return this.finalize(node2, new Node3.Property(kind, key, computed, value, method, shorthand));
                  };
                  Parser3.prototype.parseObjectInitializer = function() {
                    var node2 = this.createNode();
                    this.expect("{");
                    var properties = [];
                    var hasProto = {value: false};
                    while (!this.match("}")) {
                      properties.push(this.parseObjectProperty(hasProto));
                      if (!this.match("}")) {
                        this.expectCommaSeparator();
                      }
                    }
                    this.expect("}");
                    return this.finalize(node2, new Node3.ObjectExpression(properties));
                  };
                  Parser3.prototype.parseTemplateHead = function() {
                    assert_12.assert(this.lookahead.head, "Template literal must start with a template head");
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node2, new Node3.TemplateElement({raw, cooked}, token.tail));
                  };
                  Parser3.prototype.parseTemplateElement = function() {
                    if (this.lookahead.type !== 10) {
                      this.throwUnexpectedToken();
                    }
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node2, new Node3.TemplateElement({raw, cooked}, token.tail));
                  };
                  Parser3.prototype.parseTemplateLiteral = function() {
                    var node2 = this.createNode();
                    var expressions2 = [];
                    var quasis = [];
                    var quasi = this.parseTemplateHead();
                    quasis.push(quasi);
                    while (!quasi.tail) {
                      expressions2.push(this.parseExpression());
                      quasi = this.parseTemplateElement();
                      quasis.push(quasi);
                    }
                    return this.finalize(node2, new Node3.TemplateLiteral(quasis, expressions2));
                  };
                  Parser3.prototype.reinterpretExpressionAsPattern = function(expr2) {
                    switch (expr2.type) {
                      case syntax_1.Syntax.Identifier:
                      case syntax_1.Syntax.MemberExpression:
                      case syntax_1.Syntax.RestElement:
                      case syntax_1.Syntax.AssignmentPattern:
                        break;
                      case syntax_1.Syntax.SpreadElement:
                        expr2.type = syntax_1.Syntax.RestElement;
                        this.reinterpretExpressionAsPattern(expr2.argument);
                        break;
                      case syntax_1.Syntax.ArrayExpression:
                        expr2.type = syntax_1.Syntax.ArrayPattern;
                        for (var i = 0; i < expr2.elements.length; i++) {
                          if (expr2.elements[i] !== null) {
                            this.reinterpretExpressionAsPattern(expr2.elements[i]);
                          }
                        }
                        break;
                      case syntax_1.Syntax.ObjectExpression:
                        expr2.type = syntax_1.Syntax.ObjectPattern;
                        for (var i = 0; i < expr2.properties.length; i++) {
                          this.reinterpretExpressionAsPattern(expr2.properties[i].value);
                        }
                        break;
                      case syntax_1.Syntax.AssignmentExpression:
                        expr2.type = syntax_1.Syntax.AssignmentPattern;
                        delete expr2.operator;
                        this.reinterpretExpressionAsPattern(expr2.left);
                        break;
                    }
                  };
                  Parser3.prototype.parseGroupExpression = function() {
                    var expr2;
                    this.expect("(");
                    if (this.match(")")) {
                      this.nextToken();
                      if (!this.match("=>")) {
                        this.expect("=>");
                      }
                      expr2 = {type: ArrowParameterPlaceHolder, params: [], async: false};
                    } else {
                      var startToken = this.lookahead;
                      var params = [];
                      if (this.match("...")) {
                        expr2 = this.parseRestElement(params);
                        this.expect(")");
                        if (!this.match("=>")) {
                          this.expect("=>");
                        }
                        expr2 = {type: ArrowParameterPlaceHolder, params: [expr2], async: false};
                      } else {
                        var arrow = false;
                        this.context.isBindingElement = true;
                        expr2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                        if (this.match(",")) {
                          var expressions2 = [];
                          this.context.isAssignmentTarget = false;
                          expressions2.push(expr2);
                          while (this.lookahead.type !== 2) {
                            if (!this.match(",")) {
                              break;
                            }
                            this.nextToken();
                            if (this.match(")")) {
                              this.nextToken();
                              for (var i = 0; i < expressions2.length; i++) {
                                this.reinterpretExpressionAsPattern(expressions2[i]);
                              }
                              arrow = true;
                              expr2 = {type: ArrowParameterPlaceHolder, params: expressions2, async: false};
                            } else if (this.match("...")) {
                              if (!this.context.isBindingElement) {
                                this.throwUnexpectedToken(this.lookahead);
                              }
                              expressions2.push(this.parseRestElement(params));
                              this.expect(")");
                              if (!this.match("=>")) {
                                this.expect("=>");
                              }
                              this.context.isBindingElement = false;
                              for (var i = 0; i < expressions2.length; i++) {
                                this.reinterpretExpressionAsPattern(expressions2[i]);
                              }
                              arrow = true;
                              expr2 = {type: ArrowParameterPlaceHolder, params: expressions2, async: false};
                            } else {
                              expressions2.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                            }
                            if (arrow) {
                              break;
                            }
                          }
                          if (!arrow) {
                            expr2 = this.finalize(this.startNode(startToken), new Node3.SequenceExpression(expressions2));
                          }
                        }
                        if (!arrow) {
                          this.expect(")");
                          if (this.match("=>")) {
                            if (expr2.type === syntax_1.Syntax.Identifier && expr2.name === "yield") {
                              arrow = true;
                              expr2 = {type: ArrowParameterPlaceHolder, params: [expr2], async: false};
                            }
                            if (!arrow) {
                              if (!this.context.isBindingElement) {
                                this.throwUnexpectedToken(this.lookahead);
                              }
                              if (expr2.type === syntax_1.Syntax.SequenceExpression) {
                                for (var i = 0; i < expr2.expressions.length; i++) {
                                  this.reinterpretExpressionAsPattern(expr2.expressions[i]);
                                }
                              } else {
                                this.reinterpretExpressionAsPattern(expr2);
                              }
                              var parameters = expr2.type === syntax_1.Syntax.SequenceExpression ? expr2.expressions : [expr2];
                              expr2 = {type: ArrowParameterPlaceHolder, params: parameters, async: false};
                            }
                          }
                          this.context.isBindingElement = false;
                        }
                      }
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                      while (true) {
                        var expr2 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                        args.push(expr2);
                        if (this.match(")")) {
                          break;
                        }
                        this.expectCommaSeparator();
                        if (this.match(")")) {
                          break;
                        }
                      }
                    }
                    this.expect(")");
                    return args;
                  };
                  Parser3.prototype.isIdentifierName = function(token) {
                    return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
                  };
                  Parser3.prototype.parseIdentifierName = function() {
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    if (!this.isIdentifierName(token)) {
                      this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node2, new Node3.Identifier(token.value));
                  };
                  Parser3.prototype.parseNewExpression = function() {
                    var node2 = this.createNode();
                    var id = this.parseIdentifierName();
                    assert_12.assert(id.name === "new", "New expression must start with `new`");
                    var expr2;
                    if (this.match(".")) {
                      this.nextToken();
                      if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                        var property = this.parseIdentifierName();
                        expr2 = new Node3.MetaProperty(id, property);
                      } else {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    } else {
                      var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                      var args = this.match("(") ? this.parseArguments() : [];
                      expr2 = new Node3.NewExpression(callee, args);
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    }
                    return this.finalize(node2, expr2);
                  };
                  Parser3.prototype.parseAsyncArgument = function() {
                    var arg = this.parseAssignmentExpression();
                    this.context.firstCoverInitializedNameError = null;
                    return arg;
                  };
                  Parser3.prototype.parseAsyncArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                      while (true) {
                        var expr2 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                        args.push(expr2);
                        if (this.match(")")) {
                          break;
                        }
                        this.expectCommaSeparator();
                        if (this.match(")")) {
                          break;
                        }
                      }
                    }
                    this.expect(")");
                    return args;
                  };
                  Parser3.prototype.parseLeftHandSideExpressionAllowCall = function() {
                    var startToken = this.lookahead;
                    var maybeAsync = this.matchContextualKeyword("async");
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    var expr2;
                    if (this.matchKeyword("super") && this.context.inFunctionBody) {
                      expr2 = this.createNode();
                      this.nextToken();
                      expr2 = this.finalize(expr2, new Node3.Super());
                      if (!this.match("(") && !this.match(".") && !this.match("[")) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    } else {
                      expr2 = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    }
                    while (true) {
                      if (this.match(".")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect(".");
                        var property = this.parseIdentifierName();
                        expr2 = this.finalize(this.startNode(startToken), new Node3.StaticMemberExpression(expr2, property));
                      } else if (this.match("(")) {
                        var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = false;
                        var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                        expr2 = this.finalize(this.startNode(startToken), new Node3.CallExpression(expr2, args));
                        if (asyncArrow && this.match("=>")) {
                          for (var i = 0; i < args.length; ++i) {
                            this.reinterpretExpressionAsPattern(args[i]);
                          }
                          expr2 = {type: ArrowParameterPlaceHolder, params: args, async: true};
                        }
                      } else if (this.match("[")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect("[");
                        var property = this.isolateCoverGrammar(this.parseExpression);
                        this.expect("]");
                        expr2 = this.finalize(this.startNode(startToken), new Node3.ComputedMemberExpression(expr2, property));
                      } else if (this.lookahead.type === 10 && this.lookahead.head) {
                        var quasi = this.parseTemplateLiteral();
                        expr2 = this.finalize(this.startNode(startToken), new Node3.TaggedTemplateExpression(expr2, quasi));
                      } else {
                        break;
                      }
                    }
                    this.context.allowIn = previousAllowIn;
                    return expr2;
                  };
                  Parser3.prototype.parseSuper = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("super");
                    if (!this.match("[") && !this.match(".")) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    return this.finalize(node2, new Node3.Super());
                  };
                  Parser3.prototype.parseLeftHandSideExpression = function() {
                    assert_12.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                    var node2 = this.startNode(this.lookahead);
                    var expr2 = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    while (true) {
                      if (this.match("[")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect("[");
                        var property = this.isolateCoverGrammar(this.parseExpression);
                        this.expect("]");
                        expr2 = this.finalize(node2, new Node3.ComputedMemberExpression(expr2, property));
                      } else if (this.match(".")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect(".");
                        var property = this.parseIdentifierName();
                        expr2 = this.finalize(node2, new Node3.StaticMemberExpression(expr2, property));
                      } else if (this.lookahead.type === 10 && this.lookahead.head) {
                        var quasi = this.parseTemplateLiteral();
                        expr2 = this.finalize(node2, new Node3.TaggedTemplateExpression(expr2, quasi));
                      } else {
                        break;
                      }
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseUpdateExpression = function() {
                    var expr2;
                    var startToken = this.lookahead;
                    if (this.match("++") || this.match("--")) {
                      var node2 = this.startNode(startToken);
                      var token = this.nextToken();
                      expr2 = this.inheritCoverGrammar(this.parseUnaryExpression);
                      if (this.context.strict && expr2.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr2.name)) {
                        this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                      }
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      var prefix2 = true;
                      expr2 = this.finalize(node2, new Node3.UpdateExpression(token.value, expr2, prefix2));
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else {
                      expr2 = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                      if (!this.hasLineTerminator && this.lookahead.type === 7) {
                        if (this.match("++") || this.match("--")) {
                          if (this.context.strict && expr2.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr2.name)) {
                            this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                          }
                          if (!this.context.isAssignmentTarget) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                          }
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                          var operator = this.nextToken().value;
                          var prefix2 = false;
                          expr2 = this.finalize(this.startNode(startToken), new Node3.UpdateExpression(operator, expr2, prefix2));
                        }
                      }
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseAwaitExpression = function() {
                    var node2 = this.createNode();
                    this.nextToken();
                    var argument = this.parseUnaryExpression();
                    return this.finalize(node2, new Node3.AwaitExpression(argument));
                  };
                  Parser3.prototype.parseUnaryExpression = function() {
                    var expr2;
                    if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                      var node2 = this.startNode(this.lookahead);
                      var token = this.nextToken();
                      expr2 = this.inheritCoverGrammar(this.parseUnaryExpression);
                      expr2 = this.finalize(node2, new Node3.UnaryExpression(token.value, expr2));
                      if (this.context.strict && expr2.operator === "delete" && expr2.argument.type === syntax_1.Syntax.Identifier) {
                        this.tolerateError(messages_1.Messages.StrictDelete);
                      }
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else if (this.context.await && this.matchContextualKeyword("await")) {
                      expr2 = this.parseAwaitExpression();
                    } else {
                      expr2 = this.parseUpdateExpression();
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseExponentiationExpression = function() {
                    var startToken = this.lookahead;
                    var expr2 = this.inheritCoverGrammar(this.parseUnaryExpression);
                    if (expr2.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                      this.nextToken();
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var left = expr2;
                      var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                      expr2 = this.finalize(this.startNode(startToken), new Node3.BinaryExpression("**", left, right));
                    }
                    return expr2;
                  };
                  Parser3.prototype.binaryPrecedence = function(token) {
                    var op = token.value;
                    var precedence;
                    if (token.type === 7) {
                      precedence = this.operatorPrecedence[op] || 0;
                    } else if (token.type === 4) {
                      precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                    } else {
                      precedence = 0;
                    }
                    return precedence;
                  };
                  Parser3.prototype.parseBinaryExpression = function() {
                    var startToken = this.lookahead;
                    var expr2 = this.inheritCoverGrammar(this.parseExponentiationExpression);
                    var token = this.lookahead;
                    var prec = this.binaryPrecedence(token);
                    if (prec > 0) {
                      this.nextToken();
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var markers = [startToken, this.lookahead];
                      var left = expr2;
                      var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                      var stack = [left, token.value, right];
                      var precedences = [prec];
                      while (true) {
                        prec = this.binaryPrecedence(this.lookahead);
                        if (prec <= 0) {
                          break;
                        }
                        while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                          right = stack.pop();
                          var operator = stack.pop();
                          precedences.pop();
                          left = stack.pop();
                          markers.pop();
                          var node2 = this.startNode(markers[markers.length - 1]);
                          stack.push(this.finalize(node2, new Node3.BinaryExpression(operator, left, right)));
                        }
                        stack.push(this.nextToken().value);
                        precedences.push(prec);
                        markers.push(this.lookahead);
                        stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                      }
                      var i = stack.length - 1;
                      expr2 = stack[i];
                      var lastMarker = markers.pop();
                      while (i > 1) {
                        var marker = markers.pop();
                        var lastLineStart = lastMarker && lastMarker.lineStart;
                        var node2 = this.startNode(marker, lastLineStart);
                        var operator = stack[i - 1];
                        expr2 = this.finalize(node2, new Node3.BinaryExpression(operator, stack[i - 2], expr2));
                        i -= 2;
                        lastMarker = marker;
                      }
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseConditionalExpression = function() {
                    var startToken = this.lookahead;
                    var expr2 = this.inheritCoverGrammar(this.parseBinaryExpression);
                    if (this.match("?")) {
                      this.nextToken();
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = true;
                      var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      this.context.allowIn = previousAllowIn;
                      this.expect(":");
                      var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      expr2 = this.finalize(this.startNode(startToken), new Node3.ConditionalExpression(expr2, consequent, alternate));
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    }
                    return expr2;
                  };
                  Parser3.prototype.checkPatternParam = function(options2, param) {
                    switch (param.type) {
                      case syntax_1.Syntax.Identifier:
                        this.validateParam(options2, param, param.name);
                        break;
                      case syntax_1.Syntax.RestElement:
                        this.checkPatternParam(options2, param.argument);
                        break;
                      case syntax_1.Syntax.AssignmentPattern:
                        this.checkPatternParam(options2, param.left);
                        break;
                      case syntax_1.Syntax.ArrayPattern:
                        for (var i = 0; i < param.elements.length; i++) {
                          if (param.elements[i] !== null) {
                            this.checkPatternParam(options2, param.elements[i]);
                          }
                        }
                        break;
                      case syntax_1.Syntax.ObjectPattern:
                        for (var i = 0; i < param.properties.length; i++) {
                          this.checkPatternParam(options2, param.properties[i].value);
                        }
                        break;
                    }
                    options2.simple = options2.simple && param instanceof Node3.Identifier;
                  };
                  Parser3.prototype.reinterpretAsCoverFormalsList = function(expr2) {
                    var params = [expr2];
                    var options2;
                    var asyncArrow = false;
                    switch (expr2.type) {
                      case syntax_1.Syntax.Identifier:
                        break;
                      case ArrowParameterPlaceHolder:
                        params = expr2.params;
                        asyncArrow = expr2.async;
                        break;
                      default:
                        return null;
                    }
                    options2 = {simple: true, paramSet: {}};
                    for (var i = 0; i < params.length; ++i) {
                      var param = params[i];
                      if (param.type === syntax_1.Syntax.AssignmentPattern) {
                        if (param.right.type === syntax_1.Syntax.YieldExpression) {
                          if (param.right.argument) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          param.right.type = syntax_1.Syntax.Identifier;
                          param.right.name = "yield";
                          delete param.right.argument;
                          delete param.right.delegate;
                        }
                      } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      this.checkPatternParam(options2, param);
                      params[i] = param;
                    }
                    if (this.context.strict || !this.context.allowYield) {
                      for (var i = 0; i < params.length; ++i) {
                        var param = params[i];
                        if (param.type === syntax_1.Syntax.YieldExpression) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                      }
                    }
                    if (options2.message === messages_1.Messages.StrictParamDupe) {
                      var token = this.context.strict ? options2.stricted : options2.firstRestricted;
                      this.throwUnexpectedToken(token, options2.message);
                    }
                    return {simple: options2.simple, params, stricted: options2.stricted, firstRestricted: options2.firstRestricted, message: options2.message};
                  };
                  Parser3.prototype.parseAssignmentExpression = function() {
                    var expr2;
                    if (!this.context.allowYield && this.matchKeyword("yield")) {
                      expr2 = this.parseYieldExpression();
                    } else {
                      var startToken = this.lookahead;
                      var token = startToken;
                      expr2 = this.parseConditionalExpression();
                      if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                        if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                          var arg = this.parsePrimaryExpression();
                          this.reinterpretExpressionAsPattern(arg);
                          expr2 = {type: ArrowParameterPlaceHolder, params: [arg], async: true};
                        }
                      }
                      if (expr2.type === ArrowParameterPlaceHolder || this.match("=>")) {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        var isAsync = expr2.async;
                        var list = this.reinterpretAsCoverFormalsList(expr2);
                        if (list) {
                          if (this.hasLineTerminator) {
                            this.tolerateUnexpectedToken(this.lookahead);
                          }
                          this.context.firstCoverInitializedNameError = null;
                          var previousStrict = this.context.strict;
                          var previousAllowStrictDirective = this.context.allowStrictDirective;
                          this.context.allowStrictDirective = list.simple;
                          var previousAllowYield = this.context.allowYield;
                          var previousAwait = this.context.await;
                          this.context.allowYield = true;
                          this.context.await = isAsync;
                          var node2 = this.startNode(startToken);
                          this.expect("=>");
                          var body = void 0;
                          if (this.match("{")) {
                            var previousAllowIn = this.context.allowIn;
                            this.context.allowIn = true;
                            body = this.parseFunctionSourceElements();
                            this.context.allowIn = previousAllowIn;
                          } else {
                            body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          }
                          var expression = body.type !== syntax_1.Syntax.BlockStatement;
                          if (this.context.strict && list.firstRestricted) {
                            this.throwUnexpectedToken(list.firstRestricted, list.message);
                          }
                          if (this.context.strict && list.stricted) {
                            this.tolerateUnexpectedToken(list.stricted, list.message);
                          }
                          expr2 = isAsync ? this.finalize(node2, new Node3.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node2, new Node3.ArrowFunctionExpression(list.params, body, expression));
                          this.context.strict = previousStrict;
                          this.context.allowStrictDirective = previousAllowStrictDirective;
                          this.context.allowYield = previousAllowYield;
                          this.context.await = previousAwait;
                        }
                      } else {
                        if (this.matchAssign()) {
                          if (!this.context.isAssignmentTarget) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                          }
                          if (this.context.strict && expr2.type === syntax_1.Syntax.Identifier) {
                            var id = expr2;
                            if (this.scanner.isRestrictedWord(id.name)) {
                              this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                            }
                            if (this.scanner.isStrictModeReservedWord(id.name)) {
                              this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                            }
                          }
                          if (!this.match("=")) {
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                          } else {
                            this.reinterpretExpressionAsPattern(expr2);
                          }
                          token = this.nextToken();
                          var operator = token.value;
                          var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          expr2 = this.finalize(this.startNode(startToken), new Node3.AssignmentExpression(operator, expr2, right));
                          this.context.firstCoverInitializedNameError = null;
                        }
                      }
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseExpression = function() {
                    var startToken = this.lookahead;
                    var expr2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (this.match(",")) {
                      var expressions2 = [];
                      expressions2.push(expr2);
                      while (this.lookahead.type !== 2) {
                        if (!this.match(",")) {
                          break;
                        }
                        this.nextToken();
                        expressions2.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      }
                      expr2 = this.finalize(this.startNode(startToken), new Node3.SequenceExpression(expressions2));
                    }
                    return expr2;
                  };
                  Parser3.prototype.parseStatementListItem = function() {
                    var statement;
                    this.context.isAssignmentTarget = true;
                    this.context.isBindingElement = true;
                    if (this.lookahead.type === 4) {
                      switch (this.lookahead.value) {
                        case "export":
                          if (!this.context.isModule) {
                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                          }
                          statement = this.parseExportDeclaration();
                          break;
                        case "import":
                          if (!this.context.isModule) {
                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                          }
                          statement = this.parseImportDeclaration();
                          break;
                        case "const":
                          statement = this.parseLexicalDeclaration({inFor: false});
                          break;
                        case "function":
                          statement = this.parseFunctionDeclaration();
                          break;
                        case "class":
                          statement = this.parseClassDeclaration();
                          break;
                        case "let":
                          statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({inFor: false}) : this.parseStatement();
                          break;
                        default:
                          statement = this.parseStatement();
                          break;
                      }
                    } else {
                      statement = this.parseStatement();
                    }
                    return statement;
                  };
                  Parser3.prototype.parseBlock = function() {
                    var node2 = this.createNode();
                    this.expect("{");
                    var block = [];
                    while (true) {
                      if (this.match("}")) {
                        break;
                      }
                      block.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    return this.finalize(node2, new Node3.BlockStatement(block));
                  };
                  Parser3.prototype.parseLexicalBinding = function(kind, options2) {
                    var node2 = this.createNode();
                    var params = [];
                    var id = this.parsePattern(params, kind);
                    if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                      if (this.scanner.isRestrictedWord(id.name)) {
                        this.tolerateError(messages_1.Messages.StrictVarName);
                      }
                    }
                    var init2 = null;
                    if (kind === "const") {
                      if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                        if (this.match("=")) {
                          this.nextToken();
                          init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        } else {
                          this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                        }
                      }
                    } else if (!options2.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                      this.expect("=");
                      init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    return this.finalize(node2, new Node3.VariableDeclarator(id, init2));
                  };
                  Parser3.prototype.parseBindingList = function(kind, options2) {
                    var list = [this.parseLexicalBinding(kind, options2)];
                    while (this.match(",")) {
                      this.nextToken();
                      list.push(this.parseLexicalBinding(kind, options2));
                    }
                    return list;
                  };
                  Parser3.prototype.isLexicalDeclaration = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.scanner.lex();
                    this.scanner.restoreState(state);
                    return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
                  };
                  Parser3.prototype.parseLexicalDeclaration = function(options2) {
                    var node2 = this.createNode();
                    var kind = this.nextToken().value;
                    assert_12.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                    var declarations = this.parseBindingList(kind, options2);
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node3.VariableDeclaration(declarations, kind));
                  };
                  Parser3.prototype.parseBindingRestElement = function(params, kind) {
                    var node2 = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params, kind);
                    return this.finalize(node2, new Node3.RestElement(arg));
                  };
                  Parser3.prototype.parseArrayPattern = function(params, kind) {
                    var node2 = this.createNode();
                    this.expect("[");
                    var elements = [];
                    while (!this.match("]")) {
                      if (this.match(",")) {
                        this.nextToken();
                        elements.push(null);
                      } else {
                        if (this.match("...")) {
                          elements.push(this.parseBindingRestElement(params, kind));
                          break;
                        } else {
                          elements.push(this.parsePatternWithDefault(params, kind));
                        }
                        if (!this.match("]")) {
                          this.expect(",");
                        }
                      }
                    }
                    this.expect("]");
                    return this.finalize(node2, new Node3.ArrayPattern(elements));
                  };
                  Parser3.prototype.parsePropertyPattern = function(params, kind) {
                    var node2 = this.createNode();
                    var computed = false;
                    var shorthand = false;
                    var method = false;
                    var key;
                    var value;
                    if (this.lookahead.type === 3) {
                      var keyToken = this.lookahead;
                      key = this.parseVariableIdentifier();
                      var init2 = this.finalize(node2, new Node3.Identifier(keyToken.value));
                      if (this.match("=")) {
                        params.push(keyToken);
                        shorthand = true;
                        this.nextToken();
                        var expr2 = this.parseAssignmentExpression();
                        value = this.finalize(this.startNode(keyToken), new Node3.AssignmentPattern(init2, expr2));
                      } else if (!this.match(":")) {
                        params.push(keyToken);
                        shorthand = true;
                        value = init2;
                      } else {
                        this.expect(":");
                        value = this.parsePatternWithDefault(params, kind);
                      }
                    } else {
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      this.expect(":");
                      value = this.parsePatternWithDefault(params, kind);
                    }
                    return this.finalize(node2, new Node3.Property("init", key, computed, value, method, shorthand));
                  };
                  Parser3.prototype.parseObjectPattern = function(params, kind) {
                    var node2 = this.createNode();
                    var properties = [];
                    this.expect("{");
                    while (!this.match("}")) {
                      properties.push(this.parsePropertyPattern(params, kind));
                      if (!this.match("}")) {
                        this.expect(",");
                      }
                    }
                    this.expect("}");
                    return this.finalize(node2, new Node3.ObjectPattern(properties));
                  };
                  Parser3.prototype.parsePattern = function(params, kind) {
                    var pattern;
                    if (this.match("[")) {
                      pattern = this.parseArrayPattern(params, kind);
                    } else if (this.match("{")) {
                      pattern = this.parseObjectPattern(params, kind);
                    } else {
                      if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                      }
                      params.push(this.lookahead);
                      pattern = this.parseVariableIdentifier(kind);
                    }
                    return pattern;
                  };
                  Parser3.prototype.parsePatternWithDefault = function(params, kind) {
                    var startToken = this.lookahead;
                    var pattern = this.parsePattern(params, kind);
                    if (this.match("=")) {
                      this.nextToken();
                      var previousAllowYield = this.context.allowYield;
                      this.context.allowYield = true;
                      var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      this.context.allowYield = previousAllowYield;
                      pattern = this.finalize(this.startNode(startToken), new Node3.AssignmentPattern(pattern, right));
                    }
                    return pattern;
                  };
                  Parser3.prototype.parseVariableIdentifier = function(kind) {
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    if (token.type === 4 && token.value === "yield") {
                      if (this.context.strict) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      } else if (!this.context.allowYield) {
                        this.throwUnexpectedToken(token);
                      }
                    } else if (token.type !== 3) {
                      if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      } else {
                        if (this.context.strict || token.value !== "let" || kind !== "var") {
                          this.throwUnexpectedToken(token);
                        }
                      }
                    } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                      this.tolerateUnexpectedToken(token);
                    }
                    return this.finalize(node2, new Node3.Identifier(token.value));
                  };
                  Parser3.prototype.parseVariableDeclaration = function(options2) {
                    var node2 = this.createNode();
                    var params = [];
                    var id = this.parsePattern(params, "var");
                    if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                      if (this.scanner.isRestrictedWord(id.name)) {
                        this.tolerateError(messages_1.Messages.StrictVarName);
                      }
                    }
                    var init2 = null;
                    if (this.match("=")) {
                      this.nextToken();
                      init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    } else if (id.type !== syntax_1.Syntax.Identifier && !options2.inFor) {
                      this.expect("=");
                    }
                    return this.finalize(node2, new Node3.VariableDeclarator(id, init2));
                  };
                  Parser3.prototype.parseVariableDeclarationList = function(options2) {
                    var opt = {inFor: options2.inFor};
                    var list = [];
                    list.push(this.parseVariableDeclaration(opt));
                    while (this.match(",")) {
                      this.nextToken();
                      list.push(this.parseVariableDeclaration(opt));
                    }
                    return list;
                  };
                  Parser3.prototype.parseVariableStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("var");
                    var declarations = this.parseVariableDeclarationList({inFor: false});
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node3.VariableDeclaration(declarations, "var"));
                  };
                  Parser3.prototype.parseEmptyStatement = function() {
                    var node2 = this.createNode();
                    this.expect(";");
                    return this.finalize(node2, new Node3.EmptyStatement());
                  };
                  Parser3.prototype.parseExpressionStatement = function() {
                    var node2 = this.createNode();
                    var expr2 = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node3.ExpressionStatement(expr2));
                  };
                  Parser3.prototype.parseIfClause = function() {
                    if (this.context.strict && this.matchKeyword("function")) {
                      this.tolerateError(messages_1.Messages.StrictFunction);
                    }
                    return this.parseStatement();
                  };
                  Parser3.prototype.parseIfStatement = function() {
                    var node2 = this.createNode();
                    var consequent;
                    var alternate = null;
                    this.expectKeyword("if");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      consequent = this.finalize(this.createNode(), new Node3.EmptyStatement());
                    } else {
                      this.expect(")");
                      consequent = this.parseIfClause();
                      if (this.matchKeyword("else")) {
                        this.nextToken();
                        alternate = this.parseIfClause();
                      }
                    }
                    return this.finalize(node2, new Node3.IfStatement(test, consequent, alternate));
                  };
                  Parser3.prototype.parseDoWhileStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("do");
                    var previousInIteration = this.context.inIteration;
                    this.context.inIteration = true;
                    var body = this.parseStatement();
                    this.context.inIteration = previousInIteration;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                    } else {
                      this.expect(")");
                      if (this.match(";")) {
                        this.nextToken();
                      }
                    }
                    return this.finalize(node2, new Node3.DoWhileStatement(body, test));
                  };
                  Parser3.prototype.parseWhileStatement = function() {
                    var node2 = this.createNode();
                    var body;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      body = this.finalize(this.createNode(), new Node3.EmptyStatement());
                    } else {
                      this.expect(")");
                      var previousInIteration = this.context.inIteration;
                      this.context.inIteration = true;
                      body = this.parseStatement();
                      this.context.inIteration = previousInIteration;
                    }
                    return this.finalize(node2, new Node3.WhileStatement(test, body));
                  };
                  Parser3.prototype.parseForStatement = function() {
                    var init2 = null;
                    var test = null;
                    var update = null;
                    var forIn = true;
                    var left, right;
                    var node2 = this.createNode();
                    this.expectKeyword("for");
                    this.expect("(");
                    if (this.match(";")) {
                      this.nextToken();
                    } else {
                      if (this.matchKeyword("var")) {
                        init2 = this.createNode();
                        this.nextToken();
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = false;
                        var declarations = this.parseVariableDeclarationList({inFor: true});
                        this.context.allowIn = previousAllowIn;
                        if (declarations.length === 1 && this.matchKeyword("in")) {
                          var decl = declarations[0];
                          if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                            this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                          }
                          init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, "var"));
                          this.nextToken();
                          left = init2;
                          right = this.parseExpression();
                          init2 = null;
                        } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                          init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, "var"));
                          this.nextToken();
                          left = init2;
                          right = this.parseAssignmentExpression();
                          init2 = null;
                          forIn = false;
                        } else {
                          init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, "var"));
                          this.expect(";");
                        }
                      } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                        init2 = this.createNode();
                        var kind = this.nextToken().value;
                        if (!this.context.strict && this.lookahead.value === "in") {
                          init2 = this.finalize(init2, new Node3.Identifier(kind));
                          this.nextToken();
                          left = init2;
                          right = this.parseExpression();
                          init2 = null;
                        } else {
                          var previousAllowIn = this.context.allowIn;
                          this.context.allowIn = false;
                          var declarations = this.parseBindingList(kind, {inFor: true});
                          this.context.allowIn = previousAllowIn;
                          if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                            init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, kind));
                            this.nextToken();
                            left = init2;
                            right = this.parseExpression();
                            init2 = null;
                          } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                            init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, kind));
                            this.nextToken();
                            left = init2;
                            right = this.parseAssignmentExpression();
                            init2 = null;
                            forIn = false;
                          } else {
                            this.consumeSemicolon();
                            init2 = this.finalize(init2, new Node3.VariableDeclaration(declarations, kind));
                          }
                        }
                      } else {
                        var initStartToken = this.lookahead;
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = false;
                        init2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                        this.context.allowIn = previousAllowIn;
                        if (this.matchKeyword("in")) {
                          if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                          }
                          this.nextToken();
                          this.reinterpretExpressionAsPattern(init2);
                          left = init2;
                          right = this.parseExpression();
                          init2 = null;
                        } else if (this.matchContextualKeyword("of")) {
                          if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                          }
                          this.nextToken();
                          this.reinterpretExpressionAsPattern(init2);
                          left = init2;
                          right = this.parseAssignmentExpression();
                          init2 = null;
                          forIn = false;
                        } else {
                          if (this.match(",")) {
                            var initSeq = [init2];
                            while (this.match(",")) {
                              this.nextToken();
                              initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                            }
                            init2 = this.finalize(this.startNode(initStartToken), new Node3.SequenceExpression(initSeq));
                          }
                          this.expect(";");
                        }
                      }
                    }
                    if (typeof left === "undefined") {
                      if (!this.match(";")) {
                        test = this.parseExpression();
                      }
                      this.expect(";");
                      if (!this.match(")")) {
                        update = this.parseExpression();
                      }
                    }
                    var body;
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      body = this.finalize(this.createNode(), new Node3.EmptyStatement());
                    } else {
                      this.expect(")");
                      var previousInIteration = this.context.inIteration;
                      this.context.inIteration = true;
                      body = this.isolateCoverGrammar(this.parseStatement);
                      this.context.inIteration = previousInIteration;
                    }
                    return typeof left === "undefined" ? this.finalize(node2, new Node3.ForStatement(init2, test, update, body)) : forIn ? this.finalize(node2, new Node3.ForInStatement(left, right, body)) : this.finalize(node2, new Node3.ForOfStatement(left, right, body));
                  };
                  Parser3.prototype.parseContinueStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("continue");
                    var label = null;
                    if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                      var id = this.parseVariableIdentifier();
                      label = id;
                      var key = "$" + id.name;
                      if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                        this.throwError(messages_1.Messages.UnknownLabel, id.name);
                      }
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration) {
                      this.throwError(messages_1.Messages.IllegalContinue);
                    }
                    return this.finalize(node2, new Node3.ContinueStatement(label));
                  };
                  Parser3.prototype.parseBreakStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("break");
                    var label = null;
                    if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                      var id = this.parseVariableIdentifier();
                      var key = "$" + id.name;
                      if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                        this.throwError(messages_1.Messages.UnknownLabel, id.name);
                      }
                      label = id;
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                      this.throwError(messages_1.Messages.IllegalBreak);
                    }
                    return this.finalize(node2, new Node3.BreakStatement(label));
                  };
                  Parser3.prototype.parseReturnStatement = function() {
                    if (!this.context.inFunctionBody) {
                      this.tolerateError(messages_1.Messages.IllegalReturn);
                    }
                    var node2 = this.createNode();
                    this.expectKeyword("return");
                    var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
                    var argument = hasArgument ? this.parseExpression() : null;
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node3.ReturnStatement(argument));
                  };
                  Parser3.prototype.parseWithStatement = function() {
                    if (this.context.strict) {
                      this.tolerateError(messages_1.Messages.StrictModeWith);
                    }
                    var node2 = this.createNode();
                    var body;
                    this.expectKeyword("with");
                    this.expect("(");
                    var object2 = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      body = this.finalize(this.createNode(), new Node3.EmptyStatement());
                    } else {
                      this.expect(")");
                      body = this.parseStatement();
                    }
                    return this.finalize(node2, new Node3.WithStatement(object2, body));
                  };
                  Parser3.prototype.parseSwitchCase = function() {
                    var node2 = this.createNode();
                    var test;
                    if (this.matchKeyword("default")) {
                      this.nextToken();
                      test = null;
                    } else {
                      this.expectKeyword("case");
                      test = this.parseExpression();
                    }
                    this.expect(":");
                    var consequent = [];
                    while (true) {
                      if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                        break;
                      }
                      consequent.push(this.parseStatementListItem());
                    }
                    return this.finalize(node2, new Node3.SwitchCase(test, consequent));
                  };
                  Parser3.prototype.parseSwitchStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("switch");
                    this.expect("(");
                    var discriminant = this.parseExpression();
                    this.expect(")");
                    var previousInSwitch = this.context.inSwitch;
                    this.context.inSwitch = true;
                    var cases = [];
                    var defaultFound = false;
                    this.expect("{");
                    while (true) {
                      if (this.match("}")) {
                        break;
                      }
                      var clause = this.parseSwitchCase();
                      if (clause.test === null) {
                        if (defaultFound) {
                          this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                        }
                        defaultFound = true;
                      }
                      cases.push(clause);
                    }
                    this.expect("}");
                    this.context.inSwitch = previousInSwitch;
                    return this.finalize(node2, new Node3.SwitchStatement(discriminant, cases));
                  };
                  Parser3.prototype.parseLabelledStatement = function() {
                    var node2 = this.createNode();
                    var expr2 = this.parseExpression();
                    var statement;
                    if (expr2.type === syntax_1.Syntax.Identifier && this.match(":")) {
                      this.nextToken();
                      var id = expr2;
                      var key = "$" + id.name;
                      if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                        this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                      }
                      this.context.labelSet[key] = true;
                      var body = void 0;
                      if (this.matchKeyword("class")) {
                        this.tolerateUnexpectedToken(this.lookahead);
                        body = this.parseClassDeclaration();
                      } else if (this.matchKeyword("function")) {
                        var token = this.lookahead;
                        var declaration = this.parseFunctionDeclaration();
                        if (this.context.strict) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                        } else if (declaration.generator) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                        }
                        body = declaration;
                      } else {
                        body = this.parseStatement();
                      }
                      delete this.context.labelSet[key];
                      statement = new Node3.LabeledStatement(id, body);
                    } else {
                      this.consumeSemicolon();
                      statement = new Node3.ExpressionStatement(expr2);
                    }
                    return this.finalize(node2, statement);
                  };
                  Parser3.prototype.parseThrowStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("throw");
                    if (this.hasLineTerminator) {
                      this.throwError(messages_1.Messages.NewlineAfterThrow);
                    }
                    var argument = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node3.ThrowStatement(argument));
                  };
                  Parser3.prototype.parseCatchClause = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("catch");
                    this.expect("(");
                    if (this.match(")")) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    var params = [];
                    var param = this.parsePattern(params);
                    var paramMap = {};
                    for (var i = 0; i < params.length; i++) {
                      var key = "$" + params[i].value;
                      if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                        this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                      }
                      paramMap[key] = true;
                    }
                    if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                      if (this.scanner.isRestrictedWord(param.name)) {
                        this.tolerateError(messages_1.Messages.StrictCatchVariable);
                      }
                    }
                    this.expect(")");
                    var body = this.parseBlock();
                    return this.finalize(node2, new Node3.CatchClause(param, body));
                  };
                  Parser3.prototype.parseFinallyClause = function() {
                    this.expectKeyword("finally");
                    return this.parseBlock();
                  };
                  Parser3.prototype.parseTryStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("try");
                    var block = this.parseBlock();
                    var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                    var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                    if (!handler && !finalizer) {
                      this.throwError(messages_1.Messages.NoCatchOrFinally);
                    }
                    return this.finalize(node2, new Node3.TryStatement(block, handler, finalizer));
                  };
                  Parser3.prototype.parseDebuggerStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("debugger");
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node3.DebuggerStatement());
                  };
                  Parser3.prototype.parseStatement = function() {
                    var statement;
                    switch (this.lookahead.type) {
                      case 1:
                      case 5:
                      case 6:
                      case 8:
                      case 10:
                      case 9:
                        statement = this.parseExpressionStatement();
                        break;
                      case 7:
                        var value = this.lookahead.value;
                        if (value === "{") {
                          statement = this.parseBlock();
                        } else if (value === "(") {
                          statement = this.parseExpressionStatement();
                        } else if (value === ";") {
                          statement = this.parseEmptyStatement();
                        } else {
                          statement = this.parseExpressionStatement();
                        }
                        break;
                      case 3:
                        statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                        break;
                      case 4:
                        switch (this.lookahead.value) {
                          case "break":
                            statement = this.parseBreakStatement();
                            break;
                          case "continue":
                            statement = this.parseContinueStatement();
                            break;
                          case "debugger":
                            statement = this.parseDebuggerStatement();
                            break;
                          case "do":
                            statement = this.parseDoWhileStatement();
                            break;
                          case "for":
                            statement = this.parseForStatement();
                            break;
                          case "function":
                            statement = this.parseFunctionDeclaration();
                            break;
                          case "if":
                            statement = this.parseIfStatement();
                            break;
                          case "return":
                            statement = this.parseReturnStatement();
                            break;
                          case "switch":
                            statement = this.parseSwitchStatement();
                            break;
                          case "throw":
                            statement = this.parseThrowStatement();
                            break;
                          case "try":
                            statement = this.parseTryStatement();
                            break;
                          case "var":
                            statement = this.parseVariableStatement();
                            break;
                          case "while":
                            statement = this.parseWhileStatement();
                            break;
                          case "with":
                            statement = this.parseWithStatement();
                            break;
                          default:
                            statement = this.parseExpressionStatement();
                            break;
                        }
                        break;
                      default:
                        statement = this.throwUnexpectedToken(this.lookahead);
                    }
                    return statement;
                  };
                  Parser3.prototype.parseFunctionSourceElements = function() {
                    var node2 = this.createNode();
                    this.expect("{");
                    var body = this.parseDirectivePrologues();
                    var previousLabelSet = this.context.labelSet;
                    var previousInIteration = this.context.inIteration;
                    var previousInSwitch = this.context.inSwitch;
                    var previousInFunctionBody = this.context.inFunctionBody;
                    this.context.labelSet = {};
                    this.context.inIteration = false;
                    this.context.inSwitch = false;
                    this.context.inFunctionBody = true;
                    while (this.lookahead.type !== 2) {
                      if (this.match("}")) {
                        break;
                      }
                      body.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    this.context.labelSet = previousLabelSet;
                    this.context.inIteration = previousInIteration;
                    this.context.inSwitch = previousInSwitch;
                    this.context.inFunctionBody = previousInFunctionBody;
                    return this.finalize(node2, new Node3.BlockStatement(body));
                  };
                  Parser3.prototype.validateParam = function(options2, param, name2) {
                    var key = "$" + name2;
                    if (this.context.strict) {
                      if (this.scanner.isRestrictedWord(name2)) {
                        options2.stricted = param;
                        options2.message = messages_1.Messages.StrictParamName;
                      }
                      if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                        options2.stricted = param;
                        options2.message = messages_1.Messages.StrictParamDupe;
                      }
                    } else if (!options2.firstRestricted) {
                      if (this.scanner.isRestrictedWord(name2)) {
                        options2.firstRestricted = param;
                        options2.message = messages_1.Messages.StrictParamName;
                      } else if (this.scanner.isStrictModeReservedWord(name2)) {
                        options2.firstRestricted = param;
                        options2.message = messages_1.Messages.StrictReservedWord;
                      } else if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                        options2.stricted = param;
                        options2.message = messages_1.Messages.StrictParamDupe;
                      }
                    }
                    if (typeof Object.defineProperty === "function") {
                      Object.defineProperty(options2.paramSet, key, {value: true, enumerable: true, writable: true, configurable: true});
                    } else {
                      options2.paramSet[key] = true;
                    }
                  };
                  Parser3.prototype.parseRestElement = function(params) {
                    var node2 = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params);
                    if (this.match("=")) {
                      this.throwError(messages_1.Messages.DefaultRestParameter);
                    }
                    if (!this.match(")")) {
                      this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                    }
                    return this.finalize(node2, new Node3.RestElement(arg));
                  };
                  Parser3.prototype.parseFormalParameter = function(options2) {
                    var params = [];
                    var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                    for (var i = 0; i < params.length; i++) {
                      this.validateParam(options2, params[i], params[i].value);
                    }
                    options2.simple = options2.simple && param instanceof Node3.Identifier;
                    options2.params.push(param);
                  };
                  Parser3.prototype.parseFormalParameters = function(firstRestricted) {
                    var options2;
                    options2 = {simple: true, params: [], firstRestricted};
                    this.expect("(");
                    if (!this.match(")")) {
                      options2.paramSet = {};
                      while (this.lookahead.type !== 2) {
                        this.parseFormalParameter(options2);
                        if (this.match(")")) {
                          break;
                        }
                        this.expect(",");
                        if (this.match(")")) {
                          break;
                        }
                      }
                    }
                    this.expect(")");
                    return {simple: options2.simple, params: options2.params, stricted: options2.stricted, firstRestricted: options2.firstRestricted, message: options2.message};
                  };
                  Parser3.prototype.matchAsyncFunction = function() {
                    var match = this.matchContextualKeyword("async");
                    if (match) {
                      var state = this.scanner.saveState();
                      this.scanner.scanComments();
                      var next = this.scanner.lex();
                      this.scanner.restoreState(state);
                      match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                    }
                    return match;
                  };
                  Parser3.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                    var node2 = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                      this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                      this.nextToken();
                    }
                    var message;
                    var id = null;
                    var firstRestricted = null;
                    if (!identifierIsOptional || !this.match("(")) {
                      var token = this.lookahead;
                      id = this.parseVariableIdentifier();
                      if (this.context.strict) {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                        }
                      } else {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictFunctionName;
                        } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictReservedWord;
                        }
                      }
                    }
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                      message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                      this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                      this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node2, new Node3.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node2, new Node3.FunctionDeclaration(id, params, body, isGenerator));
                  };
                  Parser3.prototype.parseFunctionExpression = function() {
                    var node2 = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                      this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                      this.nextToken();
                    }
                    var message;
                    var id = null;
                    var firstRestricted;
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    if (!this.match("(")) {
                      var token = this.lookahead;
                      id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                      if (this.context.strict) {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                        }
                      } else {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictFunctionName;
                        } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictReservedWord;
                        }
                      }
                    }
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                      message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                      this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                      this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node2, new Node3.AsyncFunctionExpression(id, params, body)) : this.finalize(node2, new Node3.FunctionExpression(id, params, body, isGenerator));
                  };
                  Parser3.prototype.parseDirective = function() {
                    var token = this.lookahead;
                    var node2 = this.createNode();
                    var expr2 = this.parseExpression();
                    var directive = expr2.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                    this.consumeSemicolon();
                    return this.finalize(node2, directive ? new Node3.Directive(expr2, directive) : new Node3.ExpressionStatement(expr2));
                  };
                  Parser3.prototype.parseDirectivePrologues = function() {
                    var firstRestricted = null;
                    var body = [];
                    while (true) {
                      var token = this.lookahead;
                      if (token.type !== 8) {
                        break;
                      }
                      var statement = this.parseDirective();
                      body.push(statement);
                      var directive = statement.directive;
                      if (typeof directive !== "string") {
                        break;
                      }
                      if (directive === "use strict") {
                        this.context.strict = true;
                        if (firstRestricted) {
                          this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                        }
                        if (!this.context.allowStrictDirective) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                        }
                      } else {
                        if (!firstRestricted && token.octal) {
                          firstRestricted = token;
                        }
                      }
                    }
                    return body;
                  };
                  Parser3.prototype.qualifiedPropertyName = function(token) {
                    switch (token.type) {
                      case 3:
                      case 8:
                      case 1:
                      case 5:
                      case 6:
                      case 4:
                        return true;
                      case 7:
                        return token.value === "[";
                    }
                    return false;
                  };
                  Parser3.prototype.parseGetterMethod = function() {
                    var node2 = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length > 0) {
                      this.tolerateError(messages_1.Messages.BadGetterArity);
                    }
                    var method = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node3.FunctionExpression(null, formalParameters.params, method, isGenerator));
                  };
                  Parser3.prototype.parseSetterMethod = function() {
                    var node2 = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length !== 1) {
                      this.tolerateError(messages_1.Messages.BadSetterArity);
                    } else if (formalParameters.params[0] instanceof Node3.RestElement) {
                      this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                    }
                    var method = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node3.FunctionExpression(null, formalParameters.params, method, isGenerator));
                  };
                  Parser3.prototype.parseGeneratorMethod = function() {
                    var node2 = this.createNode();
                    var isGenerator = true;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    this.context.allowYield = false;
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node3.FunctionExpression(null, params.params, method, isGenerator));
                  };
                  Parser3.prototype.isStartOfExpression = function() {
                    var start = true;
                    var value = this.lookahead.value;
                    switch (this.lookahead.type) {
                      case 7:
                        start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                        break;
                      case 4:
                        start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                        break;
                    }
                    return start;
                  };
                  Parser3.prototype.parseYieldExpression = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("yield");
                    var argument = null;
                    var delegate = false;
                    if (!this.hasLineTerminator) {
                      var previousAllowYield = this.context.allowYield;
                      this.context.allowYield = false;
                      delegate = this.match("*");
                      if (delegate) {
                        this.nextToken();
                        argument = this.parseAssignmentExpression();
                      } else if (this.isStartOfExpression()) {
                        argument = this.parseAssignmentExpression();
                      }
                      this.context.allowYield = previousAllowYield;
                    }
                    return this.finalize(node2, new Node3.YieldExpression(argument, delegate));
                  };
                  Parser3.prototype.parseClassElement = function(hasConstructor) {
                    var token = this.lookahead;
                    var node2 = this.createNode();
                    var kind = "";
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method = false;
                    var isStatic = false;
                    var isAsync = false;
                    if (this.match("*")) {
                      this.nextToken();
                    } else {
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      var id = key;
                      if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                        token = this.lookahead;
                        isStatic = true;
                        computed = this.match("[");
                        if (this.match("*")) {
                          this.nextToken();
                        } else {
                          key = this.parseObjectPropertyKey();
                        }
                      }
                      if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                        var punctuator = this.lookahead.value;
                        if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                          isAsync = true;
                          token = this.lookahead;
                          key = this.parseObjectPropertyKey();
                          if (token.type === 3 && token.value === "constructor") {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                          }
                        }
                      }
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3) {
                      if (token.value === "get" && lookaheadPropertyKey) {
                        kind = "get";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        this.context.allowYield = false;
                        value = this.parseGetterMethod();
                      } else if (token.value === "set" && lookaheadPropertyKey) {
                        kind = "set";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseSetterMethod();
                      }
                    } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                      kind = "init";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      value = this.parseGeneratorMethod();
                      method = true;
                    }
                    if (!kind && key && this.match("(")) {
                      kind = "init";
                      value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                      method = true;
                    }
                    if (!kind) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    if (kind === "init") {
                      kind = "method";
                    }
                    if (!computed) {
                      if (isStatic && this.isPropertyKey(key, "prototype")) {
                        this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                      }
                      if (!isStatic && this.isPropertyKey(key, "constructor")) {
                        if (kind !== "method" || !method || value && value.generator) {
                          this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                        }
                        if (hasConstructor.value) {
                          this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                        } else {
                          hasConstructor.value = true;
                        }
                        kind = "constructor";
                      }
                    }
                    return this.finalize(node2, new Node3.MethodDefinition(key, computed, value, kind, isStatic));
                  };
                  Parser3.prototype.parseClassElementList = function() {
                    var body = [];
                    var hasConstructor = {value: false};
                    this.expect("{");
                    while (!this.match("}")) {
                      if (this.match(";")) {
                        this.nextToken();
                      } else {
                        body.push(this.parseClassElement(hasConstructor));
                      }
                    }
                    this.expect("}");
                    return body;
                  };
                  Parser3.prototype.parseClassBody = function() {
                    var node2 = this.createNode();
                    var elementList = this.parseClassElementList();
                    return this.finalize(node2, new Node3.ClassBody(elementList));
                  };
                  Parser3.prototype.parseClassDeclaration = function(identifierIsOptional) {
                    var node2 = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                      this.nextToken();
                      superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node2, new Node3.ClassDeclaration(id, superClass, classBody));
                  };
                  Parser3.prototype.parseClassExpression = function() {
                    var node2 = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                      this.nextToken();
                      superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node2, new Node3.ClassExpression(id, superClass, classBody));
                  };
                  Parser3.prototype.parseModule = function() {
                    this.context.strict = true;
                    this.context.isModule = true;
                    this.scanner.isModule = true;
                    var node2 = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while (this.lookahead.type !== 2) {
                      body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node2, new Node3.Module(body));
                  };
                  Parser3.prototype.parseScript = function() {
                    var node2 = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while (this.lookahead.type !== 2) {
                      body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node2, new Node3.Script(body));
                  };
                  Parser3.prototype.parseModuleSpecifier = function() {
                    var node2 = this.createNode();
                    if (this.lookahead.type !== 8) {
                      this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                    }
                    var token = this.nextToken();
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node2, new Node3.Literal(token.value, raw));
                  };
                  Parser3.prototype.parseImportSpecifier = function() {
                    var node2 = this.createNode();
                    var imported;
                    var local;
                    if (this.lookahead.type === 3) {
                      imported = this.parseVariableIdentifier();
                      local = imported;
                      if (this.matchContextualKeyword("as")) {
                        this.nextToken();
                        local = this.parseVariableIdentifier();
                      }
                    } else {
                      imported = this.parseIdentifierName();
                      local = imported;
                      if (this.matchContextualKeyword("as")) {
                        this.nextToken();
                        local = this.parseVariableIdentifier();
                      } else {
                        this.throwUnexpectedToken(this.nextToken());
                      }
                    }
                    return this.finalize(node2, new Node3.ImportSpecifier(local, imported));
                  };
                  Parser3.prototype.parseNamedImports = function() {
                    this.expect("{");
                    var specifiers = [];
                    while (!this.match("}")) {
                      specifiers.push(this.parseImportSpecifier());
                      if (!this.match("}")) {
                        this.expect(",");
                      }
                    }
                    this.expect("}");
                    return specifiers;
                  };
                  Parser3.prototype.parseImportDefaultSpecifier = function() {
                    var node2 = this.createNode();
                    var local = this.parseIdentifierName();
                    return this.finalize(node2, new Node3.ImportDefaultSpecifier(local));
                  };
                  Parser3.prototype.parseImportNamespaceSpecifier = function() {
                    var node2 = this.createNode();
                    this.expect("*");
                    if (!this.matchContextualKeyword("as")) {
                      this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                    }
                    this.nextToken();
                    var local = this.parseIdentifierName();
                    return this.finalize(node2, new Node3.ImportNamespaceSpecifier(local));
                  };
                  Parser3.prototype.parseImportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                      this.throwError(messages_1.Messages.IllegalImportDeclaration);
                    }
                    var node2 = this.createNode();
                    this.expectKeyword("import");
                    var src;
                    var specifiers = [];
                    if (this.lookahead.type === 8) {
                      src = this.parseModuleSpecifier();
                    } else {
                      if (this.match("{")) {
                        specifiers = specifiers.concat(this.parseNamedImports());
                      } else if (this.match("*")) {
                        specifiers.push(this.parseImportNamespaceSpecifier());
                      } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                        specifiers.push(this.parseImportDefaultSpecifier());
                        if (this.match(",")) {
                          this.nextToken();
                          if (this.match("*")) {
                            specifiers.push(this.parseImportNamespaceSpecifier());
                          } else if (this.match("{")) {
                            specifiers = specifiers.concat(this.parseNamedImports());
                          } else {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                        }
                      } else {
                        this.throwUnexpectedToken(this.nextToken());
                      }
                      if (!this.matchContextualKeyword("from")) {
                        var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                        this.throwError(message, this.lookahead.value);
                      }
                      this.nextToken();
                      src = this.parseModuleSpecifier();
                    }
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node3.ImportDeclaration(specifiers, src));
                  };
                  Parser3.prototype.parseExportSpecifier = function() {
                    var node2 = this.createNode();
                    var local = this.parseIdentifierName();
                    var exported = local;
                    if (this.matchContextualKeyword("as")) {
                      this.nextToken();
                      exported = this.parseIdentifierName();
                    }
                    return this.finalize(node2, new Node3.ExportSpecifier(local, exported));
                  };
                  Parser3.prototype.parseExportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                      this.throwError(messages_1.Messages.IllegalExportDeclaration);
                    }
                    var node2 = this.createNode();
                    this.expectKeyword("export");
                    var exportDeclaration;
                    if (this.matchKeyword("default")) {
                      this.nextToken();
                      if (this.matchKeyword("function")) {
                        var declaration = this.parseFunctionDeclaration(true);
                        exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                      } else if (this.matchKeyword("class")) {
                        var declaration = this.parseClassDeclaration(true);
                        exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                      } else if (this.matchContextualKeyword("async")) {
                        var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                        exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                      } else {
                        if (this.matchContextualKeyword("from")) {
                          this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                        }
                        var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                        this.consumeSemicolon();
                        exportDeclaration = this.finalize(node2, new Node3.ExportDefaultDeclaration(declaration));
                      }
                    } else if (this.match("*")) {
                      this.nextToken();
                      if (!this.matchContextualKeyword("from")) {
                        var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                        this.throwError(message, this.lookahead.value);
                      }
                      this.nextToken();
                      var src = this.parseModuleSpecifier();
                      this.consumeSemicolon();
                      exportDeclaration = this.finalize(node2, new Node3.ExportAllDeclaration(src));
                    } else if (this.lookahead.type === 4) {
                      var declaration = void 0;
                      switch (this.lookahead.value) {
                        case "let":
                        case "const":
                          declaration = this.parseLexicalDeclaration({inFor: false});
                          break;
                        case "var":
                        case "class":
                        case "function":
                          declaration = this.parseStatementListItem();
                          break;
                        default:
                          this.throwUnexpectedToken(this.lookahead);
                      }
                      exportDeclaration = this.finalize(node2, new Node3.ExportNamedDeclaration(declaration, [], null));
                    } else if (this.matchAsyncFunction()) {
                      var declaration = this.parseFunctionDeclaration();
                      exportDeclaration = this.finalize(node2, new Node3.ExportNamedDeclaration(declaration, [], null));
                    } else {
                      var specifiers = [];
                      var source = null;
                      var isExportFromIdentifier = false;
                      this.expect("{");
                      while (!this.match("}")) {
                        isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                        specifiers.push(this.parseExportSpecifier());
                        if (!this.match("}")) {
                          this.expect(",");
                        }
                      }
                      this.expect("}");
                      if (this.matchContextualKeyword("from")) {
                        this.nextToken();
                        source = this.parseModuleSpecifier();
                        this.consumeSemicolon();
                      } else if (isExportFromIdentifier) {
                        var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                        this.throwError(message, this.lookahead.value);
                      } else {
                        this.consumeSemicolon();
                      }
                      exportDeclaration = this.finalize(node2, new Node3.ExportNamedDeclaration(null, specifiers, source));
                    }
                    return exportDeclaration;
                  };
                  return Parser3;
                }();
                exports5.Parser = Parser2;
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                function assert2(condition, message) {
                  if (!condition) {
                    throw new Error("ASSERT: " + message);
                  }
                }
                exports5.assert = assert2;
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var ErrorHandler = function() {
                  function ErrorHandler2() {
                    this.errors = [];
                    this.tolerant = false;
                  }
                  ErrorHandler2.prototype.recordError = function(error) {
                    this.errors.push(error);
                  };
                  ErrorHandler2.prototype.tolerate = function(error) {
                    if (this.tolerant) {
                      this.recordError(error);
                    } else {
                      throw error;
                    }
                  };
                  ErrorHandler2.prototype.constructError = function(msg, column) {
                    var error = new Error(msg);
                    try {
                      throw error;
                    } catch (base) {
                      if (Object.create && Object.defineProperty) {
                        error = Object.create(base);
                        Object.defineProperty(error, "column", {value: column});
                      }
                    }
                    return error;
                  };
                  ErrorHandler2.prototype.createError = function(index, line, col, description) {
                    var msg = "Line " + line + ": " + description;
                    var error = this.constructError(msg, col);
                    error.index = index;
                    error.lineNumber = line;
                    error.description = description;
                    return error;
                  };
                  ErrorHandler2.prototype.throwError = function(index, line, col, description) {
                    throw this.createError(index, line, col, description);
                  };
                  ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
                    var error = this.createError(index, line, col, description);
                    if (this.tolerant) {
                      this.recordError(error);
                    } else {
                      throw error;
                    }
                  };
                  return ErrorHandler2;
                }();
                exports5.ErrorHandler = ErrorHandler;
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                exports5.Messages = {BadGetterArity: "Getter must not have any formal parameters", BadSetterArity: "Setter must have exactly one formal parameter", BadSetterRestParameter: "Setter function argument must not be a rest parameter", ConstructorIsAsync: "Class constructor may not be an async method", ConstructorSpecialMethod: "Class constructor may not be an accessor", DeclarationMissingInitializer: "Missing initializer in %0 declaration", DefaultRestParameter: "Unexpected token =", DuplicateBinding: "Duplicate binding %0", DuplicateConstructor: "A class may only have one constructor", DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals", ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer", GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts", IllegalBreak: "Illegal break statement", IllegalContinue: "Illegal continue statement", IllegalExportDeclaration: "Unexpected token", IllegalImportDeclaration: "Unexpected token", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list", IllegalReturn: "Illegal return statement", InvalidEscapedReservedWord: "Keyword must not contain escaped characters", InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence", InvalidLHSInAssignment: "Invalid left-hand side in assignment", InvalidLHSInForIn: "Invalid left-hand side in for-in", InvalidLHSInForLoop: "Invalid left-hand side in for-loop", InvalidModuleSpecifier: "Unexpected token", InvalidRegExp: "Invalid regular expression", LetInLexicalBinding: "let is disallowed as a lexically bound name", MissingFromClause: "Unexpected token", MultipleDefaultsInSwitch: "More than one default clause in switch statement", NewlineAfterThrow: "Illegal newline after throw", NoAsAfterImportNamespace: "Unexpected token", NoCatchOrFinally: "Missing catch or finally after try", ParameterAfterRestParameter: "Rest parameter must be last formal parameter", Redeclaration: "%0 '%1' has already been declared", StaticPrototype: "Classes may not have static property named prototype", StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode", StrictDelete: "Delete of an unqualified identifier in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block", StrictFunctionName: "Function name may not be eval or arguments in strict mode", StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode", StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode", StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode", StrictModeWith: "Strict mode code may not include a with statement", StrictOctalLiteral: "Octal literals are not allowed in strict mode.", StrictParamDupe: "Strict mode function may not have duplicate parameter names", StrictParamName: "Parameter name eval or arguments is not allowed in strict mode", StrictReservedWord: "Use of future reserved word in strict mode", StrictVarName: "Variable name may not be eval or arguments in strict mode", TemplateOctalLiteral: "Octal literals are not allowed in template strings.", UnexpectedEOS: "Unexpected end of input", UnexpectedIdentifier: "Unexpected identifier", UnexpectedNumber: "Unexpected number", UnexpectedReserved: "Unexpected reserved word", UnexpectedString: "Unexpected string", UnexpectedTemplate: "Unexpected quasi %0", UnexpectedToken: "Unexpected token %0", UnexpectedTokenIllegal: "Unexpected token ILLEGAL", UnknownLabel: "Undefined label '%0'", UnterminatedRegExp: "Invalid regular expression: missing /"};
              }, function(module4, exports5, __webpack_require__) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var assert_12 = __webpack_require__(9);
                var character_1 = __webpack_require__(4);
                var messages_1 = __webpack_require__(11);
                function hexValue(ch) {
                  return "0123456789abcdef".indexOf(ch.toLowerCase());
                }
                function octalValue(ch) {
                  return "01234567".indexOf(ch);
                }
                var Scanner = function() {
                  function Scanner2(code, handler) {
                    this.source = code;
                    this.errorHandler = handler;
                    this.trackComment = false;
                    this.isModule = false;
                    this.length = code.length;
                    this.index = 0;
                    this.lineNumber = code.length > 0 ? 1 : 0;
                    this.lineStart = 0;
                    this.curlyStack = [];
                  }
                  Scanner2.prototype.saveState = function() {
                    return {index: this.index, lineNumber: this.lineNumber, lineStart: this.lineStart};
                  };
                  Scanner2.prototype.restoreState = function(state) {
                    this.index = state.index;
                    this.lineNumber = state.lineNumber;
                    this.lineStart = state.lineStart;
                  };
                  Scanner2.prototype.eof = function() {
                    return this.index >= this.length;
                  };
                  Scanner2.prototype.throwUnexpectedToken = function(message) {
                    if (message === void 0) {
                      message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                  };
                  Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                    if (message === void 0) {
                      message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                  };
                  Scanner2.prototype.skipSingleLineComment = function(offset) {
                    var comments2 = [];
                    var start, loc;
                    if (this.trackComment) {
                      comments2 = [];
                      start = this.index - offset;
                      loc = {start: {line: this.lineNumber, column: this.index - this.lineStart - offset}, end: {}};
                    }
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      ++this.index;
                      if (character_1.Character.isLineTerminator(ch)) {
                        if (this.trackComment) {
                          loc.end = {line: this.lineNumber, column: this.index - this.lineStart - 1};
                          var entry = {multiLine: false, slice: [start + offset, this.index - 1], range: [start, this.index - 1], loc};
                          comments2.push(entry);
                        }
                        if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                          ++this.index;
                        }
                        ++this.lineNumber;
                        this.lineStart = this.index;
                        return comments2;
                      }
                    }
                    if (this.trackComment) {
                      loc.end = {line: this.lineNumber, column: this.index - this.lineStart};
                      var entry = {multiLine: false, slice: [start + offset, this.index], range: [start, this.index], loc};
                      comments2.push(entry);
                    }
                    return comments2;
                  };
                  Scanner2.prototype.skipMultiLineComment = function() {
                    var comments2 = [];
                    var start, loc;
                    if (this.trackComment) {
                      comments2 = [];
                      start = this.index - 2;
                      loc = {start: {line: this.lineNumber, column: this.index - this.lineStart - 2}, end: {}};
                    }
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      if (character_1.Character.isLineTerminator(ch)) {
                        if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                          ++this.index;
                        }
                        ++this.lineNumber;
                        ++this.index;
                        this.lineStart = this.index;
                      } else if (ch === 42) {
                        if (this.source.charCodeAt(this.index + 1) === 47) {
                          this.index += 2;
                          if (this.trackComment) {
                            loc.end = {line: this.lineNumber, column: this.index - this.lineStart};
                            var entry = {multiLine: true, slice: [start + 2, this.index - 2], range: [start, this.index], loc};
                            comments2.push(entry);
                          }
                          return comments2;
                        }
                        ++this.index;
                      } else {
                        ++this.index;
                      }
                    }
                    if (this.trackComment) {
                      loc.end = {line: this.lineNumber, column: this.index - this.lineStart};
                      var entry = {multiLine: true, slice: [start + 2, this.index], range: [start, this.index], loc};
                      comments2.push(entry);
                    }
                    this.tolerateUnexpectedToken();
                    return comments2;
                  };
                  Scanner2.prototype.scanComments = function() {
                    var comments2;
                    if (this.trackComment) {
                      comments2 = [];
                    }
                    var start = this.index === 0;
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      if (character_1.Character.isWhiteSpace(ch)) {
                        ++this.index;
                      } else if (character_1.Character.isLineTerminator(ch)) {
                        ++this.index;
                        if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                          ++this.index;
                        }
                        ++this.lineNumber;
                        this.lineStart = this.index;
                        start = true;
                      } else if (ch === 47) {
                        ch = this.source.charCodeAt(this.index + 1);
                        if (ch === 47) {
                          this.index += 2;
                          var comment2 = this.skipSingleLineComment(2);
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                          start = true;
                        } else if (ch === 42) {
                          this.index += 2;
                          var comment2 = this.skipMultiLineComment();
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                        } else {
                          break;
                        }
                      } else if (start && ch === 45) {
                        if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                          this.index += 3;
                          var comment2 = this.skipSingleLineComment(3);
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                        } else {
                          break;
                        }
                      } else if (ch === 60 && !this.isModule) {
                        if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                          this.index += 4;
                          var comment2 = this.skipSingleLineComment(4);
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                        } else {
                          break;
                        }
                      } else {
                        break;
                      }
                    }
                    return comments2;
                  };
                  Scanner2.prototype.isFutureReservedWord = function(id) {
                    switch (id) {
                      case "enum":
                      case "export":
                      case "import":
                      case "super":
                        return true;
                      default:
                        return false;
                    }
                  };
                  Scanner2.prototype.isStrictModeReservedWord = function(id) {
                    switch (id) {
                      case "implements":
                      case "interface":
                      case "package":
                      case "private":
                      case "protected":
                      case "public":
                      case "static":
                      case "yield":
                      case "let":
                        return true;
                      default:
                        return false;
                    }
                  };
                  Scanner2.prototype.isRestrictedWord = function(id) {
                    return id === "eval" || id === "arguments";
                  };
                  Scanner2.prototype.isKeyword = function(id) {
                    switch (id.length) {
                      case 2:
                        return id === "if" || id === "in" || id === "do";
                      case 3:
                        return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                      case 4:
                        return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                      case 5:
                        return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                      case 6:
                        return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                      case 7:
                        return id === "default" || id === "finally" || id === "extends";
                      case 8:
                        return id === "function" || id === "continue" || id === "debugger";
                      case 10:
                        return id === "instanceof";
                      default:
                        return false;
                    }
                  };
                  Scanner2.prototype.codePointAt = function(i) {
                    var cp = this.source.charCodeAt(i);
                    if (cp >= 55296 && cp <= 56319) {
                      var second = this.source.charCodeAt(i + 1);
                      if (second >= 56320 && second <= 57343) {
                        var first = cp;
                        cp = (first - 55296) * 1024 + second - 56320 + 65536;
                      }
                    }
                    return cp;
                  };
                  Scanner2.prototype.scanHexEscape = function(prefix2) {
                    var len = prefix2 === "u" ? 4 : 2;
                    var code = 0;
                    for (var i = 0; i < len; ++i) {
                      if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                        code = code * 16 + hexValue(this.source[this.index++]);
                      } else {
                        return null;
                      }
                    }
                    return String.fromCharCode(code);
                  };
                  Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                    var ch = this.source[this.index];
                    var code = 0;
                    if (ch === "}") {
                      this.throwUnexpectedToken();
                    }
                    while (!this.eof()) {
                      ch = this.source[this.index++];
                      if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                        break;
                      }
                      code = code * 16 + hexValue(ch);
                    }
                    if (code > 1114111 || ch !== "}") {
                      this.throwUnexpectedToken();
                    }
                    return character_1.Character.fromCodePoint(code);
                  };
                  Scanner2.prototype.getIdentifier = function() {
                    var start = this.index++;
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      if (ch === 92) {
                        this.index = start;
                        return this.getComplexIdentifier();
                      } else if (ch >= 55296 && ch < 57343) {
                        this.index = start;
                        return this.getComplexIdentifier();
                      }
                      if (character_1.Character.isIdentifierPart(ch)) {
                        ++this.index;
                      } else {
                        break;
                      }
                    }
                    return this.source.slice(start, this.index);
                  };
                  Scanner2.prototype.getComplexIdentifier = function() {
                    var cp = this.codePointAt(this.index);
                    var id = character_1.Character.fromCodePoint(cp);
                    this.index += id.length;
                    var ch;
                    if (cp === 92) {
                      if (this.source.charCodeAt(this.index) !== 117) {
                        this.throwUnexpectedToken();
                      }
                      ++this.index;
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        ch = this.scanUnicodeCodePointEscape();
                      } else {
                        ch = this.scanHexEscape("u");
                        if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken();
                        }
                      }
                      id = ch;
                    }
                    while (!this.eof()) {
                      cp = this.codePointAt(this.index);
                      if (!character_1.Character.isIdentifierPart(cp)) {
                        break;
                      }
                      ch = character_1.Character.fromCodePoint(cp);
                      id += ch;
                      this.index += ch.length;
                      if (cp === 92) {
                        id = id.substr(0, id.length - 1);
                        if (this.source.charCodeAt(this.index) !== 117) {
                          this.throwUnexpectedToken();
                        }
                        ++this.index;
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          ch = this.scanUnicodeCodePointEscape();
                        } else {
                          ch = this.scanHexEscape("u");
                          if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                            this.throwUnexpectedToken();
                          }
                        }
                        id += ch;
                      }
                    }
                    return id;
                  };
                  Scanner2.prototype.octalToDecimal = function(ch) {
                    var octal = ch !== "0";
                    var code = octalValue(ch);
                    if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                      octal = true;
                      code = code * 8 + octalValue(this.source[this.index++]);
                      if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                        code = code * 8 + octalValue(this.source[this.index++]);
                      }
                    }
                    return {code, octal};
                  };
                  Scanner2.prototype.scanIdentifier = function() {
                    var type2;
                    var start = this.index;
                    var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                    if (id.length === 1) {
                      type2 = 3;
                    } else if (this.isKeyword(id)) {
                      type2 = 4;
                    } else if (id === "null") {
                      type2 = 5;
                    } else if (id === "true" || id === "false") {
                      type2 = 1;
                    } else {
                      type2 = 3;
                    }
                    if (type2 !== 3 && start + id.length !== this.index) {
                      var restore = this.index;
                      this.index = start;
                      this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                      this.index = restore;
                    }
                    return {type: type2, value: id, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.scanPunctuator = function() {
                    var start = this.index;
                    var str = this.source[this.index];
                    switch (str) {
                      case "(":
                      case "{":
                        if (str === "{") {
                          this.curlyStack.push("{");
                        }
                        ++this.index;
                        break;
                      case ".":
                        ++this.index;
                        if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                          this.index += 2;
                          str = "...";
                        }
                        break;
                      case "}":
                        ++this.index;
                        this.curlyStack.pop();
                        break;
                      case ")":
                      case ";":
                      case ",":
                      case "[":
                      case "]":
                      case ":":
                      case "?":
                      case "~":
                        ++this.index;
                        break;
                      default:
                        str = this.source.substr(this.index, 4);
                        if (str === ">>>=") {
                          this.index += 4;
                        } else {
                          str = str.substr(0, 3);
                          if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                            this.index += 3;
                          } else {
                            str = str.substr(0, 2);
                            if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                              this.index += 2;
                            } else {
                              str = this.source[this.index];
                              if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                                ++this.index;
                              }
                            }
                          }
                        }
                    }
                    if (this.index === start) {
                      this.throwUnexpectedToken();
                    }
                    return {type: 7, value: str, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.scanHexLiteral = function(start) {
                    var num = "";
                    while (!this.eof()) {
                      if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                        break;
                      }
                      num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                      this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                      this.throwUnexpectedToken();
                    }
                    return {type: 6, value: parseInt("0x" + num, 16), lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.scanBinaryLiteral = function(start) {
                    var num = "";
                    var ch;
                    while (!this.eof()) {
                      ch = this.source[this.index];
                      if (ch !== "0" && ch !== "1") {
                        break;
                      }
                      num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                      this.throwUnexpectedToken();
                    }
                    if (!this.eof()) {
                      ch = this.source.charCodeAt(this.index);
                      if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                        this.throwUnexpectedToken();
                      }
                    }
                    return {type: 6, value: parseInt(num, 2), lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.scanOctalLiteral = function(prefix2, start) {
                    var num = "";
                    var octal = false;
                    if (character_1.Character.isOctalDigit(prefix2.charCodeAt(0))) {
                      octal = true;
                      num = "0" + this.source[this.index++];
                    } else {
                      ++this.index;
                    }
                    while (!this.eof()) {
                      if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                        break;
                      }
                      num += this.source[this.index++];
                    }
                    if (!octal && num.length === 0) {
                      this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      this.throwUnexpectedToken();
                    }
                    return {type: 6, value: parseInt(num, 8), octal, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.isImplicitOctalLiteral = function() {
                    for (var i = this.index + 1; i < this.length; ++i) {
                      var ch = this.source[i];
                      if (ch === "8" || ch === "9") {
                        return false;
                      }
                      if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        return true;
                      }
                    }
                    return true;
                  };
                  Scanner2.prototype.scanNumericLiteral = function() {
                    var start = this.index;
                    var ch = this.source[start];
                    assert_12.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                    var num = "";
                    if (ch !== ".") {
                      num = this.source[this.index++];
                      ch = this.source[this.index];
                      if (num === "0") {
                        if (ch === "x" || ch === "X") {
                          ++this.index;
                          return this.scanHexLiteral(start);
                        }
                        if (ch === "b" || ch === "B") {
                          ++this.index;
                          return this.scanBinaryLiteral(start);
                        }
                        if (ch === "o" || ch === "O") {
                          return this.scanOctalLiteral(ch, start);
                        }
                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          if (this.isImplicitOctalLiteral()) {
                            return this.scanOctalLiteral(ch, start);
                          }
                        }
                      }
                      while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        num += this.source[this.index++];
                      }
                      ch = this.source[this.index];
                    }
                    if (ch === ".") {
                      num += this.source[this.index++];
                      while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        num += this.source[this.index++];
                      }
                      ch = this.source[this.index];
                    }
                    if (ch === "e" || ch === "E") {
                      num += this.source[this.index++];
                      ch = this.source[this.index];
                      if (ch === "+" || ch === "-") {
                        num += this.source[this.index++];
                      }
                      if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                          num += this.source[this.index++];
                        }
                      } else {
                        this.throwUnexpectedToken();
                      }
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                      this.throwUnexpectedToken();
                    }
                    return {type: 6, value: parseFloat(num), lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.scanStringLiteral = function() {
                    var start = this.index;
                    var quote = this.source[start];
                    assert_12.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                    ++this.index;
                    var octal = false;
                    var str = "";
                    while (!this.eof()) {
                      var ch = this.source[this.index++];
                      if (ch === quote) {
                        quote = "";
                        break;
                      } else if (ch === "\\") {
                        ch = this.source[this.index++];
                        if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                          switch (ch) {
                            case "u":
                              if (this.source[this.index] === "{") {
                                ++this.index;
                                str += this.scanUnicodeCodePointEscape();
                              } else {
                                var unescaped_1 = this.scanHexEscape(ch);
                                if (unescaped_1 === null) {
                                  this.throwUnexpectedToken();
                                }
                                str += unescaped_1;
                              }
                              break;
                            case "x":
                              var unescaped = this.scanHexEscape(ch);
                              if (unescaped === null) {
                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                              }
                              str += unescaped;
                              break;
                            case "n":
                              str += "\n";
                              break;
                            case "r":
                              str += "\r";
                              break;
                            case "t":
                              str += "	";
                              break;
                            case "b":
                              str += "\b";
                              break;
                            case "f":
                              str += "\f";
                              break;
                            case "v":
                              str += "\v";
                              break;
                            case "8":
                            case "9":
                              str += ch;
                              this.tolerateUnexpectedToken();
                              break;
                            default:
                              if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                var octToDec = this.octalToDecimal(ch);
                                octal = octToDec.octal || octal;
                                str += String.fromCharCode(octToDec.code);
                              } else {
                                str += ch;
                              }
                              break;
                          }
                        } else {
                          ++this.lineNumber;
                          if (ch === "\r" && this.source[this.index] === "\n") {
                            ++this.index;
                          }
                          this.lineStart = this.index;
                        }
                      } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        break;
                      } else {
                        str += ch;
                      }
                    }
                    if (quote !== "") {
                      this.index = start;
                      this.throwUnexpectedToken();
                    }
                    return {type: 8, value: str, octal, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.scanTemplate = function() {
                    var cooked = "";
                    var terminated = false;
                    var start = this.index;
                    var head = this.source[start] === "`";
                    var tail = false;
                    var rawOffset = 2;
                    ++this.index;
                    while (!this.eof()) {
                      var ch = this.source[this.index++];
                      if (ch === "`") {
                        rawOffset = 1;
                        tail = true;
                        terminated = true;
                        break;
                      } else if (ch === "$") {
                        if (this.source[this.index] === "{") {
                          this.curlyStack.push("${");
                          ++this.index;
                          terminated = true;
                          break;
                        }
                        cooked += ch;
                      } else if (ch === "\\") {
                        ch = this.source[this.index++];
                        if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                          switch (ch) {
                            case "n":
                              cooked += "\n";
                              break;
                            case "r":
                              cooked += "\r";
                              break;
                            case "t":
                              cooked += "	";
                              break;
                            case "u":
                              if (this.source[this.index] === "{") {
                                ++this.index;
                                cooked += this.scanUnicodeCodePointEscape();
                              } else {
                                var restore = this.index;
                                var unescaped_2 = this.scanHexEscape(ch);
                                if (unescaped_2 !== null) {
                                  cooked += unescaped_2;
                                } else {
                                  this.index = restore;
                                  cooked += ch;
                                }
                              }
                              break;
                            case "x":
                              var unescaped = this.scanHexEscape(ch);
                              if (unescaped === null) {
                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                              }
                              cooked += unescaped;
                              break;
                            case "b":
                              cooked += "\b";
                              break;
                            case "f":
                              cooked += "\f";
                              break;
                            case "v":
                              cooked += "\v";
                              break;
                            default:
                              if (ch === "0") {
                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                  this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                                }
                                cooked += "\0";
                              } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                              } else {
                                cooked += ch;
                              }
                              break;
                          }
                        } else {
                          ++this.lineNumber;
                          if (ch === "\r" && this.source[this.index] === "\n") {
                            ++this.index;
                          }
                          this.lineStart = this.index;
                        }
                      } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        ++this.lineNumber;
                        if (ch === "\r" && this.source[this.index] === "\n") {
                          ++this.index;
                        }
                        this.lineStart = this.index;
                        cooked += "\n";
                      } else {
                        cooked += ch;
                      }
                    }
                    if (!terminated) {
                      this.throwUnexpectedToken();
                    }
                    if (!head) {
                      this.curlyStack.pop();
                    }
                    return {type: 10, value: this.source.slice(start + 1, this.index - rawOffset), cooked, head, tail, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.testRegExp = function(pattern, flags) {
                    var astralSubstitute = "\uFFFF";
                    var tmp = pattern;
                    var self2 = this;
                    if (flags.indexOf("u") >= 0) {
                      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                        var codePoint = parseInt($1 || $2, 16);
                        if (codePoint > 1114111) {
                          self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                        }
                        if (codePoint <= 65535) {
                          return String.fromCharCode(codePoint);
                        }
                        return astralSubstitute;
                      }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                    }
                    try {
                      RegExp(tmp);
                    } catch (e) {
                      this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                    }
                    try {
                      return new RegExp(pattern, flags);
                    } catch (exception) {
                      return null;
                    }
                  };
                  Scanner2.prototype.scanRegExpBody = function() {
                    var ch = this.source[this.index];
                    assert_12.assert(ch === "/", "Regular expression literal must start with a slash");
                    var str = this.source[this.index++];
                    var classMarker = false;
                    var terminated = false;
                    while (!this.eof()) {
                      ch = this.source[this.index++];
                      str += ch;
                      if (ch === "\\") {
                        ch = this.source[this.index++];
                        if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                        }
                        str += ch;
                      } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                      } else if (classMarker) {
                        if (ch === "]") {
                          classMarker = false;
                        }
                      } else {
                        if (ch === "/") {
                          terminated = true;
                          break;
                        } else if (ch === "[") {
                          classMarker = true;
                        }
                      }
                    }
                    if (!terminated) {
                      this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    }
                    return str.substr(1, str.length - 2);
                  };
                  Scanner2.prototype.scanRegExpFlags = function() {
                    var str = "";
                    var flags = "";
                    while (!this.eof()) {
                      var ch = this.source[this.index];
                      if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                        break;
                      }
                      ++this.index;
                      if (ch === "\\" && !this.eof()) {
                        ch = this.source[this.index];
                        if (ch === "u") {
                          ++this.index;
                          var restore = this.index;
                          var char = this.scanHexEscape("u");
                          if (char !== null) {
                            flags += char;
                            for (str += "\\u"; restore < this.index; ++restore) {
                              str += this.source[restore];
                            }
                          } else {
                            this.index = restore;
                            flags += "u";
                            str += "\\u";
                          }
                          this.tolerateUnexpectedToken();
                        } else {
                          str += "\\";
                          this.tolerateUnexpectedToken();
                        }
                      } else {
                        flags += ch;
                        str += ch;
                      }
                    }
                    return flags;
                  };
                  Scanner2.prototype.scanRegExp = function() {
                    var start = this.index;
                    var pattern = this.scanRegExpBody();
                    var flags = this.scanRegExpFlags();
                    var value = this.testRegExp(pattern, flags);
                    return {type: 9, value: "", pattern, flags, regex: value, lineNumber: this.lineNumber, lineStart: this.lineStart, start, end: this.index};
                  };
                  Scanner2.prototype.lex = function() {
                    if (this.eof()) {
                      return {type: 2, value: "", lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index};
                    }
                    var cp = this.source.charCodeAt(this.index);
                    if (character_1.Character.isIdentifierStart(cp)) {
                      return this.scanIdentifier();
                    }
                    if (cp === 40 || cp === 41 || cp === 59) {
                      return this.scanPunctuator();
                    }
                    if (cp === 39 || cp === 34) {
                      return this.scanStringLiteral();
                    }
                    if (cp === 46) {
                      if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                        return this.scanNumericLiteral();
                      }
                      return this.scanPunctuator();
                    }
                    if (character_1.Character.isDecimalDigit(cp)) {
                      return this.scanNumericLiteral();
                    }
                    if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                      return this.scanTemplate();
                    }
                    if (cp >= 55296 && cp < 57343) {
                      if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                        return this.scanIdentifier();
                      }
                    }
                    return this.scanPunctuator();
                  };
                  return Scanner2;
                }();
                exports5.Scanner = Scanner;
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                exports5.TokenName = {};
                exports5.TokenName[1] = "Boolean";
                exports5.TokenName[2] = "<end>";
                exports5.TokenName[3] = "Identifier";
                exports5.TokenName[4] = "Keyword";
                exports5.TokenName[5] = "Null";
                exports5.TokenName[6] = "Numeric";
                exports5.TokenName[7] = "Punctuator";
                exports5.TokenName[8] = "String";
                exports5.TokenName[9] = "RegularExpression";
                exports5.TokenName[10] = "Template";
              }, function(module4, exports5) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                exports5.XHTMLEntities = {quot: '"', amp: "&", apos: "'", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666", lang: "\u27E8", rang: "\u27E9"};
              }, function(module4, exports5, __webpack_require__) {
                Object.defineProperty(exports5, "__esModule", {value: true});
                var error_handler_1 = __webpack_require__(10);
                var scanner_1 = __webpack_require__(12);
                var token_1 = __webpack_require__(13);
                var Reader = function() {
                  function Reader2() {
                    this.values = [];
                    this.curly = this.paren = -1;
                  }
                  Reader2.prototype.beforeFunctionExpression = function(t) {
                    return [
                      "(",
                      "{",
                      "[",
                      "in",
                      "typeof",
                      "instanceof",
                      "new",
                      "return",
                      "case",
                      "delete",
                      "throw",
                      "void",
                      "=",
                      "+=",
                      "-=",
                      "*=",
                      "**=",
                      "/=",
                      "%=",
                      "<<=",
                      ">>=",
                      ">>>=",
                      "&=",
                      "|=",
                      "^=",
                      ",",
                      "+",
                      "-",
                      "*",
                      "**",
                      "/",
                      "%",
                      "++",
                      "--",
                      "<<",
                      ">>",
                      ">>>",
                      "&",
                      "|",
                      "^",
                      "!",
                      "~",
                      "&&",
                      "||",
                      "?",
                      ":",
                      "===",
                      "==",
                      ">=",
                      "<=",
                      "<",
                      ">",
                      "!=",
                      "!=="
                    ].indexOf(t) >= 0;
                  };
                  Reader2.prototype.isRegexStart = function() {
                    var previous = this.values[this.values.length - 1];
                    var regex2 = previous !== null;
                    switch (previous) {
                      case "this":
                      case "]":
                        regex2 = false;
                        break;
                      case ")":
                        var keyword = this.values[this.paren - 1];
                        regex2 = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                        break;
                      case "}":
                        regex2 = false;
                        if (this.values[this.curly - 3] === "function") {
                          var check = this.values[this.curly - 4];
                          regex2 = check ? !this.beforeFunctionExpression(check) : false;
                        } else if (this.values[this.curly - 4] === "function") {
                          var check = this.values[this.curly - 5];
                          regex2 = check ? !this.beforeFunctionExpression(check) : true;
                        }
                        break;
                    }
                    return regex2;
                  };
                  Reader2.prototype.push = function(token) {
                    if (token.type === 7 || token.type === 4) {
                      if (token.value === "{") {
                        this.curly = this.values.length;
                      } else if (token.value === "(") {
                        this.paren = this.values.length;
                      }
                      this.values.push(token.value);
                    } else {
                      this.values.push(null);
                    }
                  };
                  return Reader2;
                }();
                var Tokenizer2 = function() {
                  function Tokenizer3(code, config) {
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
                    this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                    this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
                    this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
                    this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
                    this.buffer = [];
                    this.reader = new Reader();
                  }
                  Tokenizer3.prototype.errors = function() {
                    return this.errorHandler.errors;
                  };
                  Tokenizer3.prototype.getNextToken = function() {
                    if (this.buffer.length === 0) {
                      var comments2 = this.scanner.scanComments();
                      if (this.scanner.trackComment) {
                        for (var i = 0; i < comments2.length; ++i) {
                          var e = comments2[i];
                          var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                          var comment2 = {type: e.multiLine ? "BlockComment" : "LineComment", value};
                          if (this.trackRange) {
                            comment2.range = e.range;
                          }
                          if (this.trackLoc) {
                            comment2.loc = e.loc;
                          }
                          this.buffer.push(comment2);
                        }
                      }
                      if (!this.scanner.eof()) {
                        var loc = void 0;
                        if (this.trackLoc) {
                          loc = {start: {line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart}, end: {}};
                        }
                        var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                        var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                        this.reader.push(token);
                        var entry = {type: token_1.TokenName[token.type], value: this.scanner.source.slice(token.start, token.end)};
                        if (this.trackRange) {
                          entry.range = [token.start, token.end];
                        }
                        if (this.trackLoc) {
                          loc.end = {line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart};
                          entry.loc = loc;
                        }
                        if (token.type === 9) {
                          var pattern = token.pattern;
                          var flags = token.flags;
                          entry.regex = {pattern, flags};
                        }
                        this.buffer.push(entry);
                      }
                    }
                    return this.buffer.shift();
                  };
                  return Tokenizer3;
                }();
                exports5.Tokenizer = Tokenizer2;
              }]);
            });
          });
          var esprima = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.parse = void 0;
            function parse(source, options2) {
              var comments2 = [];
              var ast = esprima$1.parse(source, {loc: true, locations: true, comment: true, onComment: comments2, range: util$2.getOption(options2, "range", false), tolerant: util$2.getOption(options2, "tolerant", true), tokens: true, jsx: util$2.getOption(options2, "jsx", false)});
              if (!Array.isArray(ast.comments)) {
                ast.comments = comments2;
              }
              return ast;
            }
            exports4.parse = parse;
          });
          var _endianness;
          function endianness() {
            if (typeof _endianness === "undefined") {
              var a = new ArrayBuffer(2);
              var b = new Uint8Array(a);
              var c2 = new Uint16Array(a);
              b[0] = 1;
              b[1] = 2;
              if (c2[0] === 258) {
                _endianness = "BE";
              } else if (c2[0] === 513) {
                _endianness = "LE";
              } else {
                throw new Error("unable to figure out endianess");
              }
            }
            return _endianness;
          }
          function hostname() {
            if (typeof global2.location !== "undefined") {
              return global2.location.hostname;
            } else
              return "";
          }
          function loadavg() {
            return [];
          }
          function uptime() {
            return 0;
          }
          function freemem() {
            return Number.MAX_VALUE;
          }
          function totalmem() {
            return Number.MAX_VALUE;
          }
          function cpus() {
            return [];
          }
          function type() {
            return "Browser";
          }
          function release() {
            if (typeof global2.navigator !== "undefined") {
              return global2.navigator.appVersion;
            }
            return "";
          }
          function networkInterfaces() {
          }
          function getNetworkInterfaces() {
          }
          function arch() {
            return "javascript";
          }
          function platform() {
            return "browser";
          }
          function tmpDir() {
            return "/tmp";
          }
          var tmpdir = tmpDir;
          var EOL = "\n";
          var os = {EOL, tmpdir, tmpDir, networkInterfaces, getNetworkInterfaces, release, type, cpus, totalmem, freemem, uptime, loadavg, hostname, endianness};
          var os$1 = /* @__PURE__ */ Object.freeze({__proto__: null, endianness, hostname, loadavg, uptime, freemem, totalmem, cpus, type, release, networkInterfaces, getNetworkInterfaces, arch, platform, tmpDir, tmpdir, EOL, "default": os});
          var require$$13 = /* @__PURE__ */ getAugmentedNamespace2(os$1);
          var options = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.normalize = void 0;
            var defaults = {parser: esprima, tabWidth: 4, useTabs: false, reuseWhitespace: true, lineTerminator: require$$13.EOL || "\n", wrapColumn: 74, sourceFileName: null, sourceMapName: null, sourceRoot: null, inputSourceMap: null, range: false, tolerant: true, quote: null, trailingComma: false, arrayBracketSpacing: false, objectCurlySpacing: true, arrowParensAlways: false, flowObjectCommas: true, tokens: true};
            var hasOwn2 = defaults.hasOwnProperty;
            function normalize3(opts) {
              var options2 = opts || defaults;
              function get2(key) {
                return hasOwn2.call(options2, key) ? options2[key] : defaults[key];
              }
              return {tabWidth: +get2("tabWidth"), useTabs: !!get2("useTabs"), reuseWhitespace: !!get2("reuseWhitespace"), lineTerminator: get2("lineTerminator"), wrapColumn: Math.max(get2("wrapColumn"), 0), sourceFileName: get2("sourceFileName"), sourceMapName: get2("sourceMapName"), sourceRoot: get2("sourceRoot"), inputSourceMap: get2("inputSourceMap"), parser: get2("esprima") || get2("parser"), range: get2("range"), tolerant: get2("tolerant"), quote: get2("quote"), trailingComma: get2("trailingComma"), arrayBracketSpacing: get2("arrayBracketSpacing"), objectCurlySpacing: get2("objectCurlySpacing"), arrowParensAlways: get2("arrowParensAlways"), flowObjectCommas: get2("flowObjectCommas"), tokens: !!get2("tokens")};
            }
            exports4.normalize = normalize3;
          });
          var assert_1$1 = tslib_1.__importDefault(require$$0$1);
          var Mapping = function() {
            function Mapping2(sourceLines, sourceLoc, targetLoc) {
              if (targetLoc === void 0) {
                targetLoc = sourceLoc;
              }
              this.sourceLines = sourceLines;
              this.sourceLoc = sourceLoc;
              this.targetLoc = targetLoc;
            }
            Mapping2.prototype.slice = function(lines2, start, end) {
              if (end === void 0) {
                end = lines2.lastPos();
              }
              var sourceLines = this.sourceLines;
              var sourceLoc = this.sourceLoc;
              var targetLoc = this.targetLoc;
              function skip(name2) {
                var sourceFromPos = sourceLoc[name2];
                var targetFromPos = targetLoc[name2];
                var targetToPos = start;
                if (name2 === "end") {
                  targetToPos = end;
                } else {
                  assert_1$1.default.strictEqual(name2, "start");
                }
                return skipChars(sourceLines, sourceFromPos, lines2, targetFromPos, targetToPos);
              }
              if (util$2.comparePos(start, targetLoc.start) <= 0) {
                if (util$2.comparePos(targetLoc.end, end) <= 0) {
                  targetLoc = {start: subtractPos(targetLoc.start, start.line, start.column), end: subtractPos(targetLoc.end, start.line, start.column)};
                } else if (util$2.comparePos(end, targetLoc.start) <= 0) {
                  return null;
                } else {
                  sourceLoc = {start: sourceLoc.start, end: skip("end")};
                  targetLoc = {start: subtractPos(targetLoc.start, start.line, start.column), end: subtractPos(end, start.line, start.column)};
                }
              } else {
                if (util$2.comparePos(targetLoc.end, start) <= 0) {
                  return null;
                }
                if (util$2.comparePos(targetLoc.end, end) <= 0) {
                  sourceLoc = {start: skip("start"), end: sourceLoc.end};
                  targetLoc = {
                    start: {line: 1, column: 0},
                    end: subtractPos(targetLoc.end, start.line, start.column)
                  };
                } else {
                  sourceLoc = {start: skip("start"), end: skip("end")};
                  targetLoc = {
                    start: {line: 1, column: 0},
                    end: subtractPos(end, start.line, start.column)
                  };
                }
              }
              return new Mapping2(this.sourceLines, sourceLoc, targetLoc);
            };
            Mapping2.prototype.add = function(line, column) {
              return new Mapping2(this.sourceLines, this.sourceLoc, {start: addPos(this.targetLoc.start, line, column), end: addPos(this.targetLoc.end, line, column)});
            };
            Mapping2.prototype.subtract = function(line, column) {
              return new Mapping2(this.sourceLines, this.sourceLoc, {start: subtractPos(this.targetLoc.start, line, column), end: subtractPos(this.targetLoc.end, line, column)});
            };
            Mapping2.prototype.indent = function(by, skipFirstLine, noNegativeColumns) {
              if (skipFirstLine === void 0) {
                skipFirstLine = false;
              }
              if (noNegativeColumns === void 0) {
                noNegativeColumns = false;
              }
              if (by === 0) {
                return this;
              }
              var targetLoc = this.targetLoc;
              var startLine = targetLoc.start.line;
              var endLine = targetLoc.end.line;
              if (skipFirstLine && startLine === 1 && endLine === 1) {
                return this;
              }
              targetLoc = {start: targetLoc.start, end: targetLoc.end};
              if (!skipFirstLine || startLine > 1) {
                var startColumn = targetLoc.start.column + by;
                targetLoc.start = {line: startLine, column: noNegativeColumns ? Math.max(0, startColumn) : startColumn};
              }
              if (!skipFirstLine || endLine > 1) {
                var endColumn = targetLoc.end.column + by;
                targetLoc.end = {line: endLine, column: noNegativeColumns ? Math.max(0, endColumn) : endColumn};
              }
              return new Mapping2(this.sourceLines, this.sourceLoc, targetLoc);
            };
            return Mapping2;
          }();
          var _default$2 = Mapping;
          function addPos(toPos, line, column) {
            return {line: toPos.line + line - 1, column: toPos.line === 1 ? toPos.column + column : toPos.column};
          }
          function subtractPos(fromPos, line, column) {
            return {line: fromPos.line - line + 1, column: fromPos.line === line ? fromPos.column - column : fromPos.column};
          }
          function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
            var targetComparison = util$2.comparePos(targetFromPos, targetToPos);
            if (targetComparison === 0) {
              return sourceFromPos;
            }
            var sourceCursor, targetCursor;
            if (targetComparison < 0) {
              sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();
              targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
              var lineDiff = targetToPos.line - targetCursor.line;
              sourceCursor.line += lineDiff;
              targetCursor.line += lineDiff;
              if (lineDiff > 0) {
                sourceCursor.column = 0;
                targetCursor.column = 0;
              } else {
                assert_1$1.default.strictEqual(lineDiff, 0);
              }
              while (util$2.comparePos(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {
                assert_1$1.default.ok(sourceLines.nextPos(sourceCursor, true));
                assert_1$1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
              }
            } else {
              sourceCursor = sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();
              targetCursor = targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();
              var lineDiff = targetToPos.line - targetCursor.line;
              sourceCursor.line += lineDiff;
              targetCursor.line += lineDiff;
              if (lineDiff < 0) {
                sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
                targetCursor.column = targetLines.getLineLength(targetCursor.line);
              } else {
                assert_1$1.default.strictEqual(lineDiff, 0);
              }
              while (util$2.comparePos(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {
                assert_1$1.default.ok(sourceLines.prevPos(sourceCursor, true));
                assert_1$1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
              }
            }
            return sourceCursor;
          }
          var mapping = /* @__PURE__ */ Object.defineProperty({default: _default$2}, "__esModule", {value: true});
          var lines = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.concat = exports4.fromString = exports4.countSpaces = exports4.Lines = void 0;
            var assert_12 = tslib_1.__importDefault(require$$0$1);
            var source_map_1 = tslib_1.__importDefault(sourceMap);
            var mapping_1 = tslib_1.__importDefault(mapping);
            var Lines = function() {
              function Lines2(infos, sourceFileName) {
                if (sourceFileName === void 0) {
                  sourceFileName = null;
                }
                this.infos = infos;
                this.mappings = [];
                this.cachedSourceMap = null;
                this.cachedTabWidth = void 0;
                assert_12.default.ok(infos.length > 0);
                this.length = infos.length;
                this.name = sourceFileName || null;
                if (this.name) {
                  this.mappings.push(new mapping_1.default(this, {start: this.firstPos(), end: this.lastPos()}));
                }
              }
              Lines2.prototype.toString = function(options2) {
                return this.sliceString(this.firstPos(), this.lastPos(), options2);
              };
              Lines2.prototype.getSourceMap = function(sourceMapName, sourceRoot) {
                if (!sourceMapName) {
                  return null;
                }
                var targetLines = this;
                function updateJSON(json) {
                  json = json || {};
                  json.file = sourceMapName;
                  if (sourceRoot) {
                    json.sourceRoot = sourceRoot;
                  }
                  return json;
                }
                if (targetLines.cachedSourceMap) {
                  return updateJSON(targetLines.cachedSourceMap.toJSON());
                }
                var smg = new source_map_1.default.SourceMapGenerator(updateJSON());
                var sourcesToContents = {};
                targetLines.mappings.forEach(function(mapping2) {
                  var sourceCursor = mapping2.sourceLines.skipSpaces(mapping2.sourceLoc.start) || mapping2.sourceLines.lastPos();
                  var targetCursor = targetLines.skipSpaces(mapping2.targetLoc.start) || targetLines.lastPos();
                  while (util$2.comparePos(sourceCursor, mapping2.sourceLoc.end) < 0 && util$2.comparePos(targetCursor, mapping2.targetLoc.end) < 0) {
                    var sourceChar = mapping2.sourceLines.charAt(sourceCursor);
                    var targetChar = targetLines.charAt(targetCursor);
                    assert_12.default.strictEqual(sourceChar, targetChar);
                    var sourceName = mapping2.sourceLines.name;
                    smg.addMapping({source: sourceName, original: {line: sourceCursor.line, column: sourceCursor.column}, generated: {line: targetCursor.line, column: targetCursor.column}});
                    if (!hasOwn2.call(sourcesToContents, sourceName)) {
                      var sourceContent = mapping2.sourceLines.toString();
                      smg.setSourceContent(sourceName, sourceContent);
                      sourcesToContents[sourceName] = sourceContent;
                    }
                    targetLines.nextPos(targetCursor, true);
                    mapping2.sourceLines.nextPos(sourceCursor, true);
                  }
                });
                targetLines.cachedSourceMap = smg;
                return smg.toJSON();
              };
              Lines2.prototype.bootstrapCharAt = function(pos) {
                assert_12.default.strictEqual(typeof pos, "object");
                assert_12.default.strictEqual(typeof pos.line, "number");
                assert_12.default.strictEqual(typeof pos.column, "number");
                var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];
                if (typeof string === "undefined")
                  return "";
                if (column === string.length && line < strings.length)
                  return "\n";
                if (column >= string.length)
                  return "";
                return string.charAt(column);
              };
              Lines2.prototype.charAt = function(pos) {
                assert_12.default.strictEqual(typeof pos, "object");
                assert_12.default.strictEqual(typeof pos.line, "number");
                assert_12.default.strictEqual(typeof pos.column, "number");
                var line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c2 = column;
                if (typeof info === "undefined" || c2 < 0)
                  return "";
                var indent = this.getIndentAt(line);
                if (c2 < indent)
                  return " ";
                c2 += info.sliceStart - indent;
                if (c2 === info.sliceEnd && line < this.length)
                  return "\n";
                if (c2 >= info.sliceEnd)
                  return "";
                return info.line.charAt(c2);
              };
              Lines2.prototype.stripMargin = function(width, skipFirstLine) {
                if (width === 0)
                  return this;
                assert_12.default.ok(width > 0, "negative margin: " + width);
                if (skipFirstLine && this.length === 1)
                  return this;
                var lines2 = new Lines2(this.infos.map(function(info, i) {
                  if (info.line && (i > 0 || !skipFirstLine)) {
                    info = tslib_1.__assign(tslib_1.__assign({}, info), {indent: Math.max(0, info.indent - width)});
                  }
                  return info;
                }));
                if (this.mappings.length > 0) {
                  var newMappings_1 = lines2.mappings;
                  assert_12.default.strictEqual(newMappings_1.length, 0);
                  this.mappings.forEach(function(mapping2) {
                    newMappings_1.push(mapping2.indent(width, skipFirstLine, true));
                  });
                }
                return lines2;
              };
              Lines2.prototype.indent = function(by) {
                if (by === 0) {
                  return this;
                }
                var lines2 = new Lines2(this.infos.map(function(info) {
                  if (info.line && !info.locked) {
                    info = tslib_1.__assign(tslib_1.__assign({}, info), {indent: info.indent + by});
                  }
                  return info;
                }));
                if (this.mappings.length > 0) {
                  var newMappings_2 = lines2.mappings;
                  assert_12.default.strictEqual(newMappings_2.length, 0);
                  this.mappings.forEach(function(mapping2) {
                    newMappings_2.push(mapping2.indent(by));
                  });
                }
                return lines2;
              };
              Lines2.prototype.indentTail = function(by) {
                if (by === 0) {
                  return this;
                }
                if (this.length < 2) {
                  return this;
                }
                var lines2 = new Lines2(this.infos.map(function(info, i) {
                  if (i > 0 && info.line && !info.locked) {
                    info = tslib_1.__assign(tslib_1.__assign({}, info), {indent: info.indent + by});
                  }
                  return info;
                }));
                if (this.mappings.length > 0) {
                  var newMappings_3 = lines2.mappings;
                  assert_12.default.strictEqual(newMappings_3.length, 0);
                  this.mappings.forEach(function(mapping2) {
                    newMappings_3.push(mapping2.indent(by, true));
                  });
                }
                return lines2;
              };
              Lines2.prototype.lockIndentTail = function() {
                if (this.length < 2) {
                  return this;
                }
                return new Lines2(this.infos.map(function(info, i) {
                  return tslib_1.__assign(tslib_1.__assign({}, info), {locked: i > 0});
                }));
              };
              Lines2.prototype.getIndentAt = function(line) {
                assert_12.default.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
                return Math.max(this.infos[line - 1].indent, 0);
              };
              Lines2.prototype.guessTabWidth = function() {
                if (typeof this.cachedTabWidth === "number") {
                  return this.cachedTabWidth;
                }
                var counts = [];
                var lastIndent = 0;
                for (var line = 1, last2 = this.length; line <= last2; ++line) {
                  var info = this.infos[line - 1];
                  var sliced = info.line.slice(info.sliceStart, info.sliceEnd);
                  if (isOnlyWhitespace(sliced)) {
                    continue;
                  }
                  var diff = Math.abs(info.indent - lastIndent);
                  counts[diff] = ~~counts[diff] + 1;
                  lastIndent = info.indent;
                }
                var maxCount = -1;
                var result = 2;
                for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
                  if (hasOwn2.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
                    maxCount = counts[tabWidth];
                    result = tabWidth;
                  }
                }
                return this.cachedTabWidth = result;
              };
              Lines2.prototype.startsWithComment = function() {
                if (this.infos.length === 0) {
                  return false;
                }
                var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
                return firstLine.length === 0 || firstLine.slice(0, 2) === "//" || firstLine.slice(0, 2) === "/*";
              };
              Lines2.prototype.isOnlyWhitespace = function() {
                return isOnlyWhitespace(this.toString());
              };
              Lines2.prototype.isPrecededOnlyByWhitespace = function(pos) {
                var info = this.infos[pos.line - 1];
                var indent = Math.max(info.indent, 0);
                var diff = pos.column - indent;
                if (diff <= 0) {
                  return true;
                }
                var start = info.sliceStart;
                var end = Math.min(start + diff, info.sliceEnd);
                var prefix2 = info.line.slice(start, end);
                return isOnlyWhitespace(prefix2);
              };
              Lines2.prototype.getLineLength = function(line) {
                var info = this.infos[line - 1];
                return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
              };
              Lines2.prototype.nextPos = function(pos, skipSpaces) {
                if (skipSpaces === void 0) {
                  skipSpaces = false;
                }
                var l = Math.max(pos.line, 0), c2 = Math.max(pos.column, 0);
                if (c2 < this.getLineLength(l)) {
                  pos.column += 1;
                  return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
                }
                if (l < this.length) {
                  pos.line += 1;
                  pos.column = 0;
                  return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
                }
                return false;
              };
              Lines2.prototype.prevPos = function(pos, skipSpaces) {
                if (skipSpaces === void 0) {
                  skipSpaces = false;
                }
                var l = pos.line, c2 = pos.column;
                if (c2 < 1) {
                  l -= 1;
                  if (l < 1)
                    return false;
                  c2 = this.getLineLength(l);
                } else {
                  c2 = Math.min(c2 - 1, this.getLineLength(l));
                }
                pos.line = l;
                pos.column = c2;
                return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
              };
              Lines2.prototype.firstPos = function() {
                return {line: 1, column: 0};
              };
              Lines2.prototype.lastPos = function() {
                return {line: this.length, column: this.getLineLength(this.length)};
              };
              Lines2.prototype.skipSpaces = function(pos, backward, modifyInPlace) {
                if (backward === void 0) {
                  backward = false;
                }
                if (modifyInPlace === void 0) {
                  modifyInPlace = false;
                }
                if (pos) {
                  pos = modifyInPlace ? pos : {line: pos.line, column: pos.column};
                } else if (backward) {
                  pos = this.lastPos();
                } else {
                  pos = this.firstPos();
                }
                if (backward) {
                  while (this.prevPos(pos)) {
                    if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
                      return pos;
                    }
                  }
                  return null;
                } else {
                  while (isOnlyWhitespace(this.charAt(pos))) {
                    if (!this.nextPos(pos)) {
                      return null;
                    }
                  }
                  return pos;
                }
              };
              Lines2.prototype.trimLeft = function() {
                var pos = this.skipSpaces(this.firstPos(), false, true);
                return pos ? this.slice(pos) : emptyLines;
              };
              Lines2.prototype.trimRight = function() {
                var pos = this.skipSpaces(this.lastPos(), true, true);
                return pos ? this.slice(this.firstPos(), pos) : emptyLines;
              };
              Lines2.prototype.trim = function() {
                var start = this.skipSpaces(this.firstPos(), false, true);
                if (start === null) {
                  return emptyLines;
                }
                var end = this.skipSpaces(this.lastPos(), true, true);
                if (end === null) {
                  return emptyLines;
                }
                return this.slice(start, end);
              };
              Lines2.prototype.eachPos = function(callback, startPos, skipSpaces) {
                if (startPos === void 0) {
                  startPos = this.firstPos();
                }
                if (skipSpaces === void 0) {
                  skipSpaces = false;
                }
                var pos = this.firstPos();
                if (startPos) {
                  pos.line = startPos.line, pos.column = startPos.column;
                }
                if (skipSpaces && !this.skipSpaces(pos, false, true)) {
                  return;
                }
                do
                  callback.call(this, pos);
                while (this.nextPos(pos, skipSpaces));
              };
              Lines2.prototype.bootstrapSlice = function(start, end) {
                var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);
                if (strings.length > 0) {
                  strings.push(strings.pop().slice(0, end.column));
                  strings[0] = strings[0].slice(start.column);
                }
                return fromString2(strings.join("\n"));
              };
              Lines2.prototype.slice = function(start, end) {
                if (!end) {
                  if (!start) {
                    return this;
                  }
                  end = this.lastPos();
                }
                if (!start) {
                  throw new Error("cannot slice with end but not start");
                }
                var sliced = this.infos.slice(start.line - 1, end.line);
                if (start.line === end.line) {
                  sliced[0] = sliceInfo(sliced[0], start.column, end.column);
                } else {
                  assert_12.default.ok(start.line < end.line);
                  sliced[0] = sliceInfo(sliced[0], start.column);
                  sliced.push(sliceInfo(sliced.pop(), 0, end.column));
                }
                var lines2 = new Lines2(sliced);
                if (this.mappings.length > 0) {
                  var newMappings_4 = lines2.mappings;
                  assert_12.default.strictEqual(newMappings_4.length, 0);
                  this.mappings.forEach(function(mapping2) {
                    var sliced2 = mapping2.slice(this, start, end);
                    if (sliced2) {
                      newMappings_4.push(sliced2);
                    }
                  }, this);
                }
                return lines2;
              };
              Lines2.prototype.bootstrapSliceString = function(start, end, options2) {
                return this.slice(start, end).toString(options2);
              };
              Lines2.prototype.sliceString = function(start, end, options$1) {
                if (start === void 0) {
                  start = this.firstPos();
                }
                if (end === void 0) {
                  end = this.lastPos();
                }
                var _a = options.normalize(options$1), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;
                var parts = [];
                for (var line = start.line; line <= end.line; ++line) {
                  var info = this.infos[line - 1];
                  if (line === start.line) {
                    if (line === end.line) {
                      info = sliceInfo(info, start.column, end.column);
                    } else {
                      info = sliceInfo(info, start.column);
                    }
                  } else if (line === end.line) {
                    info = sliceInfo(info, 0, end.column);
                  }
                  var indent = Math.max(info.indent, 0);
                  var before_1 = info.line.slice(0, info.sliceStart);
                  if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {
                    parts.push(info.line.slice(0, info.sliceEnd));
                    continue;
                  }
                  var tabs = 0;
                  var spaces = indent;
                  if (useTabs) {
                    tabs = Math.floor(indent / tabWidth);
                    spaces -= tabs * tabWidth;
                  }
                  var result = "";
                  if (tabs > 0) {
                    result += new Array(tabs + 1).join("	");
                  }
                  if (spaces > 0) {
                    result += new Array(spaces + 1).join(" ");
                  }
                  result += info.line.slice(info.sliceStart, info.sliceEnd);
                  parts.push(result);
                }
                return parts.join(lineTerminator);
              };
              Lines2.prototype.isEmpty = function() {
                return this.length < 2 && this.getLineLength(1) < 1;
              };
              Lines2.prototype.join = function(elements) {
                var separator = this;
                var infos = [];
                var mappings = [];
                var prevInfo;
                function appendLines(linesOrNull) {
                  if (linesOrNull === null) {
                    return;
                  }
                  if (prevInfo) {
                    var info = linesOrNull.infos[0];
                    var indent = new Array(info.indent + 1).join(" ");
                    var prevLine_1 = infos.length;
                    var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
                    prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);
                    prevInfo.locked = prevInfo.locked || info.locked;
                    prevInfo.sliceEnd = prevInfo.line.length;
                    if (linesOrNull.mappings.length > 0) {
                      linesOrNull.mappings.forEach(function(mapping2) {
                        mappings.push(mapping2.add(prevLine_1, prevColumn_1));
                      });
                    }
                  } else if (linesOrNull.mappings.length > 0) {
                    mappings.push.apply(mappings, linesOrNull.mappings);
                  }
                  linesOrNull.infos.forEach(function(info2, i) {
                    if (!prevInfo || i > 0) {
                      prevInfo = tslib_1.__assign({}, info2);
                      infos.push(prevInfo);
                    }
                  });
                }
                function appendWithSeparator(linesOrNull, i) {
                  if (i > 0)
                    appendLines(separator);
                  appendLines(linesOrNull);
                }
                elements.map(function(elem) {
                  var lines3 = fromString2(elem);
                  if (lines3.isEmpty())
                    return null;
                  return lines3;
                }).forEach(function(linesOrNull, i) {
                  if (separator.isEmpty()) {
                    appendLines(linesOrNull);
                  } else {
                    appendWithSeparator(linesOrNull, i);
                  }
                });
                if (infos.length < 1)
                  return emptyLines;
                var lines2 = new Lines2(infos);
                lines2.mappings = mappings;
                return lines2;
              };
              Lines2.prototype.concat = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                var list = [this];
                list.push.apply(list, args);
                assert_12.default.strictEqual(list.length, args.length + 1);
                return emptyLines.join(list);
              };
              return Lines2;
            }();
            exports4.Lines = Lines;
            var fromStringCache = {};
            var hasOwn2 = fromStringCache.hasOwnProperty;
            var maxCacheKeyLen = 10;
            function countSpaces(spaces, tabWidth) {
              var count = 0;
              var len = spaces.length;
              for (var i = 0; i < len; ++i) {
                switch (spaces.charCodeAt(i)) {
                  case 9: {
                    assert_12.default.strictEqual(typeof tabWidth, "number");
                    assert_12.default.ok(tabWidth > 0);
                    var next = Math.ceil(count / tabWidth) * tabWidth;
                    if (next === count) {
                      count += tabWidth;
                    } else {
                      count = next;
                    }
                    break;
                  }
                  case 11:
                  case 12:
                  case 13:
                  case 65279:
                    break;
                  case 32:
                  default:
                    count += 1;
                    break;
                }
              }
              return count;
            }
            exports4.countSpaces = countSpaces;
            var leadingSpaceExp = /^\s*/;
            var lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
            function fromString2(string, options$1) {
              if (string instanceof Lines)
                return string;
              string += "";
              var tabWidth = options$1 && options$1.tabWidth;
              var tabless = string.indexOf("	") < 0;
              var cacheable = !options$1 && tabless && string.length <= maxCacheKeyLen;
              assert_12.default.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);
              if (cacheable && hasOwn2.call(fromStringCache, string))
                return fromStringCache[string];
              var lines2 = new Lines(string.split(lineTerminatorSeqExp).map(function(line) {
                var spaces = leadingSpaceExp.exec(line)[0];
                return {
                  line,
                  indent: countSpaces(spaces, tabWidth),
                  locked: false,
                  sliceStart: spaces.length,
                  sliceEnd: line.length
                };
              }), options.normalize(options$1).sourceFileName);
              if (cacheable)
                fromStringCache[string] = lines2;
              return lines2;
            }
            exports4.fromString = fromString2;
            function isOnlyWhitespace(string) {
              return !/\S/.test(string);
            }
            function sliceInfo(info, startCol, endCol) {
              var sliceStart = info.sliceStart;
              var sliceEnd = info.sliceEnd;
              var indent = Math.max(info.indent, 0);
              var lineLength = indent + sliceEnd - sliceStart;
              if (typeof endCol === "undefined") {
                endCol = lineLength;
              }
              startCol = Math.max(startCol, 0);
              endCol = Math.min(endCol, lineLength);
              endCol = Math.max(endCol, startCol);
              if (endCol < indent) {
                indent = endCol;
                sliceEnd = sliceStart;
              } else {
                sliceEnd -= lineLength - endCol;
              }
              lineLength = endCol;
              lineLength -= startCol;
              if (startCol < indent) {
                indent -= startCol;
              } else {
                startCol -= indent;
                indent = 0;
                sliceStart += startCol;
              }
              assert_12.default.ok(indent >= 0);
              assert_12.default.ok(sliceStart <= sliceEnd);
              assert_12.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);
              if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {
                return info;
              }
              return {
                line: info.line,
                indent,
                locked: false,
                sliceStart,
                sliceEnd
              };
            }
            function concat(elements) {
              return emptyLines.join(elements);
            }
            exports4.concat = concat;
            var emptyLines = fromString2("");
          });
          var comments = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.printComments = exports4.attach = void 0;
            var assert_12 = tslib_1.__importDefault(require$$0$1);
            var types2 = tslib_1.__importStar(main$1);
            var n2 = types2.namedTypes;
            var isArray2 = types2.builtInTypes.array;
            var isObject3 = types2.builtInTypes.object;
            var childNodesCache = new WeakMap();
            function getSortedChildNodes(node2, lines2, resultArray) {
              if (!node2) {
                return resultArray;
              }
              util$2.fixFaultyLocations(node2, lines2);
              if (resultArray) {
                if (n2.Node.check(node2) && n2.SourceLocation.check(node2.loc)) {
                  var i = resultArray.length - 1;
                  for (; i >= 0; --i) {
                    var child = resultArray[i];
                    if (child && child.loc && util$2.comparePos(child.loc.end, node2.loc.start) <= 0) {
                      break;
                    }
                  }
                  resultArray.splice(i + 1, 0, node2);
                  return resultArray;
                }
              } else {
                var childNodes = childNodesCache.get(node2);
                if (childNodes) {
                  return childNodes;
                }
              }
              var names;
              if (isArray2.check(node2)) {
                names = Object.keys(node2);
              } else if (isObject3.check(node2)) {
                names = types2.getFieldNames(node2);
              } else {
                return resultArray;
              }
              if (!resultArray) {
                childNodesCache.set(node2, resultArray = []);
              }
              for (var i = 0, nameCount = names.length; i < nameCount; ++i) {
                getSortedChildNodes(node2[names[i]], lines2, resultArray);
              }
              return resultArray;
            }
            function decorateComment(node2, comment2, lines2) {
              var childNodes = getSortedChildNodes(node2, lines2);
              var left = 0;
              var right = childNodes && childNodes.length;
              var precedingNode;
              var followingNode;
              while (typeof right === "number" && left < right) {
                var middle = left + right >> 1;
                var child = childNodes[middle];
                if (util$2.comparePos(child.loc.start, comment2.loc.start) <= 0 && util$2.comparePos(comment2.loc.end, child.loc.end) <= 0) {
                  decorateComment(comment2.enclosingNode = child, comment2, lines2);
                  return;
                }
                if (util$2.comparePos(child.loc.end, comment2.loc.start) <= 0) {
                  precedingNode = child;
                  left = middle + 1;
                  continue;
                }
                if (util$2.comparePos(comment2.loc.end, child.loc.start) <= 0) {
                  followingNode = child;
                  right = middle;
                  continue;
                }
                throw new Error("Comment location overlaps with node location");
              }
              if (precedingNode) {
                comment2.precedingNode = precedingNode;
              }
              if (followingNode) {
                comment2.followingNode = followingNode;
              }
            }
            function attach(comments2, ast, lines2) {
              if (!isArray2.check(comments2)) {
                return;
              }
              var tiesToBreak = [];
              comments2.forEach(function(comment2) {
                comment2.loc.lines = lines2;
                decorateComment(ast, comment2, lines2);
                var pn = comment2.precedingNode;
                var en = comment2.enclosingNode;
                var fn = comment2.followingNode;
                if (pn && fn) {
                  var tieCount = tiesToBreak.length;
                  if (tieCount > 0) {
                    var lastTie = tiesToBreak[tieCount - 1];
                    assert_12.default.strictEqual(lastTie.precedingNode === comment2.precedingNode, lastTie.followingNode === comment2.followingNode);
                    if (lastTie.followingNode !== comment2.followingNode) {
                      breakTies(tiesToBreak, lines2);
                    }
                  }
                  tiesToBreak.push(comment2);
                } else if (pn) {
                  breakTies(tiesToBreak, lines2);
                  addTrailingComment(pn, comment2);
                } else if (fn) {
                  breakTies(tiesToBreak, lines2);
                  addLeadingComment(fn, comment2);
                } else if (en) {
                  breakTies(tiesToBreak, lines2);
                  addDanglingComment(en, comment2);
                } else {
                  throw new Error("AST contains no nodes at all?");
                }
              });
              breakTies(tiesToBreak, lines2);
              comments2.forEach(function(comment2) {
                delete comment2.precedingNode;
                delete comment2.enclosingNode;
                delete comment2.followingNode;
              });
            }
            exports4.attach = attach;
            function breakTies(tiesToBreak, lines2) {
              var tieCount = tiesToBreak.length;
              if (tieCount === 0) {
                return;
              }
              var pn = tiesToBreak[0].precedingNode;
              var fn = tiesToBreak[0].followingNode;
              var gapEndPos = fn.loc.start;
              var indexOfFirstLeadingComment = tieCount;
              var comment2;
              for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
                comment2 = tiesToBreak[indexOfFirstLeadingComment - 1];
                assert_12.default.strictEqual(comment2.precedingNode, pn);
                assert_12.default.strictEqual(comment2.followingNode, fn);
                var gap = lines2.sliceString(comment2.loc.end, gapEndPos);
                if (/\S/.test(gap)) {
                  break;
                }
                gapEndPos = comment2.loc.start;
              }
              while (indexOfFirstLeadingComment <= tieCount && (comment2 = tiesToBreak[indexOfFirstLeadingComment]) && (comment2.type === "Line" || comment2.type === "CommentLine") && comment2.loc.start.column > fn.loc.start.column) {
                ++indexOfFirstLeadingComment;
              }
              tiesToBreak.forEach(function(comment3, i) {
                if (i < indexOfFirstLeadingComment) {
                  addTrailingComment(pn, comment3);
                } else {
                  addLeadingComment(fn, comment3);
                }
              });
              tiesToBreak.length = 0;
            }
            function addCommentHelper(node2, comment2) {
              var comments2 = node2.comments || (node2.comments = []);
              comments2.push(comment2);
            }
            function addLeadingComment(node2, comment2) {
              comment2.leading = true;
              comment2.trailing = false;
              addCommentHelper(node2, comment2);
            }
            function addDanglingComment(node2, comment2) {
              comment2.leading = false;
              comment2.trailing = false;
              addCommentHelper(node2, comment2);
            }
            function addTrailingComment(node2, comment2) {
              comment2.leading = false;
              comment2.trailing = true;
              addCommentHelper(node2, comment2);
            }
            function printLeadingComment(commentPath, print) {
              var comment2 = commentPath.getValue();
              n2.Comment.assert(comment2);
              var loc = comment2.loc;
              var lines$1 = loc && loc.lines;
              var parts = [print(commentPath)];
              if (comment2.trailing) {
                parts.push("\n");
              } else if (lines$1 instanceof lines.Lines) {
                var trailingSpace = lines$1.slice(loc.end, lines$1.skipSpaces(loc.end) || lines$1.lastPos());
                if (trailingSpace.length === 1) {
                  parts.push(trailingSpace);
                } else {
                  parts.push(new Array(trailingSpace.length).join("\n"));
                }
              } else {
                parts.push("\n");
              }
              return lines.concat(parts);
            }
            function printTrailingComment(commentPath, print) {
              var comment2 = commentPath.getValue(commentPath);
              n2.Comment.assert(comment2);
              var loc = comment2.loc;
              var lines$1 = loc && loc.lines;
              var parts = [];
              if (lines$1 instanceof lines.Lines) {
                var fromPos = lines$1.skipSpaces(loc.start, true) || lines$1.firstPos();
                var leadingSpace = lines$1.slice(fromPos, loc.start);
                if (leadingSpace.length === 1) {
                  parts.push(leadingSpace);
                } else {
                  parts.push(new Array(leadingSpace.length).join("\n"));
                }
              }
              parts.push(print(commentPath));
              return lines.concat(parts);
            }
            function printComments(path2, print) {
              var value = path2.getValue();
              var innerLines = print(path2);
              var comments2 = n2.Node.check(value) && types2.getFieldValue(value, "comments");
              if (!comments2 || comments2.length === 0) {
                return innerLines;
              }
              var leadingParts = [];
              var trailingParts = [innerLines];
              path2.each(function(commentPath) {
                var comment2 = commentPath.getValue();
                var leading = types2.getFieldValue(comment2, "leading");
                var trailing = types2.getFieldValue(comment2, "trailing");
                if (leading || trailing && !(n2.Statement.check(value) || comment2.type === "Block" || comment2.type === "CommentBlock")) {
                  leadingParts.push(printLeadingComment(commentPath, print));
                } else if (trailing) {
                  trailingParts.push(printTrailingComment(commentPath, print));
                }
              }, "comments");
              leadingParts.push.apply(leadingParts, trailingParts);
              return lines.concat(leadingParts);
            }
            exports4.printComments = printComments;
          });
          var parser$1 = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.parse = void 0;
            var assert_12 = tslib_1.__importDefault(require$$0$1);
            var types2 = tslib_1.__importStar(main$1);
            var b = types2.builders;
            var isObject3 = types2.builtInTypes.object;
            var isArray2 = types2.builtInTypes.array;
            var util2 = tslib_1.__importStar(util$2);
            function parse(source, options$1) {
              options$1 = options.normalize(options$1);
              var lines$1 = lines.fromString(source, options$1);
              var sourceWithoutTabs = lines$1.toString({tabWidth: options$1.tabWidth, reuseWhitespace: false, useTabs: false});
              var comments$1 = [];
              var ast = options$1.parser.parse(sourceWithoutTabs, {jsx: true, loc: true, locations: true, range: options$1.range, comment: true, onComment: comments$1, tolerant: util2.getOption(options$1, "tolerant", true), ecmaVersion: 6, sourceType: util2.getOption(options$1, "sourceType", "module")});
              var tokens = Array.isArray(ast.tokens) ? ast.tokens : esprima$1.tokenize(sourceWithoutTabs, {loc: true});
              delete ast.tokens;
              tokens.forEach(function(token) {
                if (typeof token.value !== "string") {
                  token.value = lines$1.sliceString(token.loc.start, token.loc.end);
                }
              });
              if (Array.isArray(ast.comments)) {
                comments$1 = ast.comments;
                delete ast.comments;
              }
              if (ast.loc) {
                util2.fixFaultyLocations(ast, lines$1);
              } else {
                ast.loc = {start: lines$1.firstPos(), end: lines$1.lastPos()};
              }
              ast.loc.lines = lines$1;
              ast.loc.indent = 0;
              var file;
              var program;
              if (ast.type === "Program") {
                program = ast;
                file = b.file(ast, options$1.sourceFileName || null);
                file.loc = {start: lines$1.firstPos(), end: lines$1.lastPos(), lines: lines$1, indent: 0};
              } else if (ast.type === "File") {
                file = ast;
                program = file.program;
              }
              if (options$1.tokens) {
                file.tokens = tokens;
              }
              var trueProgramLoc = util2.getTrueLoc({type: program.type, loc: program.loc, body: [], comments: comments$1}, lines$1);
              program.loc.start = trueProgramLoc.start;
              program.loc.end = trueProgramLoc.end;
              comments.attach(comments$1, program.body.length ? file.program : file, lines$1);
              return new TreeCopier(lines$1, tokens).copy(file);
            }
            exports4.parse = parse;
            var TreeCopier = function TreeCopier2(lines2, tokens) {
              assert_12.default.ok(this instanceof TreeCopier2);
              this.lines = lines2;
              this.tokens = tokens;
              this.startTokenIndex = 0;
              this.endTokenIndex = tokens.length;
              this.indent = 0;
              this.seen = new Map();
            };
            var TCp = TreeCopier.prototype;
            TCp.copy = function(node2) {
              if (this.seen.has(node2)) {
                return this.seen.get(node2);
              }
              if (isArray2.check(node2)) {
                var copy_1 = new Array(node2.length);
                this.seen.set(node2, copy_1);
                node2.forEach(function(item, i2) {
                  copy_1[i2] = this.copy(item);
                }, this);
                return copy_1;
              }
              if (!isObject3.check(node2)) {
                return node2;
              }
              util2.fixFaultyLocations(node2, this.lines);
              var copy2 = Object.create(Object.getPrototypeOf(node2), {original: {
                value: node2,
                configurable: false,
                enumerable: false,
                writable: true
              }});
              this.seen.set(node2, copy2);
              var loc = node2.loc;
              var oldIndent = this.indent;
              var newIndent = oldIndent;
              var oldStartTokenIndex = this.startTokenIndex;
              var oldEndTokenIndex = this.endTokenIndex;
              if (loc) {
                if (node2.type === "Block" || node2.type === "Line" || node2.type === "CommentBlock" || node2.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) {
                  newIndent = this.indent = loc.start.column;
                }
                loc.lines = this.lines;
                loc.tokens = this.tokens;
                loc.indent = newIndent;
                this.findTokenRange(loc);
              }
              var keys = Object.keys(node2);
              var keyCount = keys.length;
              for (var i = 0; i < keyCount; ++i) {
                var key = keys[i];
                if (key === "loc") {
                  copy2[key] = node2[key];
                } else if (key === "tokens" && node2.type === "File") {
                  copy2[key] = node2[key];
                } else {
                  copy2[key] = this.copy(node2[key]);
                }
              }
              this.indent = oldIndent;
              this.startTokenIndex = oldStartTokenIndex;
              this.endTokenIndex = oldEndTokenIndex;
              return copy2;
            };
            TCp.findTokenRange = function(loc) {
              while (this.startTokenIndex > 0) {
                var token = loc.tokens[this.startTokenIndex];
                if (util2.comparePos(loc.start, token.loc.start) < 0) {
                  --this.startTokenIndex;
                } else
                  break;
              }
              while (this.endTokenIndex < loc.tokens.length) {
                var token = loc.tokens[this.endTokenIndex];
                if (util2.comparePos(token.loc.end, loc.end) < 0) {
                  ++this.endTokenIndex;
                } else
                  break;
              }
              while (this.startTokenIndex < this.endTokenIndex) {
                var token = loc.tokens[this.startTokenIndex];
                if (util2.comparePos(token.loc.start, loc.start) < 0) {
                  ++this.startTokenIndex;
                } else
                  break;
              }
              loc.start.token = this.startTokenIndex;
              while (this.endTokenIndex > this.startTokenIndex) {
                var token = loc.tokens[this.endTokenIndex - 1];
                if (util2.comparePos(loc.end, token.loc.end) < 0) {
                  --this.endTokenIndex;
                } else
                  break;
              }
              loc.end.token = this.endTokenIndex;
            };
          });
          var assert_1 = tslib_1.__importDefault(require$$0$1);
          var types$3 = tslib_1.__importStar(main$1);
          var util$1 = tslib_1.__importStar(util$2);
          var n = types$3.namedTypes;
          var isArray = types$3.builtInTypes.array;
          var isNumber = types$3.builtInTypes.number;
          var PRECEDENCE = {};
          [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].forEach(function(tier, i) {
            tier.forEach(function(op) {
              PRECEDENCE[op] = i;
            });
          });
          var FastPath = function FastPath2(value) {
            assert_1.default.ok(this instanceof FastPath2);
            this.stack = [value];
          };
          var FPp = FastPath.prototype;
          FastPath.from = function(obj) {
            if (obj instanceof FastPath) {
              return obj.copy();
            }
            if (obj instanceof types$3.NodePath) {
              var copy2 = Object.create(FastPath.prototype);
              var stack = [obj.value];
              for (var pp = void 0; pp = obj.parentPath; obj = pp)
                stack.push(obj.name, pp.value);
              copy2.stack = stack.reverse();
              return copy2;
            }
            return new FastPath(obj);
          };
          FPp.copy = function copy2() {
            var copy3 = Object.create(FastPath.prototype);
            copy3.stack = this.stack.slice(0);
            return copy3;
          };
          FPp.getName = function getName3() {
            var s = this.stack;
            var len = s.length;
            if (len > 1) {
              return s[len - 2];
            }
            return null;
          };
          FPp.getValue = function getValue() {
            var s = this.stack;
            return s[s.length - 1];
          };
          FPp.valueIsDuplicate = function() {
            var s = this.stack;
            var valueIndex = s.length - 1;
            return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
          };
          function getNodeHelper(path2, count) {
            var s = path2.stack;
            for (var i = s.length - 1; i >= 0; i -= 2) {
              var value = s[i];
              if (n.Node.check(value) && --count < 0) {
                return value;
              }
            }
            return null;
          }
          FPp.getNode = function getNode(count) {
            if (count === void 0) {
              count = 0;
            }
            return getNodeHelper(this, ~~count);
          };
          FPp.getParentNode = function getParentNode(count) {
            if (count === void 0) {
              count = 0;
            }
            return getNodeHelper(this, ~~count + 1);
          };
          FPp.getRootValue = function getRootValue() {
            var s = this.stack;
            if (s.length % 2 === 0) {
              return s[1];
            }
            return s[0];
          };
          FPp.call = function call(callback) {
            var s = this.stack;
            var origLen = s.length;
            var value = s[origLen - 1];
            var argc = arguments.length;
            for (var i = 1; i < argc; ++i) {
              var name2 = arguments[i];
              value = value[name2];
              s.push(name2, value);
            }
            var result = callback(this);
            s.length = origLen;
            return result;
          };
          FPp.each = function each(callback) {
            var s = this.stack;
            var origLen = s.length;
            var value = s[origLen - 1];
            var argc = arguments.length;
            for (var i = 1; i < argc; ++i) {
              var name2 = arguments[i];
              value = value[name2];
              s.push(name2, value);
            }
            for (var i = 0; i < value.length; ++i) {
              if (i in value) {
                s.push(i, value[i]);
                callback(this);
                s.length -= 2;
              }
            }
            s.length = origLen;
          };
          FPp.map = function map(callback) {
            var s = this.stack;
            var origLen = s.length;
            var value = s[origLen - 1];
            var argc = arguments.length;
            for (var i = 1; i < argc; ++i) {
              var name2 = arguments[i];
              value = value[name2];
              s.push(name2, value);
            }
            var result = new Array(value.length);
            for (var i = 0; i < value.length; ++i) {
              if (i in value) {
                s.push(i, value[i]);
                result[i] = callback(this, i);
                s.length -= 2;
              }
            }
            s.length = origLen;
            return result;
          };
          FPp.hasParens = function() {
            var node2 = this.getNode();
            var prevToken = this.getPrevToken(node2);
            if (!prevToken) {
              return false;
            }
            var nextToken = this.getNextToken(node2);
            if (!nextToken) {
              return false;
            }
            if (prevToken.value === "(") {
              if (nextToken.value === ")") {
                return true;
              }
              var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);
              if (justNeedsOpeningParen) {
                return true;
              }
            }
            return false;
          };
          FPp.getPrevToken = function(node2) {
            node2 = node2 || this.getNode();
            var loc = node2 && node2.loc;
            var tokens = loc && loc.tokens;
            if (tokens && loc.start.token > 0) {
              var token = tokens[loc.start.token - 1];
              if (token) {
                var rootLoc = this.getRootValue().loc;
                if (util$1.comparePos(rootLoc.start, token.loc.start) <= 0) {
                  return token;
                }
              }
            }
            return null;
          };
          FPp.getNextToken = function(node2) {
            node2 = node2 || this.getNode();
            var loc = node2 && node2.loc;
            var tokens = loc && loc.tokens;
            if (tokens && loc.end.token < tokens.length) {
              var token = tokens[loc.end.token];
              if (token) {
                var rootLoc = this.getRootValue().loc;
                if (util$1.comparePos(token.loc.end, rootLoc.end) <= 0) {
                  return token;
                }
              }
            }
            return null;
          };
          FPp.needsParens = function(assumeExpressionContext) {
            var node2 = this.getNode();
            if (node2.type === "AssignmentExpression" && node2.left.type === "ObjectPattern") {
              return true;
            }
            var parent = this.getParentNode();
            if (!parent) {
              return false;
            }
            var name2 = this.getName();
            if (this.getValue() !== node2) {
              return false;
            }
            if (n.Statement.check(node2)) {
              return false;
            }
            if (node2.type === "Identifier") {
              return false;
            }
            if (parent.type === "ParenthesizedExpression" || node2.extra && node2.extra.parenthesized) {
              return false;
            }
            switch (node2.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return parent.type === "MemberExpression" && name2 === "object" && parent.object === node2;
              case "BinaryExpression":
              case "LogicalExpression":
                switch (parent.type) {
                  case "CallExpression":
                    return name2 === "callee" && parent.callee === node2;
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                    return true;
                  case "MemberExpression":
                    return name2 === "object" && parent.object === node2;
                  case "BinaryExpression":
                  case "LogicalExpression": {
                    var po = parent.operator;
                    var pp = PRECEDENCE[po];
                    var no = node2.operator;
                    var np = PRECEDENCE[no];
                    if (pp > np) {
                      return true;
                    }
                    if (pp === np && name2 === "right") {
                      assert_1.default.strictEqual(parent.right, node2);
                      return true;
                    }
                    break;
                  }
                  default:
                    return false;
                }
                break;
              case "SequenceExpression":
                switch (parent.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return name2 !== "expression";
                  default:
                    return true;
                }
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return parent.type === "NullableTypeAnnotation";
              case "Literal":
                return parent.type === "MemberExpression" && isNumber.check(node2.value) && name2 === "object" && parent.object === node2;
              case "NumericLiteral":
                return parent.type === "MemberExpression" && name2 === "object" && parent.object === node2;
              case "YieldExpression":
              case "AwaitExpression":
              case "AssignmentExpression":
              case "ConditionalExpression":
                switch (parent.type) {
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                    return true;
                  case "CallExpression":
                  case "NewExpression":
                    return name2 === "callee" && parent.callee === node2;
                  case "ConditionalExpression":
                    return name2 === "test" && parent.test === node2;
                  case "MemberExpression":
                    return name2 === "object" && parent.object === node2;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                if (n.CallExpression.check(parent) && name2 === "callee" && parent.callee === node2) {
                  return true;
                }
                if (n.MemberExpression.check(parent) && name2 === "object" && parent.object === node2) {
                  return true;
                }
                if (n.TSAsExpression && n.TSAsExpression.check(parent) && name2 === "expression" && parent.expression === node2) {
                  return true;
                }
                return isBinary(parent);
              case "ObjectExpression":
                if (parent.type === "ArrowFunctionExpression" && name2 === "body" && parent.body === node2) {
                  return true;
                }
                break;
              case "TSAsExpression":
                if (parent.type === "ArrowFunctionExpression" && name2 === "body" && parent.body === node2 && node2.expression.type === "ObjectExpression") {
                  return true;
                }
                break;
              case "CallExpression":
                if (name2 === "declaration" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node2.callee)) {
                  return true;
                }
            }
            if (parent.type === "NewExpression" && name2 === "callee" && parent.callee === node2) {
              return containsCallExpression(node2);
            }
            if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {
              return true;
            }
            return false;
          };
          function isBinary(node2) {
            return n.BinaryExpression.check(node2) || n.LogicalExpression.check(node2);
          }
          function containsCallExpression(node2) {
            if (n.CallExpression.check(node2)) {
              return true;
            }
            if (isArray.check(node2)) {
              return node2.some(containsCallExpression);
            }
            if (n.Node.check(node2)) {
              return types$3.someField(node2, function(_name, child) {
                return containsCallExpression(child);
              });
            }
            return false;
          }
          FPp.canBeFirstInStatement = function() {
            var node2 = this.getNode();
            if (n.FunctionExpression.check(node2)) {
              return false;
            }
            if (n.ObjectExpression.check(node2)) {
              return false;
            }
            if (n.ClassExpression.check(node2)) {
              return false;
            }
            return true;
          };
          FPp.firstInStatement = function() {
            var s = this.stack;
            var parentName, parent;
            var childName, child;
            for (var i = s.length - 1; i >= 0; i -= 2) {
              if (n.Node.check(s[i])) {
                childName = parentName;
                child = parent;
                parentName = s[i - 1];
                parent = s[i];
              }
              if (!parent || !child) {
                continue;
              }
              if (n.BlockStatement.check(parent) && parentName === "body" && childName === 0) {
                assert_1.default.strictEqual(parent.body[0], child);
                return true;
              }
              if (n.ExpressionStatement.check(parent) && childName === "expression") {
                assert_1.default.strictEqual(parent.expression, child);
                return true;
              }
              if (n.AssignmentExpression.check(parent) && childName === "left") {
                assert_1.default.strictEqual(parent.left, child);
                return true;
              }
              if (n.ArrowFunctionExpression.check(parent) && childName === "body") {
                assert_1.default.strictEqual(parent.body, child);
                return true;
              }
              if (n.SequenceExpression.check(parent) && parentName === "expressions" && childName === 0) {
                assert_1.default.strictEqual(parent.expressions[0], child);
                continue;
              }
              if (n.CallExpression.check(parent) && childName === "callee") {
                assert_1.default.strictEqual(parent.callee, child);
                continue;
              }
              if (n.MemberExpression.check(parent) && childName === "object") {
                assert_1.default.strictEqual(parent.object, child);
                continue;
              }
              if (n.ConditionalExpression.check(parent) && childName === "test") {
                assert_1.default.strictEqual(parent.test, child);
                continue;
              }
              if (isBinary(parent) && childName === "left") {
                assert_1.default.strictEqual(parent.left, child);
                continue;
              }
              if (n.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
                assert_1.default.strictEqual(parent.argument, child);
                continue;
              }
              return false;
            }
            return true;
          };
          var _default$1 = FastPath;
          var fastPath = /* @__PURE__ */ Object.defineProperty({default: _default$1}, "__esModule", {value: true});
          var patcher = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.getReprinter = exports4.Patcher = void 0;
            var assert_12 = tslib_1.__importDefault(require$$0$1);
            var linesModule = tslib_1.__importStar(lines);
            var types2 = tslib_1.__importStar(main$1);
            var Printable = types2.namedTypes.Printable;
            var Expression2 = types2.namedTypes.Expression;
            var ReturnStatement = types2.namedTypes.ReturnStatement;
            var SourceLocation2 = types2.namedTypes.SourceLocation;
            var fast_path_1 = tslib_1.__importDefault(fastPath);
            var isObject3 = types2.builtInTypes.object;
            var isArray2 = types2.builtInTypes.array;
            var isString2 = types2.builtInTypes.string;
            var riskyAdjoiningCharExp = /[0-9a-z_$]/i;
            var Patcher = function Patcher2(lines2) {
              assert_12.default.ok(this instanceof Patcher2);
              assert_12.default.ok(lines2 instanceof linesModule.Lines);
              var self2 = this, replacements = [];
              self2.replace = function(loc, lines3) {
                if (isString2.check(lines3))
                  lines3 = linesModule.fromString(lines3);
                replacements.push({lines: lines3, start: loc.start, end: loc.end});
              };
              self2.get = function(loc) {
                loc = loc || {start: {line: 1, column: 0}, end: {line: lines2.length, column: lines2.getLineLength(lines2.length)}};
                var sliceFrom = loc.start, toConcat = [];
                function pushSlice(from2, to) {
                  assert_12.default.ok(util$2.comparePos(from2, to) <= 0);
                  toConcat.push(lines2.slice(from2, to));
                }
                replacements.sort(function(a, b) {
                  return util$2.comparePos(a.start, b.start);
                }).forEach(function(rep) {
                  if (util$2.comparePos(sliceFrom, rep.start) > 0)
                    ;
                  else {
                    pushSlice(sliceFrom, rep.start);
                    toConcat.push(rep.lines);
                    sliceFrom = rep.end;
                  }
                });
                pushSlice(sliceFrom, loc.end);
                return linesModule.concat(toConcat);
              };
            };
            exports4.Patcher = Patcher;
            var Pp = Patcher.prototype;
            Pp.tryToReprintComments = function(newNode, oldNode, print) {
              var patcher2 = this;
              if (!newNode.comments && !oldNode.comments) {
                return true;
              }
              var newPath = fast_path_1.default.from(newNode);
              var oldPath = fast_path_1.default.from(oldNode);
              newPath.stack.push("comments", getSurroundingComments(newNode));
              oldPath.stack.push("comments", getSurroundingComments(oldNode));
              var reprints = [];
              var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
              if (ableToReprintComments && reprints.length > 0) {
                reprints.forEach(function(reprint) {
                  var oldComment = reprint.oldPath.getValue();
                  assert_12.default.ok(oldComment.leading || oldComment.trailing);
                  patcher2.replace(oldComment.loc, print(reprint.newPath).indentTail(oldComment.loc.indent));
                });
              }
              return ableToReprintComments;
            };
            function getSurroundingComments(node2) {
              var result = [];
              if (node2.comments && node2.comments.length > 0) {
                node2.comments.forEach(function(comment2) {
                  if (comment2.leading || comment2.trailing) {
                    result.push(comment2);
                  }
                });
              }
              return result;
            }
            Pp.deleteComments = function(node2) {
              if (!node2.comments) {
                return;
              }
              var patcher2 = this;
              node2.comments.forEach(function(comment2) {
                if (comment2.leading) {
                  patcher2.replace({start: comment2.loc.start, end: node2.loc.lines.skipSpaces(comment2.loc.end, false, false)}, "");
                } else if (comment2.trailing) {
                  patcher2.replace({start: node2.loc.lines.skipSpaces(comment2.loc.start, true, false), end: comment2.loc.end}, "");
                }
              });
            };
            function getReprinter(path2) {
              assert_12.default.ok(path2 instanceof fast_path_1.default);
              var node2 = path2.getValue();
              if (!Printable.check(node2))
                return;
              var orig = node2.original;
              var origLoc = orig && orig.loc;
              var lines2 = origLoc && origLoc.lines;
              var reprints = [];
              if (!lines2 || !findReprints(path2, reprints))
                return;
              return function(print) {
                var patcher2 = new Patcher(lines2);
                reprints.forEach(function(reprint) {
                  var newNode = reprint.newPath.getValue();
                  var oldNode = reprint.oldPath.getValue();
                  SourceLocation2.assert(oldNode.loc, true);
                  var needToPrintNewPathWithComments = !patcher2.tryToReprintComments(newNode, oldNode, print);
                  if (needToPrintNewPathWithComments) {
                    patcher2.deleteComments(oldNode);
                  }
                  var newLines = print(reprint.newPath, {
                    includeComments: needToPrintNewPathWithComments,
                    avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()
                  }).indentTail(oldNode.loc.indent);
                  var nls = needsLeadingSpace(lines2, oldNode.loc, newLines);
                  var nts = needsTrailingSpace(lines2, oldNode.loc, newLines);
                  if (nls || nts) {
                    var newParts = [];
                    nls && newParts.push(" ");
                    newParts.push(newLines);
                    nts && newParts.push(" ");
                    newLines = linesModule.concat(newParts);
                  }
                  patcher2.replace(oldNode.loc, newLines);
                });
                var patchedLines = patcher2.get(origLoc).indentTail(-orig.loc.indent);
                if (path2.needsParens()) {
                  return linesModule.concat(["(", patchedLines, ")"]);
                }
                return patchedLines;
              };
            }
            exports4.getReprinter = getReprinter;
            function needsLeadingSpace(oldLines, oldLoc, newLines) {
              var posBeforeOldLoc = util$2.copyPos(oldLoc.start);
              var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
              var newFirstChar = newLines.charAt(newLines.firstPos());
              return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
            }
            function needsTrailingSpace(oldLines, oldLoc, newLines) {
              var charAfterOldLoc = oldLines.charAt(oldLoc.end);
              var newLastPos = newLines.lastPos();
              var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
              return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
            }
            function findReprints(newPath, reprints) {
              var newNode = newPath.getValue();
              Printable.assert(newNode);
              var oldNode = newNode.original;
              Printable.assert(oldNode);
              assert_12.default.deepEqual(reprints, []);
              if (newNode.type !== oldNode.type) {
                return false;
              }
              var oldPath = new fast_path_1.default(oldNode);
              var canReprint = findChildReprints(newPath, oldPath, reprints);
              if (!canReprint) {
                reprints.length = 0;
              }
              return canReprint;
            }
            function findAnyReprints(newPath, oldPath, reprints) {
              var newNode = newPath.getValue();
              var oldNode = oldPath.getValue();
              if (newNode === oldNode)
                return true;
              if (isArray2.check(newNode))
                return findArrayReprints(newPath, oldPath, reprints);
              if (isObject3.check(newNode))
                return findObjectReprints(newPath, oldPath, reprints);
              return false;
            }
            function findArrayReprints(newPath, oldPath, reprints) {
              var newNode = newPath.getValue();
              var oldNode = oldPath.getValue();
              if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
                return true;
              }
              isArray2.assert(newNode);
              var len = newNode.length;
              if (!(isArray2.check(oldNode) && oldNode.length === len))
                return false;
              for (var i = 0; i < len; ++i) {
                newPath.stack.push(i, newNode[i]);
                oldPath.stack.push(i, oldNode[i]);
                var canReprint = findAnyReprints(newPath, oldPath, reprints);
                newPath.stack.length -= 2;
                oldPath.stack.length -= 2;
                if (!canReprint) {
                  return false;
                }
              }
              return true;
            }
            function findObjectReprints(newPath, oldPath, reprints) {
              var newNode = newPath.getValue();
              isObject3.assert(newNode);
              if (newNode.original === null) {
                return false;
              }
              var oldNode = oldPath.getValue();
              if (!isObject3.check(oldNode))
                return false;
              if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
                return true;
              }
              if (Printable.check(newNode)) {
                if (!Printable.check(oldNode)) {
                  return false;
                }
                var newParentNode = newPath.getParentNode();
                var oldParentNode = oldPath.getParentNode();
                if (oldParentNode !== null && oldParentNode.type === "FunctionTypeAnnotation" && newParentNode !== null && newParentNode.type === "FunctionTypeAnnotation") {
                  var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;
                  var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
                  if (!oldNeedsParens && newNeedParens) {
                    return false;
                  }
                }
                if (newNode.type === oldNode.type) {
                  var childReprints = [];
                  if (findChildReprints(newPath, oldPath, childReprints)) {
                    reprints.push.apply(reprints, childReprints);
                  } else if (oldNode.loc) {
                    reprints.push({oldPath: oldPath.copy(), newPath: newPath.copy()});
                  } else {
                    return false;
                  }
                  return true;
                }
                if (Expression2.check(newNode) && Expression2.check(oldNode) && oldNode.loc) {
                  reprints.push({oldPath: oldPath.copy(), newPath: newPath.copy()});
                  return true;
                }
                return false;
              }
              return findChildReprints(newPath, oldPath, reprints);
            }
            function findChildReprints(newPath, oldPath, reprints) {
              var newNode = newPath.getValue();
              var oldNode = oldPath.getValue();
              isObject3.assert(newNode);
              isObject3.assert(oldNode);
              if (newNode.original === null) {
                return false;
              }
              if (newPath.needsParens() && !oldPath.hasParens()) {
                return false;
              }
              var keys = util$2.getUnionOfKeys(oldNode, newNode);
              if (oldNode.type === "File" || newNode.type === "File") {
                delete keys.tokens;
              }
              delete keys.loc;
              var originalReprintCount = reprints.length;
              for (var k in keys) {
                if (k.charAt(0) === "_") {
                  continue;
                }
                newPath.stack.push(k, types2.getFieldValue(newNode, k));
                oldPath.stack.push(k, types2.getFieldValue(oldNode, k));
                var canReprint = findAnyReprints(newPath, oldPath, reprints);
                newPath.stack.length -= 2;
                oldPath.stack.length -= 2;
                if (!canReprint) {
                  return false;
                }
              }
              if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {
                return false;
              }
              return true;
            }
          });
          var printer = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.Printer = void 0;
            var assert_12 = tslib_1.__importDefault(require$$0$1);
            var types2 = tslib_1.__importStar(main$1);
            var namedTypes2 = types2.namedTypes;
            var isString2 = types2.builtInTypes.string;
            var isObject3 = types2.builtInTypes.object;
            var fast_path_1 = tslib_1.__importDefault(fastPath);
            var util2 = tslib_1.__importStar(util$2);
            var PrintResult = function PrintResult2(code, sourceMap2) {
              assert_12.default.ok(this instanceof PrintResult2);
              isString2.assert(code);
              this.code = code;
              if (sourceMap2) {
                isObject3.assert(sourceMap2);
                this.map = sourceMap2;
              }
            };
            var PRp = PrintResult.prototype;
            var warnedAboutToString = false;
            PRp.toString = function() {
              if (!warnedAboutToString) {
                console.warn("Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged.");
                warnedAboutToString = true;
              }
              return this.code;
            };
            var emptyPrintResult = new PrintResult("");
            var Printer = function Printer2(config) {
              assert_12.default.ok(this instanceof Printer2);
              var explicitTabWidth = config && config.tabWidth;
              config = options.normalize(config);
              config.sourceFileName = null;
              function makePrintFunctionWith(options2, overrides) {
                options2 = Object.assign({}, options2, overrides);
                return function(path2) {
                  return print(path2, options2);
                };
              }
              function print(path2, options2) {
                assert_12.default.ok(path2 instanceof fast_path_1.default);
                options2 = options2 || {};
                if (options2.includeComments) {
                  return comments.printComments(path2, makePrintFunctionWith(options2, {includeComments: false}));
                }
                var oldTabWidth = config.tabWidth;
                if (!explicitTabWidth) {
                  var loc = path2.getNode().loc;
                  if (loc && loc.lines && loc.lines.guessTabWidth) {
                    config.tabWidth = loc.lines.guessTabWidth();
                  }
                }
                var reprinter = patcher.getReprinter(path2);
                var lines2 = reprinter ? reprinter(print) : genericPrint(path2, config, options2, makePrintFunctionWith(options2, {includeComments: true, avoidRootParens: false}));
                config.tabWidth = oldTabWidth;
                return lines2;
              }
              this.print = function(ast) {
                if (!ast) {
                  return emptyPrintResult;
                }
                var lines2 = print(fast_path_1.default.from(ast), {includeComments: true, avoidRootParens: false});
                return new PrintResult(lines2.toString(config), util2.composeSourceMaps(config.inputSourceMap, lines2.getSourceMap(config.sourceMapName, config.sourceRoot)));
              };
              this.printGenerically = function(ast) {
                if (!ast) {
                  return emptyPrintResult;
                }
                function printGenerically(path3) {
                  return comments.printComments(path3, function(path4) {
                    return genericPrint(path4, config, {includeComments: true, avoidRootParens: false}, printGenerically);
                  });
                }
                var path2 = fast_path_1.default.from(ast);
                var oldReuseWhitespace = config.reuseWhitespace;
                config.reuseWhitespace = false;
                var pr = new PrintResult(printGenerically(path2).toString(config));
                config.reuseWhitespace = oldReuseWhitespace;
                return pr;
              };
            };
            exports4.Printer = Printer;
            function genericPrint(path2, config, options2, printPath) {
              assert_12.default.ok(path2 instanceof fast_path_1.default);
              var node2 = path2.getValue();
              var parts = [];
              var linesWithoutParens = genericPrintNoParens(path2, config, printPath);
              if (!node2 || linesWithoutParens.isEmpty()) {
                return linesWithoutParens;
              }
              var shouldAddParens = node2.extra ? node2.extra.parenthesized : false;
              var decoratorsLines = printDecorators(path2, printPath);
              if (decoratorsLines.isEmpty()) {
                if (!options2.avoidRootParens) {
                  shouldAddParens = shouldAddParens || path2.needsParens();
                }
              } else {
                parts.push(decoratorsLines);
              }
              if (shouldAddParens) {
                parts.unshift("(");
              }
              parts.push(linesWithoutParens);
              if (shouldAddParens) {
                parts.push(")");
              }
              return lines.concat(parts);
            }
            function genericPrintNoParens(path2, options2, print) {
              var n2 = path2.getValue();
              if (!n2) {
                return lines.fromString("");
              }
              if (typeof n2 === "string") {
                return lines.fromString(n2, options2);
              }
              namedTypes2.Printable.assert(n2);
              var parts = [];
              switch (n2.type) {
                case "File":
                  return path2.call(print, "program");
                case "Program":
                  if (n2.directives) {
                    path2.each(function(childPath) {
                      parts.push(print(childPath), ";\n");
                    }, "directives");
                  }
                  if (n2.interpreter) {
                    parts.push(path2.call(print, "interpreter"));
                  }
                  parts.push(path2.call(function(bodyPath) {
                    return printStatementSequence(bodyPath, options2, print);
                  }, "body"));
                  return lines.concat(parts);
                case "Noop":
                case "EmptyStatement":
                  return lines.fromString("");
                case "ExpressionStatement":
                  return lines.concat([path2.call(print, "expression"), ";"]);
                case "ParenthesizedExpression":
                  return lines.concat(["(", path2.call(print, "expression"), ")"]);
                case "BinaryExpression":
                case "LogicalExpression":
                case "AssignmentExpression":
                  return lines.fromString(" ").join([path2.call(print, "left"), n2.operator, path2.call(print, "right")]);
                case "AssignmentPattern":
                  return lines.concat([path2.call(print, "left"), " = ", path2.call(print, "right")]);
                case "MemberExpression":
                case "OptionalMemberExpression": {
                  parts.push(path2.call(print, "object"));
                  var property = path2.call(print, "property");
                  var optional = types2.getFieldValue(n2, "optional");
                  if (n2.computed) {
                    parts.push(optional ? "?.[" : "[", property, "]");
                  } else {
                    parts.push(optional ? "?." : ".", property);
                  }
                  return lines.concat(parts);
                }
                case "ChainExpression":
                  return path2.call(print, "expression");
                case "MetaProperty":
                  return lines.concat([path2.call(print, "meta"), ".", path2.call(print, "property")]);
                case "BindExpression":
                  if (n2.object) {
                    parts.push(path2.call(print, "object"));
                  }
                  parts.push("::", path2.call(print, "callee"));
                  return lines.concat(parts);
                case "Path":
                  return lines.fromString(".").join(n2.body);
                case "Identifier":
                  return lines.concat([lines.fromString(n2.name, options2), n2.optional ? "?" : "", path2.call(print, "typeAnnotation")]);
                case "SpreadElement":
                case "SpreadElementPattern":
                case "RestProperty":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "ObjectTypeSpreadProperty":
                case "RestElement":
                  return lines.concat(["...", path2.call(print, "argument"), path2.call(print, "typeAnnotation")]);
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "TSDeclareFunction":
                  if (n2.declare) {
                    parts.push("declare ");
                  }
                  if (n2.async) {
                    parts.push("async ");
                  }
                  parts.push("function");
                  if (n2.generator)
                    parts.push("*");
                  if (n2.id) {
                    parts.push(" ", path2.call(print, "id"), path2.call(print, "typeParameters"));
                  } else {
                    if (n2.typeParameters) {
                      parts.push(path2.call(print, "typeParameters"));
                    }
                  }
                  parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType"));
                  if (n2.body) {
                    parts.push(" ", path2.call(print, "body"));
                  }
                  return lines.concat(parts);
                case "ArrowFunctionExpression":
                  if (n2.async) {
                    parts.push("async ");
                  }
                  if (n2.typeParameters) {
                    parts.push(path2.call(print, "typeParameters"));
                  }
                  if (!options2.arrowParensAlways && n2.params.length === 1 && !n2.rest && n2.params[0].type === "Identifier" && !n2.params[0].typeAnnotation && !n2.returnType) {
                    parts.push(path2.call(print, "params", 0));
                  } else {
                    parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType"));
                  }
                  parts.push(" => ", path2.call(print, "body"));
                  return lines.concat(parts);
                case "MethodDefinition":
                  return printMethod(path2, options2, print);
                case "YieldExpression":
                  parts.push("yield");
                  if (n2.delegate)
                    parts.push("*");
                  if (n2.argument)
                    parts.push(" ", path2.call(print, "argument"));
                  return lines.concat(parts);
                case "AwaitExpression":
                  parts.push("await");
                  if (n2.all)
                    parts.push("*");
                  if (n2.argument)
                    parts.push(" ", path2.call(print, "argument"));
                  return lines.concat(parts);
                case "ModuleDeclaration":
                  parts.push("module", path2.call(print, "id"));
                  if (n2.source) {
                    assert_12.default.ok(!n2.body);
                    parts.push("from", path2.call(print, "source"));
                  } else {
                    parts.push(path2.call(print, "body"));
                  }
                  return lines.fromString(" ").join(parts);
                case "ImportSpecifier":
                  if (n2.importKind && n2.importKind !== "value") {
                    parts.push(n2.importKind + " ");
                  }
                  if (n2.imported) {
                    parts.push(path2.call(print, "imported"));
                    if (n2.local && n2.local.name !== n2.imported.name) {
                      parts.push(" as ", path2.call(print, "local"));
                    }
                  } else if (n2.id) {
                    parts.push(path2.call(print, "id"));
                    if (n2.name) {
                      parts.push(" as ", path2.call(print, "name"));
                    }
                  }
                  return lines.concat(parts);
                case "ExportSpecifier":
                  if (n2.local) {
                    parts.push(path2.call(print, "local"));
                    if (n2.exported && n2.exported.name !== n2.local.name) {
                      parts.push(" as ", path2.call(print, "exported"));
                    }
                  } else if (n2.id) {
                    parts.push(path2.call(print, "id"));
                    if (n2.name) {
                      parts.push(" as ", path2.call(print, "name"));
                    }
                  }
                  return lines.concat(parts);
                case "ExportBatchSpecifier":
                  return lines.fromString("*");
                case "ImportNamespaceSpecifier":
                  parts.push("* as ");
                  if (n2.local) {
                    parts.push(path2.call(print, "local"));
                  } else if (n2.id) {
                    parts.push(path2.call(print, "id"));
                  }
                  return lines.concat(parts);
                case "ImportDefaultSpecifier":
                  if (n2.local) {
                    return path2.call(print, "local");
                  }
                  return path2.call(print, "id");
                case "TSExportAssignment":
                  return lines.concat(["export = ", path2.call(print, "expression")]);
                case "ExportDeclaration":
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                  return printExportDeclaration(path2, options2, print);
                case "ExportAllDeclaration":
                  parts.push("export *");
                  if (n2.exported) {
                    parts.push(" as ", path2.call(print, "exported"));
                  }
                  parts.push(" from ", path2.call(print, "source"), ";");
                  return lines.concat(parts);
                case "TSNamespaceExportDeclaration":
                  parts.push("export as namespace ", path2.call(print, "id"));
                  return maybeAddSemicolon(lines.concat(parts));
                case "ExportNamespaceSpecifier":
                  return lines.concat(["* as ", path2.call(print, "exported")]);
                case "ExportDefaultSpecifier":
                  return path2.call(print, "exported");
                case "Import":
                  return lines.fromString("import", options2);
                case "ImportExpression":
                  return lines.concat(["import(", path2.call(print, "source"), ")"]);
                case "ImportDeclaration": {
                  parts.push("import ");
                  if (n2.importKind && n2.importKind !== "value") {
                    parts.push(n2.importKind + " ");
                  }
                  if (n2.specifiers && n2.specifiers.length > 0) {
                    var unbracedSpecifiers_1 = [];
                    var bracedSpecifiers_1 = [];
                    path2.each(function(specifierPath) {
                      var spec = specifierPath.getValue();
                      if (spec.type === "ImportSpecifier") {
                        bracedSpecifiers_1.push(print(specifierPath));
                      } else if (spec.type === "ImportDefaultSpecifier" || spec.type === "ImportNamespaceSpecifier") {
                        unbracedSpecifiers_1.push(print(specifierPath));
                      }
                    }, "specifiers");
                    unbracedSpecifiers_1.forEach(function(lines2, i) {
                      if (i > 0) {
                        parts.push(", ");
                      }
                      parts.push(lines2);
                    });
                    if (bracedSpecifiers_1.length > 0) {
                      var lines$1 = lines.fromString(", ").join(bracedSpecifiers_1);
                      if (lines$1.getLineLength(1) > options2.wrapColumn) {
                        lines$1 = lines.concat([lines.fromString(",\n").join(bracedSpecifiers_1).indent(options2.tabWidth), ","]);
                      }
                      if (unbracedSpecifiers_1.length > 0) {
                        parts.push(", ");
                      }
                      if (lines$1.length > 1) {
                        parts.push("{\n", lines$1, "\n}");
                      } else if (options2.objectCurlySpacing) {
                        parts.push("{ ", lines$1, " }");
                      } else {
                        parts.push("{", lines$1, "}");
                      }
                    }
                    parts.push(" from ");
                  }
                  parts.push(path2.call(print, "source"), ";");
                  return lines.concat(parts);
                }
                case "BlockStatement": {
                  var naked_1 = path2.call(function(bodyPath) {
                    return printStatementSequence(bodyPath, options2, print);
                  }, "body");
                  if (naked_1.isEmpty()) {
                    if (!n2.directives || n2.directives.length === 0) {
                      return lines.fromString("{}");
                    }
                  }
                  parts.push("{\n");
                  if (n2.directives) {
                    path2.each(function(childPath) {
                      parts.push(maybeAddSemicolon(print(childPath).indent(options2.tabWidth)), n2.directives.length > 1 || !naked_1.isEmpty() ? "\n" : "");
                    }, "directives");
                  }
                  parts.push(naked_1.indent(options2.tabWidth));
                  parts.push("\n}");
                  return lines.concat(parts);
                }
                case "ReturnStatement": {
                  parts.push("return");
                  if (n2.argument) {
                    var argLines = path2.call(print, "argument");
                    if (argLines.startsWithComment() || argLines.length > 1 && namedTypes2.JSXElement && namedTypes2.JSXElement.check(n2.argument)) {
                      parts.push(" (\n", argLines.indent(options2.tabWidth), "\n)");
                    } else {
                      parts.push(" ", argLines);
                    }
                  }
                  parts.push(";");
                  return lines.concat(parts);
                }
                case "CallExpression":
                case "OptionalCallExpression":
                  parts.push(path2.call(print, "callee"));
                  if (n2.typeParameters) {
                    parts.push(path2.call(print, "typeParameters"));
                  }
                  if (n2.typeArguments) {
                    parts.push(path2.call(print, "typeArguments"));
                  }
                  if (types2.getFieldValue(n2, "optional")) {
                    parts.push("?.");
                  }
                  parts.push(printArgumentsList(path2, options2, print));
                  return lines.concat(parts);
                case "ObjectExpression":
                case "ObjectPattern":
                case "ObjectTypeAnnotation": {
                  var isTypeAnnotation_1 = n2.type === "ObjectTypeAnnotation";
                  var separator_1 = options2.flowObjectCommas ? "," : isTypeAnnotation_1 ? ";" : ",";
                  var fields = [];
                  var allowBreak_1 = false;
                  if (isTypeAnnotation_1) {
                    fields.push("indexers", "callProperties");
                    if (n2.internalSlots != null) {
                      fields.push("internalSlots");
                    }
                  }
                  fields.push("properties");
                  var len_1 = 0;
                  fields.forEach(function(field) {
                    len_1 += n2[field].length;
                  });
                  var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0;
                  var leftBrace = n2.exact ? "{|" : "{";
                  var rightBrace = n2.exact ? "|}" : "}";
                  parts.push(oneLine_1 ? leftBrace : leftBrace + "\n");
                  var leftBraceIndex = parts.length - 1;
                  var i_1 = 0;
                  fields.forEach(function(field) {
                    path2.each(function(childPath) {
                      var lines2 = print(childPath);
                      if (!oneLine_1) {
                        lines2 = lines2.indent(options2.tabWidth);
                      }
                      var multiLine = !isTypeAnnotation_1 && lines2.length > 1;
                      if (multiLine && allowBreak_1) {
                        parts.push("\n");
                      }
                      parts.push(lines2);
                      if (i_1 < len_1 - 1) {
                        parts.push(separator_1 + (multiLine ? "\n\n" : "\n"));
                        allowBreak_1 = !multiLine;
                      } else if (len_1 !== 1 && isTypeAnnotation_1) {
                        parts.push(separator_1);
                      } else if (!oneLine_1 && util2.isTrailingCommaEnabled(options2, "objects") && childPath.getValue().type !== "RestElement") {
                        parts.push(separator_1);
                      }
                      i_1++;
                    }, field);
                  });
                  if (n2.inexact) {
                    var line = lines.fromString("...", options2);
                    if (oneLine_1) {
                      if (len_1 > 0) {
                        parts.push(separator_1, " ");
                      }
                      parts.push(line);
                    } else {
                      parts.push("\n", line.indent(options2.tabWidth));
                    }
                  }
                  parts.push(oneLine_1 ? rightBrace : "\n" + rightBrace);
                  if (i_1 !== 0 && oneLine_1 && options2.objectCurlySpacing) {
                    parts[leftBraceIndex] = leftBrace + " ";
                    parts[parts.length - 1] = " " + rightBrace;
                  }
                  if (n2.typeAnnotation) {
                    parts.push(path2.call(print, "typeAnnotation"));
                  }
                  return lines.concat(parts);
                }
                case "PropertyPattern":
                  return lines.concat([path2.call(print, "key"), ": ", path2.call(print, "pattern")]);
                case "ObjectProperty":
                case "Property": {
                  if (n2.method || n2.kind === "get" || n2.kind === "set") {
                    return printMethod(path2, options2, print);
                  }
                  if (n2.shorthand && n2.value.type === "AssignmentPattern") {
                    return path2.call(print, "value");
                  }
                  var key = path2.call(print, "key");
                  if (n2.computed) {
                    parts.push("[", key, "]");
                  } else {
                    parts.push(key);
                  }
                  if (!n2.shorthand || n2.key.name !== n2.value.name) {
                    parts.push(": ", path2.call(print, "value"));
                  }
                  return lines.concat(parts);
                }
                case "ClassMethod":
                case "ObjectMethod":
                case "ClassPrivateMethod":
                case "TSDeclareMethod":
                  return printMethod(path2, options2, print);
                case "PrivateName":
                  return lines.concat(["#", path2.call(print, "id")]);
                case "Decorator":
                  return lines.concat(["@", path2.call(print, "expression")]);
                case "ArrayExpression":
                case "ArrayPattern": {
                  var elems = n2.elements;
                  var len_2 = elems.length;
                  var printed_1 = path2.map(print, "elements");
                  var joined = lines.fromString(", ").join(printed_1);
                  var oneLine_2 = joined.getLineLength(1) <= options2.wrapColumn;
                  if (oneLine_2) {
                    if (options2.arrayBracketSpacing) {
                      parts.push("[ ");
                    } else {
                      parts.push("[");
                    }
                  } else {
                    parts.push("[\n");
                  }
                  path2.each(function(elemPath) {
                    var i = elemPath.getName();
                    var elem = elemPath.getValue();
                    if (!elem) {
                      parts.push(",");
                    } else {
                      var lines2 = printed_1[i];
                      if (oneLine_2) {
                        if (i > 0)
                          parts.push(" ");
                      } else {
                        lines2 = lines2.indent(options2.tabWidth);
                      }
                      parts.push(lines2);
                      if (i < len_2 - 1 || !oneLine_2 && util2.isTrailingCommaEnabled(options2, "arrays"))
                        parts.push(",");
                      if (!oneLine_2)
                        parts.push("\n");
                    }
                  }, "elements");
                  if (oneLine_2 && options2.arrayBracketSpacing) {
                    parts.push(" ]");
                  } else {
                    parts.push("]");
                  }
                  if (n2.typeAnnotation) {
                    parts.push(path2.call(print, "typeAnnotation"));
                  }
                  return lines.concat(parts);
                }
                case "SequenceExpression":
                  return lines.fromString(", ").join(path2.map(print, "expressions"));
                case "ThisExpression":
                  return lines.fromString("this");
                case "Super":
                  return lines.fromString("super");
                case "NullLiteral":
                  return lines.fromString("null");
                case "RegExpLiteral":
                  return lines.fromString(n2.extra.raw);
                case "BigIntLiteral":
                  return lines.fromString(n2.value + "n");
                case "NumericLiteral":
                  if (n2.extra && typeof n2.extra.raw === "string" && Number(n2.extra.raw) === n2.value) {
                    return lines.fromString(n2.extra.raw, options2);
                  }
                  return lines.fromString(n2.value, options2);
                case "BooleanLiteral":
                case "StringLiteral":
                case "Literal":
                  if (typeof n2.value === "number" && typeof n2.raw === "string" && Number(n2.raw) === n2.value) {
                    return lines.fromString(n2.raw, options2);
                  }
                  if (typeof n2.value !== "string") {
                    return lines.fromString(n2.value, options2);
                  }
                  return lines.fromString(nodeStr(n2.value, options2), options2);
                case "Directive":
                  return path2.call(print, "value");
                case "DirectiveLiteral":
                  return lines.fromString(nodeStr(n2.value, options2));
                case "InterpreterDirective":
                  return lines.fromString("#!" + n2.value + "\n", options2);
                case "ModuleSpecifier":
                  if (n2.local) {
                    throw new Error("The ESTree ModuleSpecifier type should be abstract");
                  }
                  return lines.fromString(nodeStr(n2.value, options2), options2);
                case "UnaryExpression":
                  parts.push(n2.operator);
                  if (/[a-z]$/.test(n2.operator))
                    parts.push(" ");
                  parts.push(path2.call(print, "argument"));
                  return lines.concat(parts);
                case "UpdateExpression":
                  parts.push(path2.call(print, "argument"), n2.operator);
                  if (n2.prefix)
                    parts.reverse();
                  return lines.concat(parts);
                case "ConditionalExpression":
                  return lines.concat([path2.call(print, "test"), " ? ", path2.call(print, "consequent"), " : ", path2.call(print, "alternate")]);
                case "NewExpression": {
                  parts.push("new ", path2.call(print, "callee"));
                  if (n2.typeParameters) {
                    parts.push(path2.call(print, "typeParameters"));
                  }
                  if (n2.typeArguments) {
                    parts.push(path2.call(print, "typeArguments"));
                  }
                  var args = n2.arguments;
                  if (args) {
                    parts.push(printArgumentsList(path2, options2, print));
                  }
                  return lines.concat(parts);
                }
                case "VariableDeclaration": {
                  if (n2.declare) {
                    parts.push("declare ");
                  }
                  parts.push(n2.kind, " ");
                  var maxLen_1 = 0;
                  var printed = path2.map(function(childPath) {
                    var lines2 = print(childPath);
                    maxLen_1 = Math.max(lines2.length, maxLen_1);
                    return lines2;
                  }, "declarations");
                  if (maxLen_1 === 1) {
                    parts.push(lines.fromString(", ").join(printed));
                  } else if (printed.length > 1) {
                    parts.push(lines.fromString(",\n").join(printed).indentTail(n2.kind.length + 1));
                  } else {
                    parts.push(printed[0]);
                  }
                  var parentNode = path2.getParentNode();
                  if (!namedTypes2.ForStatement.check(parentNode) && !namedTypes2.ForInStatement.check(parentNode) && !(namedTypes2.ForOfStatement && namedTypes2.ForOfStatement.check(parentNode)) && !(namedTypes2.ForAwaitStatement && namedTypes2.ForAwaitStatement.check(parentNode))) {
                    parts.push(";");
                  }
                  return lines.concat(parts);
                }
                case "VariableDeclarator":
                  return n2.init ? lines.fromString(" = ").join([path2.call(print, "id"), path2.call(print, "init")]) : path2.call(print, "id");
                case "WithStatement":
                  return lines.concat(["with (", path2.call(print, "object"), ") ", path2.call(print, "body")]);
                case "IfStatement": {
                  var con = adjustClause(path2.call(print, "consequent"), options2);
                  parts.push("if (", path2.call(print, "test"), ")", con);
                  if (n2.alternate)
                    parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path2.call(print, "alternate"), options2));
                  return lines.concat(parts);
                }
                case "ForStatement": {
                  var init2 = path2.call(print, "init");
                  var sep = init2.length > 1 ? ";\n" : "; ";
                  var forParen = "for (";
                  var indented = lines.fromString(sep).join([init2, path2.call(print, "test"), path2.call(print, "update")]).indentTail(forParen.length);
                  var head = lines.concat([forParen, indented, ")"]);
                  var clause = adjustClause(path2.call(print, "body"), options2);
                  parts.push(head);
                  if (head.length > 1) {
                    parts.push("\n");
                    clause = clause.trimLeft();
                  }
                  parts.push(clause);
                  return lines.concat(parts);
                }
                case "WhileStatement":
                  return lines.concat(["while (", path2.call(print, "test"), ")", adjustClause(path2.call(print, "body"), options2)]);
                case "ForInStatement":
                  return lines.concat([n2.each ? "for each (" : "for (", path2.call(print, "left"), " in ", path2.call(print, "right"), ")", adjustClause(path2.call(print, "body"), options2)]);
                case "ForOfStatement":
                case "ForAwaitStatement":
                  parts.push("for ");
                  if (n2.await || n2.type === "ForAwaitStatement") {
                    parts.push("await ");
                  }
                  parts.push("(", path2.call(print, "left"), " of ", path2.call(print, "right"), ")", adjustClause(path2.call(print, "body"), options2));
                  return lines.concat(parts);
                case "DoWhileStatement": {
                  var doBody = lines.concat(["do", adjustClause(path2.call(print, "body"), options2)]);
                  parts.push(doBody);
                  if (endsWithBrace(doBody))
                    parts.push(" while");
                  else
                    parts.push("\nwhile");
                  parts.push(" (", path2.call(print, "test"), ");");
                  return lines.concat(parts);
                }
                case "DoExpression": {
                  var statements = path2.call(function(bodyPath) {
                    return printStatementSequence(bodyPath, options2, print);
                  }, "body");
                  return lines.concat(["do {\n", statements.indent(options2.tabWidth), "\n}"]);
                }
                case "BreakStatement":
                  parts.push("break");
                  if (n2.label)
                    parts.push(" ", path2.call(print, "label"));
                  parts.push(";");
                  return lines.concat(parts);
                case "ContinueStatement":
                  parts.push("continue");
                  if (n2.label)
                    parts.push(" ", path2.call(print, "label"));
                  parts.push(";");
                  return lines.concat(parts);
                case "LabeledStatement":
                  return lines.concat([path2.call(print, "label"), ":\n", path2.call(print, "body")]);
                case "TryStatement":
                  parts.push("try ", path2.call(print, "block"));
                  if (n2.handler) {
                    parts.push(" ", path2.call(print, "handler"));
                  } else if (n2.handlers) {
                    path2.each(function(handlerPath) {
                      parts.push(" ", print(handlerPath));
                    }, "handlers");
                  }
                  if (n2.finalizer) {
                    parts.push(" finally ", path2.call(print, "finalizer"));
                  }
                  return lines.concat(parts);
                case "CatchClause":
                  parts.push("catch ");
                  if (n2.param) {
                    parts.push("(", path2.call(print, "param"));
                  }
                  if (n2.guard) {
                    parts.push(" if ", path2.call(print, "guard"));
                  }
                  if (n2.param) {
                    parts.push(") ");
                  }
                  parts.push(path2.call(print, "body"));
                  return lines.concat(parts);
                case "ThrowStatement":
                  return lines.concat(["throw ", path2.call(print, "argument"), ";"]);
                case "SwitchStatement":
                  return lines.concat(["switch (", path2.call(print, "discriminant"), ") {\n", lines.fromString("\n").join(path2.map(print, "cases")), "\n}"]);
                case "SwitchCase":
                  if (n2.test)
                    parts.push("case ", path2.call(print, "test"), ":");
                  else
                    parts.push("default:");
                  if (n2.consequent.length > 0) {
                    parts.push("\n", path2.call(function(consequentPath) {
                      return printStatementSequence(consequentPath, options2, print);
                    }, "consequent").indent(options2.tabWidth));
                  }
                  return lines.concat(parts);
                case "DebuggerStatement":
                  return lines.fromString("debugger;");
                case "JSXAttribute":
                  parts.push(path2.call(print, "name"));
                  if (n2.value)
                    parts.push("=", path2.call(print, "value"));
                  return lines.concat(parts);
                case "JSXIdentifier":
                  return lines.fromString(n2.name, options2);
                case "JSXNamespacedName":
                  return lines.fromString(":").join([path2.call(print, "namespace"), path2.call(print, "name")]);
                case "JSXMemberExpression":
                  return lines.fromString(".").join([path2.call(print, "object"), path2.call(print, "property")]);
                case "JSXSpreadAttribute":
                  return lines.concat(["{...", path2.call(print, "argument"), "}"]);
                case "JSXSpreadChild":
                  return lines.concat(["{...", path2.call(print, "expression"), "}"]);
                case "JSXExpressionContainer":
                  return lines.concat(["{", path2.call(print, "expression"), "}"]);
                case "JSXElement":
                case "JSXFragment": {
                  var openingPropName = "opening" + (n2.type === "JSXElement" ? "Element" : "Fragment");
                  var closingPropName = "closing" + (n2.type === "JSXElement" ? "Element" : "Fragment");
                  var openingLines = path2.call(print, openingPropName);
                  if (n2[openingPropName].selfClosing) {
                    assert_12.default.ok(!n2[closingPropName], "unexpected " + closingPropName + " element in self-closing " + n2.type);
                    return openingLines;
                  }
                  var childLines = lines.concat(path2.map(function(childPath) {
                    var child = childPath.getValue();
                    if (namedTypes2.Literal.check(child) && typeof child.value === "string") {
                      if (/\S/.test(child.value)) {
                        return child.value.replace(/^\s+|\s+$/g, "");
                      } else if (/\n/.test(child.value)) {
                        return "\n";
                      }
                    }
                    return print(childPath);
                  }, "children")).indentTail(options2.tabWidth);
                  var closingLines = path2.call(print, closingPropName);
                  return lines.concat([openingLines, childLines, closingLines]);
                }
                case "JSXOpeningElement": {
                  parts.push("<", path2.call(print, "name"));
                  var attrParts_1 = [];
                  path2.each(function(attrPath) {
                    attrParts_1.push(" ", print(attrPath));
                  }, "attributes");
                  var attrLines = lines.concat(attrParts_1);
                  var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options2.wrapColumn;
                  if (needLineWrap) {
                    attrParts_1.forEach(function(part2, i) {
                      if (part2 === " ") {
                        assert_12.default.strictEqual(i % 2, 0);
                        attrParts_1[i] = "\n";
                      }
                    });
                    attrLines = lines.concat(attrParts_1).indentTail(options2.tabWidth);
                  }
                  parts.push(attrLines, n2.selfClosing ? " />" : ">");
                  return lines.concat(parts);
                }
                case "JSXClosingElement":
                  return lines.concat(["</", path2.call(print, "name"), ">"]);
                case "JSXOpeningFragment":
                  return lines.fromString("<>");
                case "JSXClosingFragment":
                  return lines.fromString("</>");
                case "JSXText":
                  return lines.fromString(n2.value, options2);
                case "JSXEmptyExpression":
                  return lines.fromString("");
                case "TypeAnnotatedIdentifier":
                  return lines.concat([path2.call(print, "annotation"), " ", path2.call(print, "identifier")]);
                case "ClassBody":
                  if (n2.body.length === 0) {
                    return lines.fromString("{}");
                  }
                  return lines.concat(["{\n", path2.call(function(bodyPath) {
                    return printStatementSequence(bodyPath, options2, print);
                  }, "body").indent(options2.tabWidth), "\n}"]);
                case "ClassPropertyDefinition":
                  parts.push("static ", path2.call(print, "definition"));
                  if (!namedTypes2.MethodDefinition.check(n2.definition))
                    parts.push(";");
                  return lines.concat(parts);
                case "ClassProperty": {
                  if (n2.declare) {
                    parts.push("declare ");
                  }
                  var access = n2.accessibility || n2.access;
                  if (typeof access === "string") {
                    parts.push(access, " ");
                  }
                  if (n2.static) {
                    parts.push("static ");
                  }
                  if (n2.abstract) {
                    parts.push("abstract ");
                  }
                  if (n2.readonly) {
                    parts.push("readonly ");
                  }
                  var key = path2.call(print, "key");
                  if (n2.computed) {
                    key = lines.concat(["[", key, "]"]);
                  }
                  if (n2.variance) {
                    key = lines.concat([printVariance(path2, print), key]);
                  }
                  parts.push(key);
                  if (n2.optional) {
                    parts.push("?");
                  }
                  if (n2.typeAnnotation) {
                    parts.push(path2.call(print, "typeAnnotation"));
                  }
                  if (n2.value) {
                    parts.push(" = ", path2.call(print, "value"));
                  }
                  parts.push(";");
                  return lines.concat(parts);
                }
                case "ClassPrivateProperty":
                  if (n2.static) {
                    parts.push("static ");
                  }
                  parts.push(path2.call(print, "key"));
                  if (n2.typeAnnotation) {
                    parts.push(path2.call(print, "typeAnnotation"));
                  }
                  if (n2.value) {
                    parts.push(" = ", path2.call(print, "value"));
                  }
                  parts.push(";");
                  return lines.concat(parts);
                case "ClassDeclaration":
                case "ClassExpression":
                  if (n2.declare) {
                    parts.push("declare ");
                  }
                  if (n2.abstract) {
                    parts.push("abstract ");
                  }
                  parts.push("class");
                  if (n2.id) {
                    parts.push(" ", path2.call(print, "id"));
                  }
                  if (n2.typeParameters) {
                    parts.push(path2.call(print, "typeParameters"));
                  }
                  if (n2.superClass) {
                    parts.push(" extends ", path2.call(print, "superClass"), path2.call(print, "superTypeParameters"));
                  }
                  if (n2["implements"] && n2["implements"].length > 0) {
                    parts.push(" implements ", lines.fromString(", ").join(path2.map(print, "implements")));
                  }
                  parts.push(" ", path2.call(print, "body"));
                  return lines.concat(parts);
                case "TemplateElement":
                  return lines.fromString(n2.value.raw, options2).lockIndentTail();
                case "TemplateLiteral": {
                  var expressions_1 = path2.map(print, "expressions");
                  parts.push("`");
                  path2.each(function(childPath) {
                    var i = childPath.getName();
                    parts.push(print(childPath));
                    if (i < expressions_1.length) {
                      parts.push("${", expressions_1[i], "}");
                    }
                  }, "quasis");
                  parts.push("`");
                  return lines.concat(parts).lockIndentTail();
                }
                case "TaggedTemplateExpression":
                  return lines.concat([path2.call(print, "tag"), path2.call(print, "quasi")]);
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "Flow":
                case "FlowType":
                case "FlowPredicate":
                case "MemberTypeAnnotation":
                case "Type":
                case "TSHasOptionalTypeParameterInstantiation":
                case "TSHasOptionalTypeParameters":
                case "TSHasOptionalTypeAnnotation":
                case "ChainElement":
                  throw new Error("unprintable type: " + JSON.stringify(n2.type));
                case "CommentBlock":
                case "Block":
                  return lines.concat(["/*", lines.fromString(n2.value, options2), "*/"]);
                case "CommentLine":
                case "Line":
                  return lines.concat(["//", lines.fromString(n2.value, options2)]);
                case "TypeAnnotation":
                  if (n2.typeAnnotation) {
                    if (n2.typeAnnotation.type !== "FunctionTypeAnnotation") {
                      parts.push(": ");
                    }
                    parts.push(path2.call(print, "typeAnnotation"));
                    return lines.concat(parts);
                  }
                  return lines.fromString("");
                case "ExistentialTypeParam":
                case "ExistsTypeAnnotation":
                  return lines.fromString("*", options2);
                case "EmptyTypeAnnotation":
                  return lines.fromString("empty", options2);
                case "AnyTypeAnnotation":
                  return lines.fromString("any", options2);
                case "MixedTypeAnnotation":
                  return lines.fromString("mixed", options2);
                case "ArrayTypeAnnotation":
                  return lines.concat([path2.call(print, "elementType"), "[]"]);
                case "TupleTypeAnnotation": {
                  var printed_2 = path2.map(print, "types");
                  var joined = lines.fromString(", ").join(printed_2);
                  var oneLine_3 = joined.getLineLength(1) <= options2.wrapColumn;
                  if (oneLine_3) {
                    if (options2.arrayBracketSpacing) {
                      parts.push("[ ");
                    } else {
                      parts.push("[");
                    }
                  } else {
                    parts.push("[\n");
                  }
                  path2.each(function(elemPath) {
                    var i = elemPath.getName();
                    var elem = elemPath.getValue();
                    if (!elem) {
                      parts.push(",");
                    } else {
                      var lines2 = printed_2[i];
                      if (oneLine_3) {
                        if (i > 0)
                          parts.push(" ");
                      } else {
                        lines2 = lines2.indent(options2.tabWidth);
                      }
                      parts.push(lines2);
                      if (i < n2.types.length - 1 || !oneLine_3 && util2.isTrailingCommaEnabled(options2, "arrays"))
                        parts.push(",");
                      if (!oneLine_3)
                        parts.push("\n");
                    }
                  }, "types");
                  if (oneLine_3 && options2.arrayBracketSpacing) {
                    parts.push(" ]");
                  } else {
                    parts.push("]");
                  }
                  return lines.concat(parts);
                }
                case "BooleanTypeAnnotation":
                  return lines.fromString("boolean", options2);
                case "BooleanLiteralTypeAnnotation":
                  assert_12.default.strictEqual(typeof n2.value, "boolean");
                  return lines.fromString("" + n2.value, options2);
                case "InterfaceTypeAnnotation":
                  parts.push("interface");
                  if (n2.extends && n2.extends.length > 0) {
                    parts.push(" extends ", lines.fromString(", ").join(path2.map(print, "extends")));
                  }
                  parts.push(" ", path2.call(print, "body"));
                  return lines.concat(parts);
                case "DeclareClass":
                  return printFlowDeclaration(path2, ["class ", path2.call(print, "id"), " ", path2.call(print, "body")]);
                case "DeclareFunction":
                  return printFlowDeclaration(path2, ["function ", path2.call(print, "id"), ";"]);
                case "DeclareModule":
                  return printFlowDeclaration(path2, ["module ", path2.call(print, "id"), " ", path2.call(print, "body")]);
                case "DeclareModuleExports":
                  return printFlowDeclaration(path2, ["module.exports", path2.call(print, "typeAnnotation")]);
                case "DeclareVariable":
                  return printFlowDeclaration(path2, ["var ", path2.call(print, "id"), ";"]);
                case "DeclareExportDeclaration":
                case "DeclareExportAllDeclaration":
                  return lines.concat(["declare ", printExportDeclaration(path2, options2, print)]);
                case "EnumDeclaration":
                  return lines.concat(["enum ", path2.call(print, "id"), path2.call(print, "body")]);
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody": {
                  if (n2.type === "EnumSymbolBody" || n2.explicitType) {
                    parts.push(" of ", n2.type.slice(4, -4).toLowerCase());
                  }
                  parts.push(" {\n", lines.fromString("\n").join(path2.map(print, "members")).indent(options2.tabWidth), "\n}");
                  return lines.concat(parts);
                }
                case "EnumDefaultedMember":
                  return lines.concat([path2.call(print, "id"), ","]);
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                  return lines.concat([path2.call(print, "id"), " = ", path2.call(print, "init"), ","]);
                case "InferredPredicate":
                  return lines.fromString("%checks", options2);
                case "DeclaredPredicate":
                  return lines.concat(["%checks(", path2.call(print, "value"), ")"]);
                case "FunctionTypeAnnotation": {
                  var parent = path2.getParentNode(0);
                  var isArrowFunctionTypeAnnotation = !(namedTypes2.ObjectTypeCallProperty.check(parent) || namedTypes2.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes2.DeclareFunction.check(path2.getParentNode(2)));
                  var needsColon = isArrowFunctionTypeAnnotation && !namedTypes2.FunctionTypeParam.check(parent) && !namedTypes2.TypeAlias.check(parent);
                  if (needsColon) {
                    parts.push(": ");
                  }
                  var needsParens = n2.params.length !== 1 || n2.params[0].name;
                  parts.push(needsParens ? "(" : "", printFunctionParams(path2, options2, print), needsParens ? ")" : "");
                  if (n2.returnType) {
                    parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path2.call(print, "returnType"));
                  }
                  return lines.concat(parts);
                }
                case "FunctionTypeParam": {
                  var name2 = path2.call(print, "name");
                  parts.push(name2);
                  if (n2.optional) {
                    parts.push("?");
                  }
                  if (name2.infos[0].line) {
                    parts.push(": ");
                  }
                  parts.push(path2.call(print, "typeAnnotation"));
                  return lines.concat(parts);
                }
                case "GenericTypeAnnotation":
                  return lines.concat([path2.call(print, "id"), path2.call(print, "typeParameters")]);
                case "DeclareInterface":
                  parts.push("declare ");
                case "InterfaceDeclaration":
                case "TSInterfaceDeclaration":
                  if (n2.declare) {
                    parts.push("declare ");
                  }
                  parts.push("interface ", path2.call(print, "id"), path2.call(print, "typeParameters"), " ");
                  if (n2["extends"] && n2["extends"].length > 0) {
                    parts.push("extends ", lines.fromString(", ").join(path2.map(print, "extends")), " ");
                  }
                  if (n2.body) {
                    parts.push(path2.call(print, "body"));
                  }
                  return lines.concat(parts);
                case "ClassImplements":
                case "InterfaceExtends":
                  return lines.concat([path2.call(print, "id"), path2.call(print, "typeParameters")]);
                case "IntersectionTypeAnnotation":
                  return lines.fromString(" & ").join(path2.map(print, "types"));
                case "NullableTypeAnnotation":
                  return lines.concat(["?", path2.call(print, "typeAnnotation")]);
                case "NullLiteralTypeAnnotation":
                  return lines.fromString("null", options2);
                case "ThisTypeAnnotation":
                  return lines.fromString("this", options2);
                case "NumberTypeAnnotation":
                  return lines.fromString("number", options2);
                case "ObjectTypeCallProperty":
                  return path2.call(print, "value");
                case "ObjectTypeIndexer":
                  if (n2.static) {
                    parts.push("static ");
                  }
                  parts.push(printVariance(path2, print), "[");
                  if (n2.id) {
                    parts.push(path2.call(print, "id"), ": ");
                  }
                  parts.push(path2.call(print, "key"), "]: ", path2.call(print, "value"));
                  return lines.concat(parts);
                case "ObjectTypeProperty":
                  return lines.concat([printVariance(path2, print), path2.call(print, "key"), n2.optional ? "?" : "", ": ", path2.call(print, "value")]);
                case "ObjectTypeInternalSlot":
                  return lines.concat([n2.static ? "static " : "", "[[", path2.call(print, "id"), "]]", n2.optional ? "?" : "", n2.value.type !== "FunctionTypeAnnotation" ? ": " : "", path2.call(print, "value")]);
                case "QualifiedTypeIdentifier":
                  return lines.concat([path2.call(print, "qualification"), ".", path2.call(print, "id")]);
                case "StringLiteralTypeAnnotation":
                  return lines.fromString(nodeStr(n2.value, options2), options2);
                case "NumberLiteralTypeAnnotation":
                case "NumericLiteralTypeAnnotation":
                  assert_12.default.strictEqual(typeof n2.value, "number");
                  return lines.fromString(JSON.stringify(n2.value), options2);
                case "BigIntLiteralTypeAnnotation":
                  return lines.fromString(n2.raw, options2);
                case "StringTypeAnnotation":
                  return lines.fromString("string", options2);
                case "DeclareTypeAlias":
                  parts.push("declare ");
                case "TypeAlias":
                  return lines.concat(["type ", path2.call(print, "id"), path2.call(print, "typeParameters"), " = ", path2.call(print, "right"), ";"]);
                case "DeclareOpaqueType":
                  parts.push("declare ");
                case "OpaqueType":
                  parts.push("opaque type ", path2.call(print, "id"), path2.call(print, "typeParameters"));
                  if (n2["supertype"]) {
                    parts.push(": ", path2.call(print, "supertype"));
                  }
                  if (n2["impltype"]) {
                    parts.push(" = ", path2.call(print, "impltype"));
                  }
                  parts.push(";");
                  return lines.concat(parts);
                case "TypeCastExpression":
                  return lines.concat(["(", path2.call(print, "expression"), path2.call(print, "typeAnnotation"), ")"]);
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation":
                  return lines.concat(["<", lines.fromString(", ").join(path2.map(print, "params")), ">"]);
                case "Variance":
                  if (n2.kind === "plus") {
                    return lines.fromString("+");
                  }
                  if (n2.kind === "minus") {
                    return lines.fromString("-");
                  }
                  return lines.fromString("");
                case "TypeParameter":
                  if (n2.variance) {
                    parts.push(printVariance(path2, print));
                  }
                  parts.push(path2.call(print, "name"));
                  if (n2.bound) {
                    parts.push(path2.call(print, "bound"));
                  }
                  if (n2["default"]) {
                    parts.push("=", path2.call(print, "default"));
                  }
                  return lines.concat(parts);
                case "TypeofTypeAnnotation":
                  return lines.concat([lines.fromString("typeof ", options2), path2.call(print, "argument")]);
                case "UnionTypeAnnotation":
                  return lines.fromString(" | ").join(path2.map(print, "types"));
                case "VoidTypeAnnotation":
                  return lines.fromString("void", options2);
                case "NullTypeAnnotation":
                  return lines.fromString("null", options2);
                case "SymbolTypeAnnotation":
                  return lines.fromString("symbol", options2);
                case "BigIntTypeAnnotation":
                  return lines.fromString("bigint", options2);
                case "TSType":
                  throw new Error("unprintable type: " + JSON.stringify(n2.type));
                case "TSNumberKeyword":
                  return lines.fromString("number", options2);
                case "TSBigIntKeyword":
                  return lines.fromString("bigint", options2);
                case "TSObjectKeyword":
                  return lines.fromString("object", options2);
                case "TSBooleanKeyword":
                  return lines.fromString("boolean", options2);
                case "TSStringKeyword":
                  return lines.fromString("string", options2);
                case "TSSymbolKeyword":
                  return lines.fromString("symbol", options2);
                case "TSAnyKeyword":
                  return lines.fromString("any", options2);
                case "TSVoidKeyword":
                  return lines.fromString("void", options2);
                case "TSThisType":
                  return lines.fromString("this", options2);
                case "TSNullKeyword":
                  return lines.fromString("null", options2);
                case "TSUndefinedKeyword":
                  return lines.fromString("undefined", options2);
                case "TSUnknownKeyword":
                  return lines.fromString("unknown", options2);
                case "TSNeverKeyword":
                  return lines.fromString("never", options2);
                case "TSArrayType":
                  return lines.concat([path2.call(print, "elementType"), "[]"]);
                case "TSLiteralType":
                  return path2.call(print, "literal");
                case "TSUnionType":
                  return lines.fromString(" | ").join(path2.map(print, "types"));
                case "TSIntersectionType":
                  return lines.fromString(" & ").join(path2.map(print, "types"));
                case "TSConditionalType":
                  parts.push(path2.call(print, "checkType"), " extends ", path2.call(print, "extendsType"), " ? ", path2.call(print, "trueType"), " : ", path2.call(print, "falseType"));
                  return lines.concat(parts);
                case "TSInferType":
                  parts.push("infer ", path2.call(print, "typeParameter"));
                  return lines.concat(parts);
                case "TSParenthesizedType":
                  return lines.concat(["(", path2.call(print, "typeAnnotation"), ")"]);
                case "TSFunctionType":
                  return lines.concat([path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ") => ", path2.call(print, "typeAnnotation", "typeAnnotation")]);
                case "TSConstructorType":
                  return lines.concat(["new ", path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ") => ", path2.call(print, "typeAnnotation", "typeAnnotation")]);
                case "TSMappedType": {
                  parts.push(n2.readonly ? "readonly " : "", "[", path2.call(print, "typeParameter"), "]", n2.optional ? "?" : "");
                  if (n2.typeAnnotation) {
                    parts.push(": ", path2.call(print, "typeAnnotation"), ";");
                  }
                  return lines.concat(["{\n", lines.concat(parts).indent(options2.tabWidth), "\n}"]);
                }
                case "TSTupleType":
                  return lines.concat(["[", lines.fromString(", ").join(path2.map(print, "elementTypes")), "]"]);
                case "TSNamedTupleMember":
                  parts.push(path2.call(print, "label"));
                  if (n2.optional) {
                    parts.push("?");
                  }
                  parts.push(": ", path2.call(print, "elementType"));
                  return lines.concat(parts);
                case "TSRestType":
                  return lines.concat(["...", path2.call(print, "typeAnnotation")]);
                case "TSOptionalType":
                  return lines.concat([path2.call(print, "typeAnnotation"), "?"]);
                case "TSIndexedAccessType":
                  return lines.concat([path2.call(print, "objectType"), "[", path2.call(print, "indexType"), "]"]);
                case "TSTypeOperator":
                  return lines.concat([path2.call(print, "operator"), " ", path2.call(print, "typeAnnotation")]);
                case "TSTypeLiteral": {
                  var memberLines = lines.fromString(",\n").join(path2.map(print, "members"));
                  if (memberLines.isEmpty()) {
                    return lines.fromString("{}", options2);
                  }
                  parts.push("{\n", memberLines.indent(options2.tabWidth), "\n}");
                  return lines.concat(parts);
                }
                case "TSEnumMember":
                  parts.push(path2.call(print, "id"));
                  if (n2.initializer) {
                    parts.push(" = ", path2.call(print, "initializer"));
                  }
                  return lines.concat(parts);
                case "TSTypeQuery":
                  return lines.concat(["typeof ", path2.call(print, "exprName")]);
                case "TSParameterProperty":
                  if (n2.accessibility) {
                    parts.push(n2.accessibility, " ");
                  }
                  if (n2.export) {
                    parts.push("export ");
                  }
                  if (n2.static) {
                    parts.push("static ");
                  }
                  if (n2.readonly) {
                    parts.push("readonly ");
                  }
                  parts.push(path2.call(print, "parameter"));
                  return lines.concat(parts);
                case "TSTypeReference":
                  return lines.concat([path2.call(print, "typeName"), path2.call(print, "typeParameters")]);
                case "TSQualifiedName":
                  return lines.concat([path2.call(print, "left"), ".", path2.call(print, "right")]);
                case "TSAsExpression": {
                  var expression = path2.call(print, "expression");
                  parts.push(expression, lines.fromString(" as "), path2.call(print, "typeAnnotation"));
                  return lines.concat(parts);
                }
                case "TSNonNullExpression":
                  return lines.concat([path2.call(print, "expression"), "!"]);
                case "TSTypeAnnotation":
                  return lines.concat([": ", path2.call(print, "typeAnnotation")]);
                case "TSIndexSignature":
                  return lines.concat([n2.readonly ? "readonly " : "", "[", path2.map(print, "parameters"), "]", path2.call(print, "typeAnnotation")]);
                case "TSPropertySignature":
                  parts.push(printVariance(path2, print), n2.readonly ? "readonly " : "");
                  if (n2.computed) {
                    parts.push("[", path2.call(print, "key"), "]");
                  } else {
                    parts.push(path2.call(print, "key"));
                  }
                  parts.push(n2.optional ? "?" : "", path2.call(print, "typeAnnotation"));
                  return lines.concat(parts);
                case "TSMethodSignature":
                  if (n2.computed) {
                    parts.push("[", path2.call(print, "key"), "]");
                  } else {
                    parts.push(path2.call(print, "key"));
                  }
                  if (n2.optional) {
                    parts.push("?");
                  }
                  parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation"));
                  return lines.concat(parts);
                case "TSTypePredicate":
                  if (n2.asserts) {
                    parts.push("asserts ");
                  }
                  parts.push(path2.call(print, "parameterName"));
                  if (n2.typeAnnotation) {
                    parts.push(" is ", path2.call(print, "typeAnnotation", "typeAnnotation"));
                  }
                  return lines.concat(parts);
                case "TSCallSignatureDeclaration":
                  return lines.concat([path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation")]);
                case "TSConstructSignatureDeclaration":
                  if (n2.typeParameters) {
                    parts.push("new", path2.call(print, "typeParameters"));
                  } else {
                    parts.push("new ");
                  }
                  parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation"));
                  return lines.concat(parts);
                case "TSTypeAliasDeclaration":
                  return lines.concat([n2.declare ? "declare " : "", "type ", path2.call(print, "id"), path2.call(print, "typeParameters"), " = ", path2.call(print, "typeAnnotation"), ";"]);
                case "TSTypeParameter": {
                  parts.push(path2.call(print, "name"));
                  var parent = path2.getParentNode(0);
                  var isInMappedType = namedTypes2.TSMappedType.check(parent);
                  if (n2.constraint) {
                    parts.push(isInMappedType ? " in " : " extends ", path2.call(print, "constraint"));
                  }
                  if (n2["default"]) {
                    parts.push(" = ", path2.call(print, "default"));
                  }
                  return lines.concat(parts);
                }
                case "TSTypeAssertion": {
                  parts.push("<", path2.call(print, "typeAnnotation"), "> ", path2.call(print, "expression"));
                  return lines.concat(parts);
                }
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                  return lines.concat(["<", lines.fromString(", ").join(path2.map(print, "params")), ">"]);
                case "TSEnumDeclaration": {
                  parts.push(n2.declare ? "declare " : "", n2.const ? "const " : "", "enum ", path2.call(print, "id"));
                  var memberLines = lines.fromString(",\n").join(path2.map(print, "members"));
                  if (memberLines.isEmpty()) {
                    parts.push(" {}");
                  } else {
                    parts.push(" {\n", memberLines.indent(options2.tabWidth), "\n}");
                  }
                  return lines.concat(parts);
                }
                case "TSExpressionWithTypeArguments":
                  return lines.concat([path2.call(print, "expression"), path2.call(print, "typeParameters")]);
                case "TSInterfaceBody": {
                  var lines$1 = lines.fromString(";\n").join(path2.map(print, "body"));
                  if (lines$1.isEmpty()) {
                    return lines.fromString("{}", options2);
                  }
                  return lines.concat(["{\n", lines$1.indent(options2.tabWidth), ";", "\n}"]);
                }
                case "TSImportType":
                  parts.push("import(", path2.call(print, "argument"), ")");
                  if (n2.qualifier) {
                    parts.push(".", path2.call(print, "qualifier"));
                  }
                  if (n2.typeParameters) {
                    parts.push(path2.call(print, "typeParameters"));
                  }
                  return lines.concat(parts);
                case "TSImportEqualsDeclaration":
                  if (n2.isExport) {
                    parts.push("export ");
                  }
                  parts.push("import ", path2.call(print, "id"), " = ", path2.call(print, "moduleReference"));
                  return maybeAddSemicolon(lines.concat(parts));
                case "TSExternalModuleReference":
                  return lines.concat(["require(", path2.call(print, "expression"), ")"]);
                case "TSModuleDeclaration": {
                  var parent = path2.getParentNode();
                  if (parent.type === "TSModuleDeclaration") {
                    parts.push(".");
                  } else {
                    if (n2.declare) {
                      parts.push("declare ");
                    }
                    if (!n2.global) {
                      var isExternal = n2.id.type === "StringLiteral" || n2.id.type === "Literal" && typeof n2.id.value === "string";
                      if (isExternal) {
                        parts.push("module ");
                      } else if (n2.loc && n2.loc.lines && n2.id.loc) {
                        var prefix2 = n2.loc.lines.sliceString(n2.loc.start, n2.id.loc.start);
                        if (prefix2.indexOf("module") >= 0) {
                          parts.push("module ");
                        } else {
                          parts.push("namespace ");
                        }
                      } else {
                        parts.push("namespace ");
                      }
                    }
                  }
                  parts.push(path2.call(print, "id"));
                  if (n2.body && n2.body.type === "TSModuleDeclaration") {
                    parts.push(path2.call(print, "body"));
                  } else if (n2.body) {
                    var bodyLines = path2.call(print, "body");
                    if (bodyLines.isEmpty()) {
                      parts.push(" {}");
                    } else {
                      parts.push(" {\n", bodyLines.indent(options2.tabWidth), "\n}");
                    }
                  }
                  return lines.concat(parts);
                }
                case "TSModuleBlock":
                  return path2.call(function(bodyPath) {
                    return printStatementSequence(bodyPath, options2, print);
                  }, "body");
                case "ClassHeritage":
                case "ComprehensionBlock":
                case "ComprehensionExpression":
                case "Glob":
                case "GeneratorExpression":
                case "LetStatement":
                case "LetExpression":
                case "GraphExpression":
                case "GraphIndexExpression":
                case "XMLDefaultDeclaration":
                case "XMLAnyName":
                case "XMLQualifiedIdentifier":
                case "XMLFunctionQualifiedIdentifier":
                case "XMLAttributeSelector":
                case "XMLFilterExpression":
                case "XML":
                case "XMLElement":
                case "XMLList":
                case "XMLEscape":
                case "XMLText":
                case "XMLStartTag":
                case "XMLEndTag":
                case "XMLPointTag":
                case "XMLName":
                case "XMLAttribute":
                case "XMLCdata":
                case "XMLComment":
                case "XMLProcessingInstruction":
                default:
                  debugger;
                  throw new Error("unknown type: " + JSON.stringify(n2.type));
              }
            }
            function printDecorators(path2, printPath) {
              var parts = [];
              var node2 = path2.getValue();
              if (node2.decorators && node2.decorators.length > 0 && !util2.getParentExportDeclaration(path2)) {
                path2.each(function(decoratorPath) {
                  parts.push(printPath(decoratorPath), "\n");
                }, "decorators");
              } else if (util2.isExportDeclaration(node2) && node2.declaration && node2.declaration.decorators) {
                path2.each(function(decoratorPath) {
                  parts.push(printPath(decoratorPath), "\n");
                }, "declaration", "decorators");
              }
              return lines.concat(parts);
            }
            function printStatementSequence(path2, options2, print) {
              var filtered = [];
              var sawComment = false;
              var sawStatement = false;
              path2.each(function(stmtPath) {
                var stmt = stmtPath.getValue();
                if (!stmt) {
                  return;
                }
                if (stmt.type === "EmptyStatement" && !(stmt.comments && stmt.comments.length > 0)) {
                  return;
                }
                if (namedTypes2.Comment.check(stmt)) {
                  sawComment = true;
                } else if (namedTypes2.Statement.check(stmt)) {
                  sawStatement = true;
                } else {
                  isString2.assert(stmt);
                }
                filtered.push({node: stmt, printed: print(stmtPath)});
              });
              if (sawComment) {
                assert_12.default.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement lists, but may not coexist with non-Comment nodes.");
              }
              var prevTrailingSpace = null;
              var len = filtered.length;
              var parts = [];
              filtered.forEach(function(info, i) {
                var printed = info.printed;
                var stmt = info.node;
                var multiLine = printed.length > 1;
                var notFirst = i > 0;
                var notLast = i < len - 1;
                var leadingSpace;
                var trailingSpace;
                var lines2 = stmt && stmt.loc && stmt.loc.lines;
                var trueLoc = lines2 && options2.reuseWhitespace && util2.getTrueLoc(stmt, lines2);
                if (notFirst) {
                  if (trueLoc) {
                    var beforeStart = lines2.skipSpaces(trueLoc.start, true);
                    var beforeStartLine = beforeStart ? beforeStart.line : 1;
                    var leadingGap = trueLoc.start.line - beforeStartLine;
                    leadingSpace = Array(leadingGap + 1).join("\n");
                  } else {
                    leadingSpace = multiLine ? "\n\n" : "\n";
                  }
                } else {
                  leadingSpace = "";
                }
                if (notLast) {
                  if (trueLoc) {
                    var afterEnd = lines2.skipSpaces(trueLoc.end);
                    var afterEndLine = afterEnd ? afterEnd.line : lines2.length;
                    var trailingGap = afterEndLine - trueLoc.end.line;
                    trailingSpace = Array(trailingGap + 1).join("\n");
                  } else {
                    trailingSpace = multiLine ? "\n\n" : "\n";
                  }
                } else {
                  trailingSpace = "";
                }
                parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
                if (notLast) {
                  prevTrailingSpace = trailingSpace;
                } else if (trailingSpace) {
                  parts.push(trailingSpace);
                }
              });
              return lines.concat(parts);
            }
            function maxSpace(s1, s2) {
              if (!s1 && !s2) {
                return lines.fromString("");
              }
              if (!s1) {
                return lines.fromString(s2);
              }
              if (!s2) {
                return lines.fromString(s1);
              }
              var spaceLines1 = lines.fromString(s1);
              var spaceLines2 = lines.fromString(s2);
              if (spaceLines2.length > spaceLines1.length) {
                return spaceLines2;
              }
              return spaceLines1;
            }
            function printMethod(path2, options2, print) {
              var node2 = path2.getNode();
              var kind = node2.kind;
              var parts = [];
              var nodeValue = node2.value;
              if (!namedTypes2.FunctionExpression.check(nodeValue)) {
                nodeValue = node2;
              }
              var access = node2.accessibility || node2.access;
              if (typeof access === "string") {
                parts.push(access, " ");
              }
              if (node2.static) {
                parts.push("static ");
              }
              if (node2.abstract) {
                parts.push("abstract ");
              }
              if (node2.readonly) {
                parts.push("readonly ");
              }
              if (nodeValue.async) {
                parts.push("async ");
              }
              if (nodeValue.generator) {
                parts.push("*");
              }
              if (kind === "get" || kind === "set") {
                parts.push(kind, " ");
              }
              var key = path2.call(print, "key");
              if (node2.computed) {
                key = lines.concat(["[", key, "]"]);
              }
              parts.push(key);
              if (node2.optional) {
                parts.push("?");
              }
              if (node2 === nodeValue) {
                parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType"));
                if (node2.body) {
                  parts.push(" ", path2.call(print, "body"));
                } else {
                  parts.push(";");
                }
              } else {
                parts.push(path2.call(print, "value", "typeParameters"), "(", path2.call(function(valuePath) {
                  return printFunctionParams(valuePath, options2, print);
                }, "value"), ")", path2.call(print, "value", "returnType"));
                if (nodeValue.body) {
                  parts.push(" ", path2.call(print, "value", "body"));
                } else {
                  parts.push(";");
                }
              }
              return lines.concat(parts);
            }
            function printArgumentsList(path2, options2, print) {
              var printed = path2.map(print, "arguments");
              var trailingComma = util2.isTrailingCommaEnabled(options2, "parameters");
              var joined = lines.fromString(", ").join(printed);
              if (joined.getLineLength(1) > options2.wrapColumn) {
                joined = lines.fromString(",\n").join(printed);
                return lines.concat(["(\n", joined.indent(options2.tabWidth), trailingComma ? ",\n)" : "\n)"]);
              }
              return lines.concat(["(", joined, ")"]);
            }
            function printFunctionParams(path2, options2, print) {
              var fun = path2.getValue();
              var params;
              var printed = [];
              if (fun.params) {
                params = fun.params;
                printed = path2.map(print, "params");
              } else if (fun.parameters) {
                params = fun.parameters;
                printed = path2.map(print, "parameters");
              }
              if (fun.defaults) {
                path2.each(function(defExprPath) {
                  var i = defExprPath.getName();
                  var p = printed[i];
                  if (p && defExprPath.getValue()) {
                    printed[i] = lines.concat([p, " = ", print(defExprPath)]);
                  }
                }, "defaults");
              }
              if (fun.rest) {
                printed.push(lines.concat(["...", path2.call(print, "rest")]));
              }
              var joined = lines.fromString(", ").join(printed);
              if (joined.length > 1 || joined.getLineLength(1) > options2.wrapColumn) {
                joined = lines.fromString(",\n").join(printed);
                if (util2.isTrailingCommaEnabled(options2, "parameters") && !fun.rest && params[params.length - 1].type !== "RestElement") {
                  joined = lines.concat([joined, ",\n"]);
                } else {
                  joined = lines.concat([joined, "\n"]);
                }
                return lines.concat(["\n", joined.indent(options2.tabWidth)]);
              }
              return joined;
            }
            function printExportDeclaration(path2, options2, print) {
              var decl = path2.getValue();
              var parts = ["export "];
              if (decl.exportKind && decl.exportKind === "type") {
                if (!decl.declaration) {
                  parts.push("type ");
                }
              }
              var shouldPrintSpaces = options2.objectCurlySpacing;
              namedTypes2.Declaration.assert(decl);
              if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
                parts.push("default ");
              }
              if (decl.declaration) {
                parts.push(path2.call(print, "declaration"));
              } else if (decl.specifiers) {
                if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier") {
                  parts.push("*");
                } else if (decl.specifiers.length === 0) {
                  parts.push("{}");
                } else if (decl.specifiers[0].type === "ExportDefaultSpecifier") {
                  var unbracedSpecifiers_2 = [];
                  var bracedSpecifiers_2 = [];
                  path2.each(function(specifierPath) {
                    var spec = specifierPath.getValue();
                    if (spec.type === "ExportDefaultSpecifier") {
                      unbracedSpecifiers_2.push(print(specifierPath));
                    } else {
                      bracedSpecifiers_2.push(print(specifierPath));
                    }
                  }, "specifiers");
                  unbracedSpecifiers_2.forEach(function(lines2, i) {
                    if (i > 0) {
                      parts.push(", ");
                    }
                    parts.push(lines2);
                  });
                  if (bracedSpecifiers_2.length > 0) {
                    var lines_2 = lines.fromString(", ").join(bracedSpecifiers_2);
                    if (lines_2.getLineLength(1) > options2.wrapColumn) {
                      lines_2 = lines.concat([lines.fromString(",\n").join(bracedSpecifiers_2).indent(options2.tabWidth), ","]);
                    }
                    if (unbracedSpecifiers_2.length > 0) {
                      parts.push(", ");
                    }
                    if (lines_2.length > 1) {
                      parts.push("{\n", lines_2, "\n}");
                    } else if (options2.objectCurlySpacing) {
                      parts.push("{ ", lines_2, " }");
                    } else {
                      parts.push("{", lines_2, "}");
                    }
                  }
                } else {
                  parts.push(shouldPrintSpaces ? "{ " : "{", lines.fromString(", ").join(path2.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
                }
                if (decl.source) {
                  parts.push(" from ", path2.call(print, "source"));
                }
              }
              var lines$1 = lines.concat(parts);
              if (lastNonSpaceCharacter(lines$1) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration" || decl.declaration.type === "TSModuleDeclaration" || decl.declaration.type === "TSInterfaceDeclaration" || decl.declaration.type === "TSEnumDeclaration"))) {
                lines$1 = lines.concat([lines$1, ";"]);
              }
              return lines$1;
            }
            function printFlowDeclaration(path2, parts) {
              var parentExportDecl = util2.getParentExportDeclaration(path2);
              if (parentExportDecl) {
                assert_12.default.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
              } else {
                parts.unshift("declare ");
              }
              return lines.concat(parts);
            }
            function printVariance(path2, print) {
              return path2.call(function(variancePath) {
                var value = variancePath.getValue();
                if (value) {
                  if (value === "plus") {
                    return lines.fromString("+");
                  }
                  if (value === "minus") {
                    return lines.fromString("-");
                  }
                  return print(variancePath);
                }
                return lines.fromString("");
              }, "variance");
            }
            function adjustClause(clause, options2) {
              if (clause.length > 1)
                return lines.concat([" ", clause]);
              return lines.concat(["\n", maybeAddSemicolon(clause).indent(options2.tabWidth)]);
            }
            function lastNonSpaceCharacter(lines2) {
              var pos = lines2.lastPos();
              do {
                var ch = lines2.charAt(pos);
                if (/\S/.test(ch))
                  return ch;
              } while (lines2.prevPos(pos));
            }
            function endsWithBrace(lines2) {
              return lastNonSpaceCharacter(lines2) === "}";
            }
            function swapQuotes(str) {
              return str.replace(/['"]/g, function(m) {
                return m === '"' ? "'" : '"';
              });
            }
            function nodeStr(str, options2) {
              isString2.assert(str);
              switch (options2.quote) {
                case "auto": {
                  var double = JSON.stringify(str);
                  var single = swapQuotes(JSON.stringify(swapQuotes(str)));
                  return double.length > single.length ? single : double;
                }
                case "single":
                  return swapQuotes(JSON.stringify(swapQuotes(str)));
                case "double":
                default:
                  return JSON.stringify(str);
              }
            }
            function maybeAddSemicolon(lines$1) {
              var eoc = lastNonSpaceCharacter(lines$1);
              if (!eoc || "\n};".indexOf(eoc) < 0)
                return lines.concat([lines$1, ";"]);
              return lines$1;
            }
          });
          var main = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.run = exports4.prettyPrint = exports4.print = exports4.types = exports4.parse = void 0;
            var fs_1 = tslib_1.__importDefault(require$$0__default["default"]);
            var types2 = tslib_1.__importStar(main$1);
            exports4.types = types2;
            Object.defineProperty(exports4, "parse", {enumerable: true, get: function get2() {
              return parser$1.parse;
            }});
            Object.defineProperty(exports4, "visit", {enumerable: true, get: function get2() {
              return main$1.visit;
            }});
            function print(node2, options2) {
              return new printer.Printer(options2).print(node2);
            }
            exports4.print = print;
            function prettyPrint(node2, options2) {
              return new printer.Printer(options2).printGenerically(node2);
            }
            exports4.prettyPrint = prettyPrint;
            function run(transformer, options2) {
              return runFile(process.argv[2], transformer, options2);
            }
            exports4.run = run;
            function runFile(path2, transformer, options2) {
              fs_1.default.readFile(path2, "utf-8", function(err, code) {
                if (err) {
                  console.error(err);
                  return;
                }
                runString(code, transformer, options2);
              });
            }
            function defaultWriteback(output) {
              process.stdout.write(output);
            }
            function runString(code, transformer, options2) {
              var writeback = options2 && options2.writeback || defaultWriteback;
              transformer(parser$1.parse(code, options2), function(node2) {
                writeback(print(node2, options2).code);
              });
            }
          });
          const types$2 = main.types;
          const builders = main.types.builders;
          const namedTypes = main.types.namedTypes;
          function nullNode() {
            return builders.literal(null);
          }
          function simplePropertyNode(key, value) {
            return builders.property("init", builders.literal(key), value, false);
          }
          function sourcemapAsJSON(map) {
            if (map && map.toJSON)
              return map.toJSON();
            return map;
          }
          function isObject2(value) {
            return !isNil2(value) && value.constructor === Object;
          }
          function isNil2(value) {
            return value === null || value === void 0;
          }
          function isNode() {
            return typeof process !== "undefined";
          }
          function composeSourcemaps(formerMap, latterMap) {
            if (isNode() && formerMap && latterMap && latterMap.mappings) {
              return util$2.composeSourceMaps(sourcemapAsJSON(formerMap), sourcemapAsJSON(latterMap));
            } else if (isNode() && formerMap) {
              return sourcemapAsJSON(formerMap);
            }
            return {};
          }
          const intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
          var encode$1 = function encode$12(number) {
            if (0 <= number && number < intToCharMap.length) {
              return intToCharMap[number];
            }
            throw new TypeError("Must be between 0 and 63: " + number);
          };
          var base64 = {encode: encode$1};
          const VLQ_BASE_SHIFT = 5;
          const VLQ_BASE = 1 << VLQ_BASE_SHIFT;
          const VLQ_BASE_MASK = VLQ_BASE - 1;
          const VLQ_CONTINUATION_BIT = VLQ_BASE;
          function toVLQSigned(aValue) {
            return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
          }
          var encode = function base64VLQ_encode(aValue) {
            let encoded = "";
            let digit;
            let vlq = toVLQSigned(aValue);
            do {
              digit = vlq & VLQ_BASE_MASK;
              vlq >>>= VLQ_BASE_SHIFT;
              if (vlq > 0) {
                digit |= VLQ_CONTINUATION_BIT;
              }
              encoded += base64.encode(digit);
            } while (vlq > 0);
            return encoded;
          };
          var base64Vlq = {encode};
          var util = createCommonjsModule(function(module3, exports4) {
            function getArg(aArgs, aName, aDefaultValue) {
              if (aName in aArgs) {
                return aArgs[aName];
              } else if (arguments.length === 3) {
                return aDefaultValue;
              }
              throw new Error('"' + aName + '" is a required argument.');
            }
            exports4.getArg = getArg;
            const urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
            const dataUrlRegexp = /^data:.+\,.+$/;
            function urlParse(aUrl) {
              const match = aUrl.match(urlRegexp);
              if (!match) {
                return null;
              }
              return {scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5]};
            }
            exports4.urlParse = urlParse;
            function urlGenerate(aParsedUrl) {
              let url = "";
              if (aParsedUrl.scheme) {
                url += aParsedUrl.scheme + ":";
              }
              url += "//";
              if (aParsedUrl.auth) {
                url += aParsedUrl.auth + "@";
              }
              if (aParsedUrl.host) {
                url += aParsedUrl.host;
              }
              if (aParsedUrl.port) {
                url += ":" + aParsedUrl.port;
              }
              if (aParsedUrl.path) {
                url += aParsedUrl.path;
              }
              return url;
            }
            exports4.urlGenerate = urlGenerate;
            const MAX_CACHED_INPUTS = 32;
            function lruMemoize(f) {
              const cache = [];
              return function(input) {
                for (let i = 0; i < cache.length; i++) {
                  if (cache[i].input === input) {
                    const temp = cache[0];
                    cache[0] = cache[i];
                    cache[i] = temp;
                    return cache[0].result;
                  }
                }
                const result = f(input);
                cache.unshift({input, result});
                if (cache.length > MAX_CACHED_INPUTS) {
                  cache.pop();
                }
                return result;
              };
            }
            const normalize3 = lruMemoize(function normalize4(aPath) {
              let path2 = aPath;
              const url = urlParse(aPath);
              if (url) {
                if (!url.path) {
                  return aPath;
                }
                path2 = url.path;
              }
              const isAbsolute = exports4.isAbsolute(path2);
              const parts = [];
              let start = 0;
              let i = 0;
              while (true) {
                start = i;
                i = path2.indexOf("/", start);
                if (i === -1) {
                  parts.push(path2.slice(start));
                  break;
                } else {
                  parts.push(path2.slice(start, i));
                  while (i < path2.length && path2[i] === "/") {
                    i++;
                  }
                }
              }
              let up = 0;
              for (i = parts.length - 1; i >= 0; i--) {
                const part2 = parts[i];
                if (part2 === ".") {
                  parts.splice(i, 1);
                } else if (part2 === "..") {
                  up++;
                } else if (up > 0) {
                  if (part2 === "") {
                    parts.splice(i + 1, up);
                    up = 0;
                  } else {
                    parts.splice(i, 2);
                    up--;
                  }
                }
              }
              path2 = parts.join("/");
              if (path2 === "") {
                path2 = isAbsolute ? "/" : ".";
              }
              if (url) {
                url.path = path2;
                return urlGenerate(url);
              }
              return path2;
            });
            exports4.normalize = normalize3;
            function join(aRoot, aPath) {
              if (aRoot === "") {
                aRoot = ".";
              }
              if (aPath === "") {
                aPath = ".";
              }
              const aPathUrl = urlParse(aPath);
              const aRootUrl = urlParse(aRoot);
              if (aRootUrl) {
                aRoot = aRootUrl.path || "/";
              }
              if (aPathUrl && !aPathUrl.scheme) {
                if (aRootUrl) {
                  aPathUrl.scheme = aRootUrl.scheme;
                }
                return urlGenerate(aPathUrl);
              }
              if (aPathUrl || aPath.match(dataUrlRegexp)) {
                return aPath;
              }
              if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                aRootUrl.host = aPath;
                return urlGenerate(aRootUrl);
              }
              const joined = aPath.charAt(0) === "/" ? aPath : normalize3(aRoot.replace(/\/+$/, "") + "/" + aPath);
              if (aRootUrl) {
                aRootUrl.path = joined;
                return urlGenerate(aRootUrl);
              }
              return joined;
            }
            exports4.join = join;
            exports4.isAbsolute = function(aPath) {
              return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
            };
            function relative(aRoot, aPath) {
              if (aRoot === "") {
                aRoot = ".";
              }
              aRoot = aRoot.replace(/\/$/, "");
              let level = 0;
              while (aPath.indexOf(aRoot + "/") !== 0) {
                const index = aRoot.lastIndexOf("/");
                if (index < 0) {
                  return aPath;
                }
                aRoot = aRoot.slice(0, index);
                if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                  return aPath;
                }
                ++level;
              }
              return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
            }
            exports4.relative = relative;
            const supportsNullProto = function() {
              const obj = Object.create(null);
              return !("__proto__" in obj);
            }();
            function identity(s) {
              return s;
            }
            function toSetString(aStr) {
              if (isProtoString(aStr)) {
                return "$" + aStr;
              }
              return aStr;
            }
            exports4.toSetString = supportsNullProto ? identity : toSetString;
            function fromSetString(aStr) {
              if (isProtoString(aStr)) {
                return aStr.slice(1);
              }
              return aStr;
            }
            exports4.fromSetString = supportsNullProto ? identity : fromSetString;
            function isProtoString(s) {
              if (!s) {
                return false;
              }
              const length = s.length;
              if (length < 9) {
                return false;
              }
              if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
                return false;
              }
              for (let i = length - 10; i >= 0; i--) {
                if (s.charCodeAt(i) !== 36) {
                  return false;
                }
              }
              return true;
            }
            function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
              let cmp = strcmp(mappingA.source, mappingB.source);
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0 || onlyCompareOriginal) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              return strcmp(mappingA.name, mappingB.name);
            }
            exports4.compareByOriginalPositions = compareByOriginalPositions;
            function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
              let cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0 || onlyCompareGenerated) {
                return cmp;
              }
              cmp = strcmp(mappingA.source, mappingB.source);
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0) {
                return cmp;
              }
              return strcmp(mappingA.name, mappingB.name);
            }
            exports4.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
            function strcmp(aStr1, aStr2) {
              if (aStr1 === aStr2) {
                return 0;
              }
              if (aStr1 === null) {
                return 1;
              }
              if (aStr2 === null) {
                return -1;
              }
              if (aStr1 > aStr2) {
                return 1;
              }
              return -1;
            }
            function compareByGeneratedPositionsInflated(mappingA, mappingB) {
              let cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = strcmp(mappingA.source, mappingB.source);
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0) {
                return cmp;
              }
              return strcmp(mappingA.name, mappingB.name);
            }
            exports4.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
            function parseSourceMapInput(str) {
              return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
            }
            exports4.parseSourceMapInput = parseSourceMapInput;
            function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
              sourceURL = sourceURL || "";
              if (sourceRoot) {
                if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
                  sourceRoot += "/";
                }
                sourceURL = sourceRoot + sourceURL;
              }
              if (sourceMapURL) {
                const parsed = urlParse(sourceMapURL);
                if (!parsed) {
                  throw new Error("sourceMapURL could not be parsed");
                }
                if (parsed.path) {
                  const index = parsed.path.lastIndexOf("/");
                  if (index >= 0) {
                    parsed.path = parsed.path.substring(0, index + 1);
                  }
                }
                sourceURL = join(urlGenerate(parsed), sourceURL);
              }
              return normalize3(sourceURL);
            }
            exports4.computeSourceURL = computeSourceURL;
          });
          class ArraySet$1 {
            constructor() {
              this._array = [];
              this._set = new Map();
            }
            static fromArray(aArray, aAllowDuplicates) {
              const set2 = new ArraySet$1();
              for (let i = 0, len = aArray.length; i < len; i++) {
                set2.add(aArray[i], aAllowDuplicates);
              }
              return set2;
            }
            size() {
              return this._set.size;
            }
            add(aStr, aAllowDuplicates) {
              const isDuplicate = this.has(aStr);
              const idx = this._array.length;
              if (!isDuplicate || aAllowDuplicates) {
                this._array.push(aStr);
              }
              if (!isDuplicate) {
                this._set.set(aStr, idx);
              }
            }
            has(aStr) {
              return this._set.has(aStr);
            }
            indexOf(aStr) {
              const idx = this._set.get(aStr);
              if (idx >= 0) {
                return idx;
              }
              throw new Error('"' + aStr + '" is not in the set.');
            }
            at(aIdx) {
              if (aIdx >= 0 && aIdx < this._array.length) {
                return this._array[aIdx];
              }
              throw new Error("No element indexed by " + aIdx);
            }
            toArray() {
              return this._array.slice();
            }
          }
          var ArraySet_1 = ArraySet$1;
          var arraySet = {ArraySet: ArraySet_1};
          function generatedPositionAfter(mappingA, mappingB) {
            const lineA = mappingA.generatedLine;
            const lineB = mappingB.generatedLine;
            const columnA = mappingA.generatedColumn;
            const columnB = mappingB.generatedColumn;
            return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
          }
          class MappingList$1 {
            constructor() {
              this._array = [];
              this._sorted = true;
              this._last = {generatedLine: -1, generatedColumn: 0};
            }
            unsortedForEach(aCallback, aThisArg) {
              this._array.forEach(aCallback, aThisArg);
            }
            add(aMapping) {
              if (generatedPositionAfter(this._last, aMapping)) {
                this._last = aMapping;
                this._array.push(aMapping);
              } else {
                this._sorted = false;
                this._array.push(aMapping);
              }
            }
            toArray() {
              if (!this._sorted) {
                this._array.sort(util.compareByGeneratedPositionsInflated);
                this._sorted = true;
              }
              return this._array;
            }
          }
          var MappingList_1 = MappingList$1;
          var mappingList = {MappingList: MappingList_1};
          const ArraySet = arraySet.ArraySet;
          const MappingList = mappingList.MappingList;
          class SourceMapGenerator$1 {
            constructor(aArgs) {
              if (!aArgs) {
                aArgs = {};
              }
              this._file = util.getArg(aArgs, "file", null);
              this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
              this._skipValidation = util.getArg(aArgs, "skipValidation", false);
              this._sources = new ArraySet();
              this._names = new ArraySet();
              this._mappings = new MappingList();
              this._sourcesContents = null;
            }
            static fromSourceMap(aSourceMapConsumer) {
              const sourceRoot = aSourceMapConsumer.sourceRoot;
              const generator = new SourceMapGenerator$1({file: aSourceMapConsumer.file, sourceRoot});
              aSourceMapConsumer.eachMapping(function(mapping2) {
                const newMapping = {generated: {line: mapping2.generatedLine, column: mapping2.generatedColumn}};
                if (mapping2.source != null) {
                  newMapping.source = mapping2.source;
                  if (sourceRoot != null) {
                    newMapping.source = util.relative(sourceRoot, newMapping.source);
                  }
                  newMapping.original = {line: mapping2.originalLine, column: mapping2.originalColumn};
                  if (mapping2.name != null) {
                    newMapping.name = mapping2.name;
                  }
                }
                generator.addMapping(newMapping);
              });
              aSourceMapConsumer.sources.forEach(function(sourceFile) {
                let sourceRelative = sourceFile;
                if (sourceRoot !== null) {
                  sourceRelative = util.relative(sourceRoot, sourceFile);
                }
                if (!generator._sources.has(sourceRelative)) {
                  generator._sources.add(sourceRelative);
                }
                const content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (content != null) {
                  generator.setSourceContent(sourceFile, content);
                }
              });
              return generator;
            }
            addMapping(aArgs) {
              const generated = util.getArg(aArgs, "generated");
              const original = util.getArg(aArgs, "original", null);
              let source = util.getArg(aArgs, "source", null);
              let name2 = util.getArg(aArgs, "name", null);
              if (!this._skipValidation) {
                this._validateMapping(generated, original, source, name2);
              }
              if (source != null) {
                source = String(source);
                if (!this._sources.has(source)) {
                  this._sources.add(source);
                }
              }
              if (name2 != null) {
                name2 = String(name2);
                if (!this._names.has(name2)) {
                  this._names.add(name2);
                }
              }
              this._mappings.add({generatedLine: generated.line, generatedColumn: generated.column, originalLine: original != null && original.line, originalColumn: original != null && original.column, source, name: name2});
            }
            setSourceContent(aSourceFile, aSourceContent) {
              let source = aSourceFile;
              if (this._sourceRoot != null) {
                source = util.relative(this._sourceRoot, source);
              }
              if (aSourceContent != null) {
                if (!this._sourcesContents) {
                  this._sourcesContents = Object.create(null);
                }
                this._sourcesContents[util.toSetString(source)] = aSourceContent;
              } else if (this._sourcesContents) {
                delete this._sourcesContents[util.toSetString(source)];
                if (Object.keys(this._sourcesContents).length === 0) {
                  this._sourcesContents = null;
                }
              }
            }
            applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
              let sourceFile = aSourceFile;
              if (aSourceFile == null) {
                if (aSourceMapConsumer.file == null) {
                  throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
                }
                sourceFile = aSourceMapConsumer.file;
              }
              const sourceRoot = this._sourceRoot;
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              const newSources = this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;
              const newNames = new ArraySet();
              this._mappings.unsortedForEach(function(mapping2) {
                if (mapping2.source === sourceFile && mapping2.originalLine != null) {
                  const original = aSourceMapConsumer.originalPositionFor({line: mapping2.originalLine, column: mapping2.originalColumn});
                  if (original.source != null) {
                    mapping2.source = original.source;
                    if (aSourceMapPath != null) {
                      mapping2.source = util.join(aSourceMapPath, mapping2.source);
                    }
                    if (sourceRoot != null) {
                      mapping2.source = util.relative(sourceRoot, mapping2.source);
                    }
                    mapping2.originalLine = original.line;
                    mapping2.originalColumn = original.column;
                    if (original.name != null) {
                      mapping2.name = original.name;
                    }
                  }
                }
                const source = mapping2.source;
                if (source != null && !newSources.has(source)) {
                  newSources.add(source);
                }
                const name2 = mapping2.name;
                if (name2 != null && !newNames.has(name2)) {
                  newNames.add(name2);
                }
              }, this);
              this._sources = newSources;
              this._names = newNames;
              aSourceMapConsumer.sources.forEach(function(srcFile) {
                const content = aSourceMapConsumer.sourceContentFor(srcFile);
                if (content != null) {
                  if (aSourceMapPath != null) {
                    srcFile = util.join(aSourceMapPath, srcFile);
                  }
                  if (sourceRoot != null) {
                    srcFile = util.relative(sourceRoot, srcFile);
                  }
                  this.setSourceContent(srcFile, content);
                }
              }, this);
            }
            _validateMapping(aGenerated, aOriginal, aSource, aName) {
              if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
                throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
              }
              if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)
                ;
              else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
                ;
              else {
                throw new Error("Invalid mapping: " + JSON.stringify({generated: aGenerated, source: aSource, original: aOriginal, name: aName}));
              }
            }
            _serializeMappings() {
              let previousGeneratedColumn = 0;
              let previousGeneratedLine = 1;
              let previousOriginalColumn = 0;
              let previousOriginalLine = 0;
              let previousName = 0;
              let previousSource = 0;
              let result = "";
              let next;
              let mapping2;
              let nameIdx;
              let sourceIdx;
              const mappings = this._mappings.toArray();
              for (let i = 0, len = mappings.length; i < len; i++) {
                mapping2 = mappings[i];
                next = "";
                if (mapping2.generatedLine !== previousGeneratedLine) {
                  previousGeneratedColumn = 0;
                  while (mapping2.generatedLine !== previousGeneratedLine) {
                    next += ";";
                    previousGeneratedLine++;
                  }
                } else if (i > 0) {
                  if (!util.compareByGeneratedPositionsInflated(mapping2, mappings[i - 1])) {
                    continue;
                  }
                  next += ",";
                }
                next += base64Vlq.encode(mapping2.generatedColumn - previousGeneratedColumn);
                previousGeneratedColumn = mapping2.generatedColumn;
                if (mapping2.source != null) {
                  sourceIdx = this._sources.indexOf(mapping2.source);
                  next += base64Vlq.encode(sourceIdx - previousSource);
                  previousSource = sourceIdx;
                  next += base64Vlq.encode(mapping2.originalLine - 1 - previousOriginalLine);
                  previousOriginalLine = mapping2.originalLine - 1;
                  next += base64Vlq.encode(mapping2.originalColumn - previousOriginalColumn);
                  previousOriginalColumn = mapping2.originalColumn;
                  if (mapping2.name != null) {
                    nameIdx = this._names.indexOf(mapping2.name);
                    next += base64Vlq.encode(nameIdx - previousName);
                    previousName = nameIdx;
                  }
                }
                result += next;
              }
              return result;
            }
            _generateSourcesContent(aSources, aSourceRoot) {
              return aSources.map(function(source) {
                if (!this._sourcesContents) {
                  return null;
                }
                if (aSourceRoot != null) {
                  source = util.relative(aSourceRoot, source);
                }
                const key = util.toSetString(source);
                return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
              }, this);
            }
            toJSON() {
              const map = {version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings()};
              if (this._file != null) {
                map.file = this._file;
              }
              if (this._sourceRoot != null) {
                map.sourceRoot = this._sourceRoot;
              }
              if (this._sourcesContents) {
                map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
              }
              return map;
            }
            toString() {
              return JSON.stringify(this.toJSON());
            }
          }
          SourceMapGenerator$1.prototype._version = 3;
          var SourceMapGenerator_1 = SourceMapGenerator$1;
          var sourceMapGenerator = {SourceMapGenerator: SourceMapGenerator_1};
          createCommonjsModule(function(module3, exports4) {
            exports4.GREATEST_LOWER_BOUND = 1;
            exports4.LEAST_UPPER_BOUND = 2;
            function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
              const mid = Math.floor((aHigh - aLow) / 2) + aLow;
              const cmp = aCompare(aNeedle, aHaystack[mid], true);
              if (cmp === 0) {
                return mid;
              } else if (cmp > 0) {
                if (aHigh - mid > 1) {
                  return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
                }
                if (aBias == exports4.LEAST_UPPER_BOUND) {
                  return aHigh < aHaystack.length ? aHigh : -1;
                }
                return mid;
              }
              if (mid - aLow > 1) {
                return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
              }
              if (aBias == exports4.LEAST_UPPER_BOUND) {
                return mid;
              }
              return aLow < 0 ? -1 : aLow;
            }
            exports4.search = function search(aNeedle, aHaystack, aCompare, aBias) {
              if (aHaystack.length === 0) {
                return -1;
              }
              let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports4.GREATEST_LOWER_BOUND);
              if (index < 0) {
                return -1;
              }
              while (index - 1 >= 0) {
                if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                  break;
                }
                --index;
              }
              return index;
            };
          });
          createCommonjsModule(function(module3) {
            if (typeof fetch === "function") {
              let mappingsWasmUrl = null;
              module3.exports = function readWasm() {
                if (typeof mappingsWasmUrl !== "string") {
                  throw new Error("You must provide the URL of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer");
                }
                return fetch(mappingsWasmUrl).then((response) => response.arrayBuffer());
              };
              module3.exports.initialize = (url) => mappingsWasmUrl = url;
            } else {
              const fs = require$$0__default["default"];
              const path2 = require$$1__default["default"];
              module3.exports = function readWasm() {
                return new Promise((resolve, reject) => {
                  const wasmPath = path2.join(__dirname, "mappings.wasm");
                  fs.readFile(wasmPath, null, (error, data) => {
                    if (error) {
                      reject(error);
                      return;
                    }
                    resolve(data.buffer);
                  });
                });
              };
              module3.exports.initialize = (_) => {
                console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
              };
            }
          });
          var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
          function createSourcemap(options2) {
            return new SourceMapGenerator(options2);
          }
          const Output = Object.freeze({code: "", ast: [], meta: {}, map: null});
          function createOutput(data, meta) {
            const output = Object.assign({}, Output, data, {meta});
            if (!output.map && meta && meta.options && meta.options.file)
              return Object.assign({}, output, {map: createSourcemap({file: meta.options.file})});
            return output;
          }
          function transform(compiler2, meta, source) {
            const result = compiler2 ? compiler2(source, meta) : {code: source};
            return createOutput(result, meta);
          }
          function panic$1(message) {
            throw new Error(message);
          }
          const postprocessors = new Set();
          function register$1(postprocessor) {
            if (postprocessors.has(postprocessor)) {
              panic$1(`This postprocessor "${postprocessor.name || postprocessor.toString()}" was already registered`);
            }
            postprocessors.add(postprocessor);
            return postprocessors;
          }
          function execute$1(compilerOutput, meta) {
            return Array.from(postprocessors).reduce(function(acc, postprocessor) {
              const {code, map} = acc;
              const output = postprocessor(code, meta);
              return {code: output.code, map: composeSourcemaps(map, output.map)};
            }, createOutput(compilerOutput, meta));
          }
          const preprocessors = Object.freeze({javascript: new Map(), css: new Map(), template: new Map().set("default", (code) => ({code}))});
          function preprocessorTypeError(type2) {
            panic$1(`No preprocessor of type "${type2}" was found, please make sure to use one of these: 'javascript', 'css' or 'template'`);
          }
          function preprocessorNameNotFoundError(name2) {
            panic$1(`No preprocessor named "${name2}" was found, are you sure you have registered it?'`);
          }
          function register2(type2, name2, preprocessor) {
            if (!type2)
              panic$1("Please define the type of preprocessor you want to register 'javascript', 'css' or 'template'");
            if (!name2)
              panic$1("Please define a name for your preprocessor");
            if (!preprocessor)
              panic$1("Please provide a preprocessor function");
            if (!preprocessors[type2])
              preprocessorTypeError(type2);
            if (preprocessors[type2].has(name2))
              panic$1(`The preprocessor ${name2} was already registered before`);
            preprocessors[type2].set(name2, preprocessor);
            return preprocessors;
          }
          function execute(type2, name2, meta, source) {
            if (!preprocessors[type2])
              preprocessorTypeError(type2);
            if (!preprocessors[type2].has(name2))
              preprocessorNameNotFoundError(name2);
            return transform(preprocessors[type2].get(name2), meta, source);
          }
          function compose2() {
            for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
              fns[_key] = arguments[_key];
            }
            return fns.reduce((f, g) => function() {
              return f(g(...arguments));
            });
          }
          /*! https://mths.be/cssesc v3.0.0 by @mathias */
          var object = {};
          var hasOwnProperty = object.hasOwnProperty;
          var merge = function merge2(options2, defaults) {
            if (!options2) {
              return defaults;
            }
            var result = {};
            for (var key in defaults) {
              result[key] = hasOwnProperty.call(options2, key) ? options2[key] : defaults[key];
            }
            return result;
          };
          var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
          var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
          var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
          var cssesc = function cssesc2(string, options2) {
            options2 = merge(options2, cssesc2.options);
            if (options2.quotes != "single" && options2.quotes != "double") {
              options2.quotes = "single";
            }
            var quote = options2.quotes == "double" ? '"' : "'";
            var isIdentifier2 = options2.isIdentifier;
            var firstChar = string.charAt(0);
            var output = "";
            var counter = 0;
            var length = string.length;
            while (counter < length) {
              var character = string.charAt(counter++);
              var codePoint = character.charCodeAt();
              var value = void 0;
              if (codePoint < 32 || codePoint > 126) {
                if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
                  var extra = string.charCodeAt(counter++);
                  if ((extra & 64512) == 56320) {
                    codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
                  } else {
                    counter--;
                  }
                }
                value = "\\" + codePoint.toString(16).toUpperCase() + " ";
              } else {
                if (options2.escapeEverything) {
                  if (regexAnySingleEscape.test(character)) {
                    value = "\\" + character;
                  } else {
                    value = "\\" + codePoint.toString(16).toUpperCase() + " ";
                  }
                } else if (/[\t\n\f\r\x0B]/.test(character)) {
                  value = "\\" + codePoint.toString(16).toUpperCase() + " ";
                } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier2 && regexSingleEscape.test(character)) {
                  value = "\\" + character;
                } else {
                  value = character;
                }
              }
              output += value;
            }
            if (isIdentifier2) {
              if (/^-[-\d]/.test(output)) {
                output = "\\-" + output.slice(1);
              } else if (/\d/.test(firstChar)) {
                output = "\\3" + firstChar + " " + output.slice(1);
              }
            }
            output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
              if ($1 && $1.length % 2) {
                return $0;
              }
              return ($1 || "") + $2;
            });
            if (!isIdentifier2 && options2.wrap) {
              return quote + output + quote;
            }
            return output;
          };
          cssesc.options = {"escapeEverything": false, "isIdentifier": false, "quotes": "single", "wrap": false};
          cssesc.version = "3.0.0";
          var cssesc_1 = cssesc;
          const ATTRIBUTE_TYPE_NAME = "type";
          function getPreprocessorTypeByAttribute(sourceNode2) {
            const typeAttribute = sourceNode2.attributes ? sourceNode2.attributes.find((attribute) => attribute.name === ATTRIBUTE_TYPE_NAME) : null;
            return typeAttribute ? normalize2(typeAttribute.value) : null;
          }
          function normalize2(value) {
            return value.replace("text/", "");
          }
          function preprocess(preprocessorType, preprocessorName, meta, node2) {
            const code = node2.text;
            return preprocessorName ? execute(preprocessorType, preprocessorName, meta, code) : {code};
          }
          const R_MLCOMMS = /\/\*[^*]*\*+(?:[^*/][^*]*\*+)*\//g;
          const S_LINESTR = /"[^"\n\\]*(?:\\[\S\s][^"\n\\]*)*"|'[^'\n\\]*(?:\\[\S\s][^'\n\\]*)*'/.source;
          const CSS_SELECTOR = RegExp(`([{}]|^)[; ]*((?:[^@ ;{}][^{}]*)?[^@ ;{}:] ?)(?={)|${S_LINESTR}`, "g");
          function scopedCSS(tag2, css2) {
            const host = ":host";
            const selectorsBlacklist = ["from", "to"];
            return css2.replace(CSS_SELECTOR, function(m, p1, p2) {
              if (!p2)
                return m;
              p2 = p2.replace(/[^,]+/g, function(sel) {
                const s = sel.trim();
                if (s.indexOf(tag2) === 0) {
                  return sel;
                }
                if (!s || selectorsBlacklist.indexOf(s) > -1 || s.slice(-1) === "%") {
                  return sel;
                }
                if (s.indexOf(host) < 0) {
                  return `${tag2} ${s},[is="${tag2}"] ${s}`;
                } else {
                  return `${s.replace(host, tag2)},${s.replace(host, `[is="${tag2}"]`)}`;
                }
              });
              return p1 ? `${p1} ${p2}` : p2;
            });
          }
          function compactCss(code) {
            return code.replace(R_MLCOMMS, "").replace(/\s+/g, " ").trim();
          }
          const escapeBackslashes = (s) => s.replace(/\\/g, "\\\\");
          const escapeIdentifier = (identifier) => escapeBackslashes(cssesc_1(identifier, {isIdentifier: true}));
          function css(sourceNode2, source, meta, ast) {
            const preprocessorName = getPreprocessorTypeByAttribute(sourceNode2);
            const {options: options2} = meta;
            const preprocessorOutput = preprocess("css", preprocessorName, meta, sourceNode2.text);
            const normalizedCssCode = compactCss(preprocessorOutput.code);
            const escapedCssIdentifier = escapeIdentifier(meta.tagName);
            const cssCode = (options2.scopedCss ? scopedCSS(escapedCssIdentifier, escapeBackslashes(normalizedCssCode)) : escapeBackslashes(normalizedCssCode)).trim();
            types$2.visit(ast, {visitProperty(path2) {
              if (path2.value.key.value === TAG_CSS_PROPERTY) {
                path2.value.value = builders.templateLiteral([builders.templateElement({raw: cssCode, cooked: ""}, false)], []);
                return false;
              }
              this.traverse(path2);
            }});
            return ast;
          }
          function curry2(fn) {
            for (var _len2 = arguments.length, acc = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              acc[_key2 - 1] = arguments[_key2];
            }
            return function() {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              args = [...acc, ...args];
              return args.length < fn.length ? curry2(fn, ...args) : fn(...args);
            };
          }
          function generateJavascript(ast, options2) {
            return main.print(ast, Object.assign({}, options2, {tabWidth: 2, wrapColumn: 0, quote: "single"}));
          }
          function hasHTMLOutsideRootNode(root, code, parse) {
            const additionalCode = root ? [
              code.substr(0, root.start),
              code.substr(root.end, code.length)
            ].join("").trim() : "";
            if (additionalCode) {
              try {
                const {template: template2, javascript: javascript2, css: css2} = parse(additionalCode).output;
                return [template2, javascript2, css2].some(isObject2);
              } catch (error) {
                return false;
              }
            }
            return false;
          }
          function isEmptySourcemap(map) {
            return !map || !map.mappings || !map.mappings.length;
          }
          var builtin = {AggregateError: false, "Array": false, "ArrayBuffer": false, Atomics: false, BigInt: false, BigInt64Array: false, BigUint64Array: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, FinalizationRegistry: false, "Float32Array": false, "Float64Array": false, "Function": false, globalThis: false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, WeakRef: false, "WeakSet": false};
          var es5 = {"Array": false, "Boolean": false, constructor: false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Function": false, hasOwnProperty: false, "Infinity": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, propertyIsEnumerable: false, "RangeError": false, "ReferenceError": false, "RegExp": false, "String": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false};
          var es2015 = {"Array": false, "ArrayBuffer": false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Float32Array": false, "Float64Array": false, "Function": false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, "WeakSet": false};
          var es2017 = {"Array": false, "ArrayBuffer": false, Atomics: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Float32Array": false, "Float64Array": false, "Function": false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, "WeakSet": false};
          var es2020 = {"Array": false, "ArrayBuffer": false, Atomics: false, BigInt: false, BigInt64Array: false, BigUint64Array: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, "Float32Array": false, "Float64Array": false, "Function": false, globalThis: false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, "WeakSet": false};
          var es2021 = {AggregateError: false, "Array": false, "ArrayBuffer": false, Atomics: false, BigInt: false, BigInt64Array: false, BigUint64Array: false, "Boolean": false, constructor: false, "DataView": false, "Date": false, "decodeURI": false, "decodeURIComponent": false, "encodeURI": false, "encodeURIComponent": false, "Error": false, "escape": false, "eval": false, "EvalError": false, FinalizationRegistry: false, "Float32Array": false, "Float64Array": false, "Function": false, globalThis: false, hasOwnProperty: false, "Infinity": false, "Int16Array": false, "Int32Array": false, "Int8Array": false, "isFinite": false, "isNaN": false, isPrototypeOf: false, "JSON": false, "Map": false, "Math": false, "NaN": false, "Number": false, "Object": false, "parseFloat": false, "parseInt": false, "Promise": false, propertyIsEnumerable: false, "Proxy": false, "RangeError": false, "ReferenceError": false, "Reflect": false, "RegExp": false, "Set": false, SharedArrayBuffer: false, "String": false, "Symbol": false, "SyntaxError": false, toLocaleString: false, toString: false, "TypeError": false, "Uint16Array": false, "Uint32Array": false, "Uint8Array": false, "Uint8ClampedArray": false, "undefined": false, "unescape": false, "URIError": false, valueOf: false, "WeakMap": false, WeakRef: false, "WeakSet": false};
          var browser = {AbortController: false, AbortSignal: false, addEventListener: false, alert: false, AnalyserNode: false, Animation: false, AnimationEffectReadOnly: false, AnimationEffectTiming: false, AnimationEffectTimingReadOnly: false, AnimationEvent: false, AnimationPlaybackEvent: false, AnimationTimeline: false, applicationCache: false, ApplicationCache: false, ApplicationCacheErrorEvent: false, atob: false, Attr: false, Audio: false, AudioBuffer: false, AudioBufferSourceNode: false, AudioContext: false, AudioDestinationNode: false, AudioListener: false, AudioNode: false, AudioParam: false, AudioProcessingEvent: false, AudioScheduledSourceNode: false, "AudioWorkletGlobalScope ": false, AudioWorkletNode: false, AudioWorkletProcessor: false, BarProp: false, BaseAudioContext: false, BatteryManager: false, BeforeUnloadEvent: false, BiquadFilterNode: false, Blob: false, BlobEvent: false, blur: false, BroadcastChannel: false, btoa: false, BudgetService: false, ByteLengthQueuingStrategy: false, Cache: false, caches: false, CacheStorage: false, cancelAnimationFrame: false, cancelIdleCallback: false, CanvasCaptureMediaStreamTrack: false, CanvasGradient: false, CanvasPattern: false, CanvasRenderingContext2D: false, ChannelMergerNode: false, ChannelSplitterNode: false, CharacterData: false, clearInterval: false, clearTimeout: false, clientInformation: false, ClipboardEvent: false, close: false, closed: false, CloseEvent: false, Comment: false, CompositionEvent: false, confirm: false, console: false, ConstantSourceNode: false, ConvolverNode: false, CountQueuingStrategy: false, createImageBitmap: false, Credential: false, CredentialsContainer: false, crypto: false, Crypto: false, CryptoKey: false, CSS: false, CSSConditionRule: false, CSSFontFaceRule: false, CSSGroupingRule: false, CSSImportRule: false, CSSKeyframeRule: false, CSSKeyframesRule: false, CSSMediaRule: false, CSSNamespaceRule: false, CSSPageRule: false, CSSRule: false, CSSRuleList: false, CSSStyleDeclaration: false, CSSStyleRule: false, CSSStyleSheet: false, CSSSupportsRule: false, CustomElementRegistry: false, customElements: false, CustomEvent: false, DataTransfer: false, DataTransferItem: false, DataTransferItemList: false, defaultstatus: false, defaultStatus: false, DelayNode: false, DeviceMotionEvent: false, DeviceOrientationEvent: false, devicePixelRatio: false, dispatchEvent: false, document: false, Document: false, DocumentFragment: false, DocumentType: false, DOMError: false, DOMException: false, DOMImplementation: false, DOMMatrix: false, DOMMatrixReadOnly: false, DOMParser: false, DOMPoint: false, DOMPointReadOnly: false, DOMQuad: false, DOMRect: false, DOMRectReadOnly: false, DOMStringList: false, DOMStringMap: false, DOMTokenList: false, DragEvent: false, DynamicsCompressorNode: false, Element: false, ErrorEvent: false, event: false, Event: false, EventSource: false, EventTarget: false, external: false, fetch: false, File: false, FileList: false, FileReader: false, find: false, focus: false, FocusEvent: false, FontFace: false, FontFaceSetLoadEvent: false, FormData: false, frameElement: false, frames: false, GainNode: false, Gamepad: false, GamepadButton: false, GamepadEvent: false, getComputedStyle: false, getSelection: false, HashChangeEvent: false, Headers: false, history: false, History: false, HTMLAllCollection: false, HTMLAnchorElement: false, HTMLAreaElement: false, HTMLAudioElement: false, HTMLBaseElement: false, HTMLBodyElement: false, HTMLBRElement: false, HTMLButtonElement: false, HTMLCanvasElement: false, HTMLCollection: false, HTMLContentElement: false, HTMLDataElement: false, HTMLDataListElement: false, HTMLDetailsElement: false, HTMLDialogElement: false, HTMLDirectoryElement: false, HTMLDivElement: false, HTMLDListElement: false, HTMLDocument: false, HTMLElement: false, HTMLEmbedElement: false, HTMLFieldSetElement: false, HTMLFontElement: false, HTMLFormControlsCollection: false, HTMLFormElement: false, HTMLFrameElement: false, HTMLFrameSetElement: false, HTMLHeadElement: false, HTMLHeadingElement: false, HTMLHRElement: false, HTMLHtmlElement: false, HTMLIFrameElement: false, HTMLImageElement: false, HTMLInputElement: false, HTMLLabelElement: false, HTMLLegendElement: false, HTMLLIElement: false, HTMLLinkElement: false, HTMLMapElement: false, HTMLMarqueeElement: false, HTMLMediaElement: false, HTMLMenuElement: false, HTMLMetaElement: false, HTMLMeterElement: false, HTMLModElement: false, HTMLObjectElement: false, HTMLOListElement: false, HTMLOptGroupElement: false, HTMLOptionElement: false, HTMLOptionsCollection: false, HTMLOutputElement: false, HTMLParagraphElement: false, HTMLParamElement: false, HTMLPictureElement: false, HTMLPreElement: false, HTMLProgressElement: false, HTMLQuoteElement: false, HTMLScriptElement: false, HTMLSelectElement: false, HTMLShadowElement: false, HTMLSlotElement: false, HTMLSourceElement: false, HTMLSpanElement: false, HTMLStyleElement: false, HTMLTableCaptionElement: false, HTMLTableCellElement: false, HTMLTableColElement: false, HTMLTableElement: false, HTMLTableRowElement: false, HTMLTableSectionElement: false, HTMLTemplateElement: false, HTMLTextAreaElement: false, HTMLTimeElement: false, HTMLTitleElement: false, HTMLTrackElement: false, HTMLUListElement: false, HTMLUnknownElement: false, HTMLVideoElement: false, IDBCursor: false, IDBCursorWithValue: false, IDBDatabase: false, IDBFactory: false, IDBIndex: false, IDBKeyRange: false, IDBObjectStore: false, IDBOpenDBRequest: false, IDBRequest: false, IDBTransaction: false, IDBVersionChangeEvent: false, IdleDeadline: false, IIRFilterNode: false, Image: false, ImageBitmap: false, ImageBitmapRenderingContext: false, ImageCapture: false, ImageData: false, indexedDB: false, innerHeight: false, innerWidth: false, InputEvent: false, IntersectionObserver: false, IntersectionObserverEntry: false, "Intl": false, isSecureContext: false, KeyboardEvent: false, KeyframeEffect: false, KeyframeEffectReadOnly: false, length: false, localStorage: false, location: true, Location: false, locationbar: false, matchMedia: false, MediaDeviceInfo: false, MediaDevices: false, MediaElementAudioSourceNode: false, MediaEncryptedEvent: false, MediaError: false, MediaKeyMessageEvent: false, MediaKeySession: false, MediaKeyStatusMap: false, MediaKeySystemAccess: false, MediaList: false, MediaQueryList: false, MediaQueryListEvent: false, MediaRecorder: false, MediaSettingsRange: false, MediaSource: false, MediaStream: false, MediaStreamAudioDestinationNode: false, MediaStreamAudioSourceNode: false, MediaStreamEvent: false, MediaStreamTrack: false, MediaStreamTrackEvent: false, menubar: false, MessageChannel: false, MessageEvent: false, MessagePort: false, MIDIAccess: false, MIDIConnectionEvent: false, MIDIInput: false, MIDIInputMap: false, MIDIMessageEvent: false, MIDIOutput: false, MIDIOutputMap: false, MIDIPort: false, MimeType: false, MimeTypeArray: false, MouseEvent: false, moveBy: false, moveTo: false, MutationEvent: false, MutationObserver: false, MutationRecord: false, name: false, NamedNodeMap: false, NavigationPreloadManager: false, navigator: false, Navigator: false, NetworkInformation: false, Node: false, NodeFilter: false, NodeIterator: false, NodeList: false, Notification: false, OfflineAudioCompletionEvent: false, OfflineAudioContext: false, offscreenBuffering: false, OffscreenCanvas: true, OffscreenCanvasRenderingContext2D: false, onabort: true, onafterprint: true, onanimationend: true, onanimationiteration: true, onanimationstart: true, onappinstalled: true, onauxclick: true, onbeforeinstallprompt: true, onbeforeprint: true, onbeforeunload: true, onblur: true, oncancel: true, oncanplay: true, oncanplaythrough: true, onchange: true, onclick: true, onclose: true, oncontextmenu: true, oncuechange: true, ondblclick: true, ondevicemotion: true, ondeviceorientation: true, ondeviceorientationabsolute: true, ondrag: true, ondragend: true, ondragenter: true, ondragleave: true, ondragover: true, ondragstart: true, ondrop: true, ondurationchange: true, onemptied: true, onended: true, onerror: true, onfocus: true, ongotpointercapture: true, onhashchange: true, oninput: true, oninvalid: true, onkeydown: true, onkeypress: true, onkeyup: true, onlanguagechange: true, onload: true, onloadeddata: true, onloadedmetadata: true, onloadstart: true, onlostpointercapture: true, onmessage: true, onmessageerror: true, onmousedown: true, onmouseenter: true, onmouseleave: true, onmousemove: true, onmouseout: true, onmouseover: true, onmouseup: true, onmousewheel: true, onoffline: true, ononline: true, onpagehide: true, onpageshow: true, onpause: true, onplay: true, onplaying: true, onpointercancel: true, onpointerdown: true, onpointerenter: true, onpointerleave: true, onpointermove: true, onpointerout: true, onpointerover: true, onpointerup: true, onpopstate: true, onprogress: true, onratechange: true, onrejectionhandled: true, onreset: true, onresize: true, onscroll: true, onsearch: true, onseeked: true, onseeking: true, onselect: true, onstalled: true, onstorage: true, onsubmit: true, onsuspend: true, ontimeupdate: true, ontoggle: true, ontransitionend: true, onunhandledrejection: true, onunload: true, onvolumechange: true, onwaiting: true, onwheel: true, open: false, openDatabase: false, opener: false, Option: false, origin: false, OscillatorNode: false, outerHeight: false, outerWidth: false, OverconstrainedError: false, PageTransitionEvent: false, pageXOffset: false, pageYOffset: false, PannerNode: false, parent: false, Path2D: false, PaymentAddress: false, PaymentRequest: false, PaymentRequestUpdateEvent: false, PaymentResponse: false, performance: false, Performance: false, PerformanceEntry: false, PerformanceLongTaskTiming: false, PerformanceMark: false, PerformanceMeasure: false, PerformanceNavigation: false, PerformanceNavigationTiming: false, PerformanceObserver: false, PerformanceObserverEntryList: false, PerformancePaintTiming: false, PerformanceResourceTiming: false, PerformanceTiming: false, PeriodicWave: false, Permissions: false, PermissionStatus: false, personalbar: false, PhotoCapabilities: false, Plugin: false, PluginArray: false, PointerEvent: false, PopStateEvent: false, postMessage: false, Presentation: false, PresentationAvailability: false, PresentationConnection: false, PresentationConnectionAvailableEvent: false, PresentationConnectionCloseEvent: false, PresentationConnectionList: false, PresentationReceiver: false, PresentationRequest: false, print: false, ProcessingInstruction: false, ProgressEvent: false, PromiseRejectionEvent: false, prompt: false, PushManager: false, PushSubscription: false, PushSubscriptionOptions: false, queueMicrotask: false, RadioNodeList: false, Range: false, ReadableStream: false, registerProcessor: false, RemotePlayback: false, removeEventListener: false, Request: false, requestAnimationFrame: false, requestIdleCallback: false, resizeBy: false, ResizeObserver: false, ResizeObserverEntry: false, resizeTo: false, Response: false, RTCCertificate: false, RTCDataChannel: false, RTCDataChannelEvent: false, RTCDtlsTransport: false, RTCIceCandidate: false, RTCIceGatherer: false, RTCIceTransport: false, RTCPeerConnection: false, RTCPeerConnectionIceEvent: false, RTCRtpContributingSource: false, RTCRtpReceiver: false, RTCRtpSender: false, RTCSctpTransport: false, RTCSessionDescription: false, RTCStatsReport: false, RTCTrackEvent: false, screen: false, Screen: false, screenLeft: false, ScreenOrientation: false, screenTop: false, screenX: false, screenY: false, ScriptProcessorNode: false, scroll: false, scrollbars: false, scrollBy: false, scrollTo: false, scrollX: false, scrollY: false, SecurityPolicyViolationEvent: false, Selection: false, self: false, ServiceWorker: false, ServiceWorkerContainer: false, ServiceWorkerRegistration: false, sessionStorage: false, setInterval: false, setTimeout: false, ShadowRoot: false, SharedWorker: false, SourceBuffer: false, SourceBufferList: false, speechSynthesis: false, SpeechSynthesisEvent: false, SpeechSynthesisUtterance: false, StaticRange: false, status: false, statusbar: false, StereoPannerNode: false, stop: false, Storage: false, StorageEvent: false, StorageManager: false, styleMedia: false, StyleSheet: false, StyleSheetList: false, SubtleCrypto: false, SVGAElement: false, SVGAngle: false, SVGAnimatedAngle: false, SVGAnimatedBoolean: false, SVGAnimatedEnumeration: false, SVGAnimatedInteger: false, SVGAnimatedLength: false, SVGAnimatedLengthList: false, SVGAnimatedNumber: false, SVGAnimatedNumberList: false, SVGAnimatedPreserveAspectRatio: false, SVGAnimatedRect: false, SVGAnimatedString: false, SVGAnimatedTransformList: false, SVGAnimateElement: false, SVGAnimateMotionElement: false, SVGAnimateTransformElement: false, SVGAnimationElement: false, SVGCircleElement: false, SVGClipPathElement: false, SVGComponentTransferFunctionElement: false, SVGDefsElement: false, SVGDescElement: false, SVGDiscardElement: false, SVGElement: false, SVGEllipseElement: false, SVGFEBlendElement: false, SVGFEColorMatrixElement: false, SVGFEComponentTransferElement: false, SVGFECompositeElement: false, SVGFEConvolveMatrixElement: false, SVGFEDiffuseLightingElement: false, SVGFEDisplacementMapElement: false, SVGFEDistantLightElement: false, SVGFEDropShadowElement: false, SVGFEFloodElement: false, SVGFEFuncAElement: false, SVGFEFuncBElement: false, SVGFEFuncGElement: false, SVGFEFuncRElement: false, SVGFEGaussianBlurElement: false, SVGFEImageElement: false, SVGFEMergeElement: false, SVGFEMergeNodeElement: false, SVGFEMorphologyElement: false, SVGFEOffsetElement: false, SVGFEPointLightElement: false, SVGFESpecularLightingElement: false, SVGFESpotLightElement: false, SVGFETileElement: false, SVGFETurbulenceElement: false, SVGFilterElement: false, SVGForeignObjectElement: false, SVGGElement: false, SVGGeometryElement: false, SVGGradientElement: false, SVGGraphicsElement: false, SVGImageElement: false, SVGLength: false, SVGLengthList: false, SVGLinearGradientElement: false, SVGLineElement: false, SVGMarkerElement: false, SVGMaskElement: false, SVGMatrix: false, SVGMetadataElement: false, SVGMPathElement: false, SVGNumber: false, SVGNumberList: false, SVGPathElement: false, SVGPatternElement: false, SVGPoint: false, SVGPointList: false, SVGPolygonElement: false, SVGPolylineElement: false, SVGPreserveAspectRatio: false, SVGRadialGradientElement: false, SVGRect: false, SVGRectElement: false, SVGScriptElement: false, SVGSetElement: false, SVGStopElement: false, SVGStringList: false, SVGStyleElement: false, SVGSVGElement: false, SVGSwitchElement: false, SVGSymbolElement: false, SVGTextContentElement: false, SVGTextElement: false, SVGTextPathElement: false, SVGTextPositioningElement: false, SVGTitleElement: false, SVGTransform: false, SVGTransformList: false, SVGTSpanElement: false, SVGUnitTypes: false, SVGUseElement: false, SVGViewElement: false, TaskAttributionTiming: false, Text: false, TextDecoder: false, TextEncoder: false, TextEvent: false, TextMetrics: false, TextTrack: false, TextTrackCue: false, TextTrackCueList: false, TextTrackList: false, TimeRanges: false, toolbar: false, top: false, Touch: false, TouchEvent: false, TouchList: false, TrackEvent: false, TransitionEvent: false, TreeWalker: false, UIEvent: false, URL: false, URLSearchParams: false, ValidityState: false, visualViewport: false, VisualViewport: false, VTTCue: false, WaveShaperNode: false, WebAssembly: false, WebGL2RenderingContext: false, WebGLActiveInfo: false, WebGLBuffer: false, WebGLContextEvent: false, WebGLFramebuffer: false, WebGLProgram: false, WebGLQuery: false, WebGLRenderbuffer: false, WebGLRenderingContext: false, WebGLSampler: false, WebGLShader: false, WebGLShaderPrecisionFormat: false, WebGLSync: false, WebGLTexture: false, WebGLTransformFeedback: false, WebGLUniformLocation: false, WebGLVertexArrayObject: false, WebSocket: false, WheelEvent: false, window: false, Window: false, Worker: false, WritableStream: false, XMLDocument: false, XMLHttpRequest: false, XMLHttpRequestEventTarget: false, XMLHttpRequestUpload: false, XMLSerializer: false, XPathEvaluator: false, XPathExpression: false, XPathResult: false, XSLTProcessor: false};
          var worker = {addEventListener: false, applicationCache: false, atob: false, Blob: false, BroadcastChannel: false, btoa: false, Cache: false, caches: false, clearInterval: false, clearTimeout: false, close: true, console: false, fetch: false, FileReaderSync: false, FormData: false, Headers: false, IDBCursor: false, IDBCursorWithValue: false, IDBDatabase: false, IDBFactory: false, IDBIndex: false, IDBKeyRange: false, IDBObjectStore: false, IDBOpenDBRequest: false, IDBRequest: false, IDBTransaction: false, IDBVersionChangeEvent: false, ImageData: false, importScripts: true, indexedDB: false, location: false, MessageChannel: false, MessagePort: false, name: false, navigator: false, Notification: false, onclose: true, onconnect: true, onerror: true, onlanguagechange: true, onmessage: true, onoffline: true, ononline: true, onrejectionhandled: true, onunhandledrejection: true, performance: false, Performance: false, PerformanceEntry: false, PerformanceMark: false, PerformanceMeasure: false, PerformanceNavigation: false, PerformanceResourceTiming: false, PerformanceTiming: false, postMessage: true, "Promise": false, queueMicrotask: false, removeEventListener: false, Request: false, Response: false, self: true, ServiceWorkerRegistration: false, setInterval: false, setTimeout: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false, WebSocket: false, Worker: false, WorkerGlobalScope: false, XMLHttpRequest: false};
          var node = {__dirname: false, __filename: false, AbortController: false, Buffer: false, clearImmediate: false, clearInterval: false, clearTimeout: false, console: false, exports: true, global: false, "Intl": false, module: false, process: false, queueMicrotask: false, require: false, setImmediate: false, setInterval: false, setTimeout: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false};
          var nodeBuiltin = {AbortController: false, Buffer: false, clearImmediate: false, clearInterval: false, clearTimeout: false, console: false, global: false, "Intl": false, process: false, queueMicrotask: false, setImmediate: false, setInterval: false, setTimeout: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false};
          var commonjs = {exports: true, global: false, module: false, require: false};
          var amd = {define: false, require: false};
          var mocha = {after: false, afterEach: false, before: false, beforeEach: false, context: false, describe: false, it: false, mocha: false, run: false, setup: false, specify: false, suite: false, suiteSetup: false, suiteTeardown: false, teardown: false, test: false, xcontext: false, xdescribe: false, xit: false, xspecify: false};
          var jasmine = {afterAll: false, afterEach: false, beforeAll: false, beforeEach: false, describe: false, expect: false, expectAsync: false, fail: false, fdescribe: false, fit: false, it: false, jasmine: false, pending: false, runs: false, spyOn: false, spyOnAllFunctions: false, spyOnProperty: false, waits: false, waitsFor: false, xdescribe: false, xit: false};
          var jest = {afterAll: false, afterEach: false, beforeAll: false, beforeEach: false, describe: false, expect: false, fdescribe: false, fit: false, it: false, jest: false, pit: false, require: false, test: false, xdescribe: false, xit: false, xtest: false};
          var qunit = {asyncTest: false, deepEqual: false, equal: false, expect: false, module: false, notDeepEqual: false, notEqual: false, notOk: false, notPropEqual: false, notStrictEqual: false, ok: false, propEqual: false, QUnit: false, raises: false, start: false, stop: false, strictEqual: false, test: false, throws: false};
          var phantomjs = {console: true, exports: true, phantom: true, require: true, WebPage: true};
          var couch = {emit: false, exports: false, getRow: false, log: false, module: false, provides: false, require: false, respond: false, send: false, start: false, sum: false};
          var rhino = {defineClass: false, deserialize: false, gc: false, help: false, importClass: false, importPackage: false, java: false, load: false, loadClass: false, Packages: false, print: false, quit: false, readFile: false, readUrl: false, runCommand: false, seal: false, serialize: false, spawn: false, sync: false, toint32: false, version: false};
          var nashorn = {__DIR__: false, __FILE__: false, __LINE__: false, com: false, edu: false, exit: false, java: false, Java: false, javafx: false, JavaImporter: false, javax: false, JSAdapter: false, load: false, loadWithNewGlobal: false, org: false, Packages: false, print: false, quit: false};
          var wsh = {ActiveXObject: false, CollectGarbage: false, Debug: false, Enumerator: false, GetObject: false, RuntimeObject: false, ScriptEngine: false, ScriptEngineBuildVersion: false, ScriptEngineMajorVersion: false, ScriptEngineMinorVersion: false, VBArray: false, WScript: false, WSH: false};
          var jquery = {$: false, jQuery: false};
          var yui = {YAHOO: false, YAHOO_config: false, YUI: false, YUI_config: false};
          var shelljs = {cat: false, cd: false, chmod: false, config: false, cp: false, dirs: false, echo: false, env: false, error: false, exec: false, exit: false, find: false, grep: false, ln: false, ls: false, mkdir: false, mv: false, popd: false, pushd: false, pwd: false, rm: false, sed: false, set: false, target: false, tempdir: false, test: false, touch: false, which: false};
          var prototypejs = {$: false, $$: false, $A: false, $break: false, $continue: false, $F: false, $H: false, $R: false, $w: false, Abstract: false, Ajax: false, Autocompleter: false, Builder: false, Class: false, Control: false, Draggable: false, Draggables: false, Droppables: false, Effect: false, Element: false, Enumerable: false, Event: false, Field: false, Form: false, Hash: false, Insertion: false, ObjectRange: false, PeriodicalExecuter: false, Position: false, Prototype: false, Scriptaculous: false, Selector: false, Sortable: false, SortableObserver: false, Sound: false, Template: false, Toggle: false, Try: false};
          var meteor = {$: false, Accounts: false, AccountsClient: false, AccountsCommon: false, AccountsServer: false, App: false, Assets: false, Blaze: false, check: false, Cordova: false, DDP: false, DDPRateLimiter: false, DDPServer: false, Deps: false, EJSON: false, Email: false, HTTP: false, Log: false, Match: false, Meteor: false, Mongo: false, MongoInternals: false, Npm: false, Package: false, Plugin: false, process: false, Random: false, ReactiveDict: false, ReactiveVar: false, Router: false, ServiceConfiguration: false, Session: false, share: false, Spacebars: false, Template: false, Tinytest: false, Tracker: false, UI: false, Utils: false, WebApp: false, WebAppInternals: false};
          var mongo = {_isWindows: false, _rand: false, BulkWriteResult: false, cat: false, cd: false, connect: false, db: false, getHostName: false, getMemInfo: false, hostname: false, ISODate: false, listFiles: false, load: false, ls: false, md5sumFile: false, mkdir: false, Mongo: false, NumberInt: false, NumberLong: false, ObjectId: false, PlanCache: false, print: false, printjson: false, pwd: false, quit: false, removeFile: false, rs: false, sh: false, UUID: false, version: false, WriteResult: false};
          var applescript = {$: false, Application: false, Automation: false, console: false, delay: false, Library: false, ObjC: false, ObjectSpecifier: false, Path: false, Progress: false, Ref: false};
          var serviceworker = {addEventListener: false, applicationCache: false, atob: false, Blob: false, BroadcastChannel: false, btoa: false, Cache: false, caches: false, CacheStorage: false, clearInterval: false, clearTimeout: false, Client: false, clients: false, Clients: false, close: true, console: false, ExtendableEvent: false, ExtendableMessageEvent: false, fetch: false, FetchEvent: false, FileReaderSync: false, FormData: false, Headers: false, IDBCursor: false, IDBCursorWithValue: false, IDBDatabase: false, IDBFactory: false, IDBIndex: false, IDBKeyRange: false, IDBObjectStore: false, IDBOpenDBRequest: false, IDBRequest: false, IDBTransaction: false, IDBVersionChangeEvent: false, ImageData: false, importScripts: false, indexedDB: false, location: false, MessageChannel: false, MessagePort: false, name: false, navigator: false, Notification: false, onclose: true, onconnect: true, onerror: true, onfetch: true, oninstall: true, onlanguagechange: true, onmessage: true, onmessageerror: true, onnotificationclick: true, onnotificationclose: true, onoffline: true, ononline: true, onpush: true, onpushsubscriptionchange: true, onrejectionhandled: true, onsync: true, onunhandledrejection: true, performance: false, Performance: false, PerformanceEntry: false, PerformanceMark: false, PerformanceMeasure: false, PerformanceNavigation: false, PerformanceResourceTiming: false, PerformanceTiming: false, postMessage: true, "Promise": false, queueMicrotask: false, registration: false, removeEventListener: false, Request: false, Response: false, self: false, ServiceWorker: false, ServiceWorkerContainer: false, ServiceWorkerGlobalScope: false, ServiceWorkerMessageEvent: false, ServiceWorkerRegistration: false, setInterval: false, setTimeout: false, skipWaiting: false, TextDecoder: false, TextEncoder: false, URL: false, URLSearchParams: false, WebSocket: false, WindowClient: false, Worker: false, WorkerGlobalScope: false, XMLHttpRequest: false};
          var atomtest = {advanceClock: false, atom: false, fakeClearInterval: false, fakeClearTimeout: false, fakeSetInterval: false, fakeSetTimeout: false, resetTimeouts: false, waitsForPromise: false};
          var embertest = {andThen: false, click: false, currentPath: false, currentRouteName: false, currentURL: false, fillIn: false, find: false, findAll: false, findWithAssert: false, keyEvent: false, pauseTest: false, resumeTest: false, triggerEvent: false, visit: false, wait: false};
          var protractor = {$: false, $$: false, browser: false, by: false, By: false, DartObject: false, element: false, protractor: false};
          var webextensions = {browser: false, chrome: false, opr: false};
          var greasemonkey = {cloneInto: false, createObjectIn: false, exportFunction: false, GM: false, GM_addStyle: false, GM_addValueChangeListener: false, GM_deleteValue: false, GM_download: false, GM_getResourceText: false, GM_getResourceURL: false, GM_getTab: false, GM_getTabs: false, GM_getValue: false, GM_info: false, GM_listValues: false, GM_log: false, GM_notification: false, GM_openInTab: false, GM_registerMenuCommand: false, GM_removeValueChangeListener: false, GM_saveTab: false, GM_setClipboard: false, GM_setValue: false, GM_unregisterMenuCommand: false, GM_xmlhttpRequest: false, unsafeWindow: false};
          var devtools = {$: false, $_: false, $$: false, $0: false, $1: false, $2: false, $3: false, $4: false, $x: false, chrome: false, clear: false, copy: false, debug: false, dir: false, dirxml: false, getEventListeners: false, inspect: false, keys: false, monitor: false, monitorEvents: false, profile: false, profileEnd: false, queryObjects: false, table: false, undebug: false, unmonitor: false, unmonitorEvents: false, values: false};
          var require$$03 = {builtin, es5, es2015, es2017, es2020, es2021, browser, worker, node, nodeBuiltin, commonjs, amd, mocha, jasmine, jest, qunit, phantomjs, couch, rhino, nashorn, wsh, jquery, yui, shelljs, prototypejs, meteor, mongo, applescript, serviceworker, atomtest, embertest, protractor, "shared-node-browser": {clearInterval: false, clearTimeout: false, console: false, setInterval: false, setTimeout: false, URL: false, URLSearchParams: false}, webextensions, greasemonkey, devtools};
          var globals2 = require$$03;
          const browserAPIs = ["window", "document", "console"];
          const builtinAPIs = Object.keys(globals2.builtin);
          const isIdentifier = (n2) => namedTypes.Identifier.check(n2);
          const isLiteral = (n2) => namedTypes.Literal.check(n2);
          const isExpressionStatement = (n2) => namedTypes.ExpressionStatement.check(n2);
          const isThisExpression = (n2) => namedTypes.ThisExpression.check(n2);
          const isThisExpressionStatement = (n2) => isExpressionStatement(n2) && isMemberExpression(n2.expression.left) && isThisExpression(n2.expression.left.object);
          const isNewExpression = (n2) => namedTypes.NewExpression.check(n2);
          const isSequenceExpression = (n2) => namedTypes.SequenceExpression.check(n2);
          const isExportDefaultStatement = (n2) => namedTypes.ExportDefaultDeclaration.check(n2);
          const isMemberExpression = (n2) => namedTypes.MemberExpression.check(n2);
          const isImportDeclaration = (n2) => namedTypes.ImportDeclaration.check(n2);
          const isBrowserAPI = (_ref) => {
            let {name: name2} = _ref;
            return browserAPIs.includes(name2);
          };
          const isBuiltinAPI = (_ref2) => {
            let {name: name2} = _ref2;
            return builtinAPIs.includes(name2);
          };
          const isRaw = (n2) => n2 && n2.raw;
          const LINES_RE = /\r\n?|\n/g;
          function splitStringByEOL(string) {
            return string.split(LINES_RE);
          }
          function getLineAndColumnByPosition(string, position) {
            const lines2 = splitStringByEOL(string.slice(0, position));
            return {line: lines2.length, column: lines2[lines2.length - 1].length};
          }
          function addLineOffset(input, source, node2) {
            const {column, line} = getLineAndColumnByPosition(source, node2.start);
            return `${"\n".repeat(line - 1)}${" ".repeat(column + 1)}${input}`;
          }
          function getBabelOptions(options2) {
            return {sourceType: util$2.getOption(options2, "sourceType", "module"), strictMode: util$2.getOption(options2, "strictMode", false), allowImportExportEverywhere: true, allowReturnOutsideFunction: true, startLine: 1, tokens: true, plugins: ["asyncGenerators", "bigInt", "classPrivateMethods", "classPrivateProperties", "classProperties", "decorators-legacy", "doExpressions", "dynamicImport", "exportDefaultFrom", "exportExtensions", "exportNamespaceFrom", "functionBind", "functionSent", "importMeta", "nullishCoalescingOperator", "numericSeparator", "objectRestSpread", "optionalCatchBinding", "optionalChaining", ["pipelineOperator", {proposal: "minimal"}], "throwExpressions"]};
          }
          var _default = getBabelOptions;
          var _babel_options = /* @__PURE__ */ Object.defineProperty({default: _default}, "__esModule", {value: true});
          const beforeExpr = true;
          const startsExpr = true;
          const isLoop = true;
          const isAssign = true;
          const prefix = true;
          const postfix = true;
          class TokenType {
            constructor(label, conf) {
              if (conf === void 0) {
                conf = {};
              }
              this.label = void 0;
              this.keyword = void 0;
              this.beforeExpr = void 0;
              this.startsExpr = void 0;
              this.rightAssociative = void 0;
              this.isLoop = void 0;
              this.isAssign = void 0;
              this.prefix = void 0;
              this.postfix = void 0;
              this.binop = void 0;
              this.updateContext = void 0;
              this.label = label;
              this.keyword = conf.keyword;
              this.beforeExpr = !!conf.beforeExpr;
              this.startsExpr = !!conf.startsExpr;
              this.rightAssociative = !!conf.rightAssociative;
              this.isLoop = !!conf.isLoop;
              this.isAssign = !!conf.isAssign;
              this.prefix = !!conf.prefix;
              this.postfix = !!conf.postfix;
              this.binop = conf.binop != null ? conf.binop : null;
              this.updateContext = null;
            }
          }
          const keywords = new Map();
          function createKeyword(name2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            options2.keyword = name2;
            const token = new TokenType(name2, options2);
            keywords.set(name2, token);
            return token;
          }
          function createBinop(name2, binop) {
            return new TokenType(name2, {beforeExpr, binop});
          }
          const types$1 = {num: new TokenType("num", {startsExpr}), bigint: new TokenType("bigint", {startsExpr}), decimal: new TokenType("decimal", {startsExpr}), regexp: new TokenType("regexp", {startsExpr}), string: new TokenType("string", {startsExpr}), name: new TokenType("name", {startsExpr}), eof: new TokenType("eof"), bracketL: new TokenType("[", {beforeExpr, startsExpr}), bracketHashL: new TokenType("#[", {beforeExpr, startsExpr}), bracketBarL: new TokenType("[|", {beforeExpr, startsExpr}), bracketR: new TokenType("]"), bracketBarR: new TokenType("|]"), braceL: new TokenType("{", {beforeExpr, startsExpr}), braceBarL: new TokenType("{|", {beforeExpr, startsExpr}), braceHashL: new TokenType("#{", {beforeExpr, startsExpr}), braceR: new TokenType("}"), braceBarR: new TokenType("|}"), parenL: new TokenType("(", {beforeExpr, startsExpr}), parenR: new TokenType(")"), comma: new TokenType(",", {beforeExpr}), semi: new TokenType(";", {beforeExpr}), colon: new TokenType(":", {beforeExpr}), doubleColon: new TokenType("::", {beforeExpr}), dot: new TokenType("."), question: new TokenType("?", {beforeExpr}), questionDot: new TokenType("?."), arrow: new TokenType("=>", {beforeExpr}), template: new TokenType("template"), ellipsis: new TokenType("...", {beforeExpr}), backQuote: new TokenType("`", {startsExpr}), dollarBraceL: new TokenType("${", {beforeExpr, startsExpr}), at: new TokenType("@"), hash: new TokenType("#", {startsExpr}), interpreterDirective: new TokenType("#!..."), eq: new TokenType("=", {beforeExpr, isAssign}), assign: new TokenType("_=", {beforeExpr, isAssign}), incDec: new TokenType("++/--", {prefix, postfix, startsExpr}), bang: new TokenType("!", {beforeExpr, prefix, startsExpr}), tilde: new TokenType("~", {beforeExpr, prefix, startsExpr}), pipeline: createBinop("|>", 0), nullishCoalescing: createBinop("??", 1), logicalOR: createBinop("||", 1), logicalAND: createBinop("&&", 2), bitwiseOR: createBinop("|", 3), bitwiseXOR: createBinop("^", 4), bitwiseAND: createBinop("&", 5), equality: createBinop("==/!=/===/!==", 6), relational: createBinop("</>/<=/>=", 7), bitShift: createBinop("<</>>/>>>", 8), plusMin: new TokenType("+/-", {beforeExpr, binop: 9, prefix, startsExpr}), modulo: new TokenType("%", {beforeExpr, binop: 10, startsExpr}), star: new TokenType("*", {binop: 10}), slash: createBinop("/", 10), exponent: new TokenType("**", {beforeExpr, binop: 11, rightAssociative: true}), _break: createKeyword("break"), _case: createKeyword("case", {beforeExpr}), _catch: createKeyword("catch"), _continue: createKeyword("continue"), _debugger: createKeyword("debugger"), _default: createKeyword("default", {beforeExpr}), _do: createKeyword("do", {isLoop, beforeExpr}), _else: createKeyword("else", {beforeExpr}), _finally: createKeyword("finally"), _for: createKeyword("for", {isLoop}), _function: createKeyword("function", {startsExpr}), _if: createKeyword("if"), _return: createKeyword("return", {beforeExpr}), _switch: createKeyword("switch"), _throw: createKeyword("throw", {beforeExpr, prefix, startsExpr}), _try: createKeyword("try"), _var: createKeyword("var"), _const: createKeyword("const"), _while: createKeyword("while", {isLoop}), _with: createKeyword("with"), _new: createKeyword("new", {beforeExpr, startsExpr}), _this: createKeyword("this", {startsExpr}), _super: createKeyword("super", {startsExpr}), _class: createKeyword("class", {startsExpr}), _extends: createKeyword("extends", {beforeExpr}), _export: createKeyword("export"), _import: createKeyword("import", {startsExpr}), _null: createKeyword("null", {startsExpr}), _true: createKeyword("true", {startsExpr}), _false: createKeyword("false", {startsExpr}), _in: createKeyword("in", {beforeExpr, binop: 7}), _instanceof: createKeyword("instanceof", {beforeExpr, binop: 7}), _typeof: createKeyword("typeof", {beforeExpr, prefix, startsExpr}), _void: createKeyword("void", {beforeExpr, prefix, startsExpr}), _delete: createKeyword("delete", {beforeExpr, prefix, startsExpr})};
          const lineBreak = /\r\n?|[\n\u2028\u2029]/;
          const lineBreakG = new RegExp(lineBreak.source, "g");
          function isNewLine(code) {
            switch (code) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return true;
              default:
                return false;
            }
          }
          const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
          function isWhitespace(code) {
            switch (code) {
              case 9:
              case 11:
              case 12:
              case 32:
              case 160:
              case 5760:
              case 8192:
              case 8193:
              case 8194:
              case 8195:
              case 8196:
              case 8197:
              case 8198:
              case 8199:
              case 8200:
              case 8201:
              case 8202:
              case 8239:
              case 8287:
              case 12288:
              case 65279:
                return true;
              default:
                return false;
            }
          }
          class Position {
            constructor(line, col) {
              this.line = void 0;
              this.column = void 0;
              this.line = line;
              this.column = col;
            }
          }
          class SourceLocation {
            constructor(start, end) {
              this.start = void 0;
              this.end = void 0;
              this.filename = void 0;
              this.identifierName = void 0;
              this.start = start;
              this.end = end;
            }
          }
          function getLineInfo(input, offset) {
            let line = 1;
            let lineStart = 0;
            let match;
            lineBreakG.lastIndex = 0;
            while ((match = lineBreakG.exec(input)) && match.index < offset) {
              line++;
              lineStart = lineBreakG.lastIndex;
            }
            return new Position(line, offset - lineStart);
          }
          class BaseParser {
            constructor() {
              this.sawUnambiguousESM = false;
              this.ambiguousScriptDifferentAst = false;
            }
            hasPlugin(name2) {
              return this.plugins.has(name2);
            }
            getPluginOption(plugin, name2) {
              if (this.hasPlugin(plugin))
                return this.plugins.get(plugin)[name2];
            }
          }
          function last(stack) {
            return stack[stack.length - 1];
          }
          class CommentsParser extends BaseParser {
            addComment(comment2) {
              if (this.filename)
                comment2.loc.filename = this.filename;
              this.state.trailingComments.push(comment2);
              this.state.leadingComments.push(comment2);
            }
            adjustCommentsAfterTrailingComma(node2, elements, takeAllComments) {
              if (this.state.leadingComments.length === 0) {
                return;
              }
              let lastElement = null;
              let i = elements.length;
              while (lastElement === null && i > 0) {
                lastElement = elements[--i];
              }
              if (lastElement === null) {
                return;
              }
              for (let j = 0; j < this.state.leadingComments.length; j++) {
                if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                  this.state.leadingComments.splice(j, 1);
                  j--;
                }
              }
              const newTrailingComments = [];
              for (let i2 = 0; i2 < this.state.leadingComments.length; i2++) {
                const leadingComment = this.state.leadingComments[i2];
                if (leadingComment.end < node2.end) {
                  newTrailingComments.push(leadingComment);
                  if (!takeAllComments) {
                    this.state.leadingComments.splice(i2, 1);
                    i2--;
                  }
                } else {
                  if (node2.trailingComments === void 0) {
                    node2.trailingComments = [];
                  }
                  node2.trailingComments.push(leadingComment);
                }
              }
              if (takeAllComments)
                this.state.leadingComments = [];
              if (newTrailingComments.length > 0) {
                lastElement.trailingComments = newTrailingComments;
              } else if (lastElement.trailingComments !== void 0) {
                lastElement.trailingComments = [];
              }
            }
            processComment(node2) {
              if (node2.type === "Program" && node2.body.length > 0)
                return;
              const stack = this.state.commentStack;
              let firstChild, lastChild, trailingComments, i, j;
              if (this.state.trailingComments.length > 0) {
                if (this.state.trailingComments[0].start >= node2.end) {
                  trailingComments = this.state.trailingComments;
                  this.state.trailingComments = [];
                } else {
                  this.state.trailingComments.length = 0;
                }
              } else if (stack.length > 0) {
                const lastInStack = last(stack);
                if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node2.end) {
                  trailingComments = lastInStack.trailingComments;
                  delete lastInStack.trailingComments;
                }
              }
              if (stack.length > 0 && last(stack).start >= node2.start) {
                firstChild = stack.pop();
              }
              while (stack.length > 0 && last(stack).start >= node2.start) {
                lastChild = stack.pop();
              }
              if (!lastChild && firstChild)
                lastChild = firstChild;
              if (firstChild) {
                switch (node2.type) {
                  case "ObjectExpression":
                    this.adjustCommentsAfterTrailingComma(node2, node2.properties);
                    break;
                  case "ObjectPattern":
                    this.adjustCommentsAfterTrailingComma(node2, node2.properties, true);
                    break;
                  case "CallExpression":
                    this.adjustCommentsAfterTrailingComma(node2, node2.arguments);
                    break;
                  case "ArrayExpression":
                    this.adjustCommentsAfterTrailingComma(node2, node2.elements);
                    break;
                  case "ArrayPattern":
                    this.adjustCommentsAfterTrailingComma(node2, node2.elements, true);
                    break;
                }
              } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node2.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node2.type !== "ExportSpecifier")) {
                this.adjustCommentsAfterTrailingComma(node2, [this.state.commentPreviousNode]);
              }
              if (lastChild) {
                if (lastChild.leadingComments) {
                  if (lastChild !== node2 && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node2.start) {
                    node2.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                  } else {
                    for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
                      if (lastChild.leadingComments[i].end <= node2.start) {
                        node2.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                        break;
                      }
                    }
                  }
                }
              } else if (this.state.leadingComments.length > 0) {
                if (last(this.state.leadingComments).end <= node2.start) {
                  if (this.state.commentPreviousNode) {
                    for (j = 0; j < this.state.leadingComments.length; j++) {
                      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                        this.state.leadingComments.splice(j, 1);
                        j--;
                      }
                    }
                  }
                  if (this.state.leadingComments.length > 0) {
                    node2.leadingComments = this.state.leadingComments;
                    this.state.leadingComments = [];
                  }
                } else {
                  for (i = 0; i < this.state.leadingComments.length; i++) {
                    if (this.state.leadingComments[i].end > node2.start) {
                      break;
                    }
                  }
                  const leadingComments = this.state.leadingComments.slice(0, i);
                  if (leadingComments.length) {
                    node2.leadingComments = leadingComments;
                  }
                  trailingComments = this.state.leadingComments.slice(i);
                  if (trailingComments.length === 0) {
                    trailingComments = null;
                  }
                }
              }
              this.state.commentPreviousNode = node2;
              if (trailingComments) {
                if (trailingComments.length && trailingComments[0].start >= node2.start && last(trailingComments).end <= node2.end) {
                  node2.innerComments = trailingComments;
                } else {
                  const firstTrailingCommentIndex = trailingComments.findIndex((comment2) => comment2.end >= node2.end);
                  if (firstTrailingCommentIndex > 0) {
                    node2.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);
                    node2.trailingComments = trailingComments.slice(firstTrailingCommentIndex);
                  } else {
                    node2.trailingComments = trailingComments;
                  }
                }
              }
              stack.push(node2);
            }
          }
          const ErrorCodes = Object.freeze({SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"});
          const ErrorMessages = makeErrorTemplates({AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.", PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."}, ErrorCodes.SyntaxError);
          const SourceTypeModuleErrorMessages = makeErrorTemplates({ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`}, ErrorCodes.SourceTypeModuleError);
          function makeErrorTemplates(messages, code) {
            const templates = {};
            Object.keys(messages).forEach((reasonCode) => {
              templates[reasonCode] = Object.freeze({code, reasonCode, template: messages[reasonCode]});
            });
            return Object.freeze(templates);
          }
          class ParserError extends CommentsParser {
            getLocationForPosition(pos) {
              let loc;
              if (pos === this.state.start)
                loc = this.state.startLoc;
              else if (pos === this.state.lastTokStart)
                loc = this.state.lastTokStartLoc;
              else if (pos === this.state.end)
                loc = this.state.endLoc;
              else if (pos === this.state.lastTokEnd)
                loc = this.state.lastTokEndLoc;
              else
                loc = getLineInfo(this.input, pos);
              return loc;
            }
            raise(pos, _ref3) {
              let {code, reasonCode, template: template2} = _ref3;
              for (var _len4 = arguments.length, params = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
                params[_key4 - 2] = arguments[_key4];
              }
              return this.raiseWithData(pos, {code, reasonCode}, template2, ...params);
            }
            raiseOverwrite(pos, _ref4) {
              let {code, template: template2} = _ref4;
              for (var _len5 = arguments.length, params = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
                params[_key5 - 2] = arguments[_key5];
              }
              const loc = this.getLocationForPosition(pos);
              const message = template2.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
              if (this.options.errorRecovery) {
                const errors = this.state.errors;
                for (let i = errors.length - 1; i >= 0; i--) {
                  const error = errors[i];
                  if (error.pos === pos) {
                    return Object.assign(error, {message});
                  } else if (error.pos < pos) {
                    break;
                  }
                }
              }
              return this._raise({code, loc, pos}, message);
            }
            raiseWithData(pos, data, errorTemplate) {
              for (var _len6 = arguments.length, params = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {
                params[_key6 - 3] = arguments[_key6];
              }
              const loc = this.getLocationForPosition(pos);
              const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
              return this._raise(Object.assign({loc, pos}, data), message);
            }
            _raise(errorContext, message) {
              const err = new SyntaxError(message);
              Object.assign(err, errorContext);
              if (this.options.errorRecovery) {
                if (!this.isLookahead)
                  this.state.errors.push(err);
                return err;
              } else {
                throw err;
              }
            }
          }
          var estree = (superClass) => class extends superClass {
            estreeParseRegExpLiteral(_ref5) {
              let {pattern, flags} = _ref5;
              let regex2 = null;
              try {
                regex2 = new RegExp(pattern, flags);
              } catch (e) {
              }
              const node2 = this.estreeParseLiteral(regex2);
              node2.regex = {pattern, flags};
              return node2;
            }
            estreeParseBigIntLiteral(value) {
              let bigInt;
              try {
                bigInt = BigInt(value);
              } catch (_unused) {
                bigInt = null;
              }
              const node2 = this.estreeParseLiteral(bigInt);
              node2.bigint = String(node2.value || value);
              return node2;
            }
            estreeParseDecimalLiteral(value) {
              const decimal = null;
              const node2 = this.estreeParseLiteral(decimal);
              node2.decimal = String(node2.value || value);
              return node2;
            }
            estreeParseLiteral(value) {
              return this.parseLiteral(value, "Literal");
            }
            directiveToStmt(directive) {
              const directiveLiteral = directive.value;
              const stmt = this.startNodeAt(directive.start, directive.loc.start);
              const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
              expression.value = directiveLiteral.extra.expressionValue;
              expression.raw = directiveLiteral.extra.raw;
              stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
              stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
              return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
            }
            initFunction(node2, isAsync) {
              super.initFunction(node2, isAsync);
              node2.expression = false;
            }
            checkDeclaration(node2) {
              if (node2 != null && this.isObjectProperty(node2)) {
                this.checkDeclaration(node2.value);
              } else {
                super.checkDeclaration(node2);
              }
            }
            getObjectOrClassMethodParams(method) {
              return method.value.params;
            }
            isValidDirective(stmt) {
              var _stmt$expression$extr;
              return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
            }
            stmtToDirective(stmt) {
              const directive = super.stmtToDirective(stmt);
              const value = stmt.expression.value;
              this.addExtra(directive.value, "expressionValue", value);
              return directive;
            }
            parseBlockBody(node2) {
              for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
                args[_key7 - 1] = arguments[_key7];
              }
              super.parseBlockBody(node2, ...args);
              const directiveStatements = node2.directives.map((d) => this.directiveToStmt(d));
              node2.body = directiveStatements.concat(node2.body);
              delete node2.directives;
            }
            pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
              this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
              if (method.typeParameters) {
                method.value.typeParameters = method.typeParameters;
                delete method.typeParameters;
              }
              classBody.body.push(method);
            }
            parseExprAtom(refExpressionErrors) {
              switch (this.state.type) {
                case types$1.num:
                case types$1.string:
                  return this.estreeParseLiteral(this.state.value);
                case types$1.regexp:
                  return this.estreeParseRegExpLiteral(this.state.value);
                case types$1.bigint:
                  return this.estreeParseBigIntLiteral(this.state.value);
                case types$1.decimal:
                  return this.estreeParseDecimalLiteral(this.state.value);
                case types$1._null:
                  return this.estreeParseLiteral(null);
                case types$1._true:
                  return this.estreeParseLiteral(true);
                case types$1._false:
                  return this.estreeParseLiteral(false);
                default:
                  return super.parseExprAtom(refExpressionErrors);
              }
            }
            parseMaybePrivateName() {
              const node2 = super.parseMaybePrivateName(...arguments);
              if (node2.type === "PrivateName" && this.getPluginOption("estree", "classFeatures")) {
                return this.convertPrivateNameToPrivateIdentifier(node2);
              }
              return node2;
            }
            convertPrivateNameToPrivateIdentifier(node2) {
              const name2 = super.getPrivateNameSV(node2);
              node2 = node2;
              delete node2.id;
              node2.name = name2;
              node2.type = "PrivateIdentifier";
              return node2;
            }
            isPrivateName(node2) {
              if (!this.getPluginOption("estree", "classFeatures")) {
                return super.isPrivateName(node2);
              }
              return node2.type === "PrivateIdentifier";
            }
            getPrivateNameSV(node2) {
              if (!this.getPluginOption("estree", "classFeatures")) {
                return super.getPrivateNameSV(node2);
              }
              return node2.name;
            }
            parseLiteral(value, type2, startPos, startLoc) {
              const node2 = super.parseLiteral(value, type2, startPos, startLoc);
              node2.raw = node2.extra.raw;
              delete node2.extra;
              return node2;
            }
            parseFunctionBody(node2, allowExpression, isMethod) {
              if (isMethod === void 0) {
                isMethod = false;
              }
              super.parseFunctionBody(node2, allowExpression, isMethod);
              node2.expression = node2.body.type !== "BlockStatement";
            }
            parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope) {
              if (inClassScope === void 0) {
                inClassScope = false;
              }
              let funcNode = this.startNode();
              funcNode.kind = node2.kind;
              funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope);
              funcNode.type = "FunctionExpression";
              delete funcNode.kind;
              node2.value = funcNode;
              if (type2 === "ClassPrivateMethod") {
                node2.computed = false;
              }
              type2 = "MethodDefinition";
              return this.finishNode(node2, type2);
            }
            parseClassProperty() {
              const propertyNode = super.parseClassProperty(...arguments);
              if (this.getPluginOption("estree", "classFeatures")) {
                propertyNode.type = "PropertyDefinition";
              }
              return propertyNode;
            }
            parseClassPrivateProperty() {
              const propertyNode = super.parseClassPrivateProperty(...arguments);
              if (this.getPluginOption("estree", "classFeatures")) {
                propertyNode.type = "PropertyDefinition";
                propertyNode.computed = false;
              }
              return propertyNode;
            }
            parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor) {
              const node2 = super.parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor);
              if (node2) {
                node2.type = "Property";
                if (node2.kind === "method")
                  node2.kind = "init";
                node2.shorthand = false;
              }
              return node2;
            }
            parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors) {
              const node2 = super.parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors);
              if (node2) {
                node2.kind = "init";
                node2.type = "Property";
              }
              return node2;
            }
            toAssignable(node2, isLHS) {
              if (isLHS === void 0) {
                isLHS = false;
              }
              if (node2 != null && this.isObjectProperty(node2)) {
                this.toAssignable(node2.value, isLHS);
                return node2;
              }
              return super.toAssignable(node2, isLHS);
            }
            toAssignableObjectExpressionProp(prop2) {
              if (prop2.kind === "get" || prop2.kind === "set") {
                this.raise(prop2.key.start, ErrorMessages.PatternHasAccessor);
              } else if (prop2.method) {
                this.raise(prop2.key.start, ErrorMessages.PatternHasMethod);
              } else {
                for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
                  args[_key8 - 1] = arguments[_key8];
                }
                super.toAssignableObjectExpressionProp(prop2, ...args);
              }
            }
            finishCallExpression(node2, optional) {
              super.finishCallExpression(node2, optional);
              if (node2.callee.type === "Import") {
                node2.type = "ImportExpression";
                node2.source = node2.arguments[0];
                delete node2.arguments;
                delete node2.callee;
              }
              return node2;
            }
            toReferencedArguments(node2) {
              if (node2.type === "ImportExpression") {
                return;
              }
              super.toReferencedArguments(node2);
            }
            parseExport(node2) {
              super.parseExport(node2);
              switch (node2.type) {
                case "ExportAllDeclaration":
                  node2.exported = null;
                  break;
                case "ExportNamedDeclaration":
                  if (node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier") {
                    node2.type = "ExportAllDeclaration";
                    node2.exported = node2.specifiers[0].exported;
                    delete node2.specifiers;
                  }
                  break;
              }
              return node2;
            }
            parseSubscript(base, startPos, startLoc, noCalls, state) {
              const node2 = super.parseSubscript(base, startPos, startLoc, noCalls, state);
              if (state.optionalChainMember) {
                if (node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression") {
                  node2.type = node2.type.substring(8);
                }
                if (state.stop) {
                  const chain = this.startNodeAtNode(node2);
                  chain.expression = node2;
                  return this.finishNode(chain, "ChainExpression");
                }
              } else if (node2.type === "MemberExpression" || node2.type === "CallExpression") {
                node2.optional = false;
              }
              return node2;
            }
            hasPropertyAsPrivateName(node2) {
              if (node2.type === "ChainExpression") {
                node2 = node2.expression;
              }
              return super.hasPropertyAsPrivateName(node2);
            }
            isOptionalChain(node2) {
              return node2.type === "ChainExpression";
            }
            isObjectProperty(node2) {
              return node2.type === "Property" && node2.kind === "init" && !node2.method;
            }
            isObjectMethod(node2) {
              return node2.method || node2.kind === "get" || node2.kind === "set";
            }
          };
          class TokContext {
            constructor(token, isExpr, preserveSpace, override) {
              this.token = void 0;
              this.isExpr = void 0;
              this.preserveSpace = void 0;
              this.override = void 0;
              this.token = token;
              this.isExpr = !!isExpr;
              this.preserveSpace = !!preserveSpace;
              this.override = override;
            }
          }
          const types$1$1 = {braceStatement: new TokContext("{", false), braceExpression: new TokContext("{", true), recordExpression: new TokContext("#{", true), templateQuasi: new TokContext("${", false), parenStatement: new TokContext("(", false), parenExpression: new TokContext("(", true), template: new TokContext("`", true, true, (p) => p.readTmplToken()), functionExpression: new TokContext("function", true), functionStatement: new TokContext("function", false)};
          types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
            if (this.state.context.length === 1) {
              this.state.exprAllowed = true;
              return;
            }
            let out = this.state.context.pop();
            if (out === types$1$1.braceStatement && this.curContext().token === "function") {
              out = this.state.context.pop();
            }
            this.state.exprAllowed = !out.isExpr;
          };
          types$1.name.updateContext = function(prevType) {
            let allowed = false;
            if (prevType !== types$1.dot) {
              if (this.state.value === "of" && !this.state.exprAllowed && prevType !== types$1._function && prevType !== types$1._class) {
                allowed = true;
              }
            }
            this.state.exprAllowed = allowed;
            if (this.state.isIterator) {
              this.state.isIterator = false;
            }
          };
          types$1.braceL.updateContext = function(prevType) {
            this.state.context.push(this.braceIsBlock(prevType) ? types$1$1.braceStatement : types$1$1.braceExpression);
            this.state.exprAllowed = true;
          };
          types$1.dollarBraceL.updateContext = function() {
            this.state.context.push(types$1$1.templateQuasi);
            this.state.exprAllowed = true;
          };
          types$1.parenL.updateContext = function(prevType) {
            const statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
            this.state.context.push(statementParens ? types$1$1.parenStatement : types$1$1.parenExpression);
            this.state.exprAllowed = true;
          };
          types$1.incDec.updateContext = function() {
          };
          types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
            if (prevType.beforeExpr && prevType !== types$1.semi && prevType !== types$1._else && !(prevType === types$1._return && this.hasPrecedingLineBreak()) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types$1$1.b_stat)) {
              this.state.context.push(types$1$1.functionExpression);
            } else {
              this.state.context.push(types$1$1.functionStatement);
            }
            this.state.exprAllowed = false;
          };
          types$1.backQuote.updateContext = function() {
            if (this.curContext() === types$1$1.template) {
              this.state.context.pop();
            } else {
              this.state.context.push(types$1$1.template);
            }
            this.state.exprAllowed = false;
          };
          types$1.braceHashL.updateContext = function() {
            this.state.context.push(types$1$1.recordExpression);
            this.state.exprAllowed = true;
          };
          let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
          let nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
          const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
          const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
          nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
          const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
          const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
          function isInAstralSet(code, set2) {
            let pos = 65536;
            for (let i = 0, length = set2.length; i < length; i += 2) {
              pos += set2[i];
              if (pos > code)
                return false;
              pos += set2[i + 1];
              if (pos >= code)
                return true;
            }
            return false;
          }
          function isIdentifierStart(code) {
            if (code < 65)
              return code === 36;
            if (code <= 90)
              return true;
            if (code < 97)
              return code === 95;
            if (code <= 122)
              return true;
            if (code <= 65535) {
              return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
            }
            return isInAstralSet(code, astralIdentifierStartCodes);
          }
          function isIdentifierChar(code) {
            if (code < 48)
              return code === 36;
            if (code < 58)
              return true;
            if (code < 65)
              return false;
            if (code <= 90)
              return true;
            if (code < 97)
              return code === 95;
            if (code <= 122)
              return true;
            if (code <= 65535) {
              return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
            }
            return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
          }
          const reservedWords = {keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"]};
          const keywords$1 = new Set(reservedWords.keyword);
          const reservedWordsStrictSet = new Set(reservedWords.strict);
          const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
          function isReservedWord(word, inModule) {
            return inModule && word === "await" || word === "enum";
          }
          function isStrictReservedWord(word, inModule) {
            return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
          }
          function isStrictBindOnlyReservedWord(word) {
            return reservedWordsStrictBindSet.has(word);
          }
          function isStrictBindReservedWord(word, inModule) {
            return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
          }
          function isKeyword(word) {
            return keywords$1.has(word);
          }
          const keywordRelationalOperator = /^in(stanceof)?$/;
          function isIteratorStart(current, next) {
            return current === 64 && next === 64;
          }
          const SCOPE_OTHER = 0, SCOPE_PROGRAM = 1, SCOPE_FUNCTION = 2, SCOPE_ARROW = 4, SCOPE_SIMPLE_CATCH = 8, SCOPE_SUPER = 16, SCOPE_DIRECT_SUPER = 32, SCOPE_CLASS = 64, SCOPE_STATIC_BLOCK = 128, SCOPE_TS_MODULE = 256, SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
          const BIND_KIND_VALUE = 1, BIND_KIND_TYPE = 2, BIND_SCOPE_VAR = 4, BIND_SCOPE_LEXICAL = 8, BIND_SCOPE_FUNCTION = 16, BIND_FLAGS_NONE = 64, BIND_FLAGS_CLASS = 128, BIND_FLAGS_TS_ENUM = 256, BIND_FLAGS_TS_CONST_ENUM = 512, BIND_FLAGS_TS_EXPORT_ONLY = 1024, BIND_FLAGS_FLOW_DECLARE_FN = 2048;
          const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS, BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0, BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0, BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0, BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS, BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0, BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM, BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE, BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE, BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM, BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
          const CLASS_ELEMENT_FLAG_STATIC = 4, CLASS_ELEMENT_KIND_GETTER = 2, CLASS_ELEMENT_KIND_SETTER = 1, CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
          const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER, CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER, CLASS_ELEMENT_OTHER = 0;
          class Scope {
            constructor(flags) {
              this.flags = void 0;
              this.var = [];
              this.lexical = [];
              this.functions = [];
              this.flags = flags;
            }
          }
          class ScopeHandler {
            constructor(raise, inModule) {
              this.scopeStack = [];
              this.undefinedExports = new Map();
              this.undefinedPrivateNames = new Map();
              this.raise = raise;
              this.inModule = inModule;
            }
            get inFunction() {
              return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
            }
            get allowSuper() {
              return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
            }
            get allowDirectSuper() {
              return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
            }
            get inClass() {
              return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
            }
            get inStaticBlock() {
              return (this.currentThisScope().flags & SCOPE_STATIC_BLOCK) > 0;
            }
            get inNonArrowFunction() {
              return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
            }
            get treatFunctionsAsVar() {
              return this.treatFunctionsAsVarInScope(this.currentScope());
            }
            createScope(flags) {
              return new Scope(flags);
            }
            enter(flags) {
              this.scopeStack.push(this.createScope(flags));
            }
            exit() {
              this.scopeStack.pop();
            }
            treatFunctionsAsVarInScope(scope2) {
              return !!(scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_PROGRAM);
            }
            declareName(name2, bindingType, pos) {
              let scope2 = this.currentScope();
              if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
                this.checkRedeclarationInScope(scope2, name2, bindingType, pos);
                if (bindingType & BIND_SCOPE_FUNCTION) {
                  scope2.functions.push(name2);
                } else {
                  scope2.lexical.push(name2);
                }
                if (bindingType & BIND_SCOPE_LEXICAL) {
                  this.maybeExportDefined(scope2, name2);
                }
              } else if (bindingType & BIND_SCOPE_VAR) {
                for (let i = this.scopeStack.length - 1; i >= 0; --i) {
                  scope2 = this.scopeStack[i];
                  this.checkRedeclarationInScope(scope2, name2, bindingType, pos);
                  scope2.var.push(name2);
                  this.maybeExportDefined(scope2, name2);
                  if (scope2.flags & SCOPE_VAR)
                    break;
                }
              }
              if (this.inModule && scope2.flags & SCOPE_PROGRAM) {
                this.undefinedExports.delete(name2);
              }
            }
            maybeExportDefined(scope2, name2) {
              if (this.inModule && scope2.flags & SCOPE_PROGRAM) {
                this.undefinedExports.delete(name2);
              }
            }
            checkRedeclarationInScope(scope2, name2, bindingType, pos) {
              if (this.isRedeclaredInScope(scope2, name2, bindingType)) {
                this.raise(pos, ErrorMessages.VarRedeclaration, name2);
              }
            }
            isRedeclaredInScope(scope2, name2, bindingType) {
              if (!(bindingType & BIND_KIND_VALUE))
                return false;
              if (bindingType & BIND_SCOPE_LEXICAL) {
                return scope2.lexical.indexOf(name2) > -1 || scope2.functions.indexOf(name2) > -1 || scope2.var.indexOf(name2) > -1;
              }
              if (bindingType & BIND_SCOPE_FUNCTION) {
                return scope2.lexical.indexOf(name2) > -1 || !this.treatFunctionsAsVarInScope(scope2) && scope2.var.indexOf(name2) > -1;
              }
              return scope2.lexical.indexOf(name2) > -1 && !(scope2.flags & SCOPE_SIMPLE_CATCH && scope2.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope2) && scope2.functions.indexOf(name2) > -1;
            }
            checkLocalExport(id) {
              if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
                this.undefinedExports.set(id.name, id.start);
              }
            }
            currentScope() {
              return this.scopeStack[this.scopeStack.length - 1];
            }
            currentVarScope() {
              for (let i = this.scopeStack.length - 1; ; i--) {
                const scope2 = this.scopeStack[i];
                if (scope2.flags & SCOPE_VAR) {
                  return scope2;
                }
              }
            }
            currentThisScope() {
              for (let i = this.scopeStack.length - 1; ; i--) {
                const scope2 = this.scopeStack[i];
                if ((scope2.flags & SCOPE_VAR || scope2.flags & SCOPE_CLASS) && !(scope2.flags & SCOPE_ARROW)) {
                  return scope2;
                }
              }
            }
          }
          class FlowScope extends Scope {
            constructor() {
              super(...arguments);
              this.declareFunctions = [];
            }
          }
          class FlowScopeHandler extends ScopeHandler {
            createScope(flags) {
              return new FlowScope(flags);
            }
            declareName(name2, bindingType, pos) {
              const scope2 = this.currentScope();
              if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
                this.checkRedeclarationInScope(scope2, name2, bindingType, pos);
                this.maybeExportDefined(scope2, name2);
                scope2.declareFunctions.push(name2);
                return;
              }
              super.declareName(...arguments);
            }
            isRedeclaredInScope(scope2, name2, bindingType) {
              if (super.isRedeclaredInScope(...arguments))
                return true;
              if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
                return !scope2.declareFunctions.includes(name2) && (scope2.lexical.includes(name2) || scope2.functions.includes(name2));
              }
              return false;
            }
            checkLocalExport(id) {
              if (this.scopeStack[0].declareFunctions.indexOf(id.name) === -1) {
                super.checkLocalExport(id);
              }
            }
          }
          const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
          const FlowErrors = makeErrorTemplates({AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment."}, ErrorCodes.SyntaxError);
          function isEsModuleType(bodyElement) {
            return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
          }
          function hasTypeImportKind(node2) {
            return node2.importKind === "type" || node2.importKind === "typeof";
          }
          function isMaybeDefaultImport(state) {
            return (state.type === types$1.name || !!state.type.keyword) && state.value !== "from";
          }
          const exportSuggestions = {const: "declare export var", let: "declare export var", type: "export type", interface: "export interface"};
          function partition(list, test) {
            const list1 = [];
            const list2 = [];
            for (let i = 0; i < list.length; i++) {
              (test(list[i], i, list) ? list1 : list2).push(list[i]);
            }
            return [list1, list2];
          }
          const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
          var flow = (superClass) => class extends superClass {
            constructor() {
              super(...arguments);
              this.flowPragma = void 0;
            }
            getScopeHandler() {
              return FlowScopeHandler;
            }
            shouldParseTypes() {
              return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
            }
            shouldParseEnums() {
              return !!this.getPluginOption("flow", "enums");
            }
            finishToken(type2, val) {
              if (type2 !== types$1.string && type2 !== types$1.semi && type2 !== types$1.interpreterDirective) {
                if (this.flowPragma === void 0) {
                  this.flowPragma = null;
                }
              }
              return super.finishToken(type2, val);
            }
            addComment(comment2) {
              if (this.flowPragma === void 0) {
                const matches2 = FLOW_PRAGMA_REGEX.exec(comment2.value);
                if (!matches2)
                  ;
                else if (matches2[1] === "flow") {
                  this.flowPragma = "flow";
                } else if (matches2[1] === "noflow") {
                  this.flowPragma = "noflow";
                } else {
                  throw new Error("Unexpected flow pragma");
                }
              }
              return super.addComment(comment2);
            }
            flowParseTypeInitialiser(tok) {
              const oldInType = this.state.inType;
              this.state.inType = true;
              this.expect(tok || types$1.colon);
              const type2 = this.flowParseType();
              this.state.inType = oldInType;
              return type2;
            }
            flowParsePredicate() {
              const node2 = this.startNode();
              const moduloPos = this.state.start;
              this.next();
              this.expectContextual("checks");
              if (this.state.lastTokStart > moduloPos + 1) {
                this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
              }
              if (this.eat(types$1.parenL)) {
                node2.value = this.parseExpression();
                this.expect(types$1.parenR);
                return this.finishNode(node2, "DeclaredPredicate");
              } else {
                return this.finishNode(node2, "InferredPredicate");
              }
            }
            flowParseTypeAndPredicateInitialiser() {
              const oldInType = this.state.inType;
              this.state.inType = true;
              this.expect(types$1.colon);
              let type2 = null;
              let predicate = null;
              if (this.match(types$1.modulo)) {
                this.state.inType = oldInType;
                predicate = this.flowParsePredicate();
              } else {
                type2 = this.flowParseType();
                this.state.inType = oldInType;
                if (this.match(types$1.modulo)) {
                  predicate = this.flowParsePredicate();
                }
              }
              return [type2, predicate];
            }
            flowParseDeclareClass(node2) {
              this.next();
              this.flowParseInterfaceish(node2, true);
              return this.finishNode(node2, "DeclareClass");
            }
            flowParseDeclareFunction(node2) {
              this.next();
              const id = node2.id = this.parseIdentifier();
              const typeNode = this.startNode();
              const typeContainer = this.startNode();
              if (this.isRelational("<")) {
                typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                typeNode.typeParameters = null;
              }
              this.expect(types$1.parenL);
              const tmp = this.flowParseFunctionTypeParams();
              typeNode.params = tmp.params;
              typeNode.rest = tmp.rest;
              typeNode.this = tmp._this;
              this.expect(types$1.parenR);
              [typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
              typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
              id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
              this.resetEndLocation(id);
              this.semicolon();
              this.scope.declareName(node2.id.name, BIND_FLOW_DECLARE_FN, node2.id.start);
              return this.finishNode(node2, "DeclareFunction");
            }
            flowParseDeclare(node2, insideModule) {
              if (this.match(types$1._class)) {
                return this.flowParseDeclareClass(node2);
              } else if (this.match(types$1._function)) {
                return this.flowParseDeclareFunction(node2);
              } else if (this.match(types$1._var)) {
                return this.flowParseDeclareVariable(node2);
              } else if (this.eatContextual("module")) {
                if (this.match(types$1.dot)) {
                  return this.flowParseDeclareModuleExports(node2);
                } else {
                  if (insideModule) {
                    this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
                  }
                  return this.flowParseDeclareModule(node2);
                }
              } else if (this.isContextual("type")) {
                return this.flowParseDeclareTypeAlias(node2);
              } else if (this.isContextual("opaque")) {
                return this.flowParseDeclareOpaqueType(node2);
              } else if (this.isContextual("interface")) {
                return this.flowParseDeclareInterface(node2);
              } else if (this.match(types$1._export)) {
                return this.flowParseDeclareExportDeclaration(node2, insideModule);
              } else {
                throw this.unexpected();
              }
            }
            flowParseDeclareVariable(node2) {
              this.next();
              node2.id = this.flowParseTypeAnnotatableIdentifier(true);
              this.scope.declareName(node2.id.name, BIND_VAR, node2.id.start);
              this.semicolon();
              return this.finishNode(node2, "DeclareVariable");
            }
            flowParseDeclareModule(node2) {
              this.scope.enter(SCOPE_OTHER);
              if (this.match(types$1.string)) {
                node2.id = this.parseExprAtom();
              } else {
                node2.id = this.parseIdentifier();
              }
              const bodyNode = node2.body = this.startNode();
              const body = bodyNode.body = [];
              this.expect(types$1.braceL);
              while (!this.match(types$1.braceR)) {
                let bodyNode2 = this.startNode();
                if (this.match(types$1._import)) {
                  this.next();
                  if (!this.isContextual("type") && !this.match(types$1._typeof)) {
                    this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
                  }
                  this.parseImport(bodyNode2);
                } else {
                  this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
                  bodyNode2 = this.flowParseDeclare(bodyNode2, true);
                }
                body.push(bodyNode2);
              }
              this.scope.exit();
              this.expect(types$1.braceR);
              this.finishNode(bodyNode, "BlockStatement");
              let kind = null;
              let hasModuleExport = false;
              body.forEach((bodyElement) => {
                if (isEsModuleType(bodyElement)) {
                  if (kind === "CommonJS") {
                    this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
                  }
                  kind = "ES";
                } else if (bodyElement.type === "DeclareModuleExports") {
                  if (hasModuleExport) {
                    this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
                  }
                  if (kind === "ES") {
                    this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
                  }
                  kind = "CommonJS";
                  hasModuleExport = true;
                }
              });
              node2.kind = kind || "CommonJS";
              return this.finishNode(node2, "DeclareModule");
            }
            flowParseDeclareExportDeclaration(node2, insideModule) {
              this.expect(types$1._export);
              if (this.eat(types$1._default)) {
                if (this.match(types$1._function) || this.match(types$1._class)) {
                  node2.declaration = this.flowParseDeclare(this.startNode());
                } else {
                  node2.declaration = this.flowParseType();
                  this.semicolon();
                }
                node2.default = true;
                return this.finishNode(node2, "DeclareExportDeclaration");
              } else {
                if (this.match(types$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
                  const label = this.state.value;
                  const suggestion = exportSuggestions[label];
                  throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
                }
                if (this.match(types$1._var) || this.match(types$1._function) || this.match(types$1._class) || this.isContextual("opaque")) {
                  node2.declaration = this.flowParseDeclare(this.startNode());
                  node2.default = false;
                  return this.finishNode(node2, "DeclareExportDeclaration");
                } else if (this.match(types$1.star) || this.match(types$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
                  node2 = this.parseExport(node2);
                  if (node2.type === "ExportNamedDeclaration") {
                    node2.type = "ExportDeclaration";
                    node2.default = false;
                    delete node2.exportKind;
                  }
                  node2.type = "Declare" + node2.type;
                  return node2;
                }
              }
              throw this.unexpected();
            }
            flowParseDeclareModuleExports(node2) {
              this.next();
              this.expectContextual("exports");
              node2.typeAnnotation = this.flowParseTypeAnnotation();
              this.semicolon();
              return this.finishNode(node2, "DeclareModuleExports");
            }
            flowParseDeclareTypeAlias(node2) {
              this.next();
              this.flowParseTypeAlias(node2);
              node2.type = "DeclareTypeAlias";
              return node2;
            }
            flowParseDeclareOpaqueType(node2) {
              this.next();
              this.flowParseOpaqueType(node2, true);
              node2.type = "DeclareOpaqueType";
              return node2;
            }
            flowParseDeclareInterface(node2) {
              this.next();
              this.flowParseInterfaceish(node2);
              return this.finishNode(node2, "DeclareInterface");
            }
            flowParseInterfaceish(node2, isClass) {
              if (isClass === void 0) {
                isClass = false;
              }
              node2.id = this.flowParseRestrictedIdentifier(!isClass, true);
              this.scope.declareName(node2.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node2.id.start);
              if (this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                node2.typeParameters = null;
              }
              node2.extends = [];
              node2.implements = [];
              node2.mixins = [];
              if (this.eat(types$1._extends)) {
                do {
                  node2.extends.push(this.flowParseInterfaceExtends());
                } while (!isClass && this.eat(types$1.comma));
              }
              if (this.isContextual("mixins")) {
                this.next();
                do {
                  node2.mixins.push(this.flowParseInterfaceExtends());
                } while (this.eat(types$1.comma));
              }
              if (this.isContextual("implements")) {
                this.next();
                do {
                  node2.implements.push(this.flowParseInterfaceExtends());
                } while (this.eat(types$1.comma));
              }
              node2.body = this.flowParseObjectType({allowStatic: isClass, allowExact: false, allowSpread: false, allowProto: isClass, allowInexact: false});
            }
            flowParseInterfaceExtends() {
              const node2 = this.startNode();
              node2.id = this.flowParseQualifiedTypeIdentifier();
              if (this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node2.typeParameters = null;
              }
              return this.finishNode(node2, "InterfaceExtends");
            }
            flowParseInterface(node2) {
              this.flowParseInterfaceish(node2);
              return this.finishNode(node2, "InterfaceDeclaration");
            }
            checkNotUnderscore(word) {
              if (word === "_") {
                this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
              }
            }
            checkReservedType(word, startLoc, declaration) {
              if (!reservedTypes.has(word))
                return;
              this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
            }
            flowParseRestrictedIdentifier(liberal, declaration) {
              this.checkReservedType(this.state.value, this.state.start, declaration);
              return this.parseIdentifier(liberal);
            }
            flowParseTypeAlias(node2) {
              node2.id = this.flowParseRestrictedIdentifier(false, true);
              this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.start);
              if (this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                node2.typeParameters = null;
              }
              node2.right = this.flowParseTypeInitialiser(types$1.eq);
              this.semicolon();
              return this.finishNode(node2, "TypeAlias");
            }
            flowParseOpaqueType(node2, declare) {
              this.expectContextual("type");
              node2.id = this.flowParseRestrictedIdentifier(true, true);
              this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.start);
              if (this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                node2.typeParameters = null;
              }
              node2.supertype = null;
              if (this.match(types$1.colon)) {
                node2.supertype = this.flowParseTypeInitialiser(types$1.colon);
              }
              node2.impltype = null;
              if (!declare) {
                node2.impltype = this.flowParseTypeInitialiser(types$1.eq);
              }
              this.semicolon();
              return this.finishNode(node2, "OpaqueType");
            }
            flowParseTypeParameter(requireDefault) {
              if (requireDefault === void 0) {
                requireDefault = false;
              }
              const nodeStart = this.state.start;
              const node2 = this.startNode();
              const variance = this.flowParseVariance();
              const ident = this.flowParseTypeAnnotatableIdentifier();
              node2.name = ident.name;
              node2.variance = variance;
              node2.bound = ident.typeAnnotation;
              if (this.match(types$1.eq)) {
                this.eat(types$1.eq);
                node2.default = this.flowParseType();
              } else {
                if (requireDefault) {
                  this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
                }
              }
              return this.finishNode(node2, "TypeParameter");
            }
            flowParseTypeParameterDeclaration() {
              const oldInType = this.state.inType;
              const node2 = this.startNode();
              node2.params = [];
              this.state.inType = true;
              if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
                this.next();
              } else {
                this.unexpected();
              }
              let defaultRequired = false;
              do {
                const typeParameter = this.flowParseTypeParameter(defaultRequired);
                node2.params.push(typeParameter);
                if (typeParameter.default) {
                  defaultRequired = true;
                }
                if (!this.isRelational(">")) {
                  this.expect(types$1.comma);
                }
              } while (!this.isRelational(">"));
              this.expectRelational(">");
              this.state.inType = oldInType;
              return this.finishNode(node2, "TypeParameterDeclaration");
            }
            flowParseTypeParameterInstantiation() {
              const node2 = this.startNode();
              const oldInType = this.state.inType;
              node2.params = [];
              this.state.inType = true;
              this.expectRelational("<");
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = false;
              while (!this.isRelational(">")) {
                node2.params.push(this.flowParseType());
                if (!this.isRelational(">")) {
                  this.expect(types$1.comma);
                }
              }
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              this.expectRelational(">");
              this.state.inType = oldInType;
              return this.finishNode(node2, "TypeParameterInstantiation");
            }
            flowParseTypeParameterInstantiationCallOrNew() {
              const node2 = this.startNode();
              const oldInType = this.state.inType;
              node2.params = [];
              this.state.inType = true;
              this.expectRelational("<");
              while (!this.isRelational(">")) {
                node2.params.push(this.flowParseTypeOrImplicitInstantiation());
                if (!this.isRelational(">")) {
                  this.expect(types$1.comma);
                }
              }
              this.expectRelational(">");
              this.state.inType = oldInType;
              return this.finishNode(node2, "TypeParameterInstantiation");
            }
            flowParseInterfaceType() {
              const node2 = this.startNode();
              this.expectContextual("interface");
              node2.extends = [];
              if (this.eat(types$1._extends)) {
                do {
                  node2.extends.push(this.flowParseInterfaceExtends());
                } while (this.eat(types$1.comma));
              }
              node2.body = this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false});
              return this.finishNode(node2, "InterfaceTypeAnnotation");
            }
            flowParseObjectPropertyKey() {
              return this.match(types$1.num) || this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
            }
            flowParseObjectTypeIndexer(node2, isStatic, variance) {
              node2.static = isStatic;
              if (this.lookahead().type === types$1.colon) {
                node2.id = this.flowParseObjectPropertyKey();
                node2.key = this.flowParseTypeInitialiser();
              } else {
                node2.id = null;
                node2.key = this.flowParseType();
              }
              this.expect(types$1.bracketR);
              node2.value = this.flowParseTypeInitialiser();
              node2.variance = variance;
              return this.finishNode(node2, "ObjectTypeIndexer");
            }
            flowParseObjectTypeInternalSlot(node2, isStatic) {
              node2.static = isStatic;
              node2.id = this.flowParseObjectPropertyKey();
              this.expect(types$1.bracketR);
              this.expect(types$1.bracketR);
              if (this.isRelational("<") || this.match(types$1.parenL)) {
                node2.method = true;
                node2.optional = false;
                node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start));
              } else {
                node2.method = false;
                if (this.eat(types$1.question)) {
                  node2.optional = true;
                }
                node2.value = this.flowParseTypeInitialiser();
              }
              return this.finishNode(node2, "ObjectTypeInternalSlot");
            }
            flowParseObjectTypeMethodish(node2) {
              node2.params = [];
              node2.rest = null;
              node2.typeParameters = null;
              node2.this = null;
              if (this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              this.expect(types$1.parenL);
              if (this.match(types$1._this)) {
                node2.this = this.flowParseFunctionTypeParam(true);
                node2.this.name = null;
                if (!this.match(types$1.parenR)) {
                  this.expect(types$1.comma);
                }
              }
              while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
                node2.params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(types$1.parenR)) {
                  this.expect(types$1.comma);
                }
              }
              if (this.eat(types$1.ellipsis)) {
                node2.rest = this.flowParseFunctionTypeParam(false);
              }
              this.expect(types$1.parenR);
              node2.returnType = this.flowParseTypeInitialiser();
              return this.finishNode(node2, "FunctionTypeAnnotation");
            }
            flowParseObjectTypeCallProperty(node2, isStatic) {
              const valueNode = this.startNode();
              node2.static = isStatic;
              node2.value = this.flowParseObjectTypeMethodish(valueNode);
              return this.finishNode(node2, "ObjectTypeCallProperty");
            }
            flowParseObjectType(_ref6) {
              let {allowStatic, allowExact, allowSpread, allowProto, allowInexact} = _ref6;
              const oldInType = this.state.inType;
              this.state.inType = true;
              const nodeStart = this.startNode();
              nodeStart.callProperties = [];
              nodeStart.properties = [];
              nodeStart.indexers = [];
              nodeStart.internalSlots = [];
              let endDelim;
              let exact;
              let inexact = false;
              if (allowExact && this.match(types$1.braceBarL)) {
                this.expect(types$1.braceBarL);
                endDelim = types$1.braceBarR;
                exact = true;
              } else {
                this.expect(types$1.braceL);
                endDelim = types$1.braceR;
                exact = false;
              }
              nodeStart.exact = exact;
              while (!this.match(endDelim)) {
                let isStatic = false;
                let protoStart = null;
                let inexactStart = null;
                const node2 = this.startNode();
                if (allowProto && this.isContextual("proto")) {
                  const lookahead = this.lookahead();
                  if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
                    this.next();
                    protoStart = this.state.start;
                    allowStatic = false;
                  }
                }
                if (allowStatic && this.isContextual("static")) {
                  const lookahead = this.lookahead();
                  if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
                    this.next();
                    isStatic = true;
                  }
                }
                const variance = this.flowParseVariance();
                if (this.eat(types$1.bracketL)) {
                  if (protoStart != null) {
                    this.unexpected(protoStart);
                  }
                  if (this.eat(types$1.bracketL)) {
                    if (variance) {
                      this.unexpected(variance.start);
                    }
                    nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic));
                  } else {
                    nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic, variance));
                  }
                } else if (this.match(types$1.parenL) || this.isRelational("<")) {
                  if (protoStart != null) {
                    this.unexpected(protoStart);
                  }
                  if (variance) {
                    this.unexpected(variance.start);
                  }
                  nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic));
                } else {
                  let kind = "init";
                  if (this.isContextual("get") || this.isContextual("set")) {
                    const lookahead = this.lookahead();
                    if (lookahead.type === types$1.name || lookahead.type === types$1.string || lookahead.type === types$1.num) {
                      kind = this.state.value;
                      this.next();
                    }
                  }
                  const propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
                  if (propOrInexact === null) {
                    inexact = true;
                    inexactStart = this.state.lastTokStart;
                  } else {
                    nodeStart.properties.push(propOrInexact);
                  }
                }
                this.flowObjectTypeSemicolon();
                if (inexactStart && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
                  this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
                }
              }
              this.expect(endDelim);
              if (allowSpread) {
                nodeStart.inexact = inexact;
              }
              const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
              this.state.inType = oldInType;
              return out;
            }
            flowParseObjectTypeProperty(node2, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
              if (this.eat(types$1.ellipsis)) {
                const isInexactToken = this.match(types$1.comma) || this.match(types$1.semi) || this.match(types$1.braceR) || this.match(types$1.braceBarR);
                if (isInexactToken) {
                  if (!allowSpread) {
                    this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
                  } else if (!allowInexact) {
                    this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
                  }
                  if (variance) {
                    this.raise(variance.start, FlowErrors.InexactVariance);
                  }
                  return null;
                }
                if (!allowSpread) {
                  this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
                }
                if (protoStart != null) {
                  this.unexpected(protoStart);
                }
                if (variance) {
                  this.raise(variance.start, FlowErrors.SpreadVariance);
                }
                node2.argument = this.flowParseType();
                return this.finishNode(node2, "ObjectTypeSpreadProperty");
              } else {
                node2.key = this.flowParseObjectPropertyKey();
                node2.static = isStatic;
                node2.proto = protoStart != null;
                node2.kind = kind;
                let optional = false;
                if (this.isRelational("<") || this.match(types$1.parenL)) {
                  node2.method = true;
                  if (protoStart != null) {
                    this.unexpected(protoStart);
                  }
                  if (variance) {
                    this.unexpected(variance.start);
                  }
                  node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start));
                  if (kind === "get" || kind === "set") {
                    this.flowCheckGetterSetterParams(node2);
                  }
                  if (!allowSpread && node2.key.name === "constructor" && node2.value.this) {
                    this.raise(node2.value.this.start, FlowErrors.ThisParamBannedInConstructor);
                  }
                } else {
                  if (kind !== "init")
                    this.unexpected();
                  node2.method = false;
                  if (this.eat(types$1.question)) {
                    optional = true;
                  }
                  node2.value = this.flowParseTypeInitialiser();
                  node2.variance = variance;
                }
                node2.optional = optional;
                return this.finishNode(node2, "ObjectTypeProperty");
              }
            }
            flowCheckGetterSetterParams(property) {
              const paramCount = property.kind === "get" ? 0 : 1;
              const start = property.start;
              const length = property.value.params.length + (property.value.rest ? 1 : 0);
              if (property.value.this) {
                this.raise(property.value.this.start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
              }
              if (length !== paramCount) {
                if (property.kind === "get") {
                  this.raise(start, ErrorMessages.BadGetterArity);
                } else {
                  this.raise(start, ErrorMessages.BadSetterArity);
                }
              }
              if (property.kind === "set" && property.value.rest) {
                this.raise(start, ErrorMessages.BadSetterRestParameter);
              }
            }
            flowObjectTypeSemicolon() {
              if (!this.eat(types$1.semi) && !this.eat(types$1.comma) && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
                this.unexpected();
              }
            }
            flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
              startPos = startPos || this.state.start;
              startLoc = startLoc || this.state.startLoc;
              let node2 = id || this.flowParseRestrictedIdentifier(true);
              while (this.eat(types$1.dot)) {
                const node22 = this.startNodeAt(startPos, startLoc);
                node22.qualification = node2;
                node22.id = this.flowParseRestrictedIdentifier(true);
                node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
              }
              return node2;
            }
            flowParseGenericType(startPos, startLoc, id) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.typeParameters = null;
              node2.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
              if (this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              }
              return this.finishNode(node2, "GenericTypeAnnotation");
            }
            flowParseTypeofType() {
              const node2 = this.startNode();
              this.expect(types$1._typeof);
              node2.argument = this.flowParsePrimaryType();
              return this.finishNode(node2, "TypeofTypeAnnotation");
            }
            flowParseTupleType() {
              const node2 = this.startNode();
              node2.types = [];
              this.expect(types$1.bracketL);
              while (this.state.pos < this.length && !this.match(types$1.bracketR)) {
                node2.types.push(this.flowParseType());
                if (this.match(types$1.bracketR))
                  break;
                this.expect(types$1.comma);
              }
              this.expect(types$1.bracketR);
              return this.finishNode(node2, "TupleTypeAnnotation");
            }
            flowParseFunctionTypeParam(first) {
              let name2 = null;
              let optional = false;
              let typeAnnotation = null;
              const node2 = this.startNode();
              const lh = this.lookahead();
              const isThis = this.state.type === types$1._this;
              if (lh.type === types$1.colon || lh.type === types$1.question) {
                if (isThis && !first) {
                  this.raise(node2.start, FlowErrors.ThisParamMustBeFirst);
                }
                name2 = this.parseIdentifier(isThis);
                if (this.eat(types$1.question)) {
                  optional = true;
                  if (isThis) {
                    this.raise(node2.start, FlowErrors.ThisParamMayNotBeOptional);
                  }
                }
                typeAnnotation = this.flowParseTypeInitialiser();
              } else {
                typeAnnotation = this.flowParseType();
              }
              node2.name = name2;
              node2.optional = optional;
              node2.typeAnnotation = typeAnnotation;
              return this.finishNode(node2, "FunctionTypeParam");
            }
            reinterpretTypeAsFunctionTypeParam(type2) {
              const node2 = this.startNodeAt(type2.start, type2.loc.start);
              node2.name = null;
              node2.optional = false;
              node2.typeAnnotation = type2;
              return this.finishNode(node2, "FunctionTypeParam");
            }
            flowParseFunctionTypeParams(params) {
              if (params === void 0) {
                params = [];
              }
              let rest = null;
              let _this = null;
              if (this.match(types$1._this)) {
                _this = this.flowParseFunctionTypeParam(true);
                _this.name = null;
                if (!this.match(types$1.parenR)) {
                  this.expect(types$1.comma);
                }
              }
              while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
                params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(types$1.parenR)) {
                  this.expect(types$1.comma);
                }
              }
              if (this.eat(types$1.ellipsis)) {
                rest = this.flowParseFunctionTypeParam(false);
              }
              return {params, rest, _this};
            }
            flowIdentToTypeAnnotation(startPos, startLoc, node2, id) {
              switch (id.name) {
                case "any":
                  return this.finishNode(node2, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                  return this.finishNode(node2, "BooleanTypeAnnotation");
                case "mixed":
                  return this.finishNode(node2, "MixedTypeAnnotation");
                case "empty":
                  return this.finishNode(node2, "EmptyTypeAnnotation");
                case "number":
                  return this.finishNode(node2, "NumberTypeAnnotation");
                case "string":
                  return this.finishNode(node2, "StringTypeAnnotation");
                case "symbol":
                  return this.finishNode(node2, "SymbolTypeAnnotation");
                default:
                  this.checkNotUnderscore(id.name);
                  return this.flowParseGenericType(startPos, startLoc, id);
              }
            }
            flowParsePrimaryType() {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const node2 = this.startNode();
              let tmp;
              let type2;
              let isGroupedType = false;
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              switch (this.state.type) {
                case types$1.name:
                  if (this.isContextual("interface")) {
                    return this.flowParseInterfaceType();
                  }
                  return this.flowIdentToTypeAnnotation(startPos, startLoc, node2, this.parseIdentifier());
                case types$1.braceL:
                  return this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true});
                case types$1.braceBarL:
                  return this.flowParseObjectType({allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false});
                case types$1.bracketL:
                  this.state.noAnonFunctionType = false;
                  type2 = this.flowParseTupleType();
                  this.state.noAnonFunctionType = oldNoAnonFunctionType;
                  return type2;
                case types$1.relational:
                  if (this.state.value === "<") {
                    node2.typeParameters = this.flowParseTypeParameterDeclaration();
                    this.expect(types$1.parenL);
                    tmp = this.flowParseFunctionTypeParams();
                    node2.params = tmp.params;
                    node2.rest = tmp.rest;
                    node2.this = tmp._this;
                    this.expect(types$1.parenR);
                    this.expect(types$1.arrow);
                    node2.returnType = this.flowParseType();
                    return this.finishNode(node2, "FunctionTypeAnnotation");
                  }
                  break;
                case types$1.parenL:
                  this.next();
                  if (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
                    if (this.match(types$1.name) || this.match(types$1._this)) {
                      const token = this.lookahead().type;
                      isGroupedType = token !== types$1.question && token !== types$1.colon;
                    } else {
                      isGroupedType = true;
                    }
                  }
                  if (isGroupedType) {
                    this.state.noAnonFunctionType = false;
                    type2 = this.flowParseType();
                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                    if (this.state.noAnonFunctionType || !(this.match(types$1.comma) || this.match(types$1.parenR) && this.lookahead().type === types$1.arrow)) {
                      this.expect(types$1.parenR);
                      return type2;
                    } else {
                      this.eat(types$1.comma);
                    }
                  }
                  if (type2) {
                    tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type2)]);
                  } else {
                    tmp = this.flowParseFunctionTypeParams();
                  }
                  node2.params = tmp.params;
                  node2.rest = tmp.rest;
                  node2.this = tmp._this;
                  this.expect(types$1.parenR);
                  this.expect(types$1.arrow);
                  node2.returnType = this.flowParseType();
                  node2.typeParameters = null;
                  return this.finishNode(node2, "FunctionTypeAnnotation");
                case types$1.string:
                  return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case types$1._true:
                case types$1._false:
                  node2.value = this.match(types$1._true);
                  this.next();
                  return this.finishNode(node2, "BooleanLiteralTypeAnnotation");
                case types$1.plusMin:
                  if (this.state.value === "-") {
                    this.next();
                    if (this.match(types$1.num)) {
                      return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node2.start, node2.loc.start);
                    }
                    if (this.match(types$1.bigint)) {
                      return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node2.start, node2.loc.start);
                    }
                    throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
                  }
                  throw this.unexpected();
                case types$1.num:
                  return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case types$1.bigint:
                  return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case types$1._void:
                  this.next();
                  return this.finishNode(node2, "VoidTypeAnnotation");
                case types$1._null:
                  this.next();
                  return this.finishNode(node2, "NullLiteralTypeAnnotation");
                case types$1._this:
                  this.next();
                  return this.finishNode(node2, "ThisTypeAnnotation");
                case types$1.star:
                  this.next();
                  return this.finishNode(node2, "ExistsTypeAnnotation");
                default:
                  if (this.state.type.keyword === "typeof") {
                    return this.flowParseTypeofType();
                  } else if (this.state.type.keyword) {
                    const label = this.state.type.label;
                    this.next();
                    return super.createIdentifier(node2, label);
                  }
              }
              throw this.unexpected();
            }
            flowParsePostfixType() {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              let type2 = this.flowParsePrimaryType();
              let seenOptionalIndexedAccess = false;
              while ((this.match(types$1.bracketL) || this.match(types$1.questionDot)) && !this.canInsertSemicolon()) {
                const node2 = this.startNodeAt(startPos, startLoc);
                const optional = this.eat(types$1.questionDot);
                seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
                this.expect(types$1.bracketL);
                if (!optional && this.match(types$1.bracketR)) {
                  node2.elementType = type2;
                  this.next();
                  type2 = this.finishNode(node2, "ArrayTypeAnnotation");
                } else {
                  node2.objectType = type2;
                  node2.indexType = this.flowParseType();
                  this.expect(types$1.bracketR);
                  if (seenOptionalIndexedAccess) {
                    node2.optional = optional;
                    type2 = this.finishNode(node2, "OptionalIndexedAccessType");
                  } else {
                    type2 = this.finishNode(node2, "IndexedAccessType");
                  }
                }
              }
              return type2;
            }
            flowParsePrefixType() {
              const node2 = this.startNode();
              if (this.eat(types$1.question)) {
                node2.typeAnnotation = this.flowParsePrefixType();
                return this.finishNode(node2, "NullableTypeAnnotation");
              } else {
                return this.flowParsePostfixType();
              }
            }
            flowParseAnonFunctionWithoutParens() {
              const param = this.flowParsePrefixType();
              if (!this.state.noAnonFunctionType && this.eat(types$1.arrow)) {
                const node2 = this.startNodeAt(param.start, param.loc.start);
                node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
                node2.rest = null;
                node2.this = null;
                node2.returnType = this.flowParseType();
                node2.typeParameters = null;
                return this.finishNode(node2, "FunctionTypeAnnotation");
              }
              return param;
            }
            flowParseIntersectionType() {
              const node2 = this.startNode();
              this.eat(types$1.bitwiseAND);
              const type2 = this.flowParseAnonFunctionWithoutParens();
              node2.types = [type2];
              while (this.eat(types$1.bitwiseAND)) {
                node2.types.push(this.flowParseAnonFunctionWithoutParens());
              }
              return node2.types.length === 1 ? type2 : this.finishNode(node2, "IntersectionTypeAnnotation");
            }
            flowParseUnionType() {
              const node2 = this.startNode();
              this.eat(types$1.bitwiseOR);
              const type2 = this.flowParseIntersectionType();
              node2.types = [type2];
              while (this.eat(types$1.bitwiseOR)) {
                node2.types.push(this.flowParseIntersectionType());
              }
              return node2.types.length === 1 ? type2 : this.finishNode(node2, "UnionTypeAnnotation");
            }
            flowParseType() {
              const oldInType = this.state.inType;
              this.state.inType = true;
              const type2 = this.flowParseUnionType();
              this.state.inType = oldInType;
              this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
              return type2;
            }
            flowParseTypeOrImplicitInstantiation() {
              if (this.state.type === types$1.name && this.state.value === "_") {
                const startPos = this.state.start;
                const startLoc = this.state.startLoc;
                const node2 = this.parseIdentifier();
                return this.flowParseGenericType(startPos, startLoc, node2);
              } else {
                return this.flowParseType();
              }
            }
            flowParseTypeAnnotation() {
              const node2 = this.startNode();
              node2.typeAnnotation = this.flowParseTypeInitialiser();
              return this.finishNode(node2, "TypeAnnotation");
            }
            flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
              const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
              if (this.match(types$1.colon)) {
                ident.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(ident);
              }
              return ident;
            }
            typeCastToParameter(node2) {
              node2.expression.typeAnnotation = node2.typeAnnotation;
              this.resetEndLocation(node2.expression, node2.typeAnnotation.end, node2.typeAnnotation.loc.end);
              return node2.expression;
            }
            flowParseVariance() {
              let variance = null;
              if (this.match(types$1.plusMin)) {
                variance = this.startNode();
                if (this.state.value === "+") {
                  variance.kind = "plus";
                } else {
                  variance.kind = "minus";
                }
                this.next();
                this.finishNode(variance, "Variance");
              }
              return variance;
            }
            parseFunctionBody(node2, allowExpressionBody, isMethod) {
              if (isMethod === void 0) {
                isMethod = false;
              }
              if (allowExpressionBody) {
                return this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod));
              }
              return super.parseFunctionBody(node2, false, isMethod);
            }
            parseFunctionBodyAndFinish(node2, type2, isMethod) {
              if (isMethod === void 0) {
                isMethod = false;
              }
              if (this.match(types$1.colon)) {
                const typeNode = this.startNode();
                [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
                node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
              }
              super.parseFunctionBodyAndFinish(node2, type2, isMethod);
            }
            parseStatement(context, topLevel) {
              if (this.state.strict && this.match(types$1.name) && this.state.value === "interface") {
                const lookahead = this.lookahead();
                if (lookahead.type === types$1.name || isKeyword(lookahead.value)) {
                  const node2 = this.startNode();
                  this.next();
                  return this.flowParseInterface(node2);
                }
              } else if (this.shouldParseEnums() && this.isContextual("enum")) {
                const node2 = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node2);
              }
              const stmt = super.parseStatement(context, topLevel);
              if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
                this.flowPragma = null;
              }
              return stmt;
            }
            parseExpressionStatement(node2, expr2) {
              if (expr2.type === "Identifier") {
                if (expr2.name === "declare") {
                  if (this.match(types$1._class) || this.match(types$1.name) || this.match(types$1._function) || this.match(types$1._var) || this.match(types$1._export)) {
                    return this.flowParseDeclare(node2);
                  }
                } else if (this.match(types$1.name)) {
                  if (expr2.name === "interface") {
                    return this.flowParseInterface(node2);
                  } else if (expr2.name === "type") {
                    return this.flowParseTypeAlias(node2);
                  } else if (expr2.name === "opaque") {
                    return this.flowParseOpaqueType(node2, false);
                  }
                }
              }
              return super.parseExpressionStatement(node2, expr2);
            }
            shouldParseExportDeclaration() {
              return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
            }
            isExportDefaultSpecifier() {
              if (this.match(types$1.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
                return false;
              }
              return super.isExportDefaultSpecifier();
            }
            parseExportDefaultExpression() {
              if (this.shouldParseEnums() && this.isContextual("enum")) {
                const node2 = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node2);
              }
              return super.parseExportDefaultExpression();
            }
            parseConditional(expr2, startPos, startLoc, refNeedsArrowPos) {
              if (!this.match(types$1.question))
                return expr2;
              if (refNeedsArrowPos) {
                const result = this.tryParse(() => super.parseConditional(expr2, startPos, startLoc));
                if (!result.node) {
                  refNeedsArrowPos.start = result.error.pos || this.state.start;
                  return expr2;
                }
                if (result.error)
                  this.state = result.failState;
                return result.node;
              }
              this.expect(types$1.question);
              const state = this.state.clone();
              const originalNoArrowAt = this.state.noArrowAt;
              const node2 = this.startNodeAt(startPos, startLoc);
              let {consequent, failed} = this.tryParseConditionalConsequent();
              let [valid, invalid] = this.getArrowLikeExpressions(consequent);
              if (failed || invalid.length > 0) {
                const noArrowAt = [...originalNoArrowAt];
                if (invalid.length > 0) {
                  this.state = state;
                  this.state.noArrowAt = noArrowAt;
                  for (let i = 0; i < invalid.length; i++) {
                    noArrowAt.push(invalid[i].start);
                  }
                  ({consequent, failed} = this.tryParseConditionalConsequent());
                  [valid, invalid] = this.getArrowLikeExpressions(consequent);
                }
                if (failed && valid.length > 1) {
                  this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
                }
                if (failed && valid.length === 1) {
                  this.state = state;
                  this.state.noArrowAt = noArrowAt.concat(valid[0].start);
                  ({consequent, failed} = this.tryParseConditionalConsequent());
                }
              }
              this.getArrowLikeExpressions(consequent, true);
              this.state.noArrowAt = originalNoArrowAt;
              this.expect(types$1.colon);
              node2.test = expr2;
              node2.consequent = consequent;
              node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0, void 0));
              return this.finishNode(node2, "ConditionalExpression");
            }
            tryParseConditionalConsequent() {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              const consequent = this.parseMaybeAssignAllowIn();
              const failed = !this.match(types$1.colon);
              this.state.noArrowParamsConversionAt.pop();
              return {consequent, failed};
            }
            getArrowLikeExpressions(node2, disallowInvalid) {
              const stack = [node2];
              const arrows = [];
              while (stack.length !== 0) {
                const node3 = stack.pop();
                if (node3.type === "ArrowFunctionExpression") {
                  if (node3.typeParameters || !node3.returnType) {
                    this.finishArrowValidation(node3);
                  } else {
                    arrows.push(node3);
                  }
                  stack.push(node3.body);
                } else if (node3.type === "ConditionalExpression") {
                  stack.push(node3.consequent);
                  stack.push(node3.alternate);
                }
              }
              if (disallowInvalid) {
                arrows.forEach((node3) => this.finishArrowValidation(node3));
                return [arrows, []];
              }
              return partition(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)));
            }
            finishArrowValidation(node2) {
              var _node$extra;
              this.toAssignableList(node2.params, (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingComma, false);
              this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
              super.checkParams(node2, false, true);
              this.scope.exit();
            }
            forwardNoArrowParamsConversionAt(node2, parse) {
              let result;
              if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                result = parse();
                this.state.noArrowParamsConversionAt.pop();
              } else {
                result = parse();
              }
              return result;
            }
            parseParenItem(node2, startPos, startLoc) {
              node2 = super.parseParenItem(node2, startPos, startLoc);
              if (this.eat(types$1.question)) {
                node2.optional = true;
                this.resetEndLocation(node2);
              }
              if (this.match(types$1.colon)) {
                const typeCastNode = this.startNodeAt(startPos, startLoc);
                typeCastNode.expression = node2;
                typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TypeCastExpression");
              }
              return node2;
            }
            assertModuleNodeAllowed(node2) {
              if (node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type") {
                return;
              }
              super.assertModuleNodeAllowed(node2);
            }
            parseExport(node2) {
              const decl = super.parseExport(node2);
              if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
                decl.exportKind = decl.exportKind || "value";
              }
              return decl;
            }
            parseExportDeclaration(node2) {
              if (this.isContextual("type")) {
                node2.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                if (this.match(types$1.braceL)) {
                  node2.specifiers = this.parseExportSpecifiers();
                  this.parseExportFrom(node2);
                  return null;
                } else {
                  return this.flowParseTypeAlias(declarationNode);
                }
              } else if (this.isContextual("opaque")) {
                node2.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseOpaqueType(declarationNode, false);
              } else if (this.isContextual("interface")) {
                node2.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseInterface(declarationNode);
              } else if (this.shouldParseEnums() && this.isContextual("enum")) {
                node2.exportKind = "value";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(declarationNode);
              } else {
                return super.parseExportDeclaration(node2);
              }
            }
            eatExportStar(node2) {
              if (super.eatExportStar(...arguments))
                return true;
              if (this.isContextual("type") && this.lookahead().type === types$1.star) {
                node2.exportKind = "type";
                this.next();
                this.next();
                return true;
              }
              return false;
            }
            maybeParseExportNamespaceSpecifier(node2) {
              const pos = this.state.start;
              const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2);
              if (hasNamespace && node2.exportKind === "type") {
                this.unexpected(pos);
              }
              return hasNamespace;
            }
            parseClassId(node2, isStatement, optionalId) {
              super.parseClassId(node2, isStatement, optionalId);
              if (this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              }
            }
            parseClassMember(classBody, member, state) {
              const pos = this.state.start;
              if (this.isContextual("declare")) {
                if (this.parseClassMemberFromModifier(classBody, member)) {
                  return;
                }
                member.declare = true;
              }
              super.parseClassMember(classBody, member, state);
              if (member.declare) {
                if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
                  this.raise(pos, FlowErrors.DeclareClassElement);
                } else if (member.value) {
                  this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
                }
              }
            }
            getTokenFromCode(code) {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (code === 123 && next === 124) {
                return this.finishOp(types$1.braceBarL, 2);
              } else if (this.state.inType && (code === 62 || code === 60)) {
                return this.finishOp(types$1.relational, 1);
              } else if (this.state.inType && code === 63) {
                if (next === 46) {
                  return this.finishOp(types$1.questionDot, 2);
                }
                return this.finishOp(types$1.question, 1);
              } else if (isIteratorStart(code, next)) {
                this.state.isIterator = true;
                return super.readWord();
              } else {
                return super.getTokenFromCode(code);
              }
            }
            isAssignable(node2, isBinding) {
              switch (node2.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                  return true;
                case "ObjectExpression": {
                  const last2 = node2.properties.length - 1;
                  return node2.properties.every((prop2, i) => {
                    return prop2.type !== "ObjectMethod" && (i === last2 || prop2.type === "SpreadElement") && this.isAssignable(prop2);
                  });
                }
                case "ObjectProperty":
                  return this.isAssignable(node2.value);
                case "SpreadElement":
                  return this.isAssignable(node2.argument);
                case "ArrayExpression":
                  return node2.elements.every((element) => this.isAssignable(element));
                case "AssignmentExpression":
                  return node2.operator === "=";
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                  return this.isAssignable(node2.expression);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return !isBinding;
                default:
                  return false;
              }
            }
            toAssignable(node2, isLHS) {
              if (isLHS === void 0) {
                isLHS = false;
              }
              if (node2.type === "TypeCastExpression") {
                return super.toAssignable(this.typeCastToParameter(node2), isLHS);
              } else {
                return super.toAssignable(node2, isLHS);
              }
            }
            toAssignableList(exprList, trailingCommaPos, isLHS) {
              for (let i = 0; i < exprList.length; i++) {
                const expr2 = exprList[i];
                if ((expr2 == null ? void 0 : expr2.type) === "TypeCastExpression") {
                  exprList[i] = this.typeCastToParameter(expr2);
                }
              }
              return super.toAssignableList(exprList, trailingCommaPos, isLHS);
            }
            toReferencedList(exprList, isParenthesizedExpr) {
              for (let i = 0; i < exprList.length; i++) {
                var _expr$extra;
                const expr2 = exprList[i];
                if (expr2 && expr2.type === "TypeCastExpression" && !((_expr$extra = expr2.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
                  this.raise(expr2.typeAnnotation.start, FlowErrors.TypeCastInPattern);
                }
              }
              return exprList;
            }
            parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
              const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
              if (canBePattern && !this.state.maybeInArrowParameters) {
                this.toReferencedList(node2.elements);
              }
              return node2;
            }
            checkLVal(expr2) {
              if (expr2.type !== "TypeCastExpression") {
                for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
                  args[_key9 - 1] = arguments[_key9];
                }
                return super.checkLVal(expr2, ...args);
              }
            }
            parseClassProperty(node2) {
              if (this.match(types$1.colon)) {
                node2.typeAnnotation = this.flowParseTypeAnnotation();
              }
              return super.parseClassProperty(node2);
            }
            parseClassPrivateProperty(node2) {
              if (this.match(types$1.colon)) {
                node2.typeAnnotation = this.flowParseTypeAnnotation();
              }
              return super.parseClassPrivateProperty(node2);
            }
            isClassMethod() {
              return this.isRelational("<") || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(types$1.colon) || super.isClassProperty();
            }
            isNonstaticConstructor(method) {
              return !this.match(types$1.colon) && super.isNonstaticConstructor(method);
            }
            pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
              if (method.variance) {
                this.unexpected(method.variance.start);
              }
              delete method.variance;
              if (this.isRelational("<")) {
                method.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
              if (method.params && isConstructor) {
                const params = method.params;
                if (params.length > 0 && this.isThisParam(params[0])) {
                  this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
                }
              } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
                const params = method.value.params;
                if (params.length > 0 && this.isThisParam(params[0])) {
                  this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
                }
              }
            }
            pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
              if (method.variance) {
                this.unexpected(method.variance.start);
              }
              delete method.variance;
              if (this.isRelational("<")) {
                method.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
            }
            parseClassSuper(node2) {
              super.parseClassSuper(node2);
              if (node2.superClass && this.isRelational("<")) {
                node2.superTypeParameters = this.flowParseTypeParameterInstantiation();
              }
              if (this.isContextual("implements")) {
                this.next();
                const implemented = node2.implements = [];
                do {
                  const node3 = this.startNode();
                  node3.id = this.flowParseRestrictedIdentifier(true);
                  if (this.isRelational("<")) {
                    node3.typeParameters = this.flowParseTypeParameterInstantiation();
                  } else {
                    node3.typeParameters = null;
                  }
                  implemented.push(this.finishNode(node3, "ClassImplements"));
                } while (this.eat(types$1.comma));
              }
            }
            checkGetterSetterParams(method) {
              super.checkGetterSetterParams(method);
              const params = this.getObjectOrClassMethodParams(method);
              if (params.length > 0) {
                const param = params[0];
                if (this.isThisParam(param) && method.kind === "get") {
                  this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
                } else if (this.isThisParam(param)) {
                  this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
                }
              }
            }
            parsePropertyName(node2, isPrivateNameAllowed) {
              const variance = this.flowParseVariance();
              const key = super.parsePropertyName(node2, isPrivateNameAllowed);
              node2.variance = variance;
              return key;
            }
            parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
              if (prop2.variance) {
                this.unexpected(prop2.variance.start);
              }
              delete prop2.variance;
              let typeParameters;
              if (this.isRelational("<") && !isAccessor) {
                typeParameters = this.flowParseTypeParameterDeclaration();
                if (!this.match(types$1.parenL))
                  this.unexpected();
              }
              super.parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
              if (typeParameters) {
                (prop2.value || prop2).typeParameters = typeParameters;
              }
            }
            parseAssignableListItemTypes(param) {
              if (this.eat(types$1.question)) {
                if (param.type !== "Identifier") {
                  this.raise(param.start, FlowErrors.OptionalBindingPattern);
                }
                if (this.isThisParam(param)) {
                  this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
                }
                param.optional = true;
              }
              if (this.match(types$1.colon)) {
                param.typeAnnotation = this.flowParseTypeAnnotation();
              } else if (this.isThisParam(param)) {
                this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
              }
              if (this.match(types$1.eq) && this.isThisParam(param)) {
                this.raise(param.start, FlowErrors.ThisParamNoDefault);
              }
              this.resetEndLocation(param);
              return param;
            }
            parseMaybeDefault(startPos, startLoc, left) {
              const node2 = super.parseMaybeDefault(startPos, startLoc, left);
              if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
                this.raise(node2.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
              }
              return node2;
            }
            shouldParseDefaultImport(node2) {
              if (!hasTypeImportKind(node2)) {
                return super.shouldParseDefaultImport(node2);
              }
              return isMaybeDefaultImport(this.state);
            }
            parseImportSpecifierLocal(node2, specifier, type2, contextDescription) {
              specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
              this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
              node2.specifiers.push(this.finishNode(specifier, type2));
            }
            maybeParseDefaultImportSpecifier(node2) {
              node2.importKind = "value";
              let kind = null;
              if (this.match(types$1._typeof)) {
                kind = "typeof";
              } else if (this.isContextual("type")) {
                kind = "type";
              }
              if (kind) {
                const lh = this.lookahead();
                if (kind === "type" && lh.type === types$1.star) {
                  this.unexpected(lh.start);
                }
                if (isMaybeDefaultImport(lh) || lh.type === types$1.braceL || lh.type === types$1.star) {
                  this.next();
                  node2.importKind = kind;
                }
              }
              return super.maybeParseDefaultImportSpecifier(node2);
            }
            parseImportSpecifier(node2) {
              const specifier = this.startNode();
              const firstIdentLoc = this.state.start;
              const firstIdent = this.parseModuleExportName();
              let specifierTypeKind = null;
              if (firstIdent.type === "Identifier") {
                if (firstIdent.name === "type") {
                  specifierTypeKind = "type";
                } else if (firstIdent.name === "typeof") {
                  specifierTypeKind = "typeof";
                }
              }
              let isBinding = false;
              if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
                const as_ident = this.parseIdentifier(true);
                if (specifierTypeKind !== null && !this.match(types$1.name) && !this.state.type.keyword) {
                  specifier.imported = as_ident;
                  specifier.importKind = specifierTypeKind;
                  specifier.local = as_ident.__clone();
                } else {
                  specifier.imported = firstIdent;
                  specifier.importKind = null;
                  specifier.local = this.parseIdentifier();
                }
              } else if (specifierTypeKind !== null && (this.match(types$1.name) || this.state.type.keyword)) {
                specifier.imported = this.parseIdentifier(true);
                specifier.importKind = specifierTypeKind;
                if (this.eatContextual("as")) {
                  specifier.local = this.parseIdentifier();
                } else {
                  isBinding = true;
                  specifier.local = specifier.imported.__clone();
                }
              } else {
                if (firstIdent.type === "StringLiteral") {
                  throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
                }
                isBinding = true;
                specifier.imported = firstIdent;
                specifier.importKind = null;
                specifier.local = specifier.imported.__clone();
              }
              const nodeIsTypeImport = hasTypeImportKind(node2);
              const specifierIsTypeImport = hasTypeImportKind(specifier);
              if (nodeIsTypeImport && specifierIsTypeImport) {
                this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);
              }
              if (nodeIsTypeImport || specifierIsTypeImport) {
                this.checkReservedType(specifier.local.name, specifier.local.start, true);
              }
              if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
                this.checkReservedWord(specifier.local.name, specifier.start, true, true);
              }
              this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
              node2.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case types$1._this:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseFunctionParams(node2, allowModifiers) {
              const kind = node2.kind;
              if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              super.parseFunctionParams(node2, allowModifiers);
            }
            parseVarId(decl, kind) {
              super.parseVarId(decl, kind);
              if (this.match(types$1.colon)) {
                decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(decl.id);
              }
            }
            parseAsyncArrowFromCallExpression(node2, call) {
              if (this.match(types$1.colon)) {
                const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                node2.returnType = this.flowParseTypeAnnotation();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
              }
              return super.parseAsyncArrowFromCallExpression(node2, call);
            }
            shouldParseAsyncArrow() {
              return this.match(types$1.colon) || super.shouldParseAsyncArrow();
            }
            parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
              var _jsx;
              let state = null;
              let jsx2;
              if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
                state = this.state.clone();
                jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);
                if (!jsx2.error)
                  return jsx2.node;
                const {context} = this.state;
                if (context[context.length - 1] === types$1$1.j_oTag) {
                  context.length -= 2;
                } else if (context[context.length - 1] === types$1$1.j_expr) {
                  context.length -= 1;
                }
              }
              if ((_jsx = jsx2) != null && _jsx.error || this.isRelational("<")) {
                var _jsx2, _jsx3;
                state = state || this.state.clone();
                let typeParameters;
                const arrow = this.tryParse((abort) => {
                  var _arrowExpression$extr;
                  typeParameters = this.flowParseTypeParameterDeclaration();
                  const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                    const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
                    this.resetStartLocationFromNode(result, typeParameters);
                    return result;
                  });
                  if (arrowExpression2.type !== "ArrowFunctionExpression" && (_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) {
                    abort();
                  }
                  const expr2 = this.maybeUnwrapTypeCastExpression(arrowExpression2);
                  expr2.typeParameters = typeParameters;
                  this.resetStartLocationFromNode(expr2, typeParameters);
                  return arrowExpression2;
                }, state);
                let arrowExpression = null;
                if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                  if (!arrow.error && !arrow.aborted) {
                    if (arrow.node.async) {
                      this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
                    }
                    return arrow.node;
                  }
                  arrowExpression = arrow.node;
                }
                if ((_jsx2 = jsx2) != null && _jsx2.node) {
                  this.state = jsx2.failState;
                  return jsx2.node;
                }
                if (arrowExpression) {
                  this.state = arrow.failState;
                  return arrowExpression;
                }
                if ((_jsx3 = jsx2) != null && _jsx3.thrown)
                  throw jsx2.error;
                if (arrow.thrown)
                  throw arrow.error;
                throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
              }
              return super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
            }
            parseArrow(node2) {
              if (this.match(types$1.colon)) {
                const result = this.tryParse(() => {
                  const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true;
                  const typeNode = this.startNode();
                  [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
                  this.state.noAnonFunctionType = oldNoAnonFunctionType;
                  if (this.canInsertSemicolon())
                    this.unexpected();
                  if (!this.match(types$1.arrow))
                    this.unexpected();
                  return typeNode;
                });
                if (result.thrown)
                  return null;
                if (result.error)
                  this.state = result.failState;
                node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
              }
              return super.parseArrow(node2);
            }
            shouldParseArrow() {
              return this.match(types$1.colon) || super.shouldParseArrow();
            }
            setArrowFunctionParameters(node2, params) {
              if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
                node2.params = params;
              } else {
                super.setArrowFunctionParameters(node2, params);
              }
            }
            checkParams(node2, allowDuplicates, isArrowFunction) {
              if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
                return;
              }
              for (let i = 0; i < node2.params.length; i++) {
                if (this.isThisParam(node2.params[i]) && i > 0) {
                  this.raise(node2.params[i].start, FlowErrors.ThisParamMustBeFirst);
                }
              }
              return super.checkParams(...arguments);
            }
            parseParenAndDistinguishExpression(canBeArrow) {
              return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
            }
            parseSubscripts(base, startPos, startLoc, noCalls) {
              if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
                this.next();
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.callee = base;
                node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                base = this.finishNode(node2, "CallExpression");
              } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
                const state = this.state.clone();
                const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
                if (!arrow.error && !arrow.aborted)
                  return arrow.node;
                const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
                if (result.node && !result.error)
                  return result.node;
                if (arrow.node) {
                  this.state = arrow.failState;
                  return arrow.node;
                }
                if (result.node) {
                  this.state = result.failState;
                  return result.node;
                }
                throw arrow.error || result.error;
              }
              return super.parseSubscripts(base, startPos, startLoc, noCalls);
            }
            parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
              if (this.match(types$1.questionDot) && this.isLookaheadToken_lt()) {
                subscriptState.optionalChainMember = true;
                if (noCalls) {
                  subscriptState.stop = true;
                  return base;
                }
                this.next();
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.callee = base;
                node2.typeArguments = this.flowParseTypeParameterInstantiation();
                this.expect(types$1.parenL);
                node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                node2.optional = true;
                return this.finishCallExpression(node2, true);
              } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.callee = base;
                const result = this.tryParse(() => {
                  node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
                  this.expect(types$1.parenL);
                  node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                  if (subscriptState.optionalChainMember)
                    node2.optional = false;
                  return this.finishCallExpression(node2, subscriptState.optionalChainMember);
                });
                if (result.node) {
                  if (result.error)
                    this.state = result.failState;
                  return result.node;
                }
              }
              return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
            }
            parseNewArguments(node2) {
              let targs = null;
              if (this.shouldParseTypes() && this.isRelational("<")) {
                targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
              }
              node2.typeArguments = targs;
              super.parseNewArguments(node2);
            }
            parseAsyncArrowWithTypeParameters(startPos, startLoc) {
              const node2 = this.startNodeAt(startPos, startLoc);
              this.parseFunctionParams(node2);
              if (!this.parseArrow(node2))
                return;
              return this.parseArrowExpression(node2, void 0, true);
            }
            readToken_mult_modulo(code) {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (code === 42 && next === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false;
                this.state.pos += 2;
                this.nextToken();
                return;
              }
              super.readToken_mult_modulo(code);
            }
            readToken_pipe_amp(code) {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (code === 124 && next === 125) {
                this.finishOp(types$1.braceBarR, 2);
                return;
              }
              super.readToken_pipe_amp(code);
            }
            parseTopLevel(file, program) {
              const fileNode = super.parseTopLevel(file, program);
              if (this.state.hasFlowComment) {
                this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
              }
              return fileNode;
            }
            skipBlockComment() {
              if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment) {
                  this.unexpected(null, FlowErrors.NestedFlowComment);
                }
                this.hasFlowCommentCompletion();
                this.state.pos += this.skipFlowComment();
                this.state.hasFlowComment = true;
                return;
              }
              if (this.state.hasFlowComment) {
                const end = this.input.indexOf("*-/", this.state.pos += 2);
                if (end === -1) {
                  throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
                }
                this.state.pos = end + 3;
                return;
              }
              super.skipBlockComment();
            }
            skipFlowComment() {
              const {pos} = this.state;
              let shiftToFirstNonWhiteSpace = 2;
              while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
                shiftToFirstNonWhiteSpace++;
              }
              const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
              const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
              if (ch2 === 58 && ch3 === 58) {
                return shiftToFirstNonWhiteSpace + 2;
              }
              if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
                return shiftToFirstNonWhiteSpace + 12;
              }
              if (ch2 === 58 && ch3 !== 58) {
                return shiftToFirstNonWhiteSpace;
              }
              return false;
            }
            hasFlowCommentCompletion() {
              const end = this.input.indexOf("*/", this.state.pos);
              if (end === -1) {
                throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
              }
            }
            flowEnumErrorBooleanMemberNotInitialized(pos, _ref7) {
              let {enumName, memberName} = _ref7;
              this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
            }
            flowEnumErrorInvalidMemberName(pos, _ref8) {
              let {enumName, memberName} = _ref8;
              const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
              this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
            }
            flowEnumErrorDuplicateMemberName(pos, _ref9) {
              let {enumName, memberName} = _ref9;
              this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
            }
            flowEnumErrorInconsistentMemberValues(pos, _ref10) {
              let {enumName} = _ref10;
              this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
            }
            flowEnumErrorInvalidExplicitType(pos, _ref11) {
              let {enumName, suppliedType} = _ref11;
              return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
            }
            flowEnumErrorInvalidMemberInitializer(pos, _ref12) {
              let {enumName, explicitType, memberName} = _ref12;
              let message = null;
              switch (explicitType) {
                case "boolean":
                case "number":
                case "string":
                  message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
                  break;
                case "symbol":
                  message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
                  break;
                default:
                  message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
              }
              return this.raise(pos, message, enumName, memberName, explicitType);
            }
            flowEnumErrorNumberMemberNotInitialized(pos, _ref13) {
              let {enumName, memberName} = _ref13;
              this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
            }
            flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref14) {
              let {enumName} = _ref14;
              this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
            }
            flowEnumMemberInit() {
              const startPos = this.state.start;
              const endOfInit = () => this.match(types$1.comma) || this.match(types$1.braceR);
              switch (this.state.type) {
                case types$1.num: {
                  const literal = this.parseLiteral(this.state.value, "NumericLiteral");
                  if (endOfInit()) {
                    return {type: "number", pos: literal.start, value: literal};
                  }
                  return {type: "invalid", pos: startPos};
                }
                case types$1.string: {
                  const literal = this.parseLiteral(this.state.value, "StringLiteral");
                  if (endOfInit()) {
                    return {type: "string", pos: literal.start, value: literal};
                  }
                  return {type: "invalid", pos: startPos};
                }
                case types$1._true:
                case types$1._false: {
                  const literal = this.parseBooleanLiteral();
                  if (endOfInit()) {
                    return {type: "boolean", pos: literal.start, value: literal};
                  }
                  return {type: "invalid", pos: startPos};
                }
                default:
                  return {type: "invalid", pos: startPos};
              }
            }
            flowEnumMemberRaw() {
              const pos = this.state.start;
              const id = this.parseIdentifier(true);
              const init2 = this.eat(types$1.eq) ? this.flowEnumMemberInit() : {type: "none", pos};
              return {id, init: init2};
            }
            flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
              const {explicitType} = context;
              if (explicitType === null) {
                return;
              }
              if (explicitType !== expectedType) {
                this.flowEnumErrorInvalidMemberInitializer(pos, context);
              }
            }
            flowEnumMembers(_ref15) {
              let {enumName, explicitType} = _ref15;
              const seenNames = new Set();
              const members = {booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: []};
              let hasUnknownMembers = false;
              while (!this.match(types$1.braceR)) {
                if (this.eat(types$1.ellipsis)) {
                  hasUnknownMembers = true;
                  break;
                }
                const memberNode = this.startNode();
                const {id, init: init2} = this.flowEnumMemberRaw();
                const memberName = id.name;
                if (memberName === "") {
                  continue;
                }
                if (/^[a-z]/.test(memberName)) {
                  this.flowEnumErrorInvalidMemberName(id.start, {enumName, memberName});
                }
                if (seenNames.has(memberName)) {
                  this.flowEnumErrorDuplicateMemberName(id.start, {enumName, memberName});
                }
                seenNames.add(memberName);
                const context = {enumName, explicitType, memberName};
                memberNode.id = id;
                switch (init2.type) {
                  case "boolean": {
                    this.flowEnumCheckExplicitTypeMismatch(init2.pos, context, "boolean");
                    memberNode.init = init2.value;
                    members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                    break;
                  }
                  case "number": {
                    this.flowEnumCheckExplicitTypeMismatch(init2.pos, context, "number");
                    memberNode.init = init2.value;
                    members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                    break;
                  }
                  case "string": {
                    this.flowEnumCheckExplicitTypeMismatch(init2.pos, context, "string");
                    memberNode.init = init2.value;
                    members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                    break;
                  }
                  case "invalid": {
                    throw this.flowEnumErrorInvalidMemberInitializer(init2.pos, context);
                  }
                  case "none": {
                    switch (explicitType) {
                      case "boolean":
                        this.flowEnumErrorBooleanMemberNotInitialized(init2.pos, context);
                        break;
                      case "number":
                        this.flowEnumErrorNumberMemberNotInitialized(init2.pos, context);
                        break;
                      default:
                        members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                    }
                  }
                }
                if (!this.match(types$1.braceR)) {
                  this.expect(types$1.comma);
                }
              }
              return {members, hasUnknownMembers};
            }
            flowEnumStringMembers(initializedMembers, defaultedMembers, _ref16) {
              let {enumName} = _ref16;
              if (initializedMembers.length === 0) {
                return defaultedMembers;
              } else if (defaultedMembers.length === 0) {
                return initializedMembers;
              } else if (defaultedMembers.length > initializedMembers.length) {
                for (const member of initializedMembers) {
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {enumName});
                }
                return defaultedMembers;
              } else {
                for (const member of defaultedMembers) {
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {enumName});
                }
                return initializedMembers;
              }
            }
            flowEnumParseExplicitType(_ref17) {
              let {enumName} = _ref17;
              if (this.eatContextual("of")) {
                if (!this.match(types$1.name)) {
                  throw this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName, suppliedType: null});
                }
                const {value} = this.state;
                this.next();
                if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
                  this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName, suppliedType: value});
                }
                return value;
              }
              return null;
            }
            flowEnumBody(node2, _ref18) {
              let {enumName, nameLoc} = _ref18;
              const explicitType = this.flowEnumParseExplicitType({enumName});
              this.expect(types$1.braceL);
              const {members, hasUnknownMembers} = this.flowEnumMembers({enumName, explicitType});
              node2.hasUnknownMembers = hasUnknownMembers;
              switch (explicitType) {
                case "boolean":
                  node2.explicitType = true;
                  node2.members = members.booleanMembers;
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumBooleanBody");
                case "number":
                  node2.explicitType = true;
                  node2.members = members.numberMembers;
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumNumberBody");
                case "string":
                  node2.explicitType = true;
                  node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {enumName});
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumStringBody");
                case "symbol":
                  node2.members = members.defaultedMembers;
                  this.expect(types$1.braceR);
                  return this.finishNode(node2, "EnumSymbolBody");
                default: {
                  const empty2 = () => {
                    node2.members = [];
                    this.expect(types$1.braceR);
                    return this.finishNode(node2, "EnumStringBody");
                  };
                  node2.explicitType = false;
                  const boolsLen = members.booleanMembers.length;
                  const numsLen = members.numberMembers.length;
                  const strsLen = members.stringMembers.length;
                  const defaultedLen = members.defaultedMembers.length;
                  if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                    return empty2();
                  } else if (!boolsLen && !numsLen) {
                    node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {enumName});
                    this.expect(types$1.braceR);
                    return this.finishNode(node2, "EnumStringBody");
                  } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                    for (const member of members.defaultedMembers) {
                      this.flowEnumErrorBooleanMemberNotInitialized(member.start, {enumName, memberName: member.id.name});
                    }
                    node2.members = members.booleanMembers;
                    this.expect(types$1.braceR);
                    return this.finishNode(node2, "EnumBooleanBody");
                  } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                    for (const member of members.defaultedMembers) {
                      this.flowEnumErrorNumberMemberNotInitialized(member.start, {enumName, memberName: member.id.name});
                    }
                    node2.members = members.numberMembers;
                    this.expect(types$1.braceR);
                    return this.finishNode(node2, "EnumNumberBody");
                  } else {
                    this.flowEnumErrorInconsistentMemberValues(nameLoc, {enumName});
                    return empty2();
                  }
                }
              }
            }
            flowParseEnumDeclaration(node2) {
              const id = this.parseIdentifier();
              node2.id = id;
              node2.body = this.flowEnumBody(this.startNode(), {enumName: id.name, nameLoc: id.start});
              return this.finishNode(node2, "EnumDeclaration");
            }
            updateContext(prevType) {
              if (this.match(types$1.name) && this.state.value === "of" && prevType === types$1.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === "interface") {
                this.state.exprAllowed = false;
              } else {
                super.updateContext(prevType);
              }
            }
            isLookaheadToken_lt() {
              const next = this.nextTokenStart();
              if (this.input.charCodeAt(next) === 60) {
                const afterNext = this.input.charCodeAt(next + 1);
                return afterNext !== 60 && afterNext !== 61;
              }
              return false;
            }
            maybeUnwrapTypeCastExpression(node2) {
              return node2.type === "TypeCastExpression" ? node2.expression : node2;
            }
          };
          const entities$1 = {quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666"};
          const HEX_NUMBER$1 = /^[\da-fA-F]+$/;
          const DECIMAL_NUMBER$1 = /^\d+$/;
          const JsxErrors = makeErrorTemplates({AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"}, ErrorCodes.SyntaxError);
          types$1$1.j_oTag = new TokContext("<tag", false);
          types$1$1.j_cTag = new TokContext("</tag", false);
          types$1$1.j_expr = new TokContext("<tag>...</tag>", true, true);
          types$1.jsxName = new TokenType("jsxName");
          types$1.jsxText = new TokenType("jsxText", {beforeExpr: true});
          types$1.jsxTagStart = new TokenType("jsxTagStart", {startsExpr: true});
          types$1.jsxTagEnd = new TokenType("jsxTagEnd");
          types$1.jsxTagStart.updateContext = function() {
            this.state.context.push(types$1$1.j_expr);
            this.state.context.push(types$1$1.j_oTag);
            this.state.exprAllowed = false;
          };
          types$1.jsxTagEnd.updateContext = function(prevType) {
            const out = this.state.context.pop();
            if (out === types$1$1.j_oTag && prevType === types$1.slash || out === types$1$1.j_cTag) {
              this.state.context.pop();
              this.state.exprAllowed = this.curContext() === types$1$1.j_expr;
            } else {
              this.state.exprAllowed = true;
            }
          };
          function isFragment(object2) {
            return object2 ? object2.type === "JSXOpeningFragment" || object2.type === "JSXClosingFragment" : false;
          }
          function getQualifiedJSXName(object2) {
            if (object2.type === "JSXIdentifier") {
              return object2.name;
            }
            if (object2.type === "JSXNamespacedName") {
              return object2.namespace.name + ":" + object2.name.name;
            }
            if (object2.type === "JSXMemberExpression") {
              return getQualifiedJSXName(object2.object) + "." + getQualifiedJSXName(object2.property);
            }
            throw new Error("Node had unexpected type: " + object2.type);
          }
          var jsx = (superClass) => class extends superClass {
            jsxReadToken() {
              let out = "";
              let chunkStart = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length) {
                  throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
                }
                const ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                  case 60:
                  case 123:
                    if (this.state.pos === this.state.start) {
                      if (ch === 60 && this.state.exprAllowed) {
                        ++this.state.pos;
                        return this.finishToken(types$1.jsxTagStart);
                      }
                      return super.getTokenFromCode(ch);
                    }
                    out += this.input.slice(chunkStart, this.state.pos);
                    return this.finishToken(types$1.jsxText, out);
                  case 38:
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadEntity();
                    chunkStart = this.state.pos;
                    break;
                  case 62:
                  case 125:
                  default:
                    if (isNewLine(ch)) {
                      out += this.input.slice(chunkStart, this.state.pos);
                      out += this.jsxReadNewLine(true);
                      chunkStart = this.state.pos;
                    } else {
                      ++this.state.pos;
                    }
                }
              }
            }
            jsxReadNewLine(normalizeCRLF) {
              const ch = this.input.charCodeAt(this.state.pos);
              let out;
              ++this.state.pos;
              if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
                out = normalizeCRLF ? "\n" : "\r\n";
              } else {
                out = String.fromCharCode(ch);
              }
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              return out;
            }
            jsxReadString(quote) {
              let out = "";
              let chunkStart = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length) {
                  throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
                }
                const ch = this.input.charCodeAt(this.state.pos);
                if (ch === quote)
                  break;
                if (ch === 38) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadEntity();
                  chunkStart = this.state.pos;
                } else if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(false);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
              }
              out += this.input.slice(chunkStart, this.state.pos++);
              return this.finishToken(types$1.string, out);
            }
            jsxReadEntity() {
              let str = "";
              let count = 0;
              let entity;
              let ch = this.input[this.state.pos];
              const startPos = ++this.state.pos;
              while (this.state.pos < this.length && count++ < 10) {
                ch = this.input[this.state.pos++];
                if (ch === ";") {
                  if (str[0] === "#") {
                    if (str[1] === "x") {
                      str = str.substr(2);
                      if (HEX_NUMBER$1.test(str)) {
                        entity = String.fromCodePoint(parseInt(str, 16));
                      }
                    } else {
                      str = str.substr(1);
                      if (DECIMAL_NUMBER$1.test(str)) {
                        entity = String.fromCodePoint(parseInt(str, 10));
                      }
                    }
                  } else {
                    entity = entities$1[str];
                  }
                  break;
                }
                str += ch;
              }
              if (!entity) {
                this.state.pos = startPos;
                return "&";
              }
              return entity;
            }
            jsxReadWord() {
              let ch;
              const start = this.state.pos;
              do {
                ch = this.input.charCodeAt(++this.state.pos);
              } while (isIdentifierChar(ch) || ch === 45);
              return this.finishToken(types$1.jsxName, this.input.slice(start, this.state.pos));
            }
            jsxParseIdentifier() {
              const node2 = this.startNode();
              if (this.match(types$1.jsxName)) {
                node2.name = this.state.value;
              } else if (this.state.type.keyword) {
                node2.name = this.state.type.keyword;
              } else {
                this.unexpected();
              }
              this.next();
              return this.finishNode(node2, "JSXIdentifier");
            }
            jsxParseNamespacedName() {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const name2 = this.jsxParseIdentifier();
              if (!this.eat(types$1.colon))
                return name2;
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.namespace = name2;
              node2.name = this.jsxParseIdentifier();
              return this.finishNode(node2, "JSXNamespacedName");
            }
            jsxParseElementName() {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              let node2 = this.jsxParseNamespacedName();
              if (node2.type === "JSXNamespacedName") {
                return node2;
              }
              while (this.eat(types$1.dot)) {
                const newNode = this.startNodeAt(startPos, startLoc);
                newNode.object = node2;
                newNode.property = this.jsxParseIdentifier();
                node2 = this.finishNode(newNode, "JSXMemberExpression");
              }
              return node2;
            }
            jsxParseAttributeValue() {
              let node2;
              switch (this.state.type) {
                case types$1.braceL:
                  node2 = this.startNode();
                  this.next();
                  node2 = this.jsxParseExpressionContainer(node2);
                  if (node2.expression.type === "JSXEmptyExpression") {
                    this.raise(node2.start, JsxErrors.AttributeIsEmpty);
                  }
                  return node2;
                case types$1.jsxTagStart:
                case types$1.string:
                  return this.parseExprAtom();
                default:
                  throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
              }
            }
            jsxParseEmptyExpression() {
              const node2 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
              return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.start, this.state.startLoc);
            }
            jsxParseSpreadChild(node2) {
              this.next();
              node2.expression = this.parseExpression();
              this.expect(types$1.braceR);
              return this.finishNode(node2, "JSXSpreadChild");
            }
            jsxParseExpressionContainer(node2) {
              if (this.match(types$1.braceR)) {
                node2.expression = this.jsxParseEmptyExpression();
              } else {
                const expression = this.parseExpression();
                node2.expression = expression;
              }
              this.expect(types$1.braceR);
              return this.finishNode(node2, "JSXExpressionContainer");
            }
            jsxParseAttribute() {
              const node2 = this.startNode();
              if (this.eat(types$1.braceL)) {
                this.expect(types$1.ellipsis);
                node2.argument = this.parseMaybeAssignAllowIn();
                this.expect(types$1.braceR);
                return this.finishNode(node2, "JSXSpreadAttribute");
              }
              node2.name = this.jsxParseNamespacedName();
              node2.value = this.eat(types$1.eq) ? this.jsxParseAttributeValue() : null;
              return this.finishNode(node2, "JSXAttribute");
            }
            jsxParseOpeningElementAt(startPos, startLoc) {
              const node2 = this.startNodeAt(startPos, startLoc);
              if (this.match(types$1.jsxTagEnd)) {
                this.expect(types$1.jsxTagEnd);
                return this.finishNode(node2, "JSXOpeningFragment");
              }
              node2.name = this.jsxParseElementName();
              return this.jsxParseOpeningElementAfterName(node2);
            }
            jsxParseOpeningElementAfterName(node2) {
              const attributes = [];
              while (!this.match(types$1.slash) && !this.match(types$1.jsxTagEnd)) {
                attributes.push(this.jsxParseAttribute());
              }
              node2.attributes = attributes;
              node2.selfClosing = this.eat(types$1.slash);
              this.expect(types$1.jsxTagEnd);
              return this.finishNode(node2, "JSXOpeningElement");
            }
            jsxParseClosingElementAt(startPos, startLoc) {
              const node2 = this.startNodeAt(startPos, startLoc);
              if (this.match(types$1.jsxTagEnd)) {
                this.expect(types$1.jsxTagEnd);
                return this.finishNode(node2, "JSXClosingFragment");
              }
              node2.name = this.jsxParseElementName();
              this.expect(types$1.jsxTagEnd);
              return this.finishNode(node2, "JSXClosingElement");
            }
            jsxParseElementAt(startPos, startLoc) {
              const node2 = this.startNodeAt(startPos, startLoc);
              const children = [];
              const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
              let closingElement = null;
              if (!openingElement.selfClosing) {
                contents:
                  for (; ; ) {
                    switch (this.state.type) {
                      case types$1.jsxTagStart:
                        startPos = this.state.start;
                        startLoc = this.state.startLoc;
                        this.next();
                        if (this.eat(types$1.slash)) {
                          closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                          break contents;
                        }
                        children.push(this.jsxParseElementAt(startPos, startLoc));
                        break;
                      case types$1.jsxText:
                        children.push(this.parseExprAtom());
                        break;
                      case types$1.braceL: {
                        const node3 = this.startNode();
                        this.next();
                        if (this.match(types$1.ellipsis)) {
                          children.push(this.jsxParseSpreadChild(node3));
                        } else {
                          children.push(this.jsxParseExpressionContainer(node3));
                        }
                        break;
                      }
                      default:
                        throw this.unexpected();
                    }
                  }
                if (isFragment(openingElement) && !isFragment(closingElement)) {
                  this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
                } else if (!isFragment(openingElement) && isFragment(closingElement)) {
                  this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
                } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                  if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                    this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
                  }
                }
              }
              if (isFragment(openingElement)) {
                node2.openingFragment = openingElement;
                node2.closingFragment = closingElement;
              } else {
                node2.openingElement = openingElement;
                node2.closingElement = closingElement;
              }
              node2.children = children;
              if (this.isRelational("<")) {
                throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
              }
              return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
            }
            jsxParseElement() {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              this.next();
              return this.jsxParseElementAt(startPos, startLoc);
            }
            parseExprAtom(refExpressionErrors) {
              if (this.match(types$1.jsxText)) {
                return this.parseLiteral(this.state.value, "JSXText");
              } else if (this.match(types$1.jsxTagStart)) {
                return this.jsxParseElement();
              } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
                this.finishToken(types$1.jsxTagStart);
                return this.jsxParseElement();
              } else {
                return super.parseExprAtom(refExpressionErrors);
              }
            }
            getTokenFromCode(code) {
              if (this.state.inPropertyName)
                return super.getTokenFromCode(code);
              const context = this.curContext();
              if (context === types$1$1.j_expr) {
                return this.jsxReadToken();
              }
              if (context === types$1$1.j_oTag || context === types$1$1.j_cTag) {
                if (isIdentifierStart(code)) {
                  return this.jsxReadWord();
                }
                if (code === 62) {
                  ++this.state.pos;
                  return this.finishToken(types$1.jsxTagEnd);
                }
                if ((code === 34 || code === 39) && context === types$1$1.j_oTag) {
                  return this.jsxReadString(code);
                }
              }
              if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                ++this.state.pos;
                return this.finishToken(types$1.jsxTagStart);
              }
              return super.getTokenFromCode(code);
            }
            updateContext(prevType) {
              if (this.match(types$1.braceL)) {
                const curContext = this.curContext();
                if (curContext === types$1$1.j_oTag) {
                  this.state.context.push(types$1$1.braceExpression);
                } else if (curContext === types$1$1.j_expr) {
                  this.state.context.push(types$1$1.templateQuasi);
                } else {
                  super.updateContext(prevType);
                }
                this.state.exprAllowed = true;
              } else if (this.match(types$1.slash) && prevType === types$1.jsxTagStart) {
                this.state.context.length -= 2;
                this.state.context.push(types$1$1.j_cTag);
                this.state.exprAllowed = false;
              } else {
                return super.updateContext(prevType);
              }
            }
          };
          class TypeScriptScope extends Scope {
            constructor() {
              super(...arguments);
              this.types = [];
              this.enums = [];
              this.constEnums = [];
              this.classes = [];
              this.exportOnlyBindings = [];
            }
          }
          class TypeScriptScopeHandler extends ScopeHandler {
            createScope(flags) {
              return new TypeScriptScope(flags);
            }
            declareName(name2, bindingType, pos) {
              const scope2 = this.currentScope();
              if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
                this.maybeExportDefined(scope2, name2);
                scope2.exportOnlyBindings.push(name2);
                return;
              }
              super.declareName(...arguments);
              if (bindingType & BIND_KIND_TYPE) {
                if (!(bindingType & BIND_KIND_VALUE)) {
                  this.checkRedeclarationInScope(scope2, name2, bindingType, pos);
                  this.maybeExportDefined(scope2, name2);
                }
                scope2.types.push(name2);
              }
              if (bindingType & BIND_FLAGS_TS_ENUM)
                scope2.enums.push(name2);
              if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
                scope2.constEnums.push(name2);
              if (bindingType & BIND_FLAGS_CLASS)
                scope2.classes.push(name2);
            }
            isRedeclaredInScope(scope2, name2, bindingType) {
              if (scope2.enums.indexOf(name2) > -1) {
                if (bindingType & BIND_FLAGS_TS_ENUM) {
                  const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
                  const wasConst = scope2.constEnums.indexOf(name2) > -1;
                  return isConst !== wasConst;
                }
                return true;
              }
              if (bindingType & BIND_FLAGS_CLASS && scope2.classes.indexOf(name2) > -1) {
                if (scope2.lexical.indexOf(name2) > -1) {
                  return !!(bindingType & BIND_KIND_VALUE);
                } else {
                  return false;
                }
              }
              if (bindingType & BIND_KIND_TYPE && scope2.types.indexOf(name2) > -1) {
                return true;
              }
              return super.isRedeclaredInScope(...arguments);
            }
            checkLocalExport(id) {
              if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
                super.checkLocalExport(id);
              }
            }
          }
          const PARAM = 0, PARAM_YIELD = 1, PARAM_AWAIT = 2, PARAM_RETURN = 4, PARAM_IN = 8;
          class ProductionParameterHandler {
            constructor() {
              this.stacks = [];
            }
            enter(flags) {
              this.stacks.push(flags);
            }
            exit() {
              this.stacks.pop();
            }
            currentFlags() {
              return this.stacks[this.stacks.length - 1];
            }
            get hasAwait() {
              return (this.currentFlags() & PARAM_AWAIT) > 0;
            }
            get hasYield() {
              return (this.currentFlags() & PARAM_YIELD) > 0;
            }
            get hasReturn() {
              return (this.currentFlags() & PARAM_RETURN) > 0;
            }
            get hasIn() {
              return (this.currentFlags() & PARAM_IN) > 0;
            }
          }
          function functionFlags(isAsync, isGenerator) {
            return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
          }
          function nonNull(x) {
            if (x == null) {
              throw new Error(`Unexpected ${x} value.`);
            }
            return x;
          }
          function assert(x) {
            if (!x) {
              throw new Error("Assert fail");
            }
          }
          const TSErrors = makeErrorTemplates({AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."}, ErrorCodes.SyntaxError);
          function keywordTypeFromName(value) {
            switch (value) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return void 0;
            }
          }
          function tsIsAccessModifier(modifier) {
            return modifier === "private" || modifier === "public" || modifier === "protected";
          }
          var typescript = (superClass) => class extends superClass {
            getScopeHandler() {
              return TypeScriptScopeHandler;
            }
            tsIsIdentifier() {
              return this.match(types$1.name);
            }
            tsTokenCanFollowModifier() {
              return (this.match(types$1.bracketL) || this.match(types$1.braceL) || this.match(types$1.star) || this.match(types$1.ellipsis) || this.match(types$1.hash) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
            }
            tsNextTokenCanFollowModifier() {
              this.next();
              return this.tsTokenCanFollowModifier();
            }
            tsParseModifier(allowedModifiers) {
              if (!this.match(types$1.name)) {
                return void 0;
              }
              const modifier = this.state.value;
              if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                return modifier;
              }
              return void 0;
            }
            tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {
              const enforceOrder = (pos, modifier, before, after) => {
                if (modifier === before && modified[after]) {
                  this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
                }
              };
              const incompatible = (pos, modifier, mod1, mod2) => {
                if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
                  this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
                }
              };
              for (; ; ) {
                const startPos = this.state.start;
                const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));
                if (!modifier)
                  break;
                if (tsIsAccessModifier(modifier)) {
                  if (modified.accessibility) {
                    this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
                  } else {
                    enforceOrder(startPos, modifier, modifier, "override");
                    enforceOrder(startPos, modifier, modifier, "static");
                    modified.accessibility = modifier;
                  }
                } else {
                  if (Object.hasOwnProperty.call(modified, modifier)) {
                    this.raise(startPos, TSErrors.DuplicateModifier, modifier);
                  } else {
                    enforceOrder(startPos, modifier, "static", "readonly");
                    enforceOrder(startPos, modifier, "static", "override");
                    enforceOrder(startPos, modifier, "override", "readonly");
                    enforceOrder(startPos, modifier, "abstract", "override");
                    incompatible(startPos, modifier, "declare", "override");
                    incompatible(startPos, modifier, "static", "abstract");
                  }
                  modified[modifier] = true;
                }
                if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
                  this.raise(startPos, errorTemplate, modifier);
                }
              }
            }
            tsIsListTerminator(kind) {
              switch (kind) {
                case "EnumMembers":
                case "TypeMembers":
                  return this.match(types$1.braceR);
                case "HeritageClauseElement":
                  return this.match(types$1.braceL);
                case "TupleElementTypes":
                  return this.match(types$1.bracketR);
                case "TypeParametersOrArguments":
                  return this.isRelational(">");
              }
              throw new Error("Unreachable");
            }
            tsParseList(kind, parseElement) {
              const result = [];
              while (!this.tsIsListTerminator(kind)) {
                result.push(parseElement());
              }
              return result;
            }
            tsParseDelimitedList(kind, parseElement) {
              return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
            }
            tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
              const result = [];
              for (; ; ) {
                if (this.tsIsListTerminator(kind)) {
                  break;
                }
                const element = parseElement();
                if (element == null) {
                  return void 0;
                }
                result.push(element);
                if (this.eat(types$1.comma)) {
                  continue;
                }
                if (this.tsIsListTerminator(kind)) {
                  break;
                }
                if (expectSuccess) {
                  this.expect(types$1.comma);
                }
                return void 0;
              }
              return result;
            }
            tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
              if (!skipFirstToken) {
                if (bracket) {
                  this.expect(types$1.bracketL);
                } else {
                  this.expectRelational("<");
                }
              }
              const result = this.tsParseDelimitedList(kind, parseElement);
              if (bracket) {
                this.expect(types$1.bracketR);
              } else {
                this.expectRelational(">");
              }
              return result;
            }
            tsParseImportType() {
              const node2 = this.startNode();
              this.expect(types$1._import);
              this.expect(types$1.parenL);
              if (!this.match(types$1.string)) {
                this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
              }
              node2.argument = this.parseExprAtom();
              this.expect(types$1.parenR);
              if (this.eat(types$1.dot)) {
                node2.qualifier = this.tsParseEntityName(true);
              }
              if (this.isRelational("<")) {
                node2.typeParameters = this.tsParseTypeArguments();
              }
              return this.finishNode(node2, "TSImportType");
            }
            tsParseEntityName(allowReservedWords) {
              let entity = this.parseIdentifier();
              while (this.eat(types$1.dot)) {
                const node2 = this.startNodeAtNode(entity);
                node2.left = entity;
                node2.right = this.parseIdentifier(allowReservedWords);
                entity = this.finishNode(node2, "TSQualifiedName");
              }
              return entity;
            }
            tsParseTypeReference() {
              const node2 = this.startNode();
              node2.typeName = this.tsParseEntityName(false);
              if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
                node2.typeParameters = this.tsParseTypeArguments();
              }
              return this.finishNode(node2, "TSTypeReference");
            }
            tsParseThisTypePredicate(lhs) {
              this.next();
              const node2 = this.startNodeAtNode(lhs);
              node2.parameterName = lhs;
              node2.typeAnnotation = this.tsParseTypeAnnotation(false);
              node2.asserts = false;
              return this.finishNode(node2, "TSTypePredicate");
            }
            tsParseThisTypeNode() {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "TSThisType");
            }
            tsParseTypeQuery() {
              const node2 = this.startNode();
              this.expect(types$1._typeof);
              if (this.match(types$1._import)) {
                node2.exprName = this.tsParseImportType();
              } else {
                node2.exprName = this.tsParseEntityName(true);
              }
              return this.finishNode(node2, "TSTypeQuery");
            }
            tsParseTypeParameter() {
              const node2 = this.startNode();
              node2.name = this.parseIdentifierName(node2.start);
              node2.constraint = this.tsEatThenParseType(types$1._extends);
              node2.default = this.tsEatThenParseType(types$1.eq);
              return this.finishNode(node2, "TSTypeParameter");
            }
            tsTryParseTypeParameters() {
              if (this.isRelational("<")) {
                return this.tsParseTypeParameters();
              }
            }
            tsParseTypeParameters() {
              const node2 = this.startNode();
              if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
                this.next();
              } else {
                this.unexpected();
              }
              node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
              if (node2.params.length === 0) {
                this.raise(node2.start, TSErrors.EmptyTypeParameters);
              }
              return this.finishNode(node2, "TSTypeParameterDeclaration");
            }
            tsTryNextParseConstantContext() {
              if (this.lookahead().type === types$1._const) {
                this.next();
                return this.tsParseTypeReference();
              }
              return null;
            }
            tsFillSignature(returnToken, signature) {
              const returnTokenRequired = returnToken === types$1.arrow;
              signature.typeParameters = this.tsTryParseTypeParameters();
              this.expect(types$1.parenL);
              signature.parameters = this.tsParseBindingListForSignature();
              if (returnTokenRequired) {
                signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
              } else if (this.match(returnToken)) {
                signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
              }
            }
            tsParseBindingListForSignature() {
              return this.parseBindingList(types$1.parenR, 41).map((pattern) => {
                if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
                  this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
                }
                return pattern;
              });
            }
            tsParseTypeMemberSemicolon() {
              if (!this.eat(types$1.comma) && !this.isLineTerminator()) {
                this.expect(types$1.semi);
              }
            }
            tsParseSignatureMember(kind, node2) {
              this.tsFillSignature(types$1.colon, node2);
              this.tsParseTypeMemberSemicolon();
              return this.finishNode(node2, kind);
            }
            tsIsUnambiguouslyIndexSignature() {
              this.next();
              return this.eat(types$1.name) && this.match(types$1.colon);
            }
            tsTryParseIndexSignature(node2) {
              if (!(this.match(types$1.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
                return void 0;
              }
              this.expect(types$1.bracketL);
              const id = this.parseIdentifier();
              id.typeAnnotation = this.tsParseTypeAnnotation();
              this.resetEndLocation(id);
              this.expect(types$1.bracketR);
              node2.parameters = [id];
              const type2 = this.tsTryParseTypeAnnotation();
              if (type2)
                node2.typeAnnotation = type2;
              this.tsParseTypeMemberSemicolon();
              return this.finishNode(node2, "TSIndexSignature");
            }
            tsParsePropertyOrMethodSignature(node2, readonly) {
              if (this.eat(types$1.question))
                node2.optional = true;
              const nodeAny = node2;
              if (this.match(types$1.parenL) || this.isRelational("<")) {
                if (readonly) {
                  this.raise(node2.start, TSErrors.ReadonlyForMethodSignature);
                }
                const method = nodeAny;
                if (method.kind && this.isRelational("<")) {
                  this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
                }
                this.tsFillSignature(types$1.colon, method);
                this.tsParseTypeMemberSemicolon();
                if (method.kind === "get") {
                  if (method.parameters.length > 0) {
                    this.raise(this.state.pos, ErrorMessages.BadGetterArity);
                    if (this.isThisParam(method.parameters[0])) {
                      this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                    }
                  }
                } else if (method.kind === "set") {
                  if (method.parameters.length !== 1) {
                    this.raise(this.state.pos, ErrorMessages.BadSetterArity);
                  } else {
                    const firstParameter = method.parameters[0];
                    if (this.isThisParam(firstParameter)) {
                      this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                    }
                    if (firstParameter.type === "Identifier" && firstParameter.optional) {
                      this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
                    }
                    if (firstParameter.type === "RestElement") {
                      this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
                    }
                  }
                  if (method.typeAnnotation) {
                    this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
                  }
                } else {
                  method.kind = "method";
                }
                return this.finishNode(method, "TSMethodSignature");
              } else {
                const property = nodeAny;
                if (readonly)
                  property.readonly = true;
                const type2 = this.tsTryParseTypeAnnotation();
                if (type2)
                  property.typeAnnotation = type2;
                this.tsParseTypeMemberSemicolon();
                return this.finishNode(property, "TSPropertySignature");
              }
            }
            tsParseTypeMember() {
              const node2 = this.startNode();
              if (this.match(types$1.parenL) || this.isRelational("<")) {
                return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
              }
              if (this.match(types$1._new)) {
                const id = this.startNode();
                this.next();
                if (this.match(types$1.parenL) || this.isRelational("<")) {
                  return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2);
                } else {
                  node2.key = this.createIdentifier(id, "new");
                  return this.tsParsePropertyOrMethodSignature(node2, false);
                }
              }
              this.tsParseModifiers(node2, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
              const idx = this.tsTryParseIndexSignature(node2);
              if (idx) {
                return idx;
              }
              this.parsePropertyName(node2, false);
              if (!node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier()) {
                node2.kind = node2.key.name;
                this.parsePropertyName(node2, false);
              }
              return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly);
            }
            tsParseTypeLiteral() {
              const node2 = this.startNode();
              node2.members = this.tsParseObjectTypeMembers();
              return this.finishNode(node2, "TSTypeLiteral");
            }
            tsParseObjectTypeMembers() {
              this.expect(types$1.braceL);
              const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
              this.expect(types$1.braceR);
              return members;
            }
            tsIsStartOfMappedType() {
              this.next();
              if (this.eat(types$1.plusMin)) {
                return this.isContextual("readonly");
              }
              if (this.isContextual("readonly")) {
                this.next();
              }
              if (!this.match(types$1.bracketL)) {
                return false;
              }
              this.next();
              if (!this.tsIsIdentifier()) {
                return false;
              }
              this.next();
              return this.match(types$1._in);
            }
            tsParseMappedTypeParameter() {
              const node2 = this.startNode();
              node2.name = this.parseIdentifierName(node2.start);
              node2.constraint = this.tsExpectThenParseType(types$1._in);
              return this.finishNode(node2, "TSTypeParameter");
            }
            tsParseMappedType() {
              const node2 = this.startNode();
              this.expect(types$1.braceL);
              if (this.match(types$1.plusMin)) {
                node2.readonly = this.state.value;
                this.next();
                this.expectContextual("readonly");
              } else if (this.eatContextual("readonly")) {
                node2.readonly = true;
              }
              this.expect(types$1.bracketL);
              node2.typeParameter = this.tsParseMappedTypeParameter();
              node2.nameType = this.eatContextual("as") ? this.tsParseType() : null;
              this.expect(types$1.bracketR);
              if (this.match(types$1.plusMin)) {
                node2.optional = this.state.value;
                this.next();
                this.expect(types$1.question);
              } else if (this.eat(types$1.question)) {
                node2.optional = true;
              }
              node2.typeAnnotation = this.tsTryParseType();
              this.semicolon();
              this.expect(types$1.braceR);
              return this.finishNode(node2, "TSMappedType");
            }
            tsParseTupleType() {
              const node2 = this.startNode();
              node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
              let seenOptionalElement = false;
              let labeledElements = null;
              node2.elementTypes.forEach((elementNode) => {
                var _labeledElements;
                let {type: type2} = elementNode;
                if (seenOptionalElement && type2 !== "TSRestType" && type2 !== "TSOptionalType" && !(type2 === "TSNamedTupleMember" && elementNode.optional)) {
                  this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
                }
                seenOptionalElement = seenOptionalElement || type2 === "TSNamedTupleMember" && elementNode.optional || type2 === "TSOptionalType";
                if (type2 === "TSRestType") {
                  elementNode = elementNode.typeAnnotation;
                  type2 = elementNode.type;
                }
                const isLabeled = type2 === "TSNamedTupleMember";
                labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;
                if (labeledElements !== isLabeled) {
                  this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
                }
              });
              return this.finishNode(node2, "TSTupleType");
            }
            tsParseTupleElementType() {
              const {start: startPos, startLoc} = this.state;
              const rest = this.eat(types$1.ellipsis);
              let type2 = this.tsParseType();
              const optional = this.eat(types$1.question);
              const labeled = this.eat(types$1.colon);
              if (labeled) {
                const labeledNode = this.startNodeAtNode(type2);
                labeledNode.optional = optional;
                if (type2.type === "TSTypeReference" && !type2.typeParameters && type2.typeName.type === "Identifier") {
                  labeledNode.label = type2.typeName;
                } else {
                  this.raise(type2.start, TSErrors.InvalidTupleMemberLabel);
                  labeledNode.label = type2;
                }
                labeledNode.elementType = this.tsParseType();
                type2 = this.finishNode(labeledNode, "TSNamedTupleMember");
              } else if (optional) {
                const optionalTypeNode = this.startNodeAtNode(type2);
                optionalTypeNode.typeAnnotation = type2;
                type2 = this.finishNode(optionalTypeNode, "TSOptionalType");
              }
              if (rest) {
                const restNode = this.startNodeAt(startPos, startLoc);
                restNode.typeAnnotation = type2;
                type2 = this.finishNode(restNode, "TSRestType");
              }
              return type2;
            }
            tsParseParenthesizedType() {
              const node2 = this.startNode();
              this.expect(types$1.parenL);
              node2.typeAnnotation = this.tsParseType();
              this.expect(types$1.parenR);
              return this.finishNode(node2, "TSParenthesizedType");
            }
            tsParseFunctionOrConstructorType(type2, abstract) {
              const node2 = this.startNode();
              if (type2 === "TSConstructorType") {
                node2.abstract = !!abstract;
                if (abstract)
                  this.next();
                this.next();
              }
              this.tsFillSignature(types$1.arrow, node2);
              return this.finishNode(node2, type2);
            }
            tsParseLiteralTypeNode() {
              const node2 = this.startNode();
              node2.literal = (() => {
                switch (this.state.type) {
                  case types$1.num:
                  case types$1.bigint:
                  case types$1.string:
                  case types$1._true:
                  case types$1._false:
                    return this.parseExprAtom();
                  default:
                    throw this.unexpected();
                }
              })();
              return this.finishNode(node2, "TSLiteralType");
            }
            tsParseTemplateLiteralType() {
              const node2 = this.startNode();
              node2.literal = this.parseTemplate(false);
              return this.finishNode(node2, "TSLiteralType");
            }
            parseTemplateSubstitution() {
              if (this.state.inType)
                return this.tsParseType();
              return super.parseTemplateSubstitution();
            }
            tsParseThisTypeOrThisTypePredicate() {
              const thisKeyword = this.tsParseThisTypeNode();
              if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
                return this.tsParseThisTypePredicate(thisKeyword);
              } else {
                return thisKeyword;
              }
            }
            tsParseNonArrayType() {
              switch (this.state.type) {
                case types$1.name:
                case types$1._void:
                case types$1._null: {
                  const type2 = this.match(types$1._void) ? "TSVoidKeyword" : this.match(types$1._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                  if (type2 !== void 0 && this.lookaheadCharCode() !== 46) {
                    const node2 = this.startNode();
                    this.next();
                    return this.finishNode(node2, type2);
                  }
                  return this.tsParseTypeReference();
                }
                case types$1.string:
                case types$1.num:
                case types$1.bigint:
                case types$1._true:
                case types$1._false:
                  return this.tsParseLiteralTypeNode();
                case types$1.plusMin:
                  if (this.state.value === "-") {
                    const node2 = this.startNode();
                    const nextToken = this.lookahead();
                    if (nextToken.type !== types$1.num && nextToken.type !== types$1.bigint) {
                      throw this.unexpected();
                    }
                    node2.literal = this.parseMaybeUnary();
                    return this.finishNode(node2, "TSLiteralType");
                  }
                  break;
                case types$1._this:
                  return this.tsParseThisTypeOrThisTypePredicate();
                case types$1._typeof:
                  return this.tsParseTypeQuery();
                case types$1._import:
                  return this.tsParseImportType();
                case types$1.braceL:
                  return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case types$1.bracketL:
                  return this.tsParseTupleType();
                case types$1.parenL:
                  return this.tsParseParenthesizedType();
                case types$1.backQuote:
                  return this.tsParseTemplateLiteralType();
              }
              throw this.unexpected();
            }
            tsParseArrayTypeOrHigher() {
              let type2 = this.tsParseNonArrayType();
              while (!this.hasPrecedingLineBreak() && this.eat(types$1.bracketL)) {
                if (this.match(types$1.bracketR)) {
                  const node2 = this.startNodeAtNode(type2);
                  node2.elementType = type2;
                  this.expect(types$1.bracketR);
                  type2 = this.finishNode(node2, "TSArrayType");
                } else {
                  const node2 = this.startNodeAtNode(type2);
                  node2.objectType = type2;
                  node2.indexType = this.tsParseType();
                  this.expect(types$1.bracketR);
                  type2 = this.finishNode(node2, "TSIndexedAccessType");
                }
              }
              return type2;
            }
            tsParseTypeOperator(operator) {
              const node2 = this.startNode();
              this.expectContextual(operator);
              node2.operator = operator;
              node2.typeAnnotation = this.tsParseTypeOperatorOrHigher();
              if (operator === "readonly") {
                this.tsCheckTypeAnnotationForReadOnly(node2);
              }
              return this.finishNode(node2, "TSTypeOperator");
            }
            tsCheckTypeAnnotationForReadOnly(node2) {
              switch (node2.typeAnnotation.type) {
                case "TSTupleType":
                case "TSArrayType":
                  return;
                default:
                  this.raise(node2.start, TSErrors.UnexpectedReadonly);
              }
            }
            tsParseInferType() {
              const node2 = this.startNode();
              this.expectContextual("infer");
              const typeParameter = this.startNode();
              typeParameter.name = this.parseIdentifierName(typeParameter.start);
              node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
              return this.finishNode(node2, "TSInferType");
            }
            tsParseTypeOperatorOrHigher() {
              const operator = ["keyof", "unique", "readonly"].find((kw) => this.isContextual(kw));
              return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
            }
            tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
              const node2 = this.startNode();
              const hasLeadingOperator = this.eat(operator);
              const types2 = [];
              do {
                types2.push(parseConstituentType());
              } while (this.eat(operator));
              if (types2.length === 1 && !hasLeadingOperator) {
                return types2[0];
              }
              node2.types = types2;
              return this.finishNode(node2, kind);
            }
            tsParseIntersectionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types$1.bitwiseAND);
            }
            tsParseUnionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types$1.bitwiseOR);
            }
            tsIsStartOfFunctionType() {
              if (this.isRelational("<")) {
                return true;
              }
              return this.match(types$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
            }
            tsSkipParameterStart() {
              if (this.match(types$1.name) || this.match(types$1._this)) {
                this.next();
                return true;
              }
              if (this.match(types$1.braceL)) {
                let braceStackCounter = 1;
                this.next();
                while (braceStackCounter > 0) {
                  if (this.match(types$1.braceL)) {
                    ++braceStackCounter;
                  } else if (this.match(types$1.braceR)) {
                    --braceStackCounter;
                  }
                  this.next();
                }
                return true;
              }
              if (this.match(types$1.bracketL)) {
                let braceStackCounter = 1;
                this.next();
                while (braceStackCounter > 0) {
                  if (this.match(types$1.bracketL)) {
                    ++braceStackCounter;
                  } else if (this.match(types$1.bracketR)) {
                    --braceStackCounter;
                  }
                  this.next();
                }
                return true;
              }
              return false;
            }
            tsIsUnambiguouslyStartOfFunctionType() {
              this.next();
              if (this.match(types$1.parenR) || this.match(types$1.ellipsis)) {
                return true;
              }
              if (this.tsSkipParameterStart()) {
                if (this.match(types$1.colon) || this.match(types$1.comma) || this.match(types$1.question) || this.match(types$1.eq)) {
                  return true;
                }
                if (this.match(types$1.parenR)) {
                  this.next();
                  if (this.match(types$1.arrow)) {
                    return true;
                  }
                }
              }
              return false;
            }
            tsParseTypeOrTypePredicateAnnotation(returnToken) {
              return this.tsInType(() => {
                const t = this.startNode();
                this.expect(returnToken);
                const node2 = this.startNode();
                const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (asserts && this.match(types$1._this)) {
                  let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                  if (thisTypePredicate.type === "TSThisType") {
                    node2.parameterName = thisTypePredicate;
                    node2.asserts = true;
                    thisTypePredicate = this.finishNode(node2, "TSTypePredicate");
                  } else {
                    this.resetStartLocationFromNode(thisTypePredicate, node2);
                    thisTypePredicate.asserts = true;
                  }
                  t.typeAnnotation = thisTypePredicate;
                  return this.finishNode(t, "TSTypeAnnotation");
                }
                const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!typePredicateVariable) {
                  if (!asserts) {
                    return this.tsParseTypeAnnotation(false, t);
                  }
                  node2.parameterName = this.parseIdentifier();
                  node2.asserts = asserts;
                  t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
                  return this.finishNode(t, "TSTypeAnnotation");
                }
                const type2 = this.tsParseTypeAnnotation(false);
                node2.parameterName = typePredicateVariable;
                node2.typeAnnotation = type2;
                node2.asserts = asserts;
                t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
                return this.finishNode(t, "TSTypeAnnotation");
              });
            }
            tsTryParseTypeOrTypePredicateAnnotation() {
              return this.match(types$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types$1.colon) : void 0;
            }
            tsTryParseTypeAnnotation() {
              return this.match(types$1.colon) ? this.tsParseTypeAnnotation() : void 0;
            }
            tsTryParseType() {
              return this.tsEatThenParseType(types$1.colon);
            }
            tsParseTypePredicatePrefix() {
              const id = this.parseIdentifier();
              if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
                this.next();
                return id;
              }
            }
            tsParseTypePredicateAsserts() {
              if (!this.match(types$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
                return false;
              }
              const containsEsc = this.state.containsEsc;
              this.next();
              if (!this.match(types$1.name) && !this.match(types$1._this)) {
                return false;
              }
              if (containsEsc) {
                this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
              }
              return true;
            }
            tsParseTypeAnnotation(eatColon, t) {
              if (eatColon === void 0) {
                eatColon = true;
              }
              if (t === void 0) {
                t = this.startNode();
              }
              this.tsInType(() => {
                if (eatColon)
                  this.expect(types$1.colon);
                t.typeAnnotation = this.tsParseType();
              });
              return this.finishNode(t, "TSTypeAnnotation");
            }
            tsParseType() {
              assert(this.state.inType);
              const type2 = this.tsParseNonConditionalType();
              if (this.hasPrecedingLineBreak() || !this.eat(types$1._extends)) {
                return type2;
              }
              const node2 = this.startNodeAtNode(type2);
              node2.checkType = type2;
              node2.extendsType = this.tsParseNonConditionalType();
              this.expect(types$1.question);
              node2.trueType = this.tsParseType();
              this.expect(types$1.colon);
              node2.falseType = this.tsParseType();
              return this.finishNode(node2, "TSConditionalType");
            }
            isAbstractConstructorSignature() {
              return this.isContextual("abstract") && this.lookahead().type === types$1._new;
            }
            tsParseNonConditionalType() {
              if (this.tsIsStartOfFunctionType()) {
                return this.tsParseFunctionOrConstructorType("TSFunctionType");
              }
              if (this.match(types$1._new)) {
                return this.tsParseFunctionOrConstructorType("TSConstructorType");
              } else if (this.isAbstractConstructorSignature()) {
                return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
              }
              return this.tsParseUnionTypeOrHigher();
            }
            tsParseTypeAssertion() {
              const node2 = this.startNode();
              const _const = this.tsTryNextParseConstantContext();
              node2.typeAnnotation = _const || this.tsNextThenParseType();
              this.expectRelational(">");
              node2.expression = this.parseMaybeUnary();
              return this.finishNode(node2, "TSTypeAssertion");
            }
            tsParseHeritageClause(descriptor) {
              const originalStart = this.state.start;
              const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
              if (!delimitedList.length) {
                this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
              }
              return delimitedList;
            }
            tsParseExpressionWithTypeArguments() {
              const node2 = this.startNode();
              node2.expression = this.tsParseEntityName(false);
              if (this.isRelational("<")) {
                node2.typeParameters = this.tsParseTypeArguments();
              }
              return this.finishNode(node2, "TSExpressionWithTypeArguments");
            }
            tsParseInterfaceDeclaration(node2) {
              node2.id = this.parseIdentifier();
              this.checkLVal(node2.id, "typescript interface declaration", BIND_TS_INTERFACE);
              node2.typeParameters = this.tsTryParseTypeParameters();
              if (this.eat(types$1._extends)) {
                node2.extends = this.tsParseHeritageClause("extends");
              }
              const body = this.startNode();
              body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
              node2.body = this.finishNode(body, "TSInterfaceBody");
              return this.finishNode(node2, "TSInterfaceDeclaration");
            }
            tsParseTypeAliasDeclaration(node2) {
              node2.id = this.parseIdentifier();
              this.checkLVal(node2.id, "typescript type alias", BIND_TS_TYPE);
              node2.typeParameters = this.tsTryParseTypeParameters();
              node2.typeAnnotation = this.tsInType(() => {
                this.expect(types$1.eq);
                if (this.isContextual("intrinsic") && this.lookahead().type !== types$1.dot) {
                  const node3 = this.startNode();
                  this.next();
                  return this.finishNode(node3, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
              });
              this.semicolon();
              return this.finishNode(node2, "TSTypeAliasDeclaration");
            }
            tsInNoContext(cb) {
              const oldContext = this.state.context;
              this.state.context = [oldContext[0]];
              try {
                return cb();
              } finally {
                this.state.context = oldContext;
              }
            }
            tsInType(cb) {
              const oldInType = this.state.inType;
              this.state.inType = true;
              try {
                return cb();
              } finally {
                this.state.inType = oldInType;
              }
            }
            tsEatThenParseType(token) {
              return !this.match(token) ? void 0 : this.tsNextThenParseType();
            }
            tsExpectThenParseType(token) {
              return this.tsDoThenParseType(() => this.expect(token));
            }
            tsNextThenParseType() {
              return this.tsDoThenParseType(() => this.next());
            }
            tsDoThenParseType(cb) {
              return this.tsInType(() => {
                cb();
                return this.tsParseType();
              });
            }
            tsParseEnumMember() {
              const node2 = this.startNode();
              node2.id = this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
              if (this.eat(types$1.eq)) {
                node2.initializer = this.parseMaybeAssignAllowIn();
              }
              return this.finishNode(node2, "TSEnumMember");
            }
            tsParseEnumDeclaration(node2, isConst) {
              if (isConst)
                node2.const = true;
              node2.id = this.parseIdentifier();
              this.checkLVal(node2.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
              this.expect(types$1.braceL);
              node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
              this.expect(types$1.braceR);
              return this.finishNode(node2, "TSEnumDeclaration");
            }
            tsParseModuleBlock() {
              const node2 = this.startNode();
              this.scope.enter(SCOPE_OTHER);
              this.expect(types$1.braceL);
              this.parseBlockOrModuleBlockBody(node2.body = [], void 0, true, types$1.braceR);
              this.scope.exit();
              return this.finishNode(node2, "TSModuleBlock");
            }
            tsParseModuleOrNamespaceDeclaration(node2, nested) {
              if (nested === void 0) {
                nested = false;
              }
              node2.id = this.parseIdentifier();
              if (!nested) {
                this.checkLVal(node2.id, "module or namespace declaration", BIND_TS_NAMESPACE);
              }
              if (this.eat(types$1.dot)) {
                const inner = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(inner, true);
                node2.body = inner;
              } else {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                node2.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
              }
              return this.finishNode(node2, "TSModuleDeclaration");
            }
            tsParseAmbientExternalModuleDeclaration(node2) {
              if (this.isContextual("global")) {
                node2.global = true;
                node2.id = this.parseIdentifier();
              } else if (this.match(types$1.string)) {
                node2.id = this.parseExprAtom();
              } else {
                this.unexpected();
              }
              if (this.match(types$1.braceL)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                node2.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
              } else {
                this.semicolon();
              }
              return this.finishNode(node2, "TSModuleDeclaration");
            }
            tsParseImportEqualsDeclaration(node2, isExport) {
              node2.isExport = isExport || false;
              node2.id = this.parseIdentifier();
              this.checkLVal(node2.id, "import equals declaration", BIND_LEXICAL);
              this.expect(types$1.eq);
              const moduleReference = this.tsParseModuleReference();
              if (node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
                this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
              }
              node2.moduleReference = moduleReference;
              this.semicolon();
              return this.finishNode(node2, "TSImportEqualsDeclaration");
            }
            tsIsExternalModuleReference() {
              return this.isContextual("require") && this.lookaheadCharCode() === 40;
            }
            tsParseModuleReference() {
              return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
            }
            tsParseExternalModuleReference() {
              const node2 = this.startNode();
              this.expectContextual("require");
              this.expect(types$1.parenL);
              if (!this.match(types$1.string)) {
                throw this.unexpected();
              }
              node2.expression = this.parseExprAtom();
              this.expect(types$1.parenR);
              return this.finishNode(node2, "TSExternalModuleReference");
            }
            tsLookAhead(f) {
              const state = this.state.clone();
              const res = f();
              this.state = state;
              return res;
            }
            tsTryParseAndCatch(f) {
              const result = this.tryParse((abort) => f() || abort());
              if (result.aborted || !result.node)
                return void 0;
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
            tsTryParse(f) {
              const state = this.state.clone();
              const result = f();
              if (result !== void 0 && result !== false) {
                return result;
              } else {
                this.state = state;
                return void 0;
              }
            }
            tsTryParseDeclare(nany) {
              if (this.isLineTerminator()) {
                return;
              }
              let starttype = this.state.type;
              let kind;
              if (this.isContextual("let")) {
                starttype = types$1._var;
                kind = "let";
              }
              return this.tsInAmbientContext(() => {
                switch (starttype) {
                  case types$1._function:
                    nany.declare = true;
                    return this.parseFunctionStatement(nany, false, true);
                  case types$1._class:
                    nany.declare = true;
                    return this.parseClass(nany, true, false);
                  case types$1._const:
                    if (this.match(types$1._const) && this.isLookaheadContextual("enum")) {
                      this.expect(types$1._const);
                      this.expectContextual("enum");
                      return this.tsParseEnumDeclaration(nany, true);
                    }
                  case types$1._var:
                    kind = kind || this.state.value;
                    return this.parseVarStatement(nany, kind);
                  case types$1.name: {
                    const value = this.state.value;
                    if (value === "global") {
                      return this.tsParseAmbientExternalModuleDeclaration(nany);
                    } else {
                      return this.tsParseDeclaration(nany, value, true);
                    }
                  }
                }
              });
            }
            tsTryParseExportDeclaration() {
              return this.tsParseDeclaration(this.startNode(), this.state.value, true);
            }
            tsParseExpressionStatement(node2, expr2) {
              switch (expr2.name) {
                case "declare": {
                  const declaration = this.tsTryParseDeclare(node2);
                  if (declaration) {
                    declaration.declare = true;
                    return declaration;
                  }
                  break;
                }
                case "global":
                  if (this.match(types$1.braceL)) {
                    this.scope.enter(SCOPE_TS_MODULE);
                    this.prodParam.enter(PARAM);
                    const mod = node2;
                    mod.global = true;
                    mod.id = expr2;
                    mod.body = this.tsParseModuleBlock();
                    this.scope.exit();
                    this.prodParam.exit();
                    return this.finishNode(mod, "TSModuleDeclaration");
                  }
                  break;
                default:
                  return this.tsParseDeclaration(node2, expr2.name, false);
              }
            }
            tsParseDeclaration(node2, value, next) {
              switch (value) {
                case "abstract":
                  if (this.tsCheckLineTerminator(next) && (this.match(types$1._class) || this.match(types$1.name))) {
                    return this.tsParseAbstractDeclaration(node2);
                  }
                  break;
                case "enum":
                  if (next || this.match(types$1.name)) {
                    if (next)
                      this.next();
                    return this.tsParseEnumDeclaration(node2, false);
                  }
                  break;
                case "interface":
                  if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                    return this.tsParseInterfaceDeclaration(node2);
                  }
                  break;
                case "module":
                  if (this.tsCheckLineTerminator(next)) {
                    if (this.match(types$1.string)) {
                      return this.tsParseAmbientExternalModuleDeclaration(node2);
                    } else if (this.match(types$1.name)) {
                      return this.tsParseModuleOrNamespaceDeclaration(node2);
                    }
                  }
                  break;
                case "namespace":
                  if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                    return this.tsParseModuleOrNamespaceDeclaration(node2);
                  }
                  break;
                case "type":
                  if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                    return this.tsParseTypeAliasDeclaration(node2);
                  }
                  break;
              }
            }
            tsCheckLineTerminator(next) {
              if (next) {
                if (this.hasFollowingLineBreak())
                  return false;
                this.next();
                return true;
              }
              return !this.isLineTerminator();
            }
            tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
              if (!this.isRelational("<")) {
                return void 0;
              }
              const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = true;
              const res = this.tsTryParseAndCatch(() => {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.typeParameters = this.tsParseTypeParameters();
                super.parseFunctionParams(node2);
                node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
                this.expect(types$1.arrow);
                return node2;
              });
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              if (!res) {
                return void 0;
              }
              return this.parseArrowExpression(res, null, true);
            }
            tsParseTypeArguments() {
              const node2 = this.startNode();
              node2.params = this.tsInType(() => this.tsInNoContext(() => {
                this.expectRelational("<");
                return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
              }));
              if (node2.params.length === 0) {
                this.raise(node2.start, TSErrors.EmptyTypeArguments);
              }
              this.state.exprAllowed = false;
              this.expectRelational(">");
              return this.finishNode(node2, "TSTypeParameterInstantiation");
            }
            tsIsDeclarationStart() {
              if (this.match(types$1.name)) {
                switch (this.state.value) {
                  case "abstract":
                  case "declare":
                  case "enum":
                  case "interface":
                  case "module":
                  case "namespace":
                  case "type":
                    return true;
                }
              }
              return false;
            }
            isExportDefaultSpecifier() {
              if (this.tsIsDeclarationStart())
                return false;
              return super.isExportDefaultSpecifier();
            }
            parseAssignableListItem(allowModifiers, decorators) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              let accessibility;
              let readonly = false;
              if (allowModifiers !== void 0) {
                accessibility = this.parseAccessModifier();
                readonly = !!this.tsParseModifier(["readonly"]);
                if (allowModifiers === false && (accessibility || readonly)) {
                  this.raise(startPos, TSErrors.UnexpectedParameterModifier);
                }
              }
              const left = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(left);
              const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
              if (accessibility || readonly) {
                const pp = this.startNodeAt(startPos, startLoc);
                if (decorators.length) {
                  pp.decorators = decorators;
                }
                if (accessibility)
                  pp.accessibility = accessibility;
                if (readonly)
                  pp.readonly = readonly;
                if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
                  this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
                }
                pp.parameter = elt;
                return this.finishNode(pp, "TSParameterProperty");
              }
              if (decorators.length) {
                left.decorators = decorators;
              }
              return elt;
            }
            parseFunctionBodyAndFinish(node2, type2, isMethod) {
              if (isMethod === void 0) {
                isMethod = false;
              }
              if (this.match(types$1.colon)) {
                node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
              }
              const bodilessType = type2 === "FunctionDeclaration" ? "TSDeclareFunction" : type2 === "ClassMethod" ? "TSDeclareMethod" : void 0;
              if (bodilessType && !this.match(types$1.braceL) && this.isLineTerminator()) {
                this.finishNode(node2, bodilessType);
                return;
              }
              if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
                this.raise(node2.start, TSErrors.DeclareFunctionHasImplementation);
                if (node2.declare) {
                  super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod);
                  return;
                }
              }
              super.parseFunctionBodyAndFinish(node2, type2, isMethod);
            }
            registerFunctionStatementId(node2) {
              if (!node2.body && node2.id) {
                this.checkLVal(node2.id, "function name", BIND_TS_AMBIENT);
              } else {
                super.registerFunctionStatementId(...arguments);
              }
            }
            tsCheckForInvalidTypeCasts(items) {
              items.forEach((node2) => {
                if ((node2 == null ? void 0 : node2.type) === "TSTypeCastExpression") {
                  this.raise(node2.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
                }
              });
            }
            toReferencedList(exprList, isInParens) {
              this.tsCheckForInvalidTypeCasts(exprList);
              return exprList;
            }
            parseArrayLike() {
              const node2 = super.parseArrayLike(...arguments);
              if (node2.type === "ArrayExpression") {
                this.tsCheckForInvalidTypeCasts(node2.elements);
              }
              return node2;
            }
            parseSubscript(base, startPos, startLoc, noCalls, state) {
              if (!this.hasPrecedingLineBreak() && this.match(types$1.bang)) {
                this.state.exprAllowed = false;
                this.next();
                const nonNullExpression = this.startNodeAt(startPos, startLoc);
                nonNullExpression.expression = base;
                return this.finishNode(nonNullExpression, "TSNonNullExpression");
              }
              if (this.isRelational("<")) {
                const result = this.tsTryParseAndCatch(() => {
                  if (!noCalls && this.atPossibleAsyncArrow(base)) {
                    const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                    if (asyncArrowFn) {
                      return asyncArrowFn;
                    }
                  }
                  const node2 = this.startNodeAt(startPos, startLoc);
                  node2.callee = base;
                  const typeArguments = this.tsParseTypeArguments();
                  if (typeArguments) {
                    if (!noCalls && this.eat(types$1.parenL)) {
                      node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                      this.tsCheckForInvalidTypeCasts(node2.arguments);
                      node2.typeParameters = typeArguments;
                      if (state.optionalChainMember) {
                        node2.optional = false;
                      }
                      return this.finishCallExpression(node2, state.optionalChainMember);
                    } else if (this.match(types$1.backQuote)) {
                      const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                      result2.typeParameters = typeArguments;
                      return result2;
                    }
                  }
                  this.unexpected();
                });
                if (result)
                  return result;
              }
              return super.parseSubscript(base, startPos, startLoc, noCalls, state);
            }
            parseNewArguments(node2) {
              if (this.isRelational("<")) {
                const typeParameters = this.tsTryParseAndCatch(() => {
                  const args = this.tsParseTypeArguments();
                  if (!this.match(types$1.parenL))
                    this.unexpected();
                  return args;
                });
                if (typeParameters) {
                  node2.typeParameters = typeParameters;
                }
              }
              super.parseNewArguments(node2);
            }
            parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
              if (nonNull(types$1._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
                const node2 = this.startNodeAt(leftStartPos, leftStartLoc);
                node2.expression = left;
                const _const = this.tsTryNextParseConstantContext();
                if (_const) {
                  node2.typeAnnotation = _const;
                } else {
                  node2.typeAnnotation = this.tsNextThenParseType();
                }
                this.finishNode(node2, "TSAsExpression");
                this.reScan_lt_gt();
                return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec);
              }
              return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
            }
            checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            }
            checkDuplicateExports() {
            }
            parseImport(node2) {
              node2.importKind = "value";
              if (this.match(types$1.name) || this.match(types$1.star) || this.match(types$1.braceL)) {
                let ahead = this.lookahead();
                if (this.isContextual("type") && ahead.type !== types$1.comma && !(ahead.type === types$1.name && ahead.value === "from") && ahead.type !== types$1.eq) {
                  node2.importKind = "type";
                  this.next();
                  ahead = this.lookahead();
                }
                if (this.match(types$1.name) && ahead.type === types$1.eq) {
                  return this.tsParseImportEqualsDeclaration(node2);
                }
              }
              const importNode = super.parseImport(node2);
              if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
                this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
              }
              return importNode;
            }
            parseExport(node2) {
              if (this.match(types$1._import)) {
                this.next();
                if (this.isContextual("type") && this.lookaheadCharCode() !== 61) {
                  node2.importKind = "type";
                  this.next();
                } else {
                  node2.importKind = "value";
                }
                return this.tsParseImportEqualsDeclaration(node2, true);
              } else if (this.eat(types$1.eq)) {
                const assign = node2;
                assign.expression = this.parseExpression();
                this.semicolon();
                return this.finishNode(assign, "TSExportAssignment");
              } else if (this.eatContextual("as")) {
                const decl = node2;
                this.expectContextual("namespace");
                decl.id = this.parseIdentifier();
                this.semicolon();
                return this.finishNode(decl, "TSNamespaceExportDeclaration");
              } else {
                if (this.isContextual("type") && this.lookahead().type === types$1.braceL) {
                  this.next();
                  node2.exportKind = "type";
                } else {
                  node2.exportKind = "value";
                }
                return super.parseExport(node2);
              }
            }
            isAbstractClass() {
              return this.isContextual("abstract") && this.lookahead().type === types$1._class;
            }
            parseExportDefaultExpression() {
              if (this.isAbstractClass()) {
                const cls = this.startNode();
                this.next();
                cls.abstract = true;
                this.parseClass(cls, true, true);
                return cls;
              }
              if (this.state.value === "interface") {
                const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
                if (result)
                  return result;
              }
              return super.parseExportDefaultExpression();
            }
            parseStatementContent(context, topLevel) {
              if (this.state.type === types$1._const) {
                const ahead = this.lookahead();
                if (ahead.type === types$1.name && ahead.value === "enum") {
                  const node2 = this.startNode();
                  this.expect(types$1._const);
                  this.expectContextual("enum");
                  return this.tsParseEnumDeclaration(node2, true);
                }
              }
              return super.parseStatementContent(context, topLevel);
            }
            parseAccessModifier() {
              return this.tsParseModifier(["public", "protected", "private"]);
            }
            tsHasSomeModifiers(member, modifiers) {
              return modifiers.some((modifier) => {
                if (tsIsAccessModifier(modifier)) {
                  return member.accessibility === modifier;
                }
                return !!member[modifier];
              });
            }
            parseClassMember(classBody, member, state) {
              const invalidModifersForStaticBlocks = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
              this.tsParseModifiers(member, invalidModifersForStaticBlocks.concat(["static"]));
              const callParseClassMemberWithIsStatic = () => {
                const isStatic = !!member.static;
                if (isStatic && this.eat(types$1.braceL)) {
                  if (this.tsHasSomeModifiers(member, invalidModifersForStaticBlocks)) {
                    this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);
                  }
                  this.parseClassStaticBlock(classBody, member);
                } else {
                  this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
                }
              };
              if (member.declare) {
                this.tsInAmbientContext(callParseClassMemberWithIsStatic);
              } else {
                callParseClassMemberWithIsStatic();
              }
            }
            parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
              const idx = this.tsTryParseIndexSignature(member);
              if (idx) {
                classBody.body.push(idx);
                if (member.abstract) {
                  this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
                }
                if (member.accessibility) {
                  this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
                }
                if (member.declare) {
                  this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
                }
                if (member.override) {
                  this.raise(member.start, TSErrors.IndexSignatureHasOverride);
                }
                return;
              }
              if (!this.state.inAbstractClass && member.abstract) {
                this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
              }
              if (member.override) {
                if (!state.hadSuperClass) {
                  this.raise(member.start, TSErrors.OverrideNotInSubClass);
                }
              }
              super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
            }
            parsePostMemberNameModifiers(methodOrProp) {
              const optional = this.eat(types$1.question);
              if (optional)
                methodOrProp.optional = true;
              if (methodOrProp.readonly && this.match(types$1.parenL)) {
                this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
              }
              if (methodOrProp.declare && this.match(types$1.parenL)) {
                this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
              }
            }
            parseExpressionStatement(node2, expr2) {
              const decl = expr2.type === "Identifier" ? this.tsParseExpressionStatement(node2, expr2) : void 0;
              return decl || super.parseExpressionStatement(node2, expr2);
            }
            shouldParseExportDeclaration() {
              if (this.tsIsDeclarationStart())
                return true;
              return super.shouldParseExportDeclaration();
            }
            parseConditional(expr2, startPos, startLoc, refNeedsArrowPos) {
              if (!refNeedsArrowPos || !this.match(types$1.question)) {
                return super.parseConditional(expr2, startPos, startLoc, refNeedsArrowPos);
              }
              const result = this.tryParse(() => super.parseConditional(expr2, startPos, startLoc));
              if (!result.node) {
                refNeedsArrowPos.start = result.error.pos || this.state.start;
                return expr2;
              }
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
            parseParenItem(node2, startPos, startLoc) {
              node2 = super.parseParenItem(node2, startPos, startLoc);
              if (this.eat(types$1.question)) {
                node2.optional = true;
                this.resetEndLocation(node2);
              }
              if (this.match(types$1.colon)) {
                const typeCastNode = this.startNodeAt(startPos, startLoc);
                typeCastNode.expression = node2;
                typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TSTypeCastExpression");
              }
              return node2;
            }
            parseExportDeclaration(node2) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const isDeclare = this.eatContextual("declare");
              if (isDeclare && (this.isContextual("declare") || !this.shouldParseExportDeclaration())) {
                throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
              }
              let declaration;
              if (this.match(types$1.name)) {
                declaration = this.tsTryParseExportDeclaration();
              }
              if (!declaration) {
                declaration = super.parseExportDeclaration(node2);
              }
              if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
                node2.exportKind = "type";
              }
              if (declaration && isDeclare) {
                this.resetStartLocation(declaration, startPos, startLoc);
                declaration.declare = true;
              }
              return declaration;
            }
            parseClassId(node2, isStatement, optionalId) {
              if ((!isStatement || optionalId) && this.isContextual("implements")) {
                return;
              }
              super.parseClassId(node2, isStatement, optionalId, node2.declare ? BIND_TS_AMBIENT : BIND_CLASS);
              const typeParameters = this.tsTryParseTypeParameters();
              if (typeParameters)
                node2.typeParameters = typeParameters;
            }
            parseClassPropertyAnnotation(node2) {
              if (!node2.optional && this.eat(types$1.bang)) {
                node2.definite = true;
              }
              const type2 = this.tsTryParseTypeAnnotation();
              if (type2)
                node2.typeAnnotation = type2;
            }
            parseClassProperty(node2) {
              this.parseClassPropertyAnnotation(node2);
              if (this.state.isAmbientContext && this.match(types$1.eq)) {
                this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
              }
              return super.parseClassProperty(node2);
            }
            parseClassPrivateProperty(node2) {
              if (node2.abstract) {
                this.raise(node2.start, TSErrors.PrivateElementHasAbstract);
              }
              if (node2.accessibility) {
                this.raise(node2.start, TSErrors.PrivateElementHasAccessibility, node2.accessibility);
              }
              this.parseClassPropertyAnnotation(node2);
              return super.parseClassPrivateProperty(node2);
            }
            pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
              const typeParameters = this.tsTryParseTypeParameters();
              if (typeParameters && isConstructor) {
                this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
              }
              if (method.declare && (method.kind === "get" || method.kind === "set")) {
                this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
              }
              if (typeParameters)
                method.typeParameters = typeParameters;
              super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
            }
            pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
              const typeParameters = this.tsTryParseTypeParameters();
              if (typeParameters)
                method.typeParameters = typeParameters;
              super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
            }
            parseClassSuper(node2) {
              super.parseClassSuper(node2);
              if (node2.superClass && this.isRelational("<")) {
                node2.superTypeParameters = this.tsParseTypeArguments();
              }
              if (this.eatContextual("implements")) {
                node2.implements = this.tsParseHeritageClause("implements");
              }
            }
            parseObjPropValue(prop2) {
              const typeParameters = this.tsTryParseTypeParameters();
              if (typeParameters)
                prop2.typeParameters = typeParameters;
              for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
                args[_key10 - 1] = arguments[_key10];
              }
              super.parseObjPropValue(prop2, ...args);
            }
            parseFunctionParams(node2, allowModifiers) {
              const typeParameters = this.tsTryParseTypeParameters();
              if (typeParameters)
                node2.typeParameters = typeParameters;
              super.parseFunctionParams(node2, allowModifiers);
            }
            parseVarId(decl, kind) {
              super.parseVarId(decl, kind);
              if (decl.id.type === "Identifier" && this.eat(types$1.bang)) {
                decl.definite = true;
              }
              const type2 = this.tsTryParseTypeAnnotation();
              if (type2) {
                decl.id.typeAnnotation = type2;
                this.resetEndLocation(decl.id);
              }
            }
            parseAsyncArrowFromCallExpression(node2, call) {
              if (this.match(types$1.colon)) {
                node2.returnType = this.tsParseTypeAnnotation();
              }
              return super.parseAsyncArrowFromCallExpression(node2, call);
            }
            parseMaybeAssign() {
              for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
                args[_key11] = arguments[_key11];
              }
              var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
              let state;
              let jsx2;
              let typeCast;
              if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
                state = this.state.clone();
                jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state);
                if (!jsx2.error)
                  return jsx2.node;
                const {context} = this.state;
                if (context[context.length - 1] === types$1$1.j_oTag) {
                  context.length -= 2;
                } else if (context[context.length - 1] === types$1$1.j_expr) {
                  context.length -= 1;
                }
              }
              if (!((_jsx = jsx2) != null && _jsx.error) && !this.isRelational("<")) {
                return super.parseMaybeAssign(...args);
              }
              let typeParameters;
              state = state || this.state.clone();
              const arrow = this.tryParse((abort) => {
                var _expr$extra, _typeParameters;
                typeParameters = this.tsParseTypeParameters();
                const expr2 = super.parseMaybeAssign(...args);
                if (expr2.type !== "ArrowFunctionExpression" || (_expr$extra = expr2.extra) != null && _expr$extra.parenthesized) {
                  abort();
                }
                if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
                  this.resetStartLocationFromNode(expr2, typeParameters);
                }
                expr2.typeParameters = typeParameters;
                return expr2;
              }, state);
              if (!arrow.error && !arrow.aborted)
                return arrow.node;
              if (!jsx2) {
                assert(!this.hasPlugin("jsx"));
                typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
                if (!typeCast.error)
                  return typeCast.node;
              }
              if ((_jsx2 = jsx2) != null && _jsx2.node) {
                this.state = jsx2.failState;
                return jsx2.node;
              }
              if (arrow.node) {
                this.state = arrow.failState;
                return arrow.node;
              }
              if ((_typeCast = typeCast) != null && _typeCast.node) {
                this.state = typeCast.failState;
                return typeCast.node;
              }
              if ((_jsx3 = jsx2) != null && _jsx3.thrown)
                throw jsx2.error;
              if (arrow.thrown)
                throw arrow.error;
              if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
                throw typeCast.error;
              throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
            }
            parseMaybeUnary(refExpressionErrors) {
              if (!this.hasPlugin("jsx") && this.isRelational("<")) {
                return this.tsParseTypeAssertion();
              } else {
                return super.parseMaybeUnary(refExpressionErrors);
              }
            }
            parseArrow(node2) {
              if (this.match(types$1.colon)) {
                const result = this.tryParse((abort) => {
                  const returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
                  if (this.canInsertSemicolon() || !this.match(types$1.arrow))
                    abort();
                  return returnType;
                });
                if (result.aborted)
                  return;
                if (!result.thrown) {
                  if (result.error)
                    this.state = result.failState;
                  node2.returnType = result.node;
                }
              }
              return super.parseArrow(node2);
            }
            parseAssignableListItemTypes(param) {
              if (this.eat(types$1.question)) {
                if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
                  this.raise(param.start, TSErrors.PatternIsOptional);
                }
                param.optional = true;
              }
              const type2 = this.tsTryParseTypeAnnotation();
              if (type2)
                param.typeAnnotation = type2;
              this.resetEndLocation(param);
              return param;
            }
            toAssignable(node2, isLHS) {
              if (isLHS === void 0) {
                isLHS = false;
              }
              switch (node2.type) {
                case "TSTypeCastExpression":
                  return super.toAssignable(this.typeCastToParameter(node2), isLHS);
                case "TSParameterProperty":
                  return super.toAssignable(node2, isLHS);
                case "ParenthesizedExpression":
                  return this.toAssignableParenthesizedExpression(node2, isLHS);
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                  node2.expression = this.toAssignable(node2.expression, isLHS);
                  return node2;
                default:
                  return super.toAssignable(node2, isLHS);
              }
            }
            toAssignableParenthesizedExpression(node2, isLHS) {
              switch (node2.expression.type) {
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                  node2.expression = this.toAssignable(node2.expression, isLHS);
                  return node2;
                default:
                  return super.toAssignable(node2, isLHS);
              }
            }
            checkLVal(expr2, contextDescription) {
              var _expr$extra2;
              for (var _len12 = arguments.length, args = new Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) {
                args[_key12 - 2] = arguments[_key12];
              }
              switch (expr2.type) {
                case "TSTypeCastExpression":
                  return;
                case "TSParameterProperty":
                  this.checkLVal(expr2.parameter, "parameter property", ...args);
                  return;
                case "TSAsExpression":
                case "TSTypeAssertion":
                  if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr2.extra) != null && _expr$extra2.parenthesized)) {
                    this.raise(expr2.start, ErrorMessages.InvalidLhs, contextDescription);
                    break;
                  }
                  this.checkLVal(expr2.expression, "parenthesized expression", ...args);
                  return;
                case "TSNonNullExpression":
                  this.checkLVal(expr2.expression, contextDescription, ...args);
                  return;
                default:
                  super.checkLVal(expr2, contextDescription, ...args);
                  return;
              }
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case types$1._this:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseMaybeDecoratorArguments(expr2) {
              if (this.isRelational("<")) {
                const typeArguments = this.tsParseTypeArguments();
                if (this.match(types$1.parenL)) {
                  const call = super.parseMaybeDecoratorArguments(expr2);
                  call.typeParameters = typeArguments;
                  return call;
                }
                this.unexpected(this.state.start, types$1.parenL);
              }
              return super.parseMaybeDecoratorArguments(expr2);
            }
            checkCommaAfterRest(close) {
              if (this.state.isAmbientContext && this.match(types$1.comma) && this.lookaheadCharCode() === close) {
                this.next();
              } else {
                super.checkCommaAfterRest(close);
              }
            }
            isClassMethod() {
              return this.isRelational("<") || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(types$1.bang) || this.match(types$1.colon) || super.isClassProperty();
            }
            parseMaybeDefault() {
              const node2 = super.parseMaybeDefault(...arguments);
              if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
                this.raise(node2.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
              }
              return node2;
            }
            getTokenFromCode(code) {
              if (this.state.inType && (code === 62 || code === 60)) {
                return this.finishOp(types$1.relational, 1);
              } else {
                return super.getTokenFromCode(code);
              }
            }
            reScan_lt_gt() {
              if (this.match(types$1.relational)) {
                const code = this.input.charCodeAt(this.state.start);
                if (code === 60 || code === 62) {
                  this.state.pos -= 1;
                  this.readToken_lt_gt(code);
                }
              }
            }
            toAssignableList(exprList) {
              for (let i = 0; i < exprList.length; i++) {
                const expr2 = exprList[i];
                if (!expr2)
                  continue;
                switch (expr2.type) {
                  case "TSTypeCastExpression":
                    exprList[i] = this.typeCastToParameter(expr2);
                    break;
                  case "TSAsExpression":
                  case "TSTypeAssertion":
                    if (!this.state.maybeInArrowParameters) {
                      exprList[i] = this.typeCastToParameter(expr2);
                    } else {
                      this.raise(expr2.start, TSErrors.UnexpectedTypeCastInParameter);
                    }
                    break;
                }
              }
              return super.toAssignableList(...arguments);
            }
            typeCastToParameter(node2) {
              node2.expression.typeAnnotation = node2.typeAnnotation;
              this.resetEndLocation(node2.expression, node2.typeAnnotation.end, node2.typeAnnotation.loc.end);
              return node2.expression;
            }
            shouldParseArrow() {
              return this.match(types$1.colon) || super.shouldParseArrow();
            }
            shouldParseAsyncArrow() {
              return this.match(types$1.colon) || super.shouldParseAsyncArrow();
            }
            canHaveLeadingDecorator() {
              return super.canHaveLeadingDecorator() || this.isAbstractClass();
            }
            jsxParseOpeningElementAfterName(node2) {
              if (this.isRelational("<")) {
                const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
                if (typeArguments)
                  node2.typeParameters = typeArguments;
              }
              return super.jsxParseOpeningElementAfterName(node2);
            }
            getGetterSetterExpectedParamCount(method) {
              const baseCount = super.getGetterSetterExpectedParamCount(method);
              const params = this.getObjectOrClassMethodParams(method);
              const firstParam = params[0];
              const hasContextParam = firstParam && this.isThisParam(firstParam);
              return hasContextParam ? baseCount + 1 : baseCount;
            }
            parseCatchClauseParam() {
              const param = super.parseCatchClauseParam();
              const type2 = this.tsTryParseTypeAnnotation();
              if (type2) {
                param.typeAnnotation = type2;
                this.resetEndLocation(param);
              }
              return param;
            }
            tsInAmbientContext(cb) {
              const oldIsAmbientContext = this.state.isAmbientContext;
              this.state.isAmbientContext = true;
              try {
                return cb();
              } finally {
                this.state.isAmbientContext = oldIsAmbientContext;
              }
            }
            parseClass(node2) {
              const oldInAbstractClass = this.state.inAbstractClass;
              this.state.inAbstractClass = !!node2.abstract;
              try {
                for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
                  args[_key13 - 1] = arguments[_key13];
                }
                return super.parseClass(node2, ...args);
              } finally {
                this.state.inAbstractClass = oldInAbstractClass;
              }
            }
            tsParseAbstractDeclaration(node2) {
              if (this.match(types$1._class)) {
                node2.abstract = true;
                return this.parseClass(node2, true, false);
              } else if (this.isContextual("interface")) {
                if (!this.hasFollowingLineBreak()) {
                  node2.abstract = true;
                  this.raise(node2.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
                  this.next();
                  return this.tsParseInterfaceDeclaration(node2);
                }
              } else {
                this.unexpected(null, types$1._class);
              }
            }
            parseMethod() {
              const method = super.parseMethod(...arguments);
              if (method.abstract) {
                const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
                if (hasBody) {
                  const {key} = method;
                  this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === "Identifier" ? key.name : `[${this.input.slice(key.start, key.end)}]`);
                }
              }
              return method;
            }
            shouldParseAsAmbientContext() {
              return !!this.getPluginOption("typescript", "dts");
            }
            parse() {
              if (this.shouldParseAsAmbientContext()) {
                this.state.isAmbientContext = true;
              }
              return super.parse();
            }
            getExpression() {
              if (this.shouldParseAsAmbientContext()) {
                this.state.isAmbientContext = true;
              }
              return super.getExpression();
            }
          };
          types$1.placeholder = new TokenType("%%", {startsExpr: true});
          const PlaceHolderErrors = makeErrorTemplates({ClassNameIsRequired: "A class name is required."}, ErrorCodes.SyntaxError);
          var placeholders = (superClass) => class extends superClass {
            parsePlaceholder(expectedNode) {
              if (this.match(types$1.placeholder)) {
                const node2 = this.startNode();
                this.next();
                this.assertNoSpace("Unexpected space in placeholder.");
                node2.name = super.parseIdentifier(true);
                this.assertNoSpace("Unexpected space in placeholder.");
                this.expect(types$1.placeholder);
                return this.finishPlaceholder(node2, expectedNode);
              }
            }
            finishPlaceholder(node2, expectedNode) {
              const isFinished = !!(node2.expectedNode && node2.type === "Placeholder");
              node2.expectedNode = expectedNode;
              return isFinished ? node2 : this.finishNode(node2, "Placeholder");
            }
            getTokenFromCode(code) {
              if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
                return this.finishOp(types$1.placeholder, 2);
              }
              return super.getTokenFromCode(...arguments);
            }
            parseExprAtom() {
              return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
            }
            parseIdentifier() {
              return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
            }
            checkReservedWord(word) {
              if (word !== void 0)
                super.checkReservedWord(...arguments);
            }
            parseBindingAtom() {
              return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
            }
            checkLVal(expr2) {
              if (expr2.type !== "Placeholder")
                super.checkLVal(...arguments);
            }
            toAssignable(node2) {
              if (node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression") {
                node2.expectedNode = "Pattern";
                return node2;
              }
              return super.toAssignable(...arguments);
            }
            isLet(context) {
              if (super.isLet(context)) {
                return true;
              }
              if (!this.isContextual("let")) {
                return false;
              }
              if (context)
                return false;
              const nextToken = this.lookahead();
              if (nextToken.type === types$1.placeholder) {
                return true;
              }
              return false;
            }
            verifyBreakContinue(node2) {
              if (node2.label && node2.label.type === "Placeholder")
                return;
              super.verifyBreakContinue(...arguments);
            }
            parseExpressionStatement(node2, expr2) {
              if (expr2.type !== "Placeholder" || expr2.extra && expr2.extra.parenthesized) {
                return super.parseExpressionStatement(...arguments);
              }
              if (this.match(types$1.colon)) {
                const stmt = node2;
                stmt.label = this.finishPlaceholder(expr2, "Identifier");
                this.next();
                stmt.body = this.parseStatement("label");
                return this.finishNode(stmt, "LabeledStatement");
              }
              this.semicolon();
              node2.name = expr2.name;
              return this.finishPlaceholder(node2, "Statement");
            }
            parseBlock() {
              return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
            }
            parseFunctionId() {
              return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
            }
            parseClass(node2, isStatement, optionalId) {
              const type2 = isStatement ? "ClassDeclaration" : "ClassExpression";
              this.next();
              this.takeDecorators(node2);
              const oldStrict = this.state.strict;
              const placeholder = this.parsePlaceholder("Identifier");
              if (placeholder) {
                if (this.match(types$1._extends) || this.match(types$1.placeholder) || this.match(types$1.braceL)) {
                  node2.id = placeholder;
                } else if (optionalId || !isStatement) {
                  node2.id = null;
                  node2.body = this.finishPlaceholder(placeholder, "ClassBody");
                  return this.finishNode(node2, type2);
                } else {
                  this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
                }
              } else {
                this.parseClassId(node2, isStatement, optionalId);
              }
              this.parseClassSuper(node2);
              node2.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node2.superClass, oldStrict);
              return this.finishNode(node2, type2);
            }
            parseExport(node2) {
              const placeholder = this.parsePlaceholder("Identifier");
              if (!placeholder)
                return super.parseExport(...arguments);
              if (!this.isContextual("from") && !this.match(types$1.comma)) {
                node2.specifiers = [];
                node2.source = null;
                node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
                return this.finishNode(node2, "ExportNamedDeclaration");
              }
              this.expectPlugin("exportDefaultFrom");
              const specifier = this.startNode();
              specifier.exported = placeholder;
              node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
              return super.parseExport(node2);
            }
            isExportDefaultSpecifier() {
              if (this.match(types$1._default)) {
                const next = this.nextTokenStart();
                if (this.isUnparsedContextual(next, "from")) {
                  if (this.input.startsWith(types$1.placeholder.label, this.nextTokenStartSince(next + 4))) {
                    return true;
                  }
                }
              }
              return super.isExportDefaultSpecifier();
            }
            maybeParseExportDefaultSpecifier(node2) {
              if (node2.specifiers && node2.specifiers.length > 0) {
                return true;
              }
              return super.maybeParseExportDefaultSpecifier(...arguments);
            }
            checkExport(node2) {
              const {specifiers} = node2;
              if (specifiers != null && specifiers.length) {
                node2.specifiers = specifiers.filter((node3) => node3.exported.type === "Placeholder");
              }
              super.checkExport(node2);
              node2.specifiers = specifiers;
            }
            parseImport(node2) {
              const placeholder = this.parsePlaceholder("Identifier");
              if (!placeholder)
                return super.parseImport(...arguments);
              node2.specifiers = [];
              if (!this.isContextual("from") && !this.match(types$1.comma)) {
                node2.source = this.finishPlaceholder(placeholder, "StringLiteral");
                this.semicolon();
                return this.finishNode(node2, "ImportDeclaration");
              }
              const specifier = this.startNodeAtNode(placeholder);
              specifier.local = placeholder;
              this.finishNode(specifier, "ImportDefaultSpecifier");
              node2.specifiers.push(specifier);
              if (this.eat(types$1.comma)) {
                const hasStarImport = this.maybeParseStarImportSpecifier(node2);
                if (!hasStarImport)
                  this.parseNamedImportSpecifiers(node2);
              }
              this.expectContextual("from");
              node2.source = this.parseImportSource();
              this.semicolon();
              return this.finishNode(node2, "ImportDeclaration");
            }
            parseImportSource() {
              return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
            }
          };
          var v8intrinsic = (superClass) => class extends superClass {
            parseV8Intrinsic() {
              if (this.match(types$1.modulo)) {
                const v8IntrinsicStart = this.state.start;
                const node2 = this.startNode();
                this.eat(types$1.modulo);
                if (this.match(types$1.name)) {
                  const name2 = this.parseIdentifierName(this.state.start);
                  const identifier = this.createIdentifier(node2, name2);
                  identifier.type = "V8IntrinsicIdentifier";
                  if (this.match(types$1.parenL)) {
                    return identifier;
                  }
                }
                this.unexpected(v8IntrinsicStart);
              }
            }
            parseExprAtom() {
              return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
            }
          };
          function hasPlugin(plugins, name2) {
            return plugins.some((plugin) => {
              if (Array.isArray(plugin)) {
                return plugin[0] === name2;
              } else {
                return plugin === name2;
              }
            });
          }
          function getPluginOption(plugins, name2, option) {
            const plugin = plugins.find((plugin2) => {
              if (Array.isArray(plugin2)) {
                return plugin2[0] === name2;
              } else {
                return plugin2 === name2;
              }
            });
            if (plugin && Array.isArray(plugin)) {
              return plugin[1][option];
            }
            return null;
          }
          const PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
          const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
          function validatePlugins(plugins) {
            if (hasPlugin(plugins, "decorators")) {
              if (hasPlugin(plugins, "decorators-legacy")) {
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              }
              const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
              if (decoratorsBeforeExport == null) {
                throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
              } else if (typeof decoratorsBeforeExport !== "boolean") {
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
              }
            }
            if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
              throw new Error("Cannot combine flow and typescript plugins.");
            }
            if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            }
            if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
              throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map((p) => `'${p}'`).join(", "));
            }
            if (hasPlugin(plugins, "moduleAttributes")) {
              if (hasPlugin(plugins, "importAssertions")) {
                throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
              }
              const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
              if (moduleAttributesVerionPluginOption !== "may-2020") {
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
              }
            }
            if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
              throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            }
            if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
              const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              error.missingPlugins = "doExpressions";
              throw error;
            }
          }
          const mixinPlugins = {estree, jsx, flow, typescript, v8intrinsic, placeholders};
          const mixinPluginNames = Object.keys(mixinPlugins);
          const defaultOptions = {sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false};
          function getOptions(opts) {
            const options2 = {};
            for (const key of Object.keys(defaultOptions)) {
              options2[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
            }
            return options2;
          }
          class State {
            constructor() {
              this.strict = void 0;
              this.curLine = void 0;
              this.startLoc = void 0;
              this.endLoc = void 0;
              this.errors = [];
              this.potentialArrowAt = -1;
              this.noArrowAt = [];
              this.noArrowParamsConversionAt = [];
              this.maybeInArrowParameters = false;
              this.inPipeline = false;
              this.inType = false;
              this.noAnonFunctionType = false;
              this.inPropertyName = false;
              this.hasFlowComment = false;
              this.isIterator = false;
              this.isAmbientContext = false;
              this.inAbstractClass = false;
              this.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
              this.soloAwait = false;
              this.inFSharpPipelineDirectBody = false;
              this.labels = [];
              this.decoratorStack = [[]];
              this.comments = [];
              this.trailingComments = [];
              this.leadingComments = [];
              this.commentStack = [];
              this.commentPreviousNode = null;
              this.pos = 0;
              this.lineStart = 0;
              this.type = types$1.eof;
              this.value = null;
              this.start = 0;
              this.end = 0;
              this.lastTokEndLoc = null;
              this.lastTokStartLoc = null;
              this.lastTokStart = 0;
              this.lastTokEnd = 0;
              this.context = [types$1$1.braceStatement];
              this.exprAllowed = true;
              this.containsEsc = false;
              this.strictErrors = new Map();
              this.exportedIdentifiers = [];
              this.tokensLength = 0;
            }
            init(options2) {
              this.strict = options2.strictMode === false ? false : options2.sourceType === "module";
              this.curLine = options2.startLine;
              this.startLoc = this.endLoc = this.curPosition();
            }
            curPosition() {
              return new Position(this.curLine, this.pos - this.lineStart);
            }
            clone(skipArrays) {
              const state = new State();
              const keys = Object.keys(this);
              for (let i = 0, length = keys.length; i < length; i++) {
                const key = keys[i];
                let val = this[key];
                if (!skipArrays && Array.isArray(val)) {
                  val = val.slice();
                }
                state[key] = val;
              }
              return state;
            }
          }
          var _isDigit = function isDigit(code) {
            return code >= 48 && code <= 57;
          };
          const VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
          const forbiddenNumericSeparatorSiblings = {decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120]};
          const allowedNumericSeparatorSiblings = {};
          allowedNumericSeparatorSiblings.bin = [48, 49];
          allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
          allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
          allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
          class Token {
            constructor(state) {
              this.type = state.type;
              this.value = state.value;
              this.start = state.start;
              this.end = state.end;
              this.loc = new SourceLocation(state.startLoc, state.endLoc);
            }
          }
          class Tokenizer extends ParserError {
            constructor(options2, input) {
              super();
              this.isLookahead = void 0;
              this.tokens = [];
              this.state = new State();
              this.state.init(options2);
              this.input = input;
              this.length = input.length;
              this.isLookahead = false;
            }
            pushToken(token) {
              this.tokens.length = this.state.tokensLength;
              this.tokens.push(token);
              ++this.state.tokensLength;
            }
            next() {
              if (!this.isLookahead) {
                this.checkKeywordEscapes();
                if (this.options.tokens) {
                  this.pushToken(new Token(this.state));
                }
              }
              this.state.lastTokEnd = this.state.end;
              this.state.lastTokStart = this.state.start;
              this.state.lastTokEndLoc = this.state.endLoc;
              this.state.lastTokStartLoc = this.state.startLoc;
              this.nextToken();
            }
            eat(type2) {
              if (this.match(type2)) {
                this.next();
                return true;
              } else {
                return false;
              }
            }
            match(type2) {
              return this.state.type === type2;
            }
            lookahead() {
              const old = this.state;
              this.state = old.clone(true);
              this.isLookahead = true;
              this.next();
              this.isLookahead = false;
              const curr = this.state;
              this.state = old;
              return curr;
            }
            nextTokenStart() {
              return this.nextTokenStartSince(this.state.pos);
            }
            nextTokenStartSince(pos) {
              skipWhiteSpace.lastIndex = pos;
              const skip = skipWhiteSpace.exec(this.input);
              return pos + skip[0].length;
            }
            lookaheadCharCode() {
              return this.input.charCodeAt(this.nextTokenStart());
            }
            setStrict(strict) {
              this.state.strict = strict;
              if (strict) {
                this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));
                this.state.strictErrors.clear();
              }
            }
            curContext() {
              return this.state.context[this.state.context.length - 1];
            }
            nextToken() {
              const curContext = this.curContext();
              if (!(curContext != null && curContext.preserveSpace))
                this.skipSpace();
              this.state.start = this.state.pos;
              this.state.startLoc = this.state.curPosition();
              if (this.state.pos >= this.length) {
                this.finishToken(types$1.eof);
                return;
              }
              const override = curContext == null ? void 0 : curContext.override;
              if (override) {
                override(this);
              } else {
                this.getTokenFromCode(this.input.codePointAt(this.state.pos));
              }
            }
            pushComment(block, text2, start, end, startLoc, endLoc) {
              const comment2 = {type: block ? "CommentBlock" : "CommentLine", value: text2, start, end, loc: new SourceLocation(startLoc, endLoc)};
              if (this.options.tokens)
                this.pushToken(comment2);
              this.state.comments.push(comment2);
              this.addComment(comment2);
            }
            skipBlockComment() {
              const startLoc = this.state.curPosition();
              const start = this.state.pos;
              const end = this.input.indexOf("*/", this.state.pos + 2);
              if (end === -1)
                throw this.raise(start, ErrorMessages.UnterminatedComment);
              this.state.pos = end + 2;
              lineBreakG.lastIndex = start;
              let match;
              while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
                ++this.state.curLine;
                this.state.lineStart = match.index + match[0].length;
              }
              if (this.isLookahead)
                return;
              this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
            }
            skipLineComment(startSkip) {
              const start = this.state.pos;
              const startLoc = this.state.curPosition();
              let ch = this.input.charCodeAt(this.state.pos += startSkip);
              if (this.state.pos < this.length) {
                while (!isNewLine(ch) && ++this.state.pos < this.length) {
                  ch = this.input.charCodeAt(this.state.pos);
                }
              }
              if (this.isLookahead)
                return;
              this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
            }
            skipSpace() {
              loop:
                while (this.state.pos < this.length) {
                  const ch = this.input.charCodeAt(this.state.pos);
                  switch (ch) {
                    case 32:
                    case 160:
                    case 9:
                      ++this.state.pos;
                      break;
                    case 13:
                      if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                        ++this.state.pos;
                      }
                    case 10:
                    case 8232:
                    case 8233:
                      ++this.state.pos;
                      ++this.state.curLine;
                      this.state.lineStart = this.state.pos;
                      break;
                    case 47:
                      switch (this.input.charCodeAt(this.state.pos + 1)) {
                        case 42:
                          this.skipBlockComment();
                          break;
                        case 47:
                          this.skipLineComment(2);
                          break;
                        default:
                          break loop;
                      }
                      break;
                    default:
                      if (isWhitespace(ch)) {
                        ++this.state.pos;
                      } else {
                        break loop;
                      }
                  }
                }
            }
            finishToken(type2, val) {
              this.state.end = this.state.pos;
              this.state.endLoc = this.state.curPosition();
              const prevType = this.state.type;
              this.state.type = type2;
              this.state.value = val;
              if (!this.isLookahead)
                this.updateContext(prevType);
            }
            readToken_numberSign() {
              if (this.state.pos === 0 && this.readToken_interpreter()) {
                return;
              }
              const nextPos = this.state.pos + 1;
              const next = this.input.charCodeAt(nextPos);
              if (next >= 48 && next <= 57) {
                throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
              }
              if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
                this.expectPlugin("recordAndTuple");
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
                  throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
                }
                if (next === 123) {
                  this.finishToken(types$1.braceHashL);
                } else {
                  this.finishToken(types$1.bracketHashL);
                }
                this.state.pos += 2;
              } else {
                this.finishOp(types$1.hash, 1);
              }
            }
            readToken_dot() {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next >= 48 && next <= 57) {
                this.readNumber(true);
                return;
              }
              if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
                this.state.pos += 3;
                this.finishToken(types$1.ellipsis);
              } else {
                ++this.state.pos;
                this.finishToken(types$1.dot);
              }
            }
            readToken_slash() {
              if (this.state.exprAllowed && !this.state.inType) {
                ++this.state.pos;
                this.readRegexp();
                return;
              }
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 61) {
                this.finishOp(types$1.assign, 2);
              } else {
                this.finishOp(types$1.slash, 1);
              }
            }
            readToken_interpreter() {
              if (this.state.pos !== 0 || this.length < 2)
                return false;
              let ch = this.input.charCodeAt(this.state.pos + 1);
              if (ch !== 33)
                return false;
              const start = this.state.pos;
              this.state.pos += 1;
              while (!isNewLine(ch) && ++this.state.pos < this.length) {
                ch = this.input.charCodeAt(this.state.pos);
              }
              const value = this.input.slice(start + 2, this.state.pos);
              this.finishToken(types$1.interpreterDirective, value);
              return true;
            }
            readToken_mult_modulo(code) {
              let type2 = code === 42 ? types$1.star : types$1.modulo;
              let width = 1;
              let next = this.input.charCodeAt(this.state.pos + 1);
              const exprAllowed = this.state.exprAllowed;
              if (code === 42 && next === 42) {
                width++;
                next = this.input.charCodeAt(this.state.pos + 2);
                type2 = types$1.exponent;
              }
              if (next === 61 && !exprAllowed) {
                width++;
                type2 = types$1.assign;
              }
              this.finishOp(type2, width);
            }
            readToken_pipe_amp(code) {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === code) {
                if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                  this.finishOp(types$1.assign, 3);
                } else {
                  this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
                }
                return;
              }
              if (code === 124) {
                if (next === 62) {
                  this.finishOp(types$1.pipeline, 2);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && next === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                    throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
                  }
                  this.finishOp(types$1.braceBarR, 2);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && next === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                    throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
                  }
                  this.finishOp(types$1.bracketBarR, 2);
                  return;
                }
              }
              if (next === 61) {
                this.finishOp(types$1.assign, 2);
                return;
              }
              this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
            }
            readToken_caret() {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 61) {
                this.finishOp(types$1.assign, 2);
              } else {
                this.finishOp(types$1.bitwiseXOR, 1);
              }
            }
            readToken_plus_min(code) {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === code) {
                if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {
                  this.skipLineComment(3);
                  this.skipSpace();
                  this.nextToken();
                  return;
                }
                this.finishOp(types$1.incDec, 2);
                return;
              }
              if (next === 61) {
                this.finishOp(types$1.assign, 2);
              } else {
                this.finishOp(types$1.plusMin, 1);
              }
            }
            readToken_lt_gt(code) {
              const next = this.input.charCodeAt(this.state.pos + 1);
              let size = 1;
              if (next === code) {
                size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(this.state.pos + size) === 61) {
                  this.finishOp(types$1.assign, size + 1);
                  return;
                }
                this.finishOp(types$1.bitShift, size);
                return;
              }
              if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
                this.skipLineComment(4);
                this.skipSpace();
                this.nextToken();
                return;
              }
              if (next === 61) {
                size = 2;
              }
              this.finishOp(types$1.relational, size);
            }
            readToken_eq_excl(code) {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 61) {
                this.finishOp(types$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                return;
              }
              if (code === 61 && next === 62) {
                this.state.pos += 2;
                this.finishToken(types$1.arrow);
                return;
              }
              this.finishOp(code === 61 ? types$1.eq : types$1.bang, 1);
            }
            readToken_question() {
              const next = this.input.charCodeAt(this.state.pos + 1);
              const next2 = this.input.charCodeAt(this.state.pos + 2);
              if (next === 63) {
                if (next2 === 61) {
                  this.finishOp(types$1.assign, 3);
                } else {
                  this.finishOp(types$1.nullishCoalescing, 2);
                }
              } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
                this.state.pos += 2;
                this.finishToken(types$1.questionDot);
              } else {
                ++this.state.pos;
                this.finishToken(types$1.question);
              }
            }
            getTokenFromCode(code) {
              switch (code) {
                case 46:
                  this.readToken_dot();
                  return;
                case 40:
                  ++this.state.pos;
                  this.finishToken(types$1.parenL);
                  return;
                case 41:
                  ++this.state.pos;
                  this.finishToken(types$1.parenR);
                  return;
                case 59:
                  ++this.state.pos;
                  this.finishToken(types$1.semi);
                  return;
                case 44:
                  ++this.state.pos;
                  this.finishToken(types$1.comma);
                  return;
                case 91:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                      throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
                    }
                    this.finishToken(types$1.bracketBarL);
                    this.state.pos += 2;
                  } else {
                    ++this.state.pos;
                    this.finishToken(types$1.bracketL);
                  }
                  return;
                case 93:
                  ++this.state.pos;
                  this.finishToken(types$1.bracketR);
                  return;
                case 123:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                      throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
                    }
                    this.finishToken(types$1.braceBarL);
                    this.state.pos += 2;
                  } else {
                    ++this.state.pos;
                    this.finishToken(types$1.braceL);
                  }
                  return;
                case 125:
                  ++this.state.pos;
                  this.finishToken(types$1.braceR);
                  return;
                case 58:
                  if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                    this.finishOp(types$1.doubleColon, 2);
                  } else {
                    ++this.state.pos;
                    this.finishToken(types$1.colon);
                  }
                  return;
                case 63:
                  this.readToken_question();
                  return;
                case 96:
                  ++this.state.pos;
                  this.finishToken(types$1.backQuote);
                  return;
                case 48: {
                  const next = this.input.charCodeAt(this.state.pos + 1);
                  if (next === 120 || next === 88) {
                    this.readRadixNumber(16);
                    return;
                  }
                  if (next === 111 || next === 79) {
                    this.readRadixNumber(8);
                    return;
                  }
                  if (next === 98 || next === 66) {
                    this.readRadixNumber(2);
                    return;
                  }
                }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  this.readNumber(false);
                  return;
                case 34:
                case 39:
                  this.readString(code);
                  return;
                case 47:
                  this.readToken_slash();
                  return;
                case 37:
                case 42:
                  this.readToken_mult_modulo(code);
                  return;
                case 124:
                case 38:
                  this.readToken_pipe_amp(code);
                  return;
                case 94:
                  this.readToken_caret();
                  return;
                case 43:
                case 45:
                  this.readToken_plus_min(code);
                  return;
                case 60:
                case 62:
                  this.readToken_lt_gt(code);
                  return;
                case 61:
                case 33:
                  this.readToken_eq_excl(code);
                  return;
                case 126:
                  this.finishOp(types$1.tilde, 1);
                  return;
                case 64:
                  ++this.state.pos;
                  this.finishToken(types$1.at);
                  return;
                case 35:
                  this.readToken_numberSign();
                  return;
                case 92:
                  this.readWord();
                  return;
                default:
                  if (isIdentifierStart(code)) {
                    this.readWord();
                    return;
                  }
              }
              throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
            }
            finishOp(type2, size) {
              const str = this.input.slice(this.state.pos, this.state.pos + size);
              this.state.pos += size;
              this.finishToken(type2, str);
            }
            readRegexp() {
              const start = this.state.pos;
              let escaped, inClass;
              for (; ; ) {
                if (this.state.pos >= this.length) {
                  throw this.raise(start, ErrorMessages.UnterminatedRegExp);
                }
                const ch = this.input.charAt(this.state.pos);
                if (lineBreak.test(ch)) {
                  throw this.raise(start, ErrorMessages.UnterminatedRegExp);
                }
                if (escaped) {
                  escaped = false;
                } else {
                  if (ch === "[") {
                    inClass = true;
                  } else if (ch === "]" && inClass) {
                    inClass = false;
                  } else if (ch === "/" && !inClass) {
                    break;
                  }
                  escaped = ch === "\\";
                }
                ++this.state.pos;
              }
              const content = this.input.slice(start, this.state.pos);
              ++this.state.pos;
              let mods = "";
              while (this.state.pos < this.length) {
                const char = this.input[this.state.pos];
                const charCode = this.input.codePointAt(this.state.pos);
                if (VALID_REGEX_FLAGS.has(char)) {
                  if (mods.indexOf(char) > -1) {
                    this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);
                  }
                } else if (isIdentifierChar(charCode) || charCode === 92) {
                  this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);
                } else {
                  break;
                }
                ++this.state.pos;
                mods += char;
              }
              this.finishToken(types$1.regexp, {pattern: content, flags: mods});
            }
            readInt(radix, len, forceLen, allowNumSeparator) {
              if (allowNumSeparator === void 0) {
                allowNumSeparator = true;
              }
              const start = this.state.pos;
              const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
              const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
              let invalid = false;
              let total = 0;
              for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                const code = this.input.charCodeAt(this.state.pos);
                let val;
                if (code === 95) {
                  const prev = this.input.charCodeAt(this.state.pos - 1);
                  const next = this.input.charCodeAt(this.state.pos + 1);
                  if (allowedSiblings.indexOf(next) === -1) {
                    this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
                  } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
                    this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
                  }
                  if (!allowNumSeparator) {
                    this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
                  }
                  ++this.state.pos;
                  continue;
                }
                if (code >= 97) {
                  val = code - 97 + 10;
                } else if (code >= 65) {
                  val = code - 65 + 10;
                } else if (_isDigit(code)) {
                  val = code - 48;
                } else {
                  val = Infinity;
                }
                if (val >= radix) {
                  if (this.options.errorRecovery && val <= 9) {
                    val = 0;
                    this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
                  } else if (forceLen) {
                    val = 0;
                    invalid = true;
                  } else {
                    break;
                  }
                }
                ++this.state.pos;
                total = total * radix + val;
              }
              if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
                return null;
              }
              return total;
            }
            readRadixNumber(radix) {
              const start = this.state.pos;
              let isBigInt = false;
              this.state.pos += 2;
              const val = this.readInt(radix);
              if (val == null) {
                this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
              }
              const next = this.input.charCodeAt(this.state.pos);
              if (next === 110) {
                ++this.state.pos;
                isBigInt = true;
              } else if (next === 109) {
                throw this.raise(start, ErrorMessages.InvalidDecimal);
              }
              if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
                throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
              }
              if (isBigInt) {
                const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(types$1.bigint, str);
                return;
              }
              this.finishToken(types$1.num, val);
            }
            readNumber(startsWithDot) {
              const start = this.state.pos;
              let isFloat = false;
              let isBigInt = false;
              let isDecimal = false;
              let hasExponent = false;
              let isOctal = false;
              if (!startsWithDot && this.readInt(10) === null) {
                this.raise(start, ErrorMessages.InvalidNumber);
              }
              const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
              if (hasLeadingZero) {
                const integer = this.input.slice(start, this.state.pos);
                this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);
                if (!this.state.strict) {
                  const underscorePos = integer.indexOf("_");
                  if (underscorePos > 0) {
                    this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
                  }
                }
                isOctal = hasLeadingZero && !/[89]/.test(integer);
              }
              let next = this.input.charCodeAt(this.state.pos);
              if (next === 46 && !isOctal) {
                ++this.state.pos;
                this.readInt(10);
                isFloat = true;
                next = this.input.charCodeAt(this.state.pos);
              }
              if ((next === 69 || next === 101) && !isOctal) {
                next = this.input.charCodeAt(++this.state.pos);
                if (next === 43 || next === 45) {
                  ++this.state.pos;
                }
                if (this.readInt(10) === null) {
                  this.raise(start, ErrorMessages.InvalidOrMissingExponent);
                }
                isFloat = true;
                hasExponent = true;
                next = this.input.charCodeAt(this.state.pos);
              }
              if (next === 110) {
                if (isFloat || hasLeadingZero) {
                  this.raise(start, ErrorMessages.InvalidBigIntLiteral);
                }
                ++this.state.pos;
                isBigInt = true;
              }
              if (next === 109) {
                this.expectPlugin("decimal", this.state.pos);
                if (hasExponent || hasLeadingZero) {
                  this.raise(start, ErrorMessages.InvalidDecimal);
                }
                ++this.state.pos;
                isDecimal = true;
              }
              if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
                throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
              }
              const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
              if (isBigInt) {
                this.finishToken(types$1.bigint, str);
                return;
              }
              if (isDecimal) {
                this.finishToken(types$1.decimal, str);
                return;
              }
              const val = isOctal ? parseInt(str, 8) : parseFloat(str);
              this.finishToken(types$1.num, val);
            }
            readCodePoint(throwOnInvalid) {
              const ch = this.input.charCodeAt(this.state.pos);
              let code;
              if (ch === 123) {
                const codePos = ++this.state.pos;
                code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
                ++this.state.pos;
                if (code !== null && code > 1114111) {
                  if (throwOnInvalid) {
                    this.raise(codePos, ErrorMessages.InvalidCodePoint);
                  } else {
                    return null;
                  }
                }
              } else {
                code = this.readHexChar(4, false, throwOnInvalid);
              }
              return code;
            }
            readString(quote) {
              let out = "", chunkStart = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length) {
                  throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
                }
                const ch = this.input.charCodeAt(this.state.pos);
                if (ch === quote)
                  break;
                if (ch === 92) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.readEscapedChar(false);
                  chunkStart = this.state.pos;
                } else if (ch === 8232 || ch === 8233) {
                  ++this.state.pos;
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                } else if (isNewLine(ch)) {
                  throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
                } else {
                  ++this.state.pos;
                }
              }
              out += this.input.slice(chunkStart, this.state.pos++);
              this.finishToken(types$1.string, out);
            }
            readTmplToken() {
              let out = "", chunkStart = this.state.pos, containsInvalid = false;
              for (; ; ) {
                if (this.state.pos >= this.length) {
                  throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
                }
                const ch = this.input.charCodeAt(this.state.pos);
                if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
                  if (this.state.pos === this.state.start && this.match(types$1.template)) {
                    if (ch === 36) {
                      this.state.pos += 2;
                      this.finishToken(types$1.dollarBraceL);
                      return;
                    } else {
                      ++this.state.pos;
                      this.finishToken(types$1.backQuote);
                      return;
                    }
                  }
                  out += this.input.slice(chunkStart, this.state.pos);
                  this.finishToken(types$1.template, containsInvalid ? null : out);
                  return;
                }
                if (ch === 92) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  const escaped = this.readEscapedChar(true);
                  if (escaped === null) {
                    containsInvalid = true;
                  } else {
                    out += escaped;
                  }
                  chunkStart = this.state.pos;
                } else if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  ++this.state.pos;
                  switch (ch) {
                    case 13:
                      if (this.input.charCodeAt(this.state.pos) === 10) {
                        ++this.state.pos;
                      }
                    case 10:
                      out += "\n";
                      break;
                    default:
                      out += String.fromCharCode(ch);
                      break;
                  }
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
              }
            }
            recordStrictModeErrors(pos, message) {
              if (this.state.strict && !this.state.strictErrors.has(pos)) {
                this.raise(pos, message);
              } else {
                this.state.strictErrors.set(pos, message);
              }
            }
            readEscapedChar(inTemplate) {
              const throwOnInvalid = !inTemplate;
              const ch = this.input.charCodeAt(++this.state.pos);
              ++this.state.pos;
              switch (ch) {
                case 110:
                  return "\n";
                case 114:
                  return "\r";
                case 120: {
                  const code = this.readHexChar(2, false, throwOnInvalid);
                  return code === null ? null : String.fromCharCode(code);
                }
                case 117: {
                  const code = this.readCodePoint(throwOnInvalid);
                  return code === null ? null : String.fromCodePoint(code);
                }
                case 116:
                  return "	";
                case 98:
                  return "\b";
                case 118:
                  return "\v";
                case 102:
                  return "\f";
                case 13:
                  if (this.input.charCodeAt(this.state.pos) === 10) {
                    ++this.state.pos;
                  }
                case 10:
                  this.state.lineStart = this.state.pos;
                  ++this.state.curLine;
                case 8232:
                case 8233:
                  return "";
                case 56:
                case 57:
                  if (inTemplate) {
                    return null;
                  } else {
                    this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
                  }
                default:
                  if (ch >= 48 && ch <= 55) {
                    const codePos = this.state.pos - 1;
                    const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
                    let octalStr = match[0];
                    let octal = parseInt(octalStr, 8);
                    if (octal > 255) {
                      octalStr = octalStr.slice(0, -1);
                      octal = parseInt(octalStr, 8);
                    }
                    this.state.pos += octalStr.length - 1;
                    const next = this.input.charCodeAt(this.state.pos);
                    if (octalStr !== "0" || next === 56 || next === 57) {
                      if (inTemplate) {
                        return null;
                      } else {
                        this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
                      }
                    }
                    return String.fromCharCode(octal);
                  }
                  return String.fromCharCode(ch);
              }
            }
            readHexChar(len, forceLen, throwOnInvalid) {
              const codePos = this.state.pos;
              const n2 = this.readInt(16, len, forceLen, false);
              if (n2 === null) {
                if (throwOnInvalid) {
                  this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
                } else {
                  this.state.pos = codePos - 1;
                }
              }
              return n2;
            }
            readWord1() {
              let word = "";
              this.state.containsEsc = false;
              const start = this.state.pos;
              let chunkStart = this.state.pos;
              while (this.state.pos < this.length) {
                const ch = this.input.codePointAt(this.state.pos);
                if (isIdentifierChar(ch)) {
                  this.state.pos += ch <= 65535 ? 1 : 2;
                } else if (this.state.isIterator && ch === 64) {
                  ++this.state.pos;
                } else if (ch === 92) {
                  this.state.containsEsc = true;
                  word += this.input.slice(chunkStart, this.state.pos);
                  const escStart = this.state.pos;
                  const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
                    continue;
                  }
                  ++this.state.pos;
                  const esc = this.readCodePoint(true);
                  if (esc !== null) {
                    if (!identifierCheck(esc)) {
                      this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
                    }
                    word += String.fromCodePoint(esc);
                  }
                  chunkStart = this.state.pos;
                } else {
                  break;
                }
              }
              return word + this.input.slice(chunkStart, this.state.pos);
            }
            isIterator(word) {
              return word === "@@iterator" || word === "@@asyncIterator";
            }
            readWord() {
              const word = this.readWord1();
              const type2 = keywords.get(word) || types$1.name;
              if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
                this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);
              }
              this.finishToken(type2, word);
            }
            checkKeywordEscapes() {
              const kw = this.state.type.keyword;
              if (kw && this.state.containsEsc) {
                this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
              }
            }
            braceIsBlock(prevType) {
              const parent = this.curContext();
              if (parent === types$1$1.functionExpression || parent === types$1$1.functionStatement) {
                return true;
              }
              if (prevType === types$1.colon && (parent === types$1$1.braceStatement || parent === types$1$1.braceExpression)) {
                return !parent.isExpr;
              }
              if (prevType === types$1._return || prevType === types$1.name && this.state.exprAllowed) {
                return this.hasPrecedingLineBreak();
              }
              if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
                return true;
              }
              if (prevType === types$1.braceL) {
                return parent === types$1$1.braceStatement;
              }
              if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
                return false;
              }
              if (prevType === types$1.relational) {
                return true;
              }
              return !this.state.exprAllowed;
            }
            updateContext(prevType) {
              const type2 = this.state.type;
              let update;
              if (type2.keyword && (prevType === types$1.dot || prevType === types$1.questionDot)) {
                this.state.exprAllowed = false;
              } else if (update = type2.updateContext) {
                update.call(this, prevType);
              } else {
                this.state.exprAllowed = type2.beforeExpr;
              }
            }
          }
          class ClassScope {
            constructor() {
              this.privateNames = new Set();
              this.loneAccessors = new Map();
              this.undefinedPrivateNames = new Map();
            }
          }
          class ClassScopeHandler {
            constructor(raise) {
              this.stack = [];
              this.undefinedPrivateNames = new Map();
              this.raise = raise;
            }
            current() {
              return this.stack[this.stack.length - 1];
            }
            enter() {
              this.stack.push(new ClassScope());
            }
            exit() {
              const oldClassScope = this.stack.pop();
              const current = this.current();
              for (const [name2, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {
                if (current) {
                  if (!current.undefinedPrivateNames.has(name2)) {
                    current.undefinedPrivateNames.set(name2, pos);
                  }
                } else {
                  this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name2);
                }
              }
            }
            declarePrivateName(name2, elementType, pos) {
              const classScope = this.current();
              let redefined = classScope.privateNames.has(name2);
              if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
                const accessor = redefined && classScope.loneAccessors.get(name2);
                if (accessor) {
                  const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
                  const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
                  const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
                  const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
                  redefined = oldKind === newKind || oldStatic !== newStatic;
                  if (!redefined)
                    classScope.loneAccessors.delete(name2);
                } else if (!redefined) {
                  classScope.loneAccessors.set(name2, elementType);
                }
              }
              if (redefined) {
                this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name2);
              }
              classScope.privateNames.add(name2);
              classScope.undefinedPrivateNames.delete(name2);
            }
            usePrivateName(name2, pos) {
              let classScope;
              for (classScope of this.stack) {
                if (classScope.privateNames.has(name2))
                  return;
              }
              if (classScope) {
                classScope.undefinedPrivateNames.set(name2, pos);
              } else {
                this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name2);
              }
            }
          }
          const kExpression = 0, kMaybeArrowParameterDeclaration = 1, kMaybeAsyncArrowParameterDeclaration = 2, kParameterDeclaration = 3;
          class ExpressionScope {
            constructor(type2) {
              if (type2 === void 0) {
                type2 = kExpression;
              }
              this.type = void 0;
              this.type = type2;
            }
            canBeArrowParameterDeclaration() {
              return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
            }
            isCertainlyParameterDeclaration() {
              return this.type === kParameterDeclaration;
            }
          }
          class ArrowHeadParsingScope extends ExpressionScope {
            constructor(type2) {
              super(type2);
              this.errors = new Map();
            }
            recordDeclarationError(pos, template2) {
              this.errors.set(pos, template2);
            }
            clearDeclarationError(pos) {
              this.errors.delete(pos);
            }
            iterateErrors(iterator) {
              this.errors.forEach(iterator);
            }
          }
          class ExpressionScopeHandler {
            constructor(raise) {
              this.stack = [new ExpressionScope()];
              this.raise = raise;
            }
            enter(scope2) {
              this.stack.push(scope2);
            }
            exit() {
              this.stack.pop();
            }
            recordParameterInitializerError(pos, template2) {
              const {stack} = this;
              let i = stack.length - 1;
              let scope2 = stack[i];
              while (!scope2.isCertainlyParameterDeclaration()) {
                if (scope2.canBeArrowParameterDeclaration()) {
                  scope2.recordDeclarationError(pos, template2);
                } else {
                  return;
                }
                scope2 = stack[--i];
              }
              this.raise(pos, template2);
            }
            recordParenthesizedIdentifierError(pos, template2) {
              const {stack} = this;
              const scope2 = stack[stack.length - 1];
              if (scope2.isCertainlyParameterDeclaration()) {
                this.raise(pos, template2);
              } else if (scope2.canBeArrowParameterDeclaration()) {
                scope2.recordDeclarationError(pos, template2);
              } else {
                return;
              }
            }
            recordAsyncArrowParametersError(pos, template2) {
              const {stack} = this;
              let i = stack.length - 1;
              let scope2 = stack[i];
              while (scope2.canBeArrowParameterDeclaration()) {
                if (scope2.type === kMaybeAsyncArrowParameterDeclaration) {
                  scope2.recordDeclarationError(pos, template2);
                }
                scope2 = stack[--i];
              }
            }
            validateAsPattern() {
              const {stack} = this;
              const currentScope = stack[stack.length - 1];
              if (!currentScope.canBeArrowParameterDeclaration())
                return;
              currentScope.iterateErrors((template2, pos) => {
                this.raise(pos, template2);
                let i = stack.length - 2;
                let scope2 = stack[i];
                while (scope2.canBeArrowParameterDeclaration()) {
                  scope2.clearDeclarationError(pos);
                  scope2 = stack[--i];
                }
              });
            }
          }
          function newParameterDeclarationScope() {
            return new ExpressionScope(kParameterDeclaration);
          }
          function newArrowHeadScope() {
            return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
          }
          function newAsyncArrowScope() {
            return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
          }
          function newExpressionScope() {
            return new ExpressionScope();
          }
          class UtilParser extends Tokenizer {
            addExtra(node2, key, val) {
              if (!node2)
                return;
              const extra = node2.extra = node2.extra || {};
              extra[key] = val;
            }
            isRelational(op) {
              return this.match(types$1.relational) && this.state.value === op;
            }
            expectRelational(op) {
              if (this.isRelational(op)) {
                this.next();
              } else {
                this.unexpected(null, types$1.relational);
              }
            }
            isContextual(name2) {
              return this.match(types$1.name) && this.state.value === name2 && !this.state.containsEsc;
            }
            isUnparsedContextual(nameStart, name2) {
              const nameEnd = nameStart + name2.length;
              return this.input.slice(nameStart, nameEnd) === name2 && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
            }
            isLookaheadContextual(name2) {
              const next = this.nextTokenStart();
              return this.isUnparsedContextual(next, name2);
            }
            eatContextual(name2) {
              return this.isContextual(name2) && this.eat(types$1.name);
            }
            expectContextual(name2, template2) {
              if (!this.eatContextual(name2))
                this.unexpected(null, template2);
            }
            canInsertSemicolon() {
              return this.match(types$1.eof) || this.match(types$1.braceR) || this.hasPrecedingLineBreak();
            }
            hasPrecedingLineBreak() {
              return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
            }
            hasFollowingLineBreak() {
              return lineBreak.test(this.input.slice(this.state.end, this.nextTokenStart()));
            }
            isLineTerminator() {
              return this.eat(types$1.semi) || this.canInsertSemicolon();
            }
            semicolon(allowAsi) {
              if (allowAsi === void 0) {
                allowAsi = true;
              }
              if (allowAsi ? this.isLineTerminator() : this.eat(types$1.semi))
                return;
              this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
            }
            expect(type2, pos) {
              this.eat(type2) || this.unexpected(pos, type2);
            }
            assertNoSpace(message) {
              if (message === void 0) {
                message = "Unexpected space.";
              }
              if (this.state.start > this.state.lastTokEnd) {
                this.raise(this.state.lastTokEnd, {code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedSpace", template: message});
              }
            }
            unexpected(pos, messageOrType) {
              if (messageOrType === void 0) {
                messageOrType = {code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token"};
              }
              if (messageOrType instanceof TokenType) {
                messageOrType = {code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedToken", template: `Unexpected token, expected "${messageOrType.label}"`};
              }
              throw this.raise(pos != null ? pos : this.state.start, messageOrType);
            }
            expectPlugin(name2, pos) {
              if (!this.hasPlugin(name2)) {
                throw this.raiseWithData(pos != null ? pos : this.state.start, {missingPlugin: [name2]}, `This experimental syntax requires enabling the parser plugin: '${name2}'`);
              }
              return true;
            }
            expectOnePlugin(names, pos) {
              if (!names.some((n2) => this.hasPlugin(n2))) {
                throw this.raiseWithData(pos != null ? pos : this.state.start, {missingPlugin: names}, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
              }
            }
            tryParse(fn, oldState) {
              if (oldState === void 0) {
                oldState = this.state.clone();
              }
              const abortSignal = {node: null};
              try {
                const node2 = fn(function(node3) {
                  if (node3 === void 0) {
                    node3 = null;
                  }
                  abortSignal.node = node3;
                  throw abortSignal;
                });
                if (this.state.errors.length > oldState.errors.length) {
                  const failState = this.state;
                  this.state = oldState;
                  return {node: node2, error: failState.errors[oldState.errors.length], thrown: false, aborted: false, failState};
                }
                return {node: node2, error: null, thrown: false, aborted: false, failState: null};
              } catch (error) {
                const failState = this.state;
                this.state = oldState;
                if (error instanceof SyntaxError) {
                  return {node: null, error, thrown: true, aborted: false, failState};
                }
                if (error === abortSignal) {
                  return {node: abortSignal.node, error: null, thrown: false, aborted: true, failState};
                }
                throw error;
              }
            }
            checkExpressionErrors(refExpressionErrors, andThrow) {
              if (!refExpressionErrors)
                return false;
              const {shorthandAssign, doubleProto} = refExpressionErrors;
              if (!andThrow)
                return shorthandAssign >= 0 || doubleProto >= 0;
              if (shorthandAssign >= 0) {
                this.unexpected(shorthandAssign);
              }
              if (doubleProto >= 0) {
                this.raise(doubleProto, ErrorMessages.DuplicateProto);
              }
            }
            isLiteralPropertyName() {
              return this.match(types$1.name) || !!this.state.type.keyword || this.match(types$1.string) || this.match(types$1.num) || this.match(types$1.bigint) || this.match(types$1.decimal);
            }
            isPrivateName(node2) {
              return node2.type === "PrivateName";
            }
            getPrivateNameSV(node2) {
              return node2.id.name;
            }
            hasPropertyAsPrivateName(node2) {
              return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
            }
            isOptionalChain(node2) {
              return node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression";
            }
            isObjectProperty(node2) {
              return node2.type === "ObjectProperty";
            }
            isObjectMethod(node2) {
              return node2.type === "ObjectMethod";
            }
            initializeScopes(inModule) {
              if (inModule === void 0) {
                inModule = this.options.sourceType === "module";
              }
              const oldLabels = this.state.labels;
              this.state.labels = [];
              const oldExportedIdentifiers = this.state.exportedIdentifiers;
              this.state.exportedIdentifiers = [];
              const oldInModule = this.inModule;
              this.inModule = inModule;
              const oldScope = this.scope;
              const ScopeHandler2 = this.getScopeHandler();
              this.scope = new ScopeHandler2(this.raise.bind(this), this.inModule);
              const oldProdParam = this.prodParam;
              this.prodParam = new ProductionParameterHandler();
              const oldClassScope = this.classScope;
              this.classScope = new ClassScopeHandler(this.raise.bind(this));
              const oldExpressionScope = this.expressionScope;
              this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
              return () => {
                this.state.labels = oldLabels;
                this.state.exportedIdentifiers = oldExportedIdentifiers;
                this.inModule = oldInModule;
                this.scope = oldScope;
                this.prodParam = oldProdParam;
                this.classScope = oldClassScope;
                this.expressionScope = oldExpressionScope;
              };
            }
            enterInitialScopes() {
              let paramFlags = PARAM;
              if (this.hasPlugin("topLevelAwait") && this.inModule) {
                paramFlags |= PARAM_AWAIT;
              }
              this.scope.enter(SCOPE_PROGRAM);
              this.prodParam.enter(paramFlags);
            }
          }
          class ExpressionErrors {
            constructor() {
              this.shorthandAssign = -1;
              this.doubleProto = -1;
            }
          }
          class Node2 {
            constructor(parser2, pos, loc) {
              this.type = void 0;
              this.start = void 0;
              this.end = void 0;
              this.loc = void 0;
              this.range = void 0;
              this.leadingComments = void 0;
              this.trailingComments = void 0;
              this.innerComments = void 0;
              this.extra = void 0;
              this.type = "";
              this.start = pos;
              this.end = 0;
              this.loc = new SourceLocation(loc);
              if (parser2 != null && parser2.options.ranges)
                this.range = [pos, 0];
              if (parser2 != null && parser2.filename)
                this.loc.filename = parser2.filename;
            }
            __clone() {
              const newNode = new Node2();
              const keys = Object.keys(this);
              for (let i = 0, length = keys.length; i < length; i++) {
                const key = keys[i];
                if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
                  newNode[key] = this[key];
                }
              }
              return newNode;
            }
          }
          class NodeUtils extends UtilParser {
            startNode() {
              return new Node2(this, this.state.start, this.state.startLoc);
            }
            startNodeAt(pos, loc) {
              return new Node2(this, pos, loc);
            }
            startNodeAtNode(type2) {
              return this.startNodeAt(type2.start, type2.loc.start);
            }
            finishNode(node2, type2) {
              return this.finishNodeAt(node2, type2, this.state.lastTokEnd, this.state.lastTokEndLoc);
            }
            finishNodeAt(node2, type2, pos, loc) {
              node2.type = type2;
              node2.end = pos;
              node2.loc.end = loc;
              if (this.options.ranges)
                node2.range[1] = pos;
              this.processComment(node2);
              return node2;
            }
            resetStartLocation(node2, start, startLoc) {
              node2.start = start;
              node2.loc.start = startLoc;
              if (this.options.ranges)
                node2.range[0] = start;
            }
            resetEndLocation(node2, end, endLoc) {
              if (end === void 0) {
                end = this.state.lastTokEnd;
              }
              if (endLoc === void 0) {
                endLoc = this.state.lastTokEndLoc;
              }
              node2.end = end;
              node2.loc.end = endLoc;
              if (this.options.ranges)
                node2.range[1] = end;
            }
            resetStartLocationFromNode(node2, locationNode) {
              this.resetStartLocation(node2, locationNode.start, locationNode.loc.start);
            }
          }
          const unwrapParenthesizedExpression = (node2) => {
            return node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
          };
          class LValParser extends NodeUtils {
            toAssignable(node2, isLHS) {
              if (isLHS === void 0) {
                isLHS = false;
              }
              var _node$extra, _node$extra3;
              let parenthesized = void 0;
              if (node2.type === "ParenthesizedExpression" || (_node$extra = node2.extra) != null && _node$extra.parenthesized) {
                parenthesized = unwrapParenthesizedExpression(node2);
                if (isLHS) {
                  if (parenthesized.type === "Identifier") {
                    this.expressionScope.recordParenthesizedIdentifierError(node2.start, ErrorMessages.InvalidParenthesizedAssignment);
                  } else if (parenthesized.type !== "MemberExpression") {
                    this.raise(node2.start, ErrorMessages.InvalidParenthesizedAssignment);
                  }
                } else {
                  this.raise(node2.start, ErrorMessages.InvalidParenthesizedAssignment);
                }
              }
              switch (node2.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                  break;
                case "ObjectExpression":
                  node2.type = "ObjectPattern";
                  for (let i = 0, length = node2.properties.length, last2 = length - 1; i < length; i++) {
                    var _node$extra2;
                    const prop2 = node2.properties[i];
                    const isLast = i === last2;
                    this.toAssignableObjectExpressionProp(prop2, isLast, isLHS);
                    if (isLast && prop2.type === "RestElement" && (_node$extra2 = node2.extra) != null && _node$extra2.trailingComma) {
                      this.raiseRestNotLast(node2.extra.trailingComma);
                    }
                  }
                  break;
                case "ObjectProperty":
                  this.toAssignable(node2.value, isLHS);
                  break;
                case "SpreadElement": {
                  this.checkToRestConversion(node2);
                  node2.type = "RestElement";
                  const arg = node2.argument;
                  this.toAssignable(arg, isLHS);
                  break;
                }
                case "ArrayExpression":
                  node2.type = "ArrayPattern";
                  this.toAssignableList(node2.elements, (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
                  break;
                case "AssignmentExpression":
                  if (node2.operator !== "=") {
                    this.raise(node2.left.end, ErrorMessages.MissingEqInAssignment);
                  }
                  node2.type = "AssignmentPattern";
                  delete node2.operator;
                  this.toAssignable(node2.left, isLHS);
                  break;
                case "ParenthesizedExpression":
                  this.toAssignable(parenthesized, isLHS);
                  break;
              }
              return node2;
            }
            toAssignableObjectExpressionProp(prop2, isLast, isLHS) {
              if (prop2.type === "ObjectMethod") {
                const error = prop2.kind === "get" || prop2.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
                this.raise(prop2.key.start, error);
              } else if (prop2.type === "SpreadElement" && !isLast) {
                this.raiseRestNotLast(prop2.start);
              } else {
                this.toAssignable(prop2, isLHS);
              }
            }
            toAssignableList(exprList, trailingCommaPos, isLHS) {
              let end = exprList.length;
              if (end) {
                const last2 = exprList[end - 1];
                if ((last2 == null ? void 0 : last2.type) === "RestElement") {
                  --end;
                } else if ((last2 == null ? void 0 : last2.type) === "SpreadElement") {
                  last2.type = "RestElement";
                  let arg = last2.argument;
                  this.toAssignable(arg, isLHS);
                  arg = unwrapParenthesizedExpression(arg);
                  if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
                    this.unexpected(arg.start);
                  }
                  if (trailingCommaPos) {
                    this.raiseTrailingCommaAfterRest(trailingCommaPos);
                  }
                  --end;
                }
              }
              for (let i = 0; i < end; i++) {
                const elt = exprList[i];
                if (elt) {
                  this.toAssignable(elt, isLHS);
                  if (elt.type === "RestElement") {
                    this.raiseRestNotLast(elt.start);
                  }
                }
              }
              return exprList;
            }
            toReferencedList(exprList, isParenthesizedExpr) {
              return exprList;
            }
            toReferencedListDeep(exprList, isParenthesizedExpr) {
              this.toReferencedList(exprList, isParenthesizedExpr);
              for (const expr2 of exprList) {
                if ((expr2 == null ? void 0 : expr2.type) === "ArrayExpression") {
                  this.toReferencedListDeep(expr2.elements);
                }
              }
            }
            parseSpread(refExpressionErrors, refNeedsArrowPos) {
              const node2 = this.startNode();
              this.next();
              node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos);
              return this.finishNode(node2, "SpreadElement");
            }
            parseRestBinding() {
              const node2 = this.startNode();
              this.next();
              node2.argument = this.parseBindingAtom();
              return this.finishNode(node2, "RestElement");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case types$1.bracketL: {
                  const node2 = this.startNode();
                  this.next();
                  node2.elements = this.parseBindingList(types$1.bracketR, 93, true);
                  return this.finishNode(node2, "ArrayPattern");
                }
                case types$1.braceL:
                  return this.parseObjectLike(types$1.braceR, true);
              }
              return this.parseIdentifier();
            }
            parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
              const elts = [];
              let first = true;
              while (!this.eat(close)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types$1.comma);
                }
                if (allowEmpty && this.match(types$1.comma)) {
                  elts.push(null);
                } else if (this.eat(close)) {
                  break;
                } else if (this.match(types$1.ellipsis)) {
                  elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
                  this.checkCommaAfterRest(closeCharCode);
                  this.expect(close);
                  break;
                } else {
                  const decorators = [];
                  if (this.match(types$1.at) && this.hasPlugin("decorators")) {
                    this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
                  }
                  while (this.match(types$1.at)) {
                    decorators.push(this.parseDecorator());
                  }
                  elts.push(this.parseAssignableListItem(allowModifiers, decorators));
                }
              }
              return elts;
            }
            parseAssignableListItem(allowModifiers, decorators) {
              const left = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(left);
              const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
              if (decorators.length) {
                left.decorators = decorators;
              }
              return elt;
            }
            parseAssignableListItemTypes(param) {
              return param;
            }
            parseMaybeDefault(startPos, startLoc, left) {
              var _startLoc, _startPos, _left;
              startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
              startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
              left = (_left = left) != null ? _left : this.parseBindingAtom();
              if (!this.eat(types$1.eq))
                return left;
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.left = left;
              node2.right = this.parseMaybeAssignAllowIn();
              return this.finishNode(node2, "AssignmentPattern");
            }
            checkLVal(expr2, contextDescription, bindingType, checkClashes, disallowLetBinding, strictModeChanged) {
              if (bindingType === void 0) {
                bindingType = BIND_NONE;
              }
              if (strictModeChanged === void 0) {
                strictModeChanged = false;
              }
              switch (expr2.type) {
                case "Identifier": {
                  const {name: name2} = expr2;
                  if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name2, this.inModule) : isStrictBindOnlyReservedWord(name2))) {
                    this.raise(expr2.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name2);
                  }
                  if (checkClashes) {
                    if (checkClashes.has(name2)) {
                      this.raise(expr2.start, ErrorMessages.ParamDupe);
                    } else {
                      checkClashes.add(name2);
                    }
                  }
                  if (disallowLetBinding && name2 === "let") {
                    this.raise(expr2.start, ErrorMessages.LetInLexicalBinding);
                  }
                  if (!(bindingType & BIND_NONE)) {
                    this.scope.declareName(name2, bindingType, expr2.start);
                  }
                  break;
                }
                case "MemberExpression":
                  if (bindingType !== BIND_NONE) {
                    this.raise(expr2.start, ErrorMessages.InvalidPropertyBindingPattern);
                  }
                  break;
                case "ObjectPattern":
                  for (let prop2 of expr2.properties) {
                    if (this.isObjectProperty(prop2))
                      prop2 = prop2.value;
                    else if (this.isObjectMethod(prop2))
                      continue;
                    this.checkLVal(prop2, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
                  }
                  break;
                case "ArrayPattern":
                  for (const elem of expr2.elements) {
                    if (elem) {
                      this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
                    }
                  }
                  break;
                case "AssignmentPattern":
                  this.checkLVal(expr2.left, "assignment pattern", bindingType, checkClashes);
                  break;
                case "RestElement":
                  this.checkLVal(expr2.argument, "rest element", bindingType, checkClashes);
                  break;
                case "ParenthesizedExpression":
                  this.checkLVal(expr2.expression, "parenthesized expression", bindingType, checkClashes);
                  break;
                default: {
                  this.raise(expr2.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
                }
              }
            }
            checkToRestConversion(node2) {
              if (node2.argument.type !== "Identifier" && node2.argument.type !== "MemberExpression") {
                this.raise(node2.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
              }
            }
            checkCommaAfterRest(close) {
              if (this.match(types$1.comma)) {
                if (this.lookaheadCharCode() === close) {
                  this.raiseTrailingCommaAfterRest(this.state.start);
                } else {
                  this.raiseRestNotLast(this.state.start);
                }
              }
            }
            raiseRestNotLast(pos) {
              throw this.raise(pos, ErrorMessages.ElementAfterRest);
            }
            raiseTrailingCommaAfterRest(pos) {
              this.raise(pos, ErrorMessages.RestTrailingComma);
            }
          }
          class ExpressionParser extends LValParser {
            checkProto(prop2, isRecord, protoRef, refExpressionErrors) {
              if (prop2.type === "SpreadElement" || this.isObjectMethod(prop2) || prop2.computed || prop2.shorthand) {
                return;
              }
              const key = prop2.key;
              const name2 = key.type === "Identifier" ? key.name : key.value;
              if (name2 === "__proto__") {
                if (isRecord) {
                  this.raise(key.start, ErrorMessages.RecordNoProto);
                  return;
                }
                if (protoRef.used) {
                  if (refExpressionErrors) {
                    if (refExpressionErrors.doubleProto === -1) {
                      refExpressionErrors.doubleProto = key.start;
                    }
                  } else {
                    this.raise(key.start, ErrorMessages.DuplicateProto);
                  }
                }
                protoRef.used = true;
              }
            }
            shouldExitDescending(expr2, potentialArrowAt) {
              return expr2.type === "ArrowFunctionExpression" && expr2.start === potentialArrowAt;
            }
            getExpression() {
              let paramFlags = PARAM;
              if (this.hasPlugin("topLevelAwait") && this.inModule) {
                paramFlags |= PARAM_AWAIT;
              }
              this.scope.enter(SCOPE_PROGRAM);
              this.prodParam.enter(paramFlags);
              this.nextToken();
              const expr2 = this.parseExpression();
              if (!this.match(types$1.eof)) {
                this.unexpected();
              }
              expr2.comments = this.state.comments;
              expr2.errors = this.state.errors;
              if (this.options.tokens) {
                expr2.tokens = this.tokens;
              }
              return expr2;
            }
            parseExpression(disallowIn, refExpressionErrors) {
              if (disallowIn) {
                return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
              }
              return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
            }
            parseExpressionBase(refExpressionErrors) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const expr2 = this.parseMaybeAssign(refExpressionErrors);
              if (this.match(types$1.comma)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.expressions = [expr2];
                while (this.eat(types$1.comma)) {
                  node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
                }
                this.toReferencedList(node2.expressions);
                return this.finishNode(node2, "SequenceExpression");
              }
              return expr2;
            }
            parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
              return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));
            }
            parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
              return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));
            }
            parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              if (this.isContextual("yield")) {
                if (this.prodParam.hasYield) {
                  this.state.exprAllowed = true;
                  let left2 = this.parseYield();
                  if (afterLeftParse) {
                    left2 = afterLeftParse.call(this, left2, startPos, startLoc);
                  }
                  return left2;
                }
              }
              let ownExpressionErrors;
              if (refExpressionErrors) {
                ownExpressionErrors = false;
              } else {
                refExpressionErrors = new ExpressionErrors();
                ownExpressionErrors = true;
              }
              if (this.match(types$1.parenL) || this.match(types$1.name)) {
                this.state.potentialArrowAt = this.state.start;
              }
              let left = this.parseMaybeConditional(refExpressionErrors, refNeedsArrowPos);
              if (afterLeftParse) {
                left = afterLeftParse.call(this, left, startPos, startLoc);
              }
              if (this.state.type.isAssign) {
                const node2 = this.startNodeAt(startPos, startLoc);
                const operator = this.state.value;
                node2.operator = operator;
                if (this.match(types$1.eq)) {
                  node2.left = this.toAssignable(left, true);
                  refExpressionErrors.doubleProto = -1;
                } else {
                  node2.left = left;
                }
                if (refExpressionErrors.shorthandAssign >= node2.left.start) {
                  refExpressionErrors.shorthandAssign = -1;
                }
                this.checkLVal(left, "assignment expression");
                this.next();
                node2.right = this.parseMaybeAssign();
                return this.finishNode(node2, "AssignmentExpression");
              } else if (ownExpressionErrors) {
                this.checkExpressionErrors(refExpressionErrors, true);
              }
              return left;
            }
            parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const potentialArrowAt = this.state.potentialArrowAt;
              const expr2 = this.parseExprOps(refExpressionErrors);
              if (this.shouldExitDescending(expr2, potentialArrowAt)) {
                return expr2;
              }
              return this.parseConditional(expr2, startPos, startLoc, refNeedsArrowPos);
            }
            parseConditional(expr2, startPos, startLoc, refNeedsArrowPos) {
              if (this.eat(types$1.question)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.test = expr2;
                node2.consequent = this.parseMaybeAssignAllowIn();
                this.expect(types$1.colon);
                node2.alternate = this.parseMaybeAssign();
                return this.finishNode(node2, "ConditionalExpression");
              }
              return expr2;
            }
            parseExprOps(refExpressionErrors) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const potentialArrowAt = this.state.potentialArrowAt;
              const expr2 = this.parseMaybeUnary(refExpressionErrors);
              if (this.shouldExitDescending(expr2, potentialArrowAt)) {
                return expr2;
              }
              return this.parseExprOp(expr2, startPos, startLoc, -1);
            }
            parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
              let prec = this.state.type.binop;
              if (prec != null && (this.prodParam.hasIn || !this.match(types$1._in))) {
                if (prec > minPrec) {
                  const op = this.state.type;
                  if (op === types$1.pipeline) {
                    this.expectPlugin("pipelineOperator");
                    if (this.state.inFSharpPipelineDirectBody) {
                      return left;
                    }
                    this.state.inPipeline = true;
                    this.checkPipelineAtInfixOperator(left, leftStartPos);
                  }
                  const node2 = this.startNodeAt(leftStartPos, leftStartLoc);
                  node2.left = left;
                  node2.operator = this.state.value;
                  const logical = op === types$1.logicalOR || op === types$1.logicalAND;
                  const coalesce = op === types$1.nullishCoalescing;
                  if (coalesce) {
                    prec = types$1.logicalAND.binop;
                  }
                  this.next();
                  if (op === types$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
                    if (this.match(types$1.name) && this.state.value === "await" && this.prodParam.hasAwait) {
                      throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
                    }
                  }
                  node2.right = this.parseExprOpRightExpr(op, prec);
                  this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                  const nextOp = this.state.type;
                  if (coalesce && (nextOp === types$1.logicalOR || nextOp === types$1.logicalAND) || logical && nextOp === types$1.nullishCoalescing) {
                    throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
                  }
                  return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec);
                }
              }
              return left;
            }
            parseExprOpRightExpr(op, prec) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              switch (op) {
                case types$1.pipeline:
                  switch (this.getPluginOption("pipelineOperator", "proposal")) {
                    case "smart":
                      return this.withTopicPermittingContext(() => {
                        return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                      });
                    case "fsharp":
                      return this.withSoloAwaitPermittingContext(() => {
                        return this.parseFSharpPipelineBody(prec);
                      });
                  }
                default:
                  return this.parseExprOpBaseRightExpr(op, prec);
              }
            }
            parseExprOpBaseRightExpr(op, prec) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
            }
            checkExponentialAfterUnary(node2) {
              if (this.match(types$1.exponent)) {
                this.raise(node2.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
              }
            }
            parseMaybeUnary(refExpressionErrors, sawUnary) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const isAwait = this.isContextual("await");
              if (isAwait && this.isAwaitAllowed()) {
                this.next();
                const expr3 = this.parseAwait(startPos, startLoc);
                if (!sawUnary)
                  this.checkExponentialAfterUnary(expr3);
                return expr3;
              }
              if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                return this.parseModuleExpression();
              }
              const update = this.match(types$1.incDec);
              const node2 = this.startNode();
              if (this.state.type.prefix) {
                node2.operator = this.state.value;
                node2.prefix = true;
                if (this.match(types$1._throw)) {
                  this.expectPlugin("throwExpressions");
                }
                const isDelete = this.match(types$1._delete);
                this.next();
                node2.argument = this.parseMaybeUnary(null, true);
                this.checkExpressionErrors(refExpressionErrors, true);
                if (this.state.strict && isDelete) {
                  const arg = node2.argument;
                  if (arg.type === "Identifier") {
                    this.raise(node2.start, ErrorMessages.StrictDelete);
                  } else if (this.hasPropertyAsPrivateName(arg)) {
                    this.raise(node2.start, ErrorMessages.DeletePrivateField);
                  }
                }
                if (!update) {
                  if (!sawUnary)
                    this.checkExponentialAfterUnary(node2);
                  return this.finishNode(node2, "UnaryExpression");
                }
              }
              const expr2 = this.parseUpdate(node2, update, refExpressionErrors);
              if (isAwait) {
                const startsExpr2 = this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types$1.modulo);
                if (startsExpr2 && !this.isAmbiguousAwait()) {
                  this.raiseOverwrite(startPos, this.hasPlugin("topLevelAwait") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);
                  return this.parseAwait(startPos, startLoc);
                }
              }
              return expr2;
            }
            parseUpdate(node2, update, refExpressionErrors) {
              if (update) {
                this.checkLVal(node2.argument, "prefix operation");
                return this.finishNode(node2, "UpdateExpression");
              }
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              let expr2 = this.parseExprSubscripts(refExpressionErrors);
              if (this.checkExpressionErrors(refExpressionErrors, false))
                return expr2;
              while (this.state.type.postfix && !this.canInsertSemicolon()) {
                const node3 = this.startNodeAt(startPos, startLoc);
                node3.operator = this.state.value;
                node3.prefix = false;
                node3.argument = expr2;
                this.checkLVal(expr2, "postfix operation");
                this.next();
                expr2 = this.finishNode(node3, "UpdateExpression");
              }
              return expr2;
            }
            parseExprSubscripts(refExpressionErrors) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              const potentialArrowAt = this.state.potentialArrowAt;
              const expr2 = this.parseExprAtom(refExpressionErrors);
              if (this.shouldExitDescending(expr2, potentialArrowAt)) {
                return expr2;
              }
              return this.parseSubscripts(expr2, startPos, startLoc);
            }
            parseSubscripts(base, startPos, startLoc, noCalls) {
              const state = {optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(base), stop: false};
              do {
                base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
                state.maybeAsyncArrow = false;
              } while (!state.stop);
              return base;
            }
            parseSubscript(base, startPos, startLoc, noCalls, state) {
              if (!noCalls && this.eat(types$1.doubleColon)) {
                return this.parseBind(base, startPos, startLoc, noCalls, state);
              } else if (this.match(types$1.backQuote)) {
                return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
              }
              let optional = false;
              if (this.match(types$1.questionDot)) {
                if (noCalls && this.lookaheadCharCode() === 40) {
                  state.stop = true;
                  return base;
                }
                state.optionalChainMember = optional = true;
                this.next();
              }
              if (!noCalls && this.match(types$1.parenL)) {
                return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
              } else if (optional || this.match(types$1.bracketL) || this.eat(types$1.dot)) {
                return this.parseMember(base, startPos, startLoc, state, optional);
              } else {
                state.stop = true;
                return base;
              }
            }
            parseMember(base, startPos, startLoc, state, optional) {
              const node2 = this.startNodeAt(startPos, startLoc);
              const computed = this.eat(types$1.bracketL);
              node2.object = base;
              node2.computed = computed;
              const property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);
              if (this.isPrivateName(property)) {
                if (node2.object.type === "Super") {
                  this.raise(startPos, ErrorMessages.SuperPrivateField);
                }
                this.classScope.usePrivateName(this.getPrivateNameSV(property), property.start);
              }
              node2.property = property;
              if (computed) {
                this.expect(types$1.bracketR);
              }
              if (state.optionalChainMember) {
                node2.optional = optional;
                return this.finishNode(node2, "OptionalMemberExpression");
              } else {
                return this.finishNode(node2, "MemberExpression");
              }
            }
            parseBind(base, startPos, startLoc, noCalls, state) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.object = base;
              node2.callee = this.parseNoCallExpr();
              state.stop = true;
              return this.parseSubscripts(this.finishNode(node2, "BindExpression"), startPos, startLoc, noCalls);
            }
            parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
              const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = true;
              this.next();
              let node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              if (state.maybeAsyncArrow) {
                this.expressionScope.enter(newAsyncArrowScope());
              }
              if (state.optionalChainMember) {
                node2.optional = optional;
              }
              if (optional) {
                node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
              } else {
                node2.arguments = this.parseCallExpressionArguments(types$1.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", node2);
              }
              this.finishCallExpression(node2, state.optionalChainMember);
              if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
                state.stop = true;
                this.expressionScope.validateAsPattern();
                this.expressionScope.exit();
                node2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node2);
              } else {
                if (state.maybeAsyncArrow) {
                  this.expressionScope.exit();
                }
                this.toReferencedArguments(node2);
              }
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              return node2;
            }
            toReferencedArguments(node2, isParenthesizedExpr) {
              this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
            }
            parseTaggedTemplateExpression(base, startPos, startLoc, state) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.tag = base;
              node2.quasi = this.parseTemplate(true);
              if (state.optionalChainMember) {
                this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
              }
              return this.finishNode(node2, "TaggedTemplateExpression");
            }
            atPossibleAsyncArrow(base) {
              return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
            }
            finishCallExpression(node2, optional) {
              if (node2.callee.type === "Import") {
                if (node2.arguments.length === 2) {
                  if (!this.hasPlugin("moduleAttributes")) {
                    this.expectPlugin("importAssertions");
                  }
                }
                if (node2.arguments.length === 0 || node2.arguments.length > 2) {
                  this.raise(node2.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
                } else {
                  for (const arg of node2.arguments) {
                    if (arg.type === "SpreadElement") {
                      this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
                    }
                  }
                }
              }
              return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
            }
            parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
              const elts = [];
              let first = true;
              const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              while (!this.eat(close)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types$1.comma);
                  if (this.match(close)) {
                    if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                      this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
                    }
                    if (nodeForExtra) {
                      this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
                    }
                    this.next();
                    break;
                  }
                }
                elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : void 0, possibleAsyncArrow ? {start: 0} : void 0, allowPlaceholder));
              }
              this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
              return elts;
            }
            shouldParseAsyncArrow() {
              return this.match(types$1.arrow) && !this.canInsertSemicolon();
            }
            parseAsyncArrowFromCallExpression(node2, call) {
              var _call$extra;
              this.expect(types$1.arrow);
              this.parseArrowExpression(node2, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
              return node2;
            }
            parseNoCallExpr() {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
            }
            parseExprAtom(refExpressionErrors) {
              if (this.state.type === types$1.slash)
                this.readRegexp();
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              let node2;
              switch (this.state.type) {
                case types$1._super:
                  return this.parseSuper();
                case types$1._import:
                  node2 = this.startNode();
                  this.next();
                  if (this.match(types$1.dot)) {
                    return this.parseImportMetaProperty(node2);
                  }
                  if (!this.match(types$1.parenL)) {
                    this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
                  }
                  return this.finishNode(node2, "Import");
                case types$1._this:
                  node2 = this.startNode();
                  this.next();
                  return this.finishNode(node2, "ThisExpression");
                case types$1.name: {
                  const containsEsc = this.state.containsEsc;
                  const id = this.parseIdentifier();
                  if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                    if (this.match(types$1._function)) {
                      const last2 = this.state.context.length - 1;
                      if (this.state.context[last2] !== types$1$1.functionStatement) {
                        throw new Error("Internal error");
                      }
                      this.state.context[last2] = types$1$1.functionExpression;
                      this.next();
                      return this.parseFunction(this.startNodeAtNode(id), void 0, true);
                    } else if (this.match(types$1.name)) {
                      if (this.lookaheadCharCode() === 61) {
                        return this.parseAsyncArrowUnaryFunction(id);
                      } else {
                        return id;
                      }
                    } else if (this.match(types$1._do)) {
                      return this.parseDo(true);
                    }
                  }
                  if (canBeArrow && this.match(types$1.arrow) && !this.canInsertSemicolon()) {
                    this.next();
                    return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                  }
                  return id;
                }
                case types$1._do: {
                  return this.parseDo(false);
                }
                case types$1.regexp: {
                  const value = this.state.value;
                  node2 = this.parseLiteral(value.value, "RegExpLiteral");
                  node2.pattern = value.pattern;
                  node2.flags = value.flags;
                  return node2;
                }
                case types$1.num:
                  return this.parseLiteral(this.state.value, "NumericLiteral");
                case types$1.bigint:
                  return this.parseLiteral(this.state.value, "BigIntLiteral");
                case types$1.decimal:
                  return this.parseLiteral(this.state.value, "DecimalLiteral");
                case types$1.string:
                  return this.parseLiteral(this.state.value, "StringLiteral");
                case types$1._null:
                  node2 = this.startNode();
                  this.next();
                  return this.finishNode(node2, "NullLiteral");
                case types$1._true:
                case types$1._false:
                  return this.parseBooleanLiteral();
                case types$1.parenL:
                  return this.parseParenAndDistinguishExpression(canBeArrow);
                case types$1.bracketBarL:
                case types$1.bracketHashL: {
                  return this.parseArrayLike(this.state.type === types$1.bracketBarL ? types$1.bracketBarR : types$1.bracketR, false, true, refExpressionErrors);
                }
                case types$1.bracketL: {
                  return this.parseArrayLike(types$1.bracketR, true, false, refExpressionErrors);
                }
                case types$1.braceBarL:
                case types$1.braceHashL: {
                  return this.parseObjectLike(this.state.type === types$1.braceBarL ? types$1.braceBarR : types$1.braceR, false, true, refExpressionErrors);
                }
                case types$1.braceL: {
                  return this.parseObjectLike(types$1.braceR, false, false, refExpressionErrors);
                }
                case types$1._function:
                  return this.parseFunctionOrFunctionSent();
                case types$1.at:
                  this.parseDecorators();
                case types$1._class:
                  node2 = this.startNode();
                  this.takeDecorators(node2);
                  return this.parseClass(node2, false);
                case types$1._new:
                  return this.parseNewOrNewTarget();
                case types$1.backQuote:
                  return this.parseTemplate(false);
                case types$1.doubleColon: {
                  node2 = this.startNode();
                  this.next();
                  node2.object = null;
                  const callee = node2.callee = this.parseNoCallExpr();
                  if (callee.type === "MemberExpression") {
                    return this.finishNode(node2, "BindExpression");
                  } else {
                    throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
                  }
                }
                case types$1.hash: {
                  if (this.state.inPipeline) {
                    node2 = this.startNode();
                    if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                      this.raise(node2.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);
                    }
                    this.next();
                    if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                      this.raise(node2.start, ErrorMessages.PrimaryTopicNotAllowed);
                    }
                    this.registerTopicReference();
                    return this.finishNode(node2, "PipelinePrimaryTopicReference");
                  }
                  const nextCh = this.input.codePointAt(this.state.end);
                  if (isIdentifierStart(nextCh) || nextCh === 92) {
                    const start = this.state.start;
                    node2 = this.parseMaybePrivateName(true);
                    if (this.match(types$1._in)) {
                      this.expectPlugin("privateIn");
                      this.classScope.usePrivateName(this.getPrivateNameSV(node2), node2.start);
                    } else if (this.hasPlugin("privateIn")) {
                      this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, this.getPrivateNameSV(node2));
                    } else {
                      throw this.unexpected(start);
                    }
                    return node2;
                  }
                }
                case types$1.relational: {
                  if (this.state.value === "<") {
                    const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                    if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                      this.expectOnePlugin(["jsx", "flow", "typescript"]);
                    }
                  }
                }
                default:
                  throw this.unexpected();
              }
            }
            parseAsyncArrowUnaryFunction(id) {
              const node2 = this.startNodeAtNode(id);
              this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
              const params = [this.parseIdentifier()];
              this.prodParam.exit();
              if (this.hasPrecedingLineBreak()) {
                this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
              }
              this.expect(types$1.arrow);
              this.parseArrowExpression(node2, params, true);
              return node2;
            }
            parseDo(isAsync) {
              this.expectPlugin("doExpressions");
              if (isAsync) {
                this.expectPlugin("asyncDoExpressions");
              }
              const node2 = this.startNode();
              node2.async = isAsync;
              this.next();
              const oldLabels = this.state.labels;
              this.state.labels = [];
              if (isAsync) {
                this.prodParam.enter(PARAM_AWAIT);
                node2.body = this.parseBlock();
                this.prodParam.exit();
              } else {
                node2.body = this.parseBlock();
              }
              this.state.labels = oldLabels;
              return this.finishNode(node2, "DoExpression");
            }
            parseSuper() {
              const node2 = this.startNode();
              this.next();
              if (this.match(types$1.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
                this.raise(node2.start, ErrorMessages.SuperNotAllowed);
              } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
                this.raise(node2.start, ErrorMessages.UnexpectedSuper);
              }
              if (!this.match(types$1.parenL) && !this.match(types$1.bracketL) && !this.match(types$1.dot)) {
                this.raise(node2.start, ErrorMessages.UnsupportedSuper);
              }
              return this.finishNode(node2, "Super");
            }
            parseBooleanLiteral() {
              const node2 = this.startNode();
              node2.value = this.match(types$1._true);
              this.next();
              return this.finishNode(node2, "BooleanLiteral");
            }
            parseMaybePrivateName(isPrivateNameAllowed) {
              const isPrivate = this.match(types$1.hash);
              if (isPrivate) {
                if (!isPrivateNameAllowed) {
                  this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);
                }
                const node2 = this.startNode();
                this.next();
                this.assertNoSpace("Unexpected space between # and identifier");
                node2.id = this.parseIdentifier(true);
                return this.finishNode(node2, "PrivateName");
              } else {
                return this.parseIdentifier(true);
              }
            }
            parseFunctionOrFunctionSent() {
              const node2 = this.startNode();
              this.next();
              if (this.prodParam.hasYield && this.match(types$1.dot)) {
                const meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
                this.next();
                return this.parseMetaProperty(node2, meta, "sent");
              }
              return this.parseFunction(node2);
            }
            parseMetaProperty(node2, meta, propertyName) {
              node2.meta = meta;
              if (meta.name === "function" && propertyName === "sent") {
                if (this.isContextual(propertyName)) {
                  this.expectPlugin("functionSent");
                } else if (!this.hasPlugin("functionSent")) {
                  this.unexpected();
                }
              }
              const containsEsc = this.state.containsEsc;
              node2.property = this.parseIdentifier(true);
              if (node2.property.name !== propertyName || containsEsc) {
                this.raise(node2.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
              }
              return this.finishNode(node2, "MetaProperty");
            }
            parseImportMetaProperty(node2) {
              const id = this.createIdentifier(this.startNodeAtNode(node2), "import");
              this.next();
              if (this.isContextual("meta")) {
                if (!this.inModule) {
                  this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
                }
                this.sawUnambiguousESM = true;
              }
              return this.parseMetaProperty(node2, id, "meta");
            }
            parseLiteral(value, type2, startPos, startLoc) {
              startPos = startPos || this.state.start;
              startLoc = startLoc || this.state.startLoc;
              const node2 = this.startNodeAt(startPos, startLoc);
              this.addExtra(node2, "rawValue", value);
              this.addExtra(node2, "raw", this.input.slice(startPos, this.state.end));
              node2.value = value;
              this.next();
              return this.finishNode(node2, type2);
            }
            parseParenAndDistinguishExpression(canBeArrow) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              let val;
              this.next();
              this.expressionScope.enter(newArrowHeadScope());
              const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
              this.state.maybeInArrowParameters = true;
              this.state.inFSharpPipelineDirectBody = false;
              const innerStartPos = this.state.start;
              const innerStartLoc = this.state.startLoc;
              const exprList = [];
              const refExpressionErrors = new ExpressionErrors();
              const refNeedsArrowPos = {start: 0};
              let first = true;
              let spreadStart;
              let optionalCommaStart;
              while (!this.match(types$1.parenR)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types$1.comma, refNeedsArrowPos.start || null);
                  if (this.match(types$1.parenR)) {
                    optionalCommaStart = this.state.start;
                    break;
                  }
                }
                if (this.match(types$1.ellipsis)) {
                  const spreadNodeStartPos = this.state.start;
                  const spreadNodeStartLoc = this.state.startLoc;
                  spreadStart = this.state.start;
                  exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
                  this.checkCommaAfterRest(41);
                  break;
                } else {
                  exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
                }
              }
              const innerEndPos = this.state.lastTokEnd;
              const innerEndLoc = this.state.lastTokEndLoc;
              this.expect(types$1.parenR);
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
              let arrowNode = this.startNodeAt(startPos, startLoc);
              if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
                this.expressionScope.validateAsPattern();
                this.expressionScope.exit();
                this.parseArrowExpression(arrowNode, exprList, false);
                return arrowNode;
              }
              this.expressionScope.exit();
              if (!exprList.length) {
                this.unexpected(this.state.lastTokStart);
              }
              if (optionalCommaStart)
                this.unexpected(optionalCommaStart);
              if (spreadStart)
                this.unexpected(spreadStart);
              this.checkExpressionErrors(refExpressionErrors, true);
              if (refNeedsArrowPos.start)
                this.unexpected(refNeedsArrowPos.start);
              this.toReferencedListDeep(exprList, true);
              if (exprList.length > 1) {
                val = this.startNodeAt(innerStartPos, innerStartLoc);
                val.expressions = exprList;
                this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
              } else {
                val = exprList[0];
              }
              if (!this.options.createParenthesizedExpressions) {
                this.addExtra(val, "parenthesized", true);
                this.addExtra(val, "parenStart", startPos);
                return val;
              }
              const parenExpression = this.startNodeAt(startPos, startLoc);
              parenExpression.expression = val;
              this.finishNode(parenExpression, "ParenthesizedExpression");
              return parenExpression;
            }
            shouldParseArrow() {
              return !this.canInsertSemicolon();
            }
            parseArrow(node2) {
              if (this.eat(types$1.arrow)) {
                return node2;
              }
            }
            parseParenItem(node2, startPos, startLoc) {
              return node2;
            }
            parseNewOrNewTarget() {
              const node2 = this.startNode();
              this.next();
              if (this.match(types$1.dot)) {
                const meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
                this.next();
                const metaProp = this.parseMetaProperty(node2, meta, "target");
                if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
                  this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
                }
                return metaProp;
              }
              return this.parseNew(node2);
            }
            parseNew(node2) {
              node2.callee = this.parseNoCallExpr();
              if (node2.callee.type === "Import") {
                this.raise(node2.callee.start, ErrorMessages.ImportCallNotNewExpression);
              } else if (this.isOptionalChain(node2.callee)) {
                this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
              } else if (this.eat(types$1.questionDot)) {
                this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
              }
              this.parseNewArguments(node2);
              return this.finishNode(node2, "NewExpression");
            }
            parseNewArguments(node2) {
              if (this.eat(types$1.parenL)) {
                const args = this.parseExprList(types$1.parenR);
                this.toReferencedList(args);
                node2.arguments = args;
              } else {
                node2.arguments = [];
              }
            }
            parseTemplateElement(isTagged) {
              const elem = this.startNode();
              if (this.state.value === null) {
                if (!isTagged) {
                  this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
                }
              }
              elem.value = {raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value};
              this.next();
              elem.tail = this.match(types$1.backQuote);
              return this.finishNode(elem, "TemplateElement");
            }
            parseTemplate(isTagged) {
              const node2 = this.startNode();
              this.next();
              node2.expressions = [];
              let curElt = this.parseTemplateElement(isTagged);
              node2.quasis = [curElt];
              while (!curElt.tail) {
                this.expect(types$1.dollarBraceL);
                node2.expressions.push(this.parseTemplateSubstitution());
                this.expect(types$1.braceR);
                node2.quasis.push(curElt = this.parseTemplateElement(isTagged));
              }
              this.next();
              return this.finishNode(node2, "TemplateLiteral");
            }
            parseTemplateSubstitution() {
              return this.parseExpression();
            }
            parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
              if (isRecord) {
                this.expectPlugin("recordAndTuple");
              }
              const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              const propHash = Object.create(null);
              let first = true;
              const node2 = this.startNode();
              node2.properties = [];
              this.next();
              while (!this.match(close)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types$1.comma);
                  if (this.match(close)) {
                    this.addExtra(node2, "trailingComma", this.state.lastTokStart);
                    break;
                  }
                }
                const prop2 = this.parsePropertyDefinition(isPattern, refExpressionErrors);
                if (!isPattern) {
                  this.checkProto(prop2, isRecord, propHash, refExpressionErrors);
                }
                if (isRecord && !this.isObjectProperty(prop2) && prop2.type !== "SpreadElement") {
                  this.raise(prop2.start, ErrorMessages.InvalidRecordProperty);
                }
                if (prop2.shorthand) {
                  this.addExtra(prop2, "shorthand", true);
                }
                node2.properties.push(prop2);
              }
              this.state.exprAllowed = false;
              this.next();
              this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
              let type2 = "ObjectExpression";
              if (isPattern) {
                type2 = "ObjectPattern";
              } else if (isRecord) {
                type2 = "RecordExpression";
              }
              return this.finishNode(node2, type2);
            }
            maybeAsyncOrAccessorProp(prop2) {
              return !prop2.computed && prop2.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types$1.bracketL) || this.match(types$1.star));
            }
            parsePropertyDefinition(isPattern, refExpressionErrors) {
              let decorators = [];
              if (this.match(types$1.at)) {
                if (this.hasPlugin("decorators")) {
                  this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
                }
                while (this.match(types$1.at)) {
                  decorators.push(this.parseDecorator());
                }
              }
              const prop2 = this.startNode();
              let isGenerator = false;
              let isAsync = false;
              let isAccessor = false;
              let startPos;
              let startLoc;
              if (this.match(types$1.ellipsis)) {
                if (decorators.length)
                  this.unexpected();
                if (isPattern) {
                  this.next();
                  prop2.argument = this.parseIdentifier();
                  this.checkCommaAfterRest(125);
                  return this.finishNode(prop2, "RestElement");
                }
                return this.parseSpread();
              }
              if (decorators.length) {
                prop2.decorators = decorators;
                decorators = [];
              }
              prop2.method = false;
              if (isPattern || refExpressionErrors) {
                startPos = this.state.start;
                startLoc = this.state.startLoc;
              }
              if (!isPattern) {
                isGenerator = this.eat(types$1.star);
              }
              const containsEsc = this.state.containsEsc;
              const key = this.parsePropertyName(prop2, false);
              if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop2)) {
                const keyName = key.name;
                if (keyName === "async" && !this.hasPrecedingLineBreak()) {
                  isAsync = true;
                  isGenerator = this.eat(types$1.star);
                  this.parsePropertyName(prop2, false);
                }
                if (keyName === "get" || keyName === "set") {
                  isAccessor = true;
                  prop2.kind = keyName;
                  if (this.match(types$1.star)) {
                    isGenerator = true;
                    this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
                    this.next();
                  }
                  this.parsePropertyName(prop2, false);
                }
              }
              this.parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
              return prop2;
            }
            getGetterSetterExpectedParamCount(method) {
              return method.kind === "get" ? 0 : 1;
            }
            getObjectOrClassMethodParams(method) {
              return method.params;
            }
            checkGetterSetterParams(method) {
              var _params;
              const paramCount = this.getGetterSetterExpectedParamCount(method);
              const params = this.getObjectOrClassMethodParams(method);
              const start = method.start;
              if (params.length !== paramCount) {
                if (method.kind === "get") {
                  this.raise(start, ErrorMessages.BadGetterArity);
                } else {
                  this.raise(start, ErrorMessages.BadSetterArity);
                }
              }
              if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
                this.raise(start, ErrorMessages.BadSetterRestParameter);
              }
            }
            parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor) {
              if (isAccessor) {
                this.parseMethod(prop2, isGenerator, false, false, false, "ObjectMethod");
                this.checkGetterSetterParams(prop2);
                return prop2;
              }
              if (isAsync || isGenerator || this.match(types$1.parenL)) {
                if (isPattern)
                  this.unexpected();
                prop2.kind = "method";
                prop2.method = true;
                return this.parseMethod(prop2, isGenerator, isAsync, false, false, "ObjectMethod");
              }
            }
            parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors) {
              prop2.shorthand = false;
              if (this.eat(types$1.colon)) {
                prop2.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
                return this.finishNode(prop2, "ObjectProperty");
              }
              if (!prop2.computed && prop2.key.type === "Identifier") {
                this.checkReservedWord(prop2.key.name, prop2.key.start, true, false);
                if (isPattern) {
                  prop2.value = this.parseMaybeDefault(startPos, startLoc, prop2.key.__clone());
                } else if (this.match(types$1.eq) && refExpressionErrors) {
                  if (refExpressionErrors.shorthandAssign === -1) {
                    refExpressionErrors.shorthandAssign = this.state.start;
                  }
                  prop2.value = this.parseMaybeDefault(startPos, startLoc, prop2.key.__clone());
                } else {
                  prop2.value = prop2.key.__clone();
                }
                prop2.shorthand = true;
                return this.finishNode(prop2, "ObjectProperty");
              }
            }
            parseObjPropValue(prop2, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
              const node2 = this.parseObjectMethod(prop2, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop2, startPos, startLoc, isPattern, refExpressionErrors);
              if (!node2)
                this.unexpected();
              return node2;
            }
            parsePropertyName(prop2, isPrivateNameAllowed) {
              if (this.eat(types$1.bracketL)) {
                prop2.computed = true;
                prop2.key = this.parseMaybeAssignAllowIn();
                this.expect(types$1.bracketR);
              } else {
                const oldInPropertyName = this.state.inPropertyName;
                this.state.inPropertyName = true;
                prop2.key = this.match(types$1.num) || this.match(types$1.string) || this.match(types$1.bigint) || this.match(types$1.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);
                if (!this.isPrivateName(prop2.key)) {
                  prop2.computed = false;
                }
                this.state.inPropertyName = oldInPropertyName;
              }
              return prop2.key;
            }
            initFunction(node2, isAsync) {
              node2.id = null;
              node2.generator = false;
              node2.async = !!isAsync;
            }
            parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope) {
              if (inClassScope === void 0) {
                inClassScope = false;
              }
              this.initFunction(node2, isAsync);
              node2.generator = !!isGenerator;
              const allowModifiers = isConstructor;
              this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
              this.prodParam.enter(functionFlags(isAsync, node2.generator));
              this.parseFunctionParams(node2, allowModifiers);
              this.parseFunctionBodyAndFinish(node2, type2, true);
              this.prodParam.exit();
              this.scope.exit();
              return node2;
            }
            parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
              if (isTuple) {
                this.expectPlugin("recordAndTuple");
              }
              const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              const node2 = this.startNode();
              this.next();
              node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2);
              this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
              return this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
            }
            parseArrowExpression(node2, params, isAsync, trailingCommaPos) {
              this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
              let flags = functionFlags(isAsync, false);
              if (!this.match(types$1.bracketL) && this.prodParam.hasIn) {
                flags |= PARAM_IN;
              }
              this.prodParam.enter(flags);
              this.initFunction(node2, isAsync);
              const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              if (params) {
                this.state.maybeInArrowParameters = true;
                this.setArrowFunctionParameters(node2, params, trailingCommaPos);
              }
              this.state.maybeInArrowParameters = false;
              this.parseFunctionBody(node2, true);
              this.prodParam.exit();
              this.scope.exit();
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              return this.finishNode(node2, "ArrowFunctionExpression");
            }
            setArrowFunctionParameters(node2, params, trailingCommaPos) {
              node2.params = this.toAssignableList(params, trailingCommaPos, false);
            }
            parseFunctionBodyAndFinish(node2, type2, isMethod) {
              if (isMethod === void 0) {
                isMethod = false;
              }
              this.parseFunctionBody(node2, false, isMethod);
              this.finishNode(node2, type2);
            }
            parseFunctionBody(node2, allowExpression, isMethod) {
              if (isMethod === void 0) {
                isMethod = false;
              }
              const isExpression = allowExpression && !this.match(types$1.braceL);
              this.expressionScope.enter(newExpressionScope());
              if (isExpression) {
                node2.body = this.parseMaybeAssign();
                this.checkParams(node2, false, allowExpression, false);
              } else {
                const oldStrict = this.state.strict;
                const oldLabels = this.state.labels;
                this.state.labels = [];
                this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
                node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
                  const nonSimple = !this.isSimpleParamList(node2.params);
                  if (hasStrictModeDirective && nonSimple) {
                    const errorPos = (node2.kind === "method" || node2.kind === "constructor") && !!node2.key ? node2.key.end : node2.start;
                    this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
                  }
                  const strictModeChanged = !oldStrict && this.state.strict;
                  this.checkParams(node2, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
                  if (this.state.strict && node2.id) {
                    this.checkLVal(node2.id, "function name", BIND_OUTSIDE, void 0, void 0, strictModeChanged);
                  }
                });
                this.prodParam.exit();
                this.expressionScope.exit();
                this.state.labels = oldLabels;
              }
            }
            isSimpleParamList(params) {
              for (let i = 0, len = params.length; i < len; i++) {
                if (params[i].type !== "Identifier")
                  return false;
              }
              return true;
            }
            checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged) {
              if (strictModeChanged === void 0) {
                strictModeChanged = true;
              }
              const checkClashes = new Set();
              for (const param of node2.params) {
                this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, void 0, strictModeChanged);
              }
            }
            parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
              const elts = [];
              let first = true;
              while (!this.eat(close)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types$1.comma);
                  if (this.match(close)) {
                    if (nodeForExtra) {
                      this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
                    }
                    this.next();
                    break;
                  }
                }
                elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
              }
              return elts;
            }
            parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
              let elt;
              if (this.match(types$1.comma)) {
                if (!allowEmpty) {
                  this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
                }
                elt = null;
              } else if (this.match(types$1.ellipsis)) {
                const spreadNodeStartPos = this.state.start;
                const spreadNodeStartLoc = this.state.startLoc;
                elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
              } else if (this.match(types$1.question)) {
                this.expectPlugin("partialApplication");
                if (!allowPlaceholder) {
                  this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
                }
                const node2 = this.startNode();
                this.next();
                elt = this.finishNode(node2, "ArgumentPlaceholder");
              } else {
                elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
              }
              return elt;
            }
            parseIdentifier(liberal) {
              const node2 = this.startNode();
              const name2 = this.parseIdentifierName(node2.start, liberal);
              return this.createIdentifier(node2, name2);
            }
            createIdentifier(node2, name2) {
              node2.name = name2;
              node2.loc.identifierName = name2;
              return this.finishNode(node2, "Identifier");
            }
            parseIdentifierName(pos, liberal) {
              let name2;
              const {start, type: type2} = this.state;
              if (type2 === types$1.name) {
                name2 = this.state.value;
              } else if (type2.keyword) {
                name2 = type2.keyword;
                const curContext = this.curContext();
                if ((type2 === types$1._class || type2 === types$1._function) && (curContext === types$1$1.functionStatement || curContext === types$1$1.functionExpression)) {
                  this.state.context.pop();
                }
              } else {
                throw this.unexpected();
              }
              if (liberal) {
                this.state.type = types$1.name;
              } else {
                this.checkReservedWord(name2, start, !!type2.keyword, false);
              }
              this.next();
              return name2;
            }
            checkReservedWord(word, startLoc, checkKeywords, isBinding) {
              if (this.prodParam.hasYield && word === "yield") {
                this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
                return;
              }
              if (word === "await") {
                if (this.prodParam.hasAwait) {
                  this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
                  return;
                } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {
                  this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
                  return;
                } else {
                  this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
                }
              }
              if (this.scope.inClass && !this.scope.inNonArrowFunction && word === "arguments") {
                this.raise(startLoc, ErrorMessages.ArgumentsInClass);
                return;
              }
              if (checkKeywords && isKeyword(word)) {
                this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
                return;
              }
              const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
              if (reservedTest(word, this.inModule)) {
                this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
              }
            }
            isAwaitAllowed() {
              if (this.prodParam.hasAwait)
                return true;
              if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
                return true;
              }
              return false;
            }
            parseAwait(startPos, startLoc) {
              const node2 = this.startNodeAt(startPos, startLoc);
              this.expressionScope.recordParameterInitializerError(node2.start, ErrorMessages.AwaitExpressionFormalParameter);
              if (this.eat(types$1.star)) {
                this.raise(node2.start, ErrorMessages.ObsoleteAwaitStar);
              }
              if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
                if (this.isAmbiguousAwait()) {
                  this.ambiguousScriptDifferentAst = true;
                } else {
                  this.sawUnambiguousESM = true;
                }
              }
              if (!this.state.soloAwait) {
                node2.argument = this.parseMaybeUnary(null, true);
              }
              return this.finishNode(node2, "AwaitExpression");
            }
            isAmbiguousAwait() {
              return this.hasPrecedingLineBreak() || this.match(types$1.plusMin) || this.match(types$1.parenL) || this.match(types$1.bracketL) || this.match(types$1.backQuote) || this.match(types$1.regexp) || this.match(types$1.slash) || this.hasPlugin("v8intrinsic") && this.match(types$1.modulo);
            }
            parseYield() {
              const node2 = this.startNode();
              this.expressionScope.recordParameterInitializerError(node2.start, ErrorMessages.YieldInParameter);
              this.next();
              if (this.match(types$1.semi) || !this.match(types$1.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
                node2.delegate = false;
                node2.argument = null;
              } else {
                node2.delegate = this.eat(types$1.star);
                node2.argument = this.parseMaybeAssign();
              }
              return this.finishNode(node2, "YieldExpression");
            }
            checkPipelineAtInfixOperator(left, leftStartPos) {
              if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
                if (left.type === "SequenceExpression") {
                  this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
                }
              }
            }
            parseSmartPipelineBody(childExpression, startPos, startLoc) {
              this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);
              return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);
            }
            checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {
              if (this.match(types$1.arrow)) {
                throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
              } else if (childExpression.type === "SequenceExpression") {
                this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
              }
            }
            parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {
              const bodyNode = this.startNodeAt(startPos, startLoc);
              const isSimpleReference = this.isSimpleReference(childExpression);
              if (isSimpleReference) {
                bodyNode.callee = childExpression;
              } else {
                if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
                  this.raise(startPos, ErrorMessages.PipelineTopicUnused);
                }
                bodyNode.expression = childExpression;
              }
              return this.finishNode(bodyNode, isSimpleReference ? "PipelineBareFunction" : "PipelineTopicExpression");
            }
            isSimpleReference(expression) {
              switch (expression.type) {
                case "MemberExpression":
                  return !expression.computed && this.isSimpleReference(expression.object);
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            withTopicPermittingContext(callback) {
              const outerContextTopicState = this.state.topicContext;
              this.state.topicContext = {maxNumOfResolvableTopics: 1, maxTopicIndex: null};
              try {
                return callback();
              } finally {
                this.state.topicContext = outerContextTopicState;
              }
            }
            withTopicForbiddingContext(callback) {
              const outerContextTopicState = this.state.topicContext;
              this.state.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
              try {
                return callback();
              } finally {
                this.state.topicContext = outerContextTopicState;
              }
            }
            withSoloAwaitPermittingContext(callback) {
              const outerContextSoloAwaitState = this.state.soloAwait;
              this.state.soloAwait = true;
              try {
                return callback();
              } finally {
                this.state.soloAwait = outerContextSoloAwaitState;
              }
            }
            allowInAnd(callback) {
              const flags = this.prodParam.currentFlags();
              const prodParamToSet = PARAM_IN & ~flags;
              if (prodParamToSet) {
                this.prodParam.enter(flags | PARAM_IN);
                try {
                  return callback();
                } finally {
                  this.prodParam.exit();
                }
              }
              return callback();
            }
            disallowInAnd(callback) {
              const flags = this.prodParam.currentFlags();
              const prodParamToClear = PARAM_IN & flags;
              if (prodParamToClear) {
                this.prodParam.enter(flags & ~PARAM_IN);
                try {
                  return callback();
                } finally {
                  this.prodParam.exit();
                }
              }
              return callback();
            }
            registerTopicReference() {
              this.state.topicContext.maxTopicIndex = 0;
            }
            primaryTopicReferenceIsAllowedInCurrentTopicContext() {
              return this.state.topicContext.maxNumOfResolvableTopics >= 1;
            }
            topicReferenceWasUsedInCurrentTopicContext() {
              return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
            }
            parseFSharpPipelineBody(prec) {
              const startPos = this.state.start;
              const startLoc = this.state.startLoc;
              this.state.potentialArrowAt = this.state.start;
              const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = true;
              const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
              this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
              return ret;
            }
            parseModuleExpression() {
              this.expectPlugin("moduleBlocks");
              const node2 = this.startNode();
              this.next();
              this.eat(types$1.braceL);
              const revertScopes = this.initializeScopes(true);
              this.enterInitialScopes();
              const program = this.startNode();
              try {
                node2.body = this.parseProgram(program, types$1.braceR, "module");
              } finally {
                revertScopes();
              }
              this.eat(types$1.braceR);
              return this.finishNode(node2, "ModuleExpression");
            }
          }
          const loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};
          const FUNC_NO_FLAGS = 0, FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
          const loneSurrogate = /[\uD800-\uDFFF]/u;
          class StatementParser extends ExpressionParser {
            parseTopLevel(file, program) {
              file.program = this.parseProgram(program);
              file.comments = this.state.comments;
              if (this.options.tokens)
                file.tokens = this.tokens;
              return this.finishNode(file, "File");
            }
            parseProgram(program, end, sourceType) {
              if (end === void 0) {
                end = types$1.eof;
              }
              if (sourceType === void 0) {
                sourceType = this.options.sourceType;
              }
              program.sourceType = sourceType;
              program.interpreter = this.parseInterpreterDirective();
              this.parseBlockBody(program, true, true, end);
              if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
                for (const [name2] of Array.from(this.scope.undefinedExports)) {
                  const pos = this.scope.undefinedExports.get(name2);
                  this.raise(pos, ErrorMessages.ModuleExportUndefined, name2);
                }
              }
              return this.finishNode(program, "Program");
            }
            stmtToDirective(stmt) {
              const expr2 = stmt.expression;
              const directiveLiteral = this.startNodeAt(expr2.start, expr2.loc.start);
              const directive = this.startNodeAt(stmt.start, stmt.loc.start);
              const raw = this.input.slice(expr2.start, expr2.end);
              const val = directiveLiteral.value = raw.slice(1, -1);
              this.addExtra(directiveLiteral, "raw", raw);
              this.addExtra(directiveLiteral, "rawValue", val);
              directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr2.end, expr2.loc.end);
              return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
            }
            parseInterpreterDirective() {
              if (!this.match(types$1.interpreterDirective)) {
                return null;
              }
              const node2 = this.startNode();
              node2.value = this.state.value;
              this.next();
              return this.finishNode(node2, "InterpreterDirective");
            }
            isLet(context) {
              if (!this.isContextual("let")) {
                return false;
              }
              return this.isLetKeyword(context);
            }
            isLetKeyword(context) {
              const next = this.nextTokenStart();
              const nextCh = this.input.charCodeAt(next);
              if (nextCh === 91)
                return true;
              if (context)
                return false;
              if (nextCh === 123)
                return true;
              if (isIdentifierStart(nextCh)) {
                let pos = next + 1;
                while (isIdentifierChar(this.input.charCodeAt(pos))) {
                  ++pos;
                }
                const ident = this.input.slice(next, pos);
                if (!keywordRelationalOperator.test(ident))
                  return true;
              }
              return false;
            }
            parseStatement(context, topLevel) {
              if (this.match(types$1.at)) {
                this.parseDecorators(true);
              }
              return this.parseStatementContent(context, topLevel);
            }
            parseStatementContent(context, topLevel) {
              let starttype = this.state.type;
              const node2 = this.startNode();
              let kind;
              if (this.isLet(context)) {
                starttype = types$1._var;
                kind = "let";
              }
              switch (starttype) {
                case types$1._break:
                case types$1._continue:
                  return this.parseBreakContinueStatement(node2, starttype.keyword);
                case types$1._debugger:
                  return this.parseDebuggerStatement(node2);
                case types$1._do:
                  return this.parseDoStatement(node2);
                case types$1._for:
                  return this.parseForStatement(node2);
                case types$1._function:
                  if (this.lookaheadCharCode() === 46)
                    break;
                  if (context) {
                    if (this.state.strict) {
                      this.raise(this.state.start, ErrorMessages.StrictFunction);
                    } else if (context !== "if" && context !== "label") {
                      this.raise(this.state.start, ErrorMessages.SloppyFunction);
                    }
                  }
                  return this.parseFunctionStatement(node2, false, !context);
                case types$1._class:
                  if (context)
                    this.unexpected();
                  return this.parseClass(node2, true);
                case types$1._if:
                  return this.parseIfStatement(node2);
                case types$1._return:
                  return this.parseReturnStatement(node2);
                case types$1._switch:
                  return this.parseSwitchStatement(node2);
                case types$1._throw:
                  return this.parseThrowStatement(node2);
                case types$1._try:
                  return this.parseTryStatement(node2);
                case types$1._const:
                case types$1._var:
                  kind = kind || this.state.value;
                  if (context && kind !== "var") {
                    this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
                  }
                  return this.parseVarStatement(node2, kind);
                case types$1._while:
                  return this.parseWhileStatement(node2);
                case types$1._with:
                  return this.parseWithStatement(node2);
                case types$1.braceL:
                  return this.parseBlock();
                case types$1.semi:
                  return this.parseEmptyStatement(node2);
                case types$1._import: {
                  const nextTokenCharCode = this.lookaheadCharCode();
                  if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                    break;
                  }
                }
                case types$1._export: {
                  if (!this.options.allowImportExportEverywhere && !topLevel) {
                    this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
                  }
                  this.next();
                  let result;
                  if (starttype === types$1._import) {
                    result = this.parseImport(node2);
                    if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                      this.sawUnambiguousESM = true;
                    }
                  } else {
                    result = this.parseExport(node2);
                    if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                      this.sawUnambiguousESM = true;
                    }
                  }
                  this.assertModuleNodeAllowed(node2);
                  return result;
                }
                default: {
                  if (this.isAsyncFunction()) {
                    if (context) {
                      this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
                    }
                    this.next();
                    return this.parseFunctionStatement(node2, true, !context);
                  }
                }
              }
              const maybeName = this.state.value;
              const expr2 = this.parseExpression();
              if (starttype === types$1.name && expr2.type === "Identifier" && this.eat(types$1.colon)) {
                return this.parseLabeledStatement(node2, maybeName, expr2, context);
              } else {
                return this.parseExpressionStatement(node2, expr2);
              }
            }
            assertModuleNodeAllowed(node2) {
              if (!this.options.allowImportExportEverywhere && !this.inModule) {
                this.raise(node2.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
              }
            }
            takeDecorators(node2) {
              const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
              if (decorators.length) {
                node2.decorators = decorators;
                this.resetStartLocationFromNode(node2, decorators[0]);
                this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
              }
            }
            canHaveLeadingDecorator() {
              return this.match(types$1._class);
            }
            parseDecorators(allowExport) {
              const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
              while (this.match(types$1.at)) {
                const decorator = this.parseDecorator();
                currentContextDecorators.push(decorator);
              }
              if (this.match(types$1._export)) {
                if (!allowExport) {
                  this.unexpected();
                }
                if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                  this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
                }
              } else if (!this.canHaveLeadingDecorator()) {
                throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
              }
            }
            parseDecorator() {
              this.expectOnePlugin(["decorators-legacy", "decorators"]);
              const node2 = this.startNode();
              this.next();
              if (this.hasPlugin("decorators")) {
                this.state.decoratorStack.push([]);
                const startPos = this.state.start;
                const startLoc = this.state.startLoc;
                let expr2;
                if (this.eat(types$1.parenL)) {
                  expr2 = this.parseExpression();
                  this.expect(types$1.parenR);
                } else {
                  expr2 = this.parseIdentifier(false);
                  while (this.eat(types$1.dot)) {
                    const node3 = this.startNodeAt(startPos, startLoc);
                    node3.object = expr2;
                    node3.property = this.parseIdentifier(true);
                    node3.computed = false;
                    expr2 = this.finishNode(node3, "MemberExpression");
                  }
                }
                node2.expression = this.parseMaybeDecoratorArguments(expr2);
                this.state.decoratorStack.pop();
              } else {
                node2.expression = this.parseExprSubscripts();
              }
              return this.finishNode(node2, "Decorator");
            }
            parseMaybeDecoratorArguments(expr2) {
              if (this.eat(types$1.parenL)) {
                const node2 = this.startNodeAtNode(expr2);
                node2.callee = expr2;
                node2.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                this.toReferencedList(node2.arguments);
                return this.finishNode(node2, "CallExpression");
              }
              return expr2;
            }
            parseBreakContinueStatement(node2, keyword) {
              const isBreak = keyword === "break";
              this.next();
              if (this.isLineTerminator()) {
                node2.label = null;
              } else {
                node2.label = this.parseIdentifier();
                this.semicolon();
              }
              this.verifyBreakContinue(node2, keyword);
              return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
            }
            verifyBreakContinue(node2, keyword) {
              const isBreak = keyword === "break";
              let i;
              for (i = 0; i < this.state.labels.length; ++i) {
                const lab = this.state.labels[i];
                if (node2.label == null || lab.name === node2.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === "loop"))
                    break;
                  if (node2.label && isBreak)
                    break;
                }
              }
              if (i === this.state.labels.length) {
                this.raise(node2.start, ErrorMessages.IllegalBreakContinue, keyword);
              }
            }
            parseDebuggerStatement(node2) {
              this.next();
              this.semicolon();
              return this.finishNode(node2, "DebuggerStatement");
            }
            parseHeaderExpression() {
              this.expect(types$1.parenL);
              const val = this.parseExpression();
              this.expect(types$1.parenR);
              return val;
            }
            parseDoStatement(node2) {
              this.next();
              this.state.labels.push(loopLabel);
              node2.body = this.withTopicForbiddingContext(() => this.parseStatement("do"));
              this.state.labels.pop();
              this.expect(types$1._while);
              node2.test = this.parseHeaderExpression();
              this.eat(types$1.semi);
              return this.finishNode(node2, "DoWhileStatement");
            }
            parseForStatement(node2) {
              this.next();
              this.state.labels.push(loopLabel);
              let awaitAt = -1;
              if (this.isAwaitAllowed() && this.eatContextual("await")) {
                awaitAt = this.state.lastTokStart;
              }
              this.scope.enter(SCOPE_OTHER);
              this.expect(types$1.parenL);
              if (this.match(types$1.semi)) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
                return this.parseFor(node2, null);
              }
              const startsWithLet = this.isContextual("let");
              const isLet = startsWithLet && this.isLetKeyword();
              if (this.match(types$1._var) || this.match(types$1._const) || isLet) {
                const init3 = this.startNode();
                const kind = isLet ? "let" : this.state.value;
                this.next();
                this.parseVar(init3, true, kind);
                this.finishNode(init3, "VariableDeclaration");
                if ((this.match(types$1._in) || this.isContextual("of")) && init3.declarations.length === 1) {
                  return this.parseForIn(node2, init3, awaitAt);
                }
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
                return this.parseFor(node2, init3);
              }
              const startsWithUnescapedName = this.match(types$1.name) && !this.state.containsEsc;
              const refExpressionErrors = new ExpressionErrors();
              const init2 = this.parseExpression(true, refExpressionErrors);
              const isForOf = this.isContextual("of");
              if (isForOf) {
                if (startsWithLet) {
                  this.raise(init2.start, ErrorMessages.ForOfLet);
                } else if (awaitAt === -1 && startsWithUnescapedName && init2.type === "Identifier" && init2.name === "async") {
                  this.raise(init2.start, ErrorMessages.ForOfAsync);
                }
              }
              if (isForOf || this.match(types$1._in)) {
                this.toAssignable(init2, true);
                const description = isForOf ? "for-of statement" : "for-in statement";
                this.checkLVal(init2, description);
                return this.parseForIn(node2, init2, awaitAt);
              } else {
                this.checkExpressionErrors(refExpressionErrors, true);
              }
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
              return this.parseFor(node2, init2);
            }
            parseFunctionStatement(node2, isAsync, declarationPosition) {
              this.next();
              return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
            }
            parseIfStatement(node2) {
              this.next();
              node2.test = this.parseHeaderExpression();
              node2.consequent = this.parseStatement("if");
              node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
              return this.finishNode(node2, "IfStatement");
            }
            parseReturnStatement(node2) {
              if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
                this.raise(this.state.start, ErrorMessages.IllegalReturn);
              }
              this.next();
              if (this.isLineTerminator()) {
                node2.argument = null;
              } else {
                node2.argument = this.parseExpression();
                this.semicolon();
              }
              return this.finishNode(node2, "ReturnStatement");
            }
            parseSwitchStatement(node2) {
              this.next();
              node2.discriminant = this.parseHeaderExpression();
              const cases = node2.cases = [];
              this.expect(types$1.braceL);
              this.state.labels.push(switchLabel);
              this.scope.enter(SCOPE_OTHER);
              let cur;
              for (let sawDefault; !this.match(types$1.braceR); ) {
                if (this.match(types$1._case) || this.match(types$1._default)) {
                  const isCase = this.match(types$1._case);
                  if (cur)
                    this.finishNode(cur, "SwitchCase");
                  cases.push(cur = this.startNode());
                  cur.consequent = [];
                  this.next();
                  if (isCase) {
                    cur.test = this.parseExpression();
                  } else {
                    if (sawDefault) {
                      this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
                    }
                    sawDefault = true;
                    cur.test = null;
                  }
                  this.expect(types$1.colon);
                } else {
                  if (cur) {
                    cur.consequent.push(this.parseStatement(null));
                  } else {
                    this.unexpected();
                  }
                }
              }
              this.scope.exit();
              if (cur)
                this.finishNode(cur, "SwitchCase");
              this.next();
              this.state.labels.pop();
              return this.finishNode(node2, "SwitchStatement");
            }
            parseThrowStatement(node2) {
              this.next();
              if (this.hasPrecedingLineBreak()) {
                this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
              }
              node2.argument = this.parseExpression();
              this.semicolon();
              return this.finishNode(node2, "ThrowStatement");
            }
            parseCatchClauseParam() {
              const param = this.parseBindingAtom();
              const simple = param.type === "Identifier";
              this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
              this.checkLVal(param, "catch clause", BIND_LEXICAL);
              return param;
            }
            parseTryStatement(node2) {
              this.next();
              node2.block = this.parseBlock();
              node2.handler = null;
              if (this.match(types$1._catch)) {
                const clause = this.startNode();
                this.next();
                if (this.match(types$1.parenL)) {
                  this.expect(types$1.parenL);
                  clause.param = this.parseCatchClauseParam();
                  this.expect(types$1.parenR);
                } else {
                  clause.param = null;
                  this.scope.enter(SCOPE_OTHER);
                }
                clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));
                this.scope.exit();
                node2.handler = this.finishNode(clause, "CatchClause");
              }
              node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
              if (!node2.handler && !node2.finalizer) {
                this.raise(node2.start, ErrorMessages.NoCatchOrFinally);
              }
              return this.finishNode(node2, "TryStatement");
            }
            parseVarStatement(node2, kind) {
              this.next();
              this.parseVar(node2, false, kind);
              this.semicolon();
              return this.finishNode(node2, "VariableDeclaration");
            }
            parseWhileStatement(node2) {
              this.next();
              node2.test = this.parseHeaderExpression();
              this.state.labels.push(loopLabel);
              node2.body = this.withTopicForbiddingContext(() => this.parseStatement("while"));
              this.state.labels.pop();
              return this.finishNode(node2, "WhileStatement");
            }
            parseWithStatement(node2) {
              if (this.state.strict) {
                this.raise(this.state.start, ErrorMessages.StrictWith);
              }
              this.next();
              node2.object = this.parseHeaderExpression();
              node2.body = this.withTopicForbiddingContext(() => this.parseStatement("with"));
              return this.finishNode(node2, "WithStatement");
            }
            parseEmptyStatement(node2) {
              this.next();
              return this.finishNode(node2, "EmptyStatement");
            }
            parseLabeledStatement(node2, maybeName, expr2, context) {
              for (const label of this.state.labels) {
                if (label.name === maybeName) {
                  this.raise(expr2.start, ErrorMessages.LabelRedeclaration, maybeName);
                }
              }
              const kind = this.state.type.isLoop ? "loop" : this.match(types$1._switch) ? "switch" : null;
              for (let i = this.state.labels.length - 1; i >= 0; i--) {
                const label = this.state.labels[i];
                if (label.statementStart === node2.start) {
                  label.statementStart = this.state.start;
                  label.kind = kind;
                } else {
                  break;
                }
              }
              this.state.labels.push({name: maybeName, kind, statementStart: this.state.start});
              node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
              this.state.labels.pop();
              node2.label = expr2;
              return this.finishNode(node2, "LabeledStatement");
            }
            parseExpressionStatement(node2, expr2) {
              node2.expression = expr2;
              this.semicolon();
              return this.finishNode(node2, "ExpressionStatement");
            }
            parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
              if (allowDirectives === void 0) {
                allowDirectives = false;
              }
              if (createNewLexicalScope === void 0) {
                createNewLexicalScope = true;
              }
              const node2 = this.startNode();
              if (allowDirectives) {
                this.state.strictErrors.clear();
              }
              this.expect(types$1.braceL);
              if (createNewLexicalScope) {
                this.scope.enter(SCOPE_OTHER);
              }
              this.parseBlockBody(node2, allowDirectives, false, types$1.braceR, afterBlockParse);
              if (createNewLexicalScope) {
                this.scope.exit();
              }
              return this.finishNode(node2, "BlockStatement");
            }
            isValidDirective(stmt) {
              return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
            }
            parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
              const body = node2.body = [];
              const directives = node2.directives = [];
              this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
            }
            parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
              const oldStrict = this.state.strict;
              let hasStrictModeDirective = false;
              let parsedNonDirective = false;
              while (!this.match(end)) {
                const stmt = this.parseStatement(null, topLevel);
                if (directives && !parsedNonDirective) {
                  if (this.isValidDirective(stmt)) {
                    const directive = this.stmtToDirective(stmt);
                    directives.push(directive);
                    if (!hasStrictModeDirective && directive.value.value === "use strict") {
                      hasStrictModeDirective = true;
                      this.setStrict(true);
                    }
                    continue;
                  }
                  parsedNonDirective = true;
                  this.state.strictErrors.clear();
                }
                body.push(stmt);
              }
              if (afterBlockParse) {
                afterBlockParse.call(this, hasStrictModeDirective);
              }
              if (!oldStrict) {
                this.setStrict(false);
              }
              this.next();
            }
            parseFor(node2, init2) {
              node2.init = init2;
              this.semicolon(false);
              node2.test = this.match(types$1.semi) ? null : this.parseExpression();
              this.semicolon(false);
              node2.update = this.match(types$1.parenR) ? null : this.parseExpression();
              this.expect(types$1.parenR);
              node2.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
              this.scope.exit();
              this.state.labels.pop();
              return this.finishNode(node2, "ForStatement");
            }
            parseForIn(node2, init2, awaitAt) {
              const isForIn = this.match(types$1._in);
              this.next();
              if (isForIn) {
                if (awaitAt > -1)
                  this.unexpected(awaitAt);
              } else {
                node2.await = awaitAt > -1;
              }
              if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.state.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
                this.raise(init2.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
              } else if (init2.type === "AssignmentPattern") {
                this.raise(init2.start, ErrorMessages.InvalidLhs, "for-loop");
              }
              node2.left = init2;
              node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
              this.expect(types$1.parenR);
              node2.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
              this.scope.exit();
              this.state.labels.pop();
              return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
            }
            parseVar(node2, isFor, kind) {
              const declarations = node2.declarations = [];
              const isTypescript = this.hasPlugin("typescript");
              node2.kind = kind;
              for (; ; ) {
                const decl = this.startNode();
                this.parseVarId(decl, kind);
                if (this.eat(types$1.eq)) {
                  decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
                } else {
                  if (kind === "const" && !(this.match(types$1._in) || this.isContextual("of"))) {
                    if (!isTypescript) {
                      this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
                    }
                  } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types$1._in) || this.isContextual("of")))) {
                    this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
                  }
                  decl.init = null;
                }
                declarations.push(this.finishNode(decl, "VariableDeclarator"));
                if (!this.eat(types$1.comma))
                  break;
              }
              return node2;
            }
            parseVarId(decl, kind) {
              decl.id = this.parseBindingAtom();
              this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, void 0, kind !== "var");
            }
            parseFunction(node2, statement, isAsync) {
              if (statement === void 0) {
                statement = FUNC_NO_FLAGS;
              }
              if (isAsync === void 0) {
                isAsync = false;
              }
              const isStatement = statement & FUNC_STATEMENT;
              const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
              const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
              this.initFunction(node2, isAsync);
              if (this.match(types$1.star) && isHangingStatement) {
                this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
              }
              node2.generator = this.eat(types$1.star);
              if (isStatement) {
                node2.id = this.parseFunctionId(requireId);
              }
              const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = false;
              this.scope.enter(SCOPE_FUNCTION);
              this.prodParam.enter(functionFlags(isAsync, node2.generator));
              if (!isStatement) {
                node2.id = this.parseFunctionId();
              }
              this.parseFunctionParams(node2, false);
              this.withTopicForbiddingContext(() => {
                this.parseFunctionBodyAndFinish(node2, isStatement ? "FunctionDeclaration" : "FunctionExpression");
              });
              this.prodParam.exit();
              this.scope.exit();
              if (isStatement && !isHangingStatement) {
                this.registerFunctionStatementId(node2);
              }
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              return node2;
            }
            parseFunctionId(requireId) {
              return requireId || this.match(types$1.name) ? this.parseIdentifier() : null;
            }
            parseFunctionParams(node2, allowModifiers) {
              this.expect(types$1.parenL);
              this.expressionScope.enter(newParameterDeclarationScope());
              node2.params = this.parseBindingList(types$1.parenR, 41, false, allowModifiers);
              this.expressionScope.exit();
            }
            registerFunctionStatementId(node2) {
              if (!node2.id)
                return;
              this.scope.declareName(node2.id.name, this.state.strict || node2.generator || node2.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node2.id.start);
            }
            parseClass(node2, isStatement, optionalId) {
              this.next();
              this.takeDecorators(node2);
              const oldStrict = this.state.strict;
              this.state.strict = true;
              this.parseClassId(node2, isStatement, optionalId);
              this.parseClassSuper(node2);
              node2.body = this.parseClassBody(!!node2.superClass, oldStrict);
              return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
            }
            isClassProperty() {
              return this.match(types$1.eq) || this.match(types$1.semi) || this.match(types$1.braceR);
            }
            isClassMethod() {
              return this.match(types$1.parenL);
            }
            isNonstaticConstructor(method) {
              return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
            }
            parseClassBody(hadSuperClass, oldStrict) {
              this.classScope.enter();
              const state = {hadConstructor: false, hadSuperClass};
              let decorators = [];
              const classBody = this.startNode();
              classBody.body = [];
              this.expect(types$1.braceL);
              this.withTopicForbiddingContext(() => {
                while (!this.match(types$1.braceR)) {
                  if (this.eat(types$1.semi)) {
                    if (decorators.length > 0) {
                      throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
                    }
                    continue;
                  }
                  if (this.match(types$1.at)) {
                    decorators.push(this.parseDecorator());
                    continue;
                  }
                  const member = this.startNode();
                  if (decorators.length) {
                    member.decorators = decorators;
                    this.resetStartLocationFromNode(member, decorators[0]);
                    decorators = [];
                  }
                  this.parseClassMember(classBody, member, state);
                  if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                    this.raise(member.start, ErrorMessages.DecoratorConstructor);
                  }
                }
              });
              this.state.strict = oldStrict;
              this.next();
              if (decorators.length) {
                throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
              }
              this.classScope.exit();
              return this.finishNode(classBody, "ClassBody");
            }
            parseClassMemberFromModifier(classBody, member) {
              const key = this.parseIdentifier(true);
              if (this.isClassMethod()) {
                const method = member;
                method.kind = "method";
                method.computed = false;
                method.key = key;
                method.static = false;
                this.pushClassMethod(classBody, method, false, false, false, false);
                return true;
              } else if (this.isClassProperty()) {
                const prop2 = member;
                prop2.computed = false;
                prop2.key = key;
                prop2.static = false;
                classBody.body.push(this.parseClassProperty(prop2));
                return true;
              }
              return false;
            }
            parseClassMember(classBody, member, state) {
              const isStatic = this.isContextual("static");
              if (isStatic) {
                if (this.parseClassMemberFromModifier(classBody, member)) {
                  return;
                }
                if (this.eat(types$1.braceL)) {
                  this.parseClassStaticBlock(classBody, member);
                  return;
                }
              }
              this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
            }
            parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
              const publicMethod = member;
              const privateMethod = member;
              const publicProp = member;
              const privateProp = member;
              const method = publicMethod;
              const publicMember = publicMethod;
              member.static = isStatic;
              if (this.eat(types$1.star)) {
                method.kind = "method";
                this.parseClassElementName(method);
                if (this.isPrivateName(method.key)) {
                  this.pushClassPrivateMethod(classBody, privateMethod, true, false);
                  return;
                }
                if (this.isNonstaticConstructor(publicMethod)) {
                  this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
                }
                this.pushClassMethod(classBody, publicMethod, true, false, false, false);
                return;
              }
              const containsEsc = this.state.containsEsc;
              const key = this.parseClassElementName(member);
              const isPrivate = this.isPrivateName(key);
              const isSimple = key.type === "Identifier";
              const maybeQuestionTokenStart = this.state.start;
              this.parsePostMemberNameModifiers(publicMember);
              if (this.isClassMethod()) {
                method.kind = "method";
                if (isPrivate) {
                  this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                  return;
                }
                const isConstructor = this.isNonstaticConstructor(publicMethod);
                let allowsDirectSuper = false;
                if (isConstructor) {
                  publicMethod.kind = "constructor";
                  if (state.hadConstructor && !this.hasPlugin("typescript")) {
                    this.raise(key.start, ErrorMessages.DuplicateConstructor);
                  }
                  if (isConstructor && this.hasPlugin("typescript") && member.override) {
                    this.raise(key.start, ErrorMessages.OverrideOnConstructor);
                  }
                  state.hadConstructor = true;
                  allowsDirectSuper = state.hadSuperClass;
                }
                this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
              } else if (this.isClassProperty()) {
                if (isPrivate) {
                  this.pushClassPrivateProperty(classBody, privateProp);
                } else {
                  this.pushClassProperty(classBody, publicProp);
                }
              } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
                const isGenerator = this.eat(types$1.star);
                if (publicMember.optional) {
                  this.unexpected(maybeQuestionTokenStart);
                }
                method.kind = "method";
                this.parseClassElementName(method);
                this.parsePostMemberNameModifiers(publicMember);
                if (this.isPrivateName(method.key)) {
                  this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
                } else {
                  if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
                  }
                  this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
                }
              } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types$1.star) && this.isLineTerminator())) {
                method.kind = key.name;
                this.parseClassElementName(publicMethod);
                if (this.isPrivateName(method.key)) {
                  this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                } else {
                  if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
                  }
                  this.pushClassMethod(classBody, publicMethod, false, false, false, false);
                }
                this.checkGetterSetterParams(publicMethod);
              } else if (this.isLineTerminator()) {
                if (isPrivate) {
                  this.pushClassPrivateProperty(classBody, privateProp);
                } else {
                  this.pushClassProperty(classBody, publicProp);
                }
              } else {
                this.unexpected();
              }
            }
            parseClassElementName(member) {
              const key = this.parsePropertyName(member, true);
              if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
                this.raise(key.start, ErrorMessages.StaticPrototype);
              }
              if (this.isPrivateName(key) && this.getPrivateNameSV(key) === "constructor") {
                this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);
              }
              return key;
            }
            parseClassStaticBlock(classBody, member) {
              var _member$decorators;
              this.expectPlugin("classStaticBlock", member.start);
              this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
              const oldLabels = this.state.labels;
              this.state.labels = [];
              this.prodParam.enter(PARAM);
              const body = member.body = [];
              this.parseBlockOrModuleBlockBody(body, void 0, false, types$1.braceR);
              this.prodParam.exit();
              this.scope.exit();
              this.state.labels = oldLabels;
              classBody.body.push(this.finishNode(member, "StaticBlock"));
              if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
                this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
              }
            }
            pushClassProperty(classBody, prop2) {
              if (!prop2.computed && (prop2.key.name === "constructor" || prop2.key.value === "constructor")) {
                this.raise(prop2.key.start, ErrorMessages.ConstructorClassField);
              }
              classBody.body.push(this.parseClassProperty(prop2));
            }
            pushClassPrivateProperty(classBody, prop2) {
              const node2 = this.parseClassPrivateProperty(prop2);
              classBody.body.push(node2);
              this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER, node2.key.start);
            }
            pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
              classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
            }
            pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
              const node2 = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
              classBody.body.push(node2);
              const kind = node2.kind === "get" ? node2.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node2.kind === "set" ? node2.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
              this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.start);
            }
            parsePostMemberNameModifiers(methodOrProp) {
            }
            parseClassPrivateProperty(node2) {
              this.parseInitializer(node2);
              this.semicolon();
              return this.finishNode(node2, "ClassPrivateProperty");
            }
            parseClassProperty(node2) {
              this.parseInitializer(node2);
              this.semicolon();
              return this.finishNode(node2, "ClassProperty");
            }
            parseInitializer(node2) {
              this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
              this.expressionScope.enter(newExpressionScope());
              this.prodParam.enter(PARAM);
              node2.value = this.eat(types$1.eq) ? this.parseMaybeAssignAllowIn() : null;
              this.expressionScope.exit();
              this.prodParam.exit();
              this.scope.exit();
            }
            parseClassId(node2, isStatement, optionalId, bindingType) {
              if (bindingType === void 0) {
                bindingType = BIND_CLASS;
              }
              if (this.match(types$1.name)) {
                node2.id = this.parseIdentifier();
                if (isStatement) {
                  this.checkLVal(node2.id, "class name", bindingType);
                }
              } else {
                if (optionalId || !isStatement) {
                  node2.id = null;
                } else {
                  this.unexpected(null, ErrorMessages.MissingClassName);
                }
              }
            }
            parseClassSuper(node2) {
              node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts() : null;
            }
            parseExport(node2) {
              const hasDefault = this.maybeParseExportDefaultSpecifier(node2);
              const parseAfterDefault = !hasDefault || this.eat(types$1.comma);
              const hasStar = parseAfterDefault && this.eatExportStar(node2);
              const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2);
              const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types$1.comma));
              const isFromRequired = hasDefault || hasStar;
              if (hasStar && !hasNamespace) {
                if (hasDefault)
                  this.unexpected();
                this.parseExportFrom(node2, true);
                return this.finishNode(node2, "ExportAllDeclaration");
              }
              const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2);
              if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
                throw this.unexpected(null, types$1.braceL);
              }
              let hasDeclaration;
              if (isFromRequired || hasSpecifiers) {
                hasDeclaration = false;
                this.parseExportFrom(node2, isFromRequired);
              } else {
                hasDeclaration = this.maybeParseExportDeclaration(node2);
              }
              if (isFromRequired || hasSpecifiers || hasDeclaration) {
                this.checkExport(node2, true, false, !!node2.source);
                return this.finishNode(node2, "ExportNamedDeclaration");
              }
              if (this.eat(types$1._default)) {
                node2.declaration = this.parseExportDefaultExpression();
                this.checkExport(node2, true, true);
                return this.finishNode(node2, "ExportDefaultDeclaration");
              }
              throw this.unexpected(null, types$1.braceL);
            }
            eatExportStar(node2) {
              return this.eat(types$1.star);
            }
            maybeParseExportDefaultSpecifier(node2) {
              if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                const specifier = this.startNode();
                specifier.exported = this.parseIdentifier(true);
                node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
                return true;
              }
              return false;
            }
            maybeParseExportNamespaceSpecifier(node2) {
              if (this.isContextual("as")) {
                if (!node2.specifiers)
                  node2.specifiers = [];
                const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
                this.next();
                specifier.exported = this.parseModuleExportName();
                node2.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
                return true;
              }
              return false;
            }
            maybeParseExportNamedSpecifiers(node2) {
              if (this.match(types$1.braceL)) {
                if (!node2.specifiers)
                  node2.specifiers = [];
                node2.specifiers.push(...this.parseExportSpecifiers());
                node2.source = null;
                node2.declaration = null;
                return true;
              }
              return false;
            }
            maybeParseExportDeclaration(node2) {
              if (this.shouldParseExportDeclaration()) {
                node2.specifiers = [];
                node2.source = null;
                node2.declaration = this.parseExportDeclaration(node2);
                return true;
              }
              return false;
            }
            isAsyncFunction() {
              if (!this.isContextual("async"))
                return false;
              const next = this.nextTokenStart();
              return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
            }
            parseExportDefaultExpression() {
              const expr2 = this.startNode();
              const isAsync = this.isAsyncFunction();
              if (this.match(types$1._function) || isAsync) {
                this.next();
                if (isAsync) {
                  this.next();
                }
                return this.parseFunction(expr2, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
              } else if (this.match(types$1._class)) {
                return this.parseClass(expr2, true, true);
              } else if (this.match(types$1.at)) {
                if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                  this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
                }
                this.parseDecorators(false);
                return this.parseClass(expr2, true, true);
              } else if (this.match(types$1._const) || this.match(types$1._var) || this.isLet()) {
                throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
              } else {
                const res = this.parseMaybeAssignAllowIn();
                this.semicolon();
                return res;
              }
            }
            parseExportDeclaration(node2) {
              return this.parseStatement(null);
            }
            isExportDefaultSpecifier() {
              if (this.match(types$1.name)) {
                const value = this.state.value;
                if (value === "async" && !this.state.containsEsc || value === "let") {
                  return false;
                }
                if ((value === "type" || value === "interface") && !this.state.containsEsc) {
                  const l = this.lookahead();
                  if (l.type === types$1.name && l.value !== "from" || l.type === types$1.braceL) {
                    this.expectOnePlugin(["flow", "typescript"]);
                    return false;
                  }
                }
              } else if (!this.match(types$1._default)) {
                return false;
              }
              const next = this.nextTokenStart();
              const hasFrom = this.isUnparsedContextual(next, "from");
              if (this.input.charCodeAt(next) === 44 || this.match(types$1.name) && hasFrom) {
                return true;
              }
              if (this.match(types$1._default) && hasFrom) {
                const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
                return nextAfterFrom === 34 || nextAfterFrom === 39;
              }
              return false;
            }
            parseExportFrom(node2, expect) {
              if (this.eatContextual("from")) {
                node2.source = this.parseImportSource();
                this.checkExport(node2);
                const assertions = this.maybeParseImportAssertions();
                if (assertions) {
                  node2.assertions = assertions;
                }
              } else {
                if (expect) {
                  this.unexpected();
                } else {
                  node2.source = null;
                }
              }
              this.semicolon();
            }
            shouldParseExportDeclaration() {
              if (this.match(types$1.at)) {
                this.expectOnePlugin(["decorators", "decorators-legacy"]);
                if (this.hasPlugin("decorators")) {
                  if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                    this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
                  } else {
                    return true;
                  }
                }
              }
              return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
            }
            checkExport(node2, checkNames, isDefault, isFrom) {
              if (checkNames) {
                if (isDefault) {
                  this.checkDuplicateExports(node2, "default");
                  if (this.hasPlugin("exportDefaultFrom")) {
                    var _declaration$extra;
                    const declaration = node2.declaration;
                    if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                      this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
                    }
                  }
                } else if (node2.specifiers && node2.specifiers.length) {
                  for (const specifier of node2.specifiers) {
                    const {exported} = specifier;
                    const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
                    this.checkDuplicateExports(specifier, exportedName);
                    if (!isFrom && specifier.local) {
                      const {local} = specifier;
                      if (local.type === "StringLiteral") {
                        this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
                      } else {
                        this.checkReservedWord(local.name, local.start, true, false);
                        this.scope.checkLocalExport(local);
                      }
                    }
                  }
                } else if (node2.declaration) {
                  if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
                    const id = node2.declaration.id;
                    if (!id)
                      throw new Error("Assertion failure");
                    this.checkDuplicateExports(node2, id.name);
                  } else if (node2.declaration.type === "VariableDeclaration") {
                    for (const declaration of node2.declaration.declarations) {
                      this.checkDeclaration(declaration.id);
                    }
                  }
                }
              }
              const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
              if (currentContextDecorators.length) {
                throw this.raise(node2.start, ErrorMessages.UnsupportedDecoratorExport);
              }
            }
            checkDeclaration(node2) {
              if (node2.type === "Identifier") {
                this.checkDuplicateExports(node2, node2.name);
              } else if (node2.type === "ObjectPattern") {
                for (const prop2 of node2.properties) {
                  this.checkDeclaration(prop2);
                }
              } else if (node2.type === "ArrayPattern") {
                for (const elem of node2.elements) {
                  if (elem) {
                    this.checkDeclaration(elem);
                  }
                }
              } else if (node2.type === "ObjectProperty") {
                this.checkDeclaration(node2.value);
              } else if (node2.type === "RestElement") {
                this.checkDeclaration(node2.argument);
              } else if (node2.type === "AssignmentPattern") {
                this.checkDeclaration(node2.left);
              }
            }
            checkDuplicateExports(node2, name2) {
              if (this.state.exportedIdentifiers.indexOf(name2) > -1) {
                this.raise(node2.start, name2 === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name2);
              }
              this.state.exportedIdentifiers.push(name2);
            }
            parseExportSpecifiers() {
              const nodes = [];
              let first = true;
              this.expect(types$1.braceL);
              while (!this.eat(types$1.braceR)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types$1.comma);
                  if (this.eat(types$1.braceR))
                    break;
                }
                const node2 = this.startNode();
                node2.local = this.parseModuleExportName();
                node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local.__clone();
                nodes.push(this.finishNode(node2, "ExportSpecifier"));
              }
              return nodes;
            }
            parseModuleExportName() {
              if (this.match(types$1.string)) {
                const result = this.parseLiteral(this.state.value, "StringLiteral");
                const surrogate = result.value.match(loneSurrogate);
                if (surrogate) {
                  this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
                }
                return result;
              }
              return this.parseIdentifier(true);
            }
            parseImport(node2) {
              node2.specifiers = [];
              if (!this.match(types$1.string)) {
                const hasDefault = this.maybeParseDefaultImportSpecifier(node2);
                const parseNext = !hasDefault || this.eat(types$1.comma);
                const hasStar = parseNext && this.maybeParseStarImportSpecifier(node2);
                if (parseNext && !hasStar)
                  this.parseNamedImportSpecifiers(node2);
                this.expectContextual("from");
              }
              node2.source = this.parseImportSource();
              const assertions = this.maybeParseImportAssertions();
              if (assertions) {
                node2.assertions = assertions;
              } else {
                const attributes = this.maybeParseModuleAttributes();
                if (attributes) {
                  node2.attributes = attributes;
                }
              }
              this.semicolon();
              return this.finishNode(node2, "ImportDeclaration");
            }
            parseImportSource() {
              if (!this.match(types$1.string))
                this.unexpected();
              return this.parseExprAtom();
            }
            shouldParseDefaultImport(node2) {
              return this.match(types$1.name);
            }
            parseImportSpecifierLocal(node2, specifier, type2, contextDescription) {
              specifier.local = this.parseIdentifier();
              this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
              node2.specifiers.push(this.finishNode(specifier, type2));
            }
            parseAssertEntries() {
              const attrs = [];
              const attrNames = new Set();
              do {
                if (this.match(types$1.braceR)) {
                  break;
                }
                const node2 = this.startNode();
                const keyName = this.state.value;
                if (this.match(types$1.string)) {
                  node2.key = this.parseLiteral(keyName, "StringLiteral");
                } else {
                  node2.key = this.parseIdentifier(true);
                }
                this.expect(types$1.colon);
                if (keyName !== "type") {
                  this.raise(node2.key.start, ErrorMessages.ModuleAttributeDifferentFromType, keyName);
                }
                if (attrNames.has(keyName)) {
                  this.raise(node2.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
                }
                attrNames.add(keyName);
                if (!this.match(types$1.string)) {
                  throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
                }
                node2.value = this.parseLiteral(this.state.value, "StringLiteral");
                this.finishNode(node2, "ImportAttribute");
                attrs.push(node2);
              } while (this.eat(types$1.comma));
              return attrs;
            }
            maybeParseModuleAttributes() {
              if (this.match(types$1._with) && !this.hasPrecedingLineBreak()) {
                this.expectPlugin("moduleAttributes");
                this.next();
              } else {
                if (this.hasPlugin("moduleAttributes"))
                  return [];
                return null;
              }
              const attrs = [];
              const attributes = new Set();
              do {
                const node2 = this.startNode();
                node2.key = this.parseIdentifier(true);
                if (node2.key.name !== "type") {
                  this.raise(node2.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node2.key.name);
                }
                if (attributes.has(node2.key.name)) {
                  this.raise(node2.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node2.key.name);
                }
                attributes.add(node2.key.name);
                this.expect(types$1.colon);
                if (!this.match(types$1.string)) {
                  throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
                }
                node2.value = this.parseLiteral(this.state.value, "StringLiteral");
                this.finishNode(node2, "ImportAttribute");
                attrs.push(node2);
              } while (this.eat(types$1.comma));
              return attrs;
            }
            maybeParseImportAssertions() {
              if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
                this.expectPlugin("importAssertions");
                this.next();
              } else {
                if (this.hasPlugin("importAssertions"))
                  return [];
                return null;
              }
              this.eat(types$1.braceL);
              const attrs = this.parseAssertEntries();
              this.eat(types$1.braceR);
              return attrs;
            }
            maybeParseDefaultImportSpecifier(node2) {
              if (this.shouldParseDefaultImport(node2)) {
                this.parseImportSpecifierLocal(node2, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
                return true;
              }
              return false;
            }
            maybeParseStarImportSpecifier(node2) {
              if (this.match(types$1.star)) {
                const specifier = this.startNode();
                this.next();
                this.expectContextual("as");
                this.parseImportSpecifierLocal(node2, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
                return true;
              }
              return false;
            }
            parseNamedImportSpecifiers(node2) {
              let first = true;
              this.expect(types$1.braceL);
              while (!this.eat(types$1.braceR)) {
                if (first) {
                  first = false;
                } else {
                  if (this.eat(types$1.colon)) {
                    throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
                  }
                  this.expect(types$1.comma);
                  if (this.eat(types$1.braceR))
                    break;
                }
                this.parseImportSpecifier(node2);
              }
            }
            parseImportSpecifier(node2) {
              const specifier = this.startNode();
              specifier.imported = this.parseModuleExportName();
              if (this.eatContextual("as")) {
                specifier.local = this.parseIdentifier();
              } else {
                const {imported} = specifier;
                if (imported.type === "StringLiteral") {
                  throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
                }
                this.checkReservedWord(imported.name, specifier.start, true, true);
                specifier.local = imported.__clone();
              }
              this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
              node2.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
            }
            isThisParam(param) {
              return param.type === "Identifier" && param.name === "this";
            }
          }
          class Parser extends StatementParser {
            constructor(options2, input) {
              options2 = getOptions(options2);
              super(options2, input);
              this.options = options2;
              this.initializeScopes();
              this.plugins = pluginsMap(this.options.plugins);
              this.filename = options2.sourceFilename;
            }
            getScopeHandler() {
              return ScopeHandler;
            }
            parse() {
              this.enterInitialScopes();
              const file = this.startNode();
              const program = this.startNode();
              this.nextToken();
              file.errors = null;
              this.parseTopLevel(file, program);
              file.errors = this.state.errors;
              return file;
            }
          }
          function pluginsMap(plugins) {
            const pluginMap = new Map();
            for (const plugin of plugins) {
              const [name2, options2] = Array.isArray(plugin) ? plugin : [plugin, {}];
              if (!pluginMap.has(name2))
                pluginMap.set(name2, options2 || {});
            }
            return pluginMap;
          }
          function parse$1(input, options2) {
            var _options;
            if (((_options = options2) == null ? void 0 : _options.sourceType) === "unambiguous") {
              options2 = Object.assign({}, options2);
              try {
                options2.sourceType = "module";
                const parser2 = getParser(options2, input);
                const ast = parser2.parse();
                if (parser2.sawUnambiguousESM) {
                  return ast;
                }
                if (parser2.ambiguousScriptDifferentAst) {
                  try {
                    options2.sourceType = "script";
                    return getParser(options2, input).parse();
                  } catch (_unused) {
                  }
                } else {
                  ast.program.sourceType = "script";
                }
                return ast;
              } catch (moduleError) {
                try {
                  options2.sourceType = "script";
                  return getParser(options2, input).parse();
                } catch (_unused2) {
                }
                throw moduleError;
              }
            } else {
              return getParser(options2, input).parse();
            }
          }
          function parseExpression(input, options2) {
            const parser2 = getParser(options2, input);
            if (parser2.options.strictMode) {
              parser2.state.strict = true;
            }
            return parser2.getExpression();
          }
          function getParser(options2, input) {
            let cls = Parser;
            if (options2 != null && options2.plugins) {
              validatePlugins(options2.plugins);
              cls = getParserClass(options2.plugins);
            }
            return new cls(options2, input);
          }
          const parserClassCache = {};
          function getParserClass(pluginsFromOptions) {
            const pluginList = mixinPluginNames.filter((name2) => hasPlugin(pluginsFromOptions, name2));
            const key = pluginList.join("/");
            let cls = parserClassCache[key];
            if (!cls) {
              cls = Parser;
              for (const plugin of pluginList) {
                cls = mixinPlugins[plugin](cls);
              }
              parserClassCache[key] = cls;
            }
            return cls;
          }
          var parse_1 = parse$1;
          var parseExpression_1 = parseExpression;
          var tokTypes = types$1;
          var lib = /* @__PURE__ */ Object.defineProperty({parse: parse_1, parseExpression: parseExpression_1, tokTypes}, "__esModule", {value: true});
          var babel = createCommonjsModule(function(module3, exports4) {
            Object.defineProperty(exports4, "__esModule", {value: true});
            exports4.parse = exports4.parser = void 0;
            var _babel_options_1 = tslib_1.__importDefault(_babel_options);
            exports4.parser = function() {
              try {
                return lib;
              } catch (e) {
                return require$$2__default["default"];
              }
            }();
            function parse(source, options2) {
              var babelOptions = _babel_options_1.default(options2);
              babelOptions.plugins.push("jsx", "flow");
              return exports4.parser.parse(source, babelOptions);
            }
            exports4.parse = parse;
          });
          function generateAST(source, options2) {
            return main.parse(source, Object.assign({parser: {parse: babel.parse}}, options2));
          }
          function findExportDefaultStatement(body) {
            return body.find(isExportDefaultStatement);
          }
          function findAllImportDeclarations(body) {
            return body.filter(isImportDeclaration);
          }
          function filterOutAllImportDeclarations(body) {
            return body.filter((n2) => !isImportDeclaration(n2));
          }
          function createDefaultExportFromLegacySyntax(body) {
            return builders.exportDefaultDeclaration(builders.functionDeclaration(builders.identifier(TAG_LOGIC_PROPERTY), [], builders.blockStatement([...filterOutAllImportDeclarations(body), builders.returnStatement(builders.thisExpression())])));
          }
          function filterNonExportDefaultStatements(body) {
            return body.filter((node2) => !isExportDefaultStatement(node2) && !isThisExpressionStatement(node2));
          }
          function getProgramBody(ast) {
            return ast.body || ast.program.body;
          }
          function extendTagProperty(ast, exportDefaultNode) {
            types$2.visit(ast, {visitProperty(path2) {
              if (path2.value.key.value === TAG_LOGIC_PROPERTY) {
                path2.value.value = exportDefaultNode.declaration;
                return false;
              }
              this.traverse(path2);
            }});
            return ast;
          }
          function javascript(sourceNode2, source, meta, ast) {
            const preprocessorName = getPreprocessorTypeByAttribute(sourceNode2);
            const javascriptNode = addLineOffset(sourceNode2.text.text, source, sourceNode2);
            const {options: options2} = meta;
            const preprocessorOutput = preprocess("javascript", preprocessorName, meta, Object.assign({}, sourceNode2, {text: javascriptNode}));
            const inputSourceMap = sourcemapAsJSON(preprocessorOutput.map);
            const generatedAst = generateAST(preprocessorOutput.code, {sourceFileName: options2.file, inputSourceMap: isEmptySourcemap(inputSourceMap) ? null : inputSourceMap});
            const generatedAstBody = getProgramBody(generatedAst);
            const exportDefaultNode = findExportDefaultStatement(generatedAstBody);
            const isLegacyRiotSyntax = isNil2(exportDefaultNode);
            const outputBody = getProgramBody(ast);
            if (exportDefaultNode && generatedAstBody.some(isThisExpressionStatement))
              throw new Error('You can	 use "export default {}" and root this statements in the same component');
            outputBody.unshift(...isLegacyRiotSyntax ? findAllImportDeclarations(generatedAstBody) : filterNonExportDefaultStatements(generatedAstBody));
            if (isLegacyRiotSyntax)
              extendTagProperty(ast, createDefaultExportFromLegacySyntax(generatedAstBody));
            if (exportDefaultNode)
              extendTagProperty(ast, exportDefaultNode);
            return ast;
          }
          const JAVASCRIPT_OUTPUT_NAME = "javascript";
          const CSS_OUTPUT_NAME = "css";
          const TEMPLATE_OUTPUT_NAME = "template";
          const JAVASCRIPT_TAG = "script";
          const STYLE_TAG = "style";
          const TEXTAREA_TAG = "textarea";
          const IS_RAW = "isRaw";
          const IS_SELF_CLOSING = "isSelfClosing";
          const IS_VOID = "isVoid";
          const IS_BOOLEAN = "isBoolean";
          const IS_CUSTOM = "isCustom";
          const IS_SPREAD = "isSpread";
          var c = /* @__PURE__ */ Object.freeze({__proto__: null, JAVASCRIPT_OUTPUT_NAME, CSS_OUTPUT_NAME, TEMPLATE_OUTPUT_NAME, JAVASCRIPT_TAG, STYLE_TAG, TEXTAREA_TAG, IS_RAW, IS_SELF_CLOSING, IS_VOID, IS_BOOLEAN, IS_CUSTOM, IS_SPREAD});
          const TAG2 = 1;
          const ATTR = 2;
          const TEXT2 = 3;
          const CDATA = 4;
          const COMMENT = 8;
          const DOCUMENT = 9;
          const DOCTYPE = 10;
          const DOCUMENT_FRAGMENT = 11;
          var types = /* @__PURE__ */ Object.freeze({__proto__: null, TAG: TAG2, ATTR, TEXT: TEXT2, CDATA, COMMENT, DOCUMENT, DOCTYPE, DOCUMENT_FRAGMENT});
          const rootTagNotFound = "Root tag not found.";
          const unclosedTemplateLiteral = "Unclosed ES6 template literal.";
          const unexpectedEndOfFile = "Unexpected end of file.";
          const unclosedComment = "Unclosed comment.";
          const unclosedNamedBlock = 'Unclosed "%1" block.';
          const duplicatedNamedTag = 'Multiple inline "<%1>" tags are not supported.';
          const unexpectedCharInExpression = "Unexpected character %1.";
          const unclosedExpression = "Unclosed expression.";
          const TAG_2C = /^(?:\/[a-zA-Z]|[a-zA-Z][^\s>/]?)/;
          const TAG_NAME = /(\/?[^\s>/]+)\s*(>)?/g;
          const ATTR_START = /(\S[^>/=\s]*)(?:\s*=\s*([^>/])?)?/g;
          const SPREAD_OPERATOR = /\.\.\./;
          const RE_SCRYLE = {script: /<\/script\s*>/gi, style: /<\/style\s*>/gi, textarea: /<\/textarea\s*>/gi};
          const RAW_TAGS = /^\/?(?:pre|textarea)$/;
          function addToCollection(collection, item) {
            if (collection === void 0) {
              collection = [];
            }
            collection.push(item);
            return collection;
          }
          function execFromPos(re, pos, string) {
            re.lastIndex = pos;
            return re.exec(string);
          }
          var escapeStr = (str) => str.replace(/(?=[-[\](){^*+?.$|\\])/g, "\\");
          function formatError(data, message, pos) {
            if (!pos) {
              pos = data.length;
            }
            const line = (data.slice(0, pos).match(/\r\n?|\n/g) || "").length + 1;
            let col = 0;
            while (--pos >= 0 && !/[\r\n]/.test(data[pos])) {
              ++col;
            }
            return `[${line},${col}]: ${message}`;
          }
          const $_ES6_BQ = "`";
          function skipES6TL(code, pos, stack) {
            const re = /[`$\\]/g;
            let c2;
            while (re.lastIndex = pos, re.exec(code)) {
              pos = re.lastIndex;
              c2 = code[pos - 1];
              if (c2 === "`") {
                return pos;
              }
              if (c2 === "$" && code[pos++] === "{") {
                stack.push($_ES6_BQ, "}");
                return pos;
              }
            }
            throw formatError(code, unclosedTemplateLiteral, pos);
          }
          function panic2(data, msg, pos) {
            const message = formatError(data, msg, pos);
            throw new Error(message);
          }
          const beforeReChars = "[{(,;:?=|&!^~>%*/";
          const beforeReSign = `${beforeReChars}+-`;
          const beforeReWords = ["case", "default", "do", "else", "in", "instanceof", "prefix", "return", "typeof", "void", "yield"];
          const wordsEndChar = beforeReWords.reduce((s, w) => s + w.slice(-1), "");
          const RE_LIT_REGEX = /^\/(?=[^*>/])[^[/\\]*(?:(?:\\.|\[(?:\\.|[^\]\\]*)*\])[^[\\/]*)*?\/[gimuy]*/;
          const RE_JS_VCHAR = /[$\w]/;
          const RE_DOT_CHAR = /.*/g;
          function _prev(code, pos) {
            while (--pos >= 0 && /\s/.test(code[pos]))
              ;
            return pos;
          }
          function skipRegex(code, start) {
            let pos = RE_DOT_CHAR.lastIndex = start++;
            const match = (RE_DOT_CHAR.exec(code) || " ")[0].match(RE_LIT_REGEX);
            if (match) {
              const next = pos + match[0].length;
              pos = _prev(code, pos);
              let c2 = code[pos];
              if (pos < 0 || beforeReChars.includes(c2)) {
                return next;
              }
              if (c2 === ".") {
                if (code[pos - 1] === ".") {
                  start = next;
                }
              } else {
                if (c2 === "+" || c2 === "-") {
                  if (code[--pos] !== c2 || (pos = _prev(code, pos)) < 0 || beforeReSign.includes(c2 = code[pos])) {
                    return next;
                  }
                }
                if (wordsEndChar.includes(c2)) {
                  const end = pos + 1;
                  while (--pos >= 0 && RE_JS_VCHAR.test(code[pos]))
                    ;
                  if (beforeReWords.includes(code.slice(pos + 1, end))) {
                    start = next;
                  }
                }
              }
            }
            return start;
          }
          const S_SQ_STR = /'[^'\n\r\\]*(?:\\(?:\r\n?|[\S\s])[^'\n\r\\]*)*'/.source;
          const S_STRING = `${S_SQ_STR}|${S_SQ_STR.replace(/'/g, '"')}`;
          const reBr = {};
          function _regex(b) {
            let re = reBr[b];
            if (!re) {
              let s = escapeStr(b);
              if (b.length > 1) {
                s = `${s}|[`;
              } else {
                s = /[{}[\]()]/.test(b) ? "[" : `[${s}`;
              }
              reBr[b] = re = new RegExp(`${S_STRING}|${s}\`/\\{}[\\]()]`, "g");
            }
            return re;
          }
          function updateStack(stack, char, idx, code) {
            let index = 0;
            switch (char) {
              case "[":
              case "(":
              case "{":
                stack.push(char === "[" ? "]" : char === "(" ? ")" : "}");
                break;
              case ")":
              case "]":
              case "}":
                if (char !== stack.pop()) {
                  panic2(code, unexpectedCharInExpression.replace("%1", char), index);
                }
                if (char === "}" && stack[stack.length - 1] === $_ES6_BQ) {
                  char = stack.pop();
                }
                index = idx + 1;
                break;
              case "/":
                index = skipRegex(code, idx);
            }
            return {char, index};
          }
          function exprExtr(code, start, bp) {
            const [openingBraces, closingBraces] = bp;
            const offset = start + openingBraces.length;
            const stack = [];
            const re = _regex(closingBraces);
            re.lastIndex = offset;
            let end;
            let match;
            while (match = re.exec(code)) {
              const idx = match.index;
              const str = match[0];
              end = re.lastIndex;
              if (str === closingBraces && !stack.length) {
                return {text: code.slice(offset, idx), start, end};
              }
              const {char, index} = updateStack(stack, str[0], idx, code);
              end = index || end;
              re.lastIndex = char === $_ES6_BQ ? skipES6TL(code, end, stack) : end;
            }
            if (stack.length) {
              panic2(code, unclosedExpression, end);
            }
          }
          function flush(store) {
            const last2 = store.last;
            store.last = null;
            if (last2 && store.root) {
              store.builder.push(last2);
            }
          }
          function getChunk(source, start, end) {
            return source.slice(start, end);
          }
          function pushText(state, start, end, extra) {
            if (extra === void 0) {
              extra = {};
            }
            const text2 = getChunk(state.data, start, end);
            const expressions2 = extra.expressions;
            const unescape2 = extra.unescape;
            let q = state.last;
            state.pos = end;
            if (q && q.type === TEXT2) {
              q.text += text2;
              q.end = end;
            } else {
              flush(state);
              state.last = q = {type: TEXT2, text: text2, start, end};
            }
            if (expressions2 && expressions2.length) {
              q.expressions = (q.expressions || []).concat(expressions2);
            }
            if (unescape2) {
              q.unescape = unescape2;
            }
            return TEXT2;
          }
          function expr(state, node2, endingChars, start) {
            const re = b0re(state, endingChars);
            re.lastIndex = start;
            const {unescape: unescape2, expressions: expressions2, end} = parseExpressions(state, re);
            if (node2) {
              if (unescape2) {
                node2.unescape = unescape2;
              }
              if (expressions2.length) {
                node2.expressions = expressions2;
              }
            } else {
              pushText(state, start, end, {expressions: expressions2, unescape: unescape2});
            }
            return end;
          }
          function parseExpressions(state, re) {
            const {data, options: options2} = state;
            const {brackets} = options2;
            const expressions2 = [];
            let unescape2, pos, match;
            while ((match = re.exec(data)) && !match[1]) {
              pos = match.index;
              if (data[pos - 1] === "\\") {
                unescape2 = match[0];
              } else {
                const tmpExpr = exprExtr(data, pos, brackets);
                if (tmpExpr) {
                  expressions2.push(tmpExpr);
                  re.lastIndex = tmpExpr.end;
                }
              }
            }
            if (!match) {
              panic2(data, unexpectedEndOfFile, pos);
            }
            return {unescape: unescape2, expressions: expressions2, end: match.index};
          }
          function b0re(state, str) {
            const {brackets} = state.options;
            const re = state.regexCache[str];
            if (re)
              return re;
            const b0 = escapeStr(brackets[0]);
            Object.assign(state.regexCache, {[str]: new RegExp(`(${str})|${b0}`, "g")});
            return state.regexCache[str];
          }
          const uniq = (l) => l.filter((x, i, a) => a.indexOf(x) === i);
          const VOID_SVG_TAGS_LIST = ["circle", "ellipse", "line", "path", "polygon", "polyline", "rect", "stop", "use"];
          const HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_LIST = ["button", "data", "input", "select", "li", "meter", "option", "output", "progress", "textarea", "param"];
          const SVG_TAGS_LIST = uniq(["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "animation", "audio", "canvas", "clipPath", "color-profile", "cursor", "defs", "desc", "discard", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "handler", "hatch", "hatchpath", "hkern", "iframe", "image", "linearGradient", "listener", "marker", "mask", "mesh", "meshgradient", "meshpatch", "meshrow", "metadata", "missing-glyph", "mpath", "pattern", "prefetch", "radialGradient", "script", "set", "solidColor", "solidcolor", "style", "svg", "switch", "symbol", "tbreak", "text", "textArea", "textPath", "title", "tref", "tspan", "unknown", "video", "view", "vkern"].concat(VOID_SVG_TAGS_LIST)).sort();
          const VOID_HTML_TAGS_LIST = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"];
          const HTML_TAGS_LIST = uniq(["a", "abbr", "address", "article", "aside", "audio", "b", "bdi", "bdo", "blockquote", "body", "canvas", "caption", "cite", "code", "colgroup", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "html", "i", "iframe", "ins", "kbd", "label", "legend", "main", "map", "mark", "math", "menu", "nav", "noscript", "object", "ol", "optgroup", "p", "picture", "pre", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "tfoot", "th", "thead", "time", "title", "tr", "u", "ul", "var", "video"].concat(VOID_HTML_TAGS_LIST).concat(HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_LIST)).sort();
          const BOOLEAN_ATTRIBUTES_LIST = ["disabled", "visible", "checked", "readonly", "required", "allowfullscreen", "autofocus", "autoplay", "compact", "controls", "default", "formnovalidate", "hidden", "ismap", "itemscope", "loop", "multiple", "muted", "noresize", "noshade", "novalidate", "nowrap", "open", "reversed", "seamless", "selected", "sortable", "truespeed", "typemustmatch"];
          function joinWithPipe(list) {
            return list.join("|");
          }
          function listsToRegex() {
            for (var _len14 = arguments.length, lists = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
              lists[_key14] = arguments[_key14];
            }
            return new RegExp(`^/?(?:${joinWithPipe(lists.map(joinWithPipe))})$`, "i");
          }
          const HTML_TAGS_RE = listsToRegex(HTML_TAGS_LIST);
          const SVG_TAGS_RE = listsToRegex(SVG_TAGS_LIST);
          const VOID_HTML_TAGS_RE = listsToRegex(VOID_HTML_TAGS_LIST);
          const VOID_SVG_TAGS_RE = listsToRegex(VOID_SVG_TAGS_LIST);
          const HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_RE = listsToRegex(HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_LIST);
          const BOOLEAN_ATTRIBUTES_RE = listsToRegex(BOOLEAN_ATTRIBUTES_LIST);
          function isVoid(tag2) {
            return [VOID_HTML_TAGS_RE, VOID_SVG_TAGS_RE].some((r) => r.test(tag2));
          }
          function isCustom(tag2) {
            return [HTML_TAGS_RE, SVG_TAGS_RE].every((l) => !l.test(tag2));
          }
          function hasValueAttribute(tag2) {
            return HTML_ELEMENTS_HAVING_VALUE_ATTRIBUTE_RE.test(tag2);
          }
          function isBoolAttribute(attribute) {
            return BOOLEAN_ATTRIBUTES_RE.test(attribute);
          }
          function memoize2(fn) {
            const cache = new WeakMap();
            return function() {
              if (cache.has(arguments.length <= 0 ? void 0 : arguments[0]))
                return cache.get(arguments.length <= 0 ? void 0 : arguments[0]);
              const ret = fn(...arguments);
              cache.set(arguments.length <= 0 ? void 0 : arguments[0], ret);
              return ret;
            };
          }
          const expressionsContentRe = memoize2((brackets) => RegExp(`(${brackets[0]}[^${brackets[1]}]*?${brackets[1]})`, "g"));
          const isSpreadAttribute$1 = (name2) => SPREAD_OPERATOR.test(name2);
          const isAttributeExpression = (name2, brackets) => name2[0] === brackets[0];
          const getAttributeEnd = (state, attr2) => expr(state, attr2, "[>/\\s]", attr2.start);
          function attr(state) {
            const {data, last: last2, pos, root} = state;
            const tag2 = last2;
            const _CH = /\S/g;
            const ch = execFromPos(_CH, pos, data);
            switch (true) {
              case !ch:
                state.pos = data.length;
                break;
              case ch[0] === ">":
                state.pos = tag2.end = _CH.lastIndex;
                if (tag2[IS_SELF_CLOSING]) {
                  state.scryle = null;
                  if (root && root.name === tag2.name) {
                    state.count--;
                  }
                }
                return TEXT2;
              case ch[0] === "/":
                state.pos = _CH.lastIndex;
                tag2[IS_SELF_CLOSING] = true;
                break;
              default:
                delete tag2[IS_SELF_CLOSING];
                setAttribute(state, ch.index, tag2);
            }
            return ATTR;
          }
          function setAttribute(state, pos, tag2) {
            const {data} = state;
            const expressionContent = expressionsContentRe(state.options.brackets);
            const re = ATTR_START;
            const start = re.lastIndex = expressionContent.lastIndex = pos;
            const attrMatches = re.exec(data);
            const isExpressionName = isAttributeExpression(attrMatches[1], state.options.brackets);
            const match = isExpressionName ? [null, expressionContent.exec(data)[1], null] : attrMatches;
            if (match) {
              const end = re.lastIndex;
              const attr2 = parseAttribute(state, match, start, end, isExpressionName);
              state.pos = tag2.end = attr2.end;
              tag2.attributes = addToCollection(tag2.attributes, attr2);
            }
          }
          function parseNomalAttribute(state, attr2, quote) {
            const {data} = state;
            let {end} = attr2;
            if (isBoolAttribute(attr2.name)) {
              attr2[IS_BOOLEAN] = true;
            }
            if (quote) {
              let valueStart = end;
              if (quote !== '"' && quote !== "'") {
                quote = "";
                valueStart--;
              }
              end = expr(state, attr2, quote || "[>/\\s]", valueStart);
              return Object.assign(attr2, {value: getChunk(data, valueStart, end), valueStart, end: quote ? ++end : end});
            }
            return attr2;
          }
          function parseSpreadAttribute(state, attr2) {
            const end = getAttributeEnd(state, attr2);
            return {[IS_SPREAD]: true, start: attr2.start, expressions: attr2.expressions.map((expr2) => Object.assign(expr2, {text: expr2.text.replace(SPREAD_OPERATOR, "").trim()})), end};
          }
          function parseExpressionNameAttribute(state, attr2) {
            const end = getAttributeEnd(state, attr2);
            return {start: attr2.start, name: attr2.expressions[0].text.trim(), expressions: attr2.expressions, end};
          }
          function parseAttribute(state, match, start, end, isExpressionName) {
            const attr2 = {name: match[1], value: "", start, end};
            const quote = match[2];
            switch (true) {
              case isSpreadAttribute$1(attr2.name):
                return parseSpreadAttribute(state, attr2);
              case isExpressionName === true:
                return parseExpressionNameAttribute(state, attr2);
              default:
                return parseNomalAttribute(state, attr2, quote);
            }
          }
          function comment(state, data, start) {
            const pos = start + 2;
            const isLongComment = data.substr(pos, 2) === "--";
            const str = isLongComment ? "-->" : ">";
            const end = data.indexOf(str, pos);
            if (end < 0) {
              panic2(data, unclosedComment, start);
            }
            pushComment(state, start, end + str.length, data.substring(start, end + str.length));
            return TEXT2;
          }
          function pushComment(state, start, end, text2) {
            state.pos = end;
            if (state.options.comments === true) {
              flush(state);
              state.last = {type: COMMENT, start, end, text: text2};
            }
          }
          function pushTag(state, name2, start, end) {
            const root = state.root;
            const last2 = {type: TAG2, name: name2, start, end};
            if (isCustom(name2)) {
              last2[IS_CUSTOM] = true;
            }
            if (isVoid(name2)) {
              last2[IS_VOID] = true;
            }
            state.pos = end;
            if (root) {
              if (name2 === root.name) {
                state.count++;
              } else if (name2 === root.close) {
                state.count--;
              }
              flush(state);
            } else {
              state.root = {name: last2.name, close: `/${name2}`};
              state.count = 1;
            }
            state.last = last2;
          }
          function tag(state) {
            const {pos, data} = state;
            const start = pos - 1;
            const str = data.substr(pos, 2);
            switch (true) {
              case str[0] === "!":
                return comment(state, data, start);
              case TAG_2C.test(str):
                return parseTag(state, start);
              default:
                return pushText(state, start, pos);
            }
          }
          function parseTag(state, start) {
            const {data, pos} = state;
            const re = TAG_NAME;
            const match = execFromPos(re, pos, data);
            const end = re.lastIndex;
            const name2 = match[1].toLowerCase();
            if (name2 in RE_SCRYLE) {
              state.scryle = name2;
            }
            pushTag(state, name2, start, end);
            if (!match[2]) {
              return ATTR;
            }
            return TEXT2;
          }
          function text(state) {
            const {pos, data, scryle} = state;
            switch (true) {
              case typeof scryle === "string": {
                const name2 = scryle;
                const re = RE_SCRYLE[name2];
                const match = execFromPos(re, pos, data);
                if (!match) {
                  panic2(data, unclosedNamedBlock.replace("%1", name2), pos - 1);
                }
                const start = match.index;
                const end = re.lastIndex;
                state.scryle = null;
                if (start > pos) {
                  parseSpecialTagsContent(state, name2, match);
                }
                pushTag(state, `/${name2}`, start, end);
                break;
              }
              case data[pos] === "<":
                state.pos++;
                return TAG2;
              default:
                expr(state, null, "<", pos);
            }
            return TEXT2;
          }
          function parseSpecialTagsContent(state, name2, match) {
            const {pos} = state;
            const start = match.index;
            if (name2 === TEXTAREA_TAG) {
              expr(state, null, match[0], pos);
            } else {
              pushText(state, pos, start);
            }
          }
          function escapeReturn(string) {
            return string.replace(/\r/g, "\\r").replace(/\n/g, "\\n");
          }
          const hasSrcAttribute = (node2) => (node2.attributes || []).some((attr2) => attr2.name === "src");
          function escapeSlashes(string) {
            return string.replace(/\\/g, "\\\\");
          }
          function cleanSpaces(string) {
            return string.replace(/\s+/g, " ");
          }
          const TREE_BUILDER_STRUCT = Object.seal({
            get() {
              const store = this.store;
              return {[TEMPLATE_OUTPUT_NAME]: store.root.nodes[0], [CSS_OUTPUT_NAME]: store[STYLE_TAG], [JAVASCRIPT_OUTPUT_NAME]: store[JAVASCRIPT_TAG]};
            },
            push(node2) {
              const store = this.store;
              switch (node2.type) {
                case COMMENT:
                  this.pushComment(store, node2);
                  break;
                case TEXT2:
                  this.pushText(store, node2);
                  break;
                case TAG2: {
                  const name2 = node2.name;
                  const closingTagChar = "/";
                  const [firstChar] = name2;
                  if (firstChar === closingTagChar && !node2.isVoid) {
                    this.closeTag(store, node2, name2);
                  } else if (firstChar !== closingTagChar) {
                    this.openTag(store, node2);
                  }
                  break;
                }
              }
            },
            pushComment(store, node2) {
              const parent = store.last;
              parent.nodes.push(node2);
            },
            closeTag(store, node2) {
              const last2 = store.scryle || store.last;
              last2.end = node2.end;
              if (store.root.nodes[0])
                store.root.nodes[0].end = node2.end;
              if (store.scryle) {
                store.scryle = null;
              } else {
                store.last = store.stack.pop();
              }
            },
            openTag(store, node2) {
              const name2 = node2.name;
              const attrs = node2.attributes;
              const isCoreTag = JAVASCRIPT_TAG === name2 && !hasSrcAttribute(node2) || name2 === STYLE_TAG;
              if (isCoreTag) {
                if (store[name2]) {
                  panic2(this.store.data, duplicatedNamedTag.replace("%1", name2), node2.start);
                }
                store[name2] = node2;
                store.scryle = store[name2];
              } else {
                const lastTag = store.last;
                const newNode = node2;
                lastTag.nodes.push(newNode);
                if (lastTag[IS_RAW] || RAW_TAGS.test(name2)) {
                  node2[IS_RAW] = true;
                }
                if (!node2[IS_SELF_CLOSING] && !node2[IS_VOID]) {
                  store.stack.push(lastTag);
                  newNode.nodes = [];
                  store.last = newNode;
                }
              }
              if (attrs) {
                this.attrs(attrs);
              }
            },
            attrs(attributes) {
              attributes.forEach((attr2) => {
                if (attr2.value) {
                  this.split(attr2, attr2.value, attr2.valueStart, true);
                }
              });
            },
            pushText(store, node2) {
              const text2 = node2.text;
              const empty2 = !/\S/.test(text2);
              const scryle = store.scryle;
              if (!scryle) {
                const parent = store.last;
                const pack = this.compact && !parent[IS_RAW];
                if (pack && empty2) {
                  return;
                }
                this.split(node2, text2, node2.start, pack);
                parent.nodes.push(node2);
              } else if (!empty2) {
                scryle.text = node2;
              }
            },
            split(node2, source, start, pack) {
              const expressions2 = node2.expressions;
              const parts = [];
              if (expressions2) {
                let pos = 0;
                expressions2.forEach((expr2) => {
                  const text2 = source.slice(pos, expr2.start - start);
                  const code = expr2.text;
                  parts.push(this.sanitise(node2, text2, pack), escapeReturn(escapeSlashes(code).trim()));
                  pos = expr2.end - start;
                });
                if (pos < node2.end) {
                  parts.push(this.sanitise(node2, source.slice(pos), pack));
                }
              } else {
                parts[0] = this.sanitise(node2, source, pack);
              }
              node2.parts = parts.filter((p) => p);
            },
            sanitise(node2, text2, pack) {
              let rep = node2.unescape;
              if (rep) {
                let idx = 0;
                rep = `\\${rep}`;
                while ((idx = text2.indexOf(rep, idx)) !== -1) {
                  text2 = text2.substr(0, idx) + text2.substr(idx + 1);
                  idx++;
                }
              }
              text2 = escapeSlashes(text2);
              return pack ? cleanSpaces(text2) : escapeReturn(text2);
            }
          });
          function createTreeBuilder(data, options2) {
            const root = {type: TAG2, name: "", start: 0, end: 0, nodes: []};
            return Object.assign(Object.create(TREE_BUILDER_STRUCT), {compact: options2.compact !== false, store: {last: root, stack: [], scryle: null, root, style: null, script: null, data}});
          }
          function parser(options2, customBuilder) {
            const state = curry2(createParserState)(options2, customBuilder || createTreeBuilder);
            return {parse: (data) => _parse(state(data))};
          }
          function createParserState(userOptions, builder, data) {
            const options2 = Object.assign({brackets: ["{", "}"]}, userOptions);
            return {options: options2, regexCache: {}, pos: 0, count: -1, root: null, last: null, scryle: null, builder: builder(data, options2), data};
          }
          function _parse(state) {
            const {data} = state;
            walk(state);
            flush(state);
            if (state.count) {
              panic2(data, state.count > 0 ? unexpectedEndOfFile : rootTagNotFound, state.pos);
            }
            return {data, output: state.builder.get()};
          }
          function walk(state, type2) {
            const {data} = state;
            const length = data.length;
            if (state.pos < length && state.count) {
              walk(state, eat(state, type2));
            }
          }
          function eat(state, type2) {
            switch (type2) {
              case TAG2:
                return tag(state);
              case ATTR:
                return attr(state);
              default:
                return text(state);
            }
          }
          const constants = c;
          const nodeTypes = types;
          const BINDING_TYPES = "bindingTypes";
          const EACH_BINDING_TYPE = "EACH";
          const IF_BINDING_TYPE = "IF";
          const TAG_BINDING_TYPE = "TAG";
          const SLOT_BINDING_TYPE = "SLOT";
          const EXPRESSION_TYPES = "expressionTypes";
          const ATTRIBUTE_EXPRESSION_TYPE = "ATTRIBUTE";
          const VALUE_EXPRESSION_TYPE = "VALUE";
          const TEXT_EXPRESSION_TYPE = "TEXT";
          const EVENT_EXPRESSION_TYPE = "EVENT";
          const TEMPLATE_FN = "template";
          const SCOPE = "scope";
          const GET_COMPONENT_FN = "getComponent";
          const BINDING_SELECTOR_KEY = "selector";
          const BINDING_GET_COMPONENT_KEY = "getComponent";
          const BINDING_TEMPLATE_KEY = "template";
          const BINDING_TYPE_KEY = "type";
          const BINDING_REDUNDANT_ATTRIBUTE_KEY = "redundantAttribute";
          const BINDING_CONDITION_KEY = "condition";
          const BINDING_ITEM_NAME_KEY = "itemName";
          const BINDING_GET_KEY_KEY = "getKey";
          const BINDING_INDEX_NAME_KEY = "indexName";
          const BINDING_EVALUATE_KEY = "evaluate";
          const BINDING_NAME_KEY = "name";
          const BINDING_SLOTS_KEY = "slots";
          const BINDING_EXPRESSIONS_KEY = "expressions";
          const BINDING_CHILD_NODE_INDEX_KEY = "childNodeIndex";
          const BINDING_BINDINGS_KEY = "bindings";
          const BINDING_ID_KEY = "id";
          const BINDING_HTML_KEY = "html";
          const BINDING_ATTRIBUTES_KEY = "attributes";
          const IF_DIRECTIVE = "if";
          const EACH_DIRECTIVE = "each";
          const KEY_ATTRIBUTE = "key";
          const SLOT_ATTRIBUTE = "slot";
          const NAME_ATTRIBUTE = "name";
          const IS_DIRECTIVE2 = "is";
          const DEFAULT_SLOT_NAME = "default";
          const TEXT_NODE_EXPRESSION_PLACEHOLDER = " ";
          const BINDING_SELECTOR_PREFIX = "expr";
          const SLOT_TAG_NODE_NAME = "slot";
          const PROGRESS_TAG_NODE_NAME = "progress";
          const TEMPLATE_TAG_NODE_NAME = "template";
          constants.IS_RAW;
          const IS_VOID_NODE = constants.IS_VOID;
          const IS_CUSTOM_NODE = constants.IS_CUSTOM;
          const IS_BOOLEAN_ATTRIBUTE = constants.IS_BOOLEAN;
          const IS_SPREAD_ATTRIBUTE = constants.IS_SPREAD;
          function isStaticNode(node2) {
            return [hasExpressions, findEachAttribute, findIfAttribute, isCustomNode, isSlotNode].every((test) => !test(node2));
          }
          function isRemovableNode(node2) {
            return isTemplateNode(node2) && !isNil2(findAttribute(SLOT_ATTRIBUTE, node2)) && !hasEachAttribute(node2) && !hasIfAttribute(node2);
          }
          function isGlobal(_ref19) {
            let {scope: scope2, node: node2} = _ref19;
            if (node2.object) {
              return isGlobal({node: node2.object, scope: scope2});
            }
            return Boolean(isRaw(node2) || isBuiltinAPI(node2) || isBrowserAPI(node2) || isNewExpression(node2) || isNodeInScope(scope2, node2));
          }
          function isNodeInScope(scope2, node2) {
            const traverse = function traverse2(isInScope) {
              if (isInScope === void 0) {
                isInScope = false;
              }
              types$2.visit(node2, {visitIdentifier(path2) {
                if (scope2.lookup(getName2(path2.node))) {
                  isInScope = true;
                }
                this.abort();
              }});
              return isInScope;
            };
            return traverse();
          }
          function isCustomNode(node2) {
            return !!(node2[IS_CUSTOM_NODE] || hasIsAttribute(node2));
          }
          function isSlotNode(node2) {
            return node2.name === SLOT_TAG_NODE_NAME;
          }
          function isVoidNode(node2) {
            return !!node2[IS_VOID_NODE];
          }
          function isTagNode(node2) {
            return node2.type === nodeTypes.TAG;
          }
          function isTextNode(node2) {
            return node2.type === nodeTypes.TEXT;
          }
          function isRootNode(node2) {
            return node2.isRoot;
          }
          function isSpreadAttribute(node2) {
            return node2[IS_SPREAD_ATTRIBUTE];
          }
          function isValueAttribute(node2) {
            return node2.name === "value";
          }
          function isProgressNode(node2) {
            return node2.name === PROGRESS_TAG_NODE_NAME;
          }
          function isTemplateNode(node2) {
            return node2.name === TEMPLATE_TAG_NODE_NAME;
          }
          const isEventAttribute = (() => {
            const EVENT_ATTR_RE = /^on/;
            return (node2) => EVENT_ATTR_RE.test(node2.name);
          })();
          function isCommentString(string) {
            return string.trim().indexOf("<!") === 0;
          }
          function hasExpressions(node2) {
            return !!(node2.expressions || getNodeAttributes(node2).some((attribute) => hasExpressions(attribute)) || node2.nodes && node2.nodes.some((node3) => isTextNode(node3) && hasExpressions(node3)));
          }
          function hasItsOwnTemplate(node2) {
            return [findEachAttribute, findIfAttribute, isCustomNode].some((test) => test(node2));
          }
          const hasIfAttribute = compose2(Boolean, findIfAttribute);
          const hasEachAttribute = compose2(Boolean, findEachAttribute);
          const hasIsAttribute = compose2(Boolean, findIsAttribute);
          compose2(Boolean, findKeyAttribute);
          function findAttribute(name2, node2) {
            return node2.attributes && node2.attributes.find((attr2) => getName2(attr2) === name2);
          }
          function findIfAttribute(node2) {
            return findAttribute(IF_DIRECTIVE, node2);
          }
          function findEachAttribute(node2) {
            return findAttribute(EACH_DIRECTIVE, node2);
          }
          function findKeyAttribute(node2) {
            return findAttribute(KEY_ATTRIBUTE, node2);
          }
          function findIsAttribute(node2) {
            return findAttribute(IS_DIRECTIVE2, node2);
          }
          function findStaticAttributes(node2) {
            return getNodeAttributes(node2).filter((attribute) => !hasExpressions(attribute));
          }
          function findDynamicAttributes(node2) {
            return getNodeAttributes(node2).filter(hasExpressions);
          }
          function createAttributeExpression(sourceNode2, sourceFile, sourceCode) {
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(ATTRIBUTE_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_NAME_KEY, isSpreadAttribute(sourceNode2) ? nullNode() : builders.literal(sourceNode2.name)), simplePropertyNode(BINDING_EVALUATE_KEY, createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode))]);
          }
          function createEventExpression(sourceNode2, sourceFile, sourceCode) {
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(EVENT_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_NAME_KEY, builders.literal(sourceNode2.name)), simplePropertyNode(BINDING_EVALUATE_KEY, createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode))]);
          }
          var quot = '"';
          var amp = "&";
          var apos = "'";
          var lt = "<";
          var gt = ">";
          var nbsp = "\xA0";
          var iexcl = "\xA1";
          var cent = "\xA2";
          var pound = "\xA3";
          var curren = "\xA4";
          var yen = "\xA5";
          var brvbar = "\xA6";
          var sect = "\xA7";
          var uml = "\xA8";
          var copy = "\xA9";
          var ordf = "\xAA";
          var laquo = "\xAB";
          var not = "\xAC";
          var shy = "\xAD";
          var reg = "\xAE";
          var macr = "\xAF";
          var deg = "\xB0";
          var plusmn = "\xB1";
          var sup2 = "\xB2";
          var sup3 = "\xB3";
          var acute = "\xB4";
          var micro = "\xB5";
          var para = "\xB6";
          var middot = "\xB7";
          var cedil = "\xB8";
          var sup1 = "\xB9";
          var ordm = "\xBA";
          var raquo = "\xBB";
          var frac14 = "\xBC";
          var frac12 = "\xBD";
          var frac34 = "\xBE";
          var iquest = "\xBF";
          var Agrave = "\xC0";
          var Aacute = "\xC1";
          var Acirc = "\xC2";
          var Atilde = "\xC3";
          var Auml = "\xC4";
          var Aring = "\xC5";
          var AElig = "\xC6";
          var Ccedil = "\xC7";
          var Egrave = "\xC8";
          var Eacute = "\xC9";
          var Ecirc = "\xCA";
          var Euml = "\xCB";
          var Igrave = "\xCC";
          var Iacute = "\xCD";
          var Icirc = "\xCE";
          var Iuml = "\xCF";
          var ETH = "\xD0";
          var Ntilde = "\xD1";
          var Ograve = "\xD2";
          var Oacute = "\xD3";
          var Ocirc = "\xD4";
          var Otilde = "\xD5";
          var Ouml = "\xD6";
          var times = "\xD7";
          var Oslash = "\xD8";
          var Ugrave = "\xD9";
          var Uacute = "\xDA";
          var Ucirc = "\xDB";
          var Uuml = "\xDC";
          var Yacute = "\xDD";
          var THORN = "\xDE";
          var szlig = "\xDF";
          var agrave = "\xE0";
          var aacute = "\xE1";
          var acirc = "\xE2";
          var atilde = "\xE3";
          var auml = "\xE4";
          var aring = "\xE5";
          var aelig = "\xE6";
          var ccedil = "\xE7";
          var egrave = "\xE8";
          var eacute = "\xE9";
          var ecirc = "\xEA";
          var euml = "\xEB";
          var igrave = "\xEC";
          var iacute = "\xED";
          var icirc = "\xEE";
          var iuml = "\xEF";
          var eth = "\xF0";
          var ntilde = "\xF1";
          var ograve = "\xF2";
          var oacute = "\xF3";
          var ocirc = "\xF4";
          var otilde = "\xF5";
          var ouml = "\xF6";
          var divide = "\xF7";
          var oslash = "\xF8";
          var ugrave = "\xF9";
          var uacute = "\xFA";
          var ucirc = "\xFB";
          var uuml = "\xFC";
          var yacute = "\xFD";
          var thorn = "\xFE";
          var yuml = "\xFF";
          var OElig = "\u0152";
          var oelig = "\u0153";
          var Scaron = "\u0160";
          var scaron = "\u0161";
          var Yuml = "\u0178";
          var fnof = "\u0192";
          var circ = "\u02C6";
          var tilde = "\u02DC";
          var Alpha = "\u0391";
          var Beta = "\u0392";
          var Gamma = "\u0393";
          var Delta = "\u0394";
          var Epsilon = "\u0395";
          var Zeta = "\u0396";
          var Eta = "\u0397";
          var Theta = "\u0398";
          var Iota = "\u0399";
          var Kappa = "\u039A";
          var Lambda = "\u039B";
          var Mu = "\u039C";
          var Nu = "\u039D";
          var Xi = "\u039E";
          var Omicron = "\u039F";
          var Pi = "\u03A0";
          var Rho = "\u03A1";
          var Sigma = "\u03A3";
          var Tau = "\u03A4";
          var Upsilon = "\u03A5";
          var Phi = "\u03A6";
          var Chi = "\u03A7";
          var Psi = "\u03A8";
          var Omega = "\u03A9";
          var alpha = "\u03B1";
          var beta = "\u03B2";
          var gamma = "\u03B3";
          var delta = "\u03B4";
          var epsilon = "\u03B5";
          var zeta = "\u03B6";
          var eta = "\u03B7";
          var theta = "\u03B8";
          var iota = "\u03B9";
          var kappa = "\u03BA";
          var lambda = "\u03BB";
          var mu = "\u03BC";
          var nu = "\u03BD";
          var xi = "\u03BE";
          var omicron = "\u03BF";
          var pi = "\u03C0";
          var rho = "\u03C1";
          var sigmaf = "\u03C2";
          var sigma = "\u03C3";
          var tau = "\u03C4";
          var upsilon = "\u03C5";
          var phi = "\u03C6";
          var chi = "\u03C7";
          var psi = "\u03C8";
          var omega = "\u03C9";
          var thetasym = "\u03D1";
          var upsih = "\u03D2";
          var piv = "\u03D6";
          var ensp = "\u2002";
          var emsp = "\u2003";
          var thinsp = "\u2009";
          var zwnj = "\u200C";
          var zwj = "\u200D";
          var lrm = "\u200E";
          var rlm = "\u200F";
          var ndash = "\u2013";
          var mdash = "\u2014";
          var lsquo = "\u2018";
          var rsquo = "\u2019";
          var sbquo = "\u201A";
          var ldquo = "\u201C";
          var rdquo = "\u201D";
          var bdquo = "\u201E";
          var dagger = "\u2020";
          var Dagger = "\u2021";
          var bull = "\u2022";
          var hellip = "\u2026";
          var permil = "\u2030";
          var prime = "\u2032";
          var Prime = "\u2033";
          var lsaquo = "\u2039";
          var rsaquo = "\u203A";
          var oline = "\u203E";
          var frasl = "\u2044";
          var euro = "\u20AC";
          var image = "\u2111";
          var weierp = "\u2118";
          var real = "\u211C";
          var trade = "\u2122";
          var alefsym = "\u2135";
          var larr = "\u2190";
          var uarr = "\u2191";
          var rarr = "\u2192";
          var darr = "\u2193";
          var harr = "\u2194";
          var crarr = "\u21B5";
          var lArr = "\u21D0";
          var uArr = "\u21D1";
          var rArr = "\u21D2";
          var dArr = "\u21D3";
          var hArr = "\u21D4";
          var forall = "\u2200";
          var part = "\u2202";
          var exist = "\u2203";
          var empty = "\u2205";
          var nabla = "\u2207";
          var isin = "\u2208";
          var notin = "\u2209";
          var ni = "\u220B";
          var prod = "\u220F";
          var sum = "\u2211";
          var minus = "\u2212";
          var lowast = "\u2217";
          var radic = "\u221A";
          var prop = "\u221D";
          var infin = "\u221E";
          var ang = "\u2220";
          var and = "\u2227";
          var or = "\u2228";
          var cap = "\u2229";
          var cup = "\u222A";
          var int = "\u222B";
          var there4 = "\u2234";
          var sim = "\u223C";
          var cong = "\u2245";
          var asymp = "\u2248";
          var ne = "\u2260";
          var equiv = "\u2261";
          var le = "\u2264";
          var ge = "\u2265";
          var sub = "\u2282";
          var sup = "\u2283";
          var nsub = "\u2284";
          var sube = "\u2286";
          var supe = "\u2287";
          var oplus = "\u2295";
          var otimes = "\u2297";
          var perp = "\u22A5";
          var sdot = "\u22C5";
          var lceil = "\u2308";
          var rceil = "\u2309";
          var lfloor = "\u230A";
          var rfloor = "\u230B";
          var lang = "\u2329";
          var rang = "\u232A";
          var loz = "\u25CA";
          var spades = "\u2660";
          var clubs = "\u2663";
          var hearts = "\u2665";
          var diams = "\u2666";
          var entities = {quot, amp, apos, lt, gt, nbsp, iexcl, cent, pound, curren, yen, brvbar, sect, uml, copy, ordf, laquo, not, shy, reg, macr, deg, plusmn, sup2, sup3, acute, micro, para, middot, cedil, sup1, ordm, raquo, frac14, frac12, frac34, iquest, Agrave, Aacute, Acirc, Atilde, Auml, Aring, AElig, Ccedil, Egrave, Eacute, Ecirc, Euml, Igrave, Iacute, Icirc, Iuml, ETH, Ntilde, Ograve, Oacute, Ocirc, Otilde, Ouml, times, Oslash, Ugrave, Uacute, Ucirc, Uuml, Yacute, THORN, szlig, agrave, aacute, acirc, atilde, auml, aring, aelig, ccedil, egrave, eacute, ecirc, euml, igrave, iacute, icirc, iuml, eth, ntilde, ograve, oacute, ocirc, otilde, ouml, divide, oslash, ugrave, uacute, ucirc, uuml, yacute, thorn, yuml, OElig, oelig, Scaron, scaron, Yuml, fnof, circ, tilde, Alpha, Beta, Gamma, Delta, Epsilon, Zeta, Eta, Theta, Iota, Kappa, Lambda, Mu, Nu, Xi, Omicron, Pi, Rho, Sigma, Tau, Upsilon, Phi, Chi, Psi, Omega, alpha, beta, gamma, delta, epsilon, zeta, eta, theta, iota, kappa, lambda, mu, nu, xi, omicron, pi, rho, sigmaf, sigma, tau, upsilon, phi, chi, psi, omega, thetasym, upsih, piv, ensp, emsp, thinsp, zwnj, zwj, lrm, rlm, ndash, mdash, lsquo, rsquo, sbquo, ldquo, rdquo, bdquo, dagger, Dagger, bull, hellip, permil, prime, Prime, lsaquo, rsaquo, oline, frasl, euro, image, weierp, real, trade, alefsym, larr, uarr, rarr, darr, harr, crarr, lArr, uArr, rArr, dArr, hArr, forall, part, exist, empty, nabla, isin, notin, ni, prod, sum, minus, lowast, radic, prop, infin, ang, and, or, cap, cup, int, there4, sim, cong, asymp, ne, equiv, le, ge, sub, sup, nsub, sube, supe, oplus, otimes, perp, sdot, lceil, rceil, lfloor, rfloor, lang, rang, loz, spades, clubs, hearts, diams};
          const HTMLEntityRe = /&(\S+);/g;
          const HEX_NUMBER = /^[\da-fA-F]+$/;
          const DECIMAL_NUMBER = /^\d+$/;
          function encodeHex(string) {
            const hex = string.substr(2);
            return HEX_NUMBER.test(hex) ? String.fromCodePoint(parseInt(hex, 16)) : string;
          }
          function encodeDecimal(string) {
            const nr = string.substr(1);
            return DECIMAL_NUMBER.test(nr) ? String.fromCodePoint(parseInt(nr, 10)) : string;
          }
          function encodeHTMLEntities(string) {
            return string.replace(HTMLEntityRe, (match, entity) => {
              const [firstChar, secondChar] = entity;
              if (firstChar === "#") {
                return secondChar === "x" ? encodeHex(entity) : encodeDecimal(entity);
              } else {
                return entities[entity] || entity;
              }
            });
          }
          function trimEnd(string) {
            return (string.trimEnd || string.trimRight).apply(string);
          }
          function trimStart(string) {
            return (string.trimStart || string.trimLeft).apply(string);
          }
          function unescapeChar(string, char) {
            return string.replace(RegExp(`\\\\${char}`, "gm"), char);
          }
          function generateLiteralStringChunksFromNode(node2, sourceCode) {
            return node2.expressions.reduce((chunks, expression, index) => {
              const start = index ? node2.expressions[index - 1].end : node2.start;
              const string = encodeHTMLEntities(sourceCode.substring(start, expression.start));
              chunks.push(index === 0 ? trimStart(string) : string);
              if (index === node2.expressions.length - 1)
                chunks.push(encodeHTMLEntities(trimEnd(sourceCode.substring(expression.end, node2.end))));
              return chunks;
            }, []).filter((str) => !isCommentString(str)).map((str) => node2.unescape ? unescapeChar(str, node2.unescape) : str);
          }
          function mergeNodeExpressions(node2, sourceFile, sourceCode) {
            if (node2.parts.length === 1)
              return transformExpression(node2.expressions[0], sourceFile, sourceCode);
            const pureStringChunks = generateLiteralStringChunksFromNode(node2, sourceCode);
            const stringsArray = pureStringChunks.reduce((acc, str, index) => {
              const expr2 = node2.expressions[index];
              return [...acc, builders.literal(str), expr2 ? transformExpression(expr2, sourceFile, sourceCode) : nullNode()];
            }, []).filter((expr2) => !isLiteral(expr2) || expr2.value);
            return createArrayString(stringsArray);
          }
          function createTextExpression(sourceNode2, sourceFile, sourceCode, childNodeIndex) {
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(TEXT_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_CHILD_NODE_INDEX_KEY, builders.literal(childNodeIndex)), simplePropertyNode(BINDING_EVALUATE_KEY, wrapASTInFunctionWithScope(mergeNodeExpressions(sourceNode2, sourceFile, sourceCode)))]);
          }
          function createValueExpression(sourceNode2, sourceFile, sourceCode) {
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(EXPRESSION_TYPES), builders.identifier(VALUE_EXPRESSION_TYPE), false)), simplePropertyNode(BINDING_EVALUATE_KEY, createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode))]);
          }
          function createExpression(sourceNode2, sourceFile, sourceCode, childNodeIndex, parentNode) {
            switch (true) {
              case isTextNode(sourceNode2):
                return createTextExpression(sourceNode2, sourceFile, sourceCode, childNodeIndex);
              case (isValueAttribute(sourceNode2) && hasValueAttribute(parentNode.name) && !isProgressNode(parentNode)):
                return createValueExpression(sourceNode2, sourceFile, sourceCode);
              case isEventAttribute(sourceNode2):
                return createEventExpression(sourceNode2, sourceFile, sourceCode);
              default:
                return createAttributeExpression(sourceNode2, sourceFile, sourceCode);
            }
          }
          function createAttributeExpressions(sourceNode2, sourceFile, sourceCode) {
            return findDynamicAttributes(sourceNode2).map((attribute) => createExpression(attribute, sourceFile, sourceCode, 0, sourceNode2));
          }
          const scope = builders.identifier(SCOPE);
          const getName2 = (node2) => node2 && node2.name ? node2.name : node2;
          function replacePathScope(path2, property) {
            path2.replace(builders.memberExpression(scope, property, false));
          }
          function updateNodeScope(path2) {
            if (!isGlobal(path2)) {
              replacePathScope(path2, path2.node);
              return false;
            }
            this.traverse(path2);
          }
          function visitMemberExpression(path2) {
            const traversePathObject = () => this.traverse(path2.get("object"));
            const currentObject = path2.node.object;
            switch (true) {
              case isGlobal(path2):
                if (currentObject.arguments && currentObject.arguments.length) {
                  traversePathObject();
                }
                break;
              case (!path2.value.computed && isIdentifier(currentObject)):
                replacePathScope(path2, path2.node);
                break;
              default:
                this.traverse(path2);
            }
            return false;
          }
          function visitObjectProperty(path2) {
            const value = path2.node.value;
            const isShorthand = path2.node.shorthand;
            if (isIdentifier(value) || isMemberExpression(value) || isShorthand) {
              if (isShorthand)
                path2.node.shorthand = false;
              updateNodeScope.call(this, path2.get("value"));
            } else {
              this.traverse(path2.get("value"));
            }
            return false;
          }
          function visitThisExpression(path2) {
            path2.replace(scope);
            this.traverse(path2);
          }
          function visitIdentifier(path2) {
            const parentValue = path2.parent.value;
            if (!isMemberExpression(parentValue) || parentValue.computed) {
              updateNodeScope.call(this, path2);
            }
            return false;
          }
          function updateNodesScope(ast) {
            const ignorePath = () => false;
            types$2.visit(ast, {visitIdentifier, visitMemberExpression, visitObjectProperty, visitThisExpression, visitClassExpression: ignorePath});
            return ast;
          }
          function createASTFromExpression(expression, sourceFile, sourceCode) {
            const code = sourceFile ? addLineOffset(expression.text, sourceCode, expression) : expression.text;
            return generateAST(`(${code})`, {sourceFileName: sourceFile});
          }
          function createTemplateProperty(args) {
            return simplePropertyNode(BINDING_TEMPLATE_KEY, args ? callTemplateFunction(...args) : nullNode());
          }
          function getAttributeExpression(attribute) {
            return attribute.expressions ? attribute.expressions[0] : Object.assign({}, attribute, {text: attribute.value});
          }
          function wrapASTInFunctionWithScope(ast) {
            return builders.functionExpression(null, [scope], builders.blockStatement([builders.returnStatement(ast)]));
          }
          function toScopedFunction(expression, sourceFile, sourceCode) {
            return compose2(wrapASTInFunctionWithScope, transformExpression)(expression, sourceFile, sourceCode);
          }
          function transformExpression(expression, sourceFile, sourceCode) {
            return compose2(getExpressionAST, updateNodesScope, createASTFromExpression)(expression, sourceFile, sourceCode);
          }
          function getExpressionAST(sourceAST) {
            const astBody = sourceAST.program.body;
            return astBody[0] ? astBody[0].expression : astBody;
          }
          function callTemplateFunction(template2, bindings2) {
            return builders.callExpression(builders.identifier(TEMPLATE_FN), [template2 ? builders.literal(template2) : nullNode(), bindings2 ? builders.arrayExpression(bindings2) : nullNode()]);
          }
          const attributeNameToDOMQuerySelector = (attributeName) => `[${attributeName}]`;
          function createSelectorProperties(attributeName) {
            return attributeName ? [simplePropertyNode(BINDING_REDUNDANT_ATTRIBUTE_KEY, builders.literal(attributeName)), simplePropertyNode(BINDING_SELECTOR_KEY, compose2(builders.literal, attributeNameToDOMQuerySelector)(attributeName))] : [];
          }
          function cloneNodeWithoutSelectorAttribute(node2, selectorAttribute) {
            return Object.assign({}, node2, {attributes: getAttributesWithoutSelector(getNodeAttributes(node2), selectorAttribute)});
          }
          function getAttributesWithoutSelector(attributes, selectorAttribute) {
            if (selectorAttribute)
              return attributes.filter((attribute) => attribute.name !== selectorAttribute);
            return attributes;
          }
          function cleanAttributes(node2) {
            return getNodeAttributes(node2).filter((attribute) => ![IF_DIRECTIVE, EACH_DIRECTIVE, KEY_ATTRIBUTE, SLOT_ATTRIBUTE, IS_DIRECTIVE2].includes(attribute.name));
          }
          function rootNodeFactory(node2) {
            return {nodes: getChildrenNodes(node2), isRoot: true};
          }
          function createRootNode(node2) {
            return Object.assign({}, rootNodeFactory(node2), {attributes: compose2(transformStatiAttributesIntoExpressions, cleanAttributes)(node2)});
          }
          function createNestedRootNode(node2) {
            return Object.assign({}, rootNodeFactory(node2), {attributes: cleanAttributes(node2)});
          }
          function transformStatiAttributesIntoExpressions(attributes) {
            return attributes.map((attribute) => {
              if (attribute.expressions)
                return attribute;
              return Object.assign({}, attribute, {expressions: [{start: attribute.valueStart, end: attribute.end, text: `'${attribute.value || attribute.name}'`}]});
            });
          }
          function getChildrenNodes(node2) {
            return node2 && node2.nodes ? node2.nodes : [];
          }
          function getNodeAttributes(node2) {
            return node2.attributes ? node2.attributes : [];
          }
          function getCustomNodeNameAsExpression(node2) {
            const isAttribute = findIsAttribute(node2);
            const toRawString = (val) => `'${val}'`;
            if (isAttribute) {
              return isAttribute.expressions ? isAttribute.expressions[0] : Object.assign({}, isAttribute, {text: toRawString(isAttribute.value)});
            }
            return Object.assign({}, node2, {text: toRawString(getName2(node2))});
          }
          function staticAttributesToString(node2) {
            return findStaticAttributes(node2).map((attribute) => attribute[IS_BOOLEAN_ATTRIBUTE] || !attribute.value ? attribute.name : `${attribute.name}="${unescapeNode(attribute, "value").value}"`).join(" ");
          }
          function unescapeNode(node2, key) {
            if (node2.unescape) {
              return Object.assign({}, node2, {[key]: unescapeChar(node2[key], node2.unescape)});
            }
            return node2;
          }
          function nodeToString(node2) {
            const attributes = staticAttributesToString(node2);
            switch (true) {
              case isTagNode(node2):
                return `<${node2.name}${attributes ? ` ${attributes}` : ""}${isVoidNode(node2) ? "/" : ""}>`;
              case isTextNode(node2):
                return hasExpressions(node2) ? TEXT_NODE_EXPRESSION_PLACEHOLDER : unescapeNode(node2, "text").text;
              default:
                return node2.text || "";
            }
          }
          function closeTag(node2) {
            return node2.name ? `</${node2.name}>` : "";
          }
          function createArrayString(stringsArray) {
            return builders.callExpression(builders.memberExpression(builders.arrayExpression(stringsArray), builders.identifier("join"), false), [builders.literal("")]);
          }
          function mergeAttributeExpressions(node2, sourceFile, sourceCode) {
            if (!node2.parts || node2.parts.length === 1) {
              return transformExpression(node2.expressions[0], sourceFile, sourceCode);
            }
            const stringsArray = [...node2.parts.reduce((acc, str) => {
              const expression = node2.expressions.find((e) => e.text.trim() === str);
              return [...acc, expression ? transformExpression(expression, sourceFile, sourceCode) : builders.literal(encodeHTMLEntities(str))];
            }, [])].filter((expr2) => !isLiteral(expr2) || expr2.value);
            return createArrayString(stringsArray);
          }
          const createBindingSelector = function createSelector(id) {
            if (id === void 0) {
              id = 0;
            }
            return () => `${BINDING_SELECTOR_PREFIX}${id++}`;
          }();
          function createBindingAttributes(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
            return builders.arrayExpression([...compose2((attributes) => attributes.map((attribute) => createExpression(attribute, sourceFile, sourceCode, 0, sourceNode2)), (attributes) => attributes.filter(hasExpressions), (attributes) => getAttributesWithoutSelector(attributes, selectorAttribute), cleanAttributes)(sourceNode2)]);
          }
          function createAttributeEvaluationFunction(sourceNode2, sourceFile, sourceCode) {
            return hasExpressions(sourceNode2) ? wrapASTInFunctionWithScope(mergeAttributeExpressions(sourceNode2, sourceFile, sourceCode)) : builders.functionExpression(null, [], builders.blockStatement([builders.returnStatement(builders.literal(sourceNode2.value || true))]));
          }
          function cloneDeep(source) {
            return JSON.parse(JSON.stringify(source));
          }
          const getEachItemName = (expression) => isSequenceExpression(expression.left) ? expression.left.expressions[0] : expression.left;
          const getEachIndexName = (expression) => isSequenceExpression(expression.left) ? expression.left.expressions[1] : null;
          const getEachValue = (expression) => expression.right;
          const nameToliteral = compose2(builders.literal, getName2);
          const generateEachItemNameKey = (expression) => simplePropertyNode(BINDING_ITEM_NAME_KEY, compose2(nameToliteral, getEachItemName)(expression));
          const generateEachIndexNameKey = (expression) => simplePropertyNode(BINDING_INDEX_NAME_KEY, compose2(nameToliteral, getEachIndexName)(expression));
          const generateEachEvaluateKey = (expression, eachExpression, sourceFile, sourceCode) => simplePropertyNode(BINDING_EVALUATE_KEY, compose2((e) => toScopedFunction(e, sourceFile, sourceCode), (e) => Object.assign({}, eachExpression, {text: generateJavascript(e).code}), getEachValue)(expression));
          function generateEachExpressionProperties(eachExpression, sourceFile, sourceCode) {
            const ast = createASTFromExpression(eachExpression, sourceFile, sourceCode);
            const body = ast.program.body;
            const firstNode = body[0];
            if (!isExpressionStatement(firstNode)) {
              panic$1(`The each directives supported should be of type "ExpressionStatement",you have provided a "${firstNode.type}"`);
            }
            const {expression} = firstNode;
            return [generateEachItemNameKey(expression), generateEachIndexNameKey(expression), generateEachEvaluateKey(expression, eachExpression, sourceFile, sourceCode)];
          }
          function createEachBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
            const [ifAttribute, eachAttribute, keyAttribute] = [findIfAttribute, findEachAttribute, findKeyAttribute].map((f) => f(sourceNode2));
            const attributeOrNull = (attribute) => attribute ? toScopedFunction(getAttributeExpression(attribute), sourceFile, sourceCode) : nullNode();
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(EACH_BINDING_TYPE), false)), simplePropertyNode(BINDING_GET_KEY_KEY, attributeOrNull(keyAttribute)), simplePropertyNode(BINDING_CONDITION_KEY, attributeOrNull(ifAttribute)), createTemplateProperty(createNestedBindings(sourceNode2, sourceFile, sourceCode, selectorAttribute)), ...createSelectorProperties(selectorAttribute), ...compose2(generateEachExpressionProperties, getAttributeExpression)(eachAttribute)]);
          }
          function createIfBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
            const ifAttribute = findIfAttribute(sourceNode2);
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(IF_BINDING_TYPE), false)), simplePropertyNode(BINDING_EVALUATE_KEY, toScopedFunction(ifAttribute.expressions[0], sourceFile, sourceCode)), ...createSelectorProperties(selectorAttribute), createTemplateProperty(createNestedBindings(sourceNode2, sourceFile, sourceCode, selectorAttribute))]);
          }
          function createTextNodeExpressions(sourceNode2, sourceFile, sourceCode) {
            const childrenNodes = getChildrenNodes(sourceNode2);
            return childrenNodes.filter(isTextNode).filter(hasExpressions).map((node2) => createExpression(node2, sourceFile, sourceCode, childrenNodes.indexOf(node2), sourceNode2));
          }
          function createSimpleBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
            return builders.objectExpression([
              ...isRemovableNode(sourceNode2) || isRootNode(sourceNode2) ? [] : createSelectorProperties(selectorAttribute),
              simplePropertyNode(BINDING_EXPRESSIONS_KEY, builders.arrayExpression([...createTextNodeExpressions(sourceNode2, sourceFile, sourceCode), ...createAttributeExpressions(sourceNode2, sourceFile, sourceCode)]))
            ]);
          }
          function createSlotBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
            const slotNameAttribute = findAttribute(NAME_ATTRIBUTE, sourceNode2);
            const slotName = slotNameAttribute ? slotNameAttribute.value : DEFAULT_SLOT_NAME;
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(SLOT_BINDING_TYPE), false)), simplePropertyNode(BINDING_ATTRIBUTES_KEY, createBindingAttributes(Object.assign({}, sourceNode2, {
              attributes: getNodeAttributes(sourceNode2).filter((attribute) => getName2(attribute) !== NAME_ATTRIBUTE)
            }), selectorAttribute, sourceFile, sourceCode)), simplePropertyNode(BINDING_NAME_KEY, builders.literal(slotName)), ...createSelectorProperties(selectorAttribute)]);
          }
          function groupSlots(sourceNode2) {
            return getChildrenNodes(sourceNode2).reduce((acc, node2) => {
              const slotAttribute = findSlotAttribute(node2);
              if (slotAttribute) {
                acc[slotAttribute.value] = node2;
              } else {
                acc.default = createNestedRootNode({nodes: [...getChildrenNodes(acc.default), node2]});
              }
              return acc;
            }, {default: null});
          }
          function buildSlot(id, sourceNode2, sourceFile, sourceCode) {
            const cloneNode = Object.assign({}, sourceNode2, {attributes: getNodeAttributes(sourceNode2)});
            const [html, bindings2] = build(cloneNode, sourceFile, sourceCode);
            return builders.objectExpression([simplePropertyNode(BINDING_ID_KEY, builders.literal(id)), simplePropertyNode(BINDING_HTML_KEY, builders.literal(html)), simplePropertyNode(BINDING_BINDINGS_KEY, builders.arrayExpression(bindings2))]);
          }
          function createSlotsArray(sourceNode2, sourceFile, sourceCode) {
            return builders.arrayExpression([...compose2((slots) => slots.map((_ref20) => {
              let [key, value] = _ref20;
              return buildSlot(key, value, sourceFile, sourceCode);
            }), (slots) => slots.filter((_ref21) => {
              let [, value] = _ref21;
              return value;
            }), Object.entries, groupSlots)(sourceNode2)]);
          }
          function findSlotAttribute(sourceNode2) {
            return getNodeAttributes(sourceNode2).find((attribute) => attribute.name === SLOT_ATTRIBUTE);
          }
          function createTagBinding(sourceNode2, selectorAttribute, sourceFile, sourceCode) {
            return builders.objectExpression([simplePropertyNode(BINDING_TYPE_KEY, builders.memberExpression(builders.identifier(BINDING_TYPES), builders.identifier(TAG_BINDING_TYPE), false)), simplePropertyNode(BINDING_GET_COMPONENT_KEY, builders.identifier(GET_COMPONENT_FN)), simplePropertyNode(BINDING_EVALUATE_KEY, toScopedFunction(getCustomNodeNameAsExpression(sourceNode2), sourceFile, sourceCode)), simplePropertyNode(BINDING_SLOTS_KEY, createSlotsArray(sourceNode2, sourceFile, sourceCode)), simplePropertyNode(BINDING_ATTRIBUTES_KEY, createBindingAttributes(sourceNode2, selectorAttribute, sourceFile, sourceCode)), ...createSelectorProperties(selectorAttribute)]);
          }
          const BuildingState = Object.freeze({html: [], bindings: [], parent: null});
          function createBindingsTag(sourceNode2, bindingsSelector) {
            if (!bindingsSelector)
              return sourceNode2;
            return Object.assign({}, sourceNode2, {
              attributes: [{name: bindingsSelector, value: bindingsSelector}, ...getNodeAttributes(sourceNode2)]
            });
          }
          function createDynamicNode(sourceNode2, sourceFile, sourceCode, state) {
            switch (true) {
              case isTextNode(sourceNode2):
                return [nodeToString(sourceNode2), []];
              default:
                return createTagWithBindings(sourceNode2, sourceFile, sourceCode);
            }
          }
          function createTagWithBindings(sourceNode2, sourceFile, sourceCode) {
            const bindingsSelector = isRootNode(sourceNode2) ? null : createBindingSelector();
            const cloneNode = createBindingsTag(sourceNode2, bindingsSelector);
            const tagOpeningHTML = nodeToString(cloneNode);
            switch (true) {
              case hasEachAttribute(cloneNode):
                return [tagOpeningHTML, [createEachBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
              case hasIfAttribute(cloneNode):
                return [tagOpeningHTML, [createIfBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
              case isCustomNode(cloneNode):
                return [tagOpeningHTML, [createTagBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
              case isSlotNode(cloneNode):
                return [tagOpeningHTML, [createSlotBinding(cloneNode, bindingsSelector)]];
              default:
                return [tagOpeningHTML, [createSimpleBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)]];
            }
          }
          function parseNode(sourceNode2, sourceFile, sourceCode, state) {
            if (isStaticNode(sourceNode2))
              return [nodeToString(sourceNode2), []];
            return createDynamicNode(sourceNode2, sourceFile, sourceCode);
          }
          function createNestedBindings(sourceNode2, sourceFile, sourceCode, selector) {
            const mightBeARiotComponent = isCustomNode(sourceNode2);
            const node2 = cloneNodeWithoutSelectorAttribute(sourceNode2, selector);
            return mightBeARiotComponent ? [null, [createTagBinding(node2, null, sourceFile, sourceCode)]] : build(createNestedRootNode(node2), sourceFile, sourceCode);
          }
          function build(sourceNode2, sourceFile, sourceCode, state) {
            if (!sourceNode2)
              panic$1("Something went wrong with your tag DOM parsing, your tag template can't be created");
            const [nodeHTML, nodeBindings] = parseNode(sourceNode2, sourceFile, sourceCode);
            const childrenNodes = getChildrenNodes(sourceNode2);
            const canRenderNodeHTML = isRemovableNode(sourceNode2) === false;
            const currentState = Object.assign({}, cloneDeep(BuildingState), state);
            canRenderNodeHTML && currentState.html.push(...nodeHTML);
            currentState.bindings.push(...nodeBindings);
            if (childrenNodes.length && !hasItsOwnTemplate(sourceNode2)) {
              childrenNodes.forEach((node2) => build(node2, sourceFile, sourceCode, Object.assign({parent: sourceNode2}, currentState)));
            }
            if (canRenderNodeHTML && isTagNode(sourceNode2) && !isVoidNode(sourceNode2)) {
              currentState.html.push(closeTag(sourceNode2));
            }
            return [currentState.html.join(""), currentState.bindings];
          }
          const templateFunctionArguments = [TEMPLATE_FN, EXPRESSION_TYPES, BINDING_TYPES, GET_COMPONENT_FN].map(builders.identifier);
          function createTemplateFunctionContent(sourceNode2, sourceFile, sourceCode) {
            return builders.blockStatement([builders.returnStatement(callTemplateFunction(...build(createRootNode(sourceNode2), sourceFile, sourceCode)))]);
          }
          function extendTemplateProperty(ast, sourceFile, sourceCode, sourceNode2) {
            types$2.visit(ast, {visitProperty(path2) {
              if (path2.value.key.value === TAG_TEMPLATE_PROPERTY) {
                path2.value.value = builders.functionExpression(null, templateFunctionArguments, createTemplateFunctionContent(sourceNode2, sourceFile, sourceCode));
                return false;
              }
              this.traverse(path2);
            }});
            return ast;
          }
          function template(sourceNode2, source, meta, ast) {
            const {options: options2} = meta;
            return extendTemplateProperty(ast, options2.file, source, sourceNode2);
          }
          const DEFAULT_OPTIONS = {template: "default", file: "[unknown-source-file]", scopedCss: true};
          function createInitialInput(_ref22) {
            let {tagName} = _ref22;
            return builders.program([builders.exportDefaultDeclaration(builders.objectExpression([simplePropertyNode(TAG_CSS_PROPERTY, nullNode()), simplePropertyNode(TAG_LOGIC_PROPERTY, nullNode()), simplePropertyNode(TAG_TEMPLATE_PROPERTY, nullNode()), simplePropertyNode(TAG_NAME_PROPERTY, builders.literal(tagName))]))]);
          }
          function normaliseInputSourceMap(map) {
            const inputSourceMap = sourcemapAsJSON(map);
            return isEmptySourcemap(inputSourceMap) ? null : inputSourceMap;
          }
          function overrideSourcemapContent(map, source) {
            return Object.assign({}, map, {sourcesContent: [source]});
          }
          function createMeta(source, options2) {
            return {tagName: null, fragments: null, options: Object.assign({}, DEFAULT_OPTIONS, options2), source};
          }
          function compile2(source, opts) {
            if (opts === void 0) {
              opts = {};
            }
            const meta = createMeta(source, opts);
            const {options: options2} = meta;
            const {code, map} = execute("template", options2.template, meta, source);
            const {parse} = parser(options2);
            const {template: template$1, css: css$1, javascript: javascript$1} = parse(code).output;
            if (hasHTMLOutsideRootNode(template$1 || css$1 || javascript$1, code, parse)) {
              throw new Error("Multiple HTML root nodes are not supported");
            }
            Object.assign(meta, {tagName: template$1.name, fragments: {template: template$1, css: css$1, javascript: javascript$1}});
            return compose2((result) => Object.assign({}, result, {meta}), (result) => execute$1(result, meta), (result) => Object.assign({}, result, {map: overrideSourcemapContent(result.map, source)}), (ast) => meta.ast = ast && generateJavascript(ast, {sourceMapName: `${options2.file}.map`, inputSourceMap: normaliseInputSourceMap(map)}), hookGenerator(template, template$1, code, meta), hookGenerator(javascript, javascript$1, code, meta), hookGenerator(css, css$1, code, meta))(createInitialInput(meta));
          }
          function hookGenerator(transformer, sourceNode2, source, meta) {
            if (!sourceNode2 || sourceNode2.nodes && !sourceNode2.nodes.length || !sourceNode2.nodes && !sourceNode2.text) {
              return (result) => result;
            }
            return curry2(transformer)(sourceNode2, source, meta);
          }
          const registerPreprocessor = register2;
          const registerPostprocessor = register$1;
          exports3.compile = compile2;
          exports3.createInitialInput = createInitialInput;
          exports3.registerPostprocessor = registerPostprocessor;
          exports3.registerPreprocessor = registerPreprocessor;
          Object.defineProperty(exports3, "__esModule", {value: true});
        });
      })(compiler$1, compiler$1.exports);
      var compiler = /* @__PURE__ */ getDefaultExportFromCjs2(compiler$1.exports);
      const GLOBAL_REGISTRY = "__riot_registry__";
      window[GLOBAL_REGISTRY] = {};
      function evaluate(js, url) {
        const node = document.createElement("script");
        const root = document.documentElement;
        if (url)
          node.text = `${js}
//# sourceURL=${url}.js`;
        root.appendChild(node);
        root.removeChild(node);
      }
      function transpile(code) {
        return `(function (global){${code}})(this)`.replace("export default", "return");
      }
      function inject(code, tagName, url) {
        evaluate(`window.${GLOBAL_REGISTRY}['${tagName}'] = ${transpile(code)}`, url);
        register(tagName, window[GLOBAL_REGISTRY][tagName]);
      }
      function compileFromString(string, options) {
        return compiler.compile(string, options);
      }
      function compileFromUrl(url, options) {
        return __async(this, null, function* () {
          const response = yield fetch(url);
          const code = yield response.text();
          return compiler.compile(code, Object.assign({
            file: url
          }, options));
        });
      }
      function compile(options) {
        return __async(this, null, function* () {
          const scripts = $('script[type="riot"]');
          const urls = scripts.map((s) => get(s, "src") || get(s, "data-src"));
          const tags = yield Promise.all(urls.map((url) => compileFromUrl(url, options)));
          tags.forEach((_ref, i) => {
            let {
              code,
              meta
            } = _ref;
            const url = urls[i];
            const {
              tagName
            } = meta;
            inject(code, tagName, url);
          });
        });
      }
      var riot_compiler2 = Object.assign({}, riot2, {
        compile,
        inject,
        compileFromUrl,
        compileFromString,
        compiler
      });
      return riot_compiler2;
    });
  })(riot_compiler);
  var riotAndCompiler = /* @__PURE__ */ getDefaultExportFromCjs(riot_compiler.exports);
  class SHandlebarsComponentInterface extends SInterface {
  }
  SHandlebarsComponentInterface.definition = {
    source: {
      type: "String"
    }
  };
  const Component = {
    "css": ``,
    "exports": {
      $source: void 0,
      tagName: `riot-${uniqid()}`,
      state: {},
      onBeforeMount() {
        return __async(this, null, function* () {
          this.component = new SComponentUtils(this.root, this.props, {
            interface: SHandlebarsComponentInterface
          });
          if (this.component.props.source) {
            this.$source = document.querySelector(this.component.props.source);
          }
          let data = {};
          if (this.$source) {
            if (!this.$source.getData) {
              throw new Error(`<red>[s-handlebars]</red> Sorry but the spcified data source provider does not provide an "<yellow>getData</yellow>" api method`);
            }
            data = yield this.$source.getData();
          }
          this.$template = this.root.querySelector("template");
          this._template = this.$template.innerHTML;
          let codeStr;
          if (!this._template.match(/<script(.*)?>/)) {
            this._template = `
              ${this._template}
              <script>
                  export default {
                      onBeforeMount() {
                          this.root.update = this.update.bind(this);
                      }
                  };
              </script>
          `;
          } else if (this._template.match(/onBeforeMount\(\)\s?\{/)) {
            this._template = this._template.replace(/onBeforeMount\(\)\s?\{/, `onBeforeMount() { this.root.update = this.update.bind(this); `);
          } else {
            this._template = this._template.replace(/export default\s?\{/, `export default {
              onBeforeMount() { this.root.update = this.update.bind(this); }, `);
          }
          codeStr = `
          <${this.tagName}>
              ${this._template}
          </${this.tagName}>
      `;
          const {code} = riotAndCompiler.compileFromString(codeStr);
          riotAndCompiler.inject(code, this.tagName, "index.html");
          const $tag = document.createElement(this.tagName);
          this.$template.parentNode.insertBefore($tag, this.$template.nextSibling);
          riotAndCompiler.mount(this.tagName);
          $tag.update({
            data
          });
          this.root.setData = this.setData.bind(this);
        });
      },
      onMounted() {
        console.log("COCO");
      },
      setData(data) {
        console.log("data", data);
      }
    },
    "template": null,
    "name": "s-handlebars"
  };
  register("s-handlebars", Component);
  querySelectorLive$1("s-handlebars:not([s-mounted])", ($elm) => {
    const id = $elm.id || "s-handlebars-" + uniqid();
    $elm.setAttribute("id", id);
    mount("#" + id);
  });
  Component.mount = () => {
    mount("s-handlebars");
  };
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  function matches(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer;
  const _selectors = {};
  function querySelectorLive(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid$6()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors[selector]) {
      _selectors[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors[obj.selector];
          });
        });
      }
      if (!_observer) {
        _observer = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid$6()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors);
                selectors.forEach((sel) => {
                  if (matches(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors);
              selectors.forEach((sel) => {
                if (matches(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  function expandPleasantCssClassname(classesStr) {
    const classesArray = [];
    const classNames = classesStr.split(/\s+/);
    let currentMedia = "";
    classNames.forEach((className) => {
      if (className.slice(0, 1) == "@") {
        currentMedia = className.replace("@", "___");
        return;
      }
      const parts = className.split(":");
      if (parts.length === 1) {
        let name2 = className;
        if (currentMedia !== "")
          name2 = className + currentMedia;
        classesArray.push(name2);
      } else {
        const firstClass = parts[0];
        let name2 = firstClass;
        if (currentMedia !== "")
          name2 = firstClass + currentMedia;
        classesArray.push(name2);
        parts.forEach((part, i) => {
          if (i > 0) {
            name2 = firstClass + "--" + part;
            if (currentMedia !== "")
              name2 = name2 + currentMedia;
            classesArray.push(name2);
          }
        });
      }
    });
    return classesArray.join(" ");
  }
  function expandPleasantCssClassnamesLive() {
    querySelectorLive('[class*=":"],[class*="@"]', ($elm) => {
      const classesStr = $elm.getAttribute("class");
      const newClassesStr = expandPleasantCssClassname(classesStr);
      $elm.setAttribute("class", newClassesStr);
    }, {
      once: false
    });
  }
  var striptags$1 = {exports: {}};
  (function(module) {
    (function(global2) {
      if (typeof Symbol2 !== "function") {
        var Symbol2 = function(name2) {
          return name2;
        };
        Symbol2.nonNative = true;
      }
      const STATE_PLAINTEXT = Symbol2("plaintext");
      const STATE_HTML = Symbol2("html");
      const STATE_COMMENT = Symbol2("comment");
      const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
      const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
      function striptags(html, allowable_tags, tag_replacement) {
        html = html || "";
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return striptags_internal(html, context);
      }
      function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return function striptags_stream(html) {
          return striptags_internal(html || "", context);
        };
      }
      striptags.init_streaming_mode = init_striptags_stream;
      function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);
        return {
          allowable_tags,
          tag_replacement,
          state: STATE_PLAINTEXT,
          tag_buffer: "",
          depth: 0,
          in_quote_char: ""
        };
      }
      function striptags_internal(html, context) {
        let allowable_tags = context.allowable_tags;
        let tag_replacement = context.tag_replacement;
        let state = context.state;
        let tag_buffer = context.tag_buffer;
        let depth = context.depth;
        let in_quote_char = context.in_quote_char;
        let output = "";
        for (let idx = 0, length = html.length; idx < length; idx++) {
          let char = html[idx];
          if (state === STATE_PLAINTEXT) {
            switch (char) {
              case "<":
                state = STATE_HTML;
                tag_buffer += char;
                break;
              default:
                output += char;
                break;
            }
          } else if (state === STATE_HTML) {
            switch (char) {
              case "<":
                if (in_quote_char) {
                  break;
                }
                depth++;
                break;
              case ">":
                if (in_quote_char) {
                  break;
                }
                if (depth) {
                  depth--;
                  break;
                }
                in_quote_char = "";
                state = STATE_PLAINTEXT;
                tag_buffer += ">";
                if (allowable_tags.has(normalize_tag(tag_buffer))) {
                  output += tag_buffer;
                } else {
                  output += tag_replacement;
                }
                tag_buffer = "";
                break;
              case '"':
              case "'":
                if (char === in_quote_char) {
                  in_quote_char = "";
                } else {
                  in_quote_char = in_quote_char || char;
                }
                tag_buffer += char;
                break;
              case "-":
                if (tag_buffer === "<!-") {
                  state = STATE_COMMENT;
                }
                tag_buffer += char;
                break;
              case " ":
              case "\n":
                if (tag_buffer === "<") {
                  state = STATE_PLAINTEXT;
                  output += "< ";
                  tag_buffer = "";
                  break;
                }
                tag_buffer += char;
                break;
              default:
                tag_buffer += char;
                break;
            }
          } else if (state === STATE_COMMENT) {
            switch (char) {
              case ">":
                if (tag_buffer.slice(-2) == "--") {
                  state = STATE_PLAINTEXT;
                }
                tag_buffer = "";
                break;
              default:
                tag_buffer += char;
                break;
            }
          }
        }
        context.state = state;
        context.tag_buffer = tag_buffer;
        context.depth = depth;
        context.in_quote_char = in_quote_char;
        return output;
      }
      function parse_allowable_tags(allowable_tags) {
        let tag_set = new Set();
        if (typeof allowable_tags === "string") {
          let match;
          while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
            tag_set.add(match[1]);
          }
        } else if (!Symbol2.nonNative && typeof allowable_tags[Symbol2.iterator] === "function") {
          tag_set = new Set(allowable_tags);
        } else if (typeof allowable_tags.forEach === "function") {
          allowable_tags.forEach(tag_set.add, tag_set);
        }
        return tag_set;
      }
      function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
        return match ? match[1].toLowerCase() : null;
      }
      if (module.exports) {
        module.exports = striptags;
      } else {
        global2.striptags = striptags;
      }
    })(commonjsGlobal$2);
  })(striptags$1);
  var __striptags = striptags$1.exports;
  function striptags(html, allowedTags = "", tagReplacement = "") {
    return __striptags(html, allowedTags, tagReplacement);
  }
  function ltrim(string, needle, trimResult = true) {
    if (string.substr(0, needle.length) === needle) {
      return trimResult ? string.substr(needle.length).trim() : string.substr(needle.length);
    }
    return string;
  }
  function queryStringToObject(str) {
    str = ltrim(str, "?");
    str = decodeURIComponent(str);
    let chunks = str.split("&");
    const obj = {};
    chunks = chunks.filter((ch) => {
      return ch !== "";
    });
    for (let c = 0; c < chunks.length; c++) {
      const split = chunks[c].split("=", 2);
      obj[split[0]] = split[1];
    }
    return obj;
  }
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __assign = function() {
    __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return {value: o && o[i++], done: !o};
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = {error};
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || from);
  }
  var ENTRIES = "ENTRIES";
  var KEYS = "KEYS";
  var VALUES = "VALUES";
  var LEAF = "";
  var TreeIterator = function() {
    function TreeIterator(set, type) {
      var node = set._tree;
      var keys = Object.keys(node);
      this.set = set;
      this._type = type;
      this._path = keys.length > 0 ? [{node, keys}] : [];
    }
    TreeIterator.prototype.next = function() {
      var value = this.dive();
      this.backtrack();
      return value;
    };
    TreeIterator.prototype.dive = function() {
      if (this._path.length === 0) {
        return {done: true, value: void 0};
      }
      var _a = last$1(this._path), node = _a.node, keys = _a.keys;
      if (last$1(keys) === LEAF) {
        return {done: false, value: this.result()};
      }
      this._path.push({node: node[last$1(keys)], keys: Object.keys(node[last$1(keys)])});
      return this.dive();
    };
    TreeIterator.prototype.backtrack = function() {
      if (this._path.length === 0) {
        return;
      }
      last$1(this._path).keys.pop();
      if (last$1(this._path).keys.length > 0) {
        return;
      }
      this._path.pop();
      this.backtrack();
    };
    TreeIterator.prototype.key = function() {
      return this.set._prefix + this._path.map(function(_a) {
        var keys = _a.keys;
        return last$1(keys);
      }).filter(function(key) {
        return key !== LEAF;
      }).join("");
    };
    TreeIterator.prototype.value = function() {
      return last$1(this._path).node[LEAF];
    };
    TreeIterator.prototype.result = function() {
      if (this._type === VALUES) {
        return this.value();
      }
      if (this._type === KEYS) {
        return this.key();
      }
      return [this.key(), this.value()];
    };
    TreeIterator.prototype[Symbol.iterator] = function() {
      return this;
    };
    return TreeIterator;
  }();
  var last$1 = function(array) {
    return array[array.length - 1];
  };
  var NONE = 0;
  var CHANGE = 1;
  var ADD = 2;
  var DELETE = 3;
  var fuzzySearch = function(node, query, maxDistance) {
    var stack = [{distance: 0, i: 0, key: "", node}];
    var results = {};
    var innerStack = [];
    var _loop_1 = function() {
      var _a = stack.pop(), node_1 = _a.node, distance = _a.distance, key = _a.key, i = _a.i, edit = _a.edit;
      Object.keys(node_1).forEach(function(k) {
        if (k === LEAF) {
          var totDistance = distance + (query.length - i);
          var _a2 = __read(results[key] || [null, Infinity], 2), d = _a2[1];
          if (totDistance <= maxDistance && totDistance < d) {
            results[key] = [node_1[k], totDistance];
          }
        } else {
          withinDistance(query, k, maxDistance - distance, i, edit, innerStack).forEach(function(_a3) {
            var d2 = _a3.distance, i2 = _a3.i, edit2 = _a3.edit;
            stack.push({node: node_1[k], distance: distance + d2, key: key + k, i: i2, edit: edit2});
          });
        }
      });
    };
    while (stack.length > 0) {
      _loop_1();
    }
    return results;
  };
  var withinDistance = function(a, b, maxDistance, i, edit, stack) {
    stack.push({distance: 0, ia: i, ib: 0, edit});
    var results = [];
    while (stack.length > 0) {
      var _a = stack.pop(), distance = _a.distance, ia = _a.ia, ib = _a.ib, edit_1 = _a.edit;
      if (ib === b.length) {
        results.push({distance, i: ia, edit: edit_1});
        continue;
      }
      if (a[ia] === b[ib]) {
        stack.push({distance, ia: ia + 1, ib: ib + 1, edit: NONE});
      } else {
        if (distance >= maxDistance) {
          continue;
        }
        if (edit_1 !== ADD) {
          stack.push({distance: distance + 1, ia, ib: ib + 1, edit: DELETE});
        }
        if (ia < a.length) {
          if (edit_1 !== DELETE) {
            stack.push({distance: distance + 1, ia: ia + 1, ib, edit: ADD});
          }
          if (edit_1 !== DELETE && edit_1 !== ADD) {
            stack.push({distance: distance + 1, ia: ia + 1, ib: ib + 1, edit: CHANGE});
          }
        }
      }
    }
    return results;
  };
  var SearchableMap = function() {
    function SearchableMap(tree, prefix) {
      if (tree === void 0) {
        tree = {};
      }
      if (prefix === void 0) {
        prefix = "";
      }
      this._tree = tree;
      this._prefix = prefix;
    }
    SearchableMap.prototype.atPrefix = function(prefix) {
      var _a;
      if (!prefix.startsWith(this._prefix)) {
        throw new Error("Mismatched prefix");
      }
      var _b = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2), node = _b[0], path = _b[1];
      if (node === void 0) {
        var _c = __read(last(path), 2), parentNode = _c[0], key_1 = _c[1];
        var nodeKey = Object.keys(parentNode).find(function(k) {
          return k !== LEAF && k.startsWith(key_1);
        });
        if (nodeKey !== void 0) {
          return new SearchableMap((_a = {}, _a[nodeKey.slice(key_1.length)] = parentNode[nodeKey], _a), prefix);
        }
      }
      return new SearchableMap(node || {}, prefix);
    };
    SearchableMap.prototype.clear = function() {
      delete this._size;
      this._tree = {};
    };
    SearchableMap.prototype.delete = function(key) {
      delete this._size;
      return remove$3(this._tree, key);
    };
    SearchableMap.prototype.entries = function() {
      return new TreeIterator(this, ENTRIES);
    };
    SearchableMap.prototype.forEach = function(fn) {
      var e_1, _a;
      try {
        for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
          fn(key, value, this);
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    SearchableMap.prototype.fuzzyGet = function(key, maxEditDistance) {
      return fuzzySearch(this._tree, key, maxEditDistance);
    };
    SearchableMap.prototype.get = function(key) {
      var node = lookup(this._tree, key);
      return node !== void 0 ? node[LEAF] : void 0;
    };
    SearchableMap.prototype.has = function(key) {
      var node = lookup(this._tree, key);
      return node !== void 0 && node.hasOwnProperty(LEAF);
    };
    SearchableMap.prototype.keys = function() {
      return new TreeIterator(this, KEYS);
    };
    SearchableMap.prototype.set = function(key, value) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      delete this._size;
      var node = createPath(this._tree, key);
      node[LEAF] = value;
      return this;
    };
    Object.defineProperty(SearchableMap.prototype, "size", {
      get: function() {
        var _this = this;
        if (this._size) {
          return this._size;
        }
        this._size = 0;
        this.forEach(function() {
          _this._size += 1;
        });
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    SearchableMap.prototype.update = function(key, fn) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      delete this._size;
      var node = createPath(this._tree, key);
      node[LEAF] = fn(node[LEAF]);
      return this;
    };
    SearchableMap.prototype.values = function() {
      return new TreeIterator(this, VALUES);
    };
    SearchableMap.prototype[Symbol.iterator] = function() {
      return this.entries();
    };
    SearchableMap.from = function(entries) {
      var e_2, _a;
      var tree = new SearchableMap();
      try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
          var _b = __read(entries_1_1.value, 2), key = _b[0], value = _b[1];
          tree.set(key, value);
        }
      } catch (e_2_1) {
        e_2 = {error: e_2_1};
      } finally {
        try {
          if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
            _a.call(entries_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return tree;
    };
    SearchableMap.fromObject = function(object) {
      return SearchableMap.from(Object.entries(object));
    };
    return SearchableMap;
  }();
  var trackDown = function(tree, key, path) {
    if (path === void 0) {
      path = [];
    }
    if (key.length === 0 || tree == null) {
      return [tree, path];
    }
    var nodeKey = Object.keys(tree).find(function(k) {
      return k !== LEAF && key.startsWith(k);
    });
    if (nodeKey === void 0) {
      path.push([tree, key]);
      return trackDown(void 0, "", path);
    }
    path.push([tree, nodeKey]);
    return trackDown(tree[nodeKey], key.slice(nodeKey.length), path);
  };
  var lookup = function(tree, key) {
    if (key.length === 0 || tree == null) {
      return tree;
    }
    var nodeKey = Object.keys(tree).find(function(k) {
      return k !== LEAF && key.startsWith(k);
    });
    if (nodeKey === void 0) {
      return void 0;
    }
    return lookup(tree[nodeKey], key.slice(nodeKey.length));
  };
  var createPath = function(tree, key) {
    var _a;
    if (key.length === 0 || tree == null) {
      return tree;
    }
    var nodeKey = Object.keys(tree).find(function(k) {
      return k !== LEAF && key.startsWith(k);
    });
    if (nodeKey === void 0) {
      var toSplit = Object.keys(tree).find(function(k) {
        return k !== LEAF && k.startsWith(key[0]);
      });
      if (toSplit === void 0) {
        tree[key] = {};
      } else {
        var prefix = commonPrefix(key, toSplit);
        tree[prefix] = (_a = {}, _a[toSplit.slice(prefix.length)] = tree[toSplit], _a);
        delete tree[toSplit];
        return createPath(tree[prefix], key.slice(prefix.length));
      }
      return tree[key];
    }
    return createPath(tree[nodeKey], key.slice(nodeKey.length));
  };
  var commonPrefix = function(a, b, i, length, prefix) {
    if (i === void 0) {
      i = 0;
    }
    if (length === void 0) {
      length = Math.min(a.length, b.length);
    }
    if (prefix === void 0) {
      prefix = "";
    }
    if (i >= length) {
      return prefix;
    }
    if (a[i] !== b[i]) {
      return prefix;
    }
    return commonPrefix(a, b, i + 1, length, prefix + a[i]);
  };
  var remove$3 = function(tree, key) {
    var _a = __read(trackDown(tree, key), 2), node = _a[0], path = _a[1];
    if (node === void 0) {
      return;
    }
    delete node[LEAF];
    var keys = Object.keys(node);
    if (keys.length === 0) {
      cleanup(path);
    }
    if (keys.length === 1) {
      merge(path, keys[0], node[keys[0]]);
    }
  };
  var cleanup = function(path) {
    if (path.length === 0) {
      return;
    }
    var _a = __read(last(path), 2), node = _a[0], key = _a[1];
    delete node[key];
    var keys = Object.keys(node);
    if (keys.length === 0) {
      cleanup(path.slice(0, -1));
    }
    if (keys.length === 1 && keys[0] !== LEAF) {
      merge(path.slice(0, -1), keys[0], node[keys[0]]);
    }
  };
  var merge = function(path, key, value) {
    if (path.length === 0) {
      return;
    }
    var _a = __read(last(path), 2), node = _a[0], nodeKey = _a[1];
    node[nodeKey + key] = value;
    delete node[nodeKey];
  };
  var last = function(array) {
    return array[array.length - 1];
  };
  var _a;
  var OR = "or";
  var AND = "and";
  var MiniSearch = function() {
    function MiniSearch(options) {
      if ((options === null || options === void 0 ? void 0 : options.fields) == null) {
        throw new Error('MiniSearch: option "fields" must be provided');
      }
      this._options = __assign(__assign(__assign({}, defaultOptions), options), {searchOptions: __assign(__assign({}, defaultSearchOptions), options.searchOptions || {})});
      this._index = new SearchableMap();
      this._documentCount = 0;
      this._documentIds = {};
      this._fieldIds = {};
      this._fieldLength = {};
      this._averageFieldLength = {};
      this._nextId = 0;
      this._storedFields = {};
      this.addFields(this._options.fields);
    }
    MiniSearch.prototype.add = function(document2) {
      var _this = this;
      var _a = this._options, extractField = _a.extractField, tokenize = _a.tokenize, processTerm = _a.processTerm, fields = _a.fields, idField = _a.idField;
      var id = extractField(document2, idField);
      if (id == null) {
        throw new Error('MiniSearch: document does not have ID field "' + idField + '"');
      }
      var shortDocumentId = this.addDocumentId(id);
      this.saveStoredFields(shortDocumentId, document2);
      fields.forEach(function(field) {
        var fieldValue = extractField(document2, field);
        if (fieldValue == null) {
          return;
        }
        var tokens = tokenize(fieldValue.toString(), field);
        _this.addFieldLength(shortDocumentId, _this._fieldIds[field], _this.documentCount - 1, tokens.length);
        tokens.forEach(function(term) {
          var processedTerm = processTerm(term, field);
          if (processedTerm) {
            _this.addTerm(_this._fieldIds[field], shortDocumentId, processedTerm);
          }
        });
      });
    };
    MiniSearch.prototype.addAll = function(documents) {
      var _this = this;
      documents.forEach(function(document2) {
        return _this.add(document2);
      });
    };
    MiniSearch.prototype.addAllAsync = function(documents, options) {
      var _this = this;
      if (options === void 0) {
        options = {};
      }
      var _a = options.chunkSize, chunkSize = _a === void 0 ? 10 : _a;
      var acc = {chunk: [], promise: Promise.resolve()};
      var _b = documents.reduce(function(_a2, document2, i) {
        var chunk2 = _a2.chunk, promise2 = _a2.promise;
        chunk2.push(document2);
        if ((i + 1) % chunkSize === 0) {
          return {
            chunk: [],
            promise: promise2.then(function() {
              return new Promise(function(resolve) {
                return setTimeout(resolve, 0);
              });
            }).then(function() {
              return _this.addAll(chunk2);
            })
          };
        } else {
          return {chunk: chunk2, promise: promise2};
        }
      }, acc), chunk = _b.chunk, promise = _b.promise;
      return promise.then(function() {
        return _this.addAll(chunk);
      });
    };
    MiniSearch.prototype.remove = function(document2) {
      var _this = this;
      var _a = this._options, tokenize = _a.tokenize, processTerm = _a.processTerm, extractField = _a.extractField, fields = _a.fields, idField = _a.idField;
      var id = extractField(document2, idField);
      if (id == null) {
        throw new Error('MiniSearch: document does not have ID field "' + idField + '"');
      }
      var _b = __read(Object.entries(this._documentIds).find(function(_a2) {
        var _b2 = __read(_a2, 2);
        _b2[0];
        var longId = _b2[1];
        return id === longId;
      }) || [], 1), shortDocumentId = _b[0];
      if (shortDocumentId == null) {
        throw new Error("MiniSearch: cannot remove document with ID " + id + ": it is not in the index");
      }
      fields.forEach(function(field) {
        var fieldValue = extractField(document2, field);
        if (fieldValue == null) {
          return;
        }
        var tokens = tokenize(fieldValue.toString(), field);
        tokens.forEach(function(term) {
          var processedTerm = processTerm(term, field);
          if (processedTerm) {
            _this.removeTerm(_this._fieldIds[field], shortDocumentId, processedTerm);
          }
        });
        _this.removeFieldLength(shortDocumentId, _this._fieldIds[field], _this.documentCount, tokens.length);
      });
      delete this._storedFields[shortDocumentId];
      delete this._documentIds[shortDocumentId];
      delete this._fieldLength[shortDocumentId];
      this._documentCount -= 1;
    };
    MiniSearch.prototype.removeAll = function(documents) {
      var _this = this;
      if (documents) {
        documents.forEach(function(document2) {
          return _this.remove(document2);
        });
      } else if (arguments.length > 0) {
        throw new Error("Expected documents to be present. Omit the argument to remove all documents.");
      } else {
        this._index = new SearchableMap();
        this._documentCount = 0;
        this._documentIds = {};
        this._fieldLength = {};
        this._averageFieldLength = {};
        this._storedFields = {};
        this._nextId = 0;
      }
    };
    MiniSearch.prototype.search = function(queryString, searchOptions) {
      var _this = this;
      if (searchOptions === void 0) {
        searchOptions = {};
      }
      var _a = this._options, tokenize = _a.tokenize, processTerm = _a.processTerm, globalSearchOptions = _a.searchOptions;
      var options = __assign(__assign({tokenize, processTerm}, globalSearchOptions), searchOptions);
      var searchTokenize = options.tokenize, searchProcessTerm = options.processTerm;
      var terms = searchTokenize(queryString).map(function(term) {
        return searchProcessTerm(term);
      }).filter(function(term) {
        return !!term;
      });
      var queries = terms.map(termToQuery(options));
      var results = queries.map(function(query) {
        return _this.executeQuery(query, options);
      });
      var combinedResults = this.combineResults(results, options.combineWith);
      return Object.entries(combinedResults).reduce(function(results2, _a2) {
        var _b = __read(_a2, 2), docId = _b[0], _c = _b[1], score = _c.score, match = _c.match, terms2 = _c.terms;
        var result = {
          id: _this._documentIds[docId],
          terms: uniq(terms2),
          score,
          match
        };
        Object.assign(result, _this._storedFields[docId]);
        if (options.filter == null || options.filter(result)) {
          results2.push(result);
        }
        return results2;
      }, []).sort(function(_a2, _b) {
        var a = _a2.score;
        var b = _b.score;
        return a < b ? 1 : -1;
      });
    };
    MiniSearch.prototype.autoSuggest = function(queryString, options) {
      if (options === void 0) {
        options = {};
      }
      options = __assign(__assign({}, defaultAutoSuggestOptions), options);
      var suggestions = this.search(queryString, options).reduce(function(suggestions2, _a) {
        var score = _a.score, terms = _a.terms;
        var phrase = terms.join(" ");
        if (suggestions2[phrase] == null) {
          suggestions2[phrase] = {score, terms, count: 1};
        } else {
          suggestions2[phrase].score += score;
          suggestions2[phrase].count += 1;
        }
        return suggestions2;
      }, {});
      return Object.entries(suggestions).map(function(_a) {
        var _b = __read(_a, 2), suggestion = _b[0], _c = _b[1], score = _c.score, terms = _c.terms, count = _c.count;
        return {suggestion, terms, score: score / count};
      }).sort(function(_a, _b) {
        var a = _a.score;
        var b = _b.score;
        return a < b ? 1 : -1;
      });
    };
    Object.defineProperty(MiniSearch.prototype, "documentCount", {
      get: function() {
        return this._documentCount;
      },
      enumerable: false,
      configurable: true
    });
    MiniSearch.loadJSON = function(json, options) {
      if (options == null) {
        throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
      }
      return MiniSearch.loadJS(JSON.parse(json), options);
    };
    MiniSearch.getDefault = function(optionName) {
      if (defaultOptions.hasOwnProperty(optionName)) {
        return getOwnProperty(defaultOptions, optionName);
      } else {
        throw new Error('MiniSearch: unknown option "' + optionName + '"');
      }
    };
    MiniSearch.loadJS = function(js, options) {
      var index = js.index, documentCount = js.documentCount, nextId = js.nextId, documentIds = js.documentIds, fieldIds = js.fieldIds, fieldLength = js.fieldLength, averageFieldLength = js.averageFieldLength, storedFields = js.storedFields;
      var miniSearch = new MiniSearch(options);
      miniSearch._index = new SearchableMap(index._tree, index._prefix);
      miniSearch._documentCount = documentCount;
      miniSearch._nextId = nextId;
      miniSearch._documentIds = documentIds;
      miniSearch._fieldIds = fieldIds;
      miniSearch._fieldLength = fieldLength;
      miniSearch._averageFieldLength = averageFieldLength;
      miniSearch._fieldIds = fieldIds;
      miniSearch._storedFields = storedFields || {};
      return miniSearch;
    };
    MiniSearch.prototype.executeQuery = function(query, searchOptions) {
      var _this = this;
      var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
      var boosts = (options.fields || this._options.fields).reduce(function(boosts2, field) {
        var _a2;
        return __assign(__assign({}, boosts2), (_a2 = {}, _a2[field] = getOwnProperty(boosts2, field) || 1, _a2));
      }, options.boost || {});
      var boostDocument = options.boostDocument, weights = options.weights;
      var _a = __assign(__assign({}, defaultSearchOptions.weights), weights), fuzzyWeight = _a.fuzzy, prefixWeight = _a.prefix;
      var exactMatch = this.termResults(query.term, boosts, boostDocument, this._index.get(query.term));
      if (!query.fuzzy && !query.prefix) {
        return exactMatch;
      }
      var results = [exactMatch];
      if (query.prefix) {
        this._index.atPrefix(query.term).forEach(function(term, data) {
          var weightedDistance = 0.3 * (term.length - query.term.length) / term.length;
          results.push(_this.termResults(term, boosts, boostDocument, data, prefixWeight, weightedDistance));
        });
      }
      if (query.fuzzy) {
        var fuzzy = query.fuzzy === true ? 0.2 : query.fuzzy;
        var maxDistance = fuzzy < 1 ? Math.round(query.term.length * fuzzy) : fuzzy;
        Object.entries(this._index.fuzzyGet(query.term, maxDistance)).forEach(function(_a2) {
          var _b = __read(_a2, 2), term = _b[0], _c = __read(_b[1], 2), data = _c[0], distance = _c[1];
          var weightedDistance = distance / term.length;
          results.push(_this.termResults(term, boosts, boostDocument, data, fuzzyWeight, weightedDistance));
        });
      }
      return results.reduce(combinators[OR], {});
    };
    MiniSearch.prototype.combineResults = function(results, combineWith) {
      if (combineWith === void 0) {
        combineWith = OR;
      }
      if (results.length === 0) {
        return {};
      }
      var operator = combineWith.toLowerCase();
      return results.reduce(combinators[operator], null) || {};
    };
    MiniSearch.prototype.toJSON = function() {
      return {
        index: this._index,
        documentCount: this._documentCount,
        nextId: this._nextId,
        documentIds: this._documentIds,
        fieldIds: this._fieldIds,
        fieldLength: this._fieldLength,
        averageFieldLength: this._averageFieldLength,
        storedFields: this._storedFields
      };
    };
    MiniSearch.prototype.termResults = function(term, boosts, boostDocument, indexData, weight, editDistance) {
      var _this = this;
      if (editDistance === void 0) {
        editDistance = 0;
      }
      if (indexData == null) {
        return {};
      }
      return Object.entries(boosts).reduce(function(results, _a) {
        var _b = __read(_a, 2), field = _b[0], boost = _b[1];
        var fieldId = _this._fieldIds[field];
        var _c = indexData[fieldId] || {ds: {}}, df = _c.df, ds = _c.ds;
        Object.entries(ds).forEach(function(_a2) {
          var _b2 = __read(_a2, 2), documentId = _b2[0], tf = _b2[1];
          var docBoost = boostDocument ? boostDocument(_this._documentIds[documentId], term) : 1;
          if (!docBoost) {
            return;
          }
          var normalizedLength = _this._fieldLength[documentId][fieldId] / _this._averageFieldLength[fieldId];
          results[documentId] = results[documentId] || {score: 0, match: {}, terms: []};
          results[documentId].terms.push(term);
          results[documentId].match[term] = getOwnProperty(results[documentId].match, term) || [];
          results[documentId].score += docBoost * score(tf, df, _this._documentCount, normalizedLength, boost, editDistance);
          results[documentId].match[term].push(field);
        });
        return results;
      }, {});
    };
    MiniSearch.prototype.addTerm = function(fieldId, documentId, term) {
      this._index.update(term, function(indexData) {
        var _a;
        indexData = indexData || {};
        var fieldIndex = indexData[fieldId] || {df: 0, ds: {}};
        if (fieldIndex.ds[documentId] == null) {
          fieldIndex.df += 1;
        }
        fieldIndex.ds[documentId] = (fieldIndex.ds[documentId] || 0) + 1;
        return __assign(__assign({}, indexData), (_a = {}, _a[fieldId] = fieldIndex, _a));
      });
    };
    MiniSearch.prototype.removeTerm = function(fieldId, documentId, term) {
      var _this = this;
      if (!this._index.has(term)) {
        this.warnDocumentChanged(documentId, fieldId, term);
        return;
      }
      this._index.update(term, function(indexData) {
        var _a;
        var fieldIndex = indexData[fieldId];
        if (fieldIndex == null || fieldIndex.ds[documentId] == null) {
          _this.warnDocumentChanged(documentId, fieldId, term);
          return indexData;
        }
        if (fieldIndex.ds[documentId] <= 1) {
          if (fieldIndex.df <= 1) {
            delete indexData[fieldId];
            return indexData;
          }
          fieldIndex.df -= 1;
        }
        if (fieldIndex.ds[documentId] <= 1) {
          delete fieldIndex.ds[documentId];
          return indexData;
        }
        fieldIndex.ds[documentId] -= 1;
        return __assign(__assign({}, indexData), (_a = {}, _a[fieldId] = fieldIndex, _a));
      });
      if (Object.keys(this._index.get(term)).length === 0) {
        this._index.delete(term);
      }
    };
    MiniSearch.prototype.warnDocumentChanged = function(shortDocumentId, fieldId, term) {
      if (console == null || console.warn == null) {
        return;
      }
      var fieldName = Object.entries(this._fieldIds).find(function(_a) {
        var _b = __read(_a, 2);
        _b[0];
        var id = _b[1];
        return id === fieldId;
      })[0];
      console.warn("MiniSearch: document with ID " + this._documentIds[shortDocumentId] + ' has changed before removal: term "' + term + '" was not present in field "' + fieldName + '". Removing a document after it has changed can corrupt the index!');
    };
    MiniSearch.prototype.addDocumentId = function(documentId) {
      var shortDocumentId = this._nextId.toString(36);
      this._documentIds[shortDocumentId] = documentId;
      this._documentCount += 1;
      this._nextId += 1;
      return shortDocumentId;
    };
    MiniSearch.prototype.addFields = function(fields) {
      var _this = this;
      fields.forEach(function(field, i) {
        _this._fieldIds[field] = i;
      });
    };
    MiniSearch.prototype.addFieldLength = function(documentId, fieldId, count, length) {
      this._averageFieldLength[fieldId] = this._averageFieldLength[fieldId] || 0;
      var totalLength = this._averageFieldLength[fieldId] * count + length;
      this._fieldLength[documentId] = this._fieldLength[documentId] || {};
      this._fieldLength[documentId][fieldId] = length;
      this._averageFieldLength[fieldId] = totalLength / (count + 1);
    };
    MiniSearch.prototype.removeFieldLength = function(documentId, fieldId, count, length) {
      var totalLength = this._averageFieldLength[fieldId] * count - length;
      this._averageFieldLength[fieldId] = totalLength / (count - 1);
    };
    MiniSearch.prototype.saveStoredFields = function(documentId, doc) {
      var _this = this;
      var _a = this._options, storeFields = _a.storeFields, extractField = _a.extractField;
      if (storeFields == null || storeFields.length === 0) {
        return;
      }
      this._storedFields[documentId] = this._storedFields[documentId] || {};
      storeFields.forEach(function(fieldName) {
        var fieldValue = extractField(doc, fieldName);
        if (fieldValue === void 0) {
          return;
        }
        _this._storedFields[documentId][fieldName] = fieldValue;
      });
    };
    return MiniSearch;
  }();
  var getOwnProperty = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : void 0;
  };
  var combinators = (_a = {}, _a[OR] = function(a, b) {
    return Object.entries(b).reduce(function(combined, _a) {
      var _b;
      var _c = __read(_a, 2), documentId = _c[0], _d = _c[1], score = _d.score, match = _d.match, terms = _d.terms;
      if (combined[documentId] == null) {
        combined[documentId] = {score, match, terms};
      } else {
        combined[documentId].score += score;
        combined[documentId].score *= 1.5;
        (_b = combined[documentId].terms).push.apply(_b, __spreadArray([], __read(terms)));
        Object.assign(combined[documentId].match, match);
      }
      return combined;
    }, a || {});
  }, _a[AND] = function(a, b) {
    if (a == null) {
      return b;
    }
    return Object.entries(b).reduce(function(combined, _a) {
      var _b = __read(_a, 2), documentId = _b[0], _c = _b[1], score = _c.score, match = _c.match, terms = _c.terms;
      if (a[documentId] === void 0) {
        return combined;
      }
      combined[documentId] = combined[documentId] || {};
      combined[documentId].score = a[documentId].score + score;
      combined[documentId].match = __assign(__assign({}, a[documentId].match), match);
      combined[documentId].terms = __spreadArray(__spreadArray([], __read(a[documentId].terms)), __read(terms));
      return combined;
    }, {});
  }, _a);
  var tfIdf = function(tf, df, n) {
    return tf * Math.log(n / df);
  };
  var score = function(termFrequency, documentFrequency, documentCount, normalizedLength, boost, editDistance) {
    var weight = boost / (1 + 0.333 * boost * editDistance);
    return weight * tfIdf(termFrequency, documentFrequency, documentCount) / normalizedLength;
  };
  var termToQuery = function(options) {
    return function(term, i, terms) {
      var fuzzy = typeof options.fuzzy === "function" ? options.fuzzy(term, i, terms) : options.fuzzy || false;
      var prefix = typeof options.prefix === "function" ? options.prefix(term, i, terms) : options.prefix === true;
      return {term, fuzzy, prefix};
    };
  };
  var uniq = function(array) {
    return array.filter(function(element, i, array2) {
      return array2.indexOf(element) === i;
    });
  };
  var defaultOptions = {
    idField: "id",
    extractField: function(document2, fieldName) {
      return document2[fieldName];
    },
    tokenize: function(text, fieldName) {
      return text.split(SPACE_OR_PUNCTUATION);
    },
    processTerm: function(term, fieldName) {
      return term.toLowerCase();
    },
    fields: void 0,
    searchOptions: void 0,
    storeFields: []
  };
  var defaultSearchOptions = {
    combineWith: OR,
    prefix: false,
    fuzzy: false,
    boost: {},
    weights: {fuzzy: 0.9, prefix: 0.75}
  };
  var defaultAutoSuggestOptions = {
    prefix: function(term, i, terms) {
      return i === terms.length - 1;
    }
  };
  var SPACE_OR_PUNCTUATION = /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;
  function sameItems(...args) {
    var _a, _b, _c;
    const arrays = args.filter((arg) => Array.isArray(arg));
    const settings = Object.assign({references: true, hash: true}, (_a = args.filter((arg) => plainObject$2(arg))[0]) !== null && _a !== void 0 ? _a : {});
    if (arrays.length > 2) {
      let newArray = arrays[0];
      arrays.forEach((currentArray) => {
        newArray = sameItems(newArray, currentArray, settings);
      });
      return unique$2(newArray);
    } else {
      const array1 = (_b = arrays[0]) !== null && _b !== void 0 ? _b : [], array2 = (_c = arrays[1]) !== null && _c !== void 0 ? _c : [];
      const sameArray = [];
      array1.forEach((array1Item) => {
        let array1ItemHash = array1Item;
        if (typeof array1Item !== "string" && settings.hash) {
          array1ItemHash = __md5$2.encrypt(array1Item);
        }
        array2.forEach((array2Item) => {
          let array2ItemHash = array2Item;
          if (typeof array2Item !== "string" && settings.hash) {
            array2ItemHash = __md5$2.encrypt(array2Item);
            if (array1ItemHash === array2ItemHash) {
              sameArray.push(array1Item);
              return;
            }
          } else if (array1Item === array2Item) {
            sameArray.push(array1Item);
            return;
          }
        });
      });
      return unique$2(sameArray);
    }
  }
  function onScrollEnd($elm, callback, settings) {
    const finalSettings = Object.assign({offset: 20, once: false, times: -1}, settings !== null && settings !== void 0 ? settings : {});
    let isBody = false;
    let $scrollListenedElm = $elm;
    let $scrollHeightElm = $elm;
    if ($elm === window.document.body) {
      isBody = true;
      $scrollListenedElm = document;
      $scrollHeightElm = window.document.body;
    } else if ($elm === window.document) {
      isBody = true;
      $elm = window.document.body;
      $scrollHeightElm = window.document.body;
    }
    let active = true, count = 0;
    const internalCallback = (e) => {
      let fullHeight, viewportHeight, scrollTop;
      if (isBody) {
        viewportHeight = window.innerHeight;
        scrollTop = $scrollHeightElm.scrollTop;
        fullHeight = Math.max(window.document.body.scrollHeight, window.document.documentElement.scrollHeight, window.document.body.offsetHeight, window.document.documentElement.offsetHeight, window.document.body.clientHeight, window.document.documentElement.clientHeight);
      } else {
        viewportHeight = $scrollHeightElm.scrollHeight;
        scrollTop = $scrollHeightElm.scrollTop;
        fullHeight = $scrollHeightElm.scrollHeight;
      }
      if (active && scrollTop + viewportHeight >= fullHeight - finalSettings.offset) {
        callback();
        count++;
        if (finalSettings.once) {
          $scrollListenedElm.removeEventListener("scroll", internalCallback);
          active = false;
        } else if (finalSettings.times > 0 && count >= finalSettings.times) {
          $scrollListenedElm.removeEventListener("scroll", internalCallback);
          active = false;
        }
      } else if ($scrollHeightElm.offsetHeight + $scrollHeightElm.scrollTop < $scrollHeightElm.scrollHeight - finalSettings.offset) {
        active = true;
      }
    };
    $scrollListenedElm.addEventListener("scroll", internalCallback);
  }
  var __awaiter$4 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function loadState() {
    var _a;
    return __awaiter$4(this, void 0, void 0, function* () {
      const state = JSON.parse((_a = window.localStorage.getItem("coffeekrakenio")) !== null && _a !== void 0 ? _a : "{}");
      return state;
    });
  }
  function getCurrentVersion() {
    return __awaiter$4(this, void 0, void 0, function* () {
      const docmapJson = yield loadDocmap();
      let version;
      if (document.location.hostname.split(".").length >= 4) {
        version = document.location.hostname.split(".").slice(0, 3).join(".").replace(/^v/, "");
      }
      return version !== null && version !== void 0 ? version : docmapJson.snapshots.slice(-1)[0];
    });
  }
  function setState(stateObj) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const state = yield loadState();
      const newState = deepMerge$2(state, stateObj);
      window.localStorage.setItem("coffeekrakenio", JSON.stringify(newState));
    });
  }
  let _docmap, _docmapPromise;
  function loadDocmap() {
    var _a;
    return __awaiter$4(this, void 0, void 0, function* () {
      const state = yield loadState();
      if (_docmap)
        return _docmap;
      if (_docmapPromise)
        return (yield _docmapPromise).data;
      const request = new SRequest({
        url: `/api/docmap?v=${(_a = state.version) !== null && _a !== void 0 ? _a : ""}`,
        method: "GET"
      });
      const promise = request.send();
      _docmapPromise = promise;
      _docmap = (yield promise).data;
      return _docmap;
    });
  }
  var __decorate$1 = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __awaiter$3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class DocNav extends LitElement {
    constructor() {
      super();
      this.maxItems = 10;
      this._maxItemsToDisplay = 10;
      this._filteredItems = {};
      this._docmap = {};
      this._saved = {
        search: "",
        platforms: [],
        types: [],
        statuses: []
      };
      this._striptags = striptags;
      this._displayItemsCount = 0;
      this._searchTimeout = 0;
      (() => __awaiter$3(this, void 0, void 0, function* () {
        const docmapJson = yield loadDocmap();
        this._docmap = docmapJson;
        this._restoreState();
        const queryStringObj = queryStringToObject(document.location.search);
        if (queryStringObj.search) {
          this._saved.search = queryStringObj.search;
        }
        this._filterItems();
        yield wait$1();
        onScrollEnd(document.body, () => {
          this._maxItemsToDisplay += this.maxItems;
          this._filterItems({
            reset: false
          });
        });
      }))();
    }
    get availablePlatforms() {
      if (!this._docmap.map)
        return [];
      const availablePlatforms = [];
      Object.keys(this._docmap.map).forEach((namespace) => {
        const docmapObj = this._docmap.map[namespace];
        if (!docmapObj.platform)
          return;
        docmapObj.platform.forEach((platform) => {
          if (availablePlatforms.indexOf(platform.name) === -1)
            availablePlatforms.push(platform.name);
        });
      });
      return availablePlatforms;
    }
    get availableTypes() {
      if (!this._docmap.map)
        return [];
      const availableTypes = [];
      Object.keys(this._docmap.map).forEach((namespace) => {
        const docmapObj = this._docmap.map[namespace];
        if (!docmapObj.type)
          return;
        if (availableTypes.indexOf(docmapObj.type) === -1)
          availableTypes.push(docmapObj.type);
      });
      return availableTypes;
    }
    get availableStatuses() {
      if (!this._docmap.map)
        return [];
      const availableStatus = [];
      Object.keys(this._docmap.map).forEach((namespace) => {
        const docmapObj = this._docmap.map[namespace];
        if (!docmapObj.status)
          return;
        if (availableStatus.indexOf(docmapObj.status) === -1)
          availableStatus.push(docmapObj.status);
      });
      return availableStatus;
    }
    _filterItems(settings = {}) {
      settings = Object.assign({reset: true}, settings);
      if (settings.reset)
        this._maxItemsToDisplay = this.maxItems;
      this._displayItemsCount = 0;
      let items = Object.values(this._docmap.map).map((i) => {
        i.id = i.name;
        return i;
      });
      if (this._saved.search) {
        let miniSearch = new MiniSearch({
          fields: ["name", "namespace", "description", "since", "type", "status"],
          storeFields: Object.keys(items[0])
        });
        miniSearch.addAll(items);
        items = miniSearch.search(this._saved.search);
      }
      let newItems = [];
      for (let i = 0; i < items.length; i++) {
        const docmapObj = items[i];
        if (this._displayItemsCount >= this._maxItemsToDisplay)
          break;
        if (this._saved.platforms.length) {
          if (!docmapObj.platform)
            continue;
          const samePlatforms = sameItems(docmapObj.platform.map((l) => l.name), this._saved.platforms);
          if (!samePlatforms.length)
            continue;
        }
        if (this._saved.types.length) {
          if (this._saved.types.indexOf(docmapObj.type) === -1)
            continue;
        }
        if (this._saved.statuses.length) {
          if (this._saved.statuses.indexOf(docmapObj.status) === -1)
            continue;
        }
        this._displayItemsCount++;
        newItems.push(docmapObj);
      }
      this._filteredItems = newItems;
    }
    _search(e) {
      clearTimeout(this._searchTimeout);
      this._searchTimeout = setTimeout(() => {
        this._saved = Object.assign(Object.assign({}, this._saved), {search: e.target.value});
        this._filterItems();
        this._saveState();
      }, 300);
    }
    _togglePlatform(platform) {
      const idx = this._saved.platforms.indexOf(platform);
      if (idx !== -1) {
        this._saved.platforms.splice(idx, 1);
        this._saved = Object.assign(Object.assign({}, this._saved), {platforms: this._saved.platforms});
      } else {
        this._saved = Object.assign(Object.assign({}, this._saved), {platforms: [...this._saved.platforms, platform]});
      }
      this._filterItems();
      this._saveState();
    }
    _toggleType(type) {
      const idx = this._saved.types.indexOf(type);
      if (idx !== -1) {
        this._saved.types.splice(idx, 1);
        this._saved = Object.assign(Object.assign({}, this._saved), {types: this._saved.types});
      } else {
        this._saved = Object.assign(Object.assign({}, this._saved), {types: [...this._saved.types, type]});
      }
      this._filterItems();
      this._saveState();
    }
    _toggleStatus(status) {
      const idx = this._saved.statuses.indexOf(status);
      if (idx !== -1) {
        this._saved.statuses.splice(idx, 1);
        this._saved = Object.assign(Object.assign({}, this._saved), {statuses: this._saved.statuses});
      } else {
        this._saved = Object.assign(Object.assign({}, this._saved), {statuses: [...this._saved.statuses, status]});
      }
      this._filterItems();
      this._saveState();
    }
    _saveState() {
      setState({
        docList: this._saved
      });
    }
    _restoreState() {
      return __awaiter$3(this, void 0, void 0, function* () {
        const state = yield loadState();
        if (!state.docList)
          return;
        this._saved = state.docList;
      });
    }
    createRenderRoot() {
      return this;
    }
    render() {
      const tpl = html`
            <div class="s-grid:12222">
                <nav class="__nav">
                
                    <form name="doc">

                        <fieldset class="__nav-search s-mb:30 s-pr:20 s-pt:20">
                            <input type="text" class="s-input s-width:100" name="search" placeholder="Search doc" value="${this._saved.search}" @keyup="${this._search}" />
                        </fieldset>

                        <fieldset class="__nav-platform s-mb:30">
                            <legend class="s-typo:h6 s-mb:10">
                                Platform
                            </legend>
                            <dl class="s-list s-bg:even">  
                                ${this.availablePlatforms.map((platform) => {
        var _a;
        return html`
                                    <dt class="s-flex s-font:40 s-p:10 s-bg:ui-surface">
                                        <label class="s-flex-item:grow" for="platform-${platform}">
                                            ${platform}
                                        </label>
                                        <label class="s-switch:accent" for="platform-${platform}">
                                            <input name="platform-${platform}" type="checkbox" id="platform-${platform}" @change="${() => this._togglePlatform(platform)}" ?checked="${((_a = this._saved.platforms) !== null && _a !== void 0 ? _a : []).indexOf(platform) !== -1}">
                                            <div class="s-switch-handler"></div>
                                        </label>
                                    </dt>
                                `;
      })}
                            </dl>
                        </fieldset>

                        <fieldset class="__nav-type s-mb:30">
                            <legend class="s-typo:h6 s-mb:10">
                                Type
                            </legend>
                            <dl class="s-list s-bg:even">
                                ${this.availableTypes.map((type) => {
        var _a;
        return html`
                                    <dt class="s-flex s-font:40 s-p:10 s-bg:ui-surface">
                                        <label class="s-flex-item:grow" for="type-${type}">
                                            ${type}
                                        </label>
                                        <label class="s-switch:accent" for="type-${type}">
                                            <input name="type-${type}" type="checkbox" id="type-${type}" @change="${() => this._toggleType(type)}" ?checked="${((_a = this._saved.types) !== null && _a !== void 0 ? _a : []).indexOf(type) !== -1}">
                                            <div class="s-switch-handler"></div>
                                        </label>
                                    </dt>
                                `;
      })}
                            </dl>
                        </fieldset>

                        <fieldset class="__nav-status s-mb:30">
                            <legend class="s-typo:h6 s-mb:10">
                                Status
                            </legend>
                            <dl class="s-list s-bg:even">
                                ${this.availableStatuses.map((status) => {
        var _a;
        return html`
                                    <dt class="s-flex s-font:40 s-p:10 s-bg:ui-surface">
                                        <label class="s-flex-item:grow" for="status-${status}">
                                            ${status}
                                        </label>
                                        <label class="s-switch:accent" for="status-${status}">
                                            <input name="status-${status}" type="checkbox" id="status-${status}" @change="${() => this._toggleStatus(status)}" ?checked="${((_a = this._saved.statuses) !== null && _a !== void 0 ? _a : []).indexOf(status) !== -1}">
                                            <div class="s-switch-handler"></div>
                                        </label>
                                    </dt>
                                `;
      })}
                            </dl>
                        </fieldset>

                    </form>
                    

                </nav>
                <section class="__list">
                    ${Object.values(this._filteredItems).map((item) => html`
                        <div class="__list-item">
                            <div class="s-p:50">
                                <div class="">
                                    <div class="s-flex">
                                        <div class="s-flex-item:grow">
                                            <div>
                                                ${item.platform.map((platform) => html`
                                                    <i class="s-platform:${platform.name} s-font:80 s-mb:30 s-mr:10"></i>
                                                `)}
                                            </div>
                                            <h4 class="s-font:title s-font:60 s-color:accent s-mb:10 s-flex-item:grow">
                                                <a href="/doc/api/${this._striptags(item.namespace)}.${this._striptags(item.name)}">
                                                    ${item.name}
                                                </a>
                                            </h4>
                                        </div>
                                        <div>
                                            <div class="s-font:40">
                                                <span class="s-font:30">Since <span class="s-color:complementary">${item.since}</span></span>
                                                &nbsp;
                                                <span class="s-badge:pill:${item.status}">${item.status}</span>
                                            </div>
                                        </div>
                                    </div>
                                    <h5 class="s-color:complementary s-font:40 s-mb:30">${item.namespace}</h5>
                                    <p class="s-typo:p s-mb:30">${item.description}</p>
                                </div>
                                ${item.example && item.example.length ? html`
                                    <div class="__code">
                                        <s-code-example default-style style="max-width:100%;" class="s-depth:50 s-flex-item:grow:shrink">
                                            <textarea lang="${item.example[0].language}">
                                                ${item.example[0].code}                    
                                            </textarea>
                                        </s-code-example>
                                    </div>
                                ` : ""}
                            </div>
                        </div>
                    `)}
                </section>
            </div>
        `;
      return tpl;
    }
  }
  __decorate$1([
    property()
  ], DocNav.prototype, "_maxItemsToDisplay", void 0);
  __decorate$1([
    property()
  ], DocNav.prototype, "_filteredItems", void 0);
  __decorate$1([
    property()
  ], DocNav.prototype, "_docmap", void 0);
  __decorate$1([
    property()
  ], DocNav.prototype, "_saved", void 0);
  function webcomponent$1(tagName = "doc-nav") {
    customElements.define(tagName, DocNav);
  }
  var __decorate = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __awaiter$2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class VersionSelector extends LitElement {
    constructor() {
      super();
      this._versions = [];
      (() => __awaiter$2(this, void 0, void 0, function* () {
        const docmapJson = yield loadDocmap();
        this._versions = docmapJson.snapshots || [];
        this._currentVersion = yield getCurrentVersion();
      }))();
    }
    createRenderRoot() {
      return this;
    }
    _change(e) {
      setTimeout(() => {
        let newLocation = document.location.href;
        if (document.location.href.match(/^https?:\/\/v[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\./)) {
          newLocation = document.location.href.replace(/^(https?:\/\/v)[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.(.*)/, `$1${e.target.value}.$2`);
        } else {
          newLocation = document.location.href.replace(/^(https?:\/\/)(.*)/, `$1v${e.target.value}.$2`);
        }
        document.location = newLocation;
      });
    }
    render() {
      return html`
            <label class="s-select">
                <select @change="${this._change}">
                    ${this._versions.map((snap) => html`
                        <option ?selected="${this._currentVersion === snap}" value="${snap}">${snap}</option>   
                    `)}
                </select>
            </label>
        `;
    }
  }
  __decorate([
    property()
  ], VersionSelector.prototype, "_currentVersion", void 0);
  __decorate([
    property()
  ], VersionSelector.prototype, "_versions", void 0);
  function webcomponent(tagName = "version-selector") {
    customElements.define(tagName, VersionSelector);
  }
  var requiresPort = function required(port, protocol) {
    protocol = protocol.split(":")[0];
    port = +port;
    if (!port)
      return false;
    switch (protocol) {
      case "http":
      case "ws":
        return port !== 80;
      case "https":
      case "wss":
        return port !== 443;
      case "ftp":
        return port !== 21;
      case "gopher":
        return port !== 70;
      case "file":
        return false;
    }
    return port !== 0;
  };
  var querystringify$1 = {};
  var has = Object.prototype.hasOwnProperty, undef;
  function decode(input) {
    try {
      return decodeURIComponent(input.replace(/\+/g, " "));
    } catch (e) {
      return null;
    }
  }
  function encode(input) {
    try {
      return encodeURIComponent(input);
    } catch (e) {
      return null;
    }
  }
  function querystring(query) {
    var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
    while (part = parser.exec(query)) {
      var key = decode(part[1]), value = decode(part[2]);
      if (key === null || value === null || key in result)
        continue;
      result[key] = value;
    }
    return result;
  }
  function querystringify(obj, prefix) {
    prefix = prefix || "";
    var pairs = [], value, key;
    if (typeof prefix !== "string")
      prefix = "?";
    for (key in obj) {
      if (has.call(obj, key)) {
        value = obj[key];
        if (!value && (value === null || value === undef || isNaN(value))) {
          value = "";
        }
        key = encode(key);
        value = encode(value);
        if (key === null || value === null)
          continue;
        pairs.push(key + "=" + value);
      }
    }
    return pairs.length ? prefix + pairs.join("&") : "";
  }
  querystringify$1.stringify = querystringify;
  querystringify$1.parse = querystring;
  var required = requiresPort, qs = querystringify$1, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/, protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i, whitespace = "[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]", left = new RegExp("^" + whitespace + "+");
  function trimLeft(str) {
    return (str ? str : "").toString().replace(left, "");
  }
  var rules = [
    ["#", "hash"],
    ["?", "query"],
    function sanitize(address) {
      return address.replace("\\", "/");
    },
    ["/", "pathname"],
    ["@", "auth", 1],
    [NaN, "host", void 0, 1, 1],
    [/:(\d+)$/, "port", void 0, 1],
    [NaN, "hostname", void 0, 1, 1]
  ];
  var ignore = {hash: 1, query: 1};
  function lolcation(loc) {
    var globalVar;
    if (typeof window !== "undefined")
      globalVar = window;
    else if (typeof commonjsGlobal$2 !== "undefined")
      globalVar = commonjsGlobal$2;
    else if (typeof self !== "undefined")
      globalVar = self;
    else
      globalVar = {};
    var location = globalVar.location || {};
    loc = loc || location;
    var finaldestination = {}, type = typeof loc, key;
    if (loc.protocol === "blob:") {
      finaldestination = new Url(unescape(loc.pathname), {});
    } else if (type === "string") {
      finaldestination = new Url(loc, {});
      for (key in ignore)
        delete finaldestination[key];
    } else if (type === "object") {
      for (key in loc) {
        if (key in ignore)
          continue;
        finaldestination[key] = loc[key];
      }
      if (finaldestination.slashes === void 0) {
        finaldestination.slashes = slashes.test(loc.href);
      }
    }
    return finaldestination;
  }
  function extractProtocol(address) {
    address = trimLeft(address);
    var match = protocolre.exec(address), protocol = match[1] ? match[1].toLowerCase() : "", slashes = !!(match[2] && match[2].length >= 2), rest = match[2] && match[2].length === 1 ? "/" + match[3] : match[3];
    return {
      protocol,
      slashes,
      rest
    };
  }
  function resolve(relative, base) {
    if (relative === "")
      return base;
    var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
    while (i--) {
      if (path[i] === ".") {
        path.splice(i, 1);
      } else if (path[i] === "..") {
        path.splice(i, 1);
        up++;
      } else if (up) {
        if (i === 0)
          unshift = true;
        path.splice(i, 1);
        up--;
      }
    }
    if (unshift)
      path.unshift("");
    if (last === "." || last === "..")
      path.push("");
    return path.join("/");
  }
  function Url(address, location, parser) {
    address = trimLeft(address);
    if (!(this instanceof Url)) {
      return new Url(address, location, parser);
    }
    var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
    if (type !== "object" && type !== "string") {
      parser = location;
      location = null;
    }
    if (parser && typeof parser !== "function")
      parser = qs.parse;
    location = lolcation(location);
    extracted = extractProtocol(address || "");
    relative = !extracted.protocol && !extracted.slashes;
    url.slashes = extracted.slashes || relative && location.slashes;
    url.protocol = extracted.protocol || location.protocol || "";
    address = extracted.rest;
    if (!extracted.slashes)
      instructions[3] = [/(.*)/, "pathname"];
    for (; i < instructions.length; i++) {
      instruction = instructions[i];
      if (typeof instruction === "function") {
        address = instruction(address);
        continue;
      }
      parse = instruction[0];
      key = instruction[1];
      if (parse !== parse) {
        url[key] = address;
      } else if (typeof parse === "string") {
        if (~(index = address.indexOf(parse))) {
          if (typeof instruction[2] === "number") {
            url[key] = address.slice(0, index);
            address = address.slice(index + instruction[2]);
          } else {
            url[key] = address.slice(index);
            address = address.slice(0, index);
          }
        }
      } else if (index = parse.exec(address)) {
        url[key] = index[1];
        address = address.slice(0, index.index);
      }
      url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
      if (instruction[4])
        url[key] = url[key].toLowerCase();
    }
    if (parser)
      url.query = parser(url.query);
    if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
      url.pathname = resolve(url.pathname, location.pathname);
    }
    if (url.pathname.charAt(0) !== "/" && url.hostname) {
      url.pathname = "/" + url.pathname;
    }
    if (!required(url.port, url.protocol)) {
      url.host = url.hostname;
      url.port = "";
    }
    url.username = url.password = "";
    if (url.auth) {
      instruction = url.auth.split(":");
      url.username = instruction[0] || "";
      url.password = instruction[1] || "";
    }
    url.origin = url.protocol && url.host && url.protocol !== "file:" ? url.protocol + "//" + url.host : "null";
    url.href = url.toString();
  }
  function set(part, value, fn) {
    var url = this;
    switch (part) {
      case "query":
        if (typeof value === "string" && value.length) {
          value = (fn || qs.parse)(value);
        }
        url[part] = value;
        break;
      case "port":
        url[part] = value;
        if (!required(value, url.protocol)) {
          url.host = url.hostname;
          url[part] = "";
        } else if (value) {
          url.host = url.hostname + ":" + value;
        }
        break;
      case "hostname":
        url[part] = value;
        if (url.port)
          value += ":" + url.port;
        url.host = value;
        break;
      case "host":
        url[part] = value;
        if (/:\d+$/.test(value)) {
          value = value.split(":");
          url.port = value.pop();
          url.hostname = value.join(":");
        } else {
          url.hostname = value;
          url.port = "";
        }
        break;
      case "protocol":
        url.protocol = value.toLowerCase();
        url.slashes = !fn;
        break;
      case "pathname":
      case "hash":
        if (value) {
          var char = part === "pathname" ? "/" : "#";
          url[part] = value.charAt(0) !== char ? char + value : value;
        } else {
          url[part] = value;
        }
        break;
      default:
        url[part] = value;
    }
    for (var i = 0; i < rules.length; i++) {
      var ins = rules[i];
      if (ins[4])
        url[ins[1]] = url[ins[1]].toLowerCase();
    }
    url.origin = url.protocol && url.host && url.protocol !== "file:" ? url.protocol + "//" + url.host : "null";
    url.href = url.toString();
    return url;
  }
  function toString(stringify) {
    if (!stringify || typeof stringify !== "function")
      stringify = qs.stringify;
    var query, url = this, protocol = url.protocol;
    if (protocol && protocol.charAt(protocol.length - 1) !== ":")
      protocol += ":";
    var result = protocol + (url.slashes ? "//" : "");
    if (url.username) {
      result += url.username;
      if (url.password)
        result += ":" + url.password;
      result += "@";
    }
    result += url.host + url.pathname;
    query = typeof url.query === "object" ? stringify(url.query) : url.query;
    if (query)
      result += query.charAt(0) !== "?" ? "?" + query : query;
    if (url.hash)
      result += url.hash;
    return result;
  }
  Url.prototype = {set, toString};
  Url.extractProtocol = extractProtocol;
  Url.location = lolcation;
  Url.trimLeft = trimLeft;
  Url.qs = qs;
  var urlParse = Url;
  function ease(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
  let isUserScrolling = false;
  let userScrollingTimeout;
  let isScrollingHappening = false;
  document.addEventListener("mousewheel", (e) => {
    if (!isScrollingHappening)
      return;
    isUserScrolling = true;
    clearTimeout(userScrollingTimeout);
    userScrollingTimeout = setTimeout(() => {
      isUserScrolling = false;
    }, 200);
  });
  function scrollTo(target, settings = {}) {
    return new Promise((resolve, reject) => {
      settings = Object.assign({duration: 500, easing: ease, offset: 0, align: "top", onFinish: null}, settings);
      const docElem = document.documentElement;
      const windowHeight = window.innerHeight;
      const maxScroll = docElem.scrollHeight - windowHeight;
      const currentY = window.pageYOffset;
      isScrollingHappening = true;
      let targetY = currentY;
      const elementBounds = isNaN(target) ? target.getBoundingClientRect() : 0;
      if (settings.align === "center") {
        targetY += elementBounds.top + elementBounds.height / 2;
        targetY -= windowHeight / 2;
        targetY -= settings.offset;
      } else if (settings.align === "bottom") {
        targetY += elementBounds.bottom;
        targetY -= windowHeight;
        targetY += settings.offset;
      } else {
        targetY += elementBounds.top;
        targetY -= settings.offset;
      }
      targetY = Math.max(Math.min(maxScroll, targetY), 0);
      const deltaY = targetY - currentY;
      const obj = {
        targetY,
        deltaY,
        duration: settings.duration,
        easing: settings.easing,
        onFinish() {
          settings.onFinish && settings.onFinish();
          resolve();
        },
        startTime: Date.now(),
        lastY: currentY,
        step: scrollTo.step
      };
      requestAnimationFrame(obj.step.bind(obj));
    });
  }
  scrollTo.step = function() {
    if (this.lastY !== window.pageYOffset && this.onFinish) {
      isScrollingHappening = false;
      this.onFinish();
      return;
    }
    const t = Math.min((Date.now() - this.startTime) / this.duration, 1);
    const y = this.targetY - (1 - this.easing(t)) * this.deltaY;
    window.scrollTo(window.scrollX, y);
    if (t !== 1 && !isUserScrolling) {
      this.lastY = window.pageYOffset;
      requestAnimationFrame(this.step.bind(this));
    } else {
      isScrollingHappening = false;
      if (this.onFinish)
        this.onFinish();
    }
  };
  function smoothScrollOnAnchorLinks(settings = {}) {
    settings = deepMerge$2({
      scroll: {},
      checkPathNames: true
    }, settings);
    querySelectorLive('a:not([is])[href*="#"]', ($link) => {
      $link.addEventListener("click", (e) => {
        const linkUrl = urlParse($link.getAttribute("href"));
        const currentUrl = urlParse();
        if (!linkUrl.hash || linkUrl.hash === "#")
          return;
        if (settings.checkPathNames && currentUrl.pathname !== linkUrl.pathname)
          return;
        const $target = document.querySelector(linkUrl.hash);
        if (!$target)
          return;
        e.preventDefault();
        history.pushState({}, null, linkUrl.hash);
        scrollTo($target, settings.scroll);
      });
    });
  }
  function scrollToLocationHash(settings = {}) {
    settings = deepMerge$2({
      scroll: {}
    }, settings);
    const hash = document.location.hash;
    if (!hash)
      return;
    const targetElm = document.querySelector(hash);
    if (!targetElm)
      return;
    if ("scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }
    return scrollTo(targetElm, settings.scroll);
  }
  function smoothScrollOnPageLoad(settings = {}) {
    settings = deepMerge$2({
      scroll: {}
    }, settings);
    scrollToLocationHash(settings);
  }
  function smoothScrollOnHashChange(settings = {}) {
    settings = deepMerge$2({
      scroll: {}
    }, settings);
    window.addEventListener("hashchange", (e) => {
      scrollToLocationHash(settings);
    });
  }
  function smoothScroll(settings = {}) {
    settings = deepMerge$2({
      scroll: {}
    }, settings);
    smoothScrollOnPageLoad(settings);
    smoothScrollOnAnchorLinks(settings);
    smoothScrollOnHashChange(settings);
  }
  function linksStateAttributes(settings = {}) {
    settings = deepMerge$2({}, settings);
    function handleLink($linkElm) {
      if ($linkElm.getAttribute("href") === document.location.pathname) {
        $linkElm.setAttribute("actual", true);
      } else if ($linkElm.getAttribute("href").startsWith(document.location.pathname)) {
        $linkElm.removeAttribute("actual");
        $linkElm.setAttribute("actual-child", true);
      } else {
        $linkElm.removeAttribute("actual");
        $linkElm.removeAttribute("actual-child");
      }
    }
    querySelectorLive(`[href]`, ($linkElm) => {
      handleLink($linkElm);
    });
    window.addEventListener("locationchange", () => {
      Array.from(document.querySelectorAll("[href]")).forEach(($linkElm) => {
        handleLink($linkElm);
      });
    });
  }
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse('{"ENVIRONMENT":"development"}');
  webcomponent$1();
  webcomponent();
  SComponentUtils.setDefaultProps("*", {
    mountWhen: "inViewport"
  });
  SComponentUtils.setDefaultProps("s-code-example", {
    toolbarPosition: "nav",
    defaultStyle: true,
    adoptStyles: ["main"],
    defaultStyleClasses: {
      main: "s-tabs"
    }
  });
  webcomponent$2();
  smoothScroll({
    scroll: {
      offset: 188
    }
  });
  linksStateAttributes();
  document.addEventListener("scroll", (e) => {
    if (document.body.scrollTop >= 10) {
      document.body.classList.add("scrolled");
    } else {
      document.body.classList.remove("scrolled");
    }
  });
  expandPleasantCssClassnamesLive();
  function sugar(dotPath) {
    return "something";
  }
  console.log("JS");
  var lib = {exports: {}};
  var fs$j = {};
  var universalify$1 = {};
  universalify$1.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve(res));
        });
      }
    }, "name", {value: fn.name});
  };
  universalify$1.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else
        fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
    }, "name", {value: fn.name});
  };
  var __fs$1 = new Proxy({}, {
    get() {
      throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_fs = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __fs$1});
  var require$$2$2 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_fs);
  var __viteBrowserExternal_constants = new Proxy({}, {
    get() {
      throw new Error('Module "constants" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_constants$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_constants});
  var require$$0$3 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_constants$1);
  var constants = require$$0$3;
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var polyfills$1 = patch$1;
  function patch$1(fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs);
    }
    if (!fs.lutimes) {
      patchLutimes(fs);
    }
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    if (!fs.lchmod) {
      fs.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchmodSync = function() {
      };
    }
    if (!fs.lchown) {
      fs.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs.rename = function(fs$rename) {
        return function(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        };
      }(fs.rename);
    }
    fs.read = function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read);
    fs.readSync = function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs.readSync);
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs2.fchmod(fd, mode, function(err2) {
            fs2.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs2.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs2.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs2.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs2.lutimes = function(path, at, mt, cb) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs2.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      } else {
        fs2.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
  var __viteBrowserExternal_stream = new Proxy({}, {
    get() {
      throw new Error('Module "stream" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_stream$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_stream});
  var require$$0$2 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_stream$1);
  var Stream = require$$0$2.Stream;
  var legacyStreams = legacy$1;
  function legacy$1(fs) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
  var clone_1$1 = clone$2;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone$2(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = {__proto__: getPrototypeOf(obj)};
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
  var __viteBrowserExternal_util = new Proxy({}, {
    get() {
      throw new Error('Module "util" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_util$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_util});
  var require$$1 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_util$1);
  var __viteBrowserExternal_assert = new Proxy({}, {
    get() {
      throw new Error('Module "assert" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_assert$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_assert});
  var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_assert$1);
  var fs$i = require$$2$2;
  var polyfills = polyfills$1;
  var legacy = legacyStreams;
  var clone$1 = clone_1$1;
  var util$2 = require$$1;
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop$2() {
  }
  function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue;
      }
    });
  }
  var debug = noop$2;
  if (util$2.debuglog)
    debug = util$2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(""))
    debug = function() {
      var m = util$2.format.apply(util$2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs$i[gracefulQueue]) {
    var queue = commonjsGlobal$2[gracefulQueue] || [];
    publishQueue(fs$i, queue);
    fs$i.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs$i, fd, function(err) {
          if (!err) {
            retry();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs$i.close);
    fs$i.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs$i, arguments);
        retry();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs$i.closeSync);
    if (/\bgfs4\b/i.test("")) {
      process.on("exit", function() {
        debug(fs$i[gracefulQueue]);
        require$$2$1.equal(fs$i[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal$2[gracefulQueue]) {
    publishQueue(commonjsGlobal$2, fs$i[gracefulQueue]);
  }
  var gracefulFs = patch(clone$1(fs$i));
  function patch(fs) {
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile)
      fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile)
      fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return fs$copyFile(src, dest, flags, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([fs$copyFile, [src, dest, flags, cb]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      });
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    function readdir(path, options, cb) {
      var args = [path];
      if (typeof options !== "function") {
        args.push(options);
      } else {
        cb = options;
      }
      args.push(go$readdir$cb);
      return go$readdir(args);
      function go$readdir$cb(err, files) {
        if (files && files.sort)
          files.sort();
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [args]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      }
    }
    function go$readdir(args) {
      return fs$readdir.apply(fs, args);
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    return fs;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs$i[gracefulQueue].push(elem);
  }
  function retry() {
    var elem = fs$i[gracefulQueue].shift();
    if (elem) {
      debug("RETRY", elem[0].name, elem[1]);
      elem[0].apply(null, elem[1]);
    }
  }
  (function(exports) {
    const u = universalify$1.fromCallback;
    const fs = gracefulFs;
    const api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs[key] === "function";
    });
    Object.keys(fs).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports[key] = fs[key];
    });
    api.forEach((method) => {
      exports[method] = u(fs[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve({bytesRead, buffer: buffer2});
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve({bytesWritten, buffer: buffer2});
        });
      });
    };
    if (typeof fs.writev === "function") {
      exports.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs.writev(fd, buffers, ...args);
        }
        return new Promise((resolve, reject) => {
          fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve({bytesWritten, buffers: buffers2});
          });
        });
      };
    }
    if (typeof fs.realpath.native === "function") {
      exports.realpath.native = u(fs.realpath.native);
    }
  })(fs$j);
  var makeDir$1 = {};
  var atLeastNode$2 = (r) => {
    const n = process.versions.node.split(".").map((x) => parseInt(x, 10));
    r = r.split(".").map((x) => parseInt(x, 10));
    return n[0] > r[0] || n[0] === r[0] && (n[1] > r[1] || n[1] === r[1] && n[2] >= r[2]);
  };
  const fs$h = fs$j;
  const path$g = require$$3$1;
  const atLeastNode$1 = atLeastNode$2;
  const useNativeRecursiveOption = atLeastNode$1("10.12.0");
  const checkPath = (pth) => {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$g.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
  const processOptions = (options) => {
    const defaults = {mode: 511};
    if (typeof options === "number")
      options = {mode: options};
    return __spreadValues(__spreadValues({}, defaults), options);
  };
  const permissionError = (pth) => {
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
  };
  makeDir$1.makeDir = (input, options) => __async(this, null, function* () {
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption) {
      const pth = path$g.resolve(input);
      return fs$h.mkdir(pth, {
        mode: options.mode,
        recursive: true
      });
    }
    const make = (pth) => __async(this, null, function* () {
      try {
        yield fs$h.mkdir(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path$g.dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          yield make(path$g.dirname(pth));
          return make(pth);
        }
        try {
          const stats = yield fs$h.stat(pth);
          if (!stats.isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (e) {
          throw error;
        }
      }
    });
    return make(path$g.resolve(input));
  });
  makeDir$1.makeDirSync = (input, options) => {
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption) {
      const pth = path$g.resolve(input);
      return fs$h.mkdirSync(pth, {
        mode: options.mode,
        recursive: true
      });
    }
    const make = (pth) => {
      try {
        fs$h.mkdirSync(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path$g.dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          make(path$g.dirname(pth));
          return make(pth);
        }
        try {
          if (!fs$h.statSync(pth).isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (e) {
          throw error;
        }
      }
    };
    return make(path$g.resolve(input));
  };
  const u$a = universalify$1.fromPromise;
  const {makeDir: _makeDir, makeDirSync} = makeDir$1;
  const makeDir = u$a(_makeDir);
  var mkdirs$2 = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
  const fs$g = gracefulFs;
  function utimesMillis$1(path, atime, mtime, callback) {
    fs$g.open(path, "r+", (err, fd) => {
      if (err)
        return callback(err);
      fs$g.futimes(fd, atime, mtime, (futimesErr) => {
        fs$g.close(fd, (closeErr) => {
          if (callback)
            callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync$1(path, atime, mtime) {
    const fd = fs$g.openSync(path, "r+");
    fs$g.futimesSync(fd, atime, mtime);
    return fs$g.closeSync(fd);
  }
  var utimes = {
    utimesMillis: utimesMillis$1,
    utimesMillisSync: utimesMillisSync$1
  };
  const fs$f = fs$j;
  const path$f = require$$3$1;
  const util$1 = require$$1;
  const atLeastNode = atLeastNode$2;
  const nodeSupportsBigInt = atLeastNode("10.5.0");
  const stat$4 = (file) => nodeSupportsBigInt ? fs$f.stat(file, {bigint: true}) : fs$f.stat(file);
  const statSync = (file) => nodeSupportsBigInt ? fs$f.statSync(file, {bigint: true}) : fs$f.statSync(file);
  function getStats$2(src, dest) {
    return Promise.all([
      stat$4(src),
      stat$4(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({srcStat, destStat}));
  }
  function getStatsSync(src, dest) {
    let destStat;
    const srcStat = statSync(src);
    try {
      destStat = statSync(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return {srcStat, destStat: null};
      throw err;
    }
    return {srcStat, destStat};
  }
  function checkPaths(src, dest, funcName, cb) {
    util$1.callbackify(getStats$2)(src, dest, (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      if (destStat && areIdentical(srcStat, destStat)) {
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return cb(null, {srcStat, destStat});
    });
  }
  function checkPathsSync(src, dest, funcName) {
    const {srcStat, destStat} = getStatsSync(src, dest);
    if (destStat && areIdentical(srcStat, destStat)) {
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return {srcStat, destStat};
  }
  function checkParentPaths(src, srcStat, dest, funcName, cb) {
    const srcParent = path$f.resolve(path$f.dirname(src));
    const destParent = path$f.resolve(path$f.dirname(dest));
    if (destParent === srcParent || destParent === path$f.parse(destParent).root)
      return cb();
    const callback = (err, destStat) => {
      if (err) {
        if (err.code === "ENOENT")
          return cb();
        return cb(err);
      }
      if (areIdentical(srcStat, destStat)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb);
    };
    if (nodeSupportsBigInt)
      fs$f.stat(destParent, {bigint: true}, callback);
    else
      fs$f.stat(destParent, callback);
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path$f.resolve(path$f.dirname(src));
    const destParent = path$f.resolve(path$f.dirname(dest));
    if (destParent === srcParent || destParent === path$f.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = statSync(destParent);
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
        return true;
      }
      if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {
        return true;
      }
    }
    return false;
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path$f.resolve(src).split(path$f.sep).filter((i) => i);
    const destArr = path$f.resolve(dest).split(path$f.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  var stat_1 = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir
  };
  const fs$e = gracefulFs;
  const path$e = require$$3$1;
  const mkdirsSync$1 = mkdirs$2.mkdirsSync;
  const utimesMillisSync = utimes.utimesMillisSync;
  const stat$3 = stat_1;
  function copySync$2(src, dest, opts) {
    if (typeof opts === "function") {
      opts = {filter: opts};
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    const {srcStat, destStat} = stat$3.checkPathsSync(src, dest, "copy");
    stat$3.checkParentPathsSync(src, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src, dest, opts);
  }
  function handleFilterAndCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path$e.dirname(dest);
    if (!fs$e.existsSync(destParent))
      mkdirsSync$1(destParent);
    return startCopy$1(destStat, src, dest, opts);
  }
  function startCopy$1(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    return getStats$1(destStat, src, dest, opts);
  }
  function getStats$1(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs$e.statSync : fs$e.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir$1(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile$1(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink$1(destStat, src, dest, opts);
  }
  function onFile$1(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile$1(srcStat, src, dest, opts);
    return mayCopyFile$1(srcStat, src, dest, opts);
  }
  function mayCopyFile$1(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs$e.unlinkSync(dest);
      return copyFile$1(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile$1(srcStat, src, dest, opts) {
    fs$e.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode$1(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    if (fileIsNotWritable$1(srcMode))
      makeFileWritable$1(dest, srcMode);
    return setDestTimestamps$1(src, dest);
  }
  function fileIsNotWritable$1(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable$1(dest, srcMode) {
    return setDestMode$1(dest, srcMode | 128);
  }
  function setDestMode$1(dest, srcMode) {
    return fs$e.chmodSync(dest, srcMode);
  }
  function setDestTimestamps$1(src, dest) {
    const updatedSrcStat = fs$e.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir$1(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy$1(srcStat.mode, src, dest, opts);
    if (destStat && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    return copyDir$1(src, dest, opts);
  }
  function mkDirAndCopy$1(srcMode, src, dest, opts) {
    fs$e.mkdirSync(dest);
    copyDir$1(src, dest, opts);
    return setDestMode$1(dest, srcMode);
  }
  function copyDir$1(src, dest, opts) {
    fs$e.readdirSync(src).forEach((item) => copyDirItem$1(item, src, dest, opts));
  }
  function copyDirItem$1(item, src, dest, opts) {
    const srcItem = path$e.join(src, item);
    const destItem = path$e.join(dest, item);
    const {destStat} = stat$3.checkPathsSync(srcItem, destItem, "copy");
    return startCopy$1(destStat, srcItem, destItem, opts);
  }
  function onLink$1(destStat, src, dest, opts) {
    let resolvedSrc = fs$e.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path$e.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$e.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs$e.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs$e.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path$e.resolve(process.cwd(), resolvedDest);
      }
      if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs$e.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink$1(resolvedSrc, dest);
    }
  }
  function copyLink$1(resolvedSrc, dest) {
    fs$e.unlinkSync(dest);
    return fs$e.symlinkSync(resolvedSrc, dest);
  }
  var copySync_1 = copySync$2;
  var copySync$1 = {
    copySync: copySync_1
  };
  const u$9 = universalify$1.fromPromise;
  const fs$d = fs$j;
  function pathExists$6(path) {
    return fs$d.access(path).then(() => true).catch(() => false);
  }
  var pathExists_1 = {
    pathExists: u$9(pathExists$6),
    pathExistsSync: fs$d.existsSync
  };
  const fs$c = gracefulFs;
  const path$d = require$$3$1;
  const mkdirs$1 = mkdirs$2.mkdirs;
  const pathExists$5 = pathExists_1.pathExists;
  const utimesMillis = utimes.utimesMillis;
  const stat$2 = stat_1;
  function copy$2(src, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = {filter: opts};
    }
    cb = cb || function() {
    };
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    stat$2.checkPaths(src, dest, "copy", (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      stat$2.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
        if (err2)
          return cb(err2);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src, dest, opts, cb) {
    const destParent = path$d.dirname(dest);
    pathExists$5(destParent, (err, dirExists) => {
      if (err)
        return cb(err);
      if (dirExists)
        return startCopy(destStat, src, dest, opts, cb);
      mkdirs$1(destParent, (err2) => {
        if (err2)
          return cb(err2);
        return startCopy(destStat, src, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    Promise.resolve(opts.filter(src, dest)).then((include) => {
      if (include)
        return onInclude(destStat, src, dest, opts, cb);
      return cb();
    }, (error) => cb(error));
  }
  function startCopy(destStat, src, dest, opts, cb) {
    if (opts.filter)
      return handleFilter(getStats, destStat, src, dest, opts, cb);
    return getStats(destStat, src, dest, opts, cb);
  }
  function getStats(destStat, src, dest, opts, cb) {
    const stat = opts.dereference ? fs$c.stat : fs$c.lstat;
    stat(src, (err, srcStat) => {
      if (err)
        return cb(err);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts, cb);
    });
  }
  function onFile(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts, cb);
    return mayCopyFile(srcStat, src, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src, dest, opts, cb) {
    if (opts.overwrite) {
      fs$c.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return copyFile(srcStat, src, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else
      return cb();
  }
  function copyFile(srcStat, src, dest, opts, cb) {
    fs$c.copyFile(src, dest, (err) => {
      if (err)
        return cb(err);
      if (opts.preserveTimestamps)
        return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
      return setDestMode(dest, srcStat.mode, cb);
    });
  }
  function handleTimestampsAndMode(srcMode, src, dest, cb) {
    if (fileIsNotWritable(srcMode)) {
      return makeFileWritable(dest, srcMode, (err) => {
        if (err)
          return cb(err);
        return setDestTimestampsAndMode(srcMode, src, dest, cb);
      });
    }
    return setDestTimestampsAndMode(srcMode, src, dest, cb);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode, cb) {
    return setDestMode(dest, srcMode | 128, cb);
  }
  function setDestTimestampsAndMode(srcMode, src, dest, cb) {
    setDestTimestamps(src, dest, (err) => {
      if (err)
        return cb(err);
      return setDestMode(dest, srcMode, cb);
    });
  }
  function setDestMode(dest, srcMode, cb) {
    return fs$c.chmod(dest, srcMode, cb);
  }
  function setDestTimestamps(src, dest, cb) {
    fs$c.stat(src, (err, updatedSrcStat) => {
      if (err)
        return cb(err);
      return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
    });
  }
  function onDir(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
    if (destStat && !destStat.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
  }
  function mkDirAndCopy(srcMode, src, dest, opts, cb) {
    fs$c.mkdir(dest, (err) => {
      if (err)
        return cb(err);
      copyDir(src, dest, opts, (err2) => {
        if (err2)
          return cb(err2);
        return setDestMode(dest, srcMode, cb);
      });
    });
  }
  function copyDir(src, dest, opts, cb) {
    fs$c.readdir(src, (err, items) => {
      if (err)
        return cb(err);
      return copyDirItems(items, src, dest, opts, cb);
    });
  }
  function copyDirItems(items, src, dest, opts, cb) {
    const item = items.pop();
    if (!item)
      return cb();
    return copyDirItem(items, item, src, dest, opts, cb);
  }
  function copyDirItem(items, item, src, dest, opts, cb) {
    const srcItem = path$d.join(src, item);
    const destItem = path$d.join(dest, item);
    stat$2.checkPaths(srcItem, destItem, "copy", (err, stats) => {
      if (err)
        return cb(err);
      const {destStat} = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2)
          return cb(err2);
        return copyDirItems(items, src, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src, dest, opts, cb) {
    fs$c.readlink(src, (err, resolvedSrc) => {
      if (err)
        return cb(err);
      if (opts.dereference) {
        resolvedSrc = path$d.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs$c.symlink(resolvedSrc, dest, cb);
      } else {
        fs$c.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
              return fs$c.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path$d.resolve(process.cwd(), resolvedDest);
          }
          if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs$c.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return fs$c.symlink(resolvedSrc, dest, cb);
    });
  }
  var copy_1 = copy$2;
  const u$8 = universalify$1.fromCallback;
  var copy$1 = {
    copy: u$8(copy_1)
  };
  const fs$b = gracefulFs;
  const path$c = require$$3$1;
  const assert = require$$2$1;
  const isWindows = process.platform === "win32";
  function defaults(options) {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs$b[m];
      m = m + "Sync";
      options[m] = options[m] || fs$b[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf$1(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT")
          er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      let errState;
      if (n === 0)
        return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf$1(path$c.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2)
            return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path$c.join(p, f), options));
    if (isWindows) {
      const startTime = Date.now();
      do {
        try {
          const ret = options.rmdirSync(p, options);
          return ret;
        } catch (e) {
        }
      } while (Date.now() - startTime < 500);
    } else {
      const ret = options.rmdirSync(p, options);
      return ret;
    }
  }
  var rimraf_1 = rimraf$1;
  rimraf$1.sync = rimrafSync;
  const u$7 = universalify$1.fromCallback;
  const rimraf = rimraf_1;
  var remove$2 = {
    remove: u$7(rimraf),
    removeSync: rimraf.sync
  };
  const u$6 = universalify$1.fromCallback;
  const fs$a = gracefulFs;
  const path$b = require$$3$1;
  const mkdir$3 = mkdirs$2;
  const remove$1 = remove$2;
  const emptyDir = u$6(function emptyDir(dir, callback) {
    callback = callback || function() {
    };
    fs$a.readdir(dir, (err, items) => {
      if (err)
        return mkdir$3.mkdirs(dir, callback);
      items = items.map((item) => path$b.join(dir, item));
      deleteItem();
      function deleteItem() {
        const item = items.pop();
        if (!item)
          return callback();
        remove$1.remove(item, (err2) => {
          if (err2)
            return callback(err2);
          deleteItem();
        });
      }
    });
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs$a.readdirSync(dir);
    } catch (e) {
      return mkdir$3.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path$b.join(dir, item);
      remove$1.removeSync(item);
    });
  }
  var empty = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
  const u$5 = universalify$1.fromCallback;
  const path$a = require$$3$1;
  const fs$9 = gracefulFs;
  const mkdir$2 = mkdirs$2;
  function createFile(file, callback) {
    function makeFile() {
      fs$9.writeFile(file, "", (err) => {
        if (err)
          return callback(err);
        callback();
      });
    }
    fs$9.stat(file, (err, stats) => {
      if (!err && stats.isFile())
        return callback();
      const dir = path$a.dirname(file);
      fs$9.stat(dir, (err2, stats2) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return mkdir$2.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeFile();
            });
          }
          return callback(err2);
        }
        if (stats2.isDirectory())
          makeFile();
        else {
          fs$9.readdir(dir, (err3) => {
            if (err3)
              return callback(err3);
          });
        }
      });
    });
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs$9.statSync(file);
    } catch (e) {
    }
    if (stats && stats.isFile())
      return;
    const dir = path$a.dirname(file);
    try {
      if (!fs$9.statSync(dir).isDirectory()) {
        fs$9.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir$2.mkdirsSync(dir);
      else
        throw err;
    }
    fs$9.writeFileSync(file, "");
  }
  var file$1 = {
    createFile: u$5(createFile),
    createFileSync
  };
  const u$4 = universalify$1.fromCallback;
  const path$9 = require$$3$1;
  const fs$8 = gracefulFs;
  const mkdir$1 = mkdirs$2;
  const pathExists$4 = pathExists_1.pathExists;
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs$8.link(srcpath2, dstpath2, (err) => {
        if (err)
          return callback(err);
        callback(null);
      });
    }
    pathExists$4(dstpath, (err, destinationExists) => {
      if (err)
        return callback(err);
      if (destinationExists)
        return callback(null);
      fs$8.lstat(srcpath, (err2) => {
        if (err2) {
          err2.message = err2.message.replace("lstat", "ensureLink");
          return callback(err2);
        }
        const dir = path$9.dirname(dstpath);
        pathExists$4(dir, (err3, dirExists) => {
          if (err3)
            return callback(err3);
          if (dirExists)
            return makeLink(srcpath, dstpath);
          mkdir$1.mkdirs(dir, (err4) => {
            if (err4)
              return callback(err4);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    const destinationExists = fs$8.existsSync(dstpath);
    if (destinationExists)
      return void 0;
    try {
      fs$8.lstatSync(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path$9.dirname(dstpath);
    const dirExists = fs$8.existsSync(dir);
    if (dirExists)
      return fs$8.linkSync(srcpath, dstpath);
    mkdir$1.mkdirsSync(dir);
    return fs$8.linkSync(srcpath, dstpath);
  }
  var link$1 = {
    createLink: u$4(createLink),
    createLinkSync
  };
  const path$8 = require$$3$1;
  const fs$7 = gracefulFs;
  const pathExists$3 = pathExists_1.pathExists;
  function symlinkPaths$1(srcpath, dstpath, callback) {
    if (path$8.isAbsolute(srcpath)) {
      return fs$7.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        });
      });
    } else {
      const dstdir = path$8.dirname(dstpath);
      const relativeToDst = path$8.join(dstdir, srcpath);
      return pathExists$3(relativeToDst, (err, exists) => {
        if (err)
          return callback(err);
        if (exists) {
          return callback(null, {
            toCwd: relativeToDst,
            toDst: srcpath
          });
        } else {
          return fs$7.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: path$8.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync$1(srcpath, dstpath) {
    let exists;
    if (path$8.isAbsolute(srcpath)) {
      exists = fs$7.existsSync(srcpath);
      if (!exists)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    } else {
      const dstdir = path$8.dirname(dstpath);
      const relativeToDst = path$8.join(dstdir, srcpath);
      exists = fs$7.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      } else {
        exists = fs$7.existsSync(srcpath);
        if (!exists)
          throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path$8.relative(dstdir, srcpath)
        };
      }
    }
  }
  var symlinkPaths_1 = {
    symlinkPaths: symlinkPaths$1,
    symlinkPathsSync: symlinkPathsSync$1
  };
  const fs$6 = gracefulFs;
  function symlinkType$1(srcpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    if (type)
      return callback(null, type);
    fs$6.lstat(srcpath, (err, stats) => {
      if (err)
        return callback(null, "file");
      type = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type);
    });
  }
  function symlinkTypeSync$1(srcpath, type) {
    let stats;
    if (type)
      return type;
    try {
      stats = fs$6.lstatSync(srcpath);
    } catch (e) {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  var symlinkType_1 = {
    symlinkType: symlinkType$1,
    symlinkTypeSync: symlinkTypeSync$1
  };
  const u$3 = universalify$1.fromCallback;
  const path$7 = require$$3$1;
  const fs$5 = gracefulFs;
  const _mkdirs = mkdirs$2;
  const mkdirs = _mkdirs.mkdirs;
  const mkdirsSync = _mkdirs.mkdirsSync;
  const _symlinkPaths = symlinkPaths_1;
  const symlinkPaths = _symlinkPaths.symlinkPaths;
  const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  const _symlinkType = symlinkType_1;
  const symlinkType = _symlinkType.symlinkType;
  const symlinkTypeSync = _symlinkType.symlinkTypeSync;
  const pathExists$2 = pathExists_1.pathExists;
  function createSymlink(srcpath, dstpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    pathExists$2(dstpath, (err, destinationExists) => {
      if (err)
        return callback(err);
      if (destinationExists)
        return callback(null);
      symlinkPaths(srcpath, dstpath, (err2, relative) => {
        if (err2)
          return callback(err2);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type, (err3, type2) => {
          if (err3)
            return callback(err3);
          const dir = path$7.dirname(dstpath);
          pathExists$2(dir, (err4, dirExists) => {
            if (err4)
              return callback(err4);
            if (dirExists)
              return fs$5.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err5) => {
              if (err5)
                return callback(err5);
              fs$5.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    const destinationExists = fs$5.existsSync(dstpath);
    if (destinationExists)
      return void 0;
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path$7.dirname(dstpath);
    const exists = fs$5.existsSync(dir);
    if (exists)
      return fs$5.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs$5.symlinkSync(srcpath, dstpath, type);
  }
  var symlink$1 = {
    createSymlink: u$3(createSymlink),
    createSymlinkSync
  };
  const file = file$1;
  const link = link$1;
  const symlink = symlink$1;
  var ensure = {
    createFile: file.createFile,
    createFileSync: file.createFileSync,
    ensureFile: file.createFile,
    ensureFileSync: file.createFileSync,
    createLink: link.createLink,
    createLinkSync: link.createLinkSync,
    ensureLink: link.createLink,
    ensureLinkSync: link.createLinkSync,
    createSymlink: symlink.createSymlink,
    createSymlinkSync: symlink.createSymlinkSync,
    ensureSymlink: symlink.createSymlink,
    ensureSymlinkSync: symlink.createSymlinkSync
  };
  function stringify$3(obj, {EOL = "\n", finalEOL = true, replacer = null, spaces} = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom$1(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  var utils = {stringify: stringify$3, stripBom: stripBom$1};
  let _fs;
  try {
    _fs = gracefulFs;
  } catch (_) {
    _fs = require$$2$2;
  }
  const universalify = universalify$1;
  const {stringify: stringify$2, stripBom} = utils;
  function _readFile(_0) {
    return __async(this, arguments, function* (file, options = {}) {
      if (typeof options === "string") {
        options = {encoding: options};
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = yield universalify.fromCallback(fs.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    });
  }
  const readFile = universalify.fromPromise(_readFile);
  function readFileSync(file, options = {}) {
    if (typeof options === "string") {
      options = {encoding: options};
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  function _writeFile(_0, _1) {
    return __async(this, arguments, function* (file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify$2(obj, options);
      yield universalify.fromCallback(fs.writeFile)(file, str, options);
    });
  }
  const writeFile = universalify.fromPromise(_writeFile);
  function writeFileSync(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify$2(obj, options);
    return fs.writeFileSync(file, str, options);
  }
  const jsonfile$1 = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  var jsonfile_1 = jsonfile$1;
  const jsonFile$1 = jsonfile_1;
  var jsonfile = {
    readJson: jsonFile$1.readFile,
    readJsonSync: jsonFile$1.readFileSync,
    writeJson: jsonFile$1.writeFile,
    writeJsonSync: jsonFile$1.writeFileSync
  };
  const u$2 = universalify$1.fromCallback;
  const fs$4 = gracefulFs;
  const path$6 = require$$3$1;
  const mkdir = mkdirs$2;
  const pathExists$1 = pathExists_1.pathExists;
  function outputFile$1(file, data, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = "utf8";
    }
    const dir = path$6.dirname(file);
    pathExists$1(dir, (err, itDoes) => {
      if (err)
        return callback(err);
      if (itDoes)
        return fs$4.writeFile(file, data, encoding, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2)
          return callback(err2);
        fs$4.writeFile(file, data, encoding, callback);
      });
    });
  }
  function outputFileSync$1(file, ...args) {
    const dir = path$6.dirname(file);
    if (fs$4.existsSync(dir)) {
      return fs$4.writeFileSync(file, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs$4.writeFileSync(file, ...args);
  }
  var output = {
    outputFile: u$2(outputFile$1),
    outputFileSync: outputFileSync$1
  };
  const {stringify: stringify$1} = utils;
  const {outputFile} = output;
  function outputJson(_0, _1) {
    return __async(this, arguments, function* (file, data, options = {}) {
      const str = stringify$1(data, options);
      yield outputFile(file, str, options);
    });
  }
  var outputJson_1 = outputJson;
  const {stringify} = utils;
  const {outputFileSync} = output;
  function outputJsonSync(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  }
  var outputJsonSync_1 = outputJsonSync;
  const u$1 = universalify$1.fromPromise;
  const jsonFile = jsonfile;
  jsonFile.outputJson = u$1(outputJson_1);
  jsonFile.outputJsonSync = outputJsonSync_1;
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  var json = jsonFile;
  const fs$3 = gracefulFs;
  const path$5 = require$$3$1;
  const copySync = copySync$1.copySync;
  const removeSync$1 = remove$2.removeSync;
  const mkdirpSync = mkdirs$2.mkdirpSync;
  const stat$1 = stat_1;
  function moveSync$1(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const {srcStat} = stat$1.checkPathsSync(src, dest, "move");
    stat$1.checkParentPathsSync(src, srcStat, dest, "move");
    mkdirpSync(path$5.dirname(dest));
    return doRename$1(src, dest, overwrite);
  }
  function doRename$1(src, dest, overwrite) {
    if (overwrite) {
      removeSync$1(dest);
      return rename$1(src, dest, overwrite);
    }
    if (fs$3.existsSync(dest))
      throw new Error("dest already exists.");
    return rename$1(src, dest, overwrite);
  }
  function rename$1(src, dest, overwrite) {
    try {
      fs$3.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice$1(src, dest, overwrite);
    }
  }
  function moveAcrossDevice$1(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync(src, dest, opts);
    return removeSync$1(src);
  }
  var moveSync_1 = moveSync$1;
  var moveSync = {
    moveSync: moveSync_1
  };
  const fs$2 = gracefulFs;
  const path$4 = require$$3$1;
  const copy = copy$1.copy;
  const remove = remove$2.remove;
  const mkdirp = mkdirs$2.mkdirp;
  const pathExists = pathExists_1.pathExists;
  const stat = stat_1;
  function move$1(src, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    const overwrite = opts.overwrite || opts.clobber || false;
    stat.checkPaths(src, dest, "move", (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat} = stats;
      stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
        if (err2)
          return cb(err2);
        mkdirp(path$4.dirname(dest), (err3) => {
          if (err3)
            return cb(err3);
          return doRename(src, dest, overwrite, cb);
        });
      });
    });
  }
  function doRename(src, dest, overwrite, cb) {
    if (overwrite) {
      return remove(dest, (err) => {
        if (err)
          return cb(err);
        return rename(src, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err)
        return cb(err);
      if (destExists)
        return cb(new Error("dest already exists."));
      return rename(src, dest, overwrite, cb);
    });
  }
  function rename(src, dest, overwrite, cb) {
    fs$2.rename(src, dest, (err) => {
      if (!err)
        return cb();
      if (err.code !== "EXDEV")
        return cb(err);
      return moveAcrossDevice(src, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy(src, dest, opts, (err) => {
      if (err)
        return cb(err);
      return remove(src, cb);
    });
  }
  var move_1 = move$1;
  const u = universalify$1.fromCallback;
  var move = {
    move: u(move_1)
  };
  (function(module) {
    module.exports = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, fs$j), copySync$1), copy$1), empty), ensure), json), mkdirs$2), moveSync), move), output), pathExists_1), remove$2);
    const fs = require$$2$2;
    if (Object.getOwnPropertyDescriptor(fs, "promises")) {
      Object.defineProperty(module.exports, "promises", {
        get() {
          return fs.promises;
        }
      });
    }
  })(lib);
  var __fs = lib.exports;
  function __packageTmpDir() {
    const tmpDir = sugar.get("storage.package.tmpDir");
    if (tmpDir !== void 0) {
      __fs.ensureDirSync(tmpDir);
      return tmpDir;
    }
    __fs.ensureDirSync(__tmpDir);
    return __tmpDir;
  }
  const fn = function() {
    const path = sugar.get("storage.package.localDir");
    __fs.ensureDirSync(path);
    return path;
  };
  function __packageCacheDir(settings = {}) {
    settings = Object.assign({}, settings);
    const packageCacheDir = sugar.get("storage.package.cacheDir");
    if (packageCacheDir !== void 0) {
      __fs.ensureDirSync(packageCacheDir);
      return packageCacheDir;
    }
    return void 0;
  }
  function isFile(path, settings = {}) {
    settings = deepMerge$1({
      symlink: true
    }, settings);
    let isMatching = __fs$1.existsSync(path);
    if (!isMatching)
      return false;
    if (settings.symlink && __fs$1.lstatSync(path).isSymbolicLink()) {
      const realPath = __fs$1.realpathSync(path);
      isMatching = isMatching && __fs$1.lstatSync(realPath).isFile();
    } else {
      isMatching = isMatching && __fs$1.lstatSync(path).isFile();
    }
    return isMatching;
  }
  var path$3 = require$$3$1, fs$1 = require$$2$2;
  function parse(data) {
    data = data.toString("utf-8");
    if (data.charCodeAt(0) === 65279)
      data = data.slice(1);
    try {
      return JSON.parse(data);
    } catch (e) {
      return false;
    }
  }
  var iteratorSymbol = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.iterator : null;
  function addSymbolIterator(result) {
    if (!iteratorSymbol) {
      return result;
    }
    result[iteratorSymbol] = function() {
      return this;
    };
    return result;
  }
  var findPackageJson = function find(root) {
    root = root || process.cwd();
    if (typeof root !== "string") {
      if (typeof root === "object" && typeof root.filename === "string") {
        root = root.filename;
      } else {
        throw new Error("Must pass a filename string or a module object to finder");
      }
    }
    return addSymbolIterator({
      next: function next() {
        if (root.match(/^(\w:\\|\/)$/))
          return addSymbolIterator({
            value: void 0,
            filename: void 0,
            done: true
          });
        var file = path$3.join(root, "package.json"), data;
        root = path$3.resolve(root, "..");
        if (fs$1.existsSync(file) && (data = parse(fs$1.readFileSync(file)))) {
          data.__path = file;
          return addSymbolIterator({
            value: data,
            filename: file,
            done: false
          });
        }
        return next();
      }
    });
  };
  function packageRoot(from = process.cwd(), highest = false) {
    if (isFile(from))
      from = from.split("/").slice(0, -1).join("/");
    const f = findPackageJson(from);
    let file = f.next();
    if (!highest) {
      const filename = file.filename || false;
      if (!filename)
        return filename;
      return filename.split("/").slice(0, -1).join("/");
    }
    let finalFile;
    while (!file.done) {
      if (file.done)
        break;
      finalFile = file;
      file = f.next();
    }
    if (finalFile.filename) {
      return finalFile.filename.split("/").slice(0, -1).join("/");
    }
    return false;
  }
  function __packageRootDir(from, highest = false) {
    if (from) {
      return packageRoot(from, highest);
    }
    const packageRootDir = sugar.get("storage.package.rootDir");
    if (packageRootDir !== void 0) {
      __fs.ensureDirSync(packageRootDir);
      return packageRootDir;
    }
    return "/";
  }
  function __srcRootDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcRootDir = sugar.get("storage.src.rootDir");
    if (srcRootDir !== void 0) {
      __fs.ensureDirSync(srcRootDir);
      return srcRootDir;
    }
    return void 0;
  }
  function __distRootDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distRootDir = sugar.get("storage.dist.rootDir");
    if (distRootDir !== void 0) {
      __fs.ensureDirSync(distRootDir);
      return distRootDir;
    }
    return void 0;
  }
  function __srcJsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcJsDir = sugar.get("storage.src.jsDir");
    if (srcJsDir !== void 0) {
      __fs.ensureDirSync(srcJsDir);
      return srcJsDir;
    }
    return void 0;
  }
  function __srcCssDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcCssDir = sugar.get("storage.src.cssDir");
    if (srcCssDir !== void 0) {
      __fs.ensureDirSync(srcCssDir);
      return srcCssDir;
    }
    return void 0;
  }
  function __srcDocDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcDocDir = sugar.get("storage.src.docDir");
    if (srcDocDir !== void 0) {
      __fs.ensureDirSync(srcDocDir);
      return srcDocDir;
    }
    return void 0;
  }
  function __srcFontsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcFontsDir = sugar.get("storage.src.fontsDir");
    if (srcFontsDir !== void 0) {
      __fs.ensureDirSync(srcFontsDir);
      return srcFontsDir;
    }
    return void 0;
  }
  function __srcIconsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcIconsDir = sugar.get("storage.src.iconsDir");
    if (srcIconsDir !== void 0) {
      __fs.ensureDirSync(srcIconsDir);
      return srcIconsDir;
    }
    return void 0;
  }
  function __srcImgDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcImgDir = sugar.get("storage.src.imgDir");
    if (srcImgDir !== void 0) {
      __fs.ensureDirSync(srcImgDir);
      return srcImgDir;
    }
    return void 0;
  }
  function __srcNodeDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcNodeDir = sugar.get("storage.src.nodeDir");
    if (srcNodeDir !== void 0) {
      __fs.ensureDirSync(srcNodeDir);
      return srcNodeDir;
    }
    return void 0;
  }
  function __srcViewsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const srcViewsDir = sugar.get("storage.src.viewsDir");
    if (srcViewsDir !== void 0) {
      __fs.ensureDirSync(srcViewsDir);
      return srcViewsDir;
    }
    return void 0;
  }
  function __distJsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distJsDir = sugar.get("storage.dist.jsDir");
    if (distJsDir !== void 0) {
      __fs.ensureDirSync(distJsDir);
      return distJsDir;
    }
    return void 0;
  }
  function __distCssDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distCssDir = sugar.get("storage.dist.cssDir");
    if (distCssDir !== void 0) {
      __fs.ensureDirSync(distCssDir);
      return distCssDir;
    }
    return void 0;
  }
  function __distDocDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distDocDir = sugar.get("storage.dist.docDir");
    if (distDocDir !== void 0) {
      __fs.ensureDirSync(distDocDir);
      return distDocDir;
    }
    return void 0;
  }
  function __distFontsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distFontsDir = sugar.get("storage.dist.fontsDir");
    if (distFontsDir !== void 0) {
      __fs.ensureDirSync(distFontsDir);
      return distFontsDir;
    }
    return void 0;
  }
  function __distIconsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distIconsDir = sugar.get("storage.dist.iconsDir");
    if (distIconsDir !== void 0) {
      __fs.ensureDirSync(distIconsDir);
      return distIconsDir;
    }
    return void 0;
  }
  function __distImgDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distImgDir = sugar.get("storage.dist.imgDir");
    if (distImgDir !== void 0) {
      __fs.ensureDirSync(distImgDir);
      return distImgDir;
    }
    return void 0;
  }
  function __distNodeDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distNodeDir = sugar.get("storage.dist.nodeDir");
    if (distNodeDir !== void 0) {
      __fs.ensureDirSync(distNodeDir);
      return distNodeDir;
    }
    return void 0;
  }
  function __distViewsDir(settings = {}) {
    settings = Object.assign({}, settings);
    const distViewsDir = sugar.get("storage.dist.viewsDir");
    if (distViewsDir !== void 0) {
      __fs.ensureDirSync(distViewsDir);
      return distViewsDir;
    }
    return void 0;
  }
  function replacePathTokens(paths, settings) {
    const set = Object.assign({packageTmpDir: true, packageLocalDir: true, packageCacheDir: true, packageRootDir: true, srcRootDir: true, distRootDir: true, srcJsDir: true, srcCssDir: true, srcDocDir: true, srcFontsDir: true, srcIconsDir: true, srcImgDir: true, srcNodeDir: true, srcViewsDir: true, distJsDir: true, distCssDir: true, distDocDir: true, distFontsDir: true, distIconsDir: true, distImgDir: true, distNodeDir: true, distViewsDir: true}, settings);
    const isArray = Array.isArray(paths);
    if (!isArray)
      paths = [paths];
    const finalPaths = paths.map((path) => {
      if (set.packageTmpDir)
        path = path.replace("%packageTmpDir", __packageTmpDir());
      if (set.packageLocalDir)
        path = path.replace("%packageLocalDir", fn());
      if (set.packageCacheDir)
        path = path.replace("%packageCacheDir", __packageCacheDir());
      if (set.packageRootDir)
        path = path.replace("%packageRootDir", __packageRootDir());
      if (set.srcRootDir)
        path = path.replace("%srcRootDir", __srcRootDir());
      if (set.distRootDir)
        path = path.replace("%distRootDir", __distRootDir());
      if (set.srcJsDir)
        path = path.replace("%srcJsDir", __srcJsDir());
      if (set.srcCssDir)
        path = path.replace("%srcCssDir", __srcCssDir());
      if (set.srcDocDir)
        path = path.replace("%srcDocDir", __srcDocDir());
      if (set.srcFontsDir)
        path = path.replace("%srcFontsDir", __srcFontsDir());
      if (set.srcIconsDir)
        path = path.replace("%srcIconsDir", __srcIconsDir());
      if (set.srcImgDir)
        path = path.replace("%srcImgDir", __srcImgDir());
      if (set.srcNodeDir)
        path = path.replace("%srcNodeDir", __srcNodeDir());
      if (set.srcViewsDir)
        path = path.replace("%srcViewsDir", __srcViewsDir());
      if (set.distJsDir)
        path = path.replace("%distJsDir", __distJsDir());
      if (set.distCssDir)
        path = path.replace("%distCssDir", __distCssDir());
      if (set.distDocDir)
        path = path.replace("%distDocDir", __distDocDir());
      if (set.distFontsDir)
        path = path.replace("%distFontsDir", __distFontsDir());
      if (set.distIconsDir)
        path = path.replace("%distIconsDir", __distIconsDir());
      if (set.distImgDir)
        path = path.replace("%distImgDir", __distImgDir());
      if (set.distNodeDir)
        path = path.replace("%distNodeDir", __distNodeDir());
      if (set.distViewsDir)
        path = path.replace("%distViewsDir", __distViewsDir());
      path = path.replace(/\/\//gm, "/");
      return path;
    });
    if (isArray)
      return finalPaths;
    else
      return finalPaths[0];
  }
  function ensureDirSync(dir) {
    dir = replacePathTokens(dir);
    __fs.ensureDirSync(dir);
  }
  function removeSync(path) {
    path = replacePathTokens(path);
    return __fs.removeSync(path);
  }
  class SCacheAdapter extends SClass {
    constructor(settings = {}) {
      super(deepMerge$1({
        cacheAdapter: {}
      }, settings));
    }
    setCache(cache) {
      this.cache = cache;
    }
  }
  var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SCacheFsAdapter extends SCacheAdapter {
    constructor(settings = {}) {
      super(deepMerge$1({
        fsCacheAdapter: {
          rootDir: sugar.get("storage.cacheDir") || `${__packageTmpDir()}/SCache`
        }
      }, settings));
    }
    get fsCacheAdapterSettings() {
      return this._settings.fsCacheAdapter;
    }
    set(name2, value) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const fsName = `${this.cache.id}/${name2}.json`.replace(/\/\//gm, "/");
        ensureDirSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName.split("/").slice(0, -1).join("/")}`);
        __fs$1.writeFileSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`, value);
        return true;
      });
    }
    get(name2) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (name2.slice(0, 1) === "/")
          name2 = name2.slice(1);
        const fsName = `${this.cache.id}/${name2}.json`;
        if (!__fs$1.existsSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`))
          return null;
        return __fs$1.readFileSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`, "utf8");
      });
    }
    delete(name2) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const fsName = `${this.cache.id}/${name2}.json`;
        return __fs$1.unlinkSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`);
      });
    }
    clear() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return removeSync(`${this.fsCacheAdapterSettings.rootDir}/${this.cache.id}`);
      });
    }
    keys() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return [];
      });
    }
  }
  SCacheFsAdapter.id = "fs";
  var SCacheFsAdapter$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": SCacheFsAdapter});
  function Lazyness(require_) {
    if (!this || !(this instanceof Lazyness)) {
      return new Lazyness(require_);
    }
    this.require = require_;
  }
  var Lazyness_1 = Lazyness;
  Lazyness.property = (object, property, fn, enumerable) => {
    Object.defineProperty(object, property, {
      configurable: true,
      enumerable: !!enumerable,
      get: function() {
        var value = fn(object, property);
        Object.defineProperty(object, property, {
          configurable: true,
          enumerable: !!enumerable,
          writable: false,
          value
        });
        return value;
      }
    });
    return object;
  };
  Lazyness.prototype.property = Lazyness.property;
  Lazyness.properties = (object, properties, enumerable) => {
    Object.keys(properties).forEach((property) => {
      Lazyness.property(object, property, properties[property], enumerable);
    });
    return object;
  };
  Lazyness.prototype.properties = Lazyness.properties;
  Lazyness.instanceProperty = (object, property, fn, enumerable) => {
    Object.defineProperty(object, property, {
      configurable: true,
      enumerable: !!enumerable,
      get: function() {
        var value = fn(this, property);
        Object.defineProperty(this, property, {
          configurable: true,
          enumerable: !!enumerable,
          writable: false,
          value
        });
        return value;
      }
    });
    return object;
  };
  Lazyness.prototype.instanceProperty = Lazyness.instanceProperty;
  Lazyness.instanceProperties = (object, properties, enumerable) => {
    Object.keys(properties).forEach((property) => {
      Lazyness.property(object, property, properties[property], enumerable);
    });
    return object;
  };
  Lazyness.prototype.instanceProperties = Lazyness.instanceProperties;
  Lazyness.value = (fn) => {
    var firstTime = true, value;
    return function() {
      if (firstTime) {
        value = fn();
        firstTime = false;
      }
      return value;
    };
  };
  Lazyness.prototype.value = Lazyness.value;
  Lazyness.require = function(require_, moduleId) {
    var firstTime = true, module_;
    return new Proxy(() => {
    }, {
      construct: (target, args) => {
        if (firstTime) {
          module_ = require_(moduleId);
          firstTime = false;
        }
        return Reflect.construct(module_, args);
      },
      apply: (target, thisArg, args) => {
        if (firstTime) {
          module_ = require_(moduleId);
          firstTime = false;
        }
        return Reflect.apply(module_, thisArg, args);
      },
      get: (target, property) => {
        if (firstTime) {
          module_ = require_(moduleId);
          firstTime = false;
        }
        return Reflect.get(module_, property);
      }
    });
  };
  Lazyness.prototype.require = function(moduleId) {
    return Lazyness.require(this.require, moduleId);
  };
  Lazyness.requireProperty = function(require_, object, property, moduleId, enumerable) {
    Object.defineProperty(object, property, {
      configurable: true,
      enumerable: !!enumerable,
      get: function() {
        var module_ = require_(moduleId);
        Object.defineProperty(object, property, {
          configurable: true,
          enumerable: !!enumerable,
          writable: false,
          value: module_
        });
        return module_;
      }
    });
    return object;
  };
  Lazyness.prototype.requireProperty = function(object, property, moduleId, enumerable) {
    return Lazyness.requireProperty(this.require, object, property, moduleId, enumerable);
  };
  Lazyness.requireProperties = function(require_, object, properties, enumerable) {
    Object.keys(properties).forEach((property) => {
      Lazyness.requireProperty(require_, object, property, properties[property], enumerable);
    });
    return object;
  };
  Lazyness.prototype.requireProperties = function(object, properties, enumerable) {
    return Lazyness.requireProperties(this.require, object, properties, enumerable);
  };
  var polyfill$1 = {};
  var polyfill_1 = polyfill$1;
  polyfill$1.repeat = function(count) {
    if (this === null) {
      throw new TypeError("can't convert " + this + " to object");
    }
    var str = "" + this;
    count = +count;
    if (count !== count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError("repeat count must be non-negative");
    }
    if (count === Infinity) {
      throw new RangeError("repeat count must be less than infinity");
    }
    count = Math.floor(count);
    if (str.length === 0 || count === 0) {
      return "";
    }
    if (str.length * count >= 1 << 28) {
      throw new RangeError("repeat count must not overflow maximum string size");
    }
    var rpt = "";
    for (; ; ) {
      if ((count & 1) === 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count === 0) {
        break;
      }
      str += str;
    }
    return rpt;
  };
  var _escape = {};
  (function(exports) {
    exports.regExp = exports.regExpPattern = (str) => str.replace(/([.*+?^${}()|[\]/\\])/g, "\\$1");
    exports.regExpReplacement = (str) => str.replace(/\$/g, "$$$$");
    exports.format = (str) => str.replace(/%/g, "%%");
    exports.jsSingleQuote = (str) => exports.control(str).replace(/'/g, "\\'");
    exports.jsDoubleQuote = (str) => exports.control(str).replace(/"/g, '\\"');
    exports.shellArg = (str) => "'" + str.replace(/'/g, "'\\''") + "'";
    var escapeControlMap = {
      "\r": "\\r",
      "\n": "\\n",
      "	": "\\t",
      "\x7F": "\\x7f"
    };
    exports.control = (str, keepNewLineAndTab = false) => str.replace(/[\x00-\x1f\x7f]/g, (match) => {
      if (keepNewLineAndTab && (match === "\n" || match === "	")) {
        return match;
      }
      if (escapeControlMap[match] !== void 0) {
        return escapeControlMap[match];
      }
      var hex = match.charCodeAt(0).toString(16);
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "\\x" + hex;
    });
    var escapeHtmlMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;"
    };
    exports.html = (str) => str.replace(/[&<>]/g, (match) => escapeHtmlMap[match]);
    exports.htmlAttr = (str) => str.replace(/[&<>"]/g, (match) => escapeHtmlMap[match]);
    exports.htmlSpecialChars = (str) => str.replace(/[&<>"']/g, (match) => escapeHtmlMap[match]);
    exports.unicodePercentEncode = (str) => str.replace(/[\x00-\x1f\u0100-\uffff\x7f%]/g, (match) => {
      try {
        return encodeURI(match);
      } catch (error) {
        return "";
      }
    });
    exports.httpHeaderValue = (str) => exports.unicodePercentEncode(str);
  })(_escape);
  var ansi$1 = {
    reset: "[0m",
    bold: "[1m",
    dim: "[2m",
    italic: "[3m",
    underline: "[4m",
    inverse: "[7m",
    defaultColor: "[39m",
    black: "[30m",
    red: "[31m",
    green: "[32m",
    yellow: "[33m",
    blue: "[34m",
    magenta: "[35m",
    cyan: "[36m",
    white: "[37m",
    grey: "[90m",
    gray: "[90m",
    brightBlack: "[90m",
    brightRed: "[91m",
    brightGreen: "[92m",
    brightYellow: "[93m",
    brightBlue: "[94m",
    brightMagenta: "[95m",
    brightCyan: "[96m",
    brightWhite: "[97m",
    defaultBgColor: "[49m",
    bgBlack: "[40m",
    bgRed: "[41m",
    bgGreen: "[42m",
    bgYellow: "[43m",
    bgBlue: "[44m",
    bgMagenta: "[45m",
    bgCyan: "[46m",
    bgWhite: "[47m",
    bgGrey: "[100m",
    bgGray: "[100m",
    bgBrightBlack: "[100m",
    bgBrightRed: "[101m",
    bgBrightGreen: "[102m",
    bgBrightYellow: "[103m",
    bgBrightBlue: "[104m",
    bgBrightMagenta: "[105m",
    bgBrightCyan: "[106m",
    bgBrightWhite: "[107m"
  };
  const unicode$1 = {};
  var unicode_1 = unicode$1;
  unicode$1.encode = (array) => String.fromCodePoint(...array);
  unicode$1.decode = (str) => {
    var value, extra, counter = 0, output = [], length = str.length;
    while (counter < length) {
      value = str.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        extra = str.charCodeAt(counter++);
        if ((extra & 64512) === 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  };
  unicode$1.firstCodePoint = (str) => {
    var extra, value = str.charCodeAt(0);
    if (value >= 55296 && value <= 56319 && str.length >= 2) {
      extra = str.charCodeAt(1);
      if ((extra & 64512) === 56320) {
        return ((value & 1023) << 10) + (extra & 1023) + 65536;
      }
    }
    return value;
  };
  unicode$1.firstChar = (str) => {
    var extra, value = str.charCodeAt(0);
    if (value >= 55296 && value <= 56319 && str.length >= 2) {
      extra = str.charCodeAt(1);
      if ((extra & 64512) === 56320) {
        return str.slice(0, 2);
      }
    }
    return str[0];
  };
  unicode$1.toArray = (str) => {
    var value, extra, counter = 0, output = [], length = str.length;
    while (counter < length) {
      value = str.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        extra = str.charCodeAt(counter++);
        if ((extra & 64512) === 56320) {
          output.push(str.slice(counter - 2, counter));
        } else {
          output.push(str[counter - 2]);
          counter--;
        }
      } else {
        output.push(str[counter - 1]);
      }
    }
    return output;
  };
  unicode$1.toCells = (Cell, str, tabWidth = 4, linePosition = 0, ...extraCellArgs) => {
    var value, extra, counter = 0, output = [], fillSize, length = str.length;
    while (counter < length) {
      value = str.charCodeAt(counter++);
      if (value === 10) {
        linePosition = 0;
      } else if (value === 9) {
        fillSize = tabWidth - linePosition % tabWidth - 1;
        output.push(new Cell("	", ...extraCellArgs));
        linePosition += 1 + fillSize;
        while (fillSize--) {
          output.push(new Cell(null, ...extraCellArgs));
        }
      } else if (value >= 55296 && value <= 56319 && counter < length) {
        extra = str.charCodeAt(counter++);
        if ((extra & 64512) === 56320) {
          value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          output.push(new Cell(str.slice(counter - 2, counter), ...extraCellArgs));
          linePosition++;
          if (unicode$1.codePointWidth(value) === 2) {
            linePosition++;
            output.push(new Cell(null, ...extraCellArgs));
          }
        } else {
          counter--;
        }
      } else {
        output.push(new Cell(str[counter - 1], ...extraCellArgs));
        linePosition++;
        if (unicode$1.codePointWidth(value) === 2) {
          output.push(new Cell(null, ...extraCellArgs));
          linePosition++;
        }
      }
    }
    return output;
  };
  unicode$1.fromCells = (cells) => {
    return cells.map((cell) => cell.filler ? "" : cell.char).join("");
  };
  unicode$1.length = (str) => {
    var value, extra, counter = 0, uLength = 0, length = str.length;
    while (counter < length) {
      value = str.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        extra = str.charCodeAt(counter++);
        if ((extra & 64512) !== 56320) {
          counter--;
        }
      }
      uLength++;
    }
    return uLength;
  };
  unicode$1.width = (str) => {
    var count = 0;
    unicode$1.decode(str).forEach((code) => count += unicode$1.codePointWidth(code));
    return count;
  };
  unicode$1.arrayWidth = (array, limit) => {
    var index, count = 0;
    if (limit === void 0) {
      limit = array.length;
    }
    for (index = 0; index < limit; index++) {
      count += unicode$1.isFullWidth(array[index]) ? 2 : 1;
    }
    return count;
  };
  var lastTruncateWidth$1 = 0;
  unicode$1.getLastTruncateWidth = () => lastTruncateWidth$1;
  unicode$1.widthLimit = unicode$1.truncateWidth = (str, limit) => {
    var value, extra, charWidth, counter = 0, lastCounter = 0, length = str.length;
    lastTruncateWidth$1 = 0;
    while (counter < length) {
      value = str.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        extra = str.charCodeAt(counter++);
        if ((extra & 64512) === 56320) {
          value = ((value & 1023) << 10) + (extra & 1023) + 65536;
        } else {
          counter--;
        }
      }
      charWidth = unicode$1.codePointWidth(value);
      if (lastTruncateWidth$1 + charWidth > limit) {
        return str.slice(0, lastCounter);
      }
      lastTruncateWidth$1 += charWidth;
      lastCounter = counter;
    }
    return str;
  };
  unicode$1.surrogatePair = (char) => {
    var code = char.charCodeAt(0);
    if (code < 55296 || code >= 57344) {
      return 0;
    } else if (code < 56320) {
      return 1;
    }
    return -1;
  };
  unicode$1.isFullWidth = (char) => {
    if (char.length <= 1) {
      return unicode$1.isFullWidthCodePoint(char.codePointAt(0));
    }
    return unicode$1.isFullWidthCodePoint(unicode$1.firstCodePoint(char));
  };
  unicode$1.charWidth = (char) => {
    if (char.length <= 1) {
      return unicode$1.codePointWidth(char.codePointAt(0));
    }
    return unicode$1.codePointWidth(unicode$1.firstCodePoint(char));
  };
  unicode$1.codePointWidth = (code) => {
    if (code >= 4352 && (code <= 4447 || code === 9001 || code === 9002 || 11904 <= code && code <= 12871 && code !== 12351 || 12880 <= code && code <= 19903 || 19968 <= code && code <= 42182 || 43360 <= code && code <= 43388 || 44032 <= code && code <= 55203 || 63744 <= code && code <= 64255 || 65040 <= code && code <= 65049 || 65072 <= code && code <= 65131 || 65281 <= code && code <= 65376 || 65504 <= code && code <= 65510 || 110592 <= code && code <= 110593 || 127488 <= code && code <= 127569 || 131072 <= code && code <= 262141)) {
      return 2;
    }
    return 1;
  };
  unicode$1.isFullWidthCodePoint = (code) => unicode$1.codePointWidth(code) === 2;
  unicode$1.toFullWidth = (str) => {
    return String.fromCodePoint(...unicode$1.decode(str).map((code) => code >= 33 && code <= 126 ? 65280 + code - 32 : code));
  };
  var format = {};
  var inspect$1 = {};
  const escape$1 = _escape;
  const ansi = ansi$1;
  const EMPTY = {};
  function inspect(options, variable) {
    if (arguments.length < 2) {
      variable = options;
      options = {};
    } else if (!options || typeof options !== "object") {
      options = {};
    }
    var runtime = {depth: 0, ancestors: []};
    if (!options.style) {
      options.style = inspectStyle.none;
    } else if (typeof options.style === "string") {
      options.style = inspectStyle[options.style];
    }
    if (options.depth === void 0) {
      options.depth = 3;
    }
    if (options.maxLength === void 0) {
      options.maxLength = 250;
    }
    if (options.outputMaxLength === void 0) {
      options.outputMaxLength = 5e3;
    }
    if (options.nofunc) {
      options.noFunc = true;
    }
    if (options.minimal) {
      options.noFunc = true;
      options.noDescriptor = true;
      options.noType = true;
      options.noArrayProperty = true;
      options.enumOnly = true;
      options.proto = false;
      options.funcDetails = false;
    }
    var str = inspect_(runtime, options, variable);
    if (str.length > options.outputMaxLength) {
      str = options.style.truncate(str, options.outputMaxLength);
    }
    return str;
  }
  function inspect_(runtime, options, variable) {
    var i, funcName, length, proto, propertyList, constructor, keyIsProperty, type, pre, indent, isArray, isFunc, specialObject, str = "", key = "", descriptorStr = "", descriptor, nextAncestors;
    type = typeof variable;
    indent = options.style.tab.repeat(runtime.depth);
    if (type === "function" && options.noFunc) {
      return "";
    }
    if (runtime.key !== void 0) {
      if (runtime.descriptor) {
        descriptorStr = [];
        if (!runtime.descriptor.configurable) {
          descriptorStr.push("-conf");
        }
        if (!runtime.descriptor.enumerable) {
          descriptorStr.push("-enum");
        }
        if (!runtime.descriptor.writable) {
          descriptorStr.push("-w");
        }
        if (descriptorStr.length) {
          descriptorStr = descriptorStr.join(" ");
        } else {
          descriptorStr = "";
        }
      }
      if (runtime.keyIsProperty) {
        if (keyNeedingQuotes(runtime.key)) {
          key = '"' + options.style.key(runtime.key) + '": ';
        } else {
          key = options.style.key(runtime.key) + ": ";
        }
      } else if (!options.noIndex) {
        key = options.style.index(runtime.key);
      }
      if (descriptorStr) {
        descriptorStr = " " + options.style.type(descriptorStr);
      }
    }
    pre = runtime.noPre ? "" : indent + key;
    if (variable === void 0) {
      str += pre + options.style.constant("undefined") + descriptorStr + options.style.newline;
    } else if (variable === EMPTY) {
      str += pre + options.style.constant("[empty]") + descriptorStr + options.style.newline;
    } else if (variable === null) {
      str += pre + options.style.constant("null") + descriptorStr + options.style.newline;
    } else if (variable === false) {
      str += pre + options.style.constant("false") + descriptorStr + options.style.newline;
    } else if (variable === true) {
      str += pre + options.style.constant("true") + descriptorStr + options.style.newline;
    } else if (type === "number") {
      str += pre + options.style.number(variable.toString()) + (options.noType ? "" : " " + options.style.type("number")) + descriptorStr + options.style.newline;
    } else if (type === "string") {
      if (variable.length > options.maxLength) {
        str += pre + '"' + options.style.string(escape$1.control(variable.slice(0, options.maxLength - 1))) + '\u2026"' + (options.noType ? "" : " " + options.style.type("string") + options.style.length("(" + variable.length + " - TRUNCATED)")) + descriptorStr + options.style.newline;
      } else {
        str += pre + '"' + options.style.string(escape$1.control(variable)) + '"' + (options.noType ? "" : " " + options.style.type("string") + options.style.length("(" + variable.length + ")")) + descriptorStr + options.style.newline;
      }
    } else if (Buffer.isBuffer(variable)) {
      str += pre + options.style.inspect(variable.inspect()) + (options.noType ? "" : " " + options.style.type("Buffer") + options.style.length("(" + variable.length + ")")) + descriptorStr + options.style.newline;
    } else if (type === "object" || type === "function") {
      funcName = length = "";
      isFunc = false;
      if (type === "function") {
        isFunc = true;
        funcName = " " + options.style.funcName(variable.name ? variable.name : "(anonymous)");
        length = options.style.length("(" + variable.length + ")");
      }
      isArray = false;
      if (Array.isArray(variable)) {
        isArray = true;
        length = options.style.length("(" + variable.length + ")");
      }
      if (!variable.constructor) {
        constructor = "(no constructor)";
      } else if (!variable.constructor.name) {
        constructor = "(anonymous)";
      } else {
        constructor = variable.constructor.name;
      }
      constructor = options.style.constructorName(constructor);
      proto = Object.getPrototypeOf(variable);
      str += pre;
      if (!options.noType) {
        if (runtime.forceType) {
          str += options.style.type(runtime.forceType);
        } else {
          str += constructor + funcName + length + " " + options.style.type(type) + descriptorStr;
        }
        if (!isFunc || options.funcDetails) {
          str += " ";
        }
      }
      if (isArray && options.noArrayProperty) {
        propertyList = [...Array(variable.length).keys()];
      } else {
        propertyList = Object.getOwnPropertyNames(variable);
      }
      if (options.sort) {
        propertyList.sort();
      }
      specialObject = specialObjectSubstitution(variable, runtime, options);
      if (options.protoBlackList && options.protoBlackList.has(proto)) {
        str += options.style.limit("[skip]") + options.style.newline;
      } else if (specialObject !== void 0) {
        if (typeof specialObject === "string") {
          str += "=> " + specialObject + options.style.newline;
        } else {
          str += "=> " + inspect_({
            depth: runtime.depth,
            ancestors: runtime.ancestors,
            noPre: true
          }, options, specialObject);
        }
      } else if (isFunc && !options.funcDetails) {
        str += options.style.newline;
      } else if (!propertyList.length && !options.proto) {
        str += (isArray ? "[]" : "{}") + options.style.newline;
      } else if (runtime.depth >= options.depth) {
        str += options.style.limit("[depth limit]") + options.style.newline;
      } else if (runtime.ancestors.indexOf(variable) !== -1) {
        str += options.style.limit("[circular]") + options.style.newline;
      } else {
        str += (isArray && options.noType && options.noArrayProperty ? "[" : "{") + options.style.newline;
        nextAncestors = runtime.ancestors.slice();
        nextAncestors.push(variable);
        for (i = 0; i < propertyList.length && str.length < options.outputMaxLength; i++) {
          if (!isArray && (options.propertyBlackList && options.propertyBlackList.has(propertyList[i]) || options.useInspectPropertyBlackList && variable.inspectPropertyBlackList instanceof Set && variable.inspectPropertyBlackList.has(propertyList[i]))) {
            continue;
          }
          if (isArray && options.noArrayProperty && !(propertyList[i] in variable)) {
            str += inspect_({
              depth: runtime.depth + 1,
              ancestors: nextAncestors,
              key: propertyList[i],
              keyIsProperty: false
            }, options, EMPTY);
          } else {
            try {
              descriptor = Object.getOwnPropertyDescriptor(variable, propertyList[i]);
              if (!descriptor.enumerable && options.enumOnly) {
                continue;
              }
              keyIsProperty = !isArray || !descriptor.enumerable || isNaN(propertyList[i]);
              if (!options.noDescriptor && descriptor && (descriptor.get || descriptor.set)) {
                str += inspect_({
                  depth: runtime.depth + 1,
                  ancestors: nextAncestors,
                  key: propertyList[i],
                  keyIsProperty,
                  descriptor,
                  forceType: "getter/setter"
                }, options, {get: descriptor.get, set: descriptor.set});
              } else {
                str += inspect_({
                  depth: runtime.depth + 1,
                  ancestors: nextAncestors,
                  key: propertyList[i],
                  keyIsProperty,
                  descriptor: options.noDescriptor ? void 0 : descriptor
                }, options, variable[propertyList[i]]);
              }
            } catch (error) {
              str += inspect_({
                depth: runtime.depth + 1,
                ancestors: nextAncestors,
                key: propertyList[i],
                keyIsProperty,
                descriptor: options.noDescriptor ? void 0 : descriptor
              }, options, error);
            }
          }
          if (i < propertyList.length - 1) {
            str += options.style.comma;
          }
        }
        if (options.proto) {
          str += inspect_({
            depth: runtime.depth + 1,
            ancestors: nextAncestors,
            key: "__proto__",
            keyIsProperty: true
          }, options, proto);
        }
        str += indent + (isArray && options.noType && options.noArrayProperty ? "]" : "}");
        str += options.style.newline;
      }
    }
    if (runtime.depth === 0) {
      if (options.style.trim) {
        str = str.trim();
      }
      if (options.style === "html") {
        str = escape$1.html(str);
      }
    }
    return str;
  }
  inspect$1.inspect = inspect;
  function keyNeedingQuotes(key) {
    if (!key.length) {
      return true;
    }
    return false;
  }
  var promiseStates = ["pending", "fulfilled", "rejected"];
  function specialObjectSubstitution(object, runtime, options) {
    if (typeof object.constructor !== "function") {
      return;
    }
    if (object instanceof String) {
      return object.toString();
    }
    if (object instanceof RegExp) {
      return object.toString();
    }
    if (object instanceof Date) {
      return object.toString() + " [" + object.getTime() + "]";
    }
    if (typeof Set === "function" && object instanceof Set) {
      return Array.from(object);
    }
    if (typeof Map === "function" && object instanceof Map) {
      return Array.from(object);
    }
    if (object instanceof Promise) {
      if (process && process.binding && process.binding("util") && process.binding("util").getPromiseDetails) {
        let details = process.binding("util").getPromiseDetails(object);
        let state = promiseStates[details[0]];
        let str = "Promise <" + state + ">";
        if (state === "fulfilled") {
          str += " " + inspect_({
            depth: runtime.depth,
            ancestors: runtime.ancestors,
            noPre: true
          }, options, details[1]);
        } else if (state === "rejected") {
          if (details[1] instanceof Error) {
            str += " " + inspectError({
              style: options.style,
              noErrorStack: true
            }, details[1]);
          } else {
            str += " " + inspect_({
              depth: runtime.depth,
              ancestors: runtime.ancestors,
              noPre: true
            }, options, details[1]);
          }
        }
        return str;
      }
    }
    if (object._bsontype) {
      return object.toString();
    }
    if (options.useInspect && typeof object.inspect === "function") {
      return object.inspect();
    }
    return;
  }
  function inspectError(options, error) {
    var str = "", stack, type, code;
    if (arguments.length < 2) {
      error = options;
      options = {};
    } else if (!options || typeof options !== "object") {
      options = {};
    }
    if (!(error instanceof Error)) {
      return "inspectError(): it's not an error, using regular variable inspection: " + inspect(options, error);
    }
    if (!options.style) {
      options.style = inspectStyle.none;
    } else if (typeof options.style === "string") {
      options.style = inspectStyle[options.style];
    }
    if (error.stack && !options.noErrorStack) {
      stack = inspectStack(options, error.stack);
    }
    type = error.type || error.constructor.name;
    code = error.code || error.name || error.errno || error.number;
    str += options.style.errorType(type) + (code ? " [" + options.style.errorType(code) + "]" : "") + ": ";
    str += options.style.errorMessage(error.message) + "\n";
    if (stack) {
      str += options.style.errorStack(stack) + "\n";
    }
    if (error.from) {
      str += options.style.newline + options.style.errorFromMessage("From error:") + options.style.newline + inspectError(options, error.from);
    }
    return str;
  }
  inspect$1.inspectError = inspectError;
  function inspectStack(options, stack) {
    if (arguments.length < 2) {
      stack = options;
      options = {};
    } else if (!options || typeof options !== "object") {
      options = {};
    }
    if (!options.style) {
      options.style = inspectStyle.none;
    } else if (typeof options.style === "string") {
      options.style = inspectStyle[options.style];
    }
    if (!stack) {
      return;
    }
    if ((options.browser || process.browser) && stack.indexOf("@") !== -1) {
      stack = stack.replace(/[</]*(?=@)/g, "").replace(/^\s*([^@]*)\s*@\s*([^\n]*)(?::([0-9]+):([0-9]+))?$/mg, (matches, method, file, line, column) => {
        return options.style.errorStack("    at ") + (method ? options.style.errorStackMethod(method) + " " : "") + options.style.errorStack("(") + (file ? options.style.errorStackFile(file) : options.style.errorStack("unknown")) + (line ? options.style.errorStack(":") + options.style.errorStackLine(line) : "") + (column ? options.style.errorStack(":") + options.style.errorStackColumn(column) : "") + options.style.errorStack(")");
      });
    } else {
      stack = stack.replace(/^[^\n]*\n/, "");
      stack = stack.replace(/^\s*(at)\s+(?:(?:(async|new)\s+)?([^\s:()[\]\n]+(?:\([^)]+\))?)\s)?(?:\[as ([^\s:()[\]\n]+)\]\s)?(?:\(?([^:()[\]\n]+):([0-9]+):([0-9]+)\)?)?$/mg, (matches, at, keyword, method, as, file, line, column) => {
        return options.style.errorStack("    at ") + (keyword ? options.style.errorStackKeyword(keyword) + " " : "") + (method ? options.style.errorStackMethod(method) + " " : "") + (as ? options.style.errorStack("[as ") + options.style.errorStackMethodAs(as) + options.style.errorStack("] ") : "") + options.style.errorStack("(") + (file ? options.style.errorStackFile(file) : options.style.errorStack("unknown")) + (line ? options.style.errorStack(":") + options.style.errorStackLine(line) : "") + (column ? options.style.errorStack(":") + options.style.errorStackColumn(column) : "") + options.style.errorStack(")");
      });
    }
    return stack;
  }
  inspect$1.inspectStack = inspectStack;
  var inspectStyle = {};
  var inspectStyleNoop = (str) => str;
  inspectStyle.none = {
    trim: false,
    tab: "    ",
    newline: "\n",
    comma: "",
    limit: inspectStyleNoop,
    type: (str) => "<" + str + ">",
    constant: inspectStyleNoop,
    funcName: inspectStyleNoop,
    constructorName: (str) => "<" + str + ">",
    length: inspectStyleNoop,
    key: inspectStyleNoop,
    index: (str) => "[" + str + "] ",
    number: inspectStyleNoop,
    inspect: inspectStyleNoop,
    string: inspectStyleNoop,
    errorType: inspectStyleNoop,
    errorMessage: inspectStyleNoop,
    errorStack: inspectStyleNoop,
    errorStackKeyword: inspectStyleNoop,
    errorStackMethod: inspectStyleNoop,
    errorStackMethodAs: inspectStyleNoop,
    errorStackFile: inspectStyleNoop,
    errorStackLine: inspectStyleNoop,
    errorStackColumn: inspectStyleNoop,
    errorFromMessage: inspectStyleNoop,
    truncate: (str, maxLength) => str.slice(0, maxLength - 1) + "\u2026"
  };
  inspectStyle.inline = Object.assign({}, inspectStyle.none, {
    trim: true,
    tab: "",
    newline: " ",
    comma: ", ",
    length: () => "",
    index: () => ""
  });
  inspectStyle.color = Object.assign({}, inspectStyle.none, {
    limit: (str) => ansi.bold + ansi.brightRed + str + ansi.reset,
    type: (str) => ansi.italic + ansi.brightBlack + str + ansi.reset,
    constant: (str) => ansi.cyan + str + ansi.reset,
    funcName: (str) => ansi.italic + ansi.magenta + str + ansi.reset,
    constructorName: (str) => ansi.magenta + str + ansi.reset,
    length: (str) => ansi.italic + ansi.brightBlack + str + ansi.reset,
    key: (str) => ansi.green + str + ansi.reset,
    index: (str) => ansi.blue + "[" + str + "]" + ansi.reset + " ",
    number: (str) => ansi.cyan + str + ansi.reset,
    inspect: (str) => ansi.cyan + str + ansi.reset,
    string: (str) => ansi.blue + str + ansi.reset,
    errorType: (str) => ansi.red + ansi.bold + str + ansi.reset,
    errorMessage: (str) => ansi.red + ansi.italic + str + ansi.reset,
    errorStack: (str) => ansi.brightBlack + str + ansi.reset,
    errorStackKeyword: (str) => ansi.italic + ansi.bold + str + ansi.reset,
    errorStackMethod: (str) => ansi.brightYellow + str + ansi.reset,
    errorStackMethodAs: (str) => ansi.yellow + str + ansi.reset,
    errorStackFile: (str) => ansi.brightCyan + str + ansi.reset,
    errorStackLine: (str) => ansi.blue + str + ansi.reset,
    errorStackColumn: (str) => ansi.magenta + str + ansi.reset,
    errorFromMessage: (str) => ansi.yellow + ansi.underline + str + ansi.reset,
    truncate: (str, maxLength) => {
      var trail = ansi.gray + "\u2026" + ansi.reset;
      str = str.slice(0, maxLength - trail.length);
      var lastEscape = str.lastIndexOf("");
      if (lastEscape >= str.length - 6) {
        str = str.slice(0, lastEscape);
      }
      return str + trail;
    }
  });
  inspectStyle.html = Object.assign({}, inspectStyle.none, {
    tab: "&nbsp;&nbsp;&nbsp;&nbsp;",
    newline: "<br />",
    limit: (str) => '<span style="color:red">' + str + "</span>",
    type: (str) => '<i style="color:gray">' + str + "</i>",
    constant: (str) => '<span style="color:cyan">' + str + "</span>",
    funcName: (str) => '<i style="color:magenta">' + str + "</i>",
    constructorName: (str) => '<span style="color:magenta">' + str + "</span>",
    length: (str) => '<i style="color:gray">' + str + "</i>",
    key: (str) => '<span style="color:green">' + str + "</span>",
    index: (str) => '<span style="color:blue">[' + str + "]</span> ",
    number: (str) => '<span style="color:cyan">' + str + "</span>",
    inspect: (str) => '<span style="color:cyan">' + str + "</span>",
    string: (str) => '<span style="color:blue">' + str + "</span>",
    errorType: (str) => '<span style="color:red">' + str + "</span>",
    errorMessage: (str) => '<span style="color:red">' + str + "</span>",
    errorStack: (str) => '<span style="color:gray">' + str + "</span>",
    errorStackKeyword: (str) => "<i>" + str + "</i>",
    errorStackMethod: (str) => '<span style="color:yellow">' + str + "</span>",
    errorStackMethodAs: (str) => '<span style="color:yellow">' + str + "</span>",
    errorStackFile: (str) => '<span style="color:cyan">' + str + "</span>",
    errorStackLine: (str) => '<span style="color:blue">' + str + "</span>",
    errorStackColumn: (str) => '<span style="color:gray">' + str + "</span>",
    errorFromMessage: (str) => '<span style="color:yellow">' + str + "</span>"
  });
  var naturalSort = function(a, b) {
    var re = /(^([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)?$|^0x[\da-fA-F]+$|\d+)/g, sre = /^\s+|\s+$/g, snre = /\s+/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[/-]\d{1,4}[/-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i = function(s) {
      return ("" + s).toLowerCase().replace(sre, "");
    }, x = i(a) || "", y = i(b) || "", xN = x.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, normChunk = function(s, l) {
      return (!s.match(ore) || l === 1) && parseFloat(s) || s.replace(snre, " ").replace(sre, "") || 0;
    }, oFxNcL, oFyNcL;
    if (yD) {
      if (xD < yD) {
        return -1;
      } else if (xD > yD) {
        return 1;
      }
    }
    for (var cLoc = 0, xNl = xN.length, yNl = yN.length, numS = Math.max(xNl, yNl); cLoc < numS; cLoc++) {
      oFxNcL = normChunk(xN[cLoc], xNl);
      oFyNcL = normChunk(yN[cLoc], yNl);
      if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
        return isNaN(oFxNcL) ? 1 : -1;
      } else if (typeof oFxNcL !== typeof oFyNcL) {
        oFxNcL += "";
        oFyNcL += "";
      }
      if (oFxNcL < oFyNcL) {
        return -1;
      }
      if (oFxNcL > oFyNcL) {
        return 1;
      }
    }
    return 0;
  };
  (function(exports) {
    const inspect = inspect$1.inspect;
    const inspectError = inspect$1.inspectError;
    const escape2 = _escape;
    const ansi = ansi$1;
    const unicode = unicode_1;
    const naturalSort$1 = naturalSort;
    exports.formatMethod = function(...args) {
      var str = args[0];
      if (typeof str !== "string") {
        if (!str) {
          str = "";
        } else if (typeof str.toString === "function") {
          str = str.toString();
        } else {
          str = "";
        }
      }
      var arg, autoIndex = 1, length = args.length, hasMarkup = false, shift = null, markupStack = [];
      if (this.markupReset && this.startingMarkupReset) {
        str = (typeof this.markupReset === "function" ? this.markupReset(markupStack) : this.markupReset) + str;
      }
      str = str.replace(/\^(.?)|(%%)|%([+-]?)([0-9]*)(?:\[([^\]]*)\])?([a-zA-Z])/g, (match, markup, doublePercent, relative, index, modeArg, mode) => {
        var replacement, i, tmp, fn, fnArgString, argMatches, argList = [];
        if (doublePercent) {
          return "%";
        }
        if (markup) {
          if (this.noMarkup) {
            return "^" + markup;
          }
          if (markup === "^") {
            return "^";
          }
          if (this.shiftMarkup && this.shiftMarkup[markup]) {
            shift = this.shiftMarkup[markup];
            return "";
          }
          if (shift) {
            if (!this.shiftedMarkup || !this.shiftedMarkup[shift] || !this.shiftedMarkup[shift][markup]) {
              return "";
            }
            hasMarkup = true;
            if (typeof this.shiftedMarkup[shift][markup] === "function") {
              replacement = this.shiftedMarkup[shift][markup](markupStack);
            } else {
              replacement = this.shiftedMarkup[shift][markup];
              markupStack.push(replacement);
            }
            shift = null;
          } else {
            if (!this.markup || !this.markup[markup]) {
              return "";
            }
            hasMarkup = true;
            if (typeof this.markup[markup] === "function") {
              replacement = this.markup[markup](markupStack);
            } else {
              replacement = this.markup[markup];
              markupStack.push(replacement);
            }
          }
          return replacement;
        }
        if (index) {
          index = parseInt(index, 10);
          if (relative) {
            if (relative === "+") {
              index = autoIndex + index;
            } else if (relative === "-") {
              index = autoIndex - index;
            }
          }
        } else {
          index = autoIndex;
        }
        autoIndex++;
        if (index >= length || index < 1) {
          arg = void 0;
        } else {
          arg = args[index];
        }
        if (modes[mode]) {
          replacement = modes[mode](arg, modeArg, this);
          if (this.argumentSanitizer && !modes[mode].noSanitize) {
            replacement = this.argumentSanitizer(replacement);
          }
          if (modeArg && !modes[mode].noCommonModeArg) {
            replacement = commonModeArg(replacement, modeArg);
          }
          return replacement;
        }
        if (mode === "F") {
          autoIndex--;
          if (modeArg === void 0) {
            return "";
          }
          tmp = modeArg.split(":");
          fn = tmp[0];
          fnArgString = tmp[1];
          if (!fn) {
            return "";
          }
          if (fnArgString && (argMatches = fnArgString.match(/%([+-]?)([0-9]*)[a-zA-Z]/g))) {
            for (i = 0; i < argMatches.length; i++) {
              relative = argMatches[i][1];
              index = argMatches[i][2];
              if (index) {
                index = parseInt(index, 10);
                if (relative) {
                  if (relative === "+") {
                    index = autoIndex + index;
                  } else if (relative === "-") {
                    index = autoIndex - index;
                  }
                }
              } else {
                index = autoIndex;
              }
              autoIndex++;
              if (index >= length || index < 1) {
                argList[i] = void 0;
              } else {
                argList[i] = args[index];
              }
            }
          }
          if (!this || !this.fn || typeof this.fn[fn] !== "function") {
            return "";
          }
          return this.fn[fn].apply(this, argList);
        }
        return "";
      });
      if (hasMarkup && this.markupReset && this.endingMarkupReset) {
        str += typeof this.markupReset === "function" ? this.markupReset(markupStack) : this.markupReset;
      }
      if (this.extraArguments) {
        for (; autoIndex < length; autoIndex++) {
          arg = args[autoIndex];
          if (arg === null || arg === void 0) {
            continue;
          } else if (typeof arg === "string") {
            str += arg;
          } else if (typeof arg === "number") {
            str += arg;
          } else if (typeof arg.toString === "function") {
            str += arg.toString();
          }
        }
      }
      return str;
    };
    const modes = {};
    modes.s = (arg) => {
      if (typeof arg === "string") {
        return arg;
      }
      if (arg === null || arg === void 0 || arg === true || arg === false) {
        return "(" + arg + ")";
      }
      if (typeof arg === "number") {
        return "" + arg;
      }
      if (typeof arg.toString === "function") {
        return arg.toString();
      }
      return "(" + arg + ")";
    };
    modes.r = (arg) => modes.s(arg);
    modes.r.noSanitize = true;
    modes.S = (arg, modeArg, options) => {
      var interpret = (str) => exports.markupMethod.call(options, options.argumentSanitizer ? options.argumentSanitizer(str) : str);
      if (typeof arg === "string") {
        return interpret(arg);
      }
      if (arg === null || arg === void 0 || arg === true || arg === false) {
        return "(" + arg + ")";
      }
      if (typeof arg === "number") {
        return "" + arg;
      }
      if (typeof arg.toString === "function") {
        return interpret(arg.toString());
      }
      return interpret("(" + arg + ")");
    };
    modes.S.noSanitize = true;
    modes.S.noCommonModeArg = true;
    modes.N = (arg, isSubCall) => {
      if (typeof arg === "string") {
        return arg;
      }
      if (arg === null || arg === void 0 || arg === true || arg === false || typeof arg === "number") {
        return "" + arg;
      }
      if (Array.isArray(arg)) {
        arg = arg.map((e) => modes.N(e, true));
        if (isSubCall) {
          return "[" + arg.join(",") + "]";
        }
        return arg.join(", ");
      }
      if (Buffer.isBuffer(arg)) {
        arg = [...arg].map((e) => {
          e = e.toString(16);
          if (e.length === 1) {
            e = "0" + e;
          }
          return e;
        });
        return "<" + arg.join(" ") + ">";
      }
      var proto = Object.getPrototypeOf(arg);
      if (proto === null || proto === Object.prototype) {
        arg = Object.entries(arg).sort(naturalSort$1).map((e) => e[0] + ": " + modes.N(e[1], true));
        if (isSubCall) {
          return "{" + arg.join(", ") + "}";
        }
        return arg.join(", ");
      }
      if (typeof arg.inspect === "function") {
        return arg.inspect();
      }
      if (typeof arg.toString === "function") {
        return arg.toString();
      }
      return "(" + arg + ")";
    };
    modes.n = (arg) => modes.N(arg, true);
    modes.f = (arg, modeArg) => {
      var match, k, v, lv, n, step = 0, toFixed, toFixedIfDecimal, padding;
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg !== "number") {
        arg = 0;
      }
      if (modeArg) {
        MODE_ARG_FORMAT_REGEX.lastIndex = 0;
        while (match = MODE_ARG_FORMAT_REGEX.exec(modeArg)) {
          [, k, v] = match;
          if (k === "z") {
            padding = +v;
          } else if (!k) {
            if (v[0] === ".") {
              lv = v[v.length - 1];
              if (lv === "!") {
                n = parseInt(v.slice(1, -1), 10);
                step = __pow(10, -n);
                toFixed = n;
              } else if (lv === "?") {
                n = parseInt(v.slice(1, -1), 10);
                step = __pow(10, -n);
                toFixed = n;
                toFixedIfDecimal = true;
              } else {
                n = parseInt(v.slice(1), 10);
                step = __pow(10, -n);
              }
            } else if (v[v.length - 1] === ".") {
              n = parseInt(v.slice(0, -1), 10);
              step = __pow(10, n);
            } else {
              n = parseInt(v, 10);
              step = __pow(10, Math.ceil(Math.log10(arg + Number.EPSILON) + Number.EPSILON) - n);
            }
          }
        }
      }
      if (step) {
        arg = round(arg, step);
      }
      if (toFixed !== void 0 && (!toFixedIfDecimal || arg !== Math.trunc(arg))) {
        arg = arg.toFixed(toFixed);
      } else {
        arg = "" + arg;
      }
      if (padding) {
        n = arg.indexOf(".");
        if (n === -1) {
          n = arg.length;
        }
        if (arg[0] === "-") {
          if (n - 1 < padding) {
            arg = "-" + "0".repeat(1 + padding - n) + arg.slice(1);
          }
        } else if (n < padding) {
          arg = "0".repeat(padding - n) + arg;
        }
      }
      return arg;
    };
    modes.f.noSanitize = true;
    modes.e = (arg, modeArg) => {
      var match, k, v;
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg !== "number") {
        arg = 0;
      }
      if (modeArg) {
        MODE_ARG_FORMAT_REGEX.lastIndex = 0;
        if (match = MODE_ARG_FORMAT_REGEX.exec(modeArg)) {
          [, k, v] = match;
          if (!k) {
            return "" + arg.toExponential(parseInt(v, 10) - 1);
          }
        }
      }
      return "" + arg.toExponential();
    };
    modes.e.noSanitize = true;
    modes.d = modes.i = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg === "number") {
        return "" + Math.floor(arg);
      }
      return "0";
    };
    modes.i.noSanitize = true;
    modes.u = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg === "number") {
        return "" + Math.max(Math.floor(arg), 0);
      }
      return "0";
    };
    modes.u.noSanitize = true;
    modes.U = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg === "number") {
        return "" + Math.max(Math.floor(arg), 1);
      }
      return "1";
    };
    modes.U.noSanitize = true;
    modes.k = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg !== "number") {
        return "0";
      }
      return metricPrefix(arg);
    };
    modes.k.noSanitize = true;
    modes.m = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg !== "number") {
        return "(NaN)";
      }
      var minus = "";
      if (arg < 0) {
        minus = "-";
        arg = -arg;
      }
      var degrees = epsilonFloor(arg), frac = arg - degrees;
      if (!frac) {
        return minus + degrees + "\xB0";
      }
      var minutes = epsilonFloor(frac * 60), seconds = epsilonFloor(frac * 3600 - minutes * 60);
      if (seconds) {
        return minus + degrees + "\xB0" + ("" + minutes).padStart(2, "0") + "\u2032" + ("" + seconds).padStart(2, "0") + "\u2033";
      }
      return minus + degrees + "\xB0" + ("" + minutes).padStart(2, "0") + "\u2032";
    };
    modes.m.noSanitize = true;
    modes.t = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg !== "number") {
        return "(NaN)";
      }
      var s = Math.floor(arg / 1e3);
      if (s < 60) {
        return s + "s";
      }
      var min = Math.floor(s / 60);
      s = s % 60;
      if (min < 60) {
        return min + "min" + ("" + s).padStart(2, "0") + "s";
      }
      var h = Math.floor(min / 60);
      min = min % 60;
      return h + "h" + ("" + min).padStart(2, "0") + "min" + ("" + s).padStart(2, "0") + "s";
    };
    modes.t.noSanitize = true;
    modes.h = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg === "number") {
        return "" + Math.max(Math.floor(arg), 0).toString(16);
      }
      return "0";
    };
    modes.h.noSanitize = true;
    modes.x = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg !== "number") {
        return "00";
      }
      var value = "" + Math.max(Math.floor(arg), 0).toString(16);
      if (value.length % 2) {
        value = "0" + value;
      }
      return value;
    };
    modes.x.noSanitize = true;
    modes.o = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg === "number") {
        return "" + Math.max(Math.floor(arg), 0).toString(8);
      }
      return "0";
    };
    modes.o.noSanitize = true;
    modes.b = (arg) => {
      if (typeof arg === "string") {
        arg = parseFloat(arg);
      }
      if (typeof arg === "number") {
        return "" + Math.max(Math.floor(arg), 0).toString(2);
      }
      return "0";
    };
    modes.b.noSanitize = true;
    modes.X = (arg) => {
      if (typeof arg === "string") {
        arg = Buffer.from(arg);
      } else if (!Buffer.isBuffer(arg)) {
        return "";
      }
      return arg.toString("hex");
    };
    modes.X.noSanitize = true;
    modes.z = (arg) => {
      if (typeof arg === "string") {
        arg = Buffer.from(arg);
      } else if (!Buffer.isBuffer(arg)) {
        return "";
      }
      return arg.toString("base64");
    };
    modes.Z = (arg) => {
      if (typeof arg === "string") {
        arg = Buffer.from(arg);
      } else if (!Buffer.isBuffer(arg)) {
        return "";
      }
      return arg.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/[=]{1,2}$/g, "");
    };
    const I_OPTIONS = {};
    modes.I = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, I_OPTIONS);
    modes.I.noSanitize = true;
    const Y_OPTIONS = {
      noFunc: true,
      enumOnly: true,
      noDescriptor: true,
      useInspect: true,
      useInspectPropertyBlackList: true
    };
    modes.Y = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, Y_OPTIONS);
    modes.Y.noSanitize = true;
    const O_OPTIONS = {minimal: true, noIndex: true};
    modes.O = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, O_OPTIONS);
    modes.O.noSanitize = true;
    const E_OPTIONS = {};
    modes.E = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, E_OPTIONS, true);
    modes.E.noSanitize = true;
    modes.J = (arg) => arg === void 0 ? "null" : JSON.stringify(arg);
    modes.D = () => "";
    modes.D.noSanitize = true;
    var defaultFormatter = {
      argumentSanitizer: (str) => escape2.control(str, true),
      extraArguments: true,
      color: false,
      noMarkup: false,
      endingMarkupReset: true,
      startingMarkupReset: false,
      markupReset: ansi.reset,
      shiftMarkup: {
        "#": "background"
      },
      markup: {
        ":": ansi.reset,
        " ": ansi.reset + " ",
        "-": ansi.dim,
        "+": ansi.bold,
        "_": ansi.underline,
        "/": ansi.italic,
        "!": ansi.inverse,
        "b": ansi.blue,
        "B": ansi.brightBlue,
        "c": ansi.cyan,
        "C": ansi.brightCyan,
        "g": ansi.green,
        "G": ansi.brightGreen,
        "k": ansi.black,
        "K": ansi.brightBlack,
        "m": ansi.magenta,
        "M": ansi.brightMagenta,
        "r": ansi.red,
        "R": ansi.brightRed,
        "w": ansi.white,
        "W": ansi.brightWhite,
        "y": ansi.yellow,
        "Y": ansi.brightYellow
      },
      shiftedMarkup: {
        background: {
          ":": ansi.reset,
          " ": ansi.reset + " ",
          "b": ansi.bgBlue,
          "B": ansi.bgBrightBlue,
          "c": ansi.bgCyan,
          "C": ansi.bgBrightCyan,
          "g": ansi.bgGreen,
          "G": ansi.bgBrightGreen,
          "k": ansi.bgBlack,
          "K": ansi.bgBrightBlack,
          "m": ansi.bgMagenta,
          "M": ansi.bgBrightMagenta,
          "r": ansi.bgRed,
          "R": ansi.bgBrightRed,
          "w": ansi.bgWhite,
          "W": ansi.bgBrightWhite,
          "y": ansi.bgYellow,
          "Y": ansi.bgBrightYellow
        }
      }
    };
    exports.createFormatter = (options) => exports.formatMethod.bind(Object.assign({}, defaultFormatter, options));
    exports.format = exports.formatMethod.bind(defaultFormatter);
    exports.format.default = defaultFormatter;
    exports.markupMethod = function(str) {
      if (typeof str !== "string") {
        if (!str) {
          str = "";
        } else if (typeof str.toString === "function") {
          str = str.toString();
        } else {
          str = "";
        }
      }
      var hasMarkup = false, shift = null, markupStack = [];
      if (this.markupReset && this.startingMarkupReset) {
        str = (typeof this.markupReset === "function" ? this.markupReset(markupStack) : this.markupReset) + str;
      }
      str = str.replace(/\^(.?)/g, (match, markup) => {
        var replacement;
        if (markup === "^") {
          return "^";
        }
        if (this.shiftMarkup && this.shiftMarkup[markup]) {
          shift = this.shiftMarkup[markup];
          return "";
        }
        if (shift) {
          if (!this.shiftedMarkup || !this.shiftedMarkup[shift] || !this.shiftedMarkup[shift][markup]) {
            return "";
          }
          hasMarkup = true;
          if (typeof this.shiftedMarkup[shift][markup] === "function") {
            replacement = this.shiftedMarkup[shift][markup](markupStack);
          } else {
            replacement = this.shiftedMarkup[shift][markup];
            markupStack.push(replacement);
          }
          shift = null;
        } else {
          if (!this.markup || !this.markup[markup]) {
            return "";
          }
          hasMarkup = true;
          if (typeof this.markup[markup] === "function") {
            replacement = this.markup[markup](markupStack);
          } else {
            replacement = this.markup[markup];
            markupStack.push(replacement);
          }
        }
        return replacement;
      });
      if (hasMarkup && this.markupReset && this.endingMarkupReset) {
        str += typeof this.markupReset === "function" ? this.markupReset(markupStack) : this.markupReset;
      }
      return str;
    };
    exports.createMarkup = (options) => exports.markupMethod.bind(Object.assign({}, defaultFormatter, options));
    exports.markup = exports.markupMethod.bind(defaultFormatter);
    exports.format.count = function(str) {
      var match, index, relative, autoIndex = 1, maxIndex = 0;
      if (typeof str !== "string") {
        return 0;
      }
      var regexp = /%([+-]?)([0-9]*)(?:\[([^\]]*)\])?([a-zA-EG-Z])/g;
      while ((match = regexp.exec(str)) !== null) {
        relative = match[1];
        index = match[2];
        if (index) {
          index = parseInt(index, 10);
          if (relative) {
            if (relative === "+") {
              index = autoIndex + index;
            } else if (relative === "-") {
              index = autoIndex - index;
            }
          }
        } else {
          index = autoIndex;
        }
        autoIndex++;
        if (maxIndex < index) {
          maxIndex = index;
        }
      }
      return maxIndex;
    };
    exports.format.hasFormatting = function(str) {
      if (str.search(/\^(.?)|(%%)|%([+-]?)([0-9]*)(?:\[([^\]]*)\])?([a-zA-Z])/) !== -1) {
        return true;
      }
      return false;
    };
    const COMMON_MODE_ARG_FORMAT_REGEX = /([a-zA-Z])(.[^a-zA-Z]*)/g;
    const MODE_ARG_FORMAT_REGEX = /([a-zA-Z]|^)(.[^a-zA-Z]*)/g;
    function commonModeArg(str, modeArg) {
      var match, k, v;
      COMMON_MODE_ARG_FORMAT_REGEX.lastIndex = 0;
      while (match = COMMON_MODE_ARG_FORMAT_REGEX.exec(modeArg)) {
        [, k, v] = match;
        if (k === "L") {
          let width = unicode.width(str);
          v = +v || 1;
          if (width > v) {
            str = unicode.truncateWidth(str, v - 1).trim() + "\u2026";
            width = unicode.width(str);
          }
          if (width < v) {
            str = " ".repeat(v - width) + str;
          }
        } else if (k === "R") {
          let width = unicode.width(str);
          v = +v || 1;
          if (width > v) {
            str = unicode.truncateWidth(str, v - 1).trim() + "\u2026";
            width = unicode.width(str);
          }
          if (width < v) {
            str = str + " ".repeat(v - width);
          }
        }
      }
      return str;
    }
    function genericInspectMode(arg, modeArg, options, modeOptions, isInspectError = false) {
      var match, k, v, outputMaxLength, maxLength, depth = 3, style = options && options.color ? "color" : "none";
      if (modeArg) {
        MODE_ARG_FORMAT_REGEX.lastIndex = 0;
        while (match = MODE_ARG_FORMAT_REGEX.exec(modeArg)) {
          [, k, v] = match;
          if (k === "c") {
            if (v === "+") {
              style = "color";
            } else if (v === "-") {
              style = "none";
            }
          } else if (k === "l") {
            outputMaxLength = parseInt(v, 10) || void 0;
          } else if (k === "s") {
            maxLength = parseInt(v, 10) || void 0;
          } else if (!k) {
            depth = parseInt(v, 10) || 1;
          }
        }
      }
      if (isInspectError) {
        return inspectError(Object.assign({
          depth,
          style,
          outputMaxLength,
          maxLength
        }, modeOptions), arg);
      }
      return inspect(Object.assign({
        depth,
        style,
        outputMaxLength,
        maxLength
      }, modeOptions), arg);
    }
    const EPSILON = 1e-10;
    const INVERSE_EPSILON = Math.round(1 / EPSILON);
    function epsilonRound(v) {
      return Math.round(v * INVERSE_EPSILON) / INVERSE_EPSILON;
    }
    function epsilonFloor(v) {
      return Math.floor(v + EPSILON);
    }
    function round(v, step) {
      return epsilonRound(step * Math.round(v * (1 / step)));
    }
    const MUL_PREFIX = ["", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    const SUB_MUL_PREFIX = ["", "m", "\xB5", "n", "p", "f", "a", "z", "y"];
    const IROUND_STEP = [100, 10, 1];
    function metricPrefix(n) {
      var log, logDiv3, logMod, base, prefix;
      if (!n || n === 1) {
        return "" + n;
      }
      if (n < 0) {
        return "-" + metricPrefix(-n);
      }
      if (n > 1) {
        log = Math.floor(Math.log10(n));
        logDiv3 = Math.floor(log / 3);
        logMod = log % 3;
        base = iround(n / Math.pow(1e3, logDiv3), IROUND_STEP[logMod]);
        prefix = MUL_PREFIX[logDiv3];
      } else {
        log = Math.floor(Math.log10(n));
        logDiv3 = Math.floor(log / 3);
        logMod = log % 3;
        if (logMod < 0) {
          logMod += 3;
        }
        base = iround(n / Math.pow(1e3, logDiv3), IROUND_STEP[logMod]);
        prefix = SUB_MUL_PREFIX[-logDiv3];
      }
      return "" + base + prefix;
    }
    function iround(v, istep) {
      return Math.round((v + Number.EPSILON) * istep) / istep;
    }
  })(format);
  var misc$1 = {};
  misc$1.resize = function(str, length) {
    if (str.length === length) {
      return str;
    } else if (str.length > length) {
      return str.slice(0, length);
    }
    return str + " ".repeat(length - str.length);
  };
  misc$1.occurrenceCount = function(str, subStr, overlap = false) {
    if (!str || !subStr) {
      return 0;
    }
    var count = 0, index = 0, inc = overlap ? 1 : subStr.length;
    while ((index = str.indexOf(subStr, index)) !== -1) {
      count++;
      index += inc;
    }
    return count;
  };
  var regexp = {};
  (function(exports) {
    var escape2 = _escape;
    exports.regexp = {};
    exports.regexp.array2alternatives = function array2alternatives(array) {
      var i, sorted = array.slice();
      sorted.sort((a, b) => {
        return b.length - a.length;
      });
      for (i = 0; i < sorted.length; i++) {
        sorted[i] = escape2.regExpPattern(sorted[i]);
      }
      return sorted.join("|");
    };
  })(regexp);
  var camel = {};
  var camel_1 = camel;
  camel.toCamelCase = function(str, preserveUpperCase = false) {
    if (!str || typeof str !== "string") {
      return "";
    }
    return str.replace(/^[\s_-]*([^\s_-]+)|[\s_-]+([^\s_-]?)([^\s_-]*)/g, (match, firstWord, firstLetter, endOfWord) => {
      if (preserveUpperCase) {
        if (firstWord) {
          return firstWord;
        }
        if (!firstLetter) {
          return "";
        }
        return firstLetter.toUpperCase() + endOfWord;
      }
      if (firstWord) {
        return firstWord.toLowerCase();
      }
      if (!firstLetter) {
        return "";
      }
      return firstLetter.toUpperCase() + endOfWord.toLowerCase();
    });
  };
  camel.camelCaseToSeparated = function(str, separator = " ") {
    if (!str || typeof str !== "string") {
      return "";
    }
    return str.replace(/^([A-Z])|([A-Z])/g, (match, firstLetter, letter) => {
      if (firstLetter) {
        return firstLetter.toLowerCase();
      }
      return separator + letter.toLowerCase();
    });
  };
  camel.camelCaseToDash = camel.camelCaseToDashed = (str) => camel.camelCaseToSeparated(str, "-");
  const C = "c";
  var require$$0$1 = {
    "\u07C0": "0",
    "\u0301": "",
    "\xA0": " ",
    "\u24B6": "A",
    "\uFF21": "A",
    "\xC0": "A",
    "\xC1": "A",
    "\xC2": "A",
    "\u1EA6": "A",
    "\u1EA4": "A",
    "\u1EAA": "A",
    "\u1EA8": "A",
    "\xC3": "A",
    "\u0100": "A",
    "\u0102": "A",
    "\u1EB0": "A",
    "\u1EAE": "A",
    "\u1EB4": "A",
    "\u1EB2": "A",
    "\u0226": "A",
    "\u01E0": "A",
    "\xC4": "A",
    "\u01DE": "A",
    "\u1EA2": "A",
    "\xC5": "A",
    "\u01FA": "A",
    "\u01CD": "A",
    "\u0200": "A",
    "\u0202": "A",
    "\u1EA0": "A",
    "\u1EAC": "A",
    "\u1EB6": "A",
    "\u1E00": "A",
    "\u0104": "A",
    "\u023A": "A",
    "\u2C6F": "A",
    "\uA732": "AA",
    "\xC6": "AE",
    "\u01FC": "AE",
    "\u01E2": "AE",
    "\uA734": "AO",
    "\uA736": "AU",
    "\uA738": "AV",
    "\uA73A": "AV",
    "\uA73C": "AY",
    "\u24B7": "B",
    "\uFF22": "B",
    "\u1E02": "B",
    "\u1E04": "B",
    "\u1E06": "B",
    "\u0243": "B",
    "\u0181": "B",
    "\uFF43": "C",
    "\u24B8": "C",
    "\uFF23": "C",
    "\uA73E": "C",
    "\u1E08": "C",
    "\xC7": "C",
    "\u24B9": "D",
    "\uFF24": "D",
    "\u1E0A": "D",
    "\u010E": "D",
    "\u1E0C": "D",
    "\u1E10": "D",
    "\u1E12": "D",
    "\u1E0E": "D",
    "\u0110": "D",
    "\u018A": "D",
    "\u0189": "D",
    "\u1D05": "D",
    "\uA779": "D",
    "\xD0": "Dh",
    "\u01F1": "DZ",
    "\u01C4": "DZ",
    "\u01F2": "Dz",
    "\u01C5": "Dz",
    "\u025B": "E",
    "\u24BA": "E",
    "\uFF25": "E",
    "\xC8": "E",
    "\xC9": "E",
    "\xCA": "E",
    "\u1EC0": "E",
    "\u1EBE": "E",
    "\u1EC4": "E",
    "\u1EC2": "E",
    "\u1EBC": "E",
    "\u0112": "E",
    "\u1E14": "E",
    "\u1E16": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\xCB": "E",
    "\u1EBA": "E",
    "\u011A": "E",
    "\u0204": "E",
    "\u0206": "E",
    "\u1EB8": "E",
    "\u1EC6": "E",
    "\u0228": "E",
    "\u1E1C": "E",
    "\u0118": "E",
    "\u1E18": "E",
    "\u1E1A": "E",
    "\u0190": "E",
    "\u018E": "E",
    "\u1D07": "E",
    "\uA77C": "F",
    "\u24BB": "F",
    "\uFF26": "F",
    "\u1E1E": "F",
    "\u0191": "F",
    "\uA77B": "F",
    "\u24BC": "G",
    "\uFF27": "G",
    "\u01F4": "G",
    "\u011C": "G",
    "\u1E20": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u01E6": "G",
    "\u0122": "G",
    "\u01E4": "G",
    "\u0193": "G",
    "\uA7A0": "G",
    "\uA77D": "G",
    "\uA77E": "G",
    "\u0262": "G",
    "\u24BD": "H",
    "\uFF28": "H",
    "\u0124": "H",
    "\u1E22": "H",
    "\u1E26": "H",
    "\u021E": "H",
    "\u1E24": "H",
    "\u1E28": "H",
    "\u1E2A": "H",
    "\u0126": "H",
    "\u2C67": "H",
    "\u2C75": "H",
    "\uA78D": "H",
    "\u24BE": "I",
    "\uFF29": "I",
    "\xCC": "I",
    "\xCD": "I",
    "\xCE": "I",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u0130": "I",
    "\xCF": "I",
    "\u1E2E": "I",
    "\u1EC8": "I",
    "\u01CF": "I",
    "\u0208": "I",
    "\u020A": "I",
    "\u1ECA": "I",
    "\u012E": "I",
    "\u1E2C": "I",
    "\u0197": "I",
    "\u24BF": "J",
    "\uFF2A": "J",
    "\u0134": "J",
    "\u0248": "J",
    "\u0237": "J",
    "\u24C0": "K",
    "\uFF2B": "K",
    "\u1E30": "K",
    "\u01E8": "K",
    "\u1E32": "K",
    "\u0136": "K",
    "\u1E34": "K",
    "\u0198": "K",
    "\u2C69": "K",
    "\uA740": "K",
    "\uA742": "K",
    "\uA744": "K",
    "\uA7A2": "K",
    "\u24C1": "L",
    "\uFF2C": "L",
    "\u013F": "L",
    "\u0139": "L",
    "\u013D": "L",
    "\u1E36": "L",
    "\u1E38": "L",
    "\u013B": "L",
    "\u1E3C": "L",
    "\u1E3A": "L",
    "\u0141": "L",
    "\u023D": "L",
    "\u2C62": "L",
    "\u2C60": "L",
    "\uA748": "L",
    "\uA746": "L",
    "\uA780": "L",
    "\u01C7": "LJ",
    "\u01C8": "Lj",
    "\u24C2": "M",
    "\uFF2D": "M",
    "\u1E3E": "M",
    "\u1E40": "M",
    "\u1E42": "M",
    "\u2C6E": "M",
    "\u019C": "M",
    "\u03FB": "M",
    "\uA7A4": "N",
    "\u0220": "N",
    "\u24C3": "N",
    "\uFF2E": "N",
    "\u01F8": "N",
    "\u0143": "N",
    "\xD1": "N",
    "\u1E44": "N",
    "\u0147": "N",
    "\u1E46": "N",
    "\u0145": "N",
    "\u1E4A": "N",
    "\u1E48": "N",
    "\u019D": "N",
    "\uA790": "N",
    "\u1D0E": "N",
    "\u01CA": "NJ",
    "\u01CB": "Nj",
    "\u24C4": "O",
    "\uFF2F": "O",
    "\xD2": "O",
    "\xD3": "O",
    "\xD4": "O",
    "\u1ED2": "O",
    "\u1ED0": "O",
    "\u1ED6": "O",
    "\u1ED4": "O",
    "\xD5": "O",
    "\u1E4C": "O",
    "\u022C": "O",
    "\u1E4E": "O",
    "\u014C": "O",
    "\u1E50": "O",
    "\u1E52": "O",
    "\u014E": "O",
    "\u022E": "O",
    "\u0230": "O",
    "\xD6": "O",
    "\u022A": "O",
    "\u1ECE": "O",
    "\u0150": "O",
    "\u01D1": "O",
    "\u020C": "O",
    "\u020E": "O",
    "\u01A0": "O",
    "\u1EDC": "O",
    "\u1EDA": "O",
    "\u1EE0": "O",
    "\u1EDE": "O",
    "\u1EE2": "O",
    "\u1ECC": "O",
    "\u1ED8": "O",
    "\u01EA": "O",
    "\u01EC": "O",
    "\xD8": "O",
    "\u01FE": "O",
    "\u0186": "O",
    "\u019F": "O",
    "\uA74A": "O",
    "\uA74C": "O",
    "\u0152": "OE",
    "\u01A2": "OI",
    "\uA74E": "OO",
    "\u0222": "OU",
    "\u24C5": "P",
    "\uFF30": "P",
    "\u1E54": "P",
    "\u1E56": "P",
    "\u01A4": "P",
    "\u2C63": "P",
    "\uA750": "P",
    "\uA752": "P",
    "\uA754": "P",
    "\u24C6": "Q",
    "\uFF31": "Q",
    "\uA756": "Q",
    "\uA758": "Q",
    "\u024A": "Q",
    "\u24C7": "R",
    "\uFF32": "R",
    "\u0154": "R",
    "\u1E58": "R",
    "\u0158": "R",
    "\u0210": "R",
    "\u0212": "R",
    "\u1E5A": "R",
    "\u1E5C": "R",
    "\u0156": "R",
    "\u1E5E": "R",
    "\u024C": "R",
    "\u2C64": "R",
    "\uA75A": "R",
    "\uA7A6": "R",
    "\uA782": "R",
    "\u24C8": "S",
    "\uFF33": "S",
    "\u1E9E": "S",
    "\u015A": "S",
    "\u1E64": "S",
    "\u015C": "S",
    "\u1E60": "S",
    "\u0160": "S",
    "\u1E66": "S",
    "\u1E62": "S",
    "\u1E68": "S",
    "\u0218": "S",
    "\u015E": "S",
    "\u2C7E": "S",
    "\uA7A8": "S",
    "\uA784": "S",
    "\u24C9": "T",
    "\uFF34": "T",
    "\u1E6A": "T",
    "\u0164": "T",
    "\u1E6C": "T",
    "\u021A": "T",
    "\u0162": "T",
    "\u1E70": "T",
    "\u1E6E": "T",
    "\u0166": "T",
    "\u01AC": "T",
    "\u01AE": "T",
    "\u023E": "T",
    "\uA786": "T",
    "\xDE": "Th",
    "\uA728": "TZ",
    "\u24CA": "U",
    "\uFF35": "U",
    "\xD9": "U",
    "\xDA": "U",
    "\xDB": "U",
    "\u0168": "U",
    "\u1E78": "U",
    "\u016A": "U",
    "\u1E7A": "U",
    "\u016C": "U",
    "\xDC": "U",
    "\u01DB": "U",
    "\u01D7": "U",
    "\u01D5": "U",
    "\u01D9": "U",
    "\u1EE6": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u01D3": "U",
    "\u0214": "U",
    "\u0216": "U",
    "\u01AF": "U",
    "\u1EEA": "U",
    "\u1EE8": "U",
    "\u1EEE": "U",
    "\u1EEC": "U",
    "\u1EF0": "U",
    "\u1EE4": "U",
    "\u1E72": "U",
    "\u0172": "U",
    "\u1E76": "U",
    "\u1E74": "U",
    "\u0244": "U",
    "\u24CB": "V",
    "\uFF36": "V",
    "\u1E7C": "V",
    "\u1E7E": "V",
    "\u01B2": "V",
    "\uA75E": "V",
    "\u0245": "V",
    "\uA760": "VY",
    "\u24CC": "W",
    "\uFF37": "W",
    "\u1E80": "W",
    "\u1E82": "W",
    "\u0174": "W",
    "\u1E86": "W",
    "\u1E84": "W",
    "\u1E88": "W",
    "\u2C72": "W",
    "\u24CD": "X",
    "\uFF38": "X",
    "\u1E8A": "X",
    "\u1E8C": "X",
    "\u24CE": "Y",
    "\uFF39": "Y",
    "\u1EF2": "Y",
    "\xDD": "Y",
    "\u0176": "Y",
    "\u1EF8": "Y",
    "\u0232": "Y",
    "\u1E8E": "Y",
    "\u0178": "Y",
    "\u1EF6": "Y",
    "\u1EF4": "Y",
    "\u01B3": "Y",
    "\u024E": "Y",
    "\u1EFE": "Y",
    "\u24CF": "Z",
    "\uFF3A": "Z",
    "\u0179": "Z",
    "\u1E90": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u1E92": "Z",
    "\u1E94": "Z",
    "\u01B5": "Z",
    "\u0224": "Z",
    "\u2C7F": "Z",
    "\u2C6B": "Z",
    "\uA762": "Z",
    "\u24D0": "a",
    "\uFF41": "a",
    "\u1E9A": "a",
    "\xE0": "a",
    "\xE1": "a",
    "\xE2": "a",
    "\u1EA7": "a",
    "\u1EA5": "a",
    "\u1EAB": "a",
    "\u1EA9": "a",
    "\xE3": "a",
    "\u0101": "a",
    "\u0103": "a",
    "\u1EB1": "a",
    "\u1EAF": "a",
    "\u1EB5": "a",
    "\u1EB3": "a",
    "\u0227": "a",
    "\u01E1": "a",
    "\xE4": "a",
    "\u01DF": "a",
    "\u1EA3": "a",
    "\xE5": "a",
    "\u01FB": "a",
    "\u01CE": "a",
    "\u0201": "a",
    "\u0203": "a",
    "\u1EA1": "a",
    "\u1EAD": "a",
    "\u1EB7": "a",
    "\u1E01": "a",
    "\u0105": "a",
    "\u2C65": "a",
    "\u0250": "a",
    "\u0251": "a",
    "\uA733": "aa",
    "\xE6": "ae",
    "\u01FD": "ae",
    "\u01E3": "ae",
    "\uA735": "ao",
    "\uA737": "au",
    "\uA739": "av",
    "\uA73B": "av",
    "\uA73D": "ay",
    "\u24D1": "b",
    "\uFF42": "b",
    "\u1E03": "b",
    "\u1E05": "b",
    "\u1E07": "b",
    "\u0180": "b",
    "\u0183": "b",
    "\u0253": "b",
    "\u0182": "b",
    "\u24D2": "c",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\xE7": "c",
    "\u1E09": "c",
    "\u0188": "c",
    "\u023C": "c",
    "\uA73F": "c",
    "\u2184": "c",
    C,
    "\u0106": "c",
    "\u0108": "c",
    "\u010A": "c",
    "\u010C": "c",
    "\u0187": "c",
    "\u023B": "c",
    "\u24D3": "d",
    "\uFF44": "d",
    "\u1E0B": "d",
    "\u010F": "d",
    "\u1E0D": "d",
    "\u1E11": "d",
    "\u1E13": "d",
    "\u1E0F": "d",
    "\u0111": "d",
    "\u018C": "d",
    "\u0256": "d",
    "\u0257": "d",
    "\u018B": "d",
    "\u13E7": "d",
    "\u0501": "d",
    "\uA7AA": "d",
    "\xF0": "dh",
    "\u01F3": "dz",
    "\u01C6": "dz",
    "\u24D4": "e",
    "\uFF45": "e",
    "\xE8": "e",
    "\xE9": "e",
    "\xEA": "e",
    "\u1EC1": "e",
    "\u1EBF": "e",
    "\u1EC5": "e",
    "\u1EC3": "e",
    "\u1EBD": "e",
    "\u0113": "e",
    "\u1E15": "e",
    "\u1E17": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\xEB": "e",
    "\u1EBB": "e",
    "\u011B": "e",
    "\u0205": "e",
    "\u0207": "e",
    "\u1EB9": "e",
    "\u1EC7": "e",
    "\u0229": "e",
    "\u1E1D": "e",
    "\u0119": "e",
    "\u1E19": "e",
    "\u1E1B": "e",
    "\u0247": "e",
    "\u01DD": "e",
    "\u24D5": "f",
    "\uFF46": "f",
    "\u1E1F": "f",
    "\u0192": "f",
    "\uFB00": "ff",
    "\uFB01": "fi",
    "\uFB02": "fl",
    "\uFB03": "ffi",
    "\uFB04": "ffl",
    "\u24D6": "g",
    "\uFF47": "g",
    "\u01F5": "g",
    "\u011D": "g",
    "\u1E21": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u01E7": "g",
    "\u0123": "g",
    "\u01E5": "g",
    "\u0260": "g",
    "\uA7A1": "g",
    "\uA77F": "g",
    "\u1D79": "g",
    "\u24D7": "h",
    "\uFF48": "h",
    "\u0125": "h",
    "\u1E23": "h",
    "\u1E27": "h",
    "\u021F": "h",
    "\u1E25": "h",
    "\u1E29": "h",
    "\u1E2B": "h",
    "\u1E96": "h",
    "\u0127": "h",
    "\u2C68": "h",
    "\u2C76": "h",
    "\u0265": "h",
    "\u0195": "hv",
    "\u24D8": "i",
    "\uFF49": "i",
    "\xEC": "i",
    "\xED": "i",
    "\xEE": "i",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\xEF": "i",
    "\u1E2F": "i",
    "\u1EC9": "i",
    "\u01D0": "i",
    "\u0209": "i",
    "\u020B": "i",
    "\u1ECB": "i",
    "\u012F": "i",
    "\u1E2D": "i",
    "\u0268": "i",
    "\u0131": "i",
    "\u24D9": "j",
    "\uFF4A": "j",
    "\u0135": "j",
    "\u01F0": "j",
    "\u0249": "j",
    "\u24DA": "k",
    "\uFF4B": "k",
    "\u1E31": "k",
    "\u01E9": "k",
    "\u1E33": "k",
    "\u0137": "k",
    "\u1E35": "k",
    "\u0199": "k",
    "\u2C6A": "k",
    "\uA741": "k",
    "\uA743": "k",
    "\uA745": "k",
    "\uA7A3": "k",
    "\u24DB": "l",
    "\uFF4C": "l",
    "\u0140": "l",
    "\u013A": "l",
    "\u013E": "l",
    "\u1E37": "l",
    "\u1E39": "l",
    "\u013C": "l",
    "\u1E3D": "l",
    "\u1E3B": "l",
    "\u017F": "l",
    "\u0142": "l",
    "\u019A": "l",
    "\u026B": "l",
    "\u2C61": "l",
    "\uA749": "l",
    "\uA781": "l",
    "\uA747": "l",
    "\u026D": "l",
    "\u01C9": "lj",
    "\u24DC": "m",
    "\uFF4D": "m",
    "\u1E3F": "m",
    "\u1E41": "m",
    "\u1E43": "m",
    "\u0271": "m",
    "\u026F": "m",
    "\u24DD": "n",
    "\uFF4E": "n",
    "\u01F9": "n",
    "\u0144": "n",
    "\xF1": "n",
    "\u1E45": "n",
    "\u0148": "n",
    "\u1E47": "n",
    "\u0146": "n",
    "\u1E4B": "n",
    "\u1E49": "n",
    "\u019E": "n",
    "\u0272": "n",
    "\u0149": "n",
    "\uA791": "n",
    "\uA7A5": "n",
    "\u0509": "n",
    "\u01CC": "nj",
    "\u24DE": "o",
    "\uFF4F": "o",
    "\xF2": "o",
    "\xF3": "o",
    "\xF4": "o",
    "\u1ED3": "o",
    "\u1ED1": "o",
    "\u1ED7": "o",
    "\u1ED5": "o",
    "\xF5": "o",
    "\u1E4D": "o",
    "\u022D": "o",
    "\u1E4F": "o",
    "\u014D": "o",
    "\u1E51": "o",
    "\u1E53": "o",
    "\u014F": "o",
    "\u022F": "o",
    "\u0231": "o",
    "\xF6": "o",
    "\u022B": "o",
    "\u1ECF": "o",
    "\u0151": "o",
    "\u01D2": "o",
    "\u020D": "o",
    "\u020F": "o",
    "\u01A1": "o",
    "\u1EDD": "o",
    "\u1EDB": "o",
    "\u1EE1": "o",
    "\u1EDF": "o",
    "\u1EE3": "o",
    "\u1ECD": "o",
    "\u1ED9": "o",
    "\u01EB": "o",
    "\u01ED": "o",
    "\xF8": "o",
    "\u01FF": "o",
    "\uA74B": "o",
    "\uA74D": "o",
    "\u0275": "o",
    "\u0254": "o",
    "\u1D11": "o",
    "\u0153": "oe",
    "\u01A3": "oi",
    "\uA74F": "oo",
    "\u0223": "ou",
    "\u24DF": "p",
    "\uFF50": "p",
    "\u1E55": "p",
    "\u1E57": "p",
    "\u01A5": "p",
    "\u1D7D": "p",
    "\uA751": "p",
    "\uA753": "p",
    "\uA755": "p",
    "\u03C1": "p",
    "\u24E0": "q",
    "\uFF51": "q",
    "\u024B": "q",
    "\uA757": "q",
    "\uA759": "q",
    "\u24E1": "r",
    "\uFF52": "r",
    "\u0155": "r",
    "\u1E59": "r",
    "\u0159": "r",
    "\u0211": "r",
    "\u0213": "r",
    "\u1E5B": "r",
    "\u1E5D": "r",
    "\u0157": "r",
    "\u1E5F": "r",
    "\u024D": "r",
    "\u027D": "r",
    "\uA75B": "r",
    "\uA7A7": "r",
    "\uA783": "r",
    "\u24E2": "s",
    "\uFF53": "s",
    "\u015B": "s",
    "\u1E65": "s",
    "\u015D": "s",
    "\u1E61": "s",
    "\u0161": "s",
    "\u1E67": "s",
    "\u1E63": "s",
    "\u1E69": "s",
    "\u0219": "s",
    "\u015F": "s",
    "\u023F": "s",
    "\uA7A9": "s",
    "\uA785": "s",
    "\u1E9B": "s",
    "\u0282": "s",
    "\xDF": "ss",
    "\u24E3": "t",
    "\uFF54": "t",
    "\u1E6B": "t",
    "\u1E97": "t",
    "\u0165": "t",
    "\u1E6D": "t",
    "\u021B": "t",
    "\u0163": "t",
    "\u1E71": "t",
    "\u1E6F": "t",
    "\u0167": "t",
    "\u01AD": "t",
    "\u0288": "t",
    "\u2C66": "t",
    "\uA787": "t",
    "\xFE": "th",
    "\uA729": "tz",
    "\u24E4": "u",
    "\uFF55": "u",
    "\xF9": "u",
    "\xFA": "u",
    "\xFB": "u",
    "\u0169": "u",
    "\u1E79": "u",
    "\u016B": "u",
    "\u1E7B": "u",
    "\u016D": "u",
    "\xFC": "u",
    "\u01DC": "u",
    "\u01D8": "u",
    "\u01D6": "u",
    "\u01DA": "u",
    "\u1EE7": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u01D4": "u",
    "\u0215": "u",
    "\u0217": "u",
    "\u01B0": "u",
    "\u1EEB": "u",
    "\u1EE9": "u",
    "\u1EEF": "u",
    "\u1EED": "u",
    "\u1EF1": "u",
    "\u1EE5": "u",
    "\u1E73": "u",
    "\u0173": "u",
    "\u1E77": "u",
    "\u1E75": "u",
    "\u0289": "u",
    "\u24E5": "v",
    "\uFF56": "v",
    "\u1E7D": "v",
    "\u1E7F": "v",
    "\u028B": "v",
    "\uA75F": "v",
    "\u028C": "v",
    "\uA761": "vy",
    "\u24E6": "w",
    "\uFF57": "w",
    "\u1E81": "w",
    "\u1E83": "w",
    "\u0175": "w",
    "\u1E87": "w",
    "\u1E85": "w",
    "\u1E98": "w",
    "\u1E89": "w",
    "\u2C73": "w",
    "\u24E7": "x",
    "\uFF58": "x",
    "\u1E8B": "x",
    "\u1E8D": "x",
    "\u24E8": "y",
    "\uFF59": "y",
    "\u1EF3": "y",
    "\xFD": "y",
    "\u0177": "y",
    "\u1EF9": "y",
    "\u0233": "y",
    "\u1E8F": "y",
    "\xFF": "y",
    "\u1EF7": "y",
    "\u1E99": "y",
    "\u1EF5": "y",
    "\u01B4": "y",
    "\u024F": "y",
    "\u1EFF": "y",
    "\u24E9": "z",
    "\uFF5A": "z",
    "\u017A": "z",
    "\u1E91": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u1E93": "z",
    "\u1E95": "z",
    "\u01B6": "z",
    "\u0225": "z",
    "\u0240": "z",
    "\u2C6C": "z",
    "\uA763": "z"
  };
  var map = require$$0$1;
  var latinize = function(str) {
    return str.replace(/[^\u0000-\u007e]/g, (c) => {
      return map[c] || c;
    });
  };
  var toTitleCase = function toTitleCase(str, options) {
    if (!str || typeof str !== "string") {
      return "";
    }
    options = options || {};
    return str.replace(/[^\s_-]+/g, (part) => {
      if (options.zealous) {
        if (options.preserveAllCaps && part === part.toUpperCase()) {
          return part;
        }
        return part[0].toUpperCase() + part.slice(1).toLowerCase();
      }
      return part[0].toUpperCase() + part.slice(1);
    });
  };
  const unicode = unicode_1;
  const FRENCH_DOUBLE_GRAPH_TYPO = {
    "!": true,
    "?": true,
    ":": true,
    ";": true
  };
  var wordwrap = function wordwrap(str, options) {
    var start = 0, end, skipEnd, lineWidth, currentLine, currentWidth, length, lastEnd, lastWidth, lastWasSpace, charWidthFn, explicitNewLine = true, strArray = unicode.toArray(str), trimNewLine = false, line, lines = [];
    if (typeof options !== "object") {
      options = {width: options};
    }
    if (!options.width || typeof options.width !== "number" || options.width <= 0) {
      options.width = 80;
    }
    lineWidth = options.offset ? options.width - options.offset : options.width;
    if (typeof options.glue !== "string") {
      options.glue = "\n";
    }
    if (options.regroupFn) {
      strArray = options.regroupFn(strArray);
      charWidthFn = options.charWidthFn || unicode.width;
    } else {
      charWidthFn = options.charWidthFn || unicode.charWidth;
    }
    length = strArray.length;
    var getNextLine = () => {
      if (!explicitNewLine || trimNewLine) {
        while (strArray[start] === " ") {
          start++;
        }
        if (trimNewLine && strArray[start] === "\n") {
          explicitNewLine = true;
          start++;
        }
      }
      if (start >= length) {
        return null;
      }
      explicitNewLine = false;
      trimNewLine = false;
      lastWasSpace = false;
      end = lastEnd = start;
      currentWidth = lastWidth = 0;
      for (; ; ) {
        if (end >= length) {
          return strArray.slice(start, end).join("");
        }
        if (strArray[end] === "\n") {
          explicitNewLine = true;
          currentLine = strArray.slice(start, end++).join("");
          if (options.fill) {
            currentLine += " ".repeat(lineWidth - currentWidth);
          }
          return currentLine;
        }
        if (options.skipFn) {
          skipEnd = options.skipFn(strArray, end);
          if (skipEnd !== end) {
            end = skipEnd;
            continue;
          }
        }
        if (strArray[end] === " " && !lastWasSpace && !FRENCH_DOUBLE_GRAPH_TYPO[strArray[end + 1]]) {
          lastEnd = end;
          lastWidth = currentWidth;
        } else {
          lastWasSpace = false;
        }
        currentWidth += charWidthFn(strArray[end]);
        if (currentWidth > lineWidth) {
          trimNewLine = true;
          if (lastEnd !== start) {
            end = lastEnd;
          } else if (lineWidth < options.width) {
            end = start;
            return "";
          }
          currentLine = strArray.slice(start, end).join("");
          if (options.fill) {
            currentLine += " ".repeat(lineWidth - lastWidth);
          }
          return currentLine;
        }
        end++;
      }
    };
    while (start < length && (line = getNextLine()) !== null) {
      lines.push(line);
      start = end;
      lineWidth = options.width;
    }
    if (explicitNewLine) {
      lines.push("");
    }
    if (!options.noTrim && !options.fill) {
      lines = lines.map((line_, index) => index === lines.length - 1 ? line_ : line_.trimRight());
    }
    if (!options.noJoin) {
      lines = lines.join(options.glue);
    }
    if (options.updateOffset) {
      options.offset = currentWidth;
    }
    return lines;
  };
  const fuzzy = {};
  var fuzzy_1 = fuzzy;
  fuzzy.score = (input, pattern) => {
    if (input === pattern) {
      return 1;
    }
    if (input.length === 0 || pattern.length === 0) {
      return 0;
    }
    return Math.max(0, 1 - fuzzy.levenshtein(input, pattern) / pattern.length);
  };
  const DEFAULT_SCORE_LIMIT = 0;
  const DEFAULT_TOKEN_DISPARITY_PENALTY = 0.88;
  const DEFAULT_DELTA_RATE = 0.9;
  fuzzy.bestMatch = (input, patterns, options = {}) => {
    var bestScore = options.scoreLimit || DEFAULT_SCORE_LIMIT, i, iMax, currentScore, currentPattern, bestIndex = -1, bestPattern = null;
    for (i = 0, iMax = patterns.length; i < iMax; i++) {
      currentPattern = patterns[i];
      currentScore = fuzzy.score(input, currentPattern);
      if (currentScore === 1) {
        return options.indexOf ? i : currentPattern;
      }
      if (currentScore > bestScore) {
        bestScore = currentScore;
        bestPattern = currentPattern;
        bestIndex = i;
      }
    }
    return options.indexOf ? bestIndex : bestPattern;
  };
  fuzzy.topMatch = (input, patterns, options = {}) => {
    var scoreLimit = options.scoreLimit || DEFAULT_SCORE_LIMIT, deltaRate = options.deltaRate || DEFAULT_DELTA_RATE, i, iMax, patternScores;
    patternScores = patterns.map((pattern, index) => ({pattern, index, score: fuzzy.score(input, pattern)}));
    patternScores.sort((a, b) => b.score - a.score);
    if (patternScores[0].score <= scoreLimit) {
      return [];
    }
    scoreLimit = Math.max(scoreLimit, patternScores[0].score * deltaRate);
    for (i = 1, iMax = patternScores.length; i < iMax; i++) {
      if (patternScores[i].score < scoreLimit) {
        patternScores.length = i;
        break;
      }
    }
    return options.indexOf ? patternScores.map((e) => e.index) : patternScores.map((e) => e.pattern);
  };
  const englishBlackList = new Set([
    "a",
    "an",
    "the",
    "this",
    "that",
    "those",
    "some",
    "of",
    "in",
    "on",
    "at",
    "my",
    "your",
    "her",
    "his",
    "its",
    "our",
    "their"
  ]);
  function tokenize(str, blackList = englishBlackList) {
    return str.split(/[ '"/|,:_-]+/g).filter((s) => s && !blackList.has(s));
  }
  fuzzy.bestTokenMatch = (input, patterns, options = {}) => {
    var scoreLimit = options.scoreLimit || DEFAULT_SCORE_LIMIT, tokenDisparityPenalty = options.tokenDisparityPenalty || DEFAULT_TOKEN_DISPARITY_PENALTY, i, iMax, j, jMax, z, zMax, currentPattern, currentPatternTokens, currentPatternToken, currentPatternScore, bestPatternScore = scoreLimit, currentInputToken, currentScore, inputTokens = tokenize(input), bestScore, bestIndex = -1, bestPattern = null;
    if (!inputTokens.length || !patterns.length) {
      return options.indexOf ? bestIndex : bestPattern;
    }
    for (i = 0, iMax = patterns.length; i < iMax; i++) {
      currentPattern = patterns[i];
      currentPatternTokens = tokenize(currentPattern);
      currentPatternScore = 0;
      for (j = 0, jMax = inputTokens.length; j < jMax; j++) {
        currentInputToken = inputTokens[j];
        bestScore = 0;
        for (z = 0, zMax = currentPatternTokens.length; z < zMax; z++) {
          currentPatternToken = currentPatternTokens[z];
          currentScore = fuzzy.score(currentInputToken, currentPatternToken);
          if (currentScore > bestScore) {
            bestScore = currentScore;
            if (currentScore === 1) {
              break;
            }
          }
        }
        currentPatternScore += bestScore;
      }
      currentPatternScore /= inputTokens.length;
      if (inputTokens.length !== currentPatternTokens.length) {
        currentPatternScore *= __pow(tokenDisparityPenalty, Math.abs(currentPatternTokens.length - inputTokens.length));
      }
      if (currentPatternScore > bestPatternScore) {
        bestPatternScore = currentPatternScore;
        bestPattern = currentPattern;
        bestIndex = i;
      }
    }
    return options.indexOf ? bestIndex : bestPattern;
  };
  fuzzy.topTokenMatch = (input, patterns, options = {}) => {
    var scoreLimit = options.scoreLimit || DEFAULT_SCORE_LIMIT, tokenDisparityPenalty = options.tokenDisparityPenalty || DEFAULT_TOKEN_DISPARITY_PENALTY, deltaRate = options.deltaRate || DEFAULT_DELTA_RATE, i, iMax, j, jMax, z, zMax, currentPattern, currentPatternTokens, currentPatternToken, currentPatternScore, currentInputToken, currentScore, inputTokens = tokenize(input), bestScore, patternScores = [];
    if (!inputTokens.length || !patterns.length) {
      return [];
    }
    for (i = 0, iMax = patterns.length; i < iMax; i++) {
      currentPattern = patterns[i];
      currentPatternTokens = tokenize(currentPattern);
      currentPatternScore = 0;
      for (j = 0, jMax = inputTokens.length; j < jMax; j++) {
        currentInputToken = inputTokens[j];
        bestScore = 0;
        for (z = 0, zMax = currentPatternTokens.length; z < zMax; z++) {
          currentPatternToken = currentPatternTokens[z];
          currentScore = fuzzy.score(currentInputToken, currentPatternToken);
          if (currentScore > bestScore) {
            bestScore = currentScore;
            if (currentScore === 1) {
              break;
            }
          }
        }
        currentPatternScore += bestScore;
      }
      currentPatternScore /= inputTokens.length;
      if (inputTokens.length !== currentPatternTokens.length) {
        currentPatternScore *= __pow(tokenDisparityPenalty, Math.abs(currentPatternTokens.length - inputTokens.length));
      }
      patternScores.push({pattern: currentPattern, index: i, score: currentPatternScore});
    }
    patternScores.sort((a, b) => b.score - a.score);
    if (patternScores[0].score <= scoreLimit) {
      return [];
    }
    scoreLimit = Math.max(scoreLimit, patternScores[0].score * deltaRate);
    for (i = 1, iMax = patternScores.length; i < iMax; i++) {
      if (patternScores[i].score < scoreLimit) {
        patternScores.length = i;
        break;
      }
    }
    return options.indexOf ? patternScores.map((e) => e.index) : patternScores.map((e) => e.pattern);
  };
  const _tracker = [];
  const _leftCharCodeCache = [];
  fuzzy.levenshtein = (left, right) => {
    if (left === right) {
      return 0;
    }
    if (left.length > right.length) {
      let swap = left;
      left = right;
      right = swap;
    }
    let leftLength = left.length;
    let rightLength = right.length;
    while (leftLength > 0 && left.charCodeAt(leftLength - 1) === right.charCodeAt(rightLength - 1)) {
      leftLength--;
      rightLength--;
    }
    let start = 0;
    while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
      start++;
    }
    leftLength -= start;
    rightLength -= start;
    if (leftLength === 0) {
      return rightLength;
    }
    let rightCharCode;
    let result;
    let temp;
    let temp2;
    let i = 0;
    let j = 0;
    while (i < leftLength) {
      _leftCharCodeCache[i] = left.charCodeAt(start + i);
      _tracker[i] = ++i;
    }
    while (j < rightLength) {
      rightCharCode = right.charCodeAt(start + j);
      temp = j++;
      result = j;
      for (i = 0; i < leftLength; i++) {
        temp2 = rightCharCode === _leftCharCodeCache[i] ? temp : temp + 1;
        temp = _tracker[i];
        result = _tracker[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
      }
    }
    return result;
  };
  var stringKit = {};
  var string$4 = stringKit;
  var fn_;
  var polyfill = polyfill_1;
  for (fn_ in polyfill) {
    stringKit[fn_] = function(str, ...args) {
      return polyfill[fn_].call(str, ...args);
    };
  }
  Object.assign(stringKit, {escape: _escape}, {ansi: ansi$1}, {unicode: unicode_1});
  Object.assign(stringKit, format, misc$1, inspect$1, regexp, camel_1, {
    latinize,
    toTitleCase,
    wordwrap,
    naturalSort,
    fuzzy: fuzzy_1
  });
  stringKit.installPolyfills = function installPolyfills() {
    var fn;
    for (fn in polyfill) {
      if (!String.prototype[fn]) {
        String.prototype[fn] = polyfill[fn];
      }
    }
  };
  const string$3 = string$4;
  const misc = {};
  var misc_1 = misc;
  const colorNameToIndexDict = {
    black: 0,
    red: 1,
    green: 2,
    yellow: 3,
    blue: 4,
    magenta: 5,
    violet: 5,
    cyan: 6,
    white: 7,
    grey: 8,
    gray: 8,
    brightblack: 8,
    brightred: 9,
    brightgreen: 10,
    brightyellow: 11,
    brightblue: 12,
    brightmagenta: 13,
    brightviolet: 13,
    brightcyan: 14,
    brightwhite: 15
  };
  misc.colorNameToIndex = (color) => colorNameToIndexDict[color.toLowerCase()];
  const indexToColorNameArray = [
    "black",
    "red",
    "green",
    "yellow",
    "blue",
    "magenta",
    "cyan",
    "white",
    "gray",
    "brightRed",
    "brightGreen",
    "brightYellow",
    "brightBlue",
    "brightMagenta",
    "brightCyan",
    "brightWhite"
  ];
  misc.indexToColorName = (index) => indexToColorNameArray[index];
  misc.hexToRgba = (hex) => {
    if (hex[0] === "#") {
      hex = hex.slice(1);
    }
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    return {
      r: parseInt(hex.slice(0, 2), 16),
      g: parseInt(hex.slice(2, 4), 16),
      b: parseInt(hex.slice(4, 6), 16),
      a: hex.length > 6 ? parseInt(hex.slice(6, 8), 16) : 255
    };
  };
  misc.color2index = misc.colorNameToIndex;
  misc.index2color = misc.indexToColorName;
  misc.hexToColor = misc.hexToRgba;
  misc.stripControlChars = (str, newline) => {
    if (newline) {
      return str.replace(/[\x00-\x09\x0b-\x1f\x7f]/g, "");
    }
    return str.replace(/[\x00-\x1f\x7f]/g, "");
  };
  const escapeSequenceRegex = /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
  const escapeSequenceParserRegex = /([\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><])|([^\u001b\u009b]+)/g;
  misc.stripEscapeSequences = (str) => str.replace(escapeSequenceRegex, "");
  misc.ansiWidth = misc.stringWidth = (str) => {
    var matches, width = 0;
    escapeSequenceParserRegex.lastIndex = 0;
    while (matches = escapeSequenceParserRegex.exec(str)) {
      if (matches[2]) {
        width += string$3.unicode.width(matches[2]);
      }
    }
    return width;
  };
  var lastTruncateWidth = 0;
  misc.getLastTruncateWidth = () => lastTruncateWidth;
  misc.truncateAnsiString = misc.truncateString = (str, maxWidth) => {
    var matches, width = 0;
    lastTruncateWidth = 0;
    escapeSequenceParserRegex.lastIndex = 0;
    while (matches = escapeSequenceParserRegex.exec(str)) {
      if (matches[2]) {
        width += string$3.unicode.width(matches[2]);
        if (width >= maxWidth) {
          if (width === maxWidth) {
            return str.slice(0, matches.index + matches[2].length);
          }
          return str.slice(0, matches.index) + string$3.unicode.truncateWidth(matches[2], maxWidth - lastTruncateWidth);
        }
        lastTruncateWidth = width;
      }
    }
    return str;
  };
  misc.markupWidth = (str) => {
    return string$3.unicode.width(str.replace(/\^\[[^\]]*]|\^(.)/g, (match, second) => {
      if (second === " " || second === "^") {
        return second;
      }
      return "";
    }));
  };
  misc.truncateMarkupString = (str, maxWidth) => {
    var index = 0, charWidth, strArray = string$3.unicode.toArray(str);
    lastTruncateWidth = 0;
    while (index < strArray.length) {
      if (strArray[index] === "^") {
        index++;
        if (strArray[index] === "[") {
          while (index < strArray.length && strArray[index] !== "]") {
            index++;
          }
          index++;
          continue;
        }
        if (strArray[index] !== " " && strArray[index] !== "^") {
          index++;
          continue;
        }
      }
      charWidth = string$3.unicode.isFullWidth(strArray[index]) ? 2 : 1;
      if (lastTruncateWidth + charWidth > maxWidth) {
        strArray.length = index;
        return strArray.join("");
      }
      lastTruncateWidth += charWidth;
      index++;
    }
    return str;
  };
  misc.escapeSequenceSkipFn = (strArray, index) => {
    var code;
    if (strArray[index] !== "") {
      return index;
    }
    index++;
    if (strArray[index] !== "[") {
      return index;
    }
    index++;
    for (; index < strArray.length; index++) {
      code = strArray[index].charCodeAt(0);
      if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
        index++;
        break;
      }
    }
    return index;
  };
  misc.wordWrapAnsi = (str, width) => string$3.wordwrap(str, {
    width,
    noJoin: true,
    fill: true,
    regroupFn: (strArray) => {
      var sequence = "", csi = false, newStrArray = [];
      strArray.forEach((char) => {
        var charCode;
        if (csi) {
          sequence += char;
          charCode = char.charCodeAt(0);
          if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122) {
            newStrArray.push(sequence);
            sequence = "";
            csi = false;
          }
        } else if (sequence) {
          sequence += char;
          if (char === "[") {
            csi = true;
          } else {
            newStrArray.push(sequence);
            sequence = "";
          }
        } else if (char === "") {
          sequence = char;
        } else {
          newStrArray.push(char);
        }
      });
      return newStrArray;
    },
    charWidthFn: (char) => {
      if (char[0] === "") {
        return 0;
      }
      return string$3.unicode.charWidth(char);
    }
  });
  misc.wordwrapMarkup = misc.wordWrapMarkup = (str, width) => string$3.wordwrap(str, {
    width,
    noJoin: true,
    fill: true,
    regroupFn: (strArray) => {
      var markup = "", complexMarkup = false, newStrArray = [];
      strArray.forEach((char) => {
        if (complexMarkup) {
          markup += char;
          if (char === "]") {
            newStrArray.push(markup);
            markup = "";
            complexMarkup = false;
          }
        } else if (markup) {
          markup += char;
          if (char === "[") {
            complexMarkup = true;
          } else {
            newStrArray.push(markup);
            markup = "";
          }
        } else if (char === "^") {
          markup = char;
        } else {
          newStrArray.push(char);
        }
      });
      return newStrArray;
    },
    charWidthFn: (char) => {
      if (char[0] === "^" && char[1]) {
        if (char[1] === "^" || char[1] === " ") {
          return 1;
        }
        return 0;
      }
      return string$3.unicode.charWidth(char);
    }
  });
  misc.preserveMarkupFormat = string$3.createFormatter({
    argumentSanitizer: (str) => str.replace(/[\x00-\x1f\x7f^]/g, (char) => char === "^" ? "^^" : ""),
    noMarkup: true
  });
  misc.markupOptions = {
    complexMarkupAliases: {
      c: "color",
      fg: "color",
      bg: "bgColor"
    },
    shiftMarkup: {
      "#": "background"
    },
    markup: {
      ":": {reset: true},
      " ": {reset: true, raw: " "},
      ";": {reset: true, special: true},
      "-": {dim: true},
      "+": {bold: true},
      "_": {underline: true},
      "/": {italic: true},
      "!": {inverse: true},
      "k": {color: 0},
      "r": {color: 1},
      "g": {color: 2},
      "y": {color: 3},
      "b": {color: 4},
      "m": {color: 5},
      "c": {color: 6},
      "w": {color: 7},
      "K": {color: 8},
      "R": {color: 9},
      "G": {color: 10},
      "Y": {color: 11},
      "B": {color: 12},
      "M": {color: 13},
      "C": {color: 14},
      "W": {color: 15}
    },
    shiftedMarkup: {
      background: {
        ":": {reset: true, defaultColor: true, bgDefaultColor: true},
        " ": {
          reset: true,
          defaultColor: true,
          bgDefaultColor: true,
          raw: " "
        },
        ";": {
          reset: true,
          special: true,
          defaultColor: true,
          bgDefaultColor: true
        },
        "k": {bgColor: 0},
        "r": {bgColor: 1},
        "g": {bgColor: 2},
        "y": {bgColor: 3},
        "b": {bgColor: 4},
        "m": {bgColor: 5},
        "c": {bgColor: 6},
        "w": {bgColor: 7},
        "K": {bgColor: 8},
        "R": {bgColor: 9},
        "G": {bgColor: 10},
        "Y": {bgColor: 11},
        "B": {bgColor: 12},
        "M": {bgColor: 13},
        "C": {bgColor: 14},
        "W": {bgColor: 15}
      }
    }
  };
  const parseMarkupRegexp = /\^\[([^\]]*)]|\^(.)|([^^]+)/g;
  misc.parseMarkup = (str, options) => {
    var complex, markup, raw, match, base = options.markup, output = [];
    parseMarkupRegexp.lastIndex = 0;
    while (match = parseMarkupRegexp.exec(str)) {
      [, complex, markup, raw] = match;
      if (complex) {
        var custom = {};
        complex.split(",").forEach((part) => {
          var [k, v] = part.split(":");
          if (options.complexMarkupAliases[k]) {
            k = options.complexMarkupAliases[k];
          }
          custom[k] = v || true;
        });
        output.push({markup: custom});
      } else if (raw) {
        output.push(raw);
      } else if (markup === "^") {
        output.push("^");
      } else if (options.shiftMarkup[markup]) {
        base = options.shiftedMarkup[options.shiftMarkup[markup]];
        continue;
      } else if (base[markup]) {
        output.push({markup: base[markup]});
      }
      base = options.markup;
    }
    return output;
  };
  const ANSI_CODES = {
    "0": {reset: true},
    "1": {bold: true},
    "2": {dim: true},
    "22": {bold: false, dim: false},
    "3": {italic: true},
    "23": {italic: false},
    "4": {underline: true},
    "24": {underline: false},
    "5": {blink: true},
    "25": {blink: false},
    "7": {inverse: true},
    "27": {inverse: false},
    "8": {hidden: true},
    "28": {hidden: false},
    "9": {strike: true},
    "29": {strike: false},
    "30": {color: 0},
    "31": {color: 1},
    "32": {color: 2},
    "33": {color: 3},
    "34": {color: 4},
    "35": {color: 5},
    "36": {color: 6},
    "37": {color: 7},
    "39:": {defaultColor: true},
    "90": {color: 8},
    "91": {color: 9},
    "92": {color: 10},
    "93": {color: 11},
    "94": {color: 12},
    "95": {color: 13},
    "96": {color: 14},
    "97": {color: 15},
    "40": {bgColor: 0},
    "41": {bgColor: 1},
    "42": {bgColor: 2},
    "43": {bgColor: 3},
    "44": {bgColor: 4},
    "45": {bgColor: 5},
    "46": {bgColor: 6},
    "47": {bgColor: 7},
    "49:": {bgDefaultColor: true},
    "100": {bgColor: 8},
    "101": {bgColor: 9},
    "102": {bgColor: 10},
    "103": {bgColor: 11},
    "104": {bgColor: 12},
    "105": {bgColor: 13},
    "106": {bgColor: 14},
    "107": {bgColor: 15}
  };
  const parseAnsiRegexp = /\x1b\[([0-9;]+)m|(.[^\x1b]*)/g;
  misc.parseAnsi = (str) => {
    var match, ansiCodes, raw, output = [];
    parseAnsiRegexp.lastIndex = 0;
    while (match = parseAnsiRegexp.exec(str)) {
      [, ansiCodes, raw] = match;
      if (raw) {
        output.push(raw);
      } else {
        ansiCodes.split(/;/g).forEach((ansiCode) => {
          if (ANSI_CODES[ansiCode]) {
            output.push({markup: ANSI_CODES[ansiCode]});
          }
        });
      }
    }
    return output;
  };
  var detectTerminal = {};
  (function(global2, undefined$1) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = {callback, args};
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined$1, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event2) {
        if (event2.source === global2 && typeof event2.data === "string" && event2.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event2.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel();
      channel.port1.onmessage = function(event2) {
        var handle = event2.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof commonjsGlobal$2 === "undefined" ? commonjsGlobal$2 : commonjsGlobal$2 : self);
  const NativePromise = commonjsGlobal$2.Promise;
  var nextTick$1;
  if (!process.browser) {
    nextTick$1 = process.nextTick;
  } else {
    nextTick$1 = setImmediate;
  }
  function Promise$j(fn) {
    this.fn = fn;
    this._then = Promise$j._dormantThen;
    this.value = null;
    this.thenHandlers = null;
    this.handledRejection = null;
    if (this.fn) {
      this._exec();
    }
  }
  var core = Promise$j;
  Promise$j.Native = NativePromise;
  Promise$j.warnUnhandledRejection = true;
  Promise$j.prototype._exec = function() {
    this._then = Promise$j._pendingThen;
    try {
      this.fn((result_) => {
        this.resolve(result_);
      }, (error_) => {
        this.reject(error_);
      });
    } catch (error) {
      this.reject(error);
    }
  };
  Promise$j.prototype.resolve = Promise$j.prototype.fulfill = function(value) {
    if (this._then.settled) {
      return this;
    }
    if (Promise$j.isThenable(value)) {
      this._execThenPromise(value);
      return this;
    }
    return this._resolveValue(value);
  };
  Promise$j.prototype._resolveValue = function(value) {
    this._then = Promise$j._fulfilledThen;
    this.value = value;
    if (this.thenHandlers && this.thenHandlers.length) {
      this._execFulfillHandlers();
    }
    return this;
  };
  Promise$j.prototype._execThenPromise = function(thenPromise) {
    try {
      thenPromise.then((result_) => {
        this.resolve(result_);
      }, (error_) => {
        this.reject(error_);
      });
    } catch (error) {
      this.reject(error);
    }
  };
  Promise$j.prototype.reject = function(error) {
    if (this._then.settled) {
      return this;
    }
    this._then = Promise$j._rejectedThen;
    this.value = error;
    if (this.thenHandlers && this.thenHandlers.length) {
      this._execRejectionHandlers();
    } else if (Promise$j.warnUnhandledRejection && !this.handledRejection) {
      this._unhandledRejection();
    }
    return this;
  };
  Promise$j.prototype._execFulfillHandlers = function() {
    var i, length = this.thenHandlers.length;
    for (i = 0; i < length; i += 3) {
      if (this.thenHandlers[i + 1]) {
        this._execOneFulfillHandler(this.thenHandlers[i], this.thenHandlers[i + 1]);
      } else {
        this.thenHandlers[i].resolve(this.value);
      }
    }
  };
  Promise$j.prototype._execOneFulfillHandler = function(promise, onFulfill) {
    try {
      promise.resolve(onFulfill(this.value));
    } catch (error_) {
      promise.reject(error_);
    }
  };
  Promise$j.prototype._execRejectionHandlers = function() {
    var i, length = this.thenHandlers.length;
    for (i = 0; i < length; i += 3) {
      if (this.thenHandlers[i + 2]) {
        this._execOneRejectHandler(this.thenHandlers[i], this.thenHandlers[i + 2]);
      } else {
        this.thenHandlers[i].reject(this.value);
      }
    }
  };
  Promise$j.prototype._execOneRejectHandler = function(promise, onReject) {
    try {
      promise.resolve(onReject(this.value));
    } catch (error_) {
      promise.reject(error_);
    }
  };
  Promise$j.prototype.resolveTimeout = Promise$j.prototype.fulfillTimeout = function(time, result) {
    setTimeout(() => this.resolve(result), time);
  };
  Promise$j.prototype.rejectTimeout = function(time, error) {
    setTimeout(() => this.reject(error), time);
  };
  Promise$j._dormantThen = function(onFulfill, onReject) {
    if (this.fn) {
      this._exec();
      return this._then(onFulfill, onReject);
    }
    var promise = new Promise$j();
    if (!this.thenHandlers) {
      this.thenHandlers = [promise, onFulfill, onReject];
    } else {
      this.thenHandlers[this.thenHandlers.length] = promise;
      this.thenHandlers[this.thenHandlers.length] = onFulfill;
      this.thenHandlers[this.thenHandlers.length] = onReject;
    }
    return promise;
  };
  Promise$j._dormantThen.settled = false;
  Promise$j._pendingThen = function(onFulfill, onReject) {
    var promise = new Promise$j();
    if (!this.thenHandlers) {
      this.thenHandlers = [promise, onFulfill, onReject];
    } else {
      this.thenHandlers[this.thenHandlers.length] = promise;
      this.thenHandlers[this.thenHandlers.length] = onFulfill;
      this.thenHandlers[this.thenHandlers.length] = onReject;
    }
    return promise;
  };
  Promise$j._pendingThen.settled = false;
  Promise$j._fulfilledThen = function(onFulfill) {
    if (!onFulfill) {
      return this;
    }
    var promise = new Promise$j();
    nextTick$1(() => {
      try {
        promise.resolve(onFulfill(this.value));
      } catch (error) {
        promise.reject(error);
      }
    });
    return promise;
  };
  Promise$j._fulfilledThen.settled = true;
  Promise$j._rejectedThen = function(onFulfill, onReject) {
    if (!onReject) {
      return this;
    }
    this.handledRejection = true;
    var promise = new Promise$j();
    nextTick$1(() => {
      try {
        promise.resolve(onReject(this.value));
      } catch (error) {
        promise.reject(error);
      }
    });
    return promise;
  };
  Promise$j._rejectedThen.settled = true;
  Promise$j.prototype.then = function(onFulfill, onReject) {
    return this._then(onFulfill, onReject);
  };
  Promise$j.prototype.catch = function(onReject = () => void 0) {
    return this._then(void 0, onReject);
  };
  Promise$j.prototype.finally = function(onSettled) {
    return this._then(onSettled, onSettled);
  };
  Promise$j.prototype.tap = Promise$j.prototype.tapThen = function(onFulfill) {
    this._then(onFulfill, void 0);
    return this;
  };
  Promise$j.prototype.tapCatch = function(onReject) {
    this._then(void 0, onReject);
    return this;
  };
  Promise$j.prototype.tapFinally = function(onSettled) {
    this._then(onSettled, onSettled);
    return this;
  };
  Promise$j.prototype.fatal = function() {
    this._then(void 0, (error) => {
      nextTick$1(() => {
        throw error;
      });
    });
  };
  Promise$j.prototype.done = function(onFulfill, onReject) {
    this._then(onFulfill, onReject).fatal();
    return this;
  };
  Promise$j.prototype.callback = function(cb) {
    this._then((value) => {
      cb(void 0, value);
    }, (error) => {
      cb(error);
    }).fatal();
    return this;
  };
  Promise$j.prototype.callbackAll = function(cb) {
    this._then((values) => {
      if (Array.isArray(values)) {
        cb(void 0, ...values);
      } else {
        cb(void 0, values);
      }
    }, (error) => {
      cb(error);
    }).fatal();
    return this;
  };
  Promise$j.callback = function(fn) {
    return new Promise$j((resolve, reject) => {
      fn((error, arg) => {
        if (error) {
          reject(error);
        } else {
          resolve(arg);
        }
      });
    });
  };
  Promise$j.callbackAll = function(fn) {
    return new Promise$j((resolve, reject) => {
      fn((error, ...args) => {
        if (error) {
          reject(error);
        } else {
          resolve(args);
        }
      });
    });
  };
  Promise$j.prototype.toPromise = Promise$j.prototype.propagate = function(promise) {
    this._then((value) => {
      promise.resolve(value);
    }, (error) => {
      promise.reject(error);
    });
    return this;
  };
  Promise$j.propagate = function(foreignPromise, promise) {
    foreignPromise.then((value) => {
      promise.resolve(value);
    }, (error) => {
      promise.reject(error);
    });
    return foreignPromise;
  };
  Promise$j.finally = function(foreignPromise, onSettled) {
    return foreignPromise.then(onSettled, onSettled);
  };
  Promise$j.resolve = Promise$j.fulfill = function(value) {
    if (Promise$j.isThenable(value)) {
      return Promise$j.fromThenable(value);
    }
    return Promise$j._resolveValue(value);
  };
  Promise$j._resolveValue = function(value) {
    var promise = new Promise$j();
    promise._then = Promise$j._fulfilledThen;
    promise.value = value;
    return promise;
  };
  Promise$j.reject = function(error) {
    var promise = new Promise$j();
    promise._then = Promise$j._rejectedThen;
    promise.value = error;
    return promise;
  };
  Promise$j.resolveTimeout = Promise$j.fulfillTimeout = function(timeout, value) {
    return new Promise$j((resolve) => setTimeout(() => resolve(value), timeout));
  };
  Promise$j.rejectTimeout = function(timeout, error) {
    return new Promise$j((resolve, reject) => setTimeout(() => reject(error), timeout));
  };
  Promise$j.resolveNextTick = Promise$j.fulfillNextTick = function(value) {
    return new Promise$j((resolve) => nextTick$1(() => resolve(value)));
  };
  Promise$j.rejectNextTick = function(error) {
    return new Promise$j((resolve, reject) => nextTick$1(() => reject(error)));
  };
  Promise$j.dormant = function(fn) {
    var promise = new Promise$j();
    promise.fn = fn;
    return promise;
  };
  Promise$j.try = function(fn) {
    try {
      return Promise$j.resolve(fn());
    } catch (error) {
      return Promise$j.reject(error);
    }
  };
  Promise$j.isThenable = function(value) {
    return value && typeof value === "object" && typeof value.then === "function";
  };
  Promise$j.fromThenable = function(thenable) {
    if (thenable instanceof Promise$j) {
      return thenable;
    }
    return new Promise$j((resolve, reject) => {
      thenable.then((value) => {
        resolve(value);
      }, (error) => {
        reject(error);
      });
    });
  };
  Promise$j._bareThen = function(value, onFulfill, onReject) {
    if (value && typeof value === "object") {
      if (value instanceof Promise$j) {
        if (value._then === Promise$j._fulfilledThen) {
          onFulfill(value.value);
        } else if (value._then === Promise$j._rejectedThen) {
          onReject(value.value);
        } else {
          value._then(onFulfill, onReject);
        }
      } else if (typeof value.then === "function") {
        value.then(onFulfill, onReject);
      } else {
        onFulfill(value);
      }
    } else {
      onFulfill(value);
    }
  };
  Promise$j._handleAll = function(iterable) {
    var value;
    for (value of iterable) {
      if (Promise$j.isThenable(value)) {
        value.handledRejection = true;
      }
    }
  };
  Promise$j.prototype._unhandledRejection = function() {
    this.handledRejection = false;
    const nextTick_ = (cb) => setTimeout(cb, 0);
    if (this.value instanceof Error) {
      nextTick_(() => {
        if (this.handledRejection === false) {
          this.value.message = "Unhandled promise rejection: " + this.value.message;
          console.error(this.value);
        }
      });
    } else {
      let error_ = new Error("Unhandled promise rejection");
      nextTick_(() => {
        if (this.handledRejection === false) {
          console.error(error_);
          console.error("Rejection reason:", this.value);
        }
      });
    }
  };
  Promise$j.prototype.isSettled = function() {
    return this._then.settled;
  };
  Promise$j.prototype.getStatus = function() {
    switch (this._then) {
      case Promise$j._dormantThen:
        return "dormant";
      case Promise$j._pendingThen:
        return "pending";
      case Promise$j._fulfilledThen:
        return "fulfilled";
      case Promise$j._rejectedThen:
        return "rejected";
    }
  };
  Promise$j.prototype.inspect = function() {
    switch (this._then) {
      case Promise$j._dormantThen:
        return "Promise { <DORMANT> }";
      case Promise$j._pendingThen:
        return "Promise { <PENDING> }";
      case Promise$j._fulfilledThen:
        return "Promise { <FULFILLED> " + this.value + " }";
      case Promise$j._rejectedThen:
        return "Promise { <REJECTED> " + this.value + " }";
    }
  };
  Promise$j.resolved = Promise$j.dummy = Promise$j.resolve();
  if (process.browser) {
    Promise$j.prototype.resolveAtAnimationFrame = function(value) {
      window.requestAnimationFrame(() => this.resolve(value));
    };
    Promise$j.prototype.rejectAtAnimationFrame = function(error) {
      window.requestAnimationFrame(() => this.reject(error));
    };
    Promise$j.resolveAtAnimationFrame = function(value) {
      return new Promise$j((resolve) => window.requestAnimationFrame(() => resolve(value)));
    };
    Promise$j.rejectAtAnimationFrame = function(error) {
      return new Promise$j((resolve, reject) => window.requestAnimationFrame(() => reject(error)));
    };
  }
  const Promise$i = seventh_1;
  const HOLE = {};
  function noop$1() {
  }
  Promise$i.all = (iterable) => {
    var index = -1, settled = false, count = 0, length = Infinity, value, values = [], allPromise = new Promise$i();
    for (value of iterable) {
      if (settled) {
        break;
      }
      index++;
      (() => {
        const promiseIndex = index;
        Promise$i.resolve(value).then((value_) => {
          if (settled) {
            return;
          }
          values[promiseIndex] = value_;
          count++;
          if (count >= length) {
            settled = true;
            allPromise._resolveValue(values);
          }
        }, (error) => {
          if (settled) {
            return;
          }
          settled = true;
          allPromise.reject(error);
        });
      })();
    }
    length = index + 1;
    if (!length) {
      allPromise._resolveValue(values);
    }
    return allPromise;
  };
  Promise$i._allArray = (iterable) => {
    var length = iterable.length;
    if (!length) {
      Promise$i._resolveValue([]);
    }
    var index, runtime = {
      settled: false,
      count: 0,
      length,
      values: [],
      allPromise: new Promise$i()
    };
    for (index = 0; !runtime.settled && index < length; index++) {
      Promise$i._allArrayOne(iterable[index], index, runtime);
    }
    return runtime.allPromise;
  };
  Promise$i._allArrayOne = (value, index, runtime) => {
    Promise$i._bareThen(value, (value_) => {
      if (runtime.settled) {
        return;
      }
      runtime.values[index] = value_;
      runtime.count++;
      if (runtime.count >= runtime.length) {
        runtime.settled = true;
        runtime.allPromise._resolveValue(runtime.values);
      }
    }, (error) => {
      if (runtime.settled) {
        return;
      }
      runtime.settled = true;
      runtime.allPromise.reject(error);
    });
  };
  Promise$i.every = Promise$i.map = (iterable, iterator) => {
    var index = -1, settled = false, count = 0, length = Infinity, value, values = [], allPromise = new Promise$i();
    for (value of iterable) {
      if (settled) {
        break;
      }
      index++;
      (() => {
        const promiseIndex = index;
        Promise$i.resolve(value).then((value_) => {
          if (settled) {
            return;
          }
          return iterator(value_, promiseIndex);
        }).then((value_) => {
          if (settled) {
            return;
          }
          values[promiseIndex] = value_;
          count++;
          if (count >= length) {
            settled = true;
            allPromise._resolveValue(values);
          }
        }, (error) => {
          if (settled) {
            return;
          }
          settled = true;
          allPromise.reject(error);
        });
      })();
    }
    length = index + 1;
    if (!length) {
      allPromise._resolveValue(values);
    }
    return allPromise;
  };
  Promise$i.any = (iterable) => {
    var index = -1, settled = false, count = 0, length = Infinity, value, errors = [], anyPromise = new Promise$i();
    for (value of iterable) {
      if (settled) {
        break;
      }
      index++;
      (() => {
        const promiseIndex = index;
        Promise$i.resolve(value).then((value_) => {
          if (settled) {
            return;
          }
          settled = true;
          anyPromise._resolveValue(value_);
        }, (error) => {
          if (settled) {
            return;
          }
          errors[promiseIndex] = error;
          count++;
          if (count >= length) {
            settled = true;
            anyPromise.reject(errors);
          }
        });
      })();
    }
    length = index + 1;
    if (!length) {
      anyPromise.reject(new RangeError("Promise.any(): empty array"));
    }
    return anyPromise;
  };
  Promise$i.some = (iterable, iterator) => {
    var index = -1, settled = false, count = 0, length = Infinity, value, errors = [], anyPromise = new Promise$i();
    for (value of iterable) {
      if (settled) {
        break;
      }
      index++;
      (() => {
        const promiseIndex = index;
        Promise$i.resolve(value).then((value_) => {
          if (settled) {
            return;
          }
          return iterator(value_, promiseIndex);
        }).then((value_) => {
          if (settled) {
            return;
          }
          settled = true;
          anyPromise._resolveValue(value_);
        }, (error) => {
          if (settled) {
            return;
          }
          errors[promiseIndex] = error;
          count++;
          if (count >= length) {
            settled = true;
            anyPromise.reject(errors);
          }
        });
      })();
    }
    length = index + 1;
    if (!length) {
      anyPromise.reject(new RangeError("Promise.any(): empty array"));
    }
    return anyPromise;
  };
  Promise$i.filter = (iterable, iterator) => {
    var index = -1, settled = false, count = 0, length = Infinity, value, values = [], filterPromise = new Promise$i();
    for (value of iterable) {
      if (settled) {
        break;
      }
      index++;
      (() => {
        const promiseIndex = index;
        Promise$i.resolve(value).then((value_) => {
          if (settled) {
            return;
          }
          values[promiseIndex] = value_;
          return iterator(value_, promiseIndex);
        }).then((iteratorValue) => {
          if (settled) {
            return;
          }
          count++;
          if (!iteratorValue) {
            values[promiseIndex] = HOLE;
          }
          if (count >= length) {
            settled = true;
            values = values.filter((e) => e !== HOLE);
            filterPromise._resolveValue(values);
          }
        }, (error) => {
          if (settled) {
            return;
          }
          settled = true;
          filterPromise.reject(error);
        });
      })();
    }
    length = index + 1;
    if (!length) {
      filterPromise._resolveValue(values);
    } else if (count >= length) {
      settled = true;
      values = values.filter((e) => e !== HOLE);
      filterPromise._resolveValue(values);
    }
    return filterPromise;
  };
  Promise$i.foreach = Promise$i.forEach = function(iterable, iterator, accumulator) {
    var index = -1, isReduce = arguments.length >= 3, it = iterable[Symbol.iterator](), forEachPromise = new Promise$i(), lastPromise = Promise$i.resolve(accumulator);
    if (Promise$i.warnUnhandledRejection) {
      Promise$i._handleAll(iterable);
    }
    var nextElement = () => {
      lastPromise.then((accumulator_) => {
        let {value, done} = it.next();
        index++;
        if (done) {
          forEachPromise.resolve(accumulator_);
        } else {
          lastPromise = Promise$i.resolve(value).then(isReduce ? (value_) => iterator(accumulator_, value_, index) : (value_) => iterator(value_, index));
          nextElement();
        }
      }, (error) => {
        forEachPromise.reject(error);
        for (; ; ) {
          let {value, done} = it.next();
          if (done) {
            break;
          }
          if (Promise$i.isThenable(value)) {
            value.then(noop$1, noop$1);
          }
        }
      });
    };
    nextElement();
    return forEachPromise;
  };
  Promise$i.reduce = (iterable, iterator, accumulator) => {
    return Promise$i.forEach(iterable, iterator, accumulator);
  };
  Promise$i.mapObject = (inputObject, iterator) => {
    var settled = false, count = 0, i, key, keys = Object.keys(inputObject), length = keys.length, value, outputObject = {}, mapPromise = new Promise$i();
    for (i = 0; !settled && i < length; i++) {
      key = keys[i];
      value = inputObject[key];
      (() => {
        const promiseKey = key;
        Promise$i.resolve(value).then((value_) => {
          if (settled) {
            return;
          }
          return iterator(value_, promiseKey);
        }).then((value_) => {
          if (settled) {
            return;
          }
          outputObject[promiseKey] = value_;
          count++;
          if (count >= length) {
            settled = true;
            mapPromise._resolveValue(outputObject);
          }
        }, (error) => {
          if (settled) {
            return;
          }
          settled = true;
          mapPromise.reject(error);
        });
      })();
    }
    if (!length) {
      mapPromise._resolveValue(outputObject);
    }
    return mapPromise;
  };
  Promise$i.concurrent = (limit, iterable, iterator) => {
    var index = -1, settled = false, running = 0, count = 0, length = Infinity, value, done = false, values = [], it = iterable[Symbol.iterator](), concurrentPromise = new Promise$i();
    if (Promise$i.warnUnhandledRejection) {
      Promise$i._handleAll(iterable);
    }
    limit = +limit || 1;
    const runBatch = () => {
      while (!done && running < limit) {
        ({value, done} = it.next());
        if (done) {
          length = index + 1;
          if (count >= length) {
            settled = true;
            concurrentPromise._resolveValue(values);
            return;
          }
          break;
        }
        if (settled) {
          break;
        }
        index++;
        (() => {
          const promiseIndex = index;
          running++;
          Promise$i.resolve(value).then((value_) => {
            if (settled) {
              return;
            }
            return iterator(value_, promiseIndex);
          }).then((value_) => {
            if (settled) {
              return;
            }
            values[promiseIndex] = value_;
            count++;
            running--;
            if (count >= length) {
              settled = true;
              concurrentPromise._resolveValue(values);
              return;
            }
            if (running < limit) {
              runBatch();
              return;
            }
          }, (error) => {
            if (settled) {
              return;
            }
            settled = true;
            concurrentPromise.reject(error);
          });
        })();
      }
    };
    runBatch();
    if (index < 0) {
      concurrentPromise._resolveValue(values);
    }
    return concurrentPromise;
  };
  Promise$i.race = (iterable) => {
    var settled = false, value, racePromise = new Promise$i();
    for (value of iterable) {
      if (settled) {
        break;
      }
      Promise$i.resolve(value).then((value_) => {
        if (settled) {
          return;
        }
        settled = true;
        racePromise._resolveValue(value_);
      }, (error) => {
        if (settled) {
          return;
        }
        settled = true;
        racePromise.reject(error);
      });
    }
    return racePromise;
  };
  const Promise$h = seventh_1;
  Promise$h.timeLimit = (timeout, asyncFnOrPromise) => {
    return new Promise$h((resolve, reject) => {
      if (typeof asyncFnOrPromise === "function") {
        asyncFnOrPromise = asyncFnOrPromise();
      }
      Promise$h.resolve(asyncFnOrPromise).then(resolve, reject);
      setTimeout(() => reject(new Error("Timeout")), timeout);
    });
  };
  Promise$h.retry = (options, asyncFn) => {
    var count = options.retries || 1, coolDown = options.coolDown || 0, raiseFactor = options.raiseFactor || 1, maxCoolDown = options.maxCoolDown || Infinity, timeout = options.timeout || 0, catchFn = options.catch || null;
    const oneTry = () => {
      return (timeout ? Promise$h.timeLimit(timeout, asyncFn) : asyncFn()).catch((error) => {
        if (!count--) {
          throw error;
        }
        var currentCoolDown = coolDown;
        coolDown = Math.min(coolDown * raiseFactor, maxCoolDown);
        if (catchFn) {
          return Promise$h.resolve(catchFn(error)).then(() => Promise$h.resolveTimeout(currentCoolDown).then(oneTry));
        }
        return Promise$h.resolveTimeout(currentCoolDown).then(oneTry);
      });
    };
    return oneTry();
  };
  Promise$h.onceEvent = (emitter, eventName) => {
    return new Promise$h((resolve) => emitter.once(eventName, resolve));
  };
  Promise$h.onceEventAll = (emitter, eventName) => {
    return new Promise$h((resolve) => emitter.once(eventName, (...args) => resolve(args)));
  };
  Promise$h.onceEventOrError = (emitter, eventName, excludeEvents, _internalAllArgs = false) => {
    return new Promise$h((resolve, reject) => {
      var altRejects;
      var resolve_ = (...args) => {
        emitter.removeListener("error", reject_);
        if (altRejects) {
          for (let event2 in altRejects) {
            emitter.removeListener(event2, altRejects[event2]);
          }
        }
        resolve(_internalAllArgs ? args : args[0]);
      };
      var reject_ = (arg) => {
        emitter.removeListener(eventName, resolve_);
        if (altRejects) {
          for (let event2 in altRejects) {
            emitter.removeListener(event2, altRejects[event2]);
          }
        }
        reject(arg);
      };
      emitter.once(eventName, resolve_);
      emitter.once("error", reject_);
      if (excludeEvents) {
        if (!Array.isArray(excludeEvents)) {
          excludeEvents = [excludeEvents];
        }
        altRejects = {};
        excludeEvents.forEach((event2) => {
          var altReject = (...args) => {
            emitter.removeListener("error", reject_);
            emitter.removeListener(eventName, resolve_);
            var error = new Error("Received an excluded event: " + event2);
            error.event = event2;
            error.eventArgs = args;
            reject(error);
          };
          emitter.once(event2, altReject);
          altRejects[event2] = altReject;
        });
      }
    });
  };
  Promise$h.onceEventAllOrError = (emitter, eventName, excludeEvents) => {
    return Promise$h.onceEventOrError(emitter, eventName, excludeEvents, true);
  };
  const Promise$g = seventh_1;
  Promise$g.promisifyAll = (nodeAsyncFn, thisBinding) => {
    if (thisBinding) {
      return (...args) => {
        return new Promise$g((resolve, reject) => {
          nodeAsyncFn.call(thisBinding, ...args, (error, ...cbArgs) => {
            if (error) {
              if (cbArgs.length && error instanceof Error) {
                error.args = cbArgs;
              }
              reject(error);
            } else {
              resolve(cbArgs);
            }
          });
        });
      };
    }
    return function(...args) {
      return new Promise$g((resolve, reject) => {
        nodeAsyncFn.call(this, ...args, (error, ...cbArgs) => {
          if (error) {
            if (cbArgs.length && error instanceof Error) {
              error.args = cbArgs;
            }
            reject(error);
          } else {
            resolve(cbArgs);
          }
        });
      });
    };
  };
  Promise$g.promisify = (nodeAsyncFn, thisBinding) => {
    if (thisBinding) {
      return (...args) => {
        return new Promise$g((resolve, reject) => {
          nodeAsyncFn.call(thisBinding, ...args, (error, cbArg) => {
            if (error) {
              if (cbArg !== void 0 && error instanceof Error) {
                error.arg = cbArg;
              }
              reject(error);
            } else {
              resolve(cbArg);
            }
          });
        });
      };
    }
    return function(...args) {
      return new Promise$g((resolve, reject) => {
        nodeAsyncFn.call(this, ...args, (error, cbArg) => {
          if (error) {
            if (cbArg !== void 0 && error instanceof Error) {
              error.arg = cbArg;
            }
            reject(error);
          } else {
            resolve(cbArg);
          }
        });
      });
    };
  };
  Promise$g.returnValueInterceptor = (interceptor, asyncFn, thisBinding) => {
    return function(...args) {
      var returnVal = asyncFn.call(thisBinding || this, ...args);
      interceptor(returnVal);
      return returnVal;
    };
  };
  Promise$g.once = (asyncFn, thisBinding) => {
    var triggered = false;
    var result;
    return function(...args) {
      if (!triggered) {
        triggered = true;
        result = asyncFn.call(thisBinding || this, ...args);
      }
      return result;
    };
  };
  Promise$g.serialize = (asyncFn, thisBinding) => {
    var lastPromise = new Promise$g.resolve();
    return function(...args) {
      var promise = new Promise$g();
      lastPromise.finally(() => {
        Promise$g.propagate(asyncFn.call(thisBinding || this, ...args), promise);
      });
      lastPromise = promise;
      return promise;
    };
  };
  Promise$g.debounce = (asyncFn, thisBinding) => {
    var inProgress = null;
    const outWrapper = () => {
      inProgress = null;
    };
    return function(...args) {
      if (inProgress) {
        return inProgress;
      }
      inProgress = asyncFn.call(thisBinding || this, ...args);
      Promise$g.finally(inProgress, outWrapper);
      return inProgress;
    };
  };
  Promise$g.debounceDelay = (delay, asyncFn, thisBinding) => {
    var inProgress = null;
    const outWrapper = () => {
      setTimeout(() => inProgress = null, delay);
    };
    return function(...args) {
      if (inProgress) {
        return inProgress;
      }
      inProgress = asyncFn.call(thisBinding || this, ...args);
      Promise$g.finally(inProgress, outWrapper);
      return inProgress;
    };
  };
  Promise$g.debounceUpdate = (asyncFn, thisBinding) => {
    var inProgress = null;
    var nextUpdateWith = null;
    var nextUpdatePromise = null;
    const outWrapper = () => {
      var args, sharedPromise;
      inProgress = null;
      if (nextUpdateWith) {
        args = nextUpdateWith;
        nextUpdateWith = null;
        sharedPromise = nextUpdatePromise;
        nextUpdatePromise = null;
        inProgress = asyncFn.call(...args);
        Promise$g.propagate(inProgress, sharedPromise);
        Promise$g.finally(inProgress, outWrapper);
        return inProgress;
      }
    };
    return function(...args) {
      var localThis = thisBinding || this;
      if (inProgress) {
        if (!nextUpdatePromise) {
          nextUpdatePromise = new Promise$g();
        }
        nextUpdateWith = [localThis, ...args];
        return nextUpdatePromise;
      }
      inProgress = asyncFn.call(localThis, ...args);
      Promise$g.finally(inProgress, outWrapper);
      return inProgress;
    };
  };
  Promise$g.NO_DELAY = {};
  Promise$g.BATCH_NO_DELAY = {};
  Promise$g.debounceSync = (getParams, fullSyncParams) => {
    var perResourceData = new Map();
    const getResourceData = (resourceId) => {
      var resourceData = perResourceData.get(resourceId);
      if (!resourceData) {
        resourceData = {
          inProgress: null,
          inProgressIsFull: null,
          last: null,
          lastTime: null,
          lastFullSync: null,
          lastFullSyncTime: null,
          nextFullSyncPromise: null,
          nextFullSyncWith: null,
          noDelayBatches: new Set()
        };
        perResourceData.set(resourceId, resourceData);
      }
      return resourceData;
    };
    const outWrapper = (resourceData, level) => {
      var delta, args, sharedPromise, now = new Date();
      resourceData.inProgress = null;
      if (level >= 2) {
        resourceData.lastFullSyncTime = resourceData.lastTime = now;
      } else if (level >= 1) {
        resourceData.lastTime = now;
      }
      if (resourceData.nextFullSyncWith) {
        if (fullSyncParams.delay && resourceData.lastFullSyncTime && (delta = now - resourceData.lastFullSyncTime - fullSyncParams.delay) < 0) {
          resourceData.inProgress = Promise$g.resolveTimeout(-delta + 1);
          resourceData.inProgress.finally(() => outWrapper(resourceData, 0));
          return resourceData.nextFullSyncPromise;
        }
        args = resourceData.nextFullSyncWith;
        resourceData.nextFullSyncWith = null;
        sharedPromise = resourceData.nextFullSyncPromise;
        resourceData.nextFullSyncPromise = null;
        resourceData.lastFullSync = resourceData.last = resourceData.inProgress = fullSyncParams.fn.call(...args);
        Promise$g.propagate(resourceData.inProgress, sharedPromise);
        Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 2));
        return resourceData.inProgress;
      }
    };
    const getInWrapper = function(resourceId, ...args) {
      var noDelay = false, localThis = getParams.thisBinding || this, resourceData = getResourceData(resourceId);
      if (args[0] === Promise$g.NO_DELAY) {
        noDelay = true;
        args.shift();
      } else if (args[0] === Promise$g.BATCH_NO_DELAY) {
        args.shift();
        let batchId = args.shift();
        if (!resourceData.noDelayBatches.has(batchId)) {
          resourceData.noDelayBatches.add(batchId);
          noDelay = true;
        }
      }
      if (resourceData.inProgress) {
        return resourceData.inProgress;
      }
      if (!noDelay && getParams.delay && resourceData.lastTime && new Date() - resourceData.lastTime < getParams.delay) {
        if (typeof getParams.onDebounce === "function") {
          getParams.onDebounce(resourceId, ...args);
        }
        return resourceData.last;
      }
      resourceData.last = resourceData.inProgress = getParams.fn.call(localThis, resourceId, ...args);
      resourceData.inProgressIsFull = false;
      Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 1));
      return resourceData.inProgress;
    };
    const fullSyncInWrapper = function(resourceId, ...args) {
      var delta, noDelay = false, localThis = fullSyncParams.thisBinding || this, resourceData = getResourceData(resourceId);
      if (args[0] === Promise$g.NO_DELAY) {
        noDelay = true;
        args.shift();
      } else if (args[0] === Promise$g.BATCH_NO_DELAY) {
        args.shift();
        let batchId = args.shift();
        if (!resourceData.noDelayBatches.has(batchId)) {
          resourceData.noDelayBatches.add(batchId);
          noDelay = true;
        }
      }
      if (!resourceData.inProgress && !noDelay && fullSyncParams.delay && resourceData.lastFullSyncTime && (delta = new Date() - resourceData.lastFullSyncTime - fullSyncParams.delay) < 0) {
        resourceData.inProgress = Promise$g.resolveTimeout(-delta + 1);
        Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 0));
      }
      if (resourceData.inProgress) {
        if (!resourceData.nextFullSyncPromise) {
          resourceData.nextFullSyncPromise = new Promise$g();
        }
        resourceData.nextFullSyncWith = [localThis, resourceId, ...args];
        return resourceData.nextFullSyncPromise;
      }
      resourceData.lastFullSync = resourceData.last = resourceData.inProgress = fullSyncParams.fn.call(localThis, resourceId, ...args);
      Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 2));
      return resourceData.inProgress;
    };
    return [getInWrapper, fullSyncInWrapper];
  };
  Promise$g.timeout = (timeout, asyncFn, thisBinding) => {
    return function(...args) {
      var promise = asyncFn.call(thisBinding || this, ...args);
      setTimeout(() => promise.reject(new Error("Timeout")), timeout);
      return promise;
    };
  };
  Promise$g.variableTimeout = (asyncFn, thisBinding) => {
    return function(timeout, ...args) {
      var promise = asyncFn.call(thisBinding || this, ...args);
      setTimeout(() => promise.reject(new Error("Timeout")), timeout);
      return promise;
    };
  };
  const Promise$f = seventh_1;
  function Queue(jobRunner, concurrency = 4) {
    this.jobRunner = jobRunner;
    this.jobs = new Map();
    this.pendingJobs = new Map();
    this.runningJobs = new Map();
    this.errorJobs = new Map();
    this.jobsDone = new Map();
    this.concurrency = +concurrency || 1;
    this.isQueueRunning = true;
    this.isLoopRunning = false;
    this.canLoopAgain = false;
    this.ready = Promise$f.resolved;
    this.startTime = null;
    this.endTime = null;
    this.drained = Promise$f.resolved;
    this.idle = Promise$f.resolved;
  }
  Promise$f.Queue = Queue;
  function Job(id, dependencies = null, data = void 0) {
    this.id = id;
    this.dependencies = dependencies === null ? null : [...dependencies];
    this.data = data === void 0 ? id : data;
    this.error = null;
    this.startTime = null;
    this.endTime = null;
  }
  Queue.Job = Job;
  Queue.prototype.setConcurrency = function(concurrency) {
    this.concurrency = +concurrency || 1;
  };
  Queue.prototype.stop = Queue.prototype.pause = function() {
    this.isQueueRunning = false;
  };
  Queue.prototype.has = function(id) {
    return this.jobs.has(id);
  };
  Queue.prototype.add = Queue.prototype.addJob = function(id, data, dependencies = null) {
    if (this.jobs.has(id)) {
      return false;
    }
    var job = new Job(id, dependencies, data);
    this.jobs.set(id, job);
    this.pendingJobs.set(id, job);
    this.canLoopAgain = true;
    if (this.isQueueRunning && !this.isLoopRunning) {
      this.run();
    }
    if (this.drained.isSettled()) {
      this.drained = new Promise$f();
    }
    return job;
  };
  Queue.prototype.addBatch = Queue.prototype.addJobBatch = function(ids) {
    var id, job;
    for (id of ids) {
      if (this.jobs.has(id)) {
        return false;
      }
      job = new Job(id);
      this.jobs.set(id, job);
      this.pendingJobs.set(id, job);
    }
    this.canLoopAgain = true;
    if (this.isQueueRunning && !this.isLoopRunning) {
      this.run();
    }
    if (this.drained.isSettled()) {
      this.drained = new Promise$f();
    }
  };
  Queue.prototype.run = Queue.prototype.resume = function() {
    return __async(this, null, function* () {
      var job;
      this.isQueueRunning = true;
      if (this.isLoopRunning) {
        return;
      }
      this.isLoopRunning = true;
      if (!this.startTime) {
        this.startTime = Date.now();
      }
      do {
        this.canLoopAgain = false;
        for (job of this.pendingJobs.values()) {
          if (job.dependencies && job.dependencies.some((dependencyId) => !this.jobsDone.has(dependencyId))) {
            continue;
          }
          if (this.idle.isSettled()) {
            this.idle = new Promise$f();
          }
          this.canLoopAgain = true;
          yield this.ready;
          if (!this.isQueueRunning) {
            this.finishRun();
            return;
          }
          this.runJob(job);
        }
      } while (this.canLoopAgain);
      this.finishRun();
    });
  };
  Queue.prototype.finishRun = function() {
    this.isLoopRunning = false;
    if (!this.pendingJobs.size) {
      this.drained.resolve();
    }
    if (!this.runningJobs.size) {
      this.endTime = Date.now();
      this.idle.resolve();
    }
  };
  Queue.prototype.runJob = function(job) {
    return __async(this, null, function* () {
      this.pendingJobs.delete(job.id);
      this.runningJobs.set(job.id, job);
      if (this.runningJobs.size >= this.concurrency) {
        this.ready = new Promise$f();
      }
      try {
        job.startTime = Date.now();
        yield this.jobRunner(job.data);
        job.endTime = Date.now();
        this.jobsDone.set(job.id, job);
        this.canLoopAgain = true;
      } catch (error) {
        job.endTime = Date.now();
        job.error = error;
        this.errorJobs.set(job.id, job);
      }
      this.runningJobs.delete(job.id);
      if (this.runningJobs.size < this.concurrency) {
        this.ready.resolve();
      }
      if (!this.isLoopRunning) {
        if (this.isQueueRunning && this.pendingJobs.size) {
          this.run();
        } else {
          this.finishRun();
        }
      }
    });
  };
  Queue.prototype.getJobTimes = function() {
    var job, stats = {};
    for (job of this.jobsDone.values()) {
      stats[job.id] = job.endTime - job.startTime;
    }
    return stats;
  };
  Queue.prototype.getStats = function() {
    var job, sum = 0, stats = {
      pending: this.pendingJobs.size,
      running: this.runningJobs.size,
      failed: this.errorJobs.size,
      done: this.jobsDone.size,
      averageJobTime: null,
      queueTime: null
    };
    if (this.jobsDone.size) {
      for (job of this.jobsDone.values()) {
        sum += job.endTime - job.startTime;
      }
      stats.averageJobTime = sum / this.jobsDone.size;
    }
    if (this.endTime) {
      stats.queueTime = this.endTime - this.startTime;
    }
    return stats;
  };
  const Promise$e = seventh_1;
  Promise$e.promisifyNodeApi = (api, suffix, multiSuffix, filter, anything) => {
    var keys;
    suffix = suffix || "Async";
    multiSuffix = multiSuffix || "AsyncAll";
    filter = filter || ((key) => key[0] !== "_" && !key.endsWith("Sync"));
    if (anything) {
      keys = [];
      for (let key in api) {
        if (typeof api[key] === "function") {
          keys.push(key);
        }
      }
    } else {
      keys = Object.keys(api);
    }
    keys.filter((key) => {
      if (typeof api[key] !== "function") {
        return false;
      }
      for (let trash in api[key].prototype) {
        return false;
      }
      return filter(key, api);
    }).forEach((key) => {
      const targetKey = key + suffix;
      const multiTargetKey = key + multiSuffix;
      if (!api[targetKey]) {
        api[targetKey] = Promise$e.promisify(api[key], api);
      }
      if (!api[multiTargetKey]) {
        api[multiTargetKey] = Promise$e.promisifyAll(api[key], api);
      }
    });
  };
  Promise$e.promisifyAnyNodeApi = (api, suffix, multiSuffix, filter) => {
    Promise$e.promisifyNodeApi(api, suffix, multiSuffix, filter, true);
  };
  const Promise$d = seventh_1;
  Promise$d.parasite = () => {
    var compatibleProtoFn = [
      "tap",
      "tapCatch",
      "finally",
      "fatal",
      "done",
      "callback",
      "callbackAll"
    ];
    compatibleProtoFn.forEach((fn) => Promise$d.Native.prototype[fn] = Promise$d.prototype[fn]);
    Promise$d.Native.prototype._then = Promise$d.Native.prototype.then;
  };
  const Promise$c = seventh_1;
  var exitInProgress = false;
  Promise$c.asyncExit = function(exitCode, timeout) {
    if (exitInProgress) {
      return;
    }
    exitInProgress = true;
    var listeners = process.listeners("asyncExit");
    if (!listeners.length) {
      process.exit(exitCode);
      return;
    }
    if (timeout === void 0) {
      timeout = 1e3;
    }
    const callListener = (listener) => {
      if (listener.length < 3) {
        listener(exitCode, timeout);
        return Promise$c.dummy;
      }
      return new Promise$c((resolve) => {
        listener(exitCode, timeout, () => {
          resolve();
        });
      });
    };
    Promise$c.map(listeners, callListener).finally(() => process.exit(exitCode));
    setTimeout(() => process.exit(exitCode), timeout);
  };
  Promise$c.resolveSafeTimeout = function(timeout, value) {
    return new Promise$c((resolve) => {
      setTimeout(() => {
        setTimeout(() => {
          setTimeout(() => {
            setTimeout(() => resolve(value), 0);
          }, timeout / 2);
        }, timeout / 2);
      }, 0);
    });
  };
  const seventh = core;
  var seventh_1 = seventh;
  var __viteBrowserExternal_child_process = new Proxy({}, {
    get() {
      throw new Error('Module "child_process" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_child_process$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_child_process});
  var require$$2 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_child_process$1);
  var __viteBrowserExternal_os = new Proxy({}, {
    get() {
      throw new Error('Module "os" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_os$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_os});
  var require$$3 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal_os$1);
  const Promise$b = seventh_1;
  const exec = require$$2.exec;
  const path$2 = require$$3$1;
  const os = require$$3;
  const termkit$4 = termkit_1;
  detectTerminal.guessTerminal = function(unpipe) {
    var envVar;
    var isSSH = !!{}.SSH_CONNECTION;
    var isTTY = !!process.stdout.isTTY;
    if (!isTTY && !unpipe) {
      return {
        isTTY,
        isSSH,
        appId: "none",
        safe: true,
        generic: "none"
      };
    }
    var platform = os.platform();
    var appId = {}.TERM;
    if (platform === "darwin") {
      appId = path$2.parse(appId).name;
    }
    var safe = appId !== {}.TERM || {}.TERM;
    var generic = appId;
    switch (appId) {
      case "xterm":
      case "xterm-256color":
        if (safe) {
          break;
        }
        if (platform === "darwin") {
          appId = "osx-256color";
          break;
        }
        for (envVar in process.env) {
          if (envVar.match(/KONSOLE/)) {
            appId = "konsole";
            safe = true;
            break;
          }
        }
        break;
      case "linux":
      case "aterm":
      case "kuake":
      case "tilda":
      case "terminology":
      case "wterm":
      case "mrxvt":
        break;
      case "gnome":
      case "gnome-256color":
      case "gnome-terminal":
      case "gnome-terminal-256color":
      case "terminator":
      case "guake":
        appId = "gnome";
        break;
      case "konsole":
        appId = "konsole";
        break;
      case "rxvt":
      case "rxvt-xpm":
      case "rxvt-unicode-256color":
      case "urxvt256c":
      case "urxvt256c-ml":
      case "rxvt-unicode":
      case "urxvt":
      case "urxvt-ml":
        {
          appId = "rxvt";
        }
        break;
      case "xfce":
      case "xfce-terminal":
      case "xfce4-terminal":
        appId = "xfce";
        break;
      case "eterm":
      case "Eterm":
        appId = "eterm";
        break;
      case "atomic-terminal":
        appId = "atomic-terminal";
        break;
      case "xterm-kitty":
      case "kitty":
        appId = "kitty";
        break;
      case "iTerm":
      case "iterm":
      case "iTerm2":
      case "iterm2":
      case "Terminal":
      case "terminal":
      case "Apple_Terminal":
        appId = "osx-256color";
        break;
      default:
        if (!appId) {
          generic = "unknown";
        } else {
          generic = appId = generic.toLowerCase();
        }
        break;
    }
    return {
      isTTY,
      isSSH,
      appId,
      safe,
      generic: safe ? appId : generic
    };
  };
  function getParentProcess(pid) {
    var parentPid, appName;
    return new Promise$b((resolve, reject) => {
      exec("ps -h -o ppid -p " + pid, (error, stdout) => {
        if (error) {
          reject(error);
          return;
        }
        parentPid = parseInt(stdout.match(/[0-9]+/gm)[0], 10);
        if (!parentPid) {
          reject(new Error("Couldn't get parent PID"));
          return;
        }
        exec("ps -h -o comm -p " + parentPid, (error_, stdout_) => {
          if (error_) {
            reject(error_);
            return;
          }
          appName = stdout_.trim();
          resolve({pid: parentPid, appName});
        });
      });
    });
  }
  detectTerminal.getParentTerminalInfo = function(callback) {
    return __async(this, null, function* () {
      var loopAgain, appName, appNames = [], appId, pid = process.pid;
      var platform = os.platform();
      var t256color = {}.COLORTERM;
      var tTrueColor = {}.COLORTERM;
      try {
        loopAgain = true;
        while (loopAgain) {
          ({appName, pid} = yield getParentProcess(pid));
          if (platform === "darwin") {
            appName = path$2.parse(appName).name;
          }
          appNames.push(appName);
          loopAgain = false;
          switch (appName) {
            case "linux":
            case "xterm":
            case "konsole":
            case "gnome-terminal":
            case "aterm":
            case "guake":
            case "kuake":
            case "tilda":
            case "terminology":
            case "wterm":
            case "mrxvt":
              appId = t256color || tTrueColor ? appName + "-256color" : appName;
              break;
            case "atomic-terminal":
              appId = appName;
              break;
            case "login":
              appName = "linux";
              appId = appName;
              break;
            case "terminator":
              appId = t256color || tTrueColor ? "gnome-256color" : "gnome";
              break;
            case "rxvt":
            case "urxvt256c":
            case "urxvt256c-ml":
              appId = "rxvt-256color";
              break;
            case "urxvt":
            case "urxvt-ml":
              appId = "rxvt";
              break;
            case "xfce4-terminal":
              appId = "xfce";
              break;
            case "gnome-terminal-":
              appName = "gnome-terminal";
              appId = t256color || tTrueColor ? "gnome-256color" : "gnome";
              break;
            case "Eterm":
            case "eterm":
              appName = "Eterm";
              appId = t256color || tTrueColor ? "eterm-256color" : "eterm";
              break;
            case "kitty":
              appName = appId = "kitty";
              break;
            case "iTerm":
            case "iTerm2":
            case "Terminal":
              appId = "osx-256color";
              break;
            default:
              if (appName.match(/gnome-terminal/)) {
                appName = "gnome-terminal";
                appId = t256color || tTrueColor ? "gnome-256color" : "gnome";
                break;
              }
              if (!pid || pid === 1) {
                throw new Error("Terminal not found, app names: " + appNames.join(", "));
              }
              loopAgain = true;
          }
        }
      } catch (error_) {
        if (callback) {
          callback(error_);
          return;
        }
        throw error_;
      }
      var result = {
        appId,
        appName,
        pid,
        safe: true
      };
      if (callback) {
        callback(void 0, result);
        return;
      }
      return result;
    });
  };
  detectTerminal.getDetectedTerminal = function(callback) {
    return __async(this, null, function* () {
      var terminal, info, guessed = termkit$4.guessTerminal();
      if (guessed.safe || guessed.isSSH) {
        terminal = termkit$4.createTerminal({
          stdin: process.stdin,
          stdout: process.stdout,
          stderr: process.stderr,
          generic: "unknown",
          appId: guessed.safe ? guessed.appId : void 0,
          isTTY: guessed.isTTY,
          isSSH: guessed.isSSH,
          processSigwinch: true,
          preferProcessSigwinch: !!termkit$4.globalConfig.preferProcessSigwinch
        });
        if (callback) {
          callback(void 0, terminal);
        }
        return terminal;
      }
      try {
        info = yield termkit$4.getParentTerminalInfo();
        terminal = termkit$4.createTerminal({
          stdin: process.stdin,
          stdout: process.stdout,
          stderr: process.stderr,
          generic: {}.TERM && {}.TERM.toLowerCase() || "unknown",
          appId: info.appId,
          appName: info.appName,
          isTTY: guessed.isTTY,
          isSSH: guessed.isSSH,
          pid: info.pid,
          processSigwinch: true,
          preferProcessSigwinch: !!termkit$4.globalConfig.preferProcessSigwinch
        });
      } catch (error) {
        terminal = termkit$4.createTerminal({
          stdin: process.stdin,
          stdout: process.stdout,
          stderr: process.stderr,
          generic: "unknown",
          appId: guessed.safe ? guessed.appId : void 0,
          isTTY: guessed.isTTY,
          isSSH: guessed.isSSH,
          processSigwinch: true,
          preferProcessSigwinch: !!termkit$4.globalConfig.preferProcessSigwinch
        });
      }
      if (callback) {
        callback(void 0, terminal);
      }
      return terminal;
    });
  };
  function extend(options, target, ...sources) {
    var i, source, newTarget = false, length = sources.length;
    if (!length) {
      return target;
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    var runtime = {depth: 0, prefix: ""};
    if (options.deep) {
      if (Array.isArray(options.deep)) {
        options.deep = new Set(options.deep);
      } else if (!(options.deep instanceof Set)) {
        options.deep = true;
      }
    }
    if (options.immutables) {
      if (Array.isArray(options.immutables)) {
        options.immutables = new Set(options.immutables);
      } else if (!(options.immutables instanceof Set)) {
        delete options.immutables;
      }
    }
    if (!options.maxDepth && options.deep && !options.circular) {
      options.maxDepth = 100;
    }
    if (options.deepFunc) {
      options.deep = true;
    }
    if (options.flat) {
      options.deep = true;
      options.proto = false;
      options.inherit = false;
      options.unflat = false;
      if (typeof options.flat !== "string") {
        options.flat = ".";
      }
    }
    if (options.unflat) {
      options.deep = false;
      options.proto = false;
      options.inherit = false;
      options.flat = false;
      if (typeof options.unflat !== "string") {
        options.unflat = ".";
      }
    }
    if (options.inherit) {
      options.own = true;
      options.proto = false;
    } else if (options.proto) {
      options.own = true;
    }
    if (!target || typeof target !== "object" && typeof target !== "function") {
      newTarget = true;
    }
    if (!options.skipRoot && (options.inherit || options.proto)) {
      for (i = length - 1; i >= 0; i--) {
        source = sources[i];
        if (source && (typeof source === "object" || typeof source === "function")) {
          if (options.inherit) {
            if (newTarget) {
              target = Object.create(source);
            } else {
              Object.setPrototypeOf(target, source);
            }
          } else if (options.proto) {
            if (newTarget) {
              target = Object.create(Object.getPrototypeOf(source));
            } else {
              Object.setPrototypeOf(target, Object.getPrototypeOf(source));
            }
          }
          break;
        }
      }
    } else if (newTarget) {
      target = {};
    }
    runtime.references = {sources: [], targets: []};
    for (i = 0; i < length; i++) {
      source = sources[i];
      if (!source || typeof source !== "object" && typeof source !== "function") {
        continue;
      }
      extendOne(runtime, options, target, source);
    }
    return target;
  }
  var extend_1 = extend;
  function extendOne(runtime, options, target, source) {
    var j, jmax, sourceKeys, sourceKey, sourceValue, sourceValueProto, value, sourceDescriptor, targetKey, targetPointer, path, indexOfSource = -1;
    if (options.maxDepth && runtime.depth > options.maxDepth) {
      throw new Error("[tree] extend(): max depth reached(" + options.maxDepth + ")");
    }
    if (options.circular) {
      runtime.references.sources.push(source);
      runtime.references.targets.push(target);
    }
    if (options.own) {
      if (options.nonEnum) {
        sourceKeys = Object.getOwnPropertyNames(source);
      } else {
        sourceKeys = Object.keys(source);
      }
    } else {
      sourceKeys = source;
    }
    for (sourceKey in sourceKeys) {
      if (options.own) {
        sourceKey = sourceKeys[sourceKey];
      }
      if (sourceKey === "__proto__") {
        continue;
      }
      if (options.descriptor) {
        sourceDescriptor = Object.getOwnPropertyDescriptor(source, sourceKey);
        sourceValue = sourceDescriptor.value;
      } else {
        sourceValue = source[sourceKey];
      }
      targetPointer = target;
      targetKey = runtime.prefix + sourceKey;
      if (options.nofunc && typeof sourceValue === "function") {
        continue;
      }
      if (options.unflat && runtime.depth === 0) {
        path = sourceKey.split(options.unflat);
        jmax = path.length - 1;
        if (jmax) {
          for (j = 0; j < jmax; j++) {
            if (!targetPointer[path[j]] || typeof targetPointer[path[j]] !== "object" && typeof targetPointer[path[j]] !== "function") {
              targetPointer[path[j]] = {};
            }
            targetPointer = targetPointer[path[j]];
          }
          targetKey = runtime.prefix + path[jmax];
        }
      }
      if (options.deep && sourceValue && (typeof sourceValue === "object" || options.deepFunc && typeof sourceValue === "function") && (!options.descriptor || !sourceDescriptor.get) && ((sourceValueProto = Object.getPrototypeOf(sourceValue)) || true) && (!(options.deep instanceof Set) || options.deep.has(sourceValueProto)) && (!options.immutables || !options.immutables.has(sourceValueProto))) {
        if (options.circular) {
          indexOfSource = runtime.references.sources.indexOf(sourceValue);
        }
        if (options.flat) {
          if (indexOfSource >= 0) {
            continue;
          }
          extendOne({depth: runtime.depth + 1, prefix: runtime.prefix + sourceKey + options.flat, references: runtime.references}, options, targetPointer, sourceValue);
        } else {
          if (indexOfSource >= 0) {
            if (options.descriptor) {
              Object.defineProperty(targetPointer, targetKey, {
                value: runtime.references.targets[indexOfSource],
                enumerable: sourceDescriptor.enumerable,
                writable: sourceDescriptor.writable,
                configurable: sourceDescriptor.configurable
              });
            } else {
              targetPointer[targetKey] = runtime.references.targets[indexOfSource];
            }
            continue;
          }
          if (!targetPointer[targetKey] || !Object.prototype.hasOwnProperty.call(targetPointer, targetKey) || typeof targetPointer[targetKey] !== "object" && typeof targetPointer[targetKey] !== "function") {
            if (Array.isArray(sourceValue)) {
              value = [];
            } else if (options.proto) {
              value = Object.create(sourceValueProto);
            } else if (options.inherit) {
              value = Object.create(sourceValue);
            } else {
              value = {};
            }
            if (options.descriptor) {
              Object.defineProperty(targetPointer, targetKey, {
                value,
                enumerable: sourceDescriptor.enumerable,
                writable: sourceDescriptor.writable,
                configurable: sourceDescriptor.configurable
              });
            } else {
              targetPointer[targetKey] = value;
            }
          } else if (options.proto && Object.getPrototypeOf(targetPointer[targetKey]) !== sourceValueProto) {
            Object.setPrototypeOf(targetPointer[targetKey], sourceValueProto);
          } else if (options.inherit && Object.getPrototypeOf(targetPointer[targetKey]) !== sourceValue) {
            Object.setPrototypeOf(targetPointer[targetKey], sourceValue);
          }
          if (options.circular) {
            runtime.references.sources.push(sourceValue);
            runtime.references.targets.push(targetPointer[targetKey]);
          }
          extendOne({depth: runtime.depth + 1, prefix: "", references: runtime.references}, options, targetPointer[targetKey], sourceValue);
        }
      } else if (options.preserve && targetPointer[targetKey] !== void 0) {
        continue;
      } else if (!options.inherit) {
        if (options.descriptor) {
          Object.defineProperty(targetPointer, targetKey, sourceDescriptor);
        } else {
          targetPointer[targetKey] = sourceValue;
        }
      }
      if (options.move) {
        delete source[sourceKey];
      }
    }
  }
  function clone(originalObject, circular) {
    var originalProto = Object.getPrototypeOf(originalObject);
    if (clone.opaque.has(originalProto)) {
      return clone.opaque.get(originalProto)(originalObject);
    }
    var propertyIndex, descriptor, keys, current, nextSource, proto, copies = [{
      source: originalObject,
      target: Array.isArray(originalObject) ? [] : Object.create(originalProto)
    }], cloneObject = copies[0].target, refMap = new Map();
    refMap.set(originalObject, cloneObject);
    while (current = copies.shift()) {
      keys = Object.getOwnPropertyNames(current.source);
      for (propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {
        descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
        if (!descriptor.value || typeof descriptor.value !== "object") {
          Object.defineProperty(current.target, keys[propertyIndex], descriptor);
          continue;
        }
        nextSource = descriptor.value;
        if (circular) {
          if (refMap.has(nextSource)) {
            descriptor.value = refMap.get(nextSource);
            Object.defineProperty(current.target, keys[propertyIndex], descriptor);
            continue;
          }
        }
        proto = Object.getPrototypeOf(descriptor.value);
        if (clone.opaque.has(proto)) {
          descriptor.value = clone.opaque.get(proto)(descriptor.value);
          Object.defineProperty(current.target, keys[propertyIndex], descriptor);
          continue;
        }
        descriptor.value = Array.isArray(nextSource) ? [] : Object.create(proto);
        if (circular) {
          refMap.set(nextSource, descriptor.value);
        }
        Object.defineProperty(current.target, keys[propertyIndex], descriptor);
        copies.push({source: nextSource, target: descriptor.value});
      }
    }
    return cloneObject;
  }
  var clone_1 = clone;
  clone.opaque = new Map();
  clone.opaque.set(Date.prototype, (src) => new Date(src));
  var treePath = {};
  var path$1 = treePath;
  treePath.op = function op(type, object, path, value) {
    var i, parts, last, pointer, key, isArray = false, pathArrayMode = false, isGenericSet, canBeEmpty = true;
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return;
    }
    if (typeof path === "string") {
      if (path) {
        parts = path.match(/([.#[\]]|[^.#[\]]+)/g);
      } else {
        parts = [""];
      }
      if (parts[0] === ".") {
        parts.unshift("");
      }
      if (parts[parts.length - 1] === ".") {
        parts.push("");
      }
    } else if (Array.isArray(path)) {
      parts = path;
      pathArrayMode = true;
    } else {
      throw new TypeError("[tree.path] ." + type + "(): the path argument should be a string or an array");
    }
    switch (type) {
      case "get":
      case "delete":
        isGenericSet = false;
        break;
      case "set":
      case "define":
      case "inc":
      case "dec":
      case "append":
      case "prepend":
      case "concat":
      case "insert":
      case "autoPush":
        isGenericSet = true;
        break;
      default:
        throw new TypeError("[tree.path] .op(): wrong type of operation '" + type + "'");
    }
    pointer = object;
    last = parts.length - 1;
    for (i = 0; i <= last; i++) {
      if (pathArrayMode) {
        if (key === void 0) {
          key = parts[i];
          continue;
        }
        if (!pointer[key] || typeof pointer[key] !== "object" && typeof pointer[key] !== "function") {
          if (!isGenericSet) {
            return void 0;
          }
          pointer[key] = {};
        }
        pointer = pointer[key];
        key = parts[i];
        continue;
      } else if (parts[i] === ".") {
        isArray = false;
        if (key === void 0) {
          if (!canBeEmpty) {
            canBeEmpty = true;
            continue;
          }
          key = "";
        }
        if (!pointer[key] || typeof pointer[key] !== "object" && typeof pointer[key] !== "function") {
          if (!isGenericSet) {
            return void 0;
          }
          pointer[key] = {};
        }
        pointer = pointer[key];
        canBeEmpty = true;
        continue;
      } else if (parts[i] === "#" || parts[i] === "[") {
        isArray = true;
        canBeEmpty = false;
        if (key === void 0) {
          if (!Array.isArray(pointer)) {
            return void 0;
          }
          continue;
        }
        if (!pointer[key] || !Array.isArray(pointer[key])) {
          if (!isGenericSet) {
            return void 0;
          }
          pointer[key] = [];
        }
        pointer = pointer[key];
        continue;
      } else if (parts[i] === "]") {
        canBeEmpty = false;
        continue;
      }
      canBeEmpty = false;
      if (!isArray) {
        key = parts[i];
        continue;
      }
      switch (parts[i]) {
        case "length":
          key = parts[i];
          break;
        case "first":
          key = 0;
          break;
        case "last":
          key = pointer.length - 1;
          if (key < 0) {
            key = 0;
          }
          break;
        case "next":
          if (!isGenericSet) {
            return void 0;
          }
          key = pointer.length;
          break;
        case "insert":
          if (!isGenericSet) {
            return void 0;
          }
          pointer.unshift(void 0);
          key = 0;
          break;
        default:
          key = parseInt(parts[i], 10);
      }
    }
    switch (type) {
      case "get":
        return pointer[key];
      case "delete":
        if (isArray && typeof key === "number") {
          pointer.splice(key, 1);
        } else {
          delete pointer[key];
        }
        return;
      case "set":
        pointer[key] = value;
        return pointer[key];
      case "define":
        if (!(key in pointer)) {
          pointer[key] = value;
        }
        return pointer[key];
      case "inc":
        if (typeof pointer[key] === "number") {
          pointer[key]++;
        } else if (!pointer[key] || typeof pointer[key] !== "object") {
          pointer[key] = 1;
        }
        return pointer[key];
      case "dec":
        if (typeof pointer[key] === "number") {
          pointer[key]--;
        } else if (!pointer[key] || typeof pointer[key] !== "object") {
          pointer[key] = -1;
        }
        return pointer[key];
      case "append":
        if (!pointer[key]) {
          pointer[key] = [value];
        } else if (Array.isArray(pointer[key])) {
          pointer[key].push(value);
        }
        return pointer[key];
      case "prepend":
        if (!pointer[key]) {
          pointer[key] = [value];
        } else if (Array.isArray(pointer[key])) {
          pointer[key].unshift(value);
        }
        return pointer[key];
      case "concat":
        if (!pointer[key]) {
          pointer[key] = value;
        } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
          pointer[key] = pointer[key].concat(value);
        }
        return pointer[key];
      case "insert":
        if (!pointer[key]) {
          pointer[key] = value;
        } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
          pointer[key] = value.concat(pointer[key]);
        }
        return pointer[key];
      case "autoPush":
        if (pointer[key] === void 0) {
          pointer[key] = value;
        } else if (Array.isArray(pointer[key])) {
          pointer[key].push(value);
        } else {
          pointer[key] = [pointer[key], value];
        }
        return pointer[key];
    }
  };
  treePath.get = treePath.op.bind(void 0, "get");
  treePath.delete = treePath.op.bind(void 0, "delete");
  treePath.set = treePath.op.bind(void 0, "set");
  treePath.define = treePath.op.bind(void 0, "define");
  treePath.inc = treePath.op.bind(void 0, "inc");
  treePath.dec = treePath.op.bind(void 0, "dec");
  treePath.append = treePath.op.bind(void 0, "append");
  treePath.prepend = treePath.op.bind(void 0, "prepend");
  treePath.concat = treePath.op.bind(void 0, "concat");
  treePath.insert = treePath.op.bind(void 0, "insert");
  treePath.autoPush = treePath.op.bind(void 0, "autoPush");
  treePath.prototype = {
    get: function(path) {
      return treePath.get(this, path);
    },
    delete: function(path) {
      return treePath.delete(this, path);
    },
    set: function(path, value) {
      return treePath.set(this, path, value);
    },
    define: function(path, value) {
      return treePath.define(this, path, value);
    },
    inc: function(path, value) {
      return treePath.inc(this, path, value);
    },
    dec: function(path, value) {
      return treePath.dec(this, path, value);
    },
    append: function(path, value) {
      return treePath.append(this, path, value);
    },
    prepend: function(path, value) {
      return treePath.prepend(this, path, value);
    },
    concat: function(path, value) {
      return treePath.concat(this, path, value);
    },
    insert: function(path, value) {
      return treePath.insert(this, path, value);
    },
    autoPush: function(path, value) {
      return treePath.autoPush(this, path, value);
    }
  };
  treePath.upgrade = function upgrade(object) {
    Object.defineProperties(object, {
      get: {value: treePath.op.bind(void 0, "get", object)},
      delete: {value: treePath.op.bind(void 0, "delete", object)},
      set: {value: treePath.op.bind(void 0, "set", object)},
      define: {value: treePath.op.bind(void 0, "define", object)},
      inc: {value: treePath.op.bind(void 0, "inc", object)},
      dec: {value: treePath.op.bind(void 0, "dec", object)},
      append: {value: treePath.op.bind(void 0, "append", object)},
      prepend: {value: treePath.op.bind(void 0, "prepend", object)},
      concat: {value: treePath.op.bind(void 0, "concat", object)},
      insert: {value: treePath.op.bind(void 0, "insert", object)},
      autoPush: {value: treePath.op.bind(void 0, "autoPush", object)}
    });
  };
  const dotPath = {};
  var dotPath_1 = dotPath;
  const EMPTY_PATH = [];
  function toPathArray(path) {
    if (Array.isArray(path)) {
      return path;
    } else if (!path) {
      return EMPTY_PATH;
    } else if (typeof path === "string") {
      return path.split(".");
    }
    throw new TypeError("[tree.dotPath]: the path argument should be a string or an array");
  }
  function walk(object, pathArray) {
    var i, iMax, pointer = object;
    for (i = 0, iMax = pathArray.length; i < iMax; i++) {
      if (!pointer || typeof pointer !== "object" && typeof pointer !== "function") {
        return void 0;
      }
      pointer = pointer[pathArray[i]];
    }
    return pointer;
  }
  function walkBeforeLast(object, pathArray) {
    var i, iMax, pointer = object;
    for (i = 0, iMax = pathArray.length - 1; i < iMax; i++) {
      if (!pointer || typeof pointer !== "object" && typeof pointer !== "function") {
        return void 0;
      }
      pointer = pointer[pathArray[i]];
    }
    return pointer;
  }
  function pave(object, pathArray) {
    var i, iMax, key, pointer = object;
    for (i = 0, iMax = pathArray.length - 1; i < iMax; i++) {
      key = pathArray[i];
      if (!pointer[key] || typeof pointer[key] !== "object" && typeof pointer[key] !== "function") {
        pointer[key] = {};
      }
      pointer = pointer[key];
    }
    return pointer;
  }
  dotPath.get = function(object, path) {
    return walk(object, toPathArray(path));
  };
  dotPath.set = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    pointer[pathArray[pathArray.length - 1]] = value;
    return value;
  };
  dotPath.define = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (!(key in pointer)) {
      pointer[key] = value;
    }
    return value;
  };
  dotPath.inc = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (typeof pointer[key] === "number") {
      pointer[key]++;
    } else if (!pointer[key] || typeof pointer[key] !== "object") {
      pointer[key] = 1;
    }
    return value;
  };
  dotPath.dec = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (typeof pointer[key] === "number") {
      pointer[key]--;
    } else if (!pointer[key] || typeof pointer[key] !== "object") {
      pointer[key] = -1;
    }
    return value;
  };
  dotPath.concat = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (!pointer[key]) {
      pointer[key] = value;
    } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
      pointer[key] = pointer[key].concat(value);
    }
    return value;
  };
  dotPath.insert = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (!pointer[key]) {
      pointer[key] = value;
    } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
      pointer[key] = value.concat(pointer[key]);
    }
    return value;
  };
  dotPath.delete = function(object, path) {
    var pathArray = toPathArray(path);
    var pointer = walkBeforeLast(object, pathArray);
    if (!pointer || typeof pointer !== "object" && typeof pointer !== "function") {
      return false;
    }
    return delete pointer[pathArray[pathArray.length - 1]];
  };
  dotPath.autoPush = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (pointer[key] === void 0) {
      pointer[key] = value;
    } else if (Array.isArray(pointer[key])) {
      pointer[key].push(value);
    } else {
      pointer[key] = [pointer[key], value];
    }
    return pointer[key];
  };
  dotPath.append = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (!pointer[key]) {
      pointer[key] = [value];
    } else if (Array.isArray(pointer[key])) {
      pointer[key].push(value);
    }
    return pointer[key];
  };
  dotPath.prepend = function(object, path, value) {
    if (!object || typeof object !== "object" && typeof object !== "function") {
      return void 0;
    }
    var pathArray = toPathArray(path);
    var pointer = pave(object, pathArray);
    var key = pathArray[pathArray.length - 1];
    if (!pointer[key]) {
      pointer[key] = [value];
    } else if (Array.isArray(pointer[key])) {
      pointer[key].unshift(value);
    }
    return pointer[key];
  };
  var lazy$1 = {};
  lazy$1.defineLazyProperty = function defineLazyProperty(object, name2, func) {
    Object.defineProperty(object, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var value = func();
        Object.defineProperty(object, name2, {
          configurable: true,
          enumerable: true,
          writable: false,
          value
        });
        return value;
      }
    });
  };
  var diff$1 = {};
  function diff(left, right, options) {
    var i, key, keyPath, leftKeys, rightKeys, leftTypeof, rightTypeof, depth, diffObject, length, arrayMode;
    leftTypeof = typeof left;
    rightTypeof = typeof right;
    if (!left || leftTypeof !== "object" && leftTypeof !== "function" || !right || rightTypeof !== "object" && rightTypeof !== "function") {
      throw new Error("[tree] diff() needs objects as argument #0 and #1");
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    depth = options.depth || 0;
    if (!depth) {
      options.diffObject = {};
      if (!options.path) {
        options.path = "";
      }
      if (!options.pathSeparator) {
        options.pathSeparator = ".";
      }
    }
    diffObject = options.diffObject;
    if (Array.isArray(left)) {
      arrayMode = true;
      length = left.length;
    } else {
      arrayMode = false;
      leftKeys = Object.keys(left);
      length = leftKeys.length;
    }
    for (i = 0; i < length; i++) {
      key = arrayMode ? i : leftKeys[i];
      keyPath = options.path + options.pathSeparator + key;
      if (!Object.prototype.hasOwnProperty.call(right, key)) {
        diffObject[keyPath] = {path: keyPath, message: "does not exist in right-hand side"};
        continue;
      }
      leftTypeof = typeof left[key];
      rightTypeof = typeof right[key];
      if (leftTypeof !== rightTypeof) {
        diffObject[keyPath] = {path: keyPath, message: "different typeof: " + leftTypeof + " - " + rightTypeof};
        continue;
      }
      if (leftTypeof === "object" || leftTypeof === "function") {
        if (!left[key]) {
          if (right[key]) {
            diffObject[keyPath] = {path: keyPath, message: "different type: null - Object"};
          }
          continue;
        }
        if (!right[key]) {
          diffObject[keyPath] = {path: keyPath, message: "different type: Object - null"};
          continue;
        }
        if (Array.isArray(left[key]) && !Array.isArray(right[key])) {
          diffObject[keyPath] = {path: keyPath, message: "different type: Array - Object"};
          continue;
        }
        if (!Array.isArray(left[key]) && Array.isArray(right[key])) {
          diffObject[keyPath] = {path: keyPath, message: "different type: Object - Array"};
          continue;
        }
        diff(left[key], right[key], {
          path: keyPath,
          pathSeparator: options.pathSeparator,
          depth: depth + 1,
          diffObject
        });
        continue;
      }
      if (left[key] !== right[key]) {
        diffObject[keyPath] = {path: keyPath, message: "different value: " + left[key] + " - " + right[key]};
        continue;
      }
    }
    if (Array.isArray(right)) {
      arrayMode = true;
      length = right.length;
    } else {
      arrayMode = false;
      rightKeys = Object.keys(right);
      length = rightKeys.length;
    }
    for (i = 0; i < length; i++) {
      key = arrayMode ? i : rightKeys[i];
      keyPath = options.path + options.pathSeparator + key;
      if (!Object.prototype.hasOwnProperty.call(left, key)) {
        diffObject[keyPath] = {path: keyPath, message: "does not exist in left-hand side"};
        continue;
      }
    }
    return Object.keys(diffObject).length ? diffObject : null;
  }
  diff$1.diff = diff;
  var tree$2 = tree_1;
  var util = require$$1;
  var masklib = {};
  var mask = masklib;
  masklib.Mask = function Mask() {
    throw new Error("Cannot create a tree.Mask() directly");
  };
  var maskDefaultOptions = {
    clone: false,
    path: "<object>",
    pathSeparator: "."
  };
  masklib.createMask = function createMask(maskArgument, options) {
    if (maskArgument === null || typeof maskArgument !== "object") {
      throw new TypeError("[tree] .createMask() : Argument #1 should be an object");
    }
    if (options !== null && typeof options === "object") {
      options = tree$2.extend(null, {}, maskDefaultOptions, options);
    } else {
      options = maskDefaultOptions;
    }
    var mask = Object.create(masklib.Mask.prototype, {
      __options__: {value: options, writable: true}
    });
    tree$2.extend(null, mask, maskArgument);
    return mask;
  };
  masklib.Mask.prototype.applyTo = function applyTo(input, context, contextOverideDefault) {
    if (input === null || typeof input !== "object") {
      throw new TypeError("[tree] .applyTo() : Argument #1 should be an object");
    }
    if (contextOverideDefault) {
      context = tree$2.extend(null, {
        mask: this,
        options: this.__options__,
        path: this.__options__.path
      }, context);
    } else if (context === void 0) {
      context = {
        mask: this,
        options: this.__options__,
        path: this.__options__.path
      };
    }
    var result, nextPath, output, i, key, maskValue, maskKeyList = Object.keys(context.mask), j, inputKey, inputValue, inputKeyList;
    if (Array.isArray(input)) {
      output = [];
    } else {
      output = {};
    }
    for (i = 0; i < maskKeyList.length; i++) {
      key = maskKeyList[i];
      maskValue = context.mask[key];
      if (key === "*") {
        inputKeyList = Object.keys(input);
        for (j = 0; j < inputKeyList.length; j++) {
          inputKey = inputKeyList[j];
          inputValue = input[inputKey];
          nextPath = context.path + context.options.pathSeparator + inputKey;
          if (maskValue !== null && typeof maskValue === "object") {
            if (inputValue !== null && typeof inputValue === "object") {
              if (inputValue instanceof masklib.Mask) {
                output[inputKey] = inputValue.applyTo(inputValue, {path: nextPath}, true);
              } else {
                output[inputKey] = this.applyTo(inputValue, tree$2.extend(null, {}, context, {mask: maskValue, path: nextPath}));
              }
            } else if (typeof context.options.leaf === "function") {
              output[inputKey] = this.applyTo({}, tree$2.extend(null, {}, context, {mask: maskValue, path: nextPath}));
            }
          } else if (maskValue !== null && typeof context.options.leaf === "function") {
            result = context.options.leaf(input, inputKey, maskValue, nextPath);
            if (!(result instanceof Error)) {
              output[inputKey] = result;
            }
          } else if (context.options.clone && (inputValue !== null && typeof inputValue === "object")) {
            output[inputKey] = tree$2.extend({deep: true}, {}, inputValue);
          } else {
            output[inputKey] = inputValue;
          }
        }
        continue;
      }
      nextPath = context.path + context.options.pathSeparator + key;
      if (maskValue !== null && typeof maskValue === "object") {
        if (Object.prototype.hasOwnProperty.call(input, key) && input[key] !== null && typeof input[key] === "object") {
          if (input.key instanceof masklib.Mask) {
            output[key] = input.key.applyTo(input[key], {path: nextPath}, true);
          } else {
            output[key] = this.applyTo(input[key], tree$2.extend(null, {}, context, {mask: maskValue, path: nextPath}));
          }
        } else if (context.options.leaf) {
          output[key] = this.applyTo({}, tree$2.extend(null, {}, context, {mask: maskValue, path: nextPath}));
        }
      } else if (Object.prototype.hasOwnProperty.call(input, key)) {
        if (maskValue !== void 0 && typeof context.options.leaf === "function") {
          result = context.options.leaf(input, key, maskValue, nextPath);
          if (!(result instanceof Error)) {
            output[key] = result;
          }
        } else if (context.options.clone && (input[key] !== null && typeof input[key] === "object")) {
          output[key] = tree$2.extend({deep: true}, {}, input[key]);
        } else {
          output[key] = input[key];
        }
      } else if (maskValue !== void 0 && typeof context.options.leaf === "function") {
        result = context.options.leaf(input, key, maskValue, nextPath);
        if (!(result instanceof Error)) {
          output[key] = result;
        }
      }
    }
    return output;
  };
  masklib.InverseMask = function InverseMask() {
    throw new Error("Cannot create a tree.InverseMask() directly");
  };
  util.inherits(masklib.InverseMask, masklib.Mask);
  masklib.createInverseMask = function createInverseMask(maskArgument, options) {
    if (maskArgument === null || typeof maskArgument !== "object") {
      throw new TypeError("[tree] .createInverseMask() : Argument #1 should be an object");
    }
    if (options !== null && typeof options === "object") {
      options = tree$2.extend(null, {}, maskDefaultOptions, options);
    } else {
      options = maskDefaultOptions;
    }
    var mask = Object.create(masklib.InverseMask.prototype, {
      __options__: {value: options, writable: true}
    });
    tree$2.extend(null, mask, maskArgument);
    return mask;
  };
  masklib.InverseMask.prototype.applyTo = function applyTo(input, context, contextOverideDefault) {
    if (input === null || typeof input !== "object") {
      throw new TypeError("[tree] .applyTo() : Argument #1 should be an object");
    }
    if (contextOverideDefault) {
      context = tree$2.extend(null, {
        mask: this,
        options: this.__options__,
        path: this.__options__.path
      }, context);
    } else if (context === void 0) {
      context = {
        mask: this,
        options: this.__options__,
        path: this.__options__.path
      };
    }
    var nextPath, output, i, key, maskValue, maskKeyList = Object.keys(context.mask), j, inputKey, inputValue, inputKeyList;
    if (Array.isArray(input)) {
      output = tree$2.extend({deep: true}, [], input);
    } else {
      output = tree$2.extend({deep: true}, {}, input);
    }
    for (i = 0; i < maskKeyList.length; i++) {
      key = maskKeyList[i];
      maskValue = context.mask[key];
      if (key === "*") {
        inputKeyList = Object.keys(input);
        for (j = 0; j < inputKeyList.length; j++) {
          inputKey = inputKeyList[j];
          inputValue = input[inputKey];
          nextPath = context.path + context.options.pathSeparator + inputKey;
          if (maskValue !== null && typeof maskValue === "object") {
            if (inputValue !== null && typeof inputValue === "object") {
              if (inputValue instanceof masklib.Mask) {
                output[inputKey] = inputValue.applyTo(inputValue, {path: nextPath}, true);
              } else {
                output[inputKey] = this.applyTo(inputValue, tree$2.extend(null, {}, context, {mask: maskValue, path: nextPath}));
              }
            }
          } else {
            delete output[inputKey];
          }
        }
        continue;
      }
      nextPath = context.path + context.options.pathSeparator + key;
      if (maskValue !== null && typeof maskValue === "object") {
        if (Object.prototype.hasOwnProperty.call(input, key) && input[key] !== null && typeof input[key] === "object") {
          if (input.key instanceof masklib.Mask) {
            output[key] = input.key.applyTo(input[key], {path: nextPath}, true);
          } else {
            output[key] = this.applyTo(input[key], tree$2.extend(null, {}, context, {mask: maskValue, path: nextPath}));
          }
        }
      } else if (Object.prototype.hasOwnProperty.call(input, key)) {
        delete output[key];
      }
    }
    return output;
  };
  var tree$1 = {};
  var tree_1 = tree$1;
  Object.assign(tree$1, {
    extend: extend_1,
    clone: clone_1,
    path: path$1,
    dotPath: dotPath_1
  }, lazy$1, diff$1, mask);
  const name$1 = "nextgen-events";
  const version = "1.3.4";
  const description = "The next generation of events handling for javascript! New: abstract away the network!";
  const main = "lib/NextGenEvents.js";
  const engines = {
    node: ">=6.0.0"
  };
  const directories = {
    test: "test"
  };
  const dependencies = {};
  const devDependencies = {
    browserify: "^16.2.2",
    "uglify-js-es6": "^2.8.9",
    ws: "^5.1.1"
  };
  const scripts = {
    test: "tea-time -R dot"
  };
  const repository = {
    type: "git",
    url: "https://github.com/cronvel/nextgen-events.git"
  };
  const keywords = [
    "events",
    "async",
    "emit",
    "listener",
    "context",
    "series",
    "serialize",
    "namespace",
    "proxy",
    "network"
  ];
  const author = "C\xE9dric Ronvel";
  const license = "MIT";
  const bugs = {
    url: "https://github.com/cronvel/nextgen-events/issues"
  };
  const config = {
    "tea-time": {
      coverDir: [
        "lib"
      ]
    }
  };
  const copyright = {
    title: "Next-Gen Events",
    years: [
      2015,
      2019
    ],
    owner: "C\xE9dric Ronvel"
  };
  var require$$0 = {
    name: name$1,
    version,
    description,
    main,
    engines,
    directories,
    dependencies,
    devDependencies,
    scripts,
    repository,
    keywords,
    author,
    license,
    bugs,
    config,
    copyright
  };
  function Proxy$1() {
    this.localServices = {};
    this.remoteServices = {};
    this.nextAckId = 1;
  }
  var _Proxy = Proxy$1;
  var NextGenEvents$5 = NextGenEvents_1;
  var MESSAGE_TYPE = "NextGenEvents/message";
  function noop() {
  }
  Proxy$1.create = (...args) => new Proxy$1(...args);
  Proxy$1.prototype.addLocalService = function(id, emitter, options) {
    this.localServices[id] = LocalService.create(this, id, emitter, options);
    return this.localServices[id];
  };
  Proxy$1.prototype.addRemoteService = function(id) {
    this.remoteServices[id] = RemoteService.create(this, id);
    return this.remoteServices[id];
  };
  Proxy$1.prototype.destroy = function() {
    Object.keys(this.localServices).forEach((id) => {
      this.localServices[id].destroy();
      delete this.localServices[id];
    });
    Object.keys(this.remoteServices).forEach((id) => {
      this.remoteServices[id].destroy();
      delete this.remoteServices[id];
    });
    this.receive = this.send = noop;
  };
  Proxy$1.prototype.push = function(message) {
    if (message.__type !== MESSAGE_TYPE || !message.service || typeof message.service !== "string" || !message.event || typeof message.event !== "string" || !message.method) {
      return;
    }
    switch (message.method) {
      case "event":
        return this.remoteServices[message.service] && this.remoteServices[message.service].receiveEvent(message);
      case "ackEmit":
        return this.remoteServices[message.service] && this.remoteServices[message.service].receiveAckEmit(message);
      case "emit":
        return this.localServices[message.service] && this.localServices[message.service].receiveEmit(message);
      case "listen":
        return this.localServices[message.service] && this.localServices[message.service].receiveListen(message);
      case "ignore":
        return this.localServices[message.service] && this.localServices[message.service].receiveIgnore(message);
      case "ackEvent":
        return this.localServices[message.service] && this.localServices[message.service].receiveAckEvent(message);
      default:
        return;
    }
  };
  Proxy$1.prototype.receive = function(raw) {
    this.push(raw);
  };
  Proxy$1.prototype.send = function() {
    throw new Error("The send() method of the Proxy MUST be extended/overwritten");
  };
  function LocalService(proxy, id, emitter, options) {
    return LocalService.create(proxy, id, emitter, options);
  }
  Proxy$1.LocalService = LocalService;
  LocalService.create = function(proxy, id, emitter, options) {
    var self2 = Object.create(LocalService.prototype, {
      proxy: {value: proxy, enumerable: true},
      id: {value: id, enumerable: true},
      emitter: {value: emitter, writable: true, enumerable: true},
      internalEvents: {value: Object.create(NextGenEvents$5.prototype), writable: true, enumerable: true},
      events: {value: {}, enumerable: true},
      canListen: {value: !!options.listen, writable: true, enumerable: true},
      canEmit: {value: !!options.emit, writable: true, enumerable: true},
      canAck: {value: !!options.ack, writable: true, enumerable: true},
      canRpc: {value: !!options.rpc, writable: true, enumerable: true},
      destroyed: {value: false, writable: true, enumerable: true}
    });
    return self2;
  };
  LocalService.prototype.destroy = function() {
    Object.keys(this.events).forEach((eventName) => {
      this.emitter.off(eventName, this.events[eventName]);
      delete this.events[eventName];
    });
    this.emitter = null;
    this.destroyed = true;
  };
  LocalService.prototype.receiveEmit = function(message) {
    if (this.destroyed || !this.canEmit || message.ack && !this.canAck) {
      return;
    }
    var event2 = {
      emitter: this.emitter,
      name: message.event,
      args: message.args || []
    };
    if (message.ack) {
      event2.callback = (interruption) => {
        this.proxy.send({
          __type: MESSAGE_TYPE,
          service: this.id,
          method: "ackEmit",
          ack: message.ack,
          event: message.event,
          interruption
        });
      };
    }
    NextGenEvents$5.emitEvent(event2);
  };
  LocalService.prototype.receiveListen = function(message) {
    if (this.destroyed || !this.canListen || message.ack && !this.canAck) {
      return;
    }
    if (message.ack) {
      if (this.events[message.event]) {
        if (this.events[message.event].ack) {
          return;
        }
        this.emitter.off(message.event, this.events[message.event]);
      }
      this.events[message.event] = LocalService.forwardWithAck.bind(this);
      this.events[message.event].ack = true;
      this.emitter.on(message.event, this.events[message.event], {eventObject: true, async: true});
    } else {
      if (this.events[message.event]) {
        if (!this.events[message.event].ack) {
          return;
        }
        this.emitter.off(message.event, this.events[message.event]);
      }
      this.events[message.event] = LocalService.forward.bind(this);
      this.events[message.event].ack = false;
      this.emitter.on(message.event, this.events[message.event], {eventObject: true});
    }
  };
  LocalService.prototype.receiveIgnore = function(message) {
    if (this.destroyed || !this.canListen) {
      return;
    }
    if (!this.events[message.event]) {
      return;
    }
    this.emitter.off(message.event, this.events[message.event]);
    this.events[message.event] = null;
  };
  LocalService.prototype.receiveAckEvent = function(message) {
    if (this.destroyed || !this.canListen || !this.canAck || !message.ack || !this.events[message.event] || !this.events[message.event].ack) {
      return;
    }
    this.internalEvents.emit("ack", message);
  };
  LocalService.forward = function(event2) {
    if (this.destroyed) {
      return;
    }
    this.proxy.send({
      __type: MESSAGE_TYPE,
      service: this.id,
      method: "event",
      event: event2.name,
      args: event2.args
    });
  };
  LocalService.forward.ack = false;
  LocalService.forwardWithAck = function(event2, callback) {
    if (this.destroyed) {
      return;
    }
    if (!event2.callback) {
      this.proxy.send({
        __type: MESSAGE_TYPE,
        service: this.id,
        method: "event",
        event: event2.name,
        args: event2.args
      });
      callback();
      return;
    }
    var triggered = false;
    var ackId = this.proxy.nextAckId++;
    var onAck = (message) => {
      if (triggered || message.ack !== ackId) {
        return;
      }
      triggered = true;
      this.internalEvents.off("ack", onAck);
      callback();
    };
    this.internalEvents.on("ack", onAck);
    this.proxy.send({
      __type: MESSAGE_TYPE,
      service: this.id,
      method: "event",
      event: event2.name,
      ack: ackId,
      args: event2.args
    });
  };
  LocalService.forwardWithAck.ack = true;
  function RemoteService(proxy, id) {
    return RemoteService.create(proxy, id);
  }
  Proxy$1.RemoteService = RemoteService;
  var EVENT_NO_ACK = 1;
  var EVENT_ACK = 2;
  RemoteService.create = function(proxy, id) {
    var self2 = Object.create(RemoteService.prototype, {
      proxy: {value: proxy, enumerable: true},
      id: {value: id, enumerable: true},
      emitter: {value: Object.create(NextGenEvents$5.prototype), writable: true, enumerable: true},
      internalEvents: {value: Object.create(NextGenEvents$5.prototype), writable: true, enumerable: true},
      events: {value: {}, enumerable: true},
      destroyed: {value: false, writable: true, enumerable: true}
    });
    return self2;
  };
  RemoteService.prototype.destroy = function() {
    this.emitter.removeAllListeners();
    this.emitter = null;
    Object.keys(this.events).forEach((eventName) => {
      delete this.events[eventName];
    });
    this.destroyed = true;
  };
  RemoteService.prototype.emit = function(eventName, ...args) {
    if (this.destroyed) {
      return;
    }
    var callback, ackId, triggered;
    if (typeof eventName === "number") {
      throw new TypeError("Cannot emit with a nice value on a remote service");
    }
    if (typeof args[args.length - 1] !== "function") {
      this.proxy.send({
        __type: MESSAGE_TYPE,
        service: this.id,
        method: "emit",
        event: eventName,
        args
      });
      return;
    }
    callback = args.pop();
    ackId = this.proxy.nextAckId++;
    triggered = false;
    var onAck = (message) => {
      if (triggered || message.ack !== ackId) {
        return;
      }
      triggered = true;
      this.internalEvents.off("ack", onAck);
      callback(message.interruption);
    };
    this.internalEvents.on("ack", onAck);
    this.proxy.send({
      __type: MESSAGE_TYPE,
      service: this.id,
      method: "emit",
      ack: ackId,
      event: eventName,
      args
    });
  };
  RemoteService.prototype.addListener = function(eventName, fn, options) {
    if (this.destroyed) {
      return;
    }
    if (typeof fn !== "function") {
      options = fn;
      fn = void 0;
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    options.fn = fn || options.fn;
    this.emitter.addListener(eventName, options);
    if (!this.emitter.__ngev.listeners[eventName] || !this.emitter.__ngev.listeners[eventName].length) {
      return;
    }
    if (options.async && this.events[eventName] !== EVENT_ACK) {
      this.events[eventName] = EVENT_ACK;
      this.proxy.send({
        __type: MESSAGE_TYPE,
        service: this.id,
        method: "listen",
        ack: true,
        event: eventName
      });
    } else if (!options.async && !this.events[eventName]) {
      this.events[eventName] = EVENT_NO_ACK;
      this.proxy.send({
        __type: MESSAGE_TYPE,
        service: this.id,
        method: "listen",
        event: eventName
      });
    }
  };
  RemoteService.prototype.on = RemoteService.prototype.addListener;
  RemoteService.prototype.once = NextGenEvents$5.prototype.once;
  RemoteService.prototype.removeListener = function(eventName, id) {
    if (this.destroyed) {
      return;
    }
    this.emitter.removeListener(eventName, id);
    if ((!this.emitter.__ngev.listeners[eventName] || !this.emitter.__ngev.listeners[eventName].length) && this.events[eventName]) {
      this.events[eventName] = 0;
      this.proxy.send({
        __type: MESSAGE_TYPE,
        service: this.id,
        method: "ignore",
        event: eventName
      });
    }
  };
  RemoteService.prototype.off = RemoteService.prototype.removeListener;
  RemoteService.prototype.receiveEvent = function(message) {
    if (this.destroyed || !this.events[message.event]) {
      return;
    }
    var event2 = {
      emitter: this.emitter,
      name: message.event,
      args: message.args || []
    };
    if (message.ack) {
      event2.callback = () => {
        this.proxy.send({
          __type: MESSAGE_TYPE,
          service: this.id,
          method: "ackEvent",
          ack: message.ack,
          event: message.event
        });
      };
    }
    NextGenEvents$5.emitEvent(event2);
    var eventName = event2.name;
    if (!this.emitter.__ngev.listeners[eventName] || !this.emitter.__ngev.listeners[eventName].length) {
      this.events[eventName] = 0;
      this.proxy.send({
        __type: MESSAGE_TYPE,
        service: this.id,
        method: "ignore",
        event: eventName
      });
    }
  };
  RemoteService.prototype.receiveAckEmit = function(message) {
    if (this.destroyed || !message.ack || this.events[message.event] !== EVENT_ACK) {
      return;
    }
    this.internalEvents.emit("ack", message);
  };
  const nextTick = process.browser ? window.setImmediate : process.nextTick;
  if (!commonjsGlobal$2.__NEXTGEN_EVENTS__) {
    commonjsGlobal$2.__NEXTGEN_EVENTS__ = {
      recursions: 0
    };
  }
  var globalData = commonjsGlobal$2.__NEXTGEN_EVENTS__;
  function NextGenEvents$4() {
  }
  var NextGenEvents_1 = NextGenEvents$4;
  NextGenEvents$4.prototype.__prototypeUID__ = "nextgen-events/NextGenEvents";
  NextGenEvents$4.prototype.__prototypeVersion__ = require$$0.version;
  NextGenEvents$4.SYNC = -Infinity;
  NextGenEvents$4.DESYNC = -1;
  NextGenEvents$4.defaultMaxListeners = Infinity;
  NextGenEvents$4.init = function() {
    Object.defineProperty(this, "__ngev", {
      configurable: true,
      value: new NextGenEvents$4.Internal()
    });
  };
  NextGenEvents$4.Internal = function(from) {
    this.nice = NextGenEvents$4.SYNC;
    this.interruptible = false;
    this.contexts = {};
    this.desync = setImmediate;
    this.depth = 0;
    this.states = {};
    this.stateGroups = {};
    this.listeners = {
      error: [],
      interrupt: [],
      newListener: [],
      removeListener: []
    };
    this.hasListenerPriority = false;
    this.maxListeners = NextGenEvents$4.defaultMaxListeners;
    if (from) {
      this.nice = from.nice;
      this.interruptible = from.interruptible;
      Object.assign(this.states, from.states), Object.assign(this.stateGroups, from.stateGroups), Object.keys(from.listeners).forEach((eventName) => {
        this.listeners[eventName] = from.listeners[eventName].slice();
      });
      Object.keys(from.contexts).forEach((contextName) => {
        var context = from.contexts[contextName];
        this.contexts[contextName] = {
          nice: context.nice,
          ready: true,
          status: context.status,
          serial: context.serial,
          scopes: {}
        };
      });
    }
  };
  NextGenEvents$4.initFrom = function(from) {
    if (!from.__ngev) {
      NextGenEvents$4.init.call(from);
    }
    Object.defineProperty(this, "__ngev", {
      configurable: true,
      value: new NextGenEvents$4.Internal(from.__ngev)
    });
  };
  NextGenEvents$4.mergeListeners = function(foreigners) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    var oldListeners = this.__ngev.listeners;
    this.__ngev.listeners = {};
    Object.keys(oldListeners).forEach((eventName) => {
      this.__ngev.listeners[eventName] = [];
    });
    foreigners.forEach((foreigner) => {
      if (!foreigner.__ngev) {
        NextGenEvents$4.init.call(foreigner);
      }
      Object.keys(foreigner.__ngev.listeners).forEach((eventName) => {
        if (!this.__ngev.listeners[eventName]) {
          this.__ngev.listeners[eventName] = [];
        }
      });
    });
    Object.keys(this.__ngev.listeners).forEach((eventName) => {
      var i, iMax, blacklist = [];
      if (oldListeners[eventName]) {
        oldListeners[eventName].forEach((listener) => {
          for (i = 0, iMax = foreigners.length; i < iMax; i++) {
            if (!foreigners[i].__ngev.listeners[eventName] || foreigners[i].__ngev.listeners[eventName].indexOf(listener) === -1) {
              blacklist.push(listener);
              break;
            }
          }
        });
      }
      foreigners.forEach((foreigner) => {
        foreigner.__ngev.listeners[eventName].forEach((listener) => {
          if (this.__ngev.listeners[eventName].indexOf(listener) === -1 && blacklist.indexOf(listener) === -1) {
            this.__ngev.listeners[eventName].push(listener);
          }
        });
      });
    });
  };
  NextGenEvents$4.filterOutCallback = function(what, currentElement) {
    return what !== currentElement;
  };
  NextGenEvents$4.prototype.addListener = function(eventName, fn, options) {
    var listener, newListenerListeners;
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!this.__ngev.listeners[eventName]) {
      this.__ngev.listeners[eventName] = [];
    }
    if (!eventName || typeof eventName !== "string") {
      throw new TypeError(".addListener(): argument #0 should be a non-empty string");
    }
    if (typeof fn === "function") {
      listener = {};
      if (!options || typeof options !== "object") {
        options = {};
      }
    } else if (options === true && fn && typeof fn === "object") {
      options = listener = fn;
      fn = void 0;
    } else {
      options = fn;
      if (!options || typeof options !== "object") {
        throw new TypeError(".addListener(): a function or an object with a 'fn' property which value is a function should be provided");
      }
      fn = void 0;
      listener = {};
    }
    listener.fn = fn || options.fn;
    listener.id = options.id !== void 0 ? options.id : listener.fn;
    listener.once = !!options.once;
    listener.async = !!options.async;
    listener.eventObject = !!options.eventObject;
    listener.nice = options.nice !== void 0 ? Math.floor(options.nice) : NextGenEvents$4.SYNC;
    listener.priority = +options.priority || 0;
    listener.context = options.context && (typeof options.context === "string" || typeof options.context === "object") ? options.context : null;
    if (typeof listener.fn !== "function") {
      throw new TypeError(".addListener(): a function or an object with a 'fn' property which value is a function should be provided");
    }
    if (typeof listener.context === "string") {
      listener.context = this.__ngev.contexts[listener.context] || this.addListenerContext(listener.context);
    }
    listener.event = eventName;
    if (this.__ngev.listeners.newListener.length) {
      newListenerListeners = this.__ngev.listeners.newListener.slice();
      this.__ngev.listeners[eventName].push(listener);
      NextGenEvents$4.emitEvent({
        emitter: this,
        name: "newListener",
        args: [[listener]],
        listeners: newListenerListeners
      });
      if (this.__ngev.states[eventName]) {
        NextGenEvents$4.emitToOneListener(this.__ngev.states[eventName], listener);
      }
      return this;
    }
    this.__ngev.listeners[eventName].push(listener);
    if (this.__ngev.hasListenerPriority) {
      this.__ngev.listeners[eventName].sort((a, b) => b.priority - a.priority);
    }
    if (this.__ngev.listeners[eventName].length === this.__ngev.maxListeners + 1) {
      process.emitWarning("Possible NextGenEvents memory leak detected. " + this.__ngev.listeners[eventName].length + " " + eventName + " listeners added. Use emitter.setMaxListeners() to increase limit", {type: "MaxListenersExceededWarning"});
    }
    if (this.__ngev.states[eventName]) {
      NextGenEvents$4.emitToOneListener(this.__ngev.states[eventName], listener);
    }
    return this;
  };
  NextGenEvents$4.prototype.on = NextGenEvents$4.prototype.addListener;
  NextGenEvents$4.prototype.once = function(eventName, fn, options) {
    if (fn && typeof fn === "object") {
      fn.once = true;
    } else if (options && typeof options === "object") {
      options.once = true;
    } else {
      options = {once: true};
    }
    return this.addListener(eventName, fn, options);
  };
  NextGenEvents$4.prototype.waitFor = function(eventName) {
    return new Promise((resolve) => {
      this.addListener(eventName, (firstArg) => resolve(firstArg), {once: true});
    });
  };
  NextGenEvents$4.prototype.waitForAll = function(eventName) {
    return new Promise((resolve) => {
      this.addListener(eventName, (...args) => resolve(args), {once: true});
    });
  };
  NextGenEvents$4.prototype.removeListener = function(eventName, id) {
    if (!eventName || typeof eventName !== "string") {
      throw new TypeError(".removeListener(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    var listeners = this.__ngev.listeners[eventName];
    if (!listeners || !listeners.length) {
      return this;
    }
    var i, removedListeners, removeCount = 0, length = listeners.length, hasRemoveListener = this.__ngev.listeners.removeListener.length;
    if (hasRemoveListener) {
      removedListeners = [];
    }
    for (i = 0; i < length; i++) {
      if (listeners[i].id === id) {
        removeCount++;
        if (hasRemoveListener) {
          removedListeners.push(listeners[i]);
        }
      } else if (removeCount) {
        listeners[i - removeCount] = listeners[i];
      }
    }
    if (removeCount) {
      listeners.length -= removeCount;
    }
    if (hasRemoveListener && removedListeners.length) {
      this.emit("removeListener", removedListeners);
    }
    return this;
  };
  NextGenEvents$4.prototype.off = NextGenEvents$4.prototype.removeListener;
  NextGenEvents$4.prototype.removeAllListeners = function(eventName) {
    var removedListeners;
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (eventName) {
      if (!eventName || typeof eventName !== "string") {
        throw new TypeError(".removeAllListeners(): argument #0 should be undefined or a non-empty string");
      }
      if (!this.__ngev.listeners[eventName]) {
        this.__ngev.listeners[eventName] = [];
      }
      removedListeners = this.__ngev.listeners[eventName];
      this.__ngev.listeners[eventName] = [];
      if (removedListeners.length && this.__ngev.listeners.removeListener.length) {
        this.emit("removeListener", removedListeners);
      }
    } else {
      this.__ngev.listeners = {
        error: [],
        interrupt: [],
        newListener: [],
        removeListener: []
      };
    }
    return this;
  };
  NextGenEvents$4.listenerWrapper = function(listener, event2, contextScope, serial, nice) {
    var returnValue, listenerCallback, eventMaster = event2.master || event2, interruptible = !!event2.master || event2.emitter.__ngev.interruptible;
    if (eventMaster.interrupt) {
      return;
    }
    if (listener.async) {
      if (contextScope) {
        contextScope.ready = !serial;
      }
      if (nice < 0) {
        if (globalData.recursions >= -nice) {
          event2.emitter.__ngev.desync(NextGenEvents$4.listenerWrapper.bind(void 0, listener, event2, contextScope, serial, NextGenEvents$4.SYNC));
          return;
        }
      } else {
        setTimeout(NextGenEvents$4.listenerWrapper.bind(void 0, listener, event2, contextScope, serial, NextGenEvents$4.SYNC), nice);
        return;
      }
      listenerCallback = (arg) => {
        eventMaster.listenersDone++;
        if (arg && interruptible && !eventMaster.interrupt && event2.name !== "interrupt") {
          eventMaster.interrupt = arg;
          if (eventMaster.callback) {
            NextGenEvents$4.emitCallback(event2);
          }
          event2.emitter.emit("interrupt", eventMaster.interrupt);
        } else if (eventMaster.listenersDone >= eventMaster.listeners.length && eventMaster.callback) {
          NextGenEvents$4.emitCallback(event2);
        }
        if (serial) {
          NextGenEvents$4.processScopeQueue(contextScope, true, true);
        }
      };
      if (listener.eventObject) {
        listener.fn(event2, listenerCallback);
      } else {
        returnValue = listener.fn(...event2.args, listenerCallback);
      }
    } else {
      if (nice < 0) {
        if (globalData.recursions >= -nice) {
          event2.emitter.__ngev.desync(NextGenEvents$4.listenerWrapper.bind(void 0, listener, event2, contextScope, serial, NextGenEvents$4.SYNC));
          return;
        }
      } else {
        setTimeout(NextGenEvents$4.listenerWrapper.bind(void 0, listener, event2, contextScope, serial, NextGenEvents$4.SYNC), nice);
        return;
      }
      if (listener.eventObject) {
        listener.fn(event2);
      } else {
        returnValue = listener.fn(...event2.args);
      }
      eventMaster.listenersDone++;
    }
    if (returnValue && interruptible && !eventMaster.interrupt && event2.name !== "interrupt") {
      eventMaster.interrupt = returnValue;
      if (eventMaster.callback) {
        NextGenEvents$4.emitCallback(event2);
      }
      event2.emitter.emit("interrupt", eventMaster.interrupt);
    } else if (eventMaster.listenersDone >= eventMaster.listeners.length && eventMaster.callback) {
      NextGenEvents$4.emitCallback(event2);
    }
  };
  var nextEventId = 0;
  NextGenEvents$4.prototype.emit = function(...args) {
    var event2 = NextGenEvents$4.createEvent(this, ...args);
    return NextGenEvents$4.emitEvent(event2);
  };
  NextGenEvents$4.prototype.emitIfListener = function(...args) {
    var eventName = typeof args[0] === "number" ? args[1] : args[0];
    if (!this.__ngev || !this.__ngev.listeners[eventName] || !this.__ngev.listeners[eventName].length) {
      return null;
    }
    var event2 = NextGenEvents$4.createEvent(this, ...args);
    return NextGenEvents$4.emitEvent(event2);
  };
  NextGenEvents$4.prototype.waitForEmit = function(...args) {
    return new Promise((resolve) => {
      this.emit(...args, (interrupt) => resolve(interrupt));
    });
  };
  NextGenEvents$4.createEvent = function(emitter, ...args) {
    var event2 = {
      emitter,
      interrupt: null,
      master: null,
      sync: true
    };
    if (typeof args[0] === "number") {
      event2.nice = Math.floor(args[0]);
      event2.name = args[1];
      if (!event2.name || typeof event2.name !== "string") {
        throw new TypeError(".emit(): when argument #0 is a number, argument #1 should be a non-empty string");
      }
      if (typeof args[args.length - 1] === "function") {
        event2.callback = args[args.length - 1];
        event2.args = args.slice(2, -1);
      } else {
        event2.args = args.slice(2);
      }
    } else {
      event2.name = args[0];
      if (!event2.name || typeof event2.name !== "string") {
        throw new TypeError(".emit(): argument #0 should be an number or a non-empty string");
      }
      if (typeof args[args.length - 1] === "function") {
        event2.callback = args[args.length - 1];
        event2.args = args.slice(1, -1);
      } else {
        event2.args = args.slice(1);
      }
    }
    return event2;
  };
  NextGenEvents$4.emitEvent = function(event2) {
    var self2 = event2.emitter, i, iMax, count = 0, state, removedListeners;
    if (!self2.__ngev) {
      NextGenEvents$4.init.call(self2);
    }
    state = self2.__ngev.states[event2.name];
    if (state !== void 0) {
      if (state && event2.args.length === state.args.length && event2.args.every((arg, index) => arg === state.args[index])) {
        return;
      }
      self2.__ngev.stateGroups[event2.name].forEach((eventName) => {
        self2.__ngev.states[eventName] = null;
      });
      self2.__ngev.states[event2.name] = event2;
    }
    if (!self2.__ngev.listeners[event2.name]) {
      self2.__ngev.listeners[event2.name] = [];
    }
    event2.id = nextEventId++;
    event2.listenersDone = 0;
    if (event2.nice === void 0 || event2.nice === null) {
      event2.nice = self2.__ngev.nice;
    }
    if (!event2.listeners) {
      event2.listeners = self2.__ngev.listeners[event2.name].slice();
    }
    globalData.recursions++;
    event2.depth = self2.__ngev.depth++;
    removedListeners = [];
    try {
      for (i = 0, iMax = event2.listeners.length; i < iMax; i++) {
        count++;
        NextGenEvents$4.emitToOneListener(event2, event2.listeners[i], removedListeners);
      }
    } catch (error) {
      globalData.recursions--;
      self2.__ngev.depth--;
      throw error;
    }
    globalData.recursions--;
    if (!event2.callback) {
      self2.__ngev.depth--;
    }
    if (removedListeners.length && self2.__ngev.listeners.removeListener.length) {
      self2.emit("removeListener", removedListeners);
    }
    if (!count) {
      if (event2.name === "error") {
        if (event2.args[0]) {
          throw event2.args[0];
        } else {
          throw Error("Uncaught, unspecified 'error' event.");
        }
      }
      if (event2.callback) {
        NextGenEvents$4.emitCallback(event2);
      }
    }
    event2.sync = false;
    return event2;
  };
  NextGenEvents$4.emitIntricatedEvents = function(array, callback) {
    var i, iMax, count = 0, removedListeners;
    if (!Array.isArray(array)) {
      throw new TypeError(".emitCorrelatedEvents() argument should be an array");
    }
    var listenerEventRows = [], context = {
      nice: NextGenEvents$4.DESYNC,
      ready: true,
      status: NextGenEvents$4.CONTEXT_ENABLED,
      serial: true,
      scopes: {}
    }, master = {
      sync: false,
      nice: NextGenEvents$4.DESYNC,
      context,
      interrupt: null,
      listeners: listenerEventRows,
      listenersDone: 0,
      depth: 0,
      callback
    };
    array.forEach((eventParams) => {
      var event2 = NextGenEvents$4.createEvent(...eventParams);
      event2.master = master;
      if (!event2.emitter.__ngev) {
        NextGenEvents$4.init.call(event2.emitter);
      }
      if (!event2.emitter.__ngev.listeners[event2.name]) {
        event2.emitter.__ngev.listeners[event2.name] = [];
      }
      event2.listeners = event2.emitter.__ngev.listeners[event2.name].slice();
      event2.id = nextEventId++;
      event2.listeners.forEach((listener) => listenerEventRows.push({event: event2, listener}));
    });
    listenerEventRows.sort((a, b) => b.listener.priority - a.listener.priority);
    globalData.recursions++;
    removedListeners = [];
    try {
      for (i = 0, iMax = listenerEventRows.length; i < iMax; i++) {
        count++;
        NextGenEvents$4.emitToOneListener(listenerEventRows[i].event, listenerEventRows[i].listener, removedListeners);
      }
    } catch (error) {
      globalData.recursions--;
      throw error;
    }
    globalData.recursions--;
    if (!count && master.callback) {
      NextGenEvents$4.emitCallback(event);
    }
    master.sync = false;
  };
  NextGenEvents$4.emitToOneListener = function(event2, listener, removedListeners) {
    var self2 = event2.emitter, eventMaster = event2.master || event2, context = event2.master ? event2.master.context : listener.context, contextScope, serial, currentNice, emitRemoveListener = false;
    if (context) {
      if (context.status === NextGenEvents$4.CONTEXT_DISABLED) {
        return;
      }
      currentNice = Math.max(eventMaster.nice, listener.nice, context.nice);
      serial = context.serial;
      contextScope = NextGenEvents$4.getContextScope(context, eventMaster.depth);
    } else {
      currentNice = Math.max(eventMaster.nice, listener.nice);
    }
    if (listener.once) {
      self2.__ngev.listeners[event2.name] = self2.__ngev.listeners[event2.name].filter(NextGenEvents$4.filterOutCallback.bind(void 0, listener));
      if (removedListeners) {
        removedListeners.push(listener);
      } else {
        emitRemoveListener = true;
      }
    }
    if (context && (context.status === NextGenEvents$4.CONTEXT_QUEUED || !contextScope.ready)) {
      contextScope.queue.push({event: event2, listener, nice: currentNice});
    } else {
      NextGenEvents$4.listenerWrapper(listener, event2, contextScope, serial, currentNice);
    }
    if (emitRemoveListener && self2.__ngev.listeners.removeListener.length) {
      self2.emit("removeListener", [listener]);
    }
  };
  NextGenEvents$4.emitCallback = function(event2) {
    var callback;
    if (event2.master) {
      callback = event2.master.callback;
      delete event2.master.callback;
      if (event2.master.sync) {
        nextTick(() => callback(event2.master.interrupt, event2));
      } else {
        callback(event2.master.interrupt, event2);
      }
      return;
    }
    callback = event2.callback;
    delete event2.callback;
    if (event2.sync && event2.emitter.__ngev.nice !== NextGenEvents$4.SYNC) {
      event2.emitter.__ngev.desync(() => {
        event2.emitter.__ngev.depth--;
        callback(event2.interrupt, event2);
      });
    } else {
      event2.emitter.__ngev.depth--;
      callback(event2.interrupt, event2);
    }
  };
  NextGenEvents$4.prototype.listeners = function(eventName) {
    if (!eventName || typeof eventName !== "string") {
      throw new TypeError(".listeners(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!this.__ngev.listeners[eventName]) {
      this.__ngev.listeners[eventName] = [];
    }
    return this.__ngev.listeners[eventName].slice();
  };
  NextGenEvents$4.listenerCount = function(emitter, eventName) {
    if (!emitter || !(emitter instanceof NextGenEvents$4)) {
      throw new TypeError(".listenerCount(): argument #0 should be an instance of NextGenEvents");
    }
    return emitter.listenerCount(eventName);
  };
  NextGenEvents$4.prototype.listenerCount = function(eventName) {
    if (!eventName || typeof eventName !== "string") {
      throw new TypeError(".listenerCount(): argument #1 should be a non-empty string");
    }
    if (!this.__ngev || !this.__ngev.listeners[eventName]) {
      return 0;
    }
    return this.__ngev.listeners[eventName].length;
  };
  NextGenEvents$4.prototype.setNice = function(nice) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    this.__ngev.nice = Math.floor(+nice || 0);
  };
  NextGenEvents$4.prototype.desyncUseNextTick = function(useNextTick) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    this.__ngev.desync = useNextTick ? nextTick : setImmediate;
  };
  NextGenEvents$4.prototype.setInterruptible = function(isInterruptible) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    this.__ngev.interruptible = !!isInterruptible;
  };
  NextGenEvents$4.prototype.setListenerPriority = function(hasListenerPriority) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    this.__ngev.hasListenerPriority = !!hasListenerPriority;
  };
  NextGenEvents$4.share = function(source, target) {
    if (!(source instanceof NextGenEvents$4) || !(target instanceof NextGenEvents$4)) {
      throw new TypeError("NextGenEvents.share() arguments should be instances of NextGenEvents");
    }
    if (!source.__ngev) {
      NextGenEvents$4.init.call(source);
    }
    Object.defineProperty(target, "__ngev", {
      configurable: true,
      value: source.__ngev
    });
  };
  NextGenEvents$4.reset = function(emitter) {
    Object.defineProperty(emitter, "__ngev", {
      configurable: true,
      value: null
    });
  };
  NextGenEvents$4.prototype.getMaxListeners = function() {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    return this.__ngev.maxListeners;
  };
  NextGenEvents$4.prototype.setMaxListeners = function(n) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    this.__ngev.maxListeners = typeof n === "number" && !Number.isNaN(n) ? Math.floor(n) : NextGenEvents$4.defaultMaxListeners;
    return this;
  };
  NextGenEvents$4.noop = () => void 0;
  NextGenEvents$4.prototype.defineStates = function(...states) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    states.forEach((state) => {
      this.__ngev.states[state] = null;
      this.__ngev.stateGroups[state] = states;
    });
  };
  NextGenEvents$4.prototype.hasState = function(state) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    return !!this.__ngev.states[state];
  };
  NextGenEvents$4.prototype.getAllStates = function() {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    return Object.keys(this.__ngev.states).filter((e) => this.__ngev.states[e]);
  };
  NextGenEvents$4.groupAddListener = function(emitters, eventName, fn, options) {
    if (typeof fn !== "function") {
      options = fn;
      fn = void 0;
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    fn = fn || options.fn;
    delete options.fn;
    options.id = options.id || fn;
    emitters.forEach((emitter) => {
      emitter.addListener(eventName, fn.bind(void 0, emitter), options);
    });
  };
  NextGenEvents$4.groupOn = NextGenEvents$4.groupAddListener;
  NextGenEvents$4.groupOnce = function(emitters, eventName, fn, options) {
    if (fn && typeof fn === "object") {
      fn.once = true;
    } else if (options && typeof options === "object") {
      options.once = true;
    } else {
      options = {once: true};
    }
    return this.groupAddListener(emitters, eventName, fn, options);
  };
  NextGenEvents$4.groupWaitFor = function(emitters, eventName) {
    return Promise.all(emitters.map((emitter) => emitter.waitFor(eventName)));
  };
  NextGenEvents$4.groupWaitForAll = function(emitters, eventName) {
    return Promise.all(emitters.map((emitter) => emitter.waitForAll(eventName)));
  };
  NextGenEvents$4.groupOnceFirst = function(emitters, eventName, fn, options) {
    var fnWrapper, triggered = false;
    if (typeof fn !== "function") {
      options = fn;
      fn = void 0;
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    fn = fn || options.fn;
    delete options.fn;
    options.id = options.id || fn;
    fnWrapper = (...args) => {
      if (triggered) {
        return;
      }
      triggered = true;
      NextGenEvents$4.groupRemoveListener(emitters, eventName, options.id);
      fn(...args);
    };
    emitters.forEach((emitter) => {
      emitter.once(eventName, fnWrapper.bind(void 0, emitter), options);
    });
  };
  NextGenEvents$4.groupWaitForFirst = function(emitters, eventName) {
    return new Promise((resolve) => {
      NextGenEvents$4.groupOnceFirst(emitters, eventName, (firstArg) => resolve(firstArg));
    });
  };
  NextGenEvents$4.groupWaitForFirstAll = function(emitters, eventName) {
    return new Promise((resolve) => {
      NextGenEvents$4.groupOnceFirst(emitters, eventName, (...args) => resolve(args));
    });
  };
  NextGenEvents$4.groupOnceLast = function(emitters, eventName, fn, options) {
    var fnWrapper, triggered = false, count = emitters.length;
    if (typeof fn !== "function") {
      options = fn;
      fn = void 0;
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    fn = fn || options.fn;
    delete options.fn;
    options.id = options.id || fn;
    fnWrapper = (...args) => {
      if (triggered) {
        return;
      }
      if (--count) {
        return;
      }
      triggered = true;
      fn(...args);
    };
    emitters.forEach((emitter) => {
      emitter.once(eventName, fnWrapper.bind(void 0, emitter), options);
    });
  };
  NextGenEvents$4.groupWaitForLast = function(emitters, eventName) {
    return new Promise((resolve) => {
      NextGenEvents$4.groupOnceLast(emitters, eventName, (firstArg) => resolve(firstArg));
    });
  };
  NextGenEvents$4.groupWaitForLastAll = function(emitters, eventName) {
    return new Promise((resolve) => {
      NextGenEvents$4.groupOnceLast(emitters, eventName, (...args) => resolve(args));
    });
  };
  NextGenEvents$4.groupRemoveListener = function(emitters, eventName, id) {
    emitters.forEach((emitter) => {
      emitter.removeListener(eventName, id);
    });
  };
  NextGenEvents$4.groupOff = NextGenEvents$4.groupRemoveListener;
  NextGenEvents$4.groupRemoveAllListeners = function(emitters, eventName) {
    emitters.forEach((emitter) => {
      emitter.removeAllListeners(eventName);
    });
  };
  NextGenEvents$4.groupEmit = function(emitters, ...args) {
    var eventName, nice, argStart = 1, argEnd, count = emitters.length, callback, callbackWrapper, callbackTriggered = false;
    if (typeof args[args.length - 1] === "function") {
      argEnd = -1;
      callback = args[args.length - 1];
      callbackWrapper = (interruption) => {
        if (callbackTriggered) {
          return;
        }
        if (interruption) {
          callbackTriggered = true;
          callback(interruption);
        } else if (!--count) {
          callbackTriggered = true;
          callback();
        }
      };
    }
    if (typeof args[0] === "number") {
      argStart = 2;
      nice = typeof args[0];
    }
    eventName = args[argStart - 1];
    args = args.slice(argStart, argEnd);
    emitters.forEach((emitter) => {
      NextGenEvents$4.emitEvent({
        emitter,
        name: eventName,
        args,
        nice,
        callback: callbackWrapper
      });
    });
  };
  NextGenEvents$4.groupWaitForEmit = function(emitters, ...args) {
    return new Promise((resolve) => {
      NextGenEvents$4.groupEmit(emitters, ...args, (interrupt) => resolve(interrupt));
    });
  };
  NextGenEvents$4.groupDefineStates = function(emitters, ...args) {
    emitters.forEach((emitter) => {
      emitter.defineStates(...args);
    });
  };
  NextGenEvents$4.groupGlobalOnce = NextGenEvents$4.groupOnceFirst;
  NextGenEvents$4.groupGlobalOnceAll = NextGenEvents$4.groupOnceLast;
  NextGenEvents$4.CONTEXT_ENABLED = 0;
  NextGenEvents$4.CONTEXT_DISABLED = 1;
  NextGenEvents$4.CONTEXT_QUEUED = 2;
  NextGenEvents$4.prototype.addListenerContext = function(contextName, options) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!contextName || typeof contextName !== "string") {
      throw new TypeError(".addListenerContext(): argument #0 should be a non-empty string");
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    var context = this.__ngev.contexts[contextName];
    if (!context) {
      context = this.__ngev.contexts[contextName] = {
        nice: NextGenEvents$4.SYNC,
        ready: true,
        status: NextGenEvents$4.CONTEXT_ENABLED,
        serial: false,
        scopes: {}
      };
    }
    if (options.nice !== void 0) {
      context.nice = Math.floor(options.nice);
    }
    if (options.status !== void 0) {
      context.status = options.status;
    }
    if (options.serial !== void 0) {
      context.serial = !!options.serial;
    }
    return context;
  };
  NextGenEvents$4.prototype.getListenerContext = function(contextName) {
    return this.__ngev.contexts[contextName];
  };
  NextGenEvents$4.getContextScope = function(context, scopeName) {
    var scope = context.scopes[scopeName];
    if (!scope) {
      scope = context.scopes[scopeName] = {
        ready: true,
        queue: []
      };
    }
    return scope;
  };
  NextGenEvents$4.prototype.disableListenerContext = function(contextName) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!contextName || typeof contextName !== "string") {
      throw new TypeError(".disableListenerContext(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev.contexts[contextName]) {
      this.addListenerContext(contextName);
    }
    this.__ngev.contexts[contextName].status = NextGenEvents$4.CONTEXT_DISABLED;
    return this;
  };
  NextGenEvents$4.prototype.enableListenerContext = function(contextName) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!contextName || typeof contextName !== "string") {
      throw new TypeError(".enableListenerContext(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev.contexts[contextName]) {
      this.addListenerContext(contextName);
    }
    var context = this.__ngev.contexts[contextName];
    context.status = NextGenEvents$4.CONTEXT_ENABLED;
    Object.values(context.scopes).forEach((contextScope) => {
      if (contextScope.queue.length > 0) {
        NextGenEvents$4.processScopeQueue(contextScope, context.serial);
      }
    });
    return this;
  };
  NextGenEvents$4.prototype.queueListenerContext = function(contextName) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!contextName || typeof contextName !== "string") {
      throw new TypeError(".queueListenerContext(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev.contexts[contextName]) {
      this.addListenerContext(contextName);
    }
    this.__ngev.contexts[contextName].status = NextGenEvents$4.CONTEXT_QUEUED;
    return this;
  };
  NextGenEvents$4.prototype.serializeListenerContext = function(contextName, value) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!contextName || typeof contextName !== "string") {
      throw new TypeError(".serializeListenerContext(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev.contexts[contextName]) {
      this.addListenerContext(contextName);
    }
    this.__ngev.contexts[contextName].serial = value === void 0 ? true : !!value;
    return this;
  };
  NextGenEvents$4.prototype.setListenerContextNice = function(contextName, nice) {
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    if (!contextName || typeof contextName !== "string") {
      throw new TypeError(".setListenerContextNice(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev.contexts[contextName]) {
      this.addListenerContext(contextName);
    }
    this.__ngev.contexts[contextName].nice = Math.floor(nice);
    return this;
  };
  NextGenEvents$4.prototype.destroyListenerContext = function(contextName) {
    var i, length, context, eventName, newListeners, removedListeners = [];
    if (!contextName || typeof contextName !== "string") {
      throw new TypeError(".disableListenerContext(): argument #0 should be a non-empty string");
    }
    if (!this.__ngev) {
      NextGenEvents$4.init.call(this);
    }
    context = this.__ngev.contexts[contextName];
    if (!context) {
      return;
    }
    for (eventName in this.__ngev.listeners) {
      newListeners = null;
      length = this.__ngev.listeners[eventName].length;
      for (i = 0; i < length; i++) {
        if (this.__ngev.listeners[eventName][i].context === context) {
          newListeners = [];
          removedListeners.push(this.__ngev.listeners[eventName][i]);
        } else if (newListeners) {
          newListeners.push(this.__ngev.listeners[eventName][i]);
        }
      }
      if (newListeners) {
        this.__ngev.listeners[eventName] = newListeners;
      }
    }
    delete this.__ngev.contexts[contextName];
    if (removedListeners.length && this.__ngev.listeners.removeListener.length) {
      this.emit("removeListener", removedListeners);
    }
    return this;
  };
  NextGenEvents$4.processScopeQueue = function(contextScope, serial, isCompletionCallback) {
    var job, event2, eventMaster;
    if (isCompletionCallback) {
      contextScope.ready = true;
    }
    globalData.recursions++;
    while (contextScope.ready && contextScope.queue.length) {
      job = contextScope.queue.shift();
      event2 = job.event;
      eventMaster = event2.master || event2;
      event2.emitter;
      if (eventMaster.interrupt) {
        continue;
      }
      NextGenEvents$4.listenerWrapper(job.listener, event2, contextScope, serial, job.nice);
    }
    globalData.recursions--;
  };
  NextGenEvents$4.on = NextGenEvents$4.prototype.on;
  NextGenEvents$4.once = NextGenEvents$4.prototype.once;
  NextGenEvents$4.off = NextGenEvents$4.prototype.off;
  if (commonjsGlobal$2.AsyncTryCatch) {
    NextGenEvents$4.prototype.asyncTryCatchId = commonjsGlobal$2.AsyncTryCatch.NextGenEvents.length;
    commonjsGlobal$2.AsyncTryCatch.NextGenEvents.push(NextGenEvents$4);
    if (commonjsGlobal$2.AsyncTryCatch.substituted) {
      commonjsGlobal$2.AsyncTryCatch.substitute();
    }
  }
  NextGenEvents$4.Proxy = _Proxy;
  var Promise$a = seventh_1;
  var yesOrNo = function yesOrNo(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    if (!options || typeof options !== "object") {
      options = {
        yes: ["y", "Y"],
        no: ["n", "N"],
        echoYes: "yes",
        echoNo: "no"
      };
    }
    if (typeof options.yes === "string") {
      options.yes = [options.yes];
    }
    if (!Array.isArray(options.yes)) {
      options.yes = ["y", "Y"];
    }
    if (typeof options.no === "string") {
      options.no = [options.no];
    }
    if (!Array.isArray(options.no)) {
      options.no = ["n", "N"];
    }
    if (!this.grabbing) {
      this.grabInput();
    }
    var onKey = (key) => {
      if (options.yes.indexOf(key) !== -1) {
        if (options.echoYes) {
          this(options.echoYes);
        }
        this.removeListener("key", onKey);
        if (callback) {
          callback(void 0, true);
        } else {
          controller.promise.resolve(true);
        }
      } else if (options.no.indexOf(key) !== -1) {
        if (options.echoNo) {
          this(options.echoNo);
        }
        this.removeListener("key", onKey);
        if (callback) {
          callback(void 0, false);
        } else {
          controller.promise.resolve(false);
        }
      }
    };
    this.on("key", onKey);
    var controller = {};
    controller.abort = () => {
      this.removeListener("key", onKey);
    };
    controller.promise = new Promise$a();
    return controller;
  };
  var autoComplete$2 = function autoComplete(array, startString, returnAlternatives, prefix, postfix) {
    var i, j, exitLoop, candidate = [], completed = startString, hasCompleted = false;
    if (!prefix) {
      prefix = "";
    }
    if (!postfix) {
      postfix = "";
    }
    for (i = 0; i < array.length; i++) {
      if (array[i].slice(0, startString.length) === startString) {
        candidate.push(array[i]);
      }
    }
    if (!candidate.length) {
      return prefix + completed + postfix;
    }
    if (candidate.length === 1) {
      return prefix + candidate[0] + postfix;
    }
    j = startString.length;
    exitLoop = false;
    for (j = startString.length; j < candidate[0].length; j++) {
      for (i = 1; i < candidate.length; i++) {
        if (candidate[i][j] !== candidate[0][j]) {
          exitLoop = true;
          break;
        }
      }
      if (exitLoop) {
        break;
      }
      completed += candidate[0][j];
      hasCompleted = true;
    }
    if (returnAlternatives && !hasCompleted) {
      candidate.prefix = prefix;
      candidate.postfix = postfix;
      return candidate;
    }
    return prefix + completed + postfix;
  };
  const NextGenEvents$3 = NextGenEvents_1;
  const Promise$9 = seventh_1;
  const string$2 = string$4;
  const autoComplete$1 = autoComplete$2;
  const defaultKeyBindings$3 = {
    ENTER: "submit",
    KP_ENTER: "submit",
    ESCAPE: "cancel",
    BACKSPACE: "backDelete",
    DELETE: "delete",
    LEFT: "backward",
    RIGHT: "forward",
    UP: "historyPrevious",
    DOWN: "historyNext",
    HOME: "startOfInput",
    END: "endOfInput",
    TAB: "autoComplete",
    CTRL_R: "autoCompleteUsingHistory",
    CTRL_LEFT: "previousWord",
    CTRL_RIGHT: "nextWord",
    ALT_D: "deleteNextWord",
    CTRL_W: "deletePreviousWord",
    CTRL_U: "deleteAllBefore",
    CTRL_K: "deleteAllAfter"
  };
  const defaultTokenRegExp = /\S+/g;
  var inputField = function inputField(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options || typeof options !== "object") {
      options = {};
    }
    if (options.echo === void 0) {
      options.echo = true;
    }
    if (typeof options.maxLength !== "number") {
      options.maxLength = Infinity;
    }
    if (typeof options.minLength !== "number") {
      options.minLength = 0;
    }
    if (options.echoChar && typeof options.echoChar !== "string") {
      options.echoChar = "\u2022";
    }
    if (options.autoCompleteMenu) {
      if (typeof options.autoCompleteMenu !== "object") {
        options.autoCompleteMenu = {};
      }
      options.autoCompleteMenu.exitOnUnexpectedKey = true;
      delete options.autoCompleteMenu.y;
    }
    var keyBindings = options.keyBindings || defaultKeyBindings$3;
    if (options.tokenRegExp && (!(options.tokenRegExp instanceof RegExp) || !options.tokenRegExp.flags.includes("g"))) {
      throw new Error(".inputField(): if set, the 'tokenRegExp' option should be a RegExp with the 'g' flag");
    }
    if (!this.grabbing) {
      this.grabInput();
    }
    var controller, finished = false, paused = false, alreadyCleanedUp = false, offset = options.cursorPosition !== void 0 ? options.cursorPosition : -1, echo = !!options.echo, start = {}, end = {}, cursor = {}, endHint = {}, inputs = [], inputIndex, alwaysRedraw = options.tokenHook || options.autoCompleteHint, hint = [], meta = false;
    var dynamic = {
      style: options.style || this,
      hintStyle: options.hintStyle || this.brightBlack,
      tokenRegExp: options.tokenRegExp || defaultTokenRegExp,
      autoComplete: options.autoComplete,
      autoCompleteMenu: options.autoCompleteMenu,
      autoCompleteHint: !!options.autoCompleteHint
    };
    if (Array.isArray(options.history)) {
      inputs = options.history.map((str) => string$2.unicode.toArray(str).slice(0, options.maxLength));
    }
    if (options.default && typeof options.default === "string") {
      inputs.push(string$2.unicode.toArray(options.default).slice(0, options.maxLength));
    } else {
      inputs.push([]);
    }
    var init = () => {
      inputIndex = inputs.length - 1;
      offset = boundOffset(offset);
      if (options.y !== void 0) {
        options.x = options.x || 1;
        this.moveTo.eraseLineAfter(options.x, options.y);
        finishInit(options.x, options.y);
      } else {
        this.getCursorLocation((error, x, y) => {
          if (error) {
            this.row.eraseLineAfter(this.height)("\n> ");
            x = 3;
            y = this.height;
          }
          finishInit(x, y);
        });
      }
    };
    var finishInit = (x, y) => {
      start.x = end.x = cursor.x = x;
      start.y = end.y = cursor.y = y;
      if (inputs[inputIndex].length) {
        computeAllCoordinate();
        redraw();
      }
      this.on("key", onKey);
      controller.emit("ready");
    };
    var cleanup = (error, input) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      finished = true;
      this.removeListener("key", onKey);
      if (error === "abort") {
        return;
      }
      this.styleReset();
      if (error) {
        if (callback) {
          callback(error);
        } else {
          controller.promise.reject(error);
        }
        return;
      }
      var value;
      if (typeof input === "string") {
        value = input;
      } else if (input) {
        value = input.join("");
      }
      if (callback) {
        callback(void 0, value);
      } else {
        controller.promise.resolve(value);
      }
    };
    var computeAllCoordinate = () => {
      var scroll, inputWidth = string$2.unicode.arrayWidth(inputs[inputIndex]), hintWidth = string$2.unicode.arrayWidth(hint);
      end = offsetCoordinate(inputWidth);
      endHint = offsetCoordinate(inputWidth + hintWidth);
      if (endHint.y > this.height) {
        scroll = endHint.y - this.height;
        dynamic.style.noFormat("\n".repeat(scroll));
        start.y -= scroll;
        end.y -= scroll;
        endHint.y -= scroll;
      }
      cursorCoordinate();
    };
    var cursorCoordinate = () => {
      cursor = offsetCoordinate(string$2.unicode.arrayWidth(inputs[inputIndex], offset));
    };
    var offsetCoordinate = (offset_) => {
      return {
        x: 1 + (start.x + offset_ - 1) % this.width,
        y: start.y + Math.floor((start.x + offset_ - 1) / this.width)
      };
    };
    var boundOffset = (offset_) => {
      if (typeof offset_ !== "number" || isNaN(offset_)) {
        return inputs[inputIndex].length;
      }
      if (offset_ < 0) {
        offset_ = inputs[inputIndex].length + 1 + offset_;
      }
      if (offset_ < 0) {
        offset_ = 0;
      } else if (offset_ >= inputs[inputIndex].length) {
        offset_ = inputs[inputIndex].length;
      }
      return offset_;
    };
    var redraw = (extraLines, forceClear) => {
      var i, hintCleared;
      extraLines = extraLines || 0;
      if (!dynamic.autoCompleteHint && forceClear) {
        this.moveTo(end.x, end.y);
        dynamic.style.noFormat.eraseLineAfter("");
      }
      this.moveTo(start.x, start.y);
      if (options.tokenHook) {
        writeTokens(inputs[inputIndex].join(""));
      } else if (options.echoChar) {
        dynamic.style.noFormat(options.echoChar.repeat(inputs[inputIndex].length));
      } else {
        dynamic.style.noFormat(inputs[inputIndex].join(""));
      }
      hintCleared = clearHint();
      if (extraLines > 0) {
        for (i = 1; i <= extraLines; i++) {
          this.moveTo(1, end.y + i);
          dynamic.style.noFormat.eraseLineAfter("");
        }
      }
      if (!hintCleared && (cursor.y < end.y || end.x === this.width)) {
        this.moveTo(end.x, end.y);
        dynamic.style.noFormat.eraseLineAfter("");
      }
      this.moveTo(cursor.x, cursor.y);
    };
    var redrawCursor = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", redrawCursor);
        return;
      }
      this.moveTo(cursor.x, cursor.y);
    };
    var pause = () => {
      if (paused) {
        return;
      }
      paused = true;
    };
    var resume = () => {
      if (!paused) {
        return;
      }
      paused = false;
      if (controller.hasState("ready")) {
        redraw();
      }
    };
    var clearHint = () => {
      if (!dynamic.autoCompleteHint) {
        return false;
      }
      var y = end.y;
      this.moveTo(end.x, end.y);
      dynamic.style.noFormat.eraseLineAfter("");
      while (y < endHint.y) {
        y++;
        this.moveTo(1, y);
        dynamic.style.noFormat.eraseLineAfter("");
      }
      this.moveTo(cursor.x, cursor.y);
      return true;
    };
    var autoCompleteMenu = (menu) => {
      paused = true;
      this.singleLineMenu(menu, dynamic.autoCompleteMenu, (error, response) => {
        paused = false;
        if (error) {
          return;
        }
        if (response.selectedText) {
          if (menu.prefix) {
            response.selectedText = menu.prefix + response.selectedText;
          }
          if (menu.postfix) {
            response.selectedText += menu.postfix;
          }
          response.selectedText = string$2.unicode.toArray(response.selectedText).slice(0, options.maxLength);
          inputs[inputIndex] = response.selectedText.concat(inputs[inputIndex].slice(offset, options.maxLength + offset - response.selectedText.length));
          offset = response.selectedText.length;
        }
        if (echo) {
          this.column.eraseLineAfter(1);
          if (end.y >= this.height && start.y > 1) {
            start.y--;
          }
          computeAllCoordinate();
          redraw();
          this.moveTo(cursor.x, cursor.y);
        }
        if (response.unexpectedKey && response.unexpectedKey !== "TAB") {
          onKey(response.unexpectedKey, void 0, response.unexpectedKeyData);
        }
      }).on("highlight", (eventData) => controller.emit("highlight", eventData));
    };
    var writeTokens = (text) => {
      var match, lastIndex, lastEndIndex = 0, tokens = [], tokenStyle, isEndOfInput;
      dynamic.style = options.style || this;
      dynamic.hintStyle = options.hintStyle || this.brightBlack;
      dynamic.tokenRegExp = options.tokenRegExp || defaultTokenRegExp;
      dynamic.autoComplete = options.autoComplete;
      dynamic.autoCompleteMenu = options.autoCompleteMenu;
      dynamic.autoCompleteHint = !!options.autoCompleteHint;
      dynamic.tokenRegExp.lastIndex = 0;
      if (options.tokenResetHook) {
        options.tokenResetHook(this, dynamic);
      }
      while ((match = dynamic.tokenRegExp.exec(text)) !== null) {
        lastIndex = dynamic.tokenRegExp.lastIndex;
        if (match.index > lastEndIndex) {
          dynamic.style.noFormat(text.slice(lastEndIndex, match.index));
        }
        isEndOfInput = match.index + match[0].length === text.length;
        tokenStyle = options.tokenHook(match[0], isEndOfInput, tokens, this, dynamic);
        if (typeof tokenStyle === "function") {
          tokenStyle.noFormat(match[0]);
        } else if (typeof tokenStyle === "string") {
          this.noFormat(tokenStyle);
        } else {
          dynamic.style.noFormat(match[0]);
        }
        tokens.push(match[0]);
        lastEndIndex = match.index + match[0].length;
        dynamic.tokenRegExp.lastIndex = lastIndex;
      }
      if (lastEndIndex < text.length) {
        dynamic.style.noFormat(text.slice(lastEndIndex));
      }
    };
    var autoCompleteHint = () => {
      if (!dynamic.autoComplete || !dynamic.autoCompleteHint || offset < inputs[inputIndex].length) {
        return;
      }
      var autoCompleted, inputText = inputs[inputIndex].join("");
      var finishCompletion = () => {
        if (Array.isArray(autoCompleted)) {
          return;
        }
        hint = string$2.unicode.toArray(autoCompleted.slice(inputText.length)).slice(0, options.maxLength - inputs[inputIndex].length);
        computeAllCoordinate();
        this.moveTo(end.x, end.y);
        dynamic.hintStyle.noFormat(hint.join(""));
        this.moveTo(cursor.x, cursor.y);
      };
      if (Array.isArray(dynamic.autoComplete)) {
        autoCompleted = autoComplete$1(dynamic.autoComplete, inputText, dynamic.autoCompleteMenu);
      } else if (typeof dynamic.autoComplete === "function") {
        if (dynamic.autoComplete.length === 2) {
          dynamic.autoComplete(inputText, (error, autoCompleted_) => {
            if (error) {
              cleanup(error);
              return;
            }
            autoCompleted = autoCompleted_;
            finishCompletion();
          });
          return;
        }
        autoCompleted = dynamic.autoComplete(inputText);
        if (Promise$9.isThenable(autoCompleted)) {
          autoCompleted.then((autoCompleted_) => {
            autoCompleted = autoCompleted_;
            finishCompletion();
          }, (error) => {
            cleanup(error);
          });
          return;
        }
      }
      finishCompletion();
    };
    var onKey = (key, trash, data) => {
      if (finished || paused) {
        return;
      }
      var leftPart, autoCompleteUsed, autoCompleted, extraLines, charToDelete, cutOffset, altKey, lastOffset = offset;
      if (meta) {
        meta = false;
        altKey = "ALT_" + key.toUpperCase();
        if (data) {
          data.isCharacter = false;
        }
        if (keyBindings[altKey]) {
          key = altKey;
        }
      }
      if (data && data.isCharacter) {
        if (inputs[inputIndex].length >= options.maxLength) {
          return;
        }
        inputs[inputIndex].splice(offset, 0, key);
        offset++;
        if (echo) {
          if (offset === inputs[inputIndex].length && !alwaysRedraw) {
            dynamic.style.noFormat(options.echoChar || key);
            computeAllCoordinate();
          } else {
            computeAllCoordinate();
            redraw();
            if (dynamic.autoCompleteHint) {
              autoCompleteHint();
            }
          }
        }
      } else {
        switch (keyBindings[key]) {
          case "submit":
            if (inputs[inputIndex].length < options.minLength) {
              break;
            }
            clearHint();
            cleanup(void 0, inputs[inputIndex]);
            break;
          case "cancel":
            if (options.cancelable) {
              cleanup();
            }
            break;
          case "meta":
            meta = true;
            break;
          case "backDelete":
            if (inputs[inputIndex].length && offset > 0) {
              charToDelete = inputs[inputIndex][offset - 1];
              inputs[inputIndex].splice(offset - 1, 1);
              offset--;
              if (echo) {
                if (cursor.y < end.y || cursor.x === 1 || alwaysRedraw) {
                  computeAllCoordinate();
                  redraw(void 0, true);
                  if (dynamic.autoCompleteHint) {
                    autoCompleteHint();
                  }
                } else {
                  computeAllCoordinate();
                  if (string$2.unicode.isFullWidth(charToDelete)) {
                    this.left(2);
                    this.delete(2);
                  } else {
                    this.left(1);
                    this.delete(1);
                  }
                }
              }
            }
            break;
          case "delete":
            if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
              charToDelete = inputs[inputIndex][offset];
              inputs[inputIndex].splice(offset, 1);
              if (echo) {
                if (cursor.y < end.y || alwaysRedraw) {
                  computeAllCoordinate();
                  redraw(void 0, true);
                  if (dynamic.autoCompleteHint) {
                    autoCompleteHint();
                  }
                } else {
                  computeAllCoordinate();
                  this.delete(string$2.unicode.isFullWidth(charToDelete) ? 2 : 1);
                }
              }
            }
            break;
          case "deleteAllBefore":
            if (inputs[inputIndex].length && offset > 0) {
              inputs[inputIndex].splice(0, offset);
              offset = 0;
              if (echo) {
                computeAllCoordinate();
                redraw(void 0, true);
              }
            }
            break;
          case "deleteAllAfter":
            if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
              inputs[inputIndex].splice(offset, inputs[inputIndex].length - offset);
              if (echo) {
                computeAllCoordinate();
                redraw(void 0, true);
                if (dynamic.autoCompleteHint) {
                  autoCompleteHint();
                }
              }
            }
            break;
          case "backward":
            if (inputs[inputIndex].length && offset > 0) {
              if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                clearHint();
              }
              offset--;
              if (echo) {
                computeAllCoordinate();
                this.moveTo(cursor.x, cursor.y);
              }
            }
            break;
          case "forward":
            if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
              offset++;
              if (echo) {
                computeAllCoordinate();
                this.moveTo(cursor.x, cursor.y);
              }
              if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                autoCompleteHint();
              }
            }
            break;
          case "deletePreviousWord":
            if (inputs[inputIndex].length && offset > 0) {
              if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                clearHint();
              }
              cutOffset = offset--;
              while (offset > 0 && inputs[inputIndex][offset] === " ") {
                offset--;
              }
              while (offset > 0 && inputs[inputIndex][offset - 1] !== " ") {
                offset--;
              }
              inputs[inputIndex].splice(offset, cutOffset - offset);
              if (echo) {
                computeAllCoordinate();
                this.moveTo(cursor.x, cursor.y);
                redraw(void 0, true);
              }
            }
            break;
          case "deleteNextWord":
            if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
              cutOffset = offset;
              while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] === " ") {
                offset++;
              }
              while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] !== " ") {
                offset++;
              }
              while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] === " ") {
                offset++;
              }
              inputs[inputIndex].splice(cutOffset, offset - cutOffset);
              offset = Math.min(inputs[inputIndex].length, cutOffset);
              if (echo) {
                computeAllCoordinate();
                this.moveTo(cursor.x, cursor.y);
                redraw(void 0, true);
              }
              if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                autoCompleteHint();
              }
            }
            break;
          case "previousWord":
            if (inputs[inputIndex].length && offset > 0) {
              if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                clearHint();
              }
              offset--;
              while (offset > 0 && inputs[inputIndex][offset] === " ") {
                offset--;
              }
              while (offset > 0 && inputs[inputIndex][offset - 1] !== " ") {
                offset--;
              }
              if (echo) {
                computeAllCoordinate();
                this.moveTo(cursor.x, cursor.y);
              }
            }
            break;
          case "nextWord":
            if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
              while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] === " ") {
                offset++;
              }
              while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] !== " ") {
                offset++;
              }
              if (echo) {
                computeAllCoordinate();
                this.moveTo(cursor.x, cursor.y);
              }
              if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                autoCompleteHint();
              }
            }
            break;
          case "startOfInput":
            if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
              clearHint();
            }
            offset = 0;
            if (echo) {
              computeAllCoordinate();
              this.moveTo(cursor.x, cursor.y);
            }
            break;
          case "endOfInput":
            offset = inputs[inputIndex].length;
            if (echo) {
              computeAllCoordinate();
              this.moveTo(cursor.x, cursor.y);
            }
            if (dynamic.autoCompleteHint && lastOffset !== inputs[inputIndex].length) {
              autoCompleteHint();
            }
            break;
          case "historyNext":
            if (inputIndex < inputs.length - 1) {
              inputIndex++;
              offset = inputs[inputIndex].length;
              if (echo) {
                extraLines = end.y - start.y;
                computeAllCoordinate();
                extraLines -= end.y - start.y;
                redraw(extraLines, true);
                this.moveTo(cursor.x, cursor.y);
              }
            }
            break;
          case "historyPrevious":
            if (inputIndex > 0) {
              inputIndex--;
              offset = inputs[inputIndex].length;
              if (echo) {
                extraLines = end.y - start.y;
                computeAllCoordinate();
                extraLines -= end.y - start.y;
                redraw(extraLines, true);
                this.moveTo(cursor.x, cursor.y);
              }
            }
            break;
          case "autoCompleteUsingHistory":
          case "autoComplete":
            autoCompleteUsed = keyBindings[key] === "autoCompleteUsingHistory" ? options.history : dynamic.autoComplete;
            if (!autoCompleteUsed) {
              break;
            }
            leftPart = inputs[inputIndex].slice(0, offset);
            var finishCompletion = () => {
              if (Array.isArray(autoCompleted)) {
                if (dynamic.autoCompleteMenu) {
                  autoCompleteMenu(autoCompleted);
                }
                return;
              }
              leftPart = string$2.unicode.toArray(autoCompleted).slice(0, options.maxLength);
              inputs[inputIndex] = leftPart.concat(inputs[inputIndex].slice(offset, options.maxLength + offset - leftPart.length));
              offset = leftPart.length;
              if (echo) {
                computeAllCoordinate();
                redraw();
              }
            };
            if (Array.isArray(autoCompleteUsed)) {
              autoCompleted = autoComplete$1(autoCompleteUsed, leftPart.join(""), dynamic.autoCompleteMenu);
            } else if (typeof autoCompleteUsed === "function") {
              if (autoCompleteUsed.length === 2) {
                autoCompleteUsed(leftPart.join(""), (error, autoCompleted_) => {
                  if (error) {
                    cleanup(error);
                    return;
                  }
                  autoCompleted = autoCompleted_;
                  finishCompletion();
                });
                return;
              }
              autoCompleted = autoCompleteUsed(leftPart.join(""));
              if (Promise$9.isThenable(autoCompleted)) {
                autoCompleted.then((autoCompleted_) => {
                  autoCompleted = autoCompleted_;
                  finishCompletion();
                }, (error) => {
                  cleanup(error);
                });
                return;
              }
            }
            finishCompletion();
            break;
        }
      }
    };
    controller = Object.create(NextGenEvents$3.prototype);
    controller.defineStates("ready");
    Object.defineProperty(controller, "ready", {
      get: function() {
        return this.hasState("ready");
      }
    });
    controller.widgetType = "inputField";
    controller.abort = () => {
      if (finished) {
        return;
      }
      cleanup("abort");
    };
    controller.stop = () => {
      if (finished) {
        return;
      }
      cleanup(void 0, inputs[inputIndex]);
    };
    controller.pause = pause;
    controller.resume = resume;
    controller.focus = (value) => {
      if (value) {
        resume();
      } else {
        pause();
      }
    };
    controller.getInput = () => inputs[inputIndex].join("");
    controller.value = controller.getInput;
    controller.getPosition = () => ({x: start.x, y: start.y});
    controller.hide = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.hide);
        return;
      }
      var i, j;
      for (i = start.x, j = start.y; j <= end.y; i = 1, j++) {
        this.moveTo.eraseLineAfter(i, j);
      }
      echo = false;
    };
    controller.show = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.show);
        return;
      }
      echo = true;
      redraw();
    };
    controller.redraw = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.redraw);
        return;
      }
      redraw(void 0, true);
    };
    controller.redrawCursor = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.redrawCursor);
        return;
      }
      redrawCursor();
    };
    controller.getCursorPosition = () => offset;
    controller.setCursorPosition = (newOffset) => {
      newOffset = boundOffset(newOffset);
      if (newOffset !== offset) {
        if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
          clearHint();
        }
        offset = newOffset;
        if (echo) {
          computeAllCoordinate();
          this.moveTo(cursor.x, cursor.y);
        }
        if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
          autoCompleteHint();
        }
      }
    };
    controller.rebase = (x, y) => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.rebase);
        return;
      }
      var rebaseTo = (x_, y_) => {
        start.x = x_;
        start.y = y_;
        if (options.echo) {
          echo = true;
          computeAllCoordinate();
          redraw();
        }
        controller.emit("rebased");
      };
      if (x !== void 0 && y !== void 0) {
        rebaseTo(x, y);
        return;
      }
      echo = false;
      this.getCursorLocation((error, x_, y_) => {
        if (error) {
          return;
        }
        rebaseTo(x_, y_);
      });
    };
    controller.promise = new Promise$9();
    init();
    return controller;
  };
  var Promise$8 = seventh_1;
  var autoComplete = autoComplete$2;
  var fs = require$$2$2;
  var path = require$$3$1;
  var fileInput = function fileInput(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    var baseDir;
    var promise = new Promise$8();
    if (options.baseDir) {
      baseDir = path.resolve(options.baseDir);
      if (!path.isAbsolute(baseDir)) {
        fs.realpath(options.baseDir, (error, resolvedPath) => {
          if (error) {
            if (callback) {
              callback(error);
            } else {
              promise.reject(error);
            }
            return;
          }
          options.baseDir = resolvedPath;
          this.fileInput(options).then((input) => {
            if (callback) {
              callback(input);
            } else {
              promise.resolve(input);
            }
          }, (error_) => {
            if (callback) {
              callback(error_);
            } else {
              promise.reject(error_);
            }
          });
        });
        return promise;
      }
    } else {
      baseDir = process.cwd();
    }
    if (baseDir[baseDir.length - 1] !== "/") {
      baseDir += "/";
    }
    var autoCompleter = function autoCompleter2(inputString) {
      return __async(this, null, function* () {
        var inputDir, inputFile, currentDir, files, completion;
        if (inputString[inputString.length - 1] === "/") {
          inputDir = inputString;
          inputFile = "";
        } else {
          inputDir = path.dirname(inputString);
          inputDir = inputDir === "." ? "" : inputDir + "/";
          inputFile = path.basename(inputString);
        }
        if (path.isAbsolute(inputString)) {
          currentDir = inputDir;
        } else {
          currentDir = baseDir + inputDir;
        }
        try {
          files = yield readdir(currentDir);
        } catch (error) {
          return inputString;
        }
        if (!Array.isArray(files) || !files.length) {
          return inputString;
        }
        completion = autoComplete(files, inputFile, true);
        if (Array.isArray(completion)) {
          completion.prefix = inputDir;
        } else {
          completion = path.normalize(inputDir + completion);
        }
        return completion;
      });
    };
    options = Object.assign({}, options, {autoComplete: autoCompleter, autoCompleteMenu: true, minLength: 1});
    this.inputField(options).promise.then((input) => {
      if (!input && typeof input !== "string") {
        input = void 0;
      } else {
        input = path.resolve(path.isAbsolute(input) ? input : baseDir + input);
      }
      if (callback) {
        callback(void 0, input);
      } else {
        promise.resolve(input);
      }
    }, (error) => {
      if (callback) {
        callback(error);
      } else {
        promise.reject(error);
      }
    });
    return promise;
  };
  function readdir(dir) {
    var promise = new Promise$8();
    if (dir[dir.length - 1] !== "/") {
      dir += "/";
    }
    fs.readdir(dir, (error, files) => {
      if (error) {
        promise.reject(error);
        return;
      }
      Promise$8.map(files, (file) => {
        return new Promise$8((resolve, reject) => {
          fs.lstat(dir + file, (error_, stats) => {
            if (error_) {
              reject(error_);
              return;
            }
            if (stats.isDirectory()) {
              file += "/";
            }
            resolve(file);
          });
        });
      }).toPromise(promise);
    });
    return promise;
  }
  const termkit$3 = termkit_1;
  const stringWidth$1 = termkit$3.stringWidth;
  const NextGenEvents$2 = NextGenEvents_1;
  const Promise$7 = seventh_1;
  const defaultKeyBindings$2 = {
    ENTER: "submit",
    KP_ENTER: "submit",
    LEFT: "previous",
    RIGHT: "next",
    UP: "previousPage",
    DOWN: "nextPage",
    TAB: "cycleNext",
    SHIFT_TAB: "cyclePrevious",
    HOME: "first",
    END: "last",
    ESCAPE: "escape"
  };
  var singleLineMenu = function singleLineMenu(menuItems_, options, callback) {
    if (arguments.length < 1) {
      throw new Error("[terminal] singleLineMenu() needs at least an array of menuItems");
    }
    if (!Array.isArray(menuItems_) || !menuItems_.length) {
      throw new TypeError("[terminal] singleLineMenu(): argument #0 should be a non-empty array");
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options || typeof options !== "object") {
      options = {};
    }
    if (options.separator === void 0) {
      options.separator = "  ";
    }
    if (options.nextPageHint === void 0) {
      options.nextPageHint = " \xBB ";
    }
    if (options.previousPageHint === void 0) {
      options.previousPageHint = " \xAB ";
    }
    if (!options.style) {
      options.style = this;
    }
    if (!options.selectedStyle) {
      options.selectedStyle = this.dim.blue.bgGreen;
    }
    if (!options.y) {
      this("\n");
    } else {
      this.moveTo(1, options.y);
    }
    var keyBindings = options.keyBindings || defaultKeyBindings$2;
    if (!this.grabbing) {
      this.grabInput();
    }
    var menuItems = menuItems_.map((e) => typeof e === "string" ? e : "" + e);
    var selectedIndexInPage = options.selectedIndex = options.selectedIndex || 0;
    var start = {}, selectedPage = 0, finished = false, menuPages = [], alreadyCleanedUp = false;
    var nextPageHintWidth = stringWidth$1(options.nextPageHint), previousPageHintWidth = stringWidth$1(options.previousPageHint), separatorWidth = stringWidth$1(options.separator);
    var computePages = () => {
      var i, itemWidth, displayText, p = 0, endX = 1, nextEndX, firstItem = true, lastItem, lineWidth, offset, xMax = this.width - nextPageHintWidth;
      menuPages = [[]];
      for (i = 0; i < menuItems.length; i++) {
        if (p >= menuPages.length) {
          menuPages.push([]);
        }
        itemWidth = stringWidth$1(menuItems[i]);
        nextEndX = endX + itemWidth + separatorWidth;
        if (nextEndX > xMax) {
          if (firstItem) {
            itemWidth = xMax - endX;
            displayText = termkit$3.truncateString(menuItems[i], itemWidth - 1) + "\u2026";
            if (i === options.selectedIndex) {
              selectedPage = p;
              selectedIndexInPage = menuPages[p].length;
            }
            menuPages[p].push({
              index: i,
              text: menuItems[i],
              displayText,
              displayTextWidth: itemWidth,
              x: endX
            });
          } else {
            i--;
          }
          p++;
          endX = 1 + previousPageHintWidth;
          firstItem = true;
          continue;
        }
        if (i === options.selectedIndex) {
          selectedPage = p;
          selectedIndexInPage = menuPages[p].length;
        }
        menuPages[p].push({
          index: i,
          text: menuItems[i],
          displayText: menuItems[i],
          displayTextWidth: itemWidth,
          x: endX
        });
        endX = nextEndX;
        firstItem = false;
      }
      for (p = 0; p < menuPages.length; p++) {
        lastItem = menuPages[p][menuPages[p].length - 1];
        lineWidth = lastItem.x + lastItem.displayTextWidth - 1;
        if (p < menuPages.length - 1) {
          lineWidth += nextPageHintWidth;
        }
        menuPages[p].x = 1;
        if (lineWidth < this.width) {
          if (options.align === "right") {
            offset = this.width - lineWidth;
          } else if (options.align === "center") {
            offset = Math.floor((this.width - lineWidth) / 2);
          } else {
            offset = 0;
          }
          menuPages[p].x += offset;
          if (offset) {
            menuPages[p].forEach((item) => item.x += offset);
          }
        }
      }
    };
    var cleanup = (error, data) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      finished = true;
      this.removeListener("key", onKey);
      this.removeListener("mouse", onMouse);
      if (error) {
        if (callback) {
          callback(error);
        } else {
          controller.promise.reject(error);
        }
        return;
      }
      var page = menuPages[selectedPage];
      var value = data !== void 0 ? data : {
        selectedIndex: page[selectedIndexInPage].index,
        selectedText: page[selectedIndexInPage].text,
        x: page[selectedIndexInPage].x,
        y: start.y
      };
      if (callback) {
        callback(void 0, value);
      } else {
        controller.promise.resolve(value);
      }
    };
    var redraw = () => {
      var i, cursorX, page = menuPages[selectedPage], endX = page.x;
      this.moveTo.eraseLineAfter(1, start.y);
      if (options.fillIn && endX > 1) {
        options.style.noFormat(" ".repeat(endX - 1));
      } else {
        this.column(endX);
      }
      if (selectedPage) {
        options.style.forceStyleOnReset.noFormat(options.previousPageHint);
        endX += previousPageHintWidth;
      }
      for (i = 0; i < page.length; i++) {
        if (i) {
          options.style.forceStyleOnReset.noFormat(options.separator);
          endX += separatorWidth;
        }
        if (i === selectedIndexInPage) {
          options.selectedStyle.forceStyleOnReset.noFormat(page[i].displayText);
          cursorX = endX;
        } else {
          options.style.forceStyleOnReset.noFormat(page[i].displayText);
        }
        endX += page[i].displayTextWidth;
      }
      if (selectedPage < menuPages.length - 1) {
        options.style.forceStyleOnReset.noFormat(options.nextPageHint);
        endX += nextPageHintWidth;
      }
      if (options.fillIn && endX < this.width) {
        options.style.noFormat(" ".repeat(this.width - endX));
      }
      this.column(cursorX);
    };
    var emitHighlight = () => {
      var item = menuPages[selectedPage][selectedIndexInPage];
      controller.emit("highlight", {
        highlightedIndex: item.index,
        highlightedText: item.text,
        x: item.x,
        y: start.y
      });
    };
    var onKey = (key, trash, data) => {
      if (finished) {
        return;
      }
      var changed = false, page = menuPages[selectedPage];
      switch (keyBindings[key]) {
        case "submit":
          cleanup();
          break;
        case "previous":
          if (selectedIndexInPage > 0) {
            selectedIndexInPage--;
            changed = true;
          } else if (selectedPage > 0) {
            selectedPage--;
            selectedIndexInPage = menuPages[selectedPage].length - 1;
            changed = true;
          }
          break;
        case "next":
          if (selectedIndexInPage < page.length - 1) {
            selectedIndexInPage++;
            changed = true;
          } else if (selectedPage < menuPages.length - 1) {
            selectedPage++;
            selectedIndexInPage = 0;
            changed = true;
          }
          break;
        case "cycleNext":
          if (selectedPage === menuPages.length - 1 && selectedIndexInPage === page.length - 1) {
            selectedPage = 0;
            selectedIndexInPage = 0;
            changed = true;
          } else if (selectedIndexInPage < page.length - 1) {
            selectedIndexInPage++;
            changed = true;
          } else if (selectedPage < menuPages.length - 1) {
            selectedPage++;
            selectedIndexInPage = 0;
            changed = true;
          }
          break;
        case "cyclePrevious":
          if (selectedPage === 0 && selectedIndexInPage === 0) {
            selectedPage = menuPages.length - 1;
            selectedIndexInPage = menuPages[selectedPage].length - 1;
            changed = true;
          } else if (selectedIndexInPage > 0) {
            selectedIndexInPage--;
            changed = true;
          } else if (selectedPage > 0) {
            selectedPage--;
            selectedIndexInPage = menuPages[selectedPage].length - 1;
            changed = true;
          }
          break;
        case "first":
          if (selectedPage !== 0 || selectedIndexInPage !== 0) {
            selectedPage = 0;
            selectedIndexInPage = 0;
            changed = true;
          }
          break;
        case "last":
          if (selectedPage !== menuPages.length - 1 || selectedIndexInPage !== menuPages[selectedPage].length - 1) {
            selectedPage = menuPages.length - 1;
            selectedIndexInPage = menuPages[selectedPage].length - 1;
            changed = true;
          }
          break;
        case "previousPage":
          if (selectedPage > 0) {
            selectedPage--;
            selectedIndexInPage = 0;
            changed = true;
          }
          break;
        case "nextPage":
          if (selectedPage < menuPages.length - 1) {
            selectedPage++;
            selectedIndexInPage = 0;
            changed = true;
          }
          break;
        case "escape":
          if (options.cancelable) {
            cleanup(void 0, {canceled: true});
          }
          if (options.exitOnUnexpectedKey) {
            cleanup(void 0, {unexpectedKey: key, unexpectedKeyData: data});
          }
          break;
        default:
          if (options.exitOnUnexpectedKey) {
            cleanup(void 0, {unexpectedKey: key, unexpectedKeyData: data});
          }
          break;
      }
      if (changed) {
        redraw();
        emitHighlight();
      }
    };
    var onMouse = (name2, data) => {
      if (finished) {
        return;
      }
      if (data.y !== start.y) {
        return;
      }
      var i, item, nextButtonX, inBounds = false, page = menuPages[selectedPage];
      if (name2 === "MOUSE_LEFT_BUTTON_PRESSED") {
        if (selectedPage > 0 && data.x >= 1 && data.x < 1 + previousPageHintWidth) {
          selectedPage--;
          selectedIndexInPage = 0;
          redraw();
          emitHighlight();
          return;
        }
        nextButtonX = page[page.length - 1].x + page[page.length - 1].displayTextWidth;
        if (selectedPage < menuPages.length - 1 && data.x >= nextButtonX && data.x < nextButtonX + nextPageHintWidth) {
          selectedPage++;
          selectedIndexInPage = 0;
          redraw();
          emitHighlight();
          return;
        }
      }
      for (i = 0; i < page.length; i++) {
        item = page[i];
        if (data.x >= item.x && data.x < item.x + item.displayTextWidth) {
          inBounds = true;
          if (selectedIndexInPage !== i) {
            selectedIndexInPage = i;
            redraw();
            emitHighlight();
          }
          break;
        }
      }
      if (inBounds && name2 === "MOUSE_LEFT_BUTTON_PRESSED") {
        cleanup();
      }
    };
    var controller = Object.create(NextGenEvents$2.prototype);
    controller.promise = new Promise$7();
    this.getCursorLocation((error, x, y) => {
      if (error) {
        this.row.eraseLineAfter(this.height)("\n");
        x = 1;
        y = this.height;
      }
      start.x = x;
      start.y = y;
      computePages();
      redraw();
      emitHighlight();
      this.on("key", onKey);
      if (this.mouseGrabbing) {
        this.on("mouse", onMouse);
      }
    });
    return controller;
  };
  const termkit$2 = termkit_1;
  const stringWidth = termkit$2.stringWidth;
  const string$1 = string$4;
  const NextGenEvents$1 = NextGenEvents_1;
  const Promise$6 = seventh_1;
  const defaultKeyBindings$1 = {
    ENTER: "submit",
    KP_ENTER: "submit",
    UP: "previous",
    DOWN: "next",
    TAB: "cycleNext",
    SHIFT_TAB: "cyclePrevious",
    HOME: "first",
    END: "last",
    BACKSPACE: "cancel",
    DELETE: "cancel",
    ESCAPE: "escape"
  };
  var singleColumnMenu = function singleColumnMenu(menuItemsArg, options, callback) {
    if (arguments.length < 1) {
      throw new Error("[terminal] singleColumnMenu() needs at least an array of menuItems");
    }
    if (!Array.isArray(menuItemsArg) || !menuItemsArg.length) {
      throw new TypeError("[terminal] singleColumnMenu(): argument #0 should be a non-empty array");
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options || typeof options !== "object") {
      options = {};
    }
    if (!options.style) {
      options.style = this;
    }
    if (!options.selectedStyle) {
      options.selectedStyle = this.inverse;
    }
    if (!options.submittedStyle) {
      options.submittedStyle = this.bgGray.bold;
    }
    if (!options.disabledStyle) {
      options.disabledStyle = this.dim;
    }
    if (!options.disabledSelectedStyle) {
      options.disabledSelectedStyle = this.bgGray.dim;
    }
    if (!options.disabledSubmittedStyle) {
      options.disabledSubmittedStyle = this.bgGray;
    }
    if (options.leftPadding === void 0) {
      options.leftPadding = " ";
    }
    if (options.selectedLeftPadding === void 0) {
      options.selectedLeftPadding = options.leftPadding;
    }
    if (options.submittedLeftPadding === void 0) {
      options.submittedLeftPadding = options.leftPadding;
    }
    if (typeof options.extraLines !== "number" || options.extraLines < 0) {
      options.extraLines = 1;
    }
    if (!options.itemMaxWidth) {
      options.itemMaxWidth = this.width - 1;
    }
    if (!options.unsubmittableIndexes) {
      options.unsubmittableIndexes = [];
    }
    var selectedIndex = options.selectedIndex || 0;
    var submittedIndex = options.submitted ? options.selectedIndex : null;
    var paused = !!options.paused;
    var keyBindings = options.keyBindings || defaultKeyBindings$1;
    if (!this.grabbing) {
      this.grabInput();
    }
    var start = {}, end = {}, textWidth, outerWidth, paddingLength, menuItems, offsetY = 0, lineCount = 0, scrollLines = 0, controller, finished = false, alreadyCleanedUp = false;
    var init = () => {
      computeItems(menuItemsArg);
      if (options.y !== void 0) {
        this.moveTo(1, options.y);
        finishInit(1, options.y);
      } else {
        this("\n");
        this.getCursorLocation((error, x, y) => {
          if (error) {
            this.row.eraseLineAfter(this.height)("\n");
            x = 1;
            y = this.height;
          }
          finishInit(x, y);
        });
      }
    };
    var computeItems = (menuItems_) => {
      textWidth = 0;
      paddingLength = Math.max(stringWidth(options.leftPadding), stringWidth(options.selectedLeftPadding));
      menuItems_ = menuItems_.map((element) => {
        if (typeof element !== "string") {
          element = "" + element;
        }
        textWidth = Math.max(textWidth, stringWidth(element));
        return element;
      });
      if (!options.oneLineItem && textWidth > options.itemMaxWidth - paddingLength) {
        outerWidth = Math.min(textWidth + paddingLength, this.width);
        menuItems = menuItems_.map((element, index) => {
          var item, lines, lineLength = options.itemMaxWidth - paddingLength;
          lines = string$1.wordwrap(element, {
            width: lineLength,
            noJoin: true,
            fill: true,
            skipFn: termkit$2.escapeSequenceSkipFn
          });
          item = {
            offsetY,
            index,
            text: element,
            displayText: lines
          };
          offsetY += lines.length;
          return item;
        });
        lineCount = offsetY;
      } else {
        textWidth = Math.min(textWidth, options.itemMaxWidth - paddingLength);
        outerWidth = Math.min(textWidth + paddingLength, this.width);
        menuItems = menuItems_.map((element, index) => {
          var elementWidth = stringWidth(element);
          return {
            offsetY: index,
            index,
            text: element,
            displayText: [elementWidth > textWidth ? element.slice(0, textWidth - 1) + "\u2026" : element + " ".repeat(textWidth - elementWidth)]
          };
        });
        lineCount = menuItems.length;
      }
    };
    var finishInit = (x, y) => {
      if (finished) {
        return;
      }
      prepareArea(x, y);
      redraw();
      this.on("key", onKey);
      if (this.mouseGrabbing) {
        this.on("mouse", onMouse);
      }
      controller.emit("ready");
      emitHighlight();
    };
    var emitHighlight = () => {
      var item = menuItems[selectedIndex];
      controller.emit("highlight", {
        highlightedIndex: item.index,
        highlightedText: item.text,
        submitted: submittedIndex !== null,
        x: 1,
        y: start.y + item.offsetY
      });
    };
    var prepareArea = (x, y) => {
      start.x = x;
      start.y = y;
      end.x = 1;
      end.y = y + lineCount;
      scrollLines = start.y + lineCount - (options.scrollRegionBottom || this.height) - 1 + options.extraLines;
      if (scrollLines > 0) {
        this("\n".repeat(scrollLines));
        start.y -= scrollLines;
        end.y -= scrollLines;
      }
    };
    var cleanup = (error, data, eraseMenu) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      finished = true;
      this.removeListener("key", onKey);
      this.removeListener("mouse", onMouse);
      if (error === "abort") {
        return;
      }
      if (controller.hasState("ready")) {
        if (eraseMenu) {
          erase();
        } else {
          this.moveTo(1, end.y);
        }
      }
      if (error) {
        if (callback) {
          callback(error);
        } else {
          controller.promise.reject(error);
        }
        return;
      }
      var value = data !== void 0 ? data : {
        selectedIndex,
        selectedText: menuItems[selectedIndex].text,
        submitted: submittedIndex !== null,
        x: 1,
        y: start.y + menuItems[selectedIndex].offsetY
      };
      if (callback) {
        callback(void 0, value);
      } else {
        controller.promise.resolve(value);
      }
    };
    var erase = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", erase);
        return;
      }
      var i, j;
      for (i = start.x, j = start.y; j <= end.y; i = 1, j++) {
        this.moveTo.eraseLineAfter(i, j);
      }
      this.moveTo(1, start.y);
    };
    var redraw = () => {
      for (var i = 0; i < menuItems.length; i++) {
        redrawItem(i);
      }
      redrawCursor();
    };
    var redrawItem = (index) => {
      var item = menuItems[index];
      item.displayText.forEach((text, line) => {
        this.moveTo(1, start.y + item.offsetY + line);
        if (paused || options.unsubmittableIndexes[index]) {
          if (index === submittedIndex) {
            if (line) {
              options.disabledSubmittedStyle.forceStyleOnReset.noFormat(options.leftPadding);
            } else {
              options.disabledSubmittedStyle.forceStyleOnReset.noFormat(options.submittedLeftPadding);
            }
            options.disabledSubmittedStyle.forceStyleOnReset.noFormat(text);
          } else if (index === selectedIndex) {
            if (line) {
              options.disabledSelectedStyle.forceStyleOnReset.noFormat(options.leftPadding);
            } else {
              options.disabledSelectedStyle.forceStyleOnReset.noFormat(options.selectedLeftPadding);
            }
            options.disabledSelectedStyle.forceStyleOnReset.noFormat(text);
          } else {
            options.disabledStyle.forceStyleOnReset.noFormat(options.leftPadding);
            options.disabledStyle.forceStyleOnReset.noFormat(text);
          }
        } else if (index === submittedIndex) {
          if (line) {
            options.submittedStyle.forceStyleOnReset.noFormat(options.leftPadding);
          } else {
            options.submittedStyle.forceStyleOnReset.noFormat(options.submittedLeftPadding);
          }
          options.submittedStyle.forceStyleOnReset.noFormat(text);
        } else if (index === selectedIndex) {
          if (line) {
            options.selectedStyle.forceStyleOnReset.noFormat(options.leftPadding);
          } else {
            options.selectedStyle.forceStyleOnReset.noFormat(options.selectedLeftPadding);
          }
          options.selectedStyle.forceStyleOnReset.noFormat(text);
        } else {
          options.style.forceStyleOnReset.noFormat(options.leftPadding);
          options.style.forceStyleOnReset.noFormat(text);
        }
      });
    };
    var redrawCursor = () => {
      this.moveTo(1, start.y + menuItems[selectedIndex].offsetY);
    };
    var select = (index) => {
      var oldSelectedIndex = selectedIndex;
      if (selectedIndex !== index && index >= 0 && index < menuItems.length) {
        selectedIndex = index;
        if (controller.hasState("ready")) {
          redrawItem(oldSelectedIndex);
          redrawItem(selectedIndex);
          redrawCursor();
          emitHighlight();
        }
      }
    };
    var submit = () => {
      if (submittedIndex !== null || options.unsubmittableIndexes[selectedIndex]) {
        return;
      }
      submittedIndex = selectedIndex;
      if (controller.hasState("ready")) {
        redrawItem(submittedIndex);
        redrawCursor();
      }
      controller.emit("submit", {
        selectedIndex: submittedIndex,
        selectedText: menuItems[submittedIndex].text,
        submitted: true,
        x: 1,
        y: start.y + menuItems[submittedIndex].offsetY
      });
      if (!options.continueOnSubmit) {
        cleanup();
      }
    };
    var cancel = () => {
      var oldSelectedIndex = submittedIndex;
      if (submittedIndex === null) {
        return;
      }
      submittedIndex = null;
      redrawItem(oldSelectedIndex);
      redrawCursor();
      controller.emit("cancel");
    };
    var pause = () => {
      if (paused) {
        return;
      }
      paused = true;
      if (controller.hasState("ready")) {
        redraw();
      }
    };
    var resume = () => {
      if (!paused) {
        return;
      }
      paused = false;
      if (controller.hasState("ready")) {
        redraw();
      }
    };
    var onKey = (key, trash, data) => {
      if (finished || paused) {
        return;
      }
      var oldSelectedIndex = selectedIndex;
      switch (keyBindings[key]) {
        case "submit":
          submit();
          break;
        case "previous":
          if (submittedIndex !== null) {
            return;
          }
          if (selectedIndex > 0) {
            selectedIndex--;
            redrawItem(selectedIndex);
            redrawItem(selectedIndex + 1);
            redrawCursor();
            emitHighlight();
          }
          break;
        case "next":
          if (submittedIndex !== null) {
            return;
          }
          if (selectedIndex < menuItems.length - 1) {
            selectedIndex++;
            redrawItem(selectedIndex - 1);
            redrawItem(selectedIndex);
            redrawCursor();
            emitHighlight();
          }
          break;
        case "cyclePrevious":
          if (submittedIndex !== null) {
            return;
          }
          selectedIndex--;
          if (selectedIndex < 0) {
            selectedIndex = menuItems.length - 1;
          }
          redrawItem(oldSelectedIndex);
          redrawItem(selectedIndex);
          redrawCursor();
          emitHighlight();
          break;
        case "cycleNext":
          if (submittedIndex !== null) {
            return;
          }
          selectedIndex++;
          if (selectedIndex >= menuItems.length) {
            selectedIndex = 0;
          }
          redrawItem(oldSelectedIndex);
          redrawItem(selectedIndex);
          redrawCursor();
          emitHighlight();
          break;
        case "first":
          if (submittedIndex !== null) {
            return;
          }
          if (selectedIndex !== 0) {
            selectedIndex = 0;
            redrawItem(oldSelectedIndex);
            redrawItem(selectedIndex);
            redrawCursor();
            emitHighlight();
          }
          break;
        case "last":
          if (submittedIndex !== null) {
            return;
          }
          if (selectedIndex !== menuItems.length - 1) {
            selectedIndex = menuItems.length - 1;
            redrawItem(oldSelectedIndex);
            redrawItem(selectedIndex);
            redrawCursor();
            emitHighlight();
          }
          break;
        case "cancel":
          cancel();
          break;
        case "escape":
          if (options.cancelable) {
            cleanup(void 0, {canceled: true});
          }
          if (options.exitOnUnexpectedKey) {
            cleanup(void 0, {unexpectedKey: key, unexpectedKeyData: data});
          }
          break;
        default:
          if (options.exitOnUnexpectedKey) {
            cleanup(void 0, {unexpectedKey: key, unexpectedKeyData: data});
          }
          break;
      }
    };
    var onMouse = (name2, data) => {
      if (finished || paused || submittedIndex !== null) {
        return;
      }
      if (data.y < start.y || data.y >= end.y) {
        return;
      }
      var i, yMin, yMax, inBounds = false;
      for (i = 0; i < menuItems.length; i++) {
        yMin = start.y + menuItems[i].offsetY;
        yMax = start.y + menuItems[i].offsetY + menuItems[i].displayText.length - 1;
        if (data.y >= yMin && data.y <= yMax && data.x < 1 + outerWidth) {
          inBounds = true;
          select(i);
          break;
        }
      }
      if (inBounds && name2 === "MOUSE_LEFT_BUTTON_PRESSED") {
        submit();
      }
    };
    controller = Object.create(NextGenEvents$1.prototype);
    controller.defineStates("ready");
    controller.abort = () => {
      if (finished) {
        return;
      }
      cleanup("abort");
    };
    controller.stop = (eraseMenu) => {
      if (finished) {
        return;
      }
      cleanup(void 0, void 0, eraseMenu);
    };
    controller.select = select;
    controller.submit = submit;
    controller.cancel = cancel;
    controller.erase = erase;
    controller.pause = pause;
    controller.resume = resume;
    controller.focus = (value) => {
      if (value) {
        resume();
      } else {
        pause();
      }
    };
    controller.getState = () => ({
      selectedIndex,
      selectedText: menuItems[selectedIndex].text,
      submitted: submittedIndex !== null,
      start,
      end,
      x: 1,
      y: start.y + menuItems[selectedIndex].offsetY
    });
    controller.getPosition = () => ({x: start.x, y: start.y});
    controller.hide = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.hide);
        return;
      }
      erase();
    };
    controller.show = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.show);
        return;
      }
      redraw();
    };
    controller.redraw = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.redraw);
        return;
      }
      redraw();
    };
    controller.redrawCursor = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.redrawCursor);
        return;
      }
      redrawCursor();
    };
    controller.rebase = () => {
      if (!controller.hasState("ready")) {
        controller.once("ready", controller.rebase);
        return;
      }
      var wasPaused = paused;
      paused = true;
      this.getCursorLocation((error, x, y) => {
        if (error) {
          return;
        }
        paused = wasPaused;
        prepareArea(x, y);
        redraw();
        controller.emit("rebased");
      });
    };
    controller.promise = new Promise$6();
    init();
    return controller;
  };
  var Promise$5 = seventh_1;
  var defaultKeyBindings = {
    ENTER: "submit",
    KP_ENTER: "submit",
    UP: "previous",
    DOWN: "next",
    LEFT: "previousColumn",
    RIGHT: "nextColumn",
    TAB: "cycleNext",
    SHIFT_TAB: "cyclePrevious",
    HOME: "first",
    END: "last"
  };
  var gridMenu = function gridMenu(menuItems_, options, callback) {
    if (arguments.length < 1) {
      throw new Error("[terminal] gridMenu() needs at least an array of menuItems argument");
    }
    if (!Array.isArray(menuItems_) || !menuItems_.length) {
      throw new TypeError("[terminal] gridMenu(): argument #0 should be a non-empty array");
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options || typeof options !== "object") {
      options = {};
    }
    if (!options.style) {
      options.style = this;
    }
    if (!options.selectedStyle) {
      options.selectedStyle = this.inverse;
    }
    if (options.leftPadding === void 0) {
      options.leftPadding = " ";
    }
    if (options.selectedLeftPadding === void 0) {
      options.selectedLeftPadding = " ";
    }
    if (options.rightPadding === void 0) {
      options.rightPadding = " ";
    }
    if (options.selectedRightPadding === void 0) {
      options.selectedRightPadding = " ";
    }
    if (!options.x) {
      options.x = 1;
    }
    if (!options.y) {
      this("\n");
    } else {
      this.moveTo(options.x, options.y);
    }
    if (!options.width) {
      options.width = this.width - options.x + 1;
    }
    if (!options.itemMaxWidth) {
      options.itemMaxWidth = Math.floor((options.width - 1) / 3);
    }
    var keyBindings = options.keyBindings || defaultKeyBindings;
    if (!this.grabbing) {
      this.grabInput();
    }
    var start = {}, selectedIndex = 0, finished = false, alreadyCleanedUp = false, itemInnerWidth = 0, itemOuterWidth = 0, menuItems, columns, rows, padLength;
    padLength = Math.max(options.leftPadding.length, options.selectedLeftPadding.length) + Math.max(options.rightPadding.length, options.selectedRightPadding.length);
    menuItems_ = menuItems_.map((element) => {
      if (typeof element !== "string") {
        element = "" + element;
      }
      itemInnerWidth = Math.max(itemInnerWidth, element.length);
      return element;
    });
    itemInnerWidth = Math.min(itemInnerWidth, options.itemMaxWidth - padLength);
    itemOuterWidth = itemInnerWidth + padLength;
    columns = Math.floor(options.width / itemOuterWidth);
    rows = Math.ceil(menuItems_.length / columns);
    menuItems = menuItems_.map((element, index) => ({
      offsetY: index % rows,
      offsetX: options.x - 1 + Math.floor(index / rows) * itemOuterWidth,
      index,
      text: element,
      displayText: element.length > itemInnerWidth ? element.slice(0, itemInnerWidth - 1) + "\u2026" : element + " ".repeat(itemInnerWidth - element.length)
    }));
    var cleanup = (error, data) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      finished = true;
      this.removeListener("key", onKey);
      this.removeListener("mouse", onMouse);
      this.moveTo(1, start.y + rows);
      if (error) {
        if (callback) {
          callback(error);
        } else {
          controller.promise.reject(error);
        }
        return;
      }
      var value = data !== void 0 ? data : {
        selectedIndex,
        selectedText: menuItems[selectedIndex].text,
        x: 1 + menuItems[selectedIndex].offsetX,
        y: start.y + menuItems[selectedIndex].offsetY
      };
      if (callback) {
        callback(void 0, value);
      } else {
        controller.promise.resolve(value);
      }
    };
    var redraw = () => {
      for (var i = 0; i < menuItems.length; i++) {
        redrawItem(i);
      }
      redrawCursor();
    };
    var redrawItem = (index) => {
      var item = menuItems[index];
      this.moveTo(1 + item.offsetX, start.y + item.offsetY);
      if (index === selectedIndex) {
        options.selectedStyle.noFormat(options.selectedLeftPadding);
        options.selectedStyle.noFormat(item.displayText);
        options.selectedStyle.noFormat(options.selectedRightPadding);
      } else {
        options.style.noFormat(options.leftPadding);
        options.style.noFormat(item.displayText);
        options.style.noFormat(options.rightPadding);
      }
    };
    var redrawCursor = () => {
      this.moveTo(1 + menuItems[selectedIndex].offsetX, start.y + menuItems[selectedIndex].offsetY);
    };
    var onKey = (key, trash, data) => {
      if (finished) {
        return;
      }
      var oldSelectedIndex = selectedIndex;
      switch (keyBindings[key]) {
        case "submit":
          cleanup();
          break;
        case "previous":
          if (selectedIndex > 0) {
            selectedIndex--;
            redrawItem(selectedIndex);
            redrawItem(selectedIndex + 1);
            redrawCursor();
          }
          break;
        case "next":
          if (selectedIndex < menuItems.length - 1) {
            selectedIndex++;
            redrawItem(selectedIndex - 1);
            redrawItem(selectedIndex);
            redrawCursor();
          }
          break;
        case "previousColumn":
          if (selectedIndex >= rows) {
            selectedIndex -= rows;
            redrawItem(oldSelectedIndex);
            redrawItem(selectedIndex);
            redrawCursor();
          }
          break;
        case "nextColumn":
          if (selectedIndex < menuItems.length - rows) {
            selectedIndex += rows;
            redrawItem(oldSelectedIndex);
            redrawItem(selectedIndex);
            redrawCursor();
          }
          break;
        case "cyclePrevious":
          selectedIndex--;
          if (selectedIndex < 0) {
            selectedIndex = menuItems.length - 1;
          }
          redrawItem(oldSelectedIndex);
          redrawItem(selectedIndex);
          redrawCursor();
          break;
        case "cycleNext":
          selectedIndex++;
          if (selectedIndex >= menuItems.length) {
            selectedIndex = 0;
          }
          redrawItem(oldSelectedIndex);
          redrawItem(selectedIndex);
          redrawCursor();
          break;
        case "first":
          if (selectedIndex !== 0) {
            selectedIndex = 0;
            redrawItem(oldSelectedIndex);
            redrawItem(selectedIndex);
            redrawCursor();
          }
          break;
        case "last":
          if (selectedIndex !== menuItems.length - 1) {
            selectedIndex = menuItems.length - 1;
            redrawItem(oldSelectedIndex);
            redrawItem(selectedIndex);
            redrawCursor();
          }
          break;
        default:
          if (options.exitOnUnexpectedKey) {
            cleanup(void 0, {unexpectedKey: key, unexpectedKeyData: data});
          }
          break;
      }
    };
    var onMouse = (name2, data) => {
      if (finished) {
        return;
      }
      if (data.y < start.y || data.y >= start.y + rows) {
        return;
      }
      var i, inBounds = false, oldSelectedIndex = selectedIndex;
      for (i = 0; i < menuItems.length; i++) {
        if (data.y === start.y + menuItems[i].offsetY && data.x >= 1 + menuItems[i].offsetX && data.x < 1 + menuItems[i].offsetX + itemOuterWidth) {
          inBounds = true;
          if (selectedIndex !== i) {
            selectedIndex = i;
            redrawItem(oldSelectedIndex);
            redrawItem(selectedIndex);
            redrawCursor();
          }
          break;
        }
      }
      if (inBounds && name2 === "MOUSE_LEFT_BUTTON_PRESSED") {
        cleanup();
      }
    };
    this.getCursorLocation((error, x, y) => {
      if (error) {
        this.row.eraseLineAfter(this.height)("\n");
        x = 1;
        y = this.height;
      }
      start.x = x;
      start.y = y;
      var extra = start.y + rows - this.height;
      if (extra > 0) {
        this("\n".repeat(extra));
        start.y -= extra;
      }
      redraw();
      this.on("key", onKey);
      if (this.mouseGrabbing) {
        this.on("mouse", onMouse);
      }
    });
    var controller = {};
    controller.promise = new Promise$5();
    return controller;
  };
  var progressBar = function progressBar_(options) {
    if (!options || typeof options !== "object") {
      options = {};
    }
    var controller = {}, progress, ready = false, pause = false, maxItems, itemsDone = 0, itemsStarted = [], itemFiller, title, titleFiller, width, y, startX, endX, oldWidth, wheel, wheelCounter = 0, itemRollCounter = 0, progressUpdateCount = 0, lastUpdateTime, lastRedrawTime, startingTime, redrawTimer, etaStartingTime, etaFiller;
    etaStartingTime = startingTime = new Date().getTime();
    wheel = ["|", "/", "-", "\\"];
    options.syncMode = !!options.syncMode;
    width = options.width || this.width - 1;
    if (!options.barBracketStyle) {
      if (options.barStyle) {
        options.barBracketStyle = options.barStyle;
      } else {
        options.barBracketStyle = this.blue;
      }
    }
    if (!options.barStyle) {
      options.barStyle = this.cyan;
    }
    if (!options.percentStyle) {
      options.percentStyle = this.yellow;
    }
    if (!options.etaStyle) {
      options.etaStyle = this.bold;
    }
    if (!options.itemStyle) {
      options.itemStyle = this.dim;
    }
    if (!options.titleStyle) {
      options.titleStyle = this.bold;
    }
    if (!options.barChar) {
      options.barChar = "=";
    } else {
      options.barChar = options.barChar[0];
    }
    if (!options.barHeadChar) {
      options.barHeadChar = ">";
    } else {
      options.barHeadChar = options.barHeadChar[0];
    }
    if (typeof options.maxRefreshTime !== "number") {
      options.maxRefreshTime = 500;
    }
    if (typeof options.minRefreshTime !== "number") {
      options.minRefreshTime = 100;
    }
    if (typeof options.items === "number") {
      maxItems = options.items;
    }
    if (maxItems && typeof options.itemSize !== "number") {
      options.itemSize = Math.round(width / 3);
    }
    itemFiller = " ".repeat(options.itemSize);
    if (options.title && typeof options.title === "string") {
      title = options.title;
      if (typeof options.titleSize !== "number") {
        options.titleSize = Math.round(Math.min(options.title.length + 1, width / 3));
      }
    }
    titleFiller = " ".repeat(options.titleSize);
    etaFiller = "           ";
    var etaString = (updated) => {
      var eta = "", elapsedEtaTime, remainingTime, averageUpdateDelay, averageUpdateProgress, lastUpdateElapsedTime, fakeProgress;
      if (progress >= 1) {
        eta = " done";
      } else if (progress > 0) {
        new Date().getTime() - startingTime;
        elapsedEtaTime = new Date().getTime() - etaStartingTime;
        if (!updated && progressUpdateCount > 1) {
          lastUpdateElapsedTime = new Date().getTime() - lastUpdateTime;
          averageUpdateDelay = elapsedEtaTime / progressUpdateCount;
          averageUpdateProgress = progress / progressUpdateCount;
          if (lastUpdateElapsedTime < averageUpdateDelay) {
            fakeProgress = progress + averageUpdateProgress * lastUpdateElapsedTime / averageUpdateDelay;
          } else {
            fakeProgress = progress + averageUpdateProgress;
          }
          if (fakeProgress > 0.99) {
            fakeProgress = 0.99;
          }
        } else {
          fakeProgress = progress;
        }
        remainingTime = elapsedEtaTime * ((1 - fakeProgress) / fakeProgress) / 1e3;
        eta = " in ";
        if (remainingTime < 10) {
          eta += Math.round(remainingTime * 10) / 10 + "s";
        } else if (remainingTime < 120) {
          eta += Math.round(remainingTime) + "s";
        } else if (remainingTime < 7200) {
          eta += Math.round(remainingTime / 60) + "min";
        } else if (remainingTime < 172800) {
          eta += Math.round(remainingTime / 3600) + "hours";
        } else if (remainingTime < 31536e3) {
          eta += Math.round(remainingTime / 86400) + "days";
        } else {
          eta = "few years";
        }
      } else {
        etaStartingTime = new Date().getTime();
      }
      eta = (eta + etaFiller).slice(0, etaFiller.length);
      return eta;
    };
    var redraw = (updated) => {
      var time, itemIndex, itemName = itemFiller, titleName = titleFiller, innerBarSize, progressSize, voidSize, progressBar = "", voidBar = "", percent = "", eta = "";
      if (!ready || pause) {
        return;
      }
      time = new Date().getTime();
      if ((!progress || progress < 1) && lastRedrawTime && time < lastRedrawTime + options.minRefreshTime) {
        if (!options.syncMode) {
          if (redrawTimer) {
            clearTimeout(redrawTimer);
          }
          redrawTimer = setTimeout(redraw.bind(this, updated), lastRedrawTime + options.minRefreshTime - time);
        }
        return;
      }
      this.saveCursor();
      if (y === null) {
        this.column(startX);
      } else {
        this.moveTo(startX, y);
      }
      innerBarSize = width - 2;
      if (options.percent) {
        innerBarSize -= 4;
        percent = ("   " + Math.round((progress || 0) * 100) + "%").slice(-4);
      }
      if (options.eta) {
        eta = etaString(updated);
        innerBarSize -= eta.length;
      }
      innerBarSize -= options.itemSize || 0;
      if (maxItems) {
        if (!itemsStarted.length) {
          itemName = "";
        } else if (itemsStarted.length === 1) {
          itemName = " " + itemsStarted[0];
        } else {
          itemIndex = itemRollCounter++ % itemsStarted.length;
          itemName = " [" + (itemIndex + 1) + "/" + itemsStarted.length + "] " + itemsStarted[itemIndex];
        }
        if (itemName.length > itemFiller.length) {
          itemName = itemName.slice(0, itemFiller.length - 1) + "\u2026";
        } else if (itemName.length < itemFiller.length) {
          itemName = (itemName + itemFiller).slice(0, itemFiller.length);
        }
      }
      innerBarSize -= options.titleSize || 0;
      if (title) {
        titleName = title;
        if (titleName.length >= titleFiller.length) {
          titleName = titleName.slice(0, titleFiller.length - 2) + "\u2026 ";
        } else {
          titleName = (titleName + titleFiller).slice(0, titleFiller.length);
        }
      }
      progressSize = progress === void 0 ? 1 : Math.round(innerBarSize * Math.max(Math.min(progress, 1), 0));
      voidSize = innerBarSize - progressSize;
      if (progressSize) {
        if (progress === void 0) {
          progressBar = wheel[++wheelCounter % wheel.length];
        } else {
          progressBar += options.barChar.repeat(progressSize - 1);
          progressBar += options.barHeadChar;
        }
      }
      voidBar += " ".repeat(voidSize);
      options.titleStyle(titleName);
      if (percent) {
        options.percentStyle(percent);
      }
      if (progress === void 0) {
        this(" ");
      } else {
        options.barBracketStyle("[");
      }
      options.barStyle(progressBar);
      this(voidBar);
      if (progress === void 0) {
        this(" ");
      } else {
        options.barBracketStyle("]");
      }
      options.etaStyle(eta);
      options.itemStyle(itemName);
      this.restoreCursor();
      if (!options.syncMode) {
        if (redrawTimer) {
          clearTimeout(redrawTimer);
        }
        if (!progress || progress < 1) {
          redrawTimer = setTimeout(redraw, options.maxRefreshTime);
        }
      }
      lastRedrawTime = time;
    };
    if (options.syncMode || options.inline || options.y) {
      oldWidth = width;
      if (options.y) {
        startX = +options.x || 1;
        y = +options.y || 1;
      } else {
        startX = 1;
        y = null;
      }
      endX = Math.min(startX + width, this.width);
      width = endX - startX;
      if (width !== oldWidth) {
        if (options.titleSize) {
          options.titleSize = Math.floor(options.titleSize * width / oldWidth);
        }
        if (options.itemSize) {
          options.itemSize = Math.floor(options.itemSize * width / oldWidth);
        }
      }
      ready = true;
      redraw();
    } else {
      this.getCursorLocation((error, x_, y_) => {
        if (error) {
          this.row.eraseLineAfter(this.height)("\n");
          x_ = 1;
          y_ = this.height;
        }
        var oldWidth_ = width;
        startX = x_;
        endX = Math.min(x_ + width, this.width);
        y = y_;
        width = endX - startX;
        if (width !== oldWidth_) {
          if (options.titleSize) {
            options.titleSize = Math.floor(options.titleSize * width / oldWidth_);
          }
          if (options.itemSize) {
            options.itemSize = Math.floor(options.itemSize * width / oldWidth_);
          }
        }
        ready = true;
        redraw();
      });
    }
    controller.startItem = (name2) => {
      itemsStarted.push(name2);
      if (itemsStarted.length === 1) {
        if (progress >= 1) {
          redraw();
          return;
        }
        if (options.syncMode) {
          redraw();
        } else {
          if (redrawTimer) {
            clearTimeout(redrawTimer);
          }
          redrawTimer = setTimeout(redraw, 0);
        }
      }
    };
    controller.itemDone = (name2) => {
      var index;
      itemsDone++;
      if (maxItems) {
        progress = itemsDone / maxItems;
      } else {
        progress = void 0;
      }
      lastUpdateTime = new Date().getTime();
      progressUpdateCount++;
      index = itemsStarted.indexOf(name2);
      if (index >= 0) {
        itemsStarted.splice(index, 1);
      }
      if (progress >= 1) {
        redraw(true);
        return;
      }
      if (options.syncMode) {
        redraw();
      } else {
        if (redrawTimer) {
          clearTimeout(redrawTimer);
        }
        redrawTimer = setTimeout(redraw.bind(this, true), 0);
      }
    };
    controller.update = (toUpdate) => {
      if (!toUpdate) {
        toUpdate = {};
      } else if (typeof toUpdate === "number") {
        toUpdate = {progress: toUpdate};
      }
      if ("progress" in toUpdate) {
        if (typeof toUpdate.progress !== "number") {
          progress = void 0;
        } else {
          progress = toUpdate.progress;
          if (progress > 1) {
            progress = 1;
          } else if (progress < 0) {
            progress = 0;
          }
          if (progress > 0) {
            progressUpdateCount++;
          }
          lastUpdateTime = new Date().getTime();
        }
      }
      if (typeof toUpdate.items === "number") {
        maxItems = toUpdate.items;
        if (maxItems) {
          progress = itemsDone / maxItems;
        }
        if (typeof options.itemSize !== "number") {
          options.itemSize = Math.round(width / 3);
          itemFiller = " ".repeat(options.itemSize);
        }
      }
      if (typeof toUpdate.title === "string") {
        title = toUpdate.title;
        if (typeof options.titleSize !== "number") {
          options.titleSize = Math.round(width / 3);
          titleFiller = " ".repeat(options.titleSize);
        }
      }
      if (progress >= 1) {
        redraw(true);
        return;
      }
      if (options.syncMode) {
        redraw();
      } else {
        if (redrawTimer) {
          clearTimeout(redrawTimer);
        }
        redrawTimer = setTimeout(redraw.bind(this, true), 0);
      }
    };
    controller.pause = controller.stop = () => {
      pause = true;
    };
    controller.resume = () => {
      if (pause) {
        pause = false;
        redraw();
      }
    };
    controller.reset = () => {
      etaStartingTime = startingTime = new Date().getTime();
      itemsDone = 0;
      progress = void 0;
      itemsStarted.length = 0;
      wheelCounter = itemRollCounter = progressUpdateCount = 0;
      redraw();
    };
    return controller;
  };
  const BIT_DOTS = "\u2800\u2801\u2802\u2803\u2804\u2805\u2806\u2807\u2840\u2841\u2842\u2843\u2844\u2845\u2846\u2847\u2808\u2809\u280A\u280B\u280C\u280D\u280E\u280F\u2848\u2849\u284A\u284B\u284C\u284D\u284E\u284F\u2810\u2811\u2812\u2813\u2814\u2815\u2816\u2817\u2850\u2851\u2852\u2853\u2854\u2855\u2856\u2857\u2818\u2819\u281A\u281B\u281C\u281D\u281E\u281F\u2858\u2859\u285A\u285B\u285C\u285D\u285E\u285F\u2820\u2821\u2822\u2823\u2824\u2825\u2826\u2827\u2860\u2861\u2862\u2863\u2864\u2865\u2866\u2867\u2828\u2829\u282A\u282B\u282C\u282D\u282E\u282F\u2868\u2869\u286A\u286B\u286C\u286D\u286E\u286F\u2830\u2831\u2832\u2833\u2834\u2835\u2836\u2837\u2870\u2871\u2872\u2873\u2874\u2875\u2876\u2877\u2838\u2839\u283A\u283B\u283C\u283D\u283E\u283F\u2878\u2879\u287A\u287B\u287C\u287D\u287E\u287F\u2880\u2881\u2882\u2883\u2884\u2885\u2886\u2887\u28C0\u28C1\u28C2\u28C3\u28C4\u28C5\u28C6\u28C7\u2888\u2889\u288A\u288B\u288C\u288D\u288E\u288F\u28C8\u28C9\u28CA\u28CB\u28CC\u28CD\u28CE\u28CF\u2890\u2891\u2892\u2893\u2894\u2895\u2896\u2897\u28D0\u28D1\u28D2\u28D3\u28D4\u28D5\u28D6\u28D7\u2898\u2899\u289A\u289B\u289C\u289D\u289E\u289F\u28D8\u28D9\u28DA\u28DB\u28DC\u28DD\u28DE\u28DF\u28A0\u28A1\u28A2\u28A3\u28A4\u28A5\u28A6\u28A7\u28E0\u28E1\u28E2\u28E3\u28E4\u28E5\u28E6\u28E7\u28A8\u28A9\u28AA\u28AB\u28AC\u28AD\u28AE\u28AF\u28E8\u28E9\u28EA\u28EB\u28EC\u28ED\u28EE\u28EF\u28B0\u28B1\u28B2\u28B3\u28B4\u28B5\u28B6\u28B7\u28F0\u28F1\u28F2\u28F3\u28F4\u28F5\u28F6\u28F7\u28B8\u28B9\u28BA\u28BB\u28BC\u28BD\u28BE\u28BF\u28F8\u28F9\u28FA\u28FB\u28FC\u28FD\u28FE\u28FF".split("");
  const GROWING_BLOCK = [" ", "\u2581", "\u2582", "\u2583", "\u2584", "\u2585", "\u2586", "\u2587", "\u2588"];
  const ENLARGING_BLOCK = [" ", "\u258F", "\u258E", "\u258D", "\u258C", "\u258B", "\u258A", "\u2589", "\u2588"];
  var spChars$1 = {
    password: "\u25CF",
    forwardSingleQuote: "\xB4",
    overscore: "\xAF",
    multiply: "\xD7",
    divide: "\xF7",
    up: "\u2191",
    down: "\u2193",
    left: "\u2190",
    right: "\u2192",
    leftAndRight: "\u2194",
    upAndDown: "\u2195",
    upLeft: "\u2196",
    upRight: "\u2197",
    downRight: "\u2198",
    downLeft: "\u2199",
    upLeftAndDownRight: "\u2921",
    upRightAndDownLeft: "\u2922",
    northWest: "\u2196",
    northEast: "\u2197",
    southEast: "\u2198",
    southWest: "\u2199",
    northWestAndSouthEast: "\u2921",
    northEastAndSouthWest: "\u2922",
    fullBlock: "\u2588",
    upperHalfBlock: "\u2580",
    lowerHalfBlock: "\u2584",
    growingBlock: GROWING_BLOCK,
    enlargingBlock: ENLARGING_BLOCK,
    bitDots: BIT_DOTS,
    bar: {
      classic: {
        border: ["[", "]"],
        body: ["=", " "]
      },
      classicWithArrow: {
        border: ["[", "]"],
        body: ["=", ">", " "]
      },
      classicWithHalf: {
        border: ["[", "]"],
        body: ["=", " ", "-", "=", " "]
      },
      solid: {
        border: ["^!\u2589", "\u258F"],
        body: ["\u2588", ...ENLARGING_BLOCK, " "]
      }
    },
    box: {
      plain: {
        vertical: "\u2588",
        horizontal: "\u2588",
        topLeft: "\u2588",
        topRight: "\u2588",
        bottomLeft: "\u2588",
        bottomRight: "\u2588",
        topTee: "\u2588",
        bottomTee: "\u2588",
        leftTee: "\u2588",
        rightTee: "\u2588",
        cross: "\u2588"
      },
      empty: {
        vertical: " ",
        horizontal: " ",
        topLeft: " ",
        topRight: " ",
        bottomLeft: " ",
        bottomRight: " ",
        topTee: " ",
        bottomTee: " ",
        leftTee: " ",
        rightTee: " ",
        cross: " "
      },
      ascii: {
        vertical: "|",
        horizontal: "-",
        topLeft: "|",
        topRight: "|",
        bottomLeft: "|",
        bottomRight: "|",
        topTee: "-",
        bottomTee: "-",
        leftTee: "|",
        rightTee: "|",
        cross: "+"
      },
      light: {
        vertical: "\u2502",
        horizontal: "\u2500",
        topLeft: "\u250C",
        topRight: "\u2510",
        bottomLeft: "\u2514",
        bottomRight: "\u2518",
        topTee: "\u252C",
        bottomTee: "\u2534",
        leftTee: "\u251C",
        rightTee: "\u2524",
        cross: "\u253C"
      },
      lightRounded: {
        vertical: "\u2502",
        horizontal: "\u2500",
        topLeft: "\u256D",
        topRight: "\u256E",
        bottomLeft: "\u2570",
        bottomRight: "\u256F",
        topTee: "\u252C",
        bottomTee: "\u2534",
        leftTee: "\u251C",
        rightTee: "\u2524",
        cross: "\u253C"
      },
      heavy: {
        vertical: "\u2503",
        horizontal: "\u2501",
        topLeft: "\u250F",
        topRight: "\u2513",
        bottomLeft: "\u2517",
        bottomRight: "\u251B",
        topTee: "\u2533",
        bottomTee: "\u253B",
        leftTee: "\u2523",
        rightTee: "\u252B",
        cross: "\u254B"
      },
      double: {
        vertical: "\u2551",
        horizontal: "\u2550",
        topLeft: "\u2554",
        topRight: "\u2557",
        bottomLeft: "\u255A",
        bottomRight: "\u255D",
        topTee: "\u2566",
        bottomTee: "\u2569",
        leftTee: "\u2560",
        rightTee: "\u2563",
        cross: "\u256C"
      },
      dotted: {
        vertical: "\u250A",
        horizontal: "\u2504",
        topLeft: "\u250C",
        topRight: "\u2510",
        bottomLeft: "\u2514",
        bottomRight: "\u2518",
        topTee: "\u252C",
        bottomTee: "\u2534",
        leftTee: "\u251C",
        rightTee: "\u2524",
        cross: "\u253C"
      }
    },
    animation: {
      asciiSpinner: ["\u2502", "/", "-", "\\"],
      lineSpinner: ["\u2502", "/", "\u2500", "\\"],
      dotSpinner: [
        BIT_DOTS[7],
        BIT_DOTS[19],
        BIT_DOTS[49],
        BIT_DOTS[112],
        BIT_DOTS[224],
        BIT_DOTS[200],
        BIT_DOTS[140],
        BIT_DOTS[14]
      ],
      bitDots: BIT_DOTS,
      impulse: [
        "\u2219\u2219\u2219",
        "\u25CF\u2219\u2219",
        "\u2219\u25CF\u2219",
        "\u2219\u2219\u25CF",
        "\u2219\u25CF\u2219",
        "\u25CF\u2219\u2219",
        "\u2219\u2219\u2219",
        "\u2219\u2219\u2219"
      ],
      unboxing: [" ", "\u2581", "\u2582", "\u2583", "\u2584", "\u2585", "\u2586", "\u2587", "\u2588", "\u2589", "\u258A", "\u258B", "\u258C", "\u258D", "\u258E", "\u258F"],
      "unboxing-color": [
        "^r^#^b ",
        "^r^#^b\u2581",
        "^r^#^b\u2582",
        "^r^#^b\u2583",
        "^r^#^b\u2584",
        "^r^#^b\u2585",
        "^r^#^b\u2586",
        "^r^#^b\u2587",
        "^r^#^m\u2588",
        "^r^#^m\u2589",
        "^r^#^m\u258A",
        "^r^#^m\u258B",
        "^r^#^m\u258C",
        "^r^#^m\u258D",
        "^r^#^m\u258E",
        "^r^#^m\u258F",
        "^m^#^y\u2588",
        "^m^#^y\u2587",
        "^m^#^y\u2586",
        "^m^#^y\u2585",
        "^m^#^y\u2584",
        "^m^#^y\u2583",
        "^m^#^y\u2582",
        "^m^#^y\u2581",
        "^b^#^y ",
        "^b^#^y\u258F",
        "^b^#^y\u258E",
        "^b^#^y\u258D",
        "^b^#^y\u258C",
        "^b^#^y\u258B",
        "^b^#^y\u258A",
        "^b^#^y\u2589"
      ]
    },
    blackSquare: "\u25A0",
    whiteSquare: "\u25A1",
    blackCircle: "\u25CF",
    whiteCircle: "\u25CB",
    blackUpTriangle: "\u25B2",
    whiteUpTriangle: "\u25B3",
    blackDownTriangle: "\u25BC",
    whiteDownTriangle: "\u25BD",
    blackLeftTriangle: "\u25C0",
    whiteLeftTriangle: "\u25C1",
    blackRightTriangle: "\u25B6",
    whiteRightTriangle: "\u25B7",
    blackDiamond: "\u25C6",
    whiteDiamond: "\u25C7",
    blackStar: "\u2605",
    whiteStar: "\u2606",
    spadeSuit: "\u2660",
    heartSuit: "\u2665",
    diamondSuit: "\u2666",
    clubSuit: "\u2663",
    powerline: {
      branch: "\uE0A0",
      line: "\uE0A1",
      readOnly: "\uE0A2",
      rightTriangleSeparator: "\uE0B0",
      rightArrowSeparator: "\uE0B1",
      leftTriangleSeparator: "\uE0B2",
      leftArrowSeparator: "\uE0B3"
    }
  };
  const spChars = spChars$1;
  var bar = function(value, options) {
    var str = "", barString = "";
    options = options || {};
    if (isNaN(value) || value < 0) {
      value = 0;
    } else if (value > 1) {
      value = 1;
    }
    var innerSize = options.innerSize || 10;
    var fullBlocks = Math.floor(value * innerSize);
    var partialBlock = Math.round((value * innerSize - fullBlocks) * 8);
    var barStyle = options.barStyle || this.blue;
    barString += "\u2588".repeat(fullBlocks);
    if (fullBlocks < innerSize) {
      barString += spChars.enlargingBlock[partialBlock];
      barString += " ".repeat(innerSize - fullBlocks - 1);
    }
    if (options.str) {
      str += this.str.inverse("\u2589");
      str += barStyle.str(barString);
      str += this.str("\u258F");
      return str;
    }
    this.inverse("\u2589");
    barStyle(barString);
    this("\u258F");
    return this;
  };
  var Promise$4 = seventh_1;
  var slowTyping = function slowTyping(str, options, callback) {
    if (typeof str !== "string") {
      throw new TypeError("[terminal] slowTyping(): argument #0 should be a string");
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options || typeof options !== "object") {
      options = {};
    }
    if (!options.style) {
      options.style = this.green;
    }
    if (!options.delay) {
      options.delay = 150;
    }
    if (!options.flashStyle) {
      options.flashStyle = this.bold.brightGreen;
    }
    if (!options.flashDelay) {
      options.flashDelay = 100;
    }
    var index, unflashTimer, promise = new Promise$4();
    var printChar = () => {
      if (unflashTimer) {
        clearTimeout(unflashTimer);
        unflashTimer = null;
        unflash();
      }
      if (index === void 0) {
        index = 0;
      } else if (index >= str.length) {
        if (callback) {
          callback();
        } else {
          promise.resolve();
        }
        return;
      } else {
        if (options.flashStyle && str[index].match(/\S/)) {
          options.flashStyle(str[index]);
          unflashTimer = setTimeout(unflash, options.flashDelay);
        } else {
          options.style(str[index]);
        }
        index++;
      }
      setTimeout(printChar, (0.2 + Math.random() * 1.8) * options.delay);
    };
    var unflash = () => {
      this.left(1);
      options.style(str[index - 1]);
      unflashTimer = null;
    };
    printChar();
    return promise;
  };
  var extClipboard = {};
  const Promise$3 = seventh_1;
  Promise$3.promisifyNodeApi(require$$2);
  const Promise$2 = seventh_1;
  require$$2.execAsync;
  const execFileAsync = require$$2.execFileAsync;
  const spawn = require$$2.spawn;
  const XCLIP_SELECTION_ARG = {
    c: "clipboard",
    p: "primary",
    s: "secondary"
  };
  if (process.platform === "linux") {
    extClipboard.getClipboard = (source) => __async(this, null, function* () {
      var arg = XCLIP_SELECTION_ARG[source[0]] || "clipboard";
      return yield execFileAsync("xclip", ["-o", "-selection", arg]);
    });
    extClipboard.setClipboard = (str, source) => __async(this, null, function* () {
      var promise = new Promise$2();
      var arg = XCLIP_SELECTION_ARG[source[0]] || "clipboard";
      var xclip = spawn("xclip", ["-i", "-selection", arg]);
      xclip.on("error", (error) => {
        promise.reject(error);
      });
      xclip.on("exit", (code) => {
        if (code !== 0) {
          promise.reject(code);
        } else {
          promise.resolve();
        }
      });
      xclip.stdin.end(str);
      return promise;
    });
  } else {
    extClipboard.getClipboard = () => Promise$2.reject(new Error("No clipboard manipulation program found"));
    extClipboard.setClipboard = () => Promise$2.reject(new Error("No clipboard manipulation program found"));
  }
  var require$$15 = [
    {
      r: 0,
      g: 0,
      b: 0,
      names: [
        "black"
      ]
    },
    {
      r: 180,
      g: 0,
      b: 0,
      names: [
        "red"
      ]
    },
    {
      r: 0,
      g: 180,
      b: 0,
      names: [
        "green"
      ]
    },
    {
      r: 180,
      g: 180,
      b: 0,
      names: [
        "yellow"
      ]
    },
    {
      r: 0,
      g: 0,
      b: 180,
      names: [
        "blue"
      ]
    },
    {
      r: 180,
      g: 0,
      b: 180,
      names: [
        "magenta"
      ]
    },
    {
      r: 0,
      g: 180,
      b: 180,
      names: [
        "cyan"
      ]
    },
    {
      r: 220,
      g: 220,
      b: 220,
      names: [
        "white"
      ]
    },
    {
      r: 55,
      g: 55,
      b: 55,
      names: [
        "brightBlack",
        "gray",
        "grey"
      ]
    },
    {
      r: 250,
      g: 0,
      b: 0,
      names: [
        "brightRed"
      ]
    },
    {
      r: 0,
      g: 250,
      b: 0,
      names: [
        "brightGreen"
      ]
    },
    {
      r: 250,
      g: 250,
      b: 0,
      names: [
        "brightYellow"
      ]
    },
    {
      r: 0,
      g: 0,
      b: 250,
      names: [
        "brightBlue"
      ]
    },
    {
      r: 250,
      g: 0,
      b: 250,
      names: [
        "brightMagenta"
      ]
    },
    {
      r: 0,
      g: 250,
      b: 250,
      names: [
        "brightCyan"
      ]
    },
    {
      r: 250,
      g: 250,
      b: 250,
      names: [
        "brightWhite"
      ]
    }
  ];
  const tree = tree_1;
  const string = string$4;
  const NextGenEvents = NextGenEvents_1;
  const Promise$1 = seventh_1;
  const termkit$1 = termkit_1;
  function Terminal(...args) {
    return Terminal.create(...args);
  }
  Terminal.prototype = Object.create(NextGenEvents.prototype);
  Terminal.prototype.constructor = Terminal;
  var Terminal_1 = Terminal;
  Terminal.create = function(createOptions) {
    if (!createOptions || typeof createOptions !== "object") {
      createOptions = {};
    }
    if (!createOptions.stdin) {
      createOptions.stdin = process.stdin;
    }
    if (!createOptions.stdout) {
      createOptions.stdout = process.stdout;
    }
    if (!createOptions.stderr) {
      createOptions.stderr = process.stderr;
    }
    if (typeof createOptions.generic !== "string") {
      createOptions.generic = "xterm";
    }
    var k;
    var termconfig;
    var chainable = Object.create(notChainable);
    var options = {
      on: "",
      off: "",
      params: 0,
      out: createOptions.stdout
    };
    var term = applyEscape.bind(void 0, options);
    Object.setPrototypeOf(term, chainable);
    term.apply = Function.prototype.apply;
    term.call = Function.prototype.call;
    options.root = term;
    term.root = term;
    term.options = options;
    term.stdin = createOptions.stdin;
    term.stdout = createOptions.stdout;
    term.stderr = createOptions.stderr;
    term.generic = createOptions.generic;
    term.appId = createOptions.appId;
    term.appName = createOptions.appName;
    term.isTTY = createOptions.isTTY === void 0 ? true : !!createOptions.isTTY;
    term.isSSH = !!createOptions.isSSH;
    term.pid = createOptions.pid;
    term.grabbing = false;
    term.mouseGrabbing = false;
    term.focusGrabbing = false;
    term.timeout = term.isSSH ? 500 : 200;
    term.shutdown = false;
    term.raw = term.stdout.write.bind(term.stdout);
    term.onStdin = onStdin.bind(term);
    term.prependStdinChunk = null;
    term.lock = {};
    term.wrapOptions = {
      x: 1,
      width: null,
      continue: false,
      offset: 0
    };
    term.width = void 0;
    term.height = void 0;
    onResize.call(term);
    if (createOptions.preferProcessSigwinch) {
      process.on("SIGWINCH", onResize.bind(term));
    } else if (term.stdout.isTTY) {
      term.stdout.on("resize", onResize.bind(term));
    } else if (createOptions.processSigwinch) {
      process.on("SIGWINCH", onResize.bind(term));
    }
    term.state = {
      fullscreen: false,
      button: {
        left: null,
        middle: null,
        right: null,
        other: null
      }
    };
    if (term.appId) {
      try {
        term.termconfigFile = term.appId + ".js";
        termconfig = require("./termconfig/" + term.termconfigFile);
      } catch (error) {
      }
    }
    if (!termconfig) {
      try {
        term.termconfigFile = term.generic + ".generic.js";
        termconfig = require("./termconfig/" + term.termconfigFile);
      } catch (error) {
        try {
          term.termconfigFile = term.generic + ".js";
          termconfig = require("./termconfig/" + term.termconfigFile);
        } catch (error_) {
          term.termconfigFile = "xterm.generic.js";
          termconfig = require("./termconfig/" + term.termconfigFile);
        }
      }
    }
    term.esc = tree.extend({deep: true}, {}, termconfig.esc);
    term.support = tree.extend({deep: true}, {}, termconfig.support);
    tree.extend(null, term.esc, pseudoEsc, {
      gray: term.esc.brightBlack,
      grey: term.esc.brightBlack,
      bgGray: term.esc.bgBrightBlack,
      bgGrey: term.esc.bgBrightBlack
    });
    term.handler = tree.extend(null, {}, termconfig.handler);
    term.keymap = tree.extend({deep: true}, {}, termconfig.keymap);
    term.colorRegister = tree.extend({deep: true}, [], defaultColorRegister, termconfig.colorRegister);
    term.escHandler = {root: term};
    term.escOffHandler = {root: term};
    term.rKeymap = [];
    term.rKeymapMaxSize = -1;
    term.rKeymapStarter = [];
    term.rKeymapStarterMaxSize = -1;
    Object.keys(term.keymap).forEach((key) => {
      var i, j, keymapObject, code, codeList = term.keymap[key];
      if (!Array.isArray(codeList)) {
        codeList = [codeList];
        term.keymap[key] = codeList;
      }
      for (j = 0; j < codeList.length; j++) {
        code = codeList[j];
        if (typeof code === "object") {
          keymapObject = code;
          keymapObject.name = key;
          code = keymapObject.code;
        } else {
          keymapObject = {
            code,
            name: key,
            matches: [key]
          };
          term.keymap[key][j] = {code};
        }
        if (keymapObject.handler && typeof keymapObject.handler !== "function") {
          term.keymap[key][j].handler = term.handler[keymapObject.handler];
        }
        if (code) {
          if (code.length > term.rKeymapMaxSize) {
            for (i = term.rKeymapMaxSize + 1; i <= code.length; i++) {
              term.rKeymap[i] = {};
            }
            term.rKeymapMaxSize = code.length;
          }
          if (term.rKeymap[code.length][code]) {
            term.rKeymap[code.length][code].matches.push(key);
          } else {
            term.rKeymap[code.length][code] = keymapObject;
            term.rKeymap[code.length][code].matches = [key];
          }
        } else {
          if (!keymapObject.starter || !keymapObject.ender || !keymapObject.handler) {
            continue;
          }
          if (keymapObject.starter.length > term.rKeymapStarterMaxSize) {
            for (i = term.rKeymapStarterMaxSize + 1; i <= keymapObject.starter.length; i++) {
              term.rKeymapStarter[i] = {};
            }
            term.rKeymapStarterMaxSize = keymapObject.starter.length;
          }
          if (term.rKeymapStarter[keymapObject.starter.length][keymapObject.starter]) {
            term.rKeymapStarter[keymapObject.starter.length][keymapObject.starter].push(key);
          } else {
            term.rKeymapStarter[keymapObject.starter.length][keymapObject.starter] = [keymapObject];
          }
        }
      }
    });
    Object.keys(term.esc).forEach((key) => {
      if (!term.esc[key] || typeof term.esc[key] !== "object") {
        console.error("Bad escape sequence entry '" + key + "' using termconfig: '" + term.termconfigFile + "'.");
        return;
      }
      if (typeof term.esc[key].on === "function") {
        term.esc[key].on = term.esc[key].on.call(term);
      }
      if (typeof term.esc[key].off === "function") {
        term.esc[key].off = term.esc[key].off.call(term);
      }
      if (term.esc[key].handler) {
        if (typeof term.esc[key].handler === "function") {
          term.escHandler[key] = term.esc[key].handler.bind(term);
        } else {
          term.escHandler[key] = term.handler[term.esc[key].handler];
        }
      }
      if (term.esc[key].offHandler) {
        if (typeof term.esc[key].offHandler === "function") {
          term.escOffHandler[key] = term.esc[key].offHandler.bind(term);
        } else {
          term.escOffHandler[key] = term.handler[term.esc[key].offHandler];
        }
      }
      Object.defineProperty(chainable, key, {
        configurable: true,
        get: function() {
          var fn, chainOptions;
          chainOptions = Object.assign({}, this.options);
          chainOptions.on += this.root.esc[key].on || "";
          chainOptions.off = (this.root.esc[key].off || "") + chainOptions.off;
          chainOptions.params += string.format.count(this.root.esc[key].on);
          if (!chainOptions.onHasFormatting && (chainOptions.params || typeof this.root.esc[key].on === "string" && string.format.hasFormatting(this.root.esc[key].on))) {
            chainOptions.onHasFormatting = true;
          }
          if (!chainOptions.offHasFormatting && (typeof this.root.esc[key].off === "string" && string.format.hasFormatting(this.root.esc[key].off))) {
            chainOptions.offHasFormatting = true;
          }
          if (this.root.esc[key].err) {
            chainOptions.err = true;
            chainOptions.out = this.root.stderr;
          }
          if (this.root.esc[key].str) {
            chainOptions.str = true;
          }
          if (this.root.esc[key].bind) {
            chainOptions.bind = true;
          }
          if (this.root.esc[key].forceStyleOnReset) {
            chainOptions.forceStyleOnReset = true;
          }
          if (this.root.esc[key].noFormat) {
            chainOptions.noFormat = true;
          }
          if (this.root.esc[key].markupOnly) {
            chainOptions.markupOnly = true;
          }
          if (this.root.esc[key].wrap) {
            chainOptions.wrap = true;
          }
          fn = applyEscape.bind(void 0, chainOptions);
          Object.setPrototypeOf(fn, chainable);
          fn.apply = Function.prototype.apply;
          fn.root = this.root || this;
          fn.options = chainOptions;
          Object.defineProperty(this, key, {value: fn, configurable: true});
          return fn;
        }
      });
    });
    term.resetString = "";
    term.setResetString = function(str) {
      term.resetString = string.markupMethod.call(term.formatConfig.rawMarkupConfig, str);
    };
    var resetFn = (extra) => term.str.styleReset() + term.resetString + extra;
    term.formatConfig = {
      fn: {},
      endingMarkupReset: true,
      markupReset: resetFn.bind(void 0, ""),
      shiftMarkup: {
        "#": "background"
      },
      markup: {
        ":": resetFn.bind(void 0, ""),
        " ": resetFn.bind(void 0, " "),
        "-": term.str.dim(),
        "+": term.str.bold(),
        "_": term.str.underline(),
        "/": term.str.italic(),
        "!": term.str.inverse(),
        "b": term.str.blue(),
        "B": term.str.brightBlue(),
        "c": term.str.cyan(),
        "C": term.str.brightCyan(),
        "g": term.str.green(),
        "G": term.str.brightGreen(),
        "k": term.str.black(),
        "K": term.str.brightBlack(),
        "m": term.str.magenta(),
        "M": term.str.brightMagenta(),
        "r": term.str.red(),
        "R": term.str.brightRed(),
        "w": term.str.white(),
        "W": term.str.brightWhite(),
        "y": term.str.yellow(),
        "Y": term.str.brightYellow()
      },
      shiftedMarkup: {
        background: {
          ":": resetFn.bind(void 0, ""),
          " ": resetFn.bind(void 0, " "),
          "b": term.str.bgBlue(),
          "B": term.str.bgBrightBlue(),
          "c": term.str.bgCyan(),
          "C": term.str.bgBrightCyan(),
          "g": term.str.bgGreen(),
          "G": term.str.bgBrightGreen(),
          "k": term.str.bgBlack(),
          "K": term.str.bgBrightBlack(),
          "m": term.str.bgMagenta(),
          "M": term.str.bgBrightMagenta(),
          "r": term.str.bgRed(),
          "R": term.str.bgBrightRed(),
          "w": term.str.bgWhite(),
          "W": term.str.bgBrightWhite(),
          "y": term.str.bgYellow(),
          "Y": term.str.bgBrightYellow()
        }
      }
    };
    term.formatConfig.rawMarkupConfig = Object.create(term.formatConfig);
    term.formatConfig.rawMarkupConfig.startingMarkupReset = false;
    term.formatConfig.rawMarkupConfig.endingMarkupReset = false;
    for (k in term.escHandler) {
      term.formatConfig.fn[k] = term.escHandler[k];
    }
    for (k in term.escOffHandler) {
      term.formatConfig.fn[k + "_off"] = term.escOffHandler[k];
    }
    term.format = string.createFormatter(term.formatConfig);
    term.markup = string.createMarkup(term.formatConfig);
    term.options = options;
    createOptimized(term);
    process.on("exit", () => {
      if (term.shutdown) {
        return;
      }
      term.shutdown = true;
      term.styleReset();
      term.grabInput(false);
    });
    process.on("asyncExit", (code, timeout, done) => {
      term.asyncCleanup().then(done);
    });
    process.once("beforeExit", () => {
      term.asyncCleanup();
    });
    term.palette = new termkit$1.Palette({system: true, term});
    return term;
  };
  function createOptimized(term) {
    var i;
    term.optimized = {};
    term.optimized.styleReset = term.str.styleReset();
    term.optimized.bold = term.str.bold();
    term.optimized.dim = term.str.dim();
    term.optimized.italic = term.str.italic();
    term.optimized.underline = term.str.underline();
    term.optimized.blink = term.str.blink();
    term.optimized.inverse = term.str.inverse();
    term.optimized.hidden = term.str.hidden();
    term.optimized.strike = term.str.strike();
    term.optimized.noBold = term.str.bold(false);
    term.optimized.noDim = term.str.dim(false);
    term.optimized.noItalic = term.str.italic(false);
    term.optimized.noUnderline = term.str.underline(false);
    term.optimized.noBlink = term.str.blink(false);
    term.optimized.noInverse = term.str.inverse(false);
    term.optimized.noHidden = term.str.hidden(false);
    term.optimized.noStrike = term.str.strike(false);
    term.optimized.color256 = [];
    term.optimized.bgColor256 = [];
    for (i = 0; i <= 255; i++) {
      term.optimized.color256[i] = term.str.color256(i);
      term.optimized.bgColor256[i] = term.str.bgColor256(i);
    }
    term.optimized.defaultColor = term.str.defaultColor();
    term.optimized.bgDefaultColor = term.str.bgDefaultColor();
    term.optimized.moveTo = term.esc.moveTo.optimized || term.str.moveTo;
    term.optimized.right = term.str.right(1);
    term.optimized.color24bits = term.esc.color24bits.optimized || term.str.color24bits;
    term.optimized.bgColor24bits = term.esc.bgColor24bits.optimized || term.str.bgColor24bits;
  }
  function applyEscape(options, ...args) {
    var fn, newOptions, wrapOptions;
    if (options.bounded) {
      args = options.bounded.concat(args);
    }
    if (options.bind) {
      newOptions = Object.assign({}, options, {bind: false, bounded: args});
      fn = applyEscape.bind(this, newOptions);
      Object.setPrototypeOf(fn, Object.getPrototypeOf(options.root));
      fn.apply = Function.prototype.apply;
      fn.root = options.root;
      fn.options = newOptions;
      return fn;
    }
    var onFormat = [options.on], output, on, off;
    var action = args[options.params];
    if (options.params) {
      onFormat = onFormat.concat(args.slice(0, options.params));
    }
    if (action === void 0 || action === true) {
      on = options.onHasFormatting ? options.root.format(...onFormat) : options.on;
      if (options.str) {
        return on;
      }
      options.out.write(on);
      return options.root;
    }
    if (action === null || action === false) {
      off = options.offHasFormatting ? options.root.format(options.off) : options.off;
      if (options.str) {
        return off;
      }
      options.out.write(off);
      return options.root;
    }
    if (typeof action !== "string") {
      if (typeof action.toString === "function") {
        action = action.toString();
      } else {
        action = "";
      }
    }
    on = options.onHasFormatting ? options.root.format(...onFormat) : options.on;
    if (options.markupOnly) {
      action = options.root.markup(...args.slice(options.params));
    } else if (!options.noFormat) {
      action = options.root.format(...args.slice(options.params));
    }
    if (options.wrap) {
      if (options.root.wrapOptions.x && options.root.wrapOptions.x > 1) {
        wrapOptions = {
          width: options.root.wrapOptions.width || options.root.width - options.root.wrapOptions.x + 1,
          glue: "\n" + options.root.str.column(options.root.wrapOptions.x),
          offset: options.root.wrapOptions.offset,
          updateOffset: true,
          skipFn: termkit$1.escapeSequenceSkipFn
        };
        action = string.wordwrap(action, wrapOptions);
        if (!options.root.wrapOptions.continue) {
          action = options.root.str.column(options.root.wrapOptions.x) + action;
        }
        options.root.wrapOptions.continue = true;
        options.root.wrapOptions.offset = wrapOptions.offset;
      } else {
        wrapOptions = {
          width: options.root.wrapOptions.width || options.root.width,
          glue: "\n",
          offset: options.root.wrapOptions.offset,
          updateOffset: true,
          skipFn: termkit$1.escapeSequenceSkipFn
        };
        action = string.wordwrap(action, wrapOptions);
        options.root.wrapOptions.continue = true;
        options.root.wrapOptions.offset = wrapOptions.offset;
      }
    } else {
      options.root.wrapOptions.continue = false;
      options.root.wrapOptions.offset = 0;
    }
    off = options.offHasFormatting ? options.root.format(options.off) : options.off;
    if (options.forceStyleOnReset) {
      action = action.replace(new RegExp(string.escape.regExp(options.root.optimized.styleReset), "g"), options.root.optimized.styleReset + on);
    }
    if (options.root.resetString) {
      output = options.root.resetString + on + action + off + options.root.resetString;
    } else {
      output = on + action + off;
    }
    if (options.crlf) {
      output = output.replace(/\n/g, "\r\n");
    }
    if (options.str) {
      return output;
    }
    options.out.write(output);
    return options.root;
  }
  var pseudoEsc = {
    error: {err: true},
    str: {str: true},
    attr: {attr: true},
    bindArgs: {bind: true},
    forceStyleOnReset: {forceStyleOnReset: true},
    noFormat: {noFormat: true},
    markupOnly: {markupOnly: true},
    wrap: {wrap: true},
    move: {
      on: "%[move:%a%a]F",
      handler: function move(x, y) {
        var sequence = "";
        if (x) {
          if (x > 0) {
            sequence += this.root.format(this.root.esc.right.on, x);
          } else {
            sequence += this.root.format(this.root.esc.left.on, -x);
          }
        }
        if (y) {
          if (y > 0) {
            sequence += this.root.format(this.root.esc.down.on, y);
          } else {
            sequence += this.root.format(this.root.esc.up.on, -y);
          }
        }
        return sequence;
      }
    },
    color: {
      on: "%[color:%a]F",
      off: function() {
        return this.root.esc.defaultColor.on;
      },
      handler: function color(c) {
        if (typeof c === "string") {
          c = termkit$1.colorNameToIndex(c);
        }
        if (typeof c !== "number") {
          return "";
        }
        c = Math.floor(c);
        if (c < 0 || c > 15) {
          return "";
        }
        if (c <= 7) {
          return this.root.format(this.root.esc.darkColor.on, c);
        }
        return this.root.format(this.root.esc.brightColor.on, c - 8);
      }
    },
    bgColor: {
      on: "%[bgColor:%a]F",
      off: function() {
        return this.root.esc.bgDefaultColor.on;
      },
      handler: function bgColor(c) {
        if (typeof c === "string") {
          c = termkit$1.colorNameToIndex(c);
        }
        if (typeof c !== "number") {
          return "";
        }
        c = Math.floor(c);
        if (c < 0 || c > 15) {
          return "";
        }
        if (c <= 7) {
          return this.root.format(this.root.esc.bgDarkColor.on, c);
        }
        return this.root.format(this.root.esc.bgBrightColor.on, c - 8);
      }
    },
    colorRgb: {
      on: "%[colorRgb:%a%a%a]F",
      off: function() {
        return this.root.esc.defaultColor.on;
      },
      handler: colorRgbHandler
    },
    bgColorRgb: {
      on: "%[bgColorRgb:%a%a%a]F",
      off: function() {
        return this.root.esc.bgDefaultColor.on;
      },
      handler: bgColorRgbHandler
    },
    colorRgbHex: {
      on: "%[colorRgbHex:%a]F",
      off: function() {
        return this.root.esc.defaultColor.on;
      },
      handler: colorRgbHandler
    },
    bgColorRgbHex: {
      on: "%[bgColorRgbHex:%a]F",
      off: function() {
        return this.root.esc.bgDefaultColor.on;
      },
      handler: bgColorRgbHandler
    },
    colorGrayscale: {
      on: "%[colorGrayscale:%a]F",
      off: function() {
        return this.root.esc.defaultColor.on;
      },
      handler: function colorGrayscale(g) {
        var c;
        if (typeof g !== "number") {
          return "";
        }
        if (g < 0 || g > 255) {
          return "";
        }
        if (!this.root.esc.color24bits.na && !this.root.esc.color24bits.fb) {
          return this.root.format(this.root.esc.color24bits.on, g, g, g);
        }
        if (!this.root.esc.color256.na && !this.root.esc.color256.fb) {
          g = Math.round(g * 25 / 255);
          if (g < 0 || g > 25) {
            return "";
          }
          if (g === 0) {
            c = 16;
          } else if (g === 25) {
            c = 231;
          } else {
            c = g + 231;
          }
          return this.root.format(this.root.esc.color256.on, c);
        }
        c = this.root.registerForRgb(g, g, g, 0, 15);
        return this.root.format(this.root.esc.color.on, c);
      }
    },
    bgColorGrayscale: {
      on: "%[bgColorGrayscale:%a]F",
      off: function() {
        return this.root.esc.bgDefaultColor.on;
      },
      handler: function bgColorGrayscale(g) {
        var c;
        if (typeof g !== "number") {
          return "";
        }
        if (g < 0 || g > 255) {
          return "";
        }
        if (!this.root.esc.bgColor24bits.na && !this.root.esc.bgColor24bits.fb) {
          return this.root.format(this.root.esc.bgColor24bits.on, g, g, g);
        }
        if (!this.root.esc.bgColor256.na && !this.root.esc.bgColor256.fb) {
          g = Math.round(g * 25 / 255);
          if (g < 0 || g > 25) {
            return "";
          }
          if (g === 0) {
            c = 16;
          } else if (g === 25) {
            c = 231;
          } else {
            c = g + 231;
          }
          return this.root.format(this.root.esc.bgColor256.on, c);
        }
        c = this.root.registerForRgb(g, g, g, 0, 15);
        return this.root.format(this.root.esc.bgColor.on, c);
      }
    }
  };
  function colorRgbHandler(r, g, b) {
    var c, rgb;
    if (typeof r === "string") {
      rgb = termkit$1.hexToRgba(r);
      r = rgb.r;
      g = rgb.g;
      b = rgb.b;
    }
    if (typeof r !== "number" || isNaN(r) || typeof g !== "number" || isNaN(g) || typeof b !== "number" || isNaN(b) || r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
      return "";
    }
    if (!this.root.esc.color24bits.na && !this.root.esc.color24bits.fb) {
      return this.root.format(this.root.esc.color24bits.on, r, g, b);
    }
    if (!this.root.esc.color256.na && !this.root.esc.color256.fb) {
      r = Math.round(r * 5 / 255);
      g = Math.round(g * 5 / 255);
      b = Math.round(b * 5 / 255);
      c = 16 + r * 36 + g * 6 + b;
      return this.root.format(this.root.esc.color256.on, c);
    }
    c = this.root.registerForRgb(r, g, b, 0, 15);
    return this.root.format(this.root.esc.color.on, c);
  }
  function bgColorRgbHandler(r, g, b) {
    var c, rgb;
    if (typeof r === "string") {
      rgb = termkit$1.hexToRgba(r);
      r = rgb.r;
      g = rgb.g;
      b = rgb.b;
    }
    if (typeof r !== "number" || isNaN(r) || typeof g !== "number" || isNaN(g) || typeof b !== "number" || isNaN(b) || r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
      return "";
    }
    if (!this.root.esc.bgColor24bits.na && !this.root.esc.bgColor24bits.fb) {
      return this.root.format(this.root.esc.bgColor24bits.on, r, g, b);
    }
    if (!this.root.esc.bgColor256.na && !this.root.esc.bgColor256.fb) {
      r = Math.round(r * 5 / 255);
      g = Math.round(g * 5 / 255);
      b = Math.round(b * 5 / 255);
      c = 16 + r * 36 + g * 6 + b;
      return this.root.format(this.root.esc.bgColor256.on, c);
    }
    c = this.root.registerForRgb(r, g, b, 0, 15);
    return this.root.format(this.root.esc.bgColor.on, c);
  }
  function onResize() {
    if (this.stdout.columns && this.stdout.rows) {
      this.width = this.stdout.columns;
      this.height = this.stdout.rows;
    }
    this.emit("resize", this.width, this.height);
  }
  var notChainable = Object.create(Terminal.prototype);
  notChainable.yesOrNo = yesOrNo;
  notChainable.inputField = inputField;
  notChainable.fileInput = fileInput;
  notChainable.singleRowMenu = notChainable.singleLineMenu = singleLineMenu;
  notChainable.singleColumnMenu = singleColumnMenu;
  notChainable.gridMenu = gridMenu;
  notChainable.progressBar = progressBar;
  notChainable.bar = bar;
  notChainable.slowTyping = slowTyping;
  notChainable.createDocument = function(options) {
    if (!options || typeof options !== "object") {
      options = {};
    }
    options.outputDst = this;
    options.eventSource = this;
    return new termkit$1.Document(options);
  };
  notChainable.createInlineElement = function(Type, options) {
    return termkit$1.Element.createInline(this, Type, options);
  };
  notChainable.table = function(table, options = {}) {
    return termkit$1.Element.createInline(this, termkit$1.TextTable, Object.assign({}, options, {
      cellContents: table,
      fit: options.fit !== void 0 ? !!options.fit : true
    }));
  };
  notChainable.spinner = function(options = {}) {
    if (typeof options === "string") {
      options = {animation: options};
    }
    return termkit$1.Element.createInline(this, termkit$1.AnimatedText, options);
  };
  notChainable.wrapColumn = function(...args) {
    this.wrapOptions.continue = false;
    this.wrapOptions.offset = 0;
    if (!args.length) {
      return;
    }
    if (args[0] && typeof args[0] === "object") {
      Object.assign(this.wrapOptions, args[0]);
      return this.wrap;
    }
    if (args.length === 1) {
      this.wrapOptions.x = 1;
      this.wrapOptions.width = args[0];
      return this.wrap;
    }
    this.wrapOptions.x = args[0];
    this.wrapOptions.width = args[1];
    return this.wrap;
  };
  notChainable.fullscreen = function(options) {
    if (options === false) {
      if (!this.state.fullscreen) {
        return this;
      }
      this.state.fullscreen = false;
      this.moveTo(1, this.height, "\n");
      this.alternateScreenBuffer(false);
      return this;
    }
    if (!options) {
      options = {};
    }
    this.state.fullscreen = true;
    if (!options.noAlternate) {
      this.alternateScreenBuffer(true);
    }
    this.clear();
  };
  function onStdin(chunk) {
    var i, j, buffer, startBuffer, char, codepoint, keymapCode, keymapStartCode, keymap, keymapList, regexp, matches, bytes, found, handlerResult, accumulate = false, index = 0, length = chunk.length;
    if (this.shutdown) {
      return;
    }
    if (this.prependStdinChunk) {
      chunk = Buffer.concat([this.prependStdinChunk, chunk]);
    }
    while (index < length) {
      found = false;
      bytes = 1;
      if (chunk[index] <= 31 || chunk[index] === 127) {
        for (i = Math.min(length, Math.max(this.rKeymapMaxSize, this.rKeymapStarterMaxSize)); i > 0; i--) {
          buffer = chunk.slice(index);
          keymapCode = buffer.toString();
          startBuffer = chunk.slice(index, index + i);
          keymapStartCode = startBuffer.toString();
          if (this.rKeymap[i] && this.rKeymap[i][keymapStartCode]) {
            keymap = this.rKeymap[i][keymapStartCode];
            found = true;
            if (keymap.handler) {
              handlerResult = keymap.handler.call(this, keymap.name, chunk.slice(index + i));
              bytes = i + handlerResult.eaten;
              if (!handlerResult.disable) {
                this.emit(keymap.event, handlerResult.name, handlerResult.data);
              }
            } else if (keymap.event) {
              bytes = i;
              this.emit(keymap.event, keymap.name, keymap.data, {code: startBuffer});
            } else {
              bytes = i;
              this.emit("key", keymap.name, keymap.matches, {isCharacter: false, code: startBuffer});
            }
            break;
          } else if (this.rKeymapStarter[i] && this.rKeymapStarter[i][keymapStartCode]) {
            keymapList = this.rKeymapStarter[i][keymapStartCode];
            for (j = 0; j < keymapList.length; j++) {
              keymap = keymapList[j];
              if (keymap.altEnder) {
                regexp = "^" + string.escape.regExp(keymap.starter) + "([ -~]*?)(" + string.escape.regExp(keymap.ender) + "|" + string.escape.regExp(keymap.altEnder) + ")";
              } else {
                regexp = "^" + string.escape.regExp(keymap.starter) + "([ -~]*?)" + string.escape.regExp(keymap.ender);
              }
              matches = keymapCode.match(new RegExp(regexp), "g");
              if (matches) {
                found = true;
                handlerResult = keymap.handler.call(this, keymap.name, matches[1]);
                bytes = matches[0].length;
                this.emit(keymap.event, handlerResult.name, handlerResult.data);
                break;
              } else if (keymap.accumulate) {
                found = true;
                accumulate = true;
                break;
              }
            }
            if (found) {
              break;
            }
          }
        }
        if (!found) {
          this.emit("unknown", chunk);
          break;
        }
      } else if (chunk[index] >= 128) {
        if (chunk[index] < 192) {
          continue;
        } else if (chunk[index] < 224) {
          bytes = 2;
        } else if (chunk[index] < 240) {
          bytes = 3;
        } else if (chunk[index] < 248) {
          bytes = 4;
        } else if (chunk[index] < 252) {
          bytes = 5;
        } else {
          bytes = 6;
        }
        buffer = chunk.slice(index, index + bytes);
        char = buffer.toString("utf8");
        if (bytes > 2) {
          codepoint = string.unicode.firstCodePoint(char);
        } else {
          codepoint = char.charCodeAt(0);
        }
        this.emit("key", char, [char], {isCharacter: true, codepoint, code: buffer});
      } else {
        char = String.fromCharCode(chunk[index]);
        this.emit("key", char, [char], {isCharacter: true, codepoint: chunk[index], code: chunk[index]});
      }
      index += bytes;
    }
    if (accumulate) {
      this.prependStdinChunk = chunk;
    } else {
      this.prependStdinChunk = null;
    }
  }
  notChainable.grabInput = function(options, safe) {
    this.mouseButton(false);
    this.mouseDrag(false);
    this.mouseMotion(false);
    this.focusEvent(false);
    this.stdin.removeListener("data", this.onStdin);
    this.grabbing = false;
    this.mouseGrabbing = false;
    this.focusGrabbing = false;
    var disable = () => {
      this.stdin.pause();
      try {
        this.stdin.setRawMode(false);
      } catch (error) {
      }
    };
    if (options === false) {
      if (safe) {
        return Promise$1.resolveSafeTimeout(this.timeout / 2).then(disable);
      }
      disable();
      return Promise$1.resolved;
    }
    if (this.shutdown) {
      return Promise$1.resolved;
    }
    this.grabbing = true;
    if (!options) {
      options = {};
    }
    try {
      this.stdin.setRawMode(true);
    } catch (error) {
    }
    this.stdin.on("data", this.onStdin);
    this.stdin.resume();
    if (options.mouse) {
      this.mouseGrabbing = true;
      switch (options.mouse) {
        case "button":
          this.mouseButton.mouseSGR();
          break;
        case "drag":
          this.mouseDrag.mouseSGR();
          break;
        case "motion":
          this.mouseMotion.mouseSGR();
          break;
      }
    }
    if (options.focus) {
      this.focusEvent();
      this.focusGrabbing = true;
    }
    return Promise$1.resolved;
  };
  notChainable.processExit = function(code) {
    this("\n");
    this.asyncCleanup().then(() => process.exit(code));
  };
  notChainable.asyncCleanup = function() {
    return __async(this, null, function* () {
      if (this.shutdown) {
        return;
      }
      this.shutdown = true;
      this.styleReset();
      var wasGrabbing = this.grabbing;
      yield this.waitStreamDone(this.stdout);
      if (!this.isTTY || !wasGrabbing) {
        return;
      }
      yield Promise$1.resolveSafeTimeout(this.timeout / 4);
      return this.grabInput(false, true);
    });
  };
  notChainable.waitStreamDone = function(stream) {
    if (!stream._writableState.needDrain) {
      return Promise$1.resolved;
    }
    return Promise$1.onceEvent(stream, "drain");
  };
  notChainable.object2attr = function(object) {
    var attr = this.esc.styleReset.on;
    if (!object || typeof object !== "object") {
      object = {};
    }
    if (typeof object.color === "string") {
      object.color = termkit$1.colorNameToIndex(object.color);
    }
    if (typeof object.color !== "number" || object.color < 0 || object.color > 255) {
      object.color = 7;
    } else {
      object.color = Math.floor(object.color);
    }
    attr += this.str.color(object.color);
    if (typeof object.bgColor === "string") {
      object.bgColor = termkit$1.colorNameToIndex(object.bgColor);
    }
    if (typeof object.bgColor !== "number" || object.bgColor < 0 || object.bgColor > 255) {
      object.bgColor = 0;
    } else {
      object.bgColor = Math.floor(object.bgColor);
    }
    attr += this.str.bgColor(object.bgColor);
    if (object.bold) {
      attr += this.esc.bold.on;
    }
    if (object.dim) {
      attr += this.esc.dim.on;
    }
    if (object.italic) {
      attr += this.esc.italic.on;
    }
    if (object.underline) {
      attr += this.esc.underline.on;
    }
    if (object.blink) {
      attr += this.esc.blink.on;
    }
    if (object.inverse) {
      attr += this.esc.inverse.on;
    }
    if (object.hidden) {
      attr += this.esc.hidden.on;
    }
    if (object.strike) {
      attr += this.esc.strike.on;
    }
    return attr;
  };
  notChainable.eraseArea = function(xMin, yMin, width = 1, height = 1) {
    xMin = Math.min(xMin, this.width);
    yMin = Math.min(yMin, this.height);
    var y, xMax = Math.min(xMin + width, this.width + 1), yMax = Math.min(yMin + height, this.height + 1), str = " ".repeat(xMax - xMin);
    for (y = yMin; y < yMax; y++) {
      this.moveTo(xMin, y, str);
    }
  };
  notChainable.getCursorLocation = function(callback) {
    var wasGrabbing = this.grabbing, alreadyCleanedUp = false, error;
    if (this.shutdown) {
      return Promise$1.resolved;
    }
    if (this.esc.requestCursorLocation.na) {
      error = new Error("Terminal is not capable");
      if (callback) {
        callback(error);
        return Promise$1.resolved;
      }
      return Promise$1.reject(error);
    }
    var promise = new Promise$1();
    if (this.lock.getCursorLocation) {
      this.once("unlock_getCursorLocation", () => {
        this.getCursorLocation().then((data) => {
          if (callback) {
            callback(void 0, data.x, data.y);
          } else {
            promise.resolve(data);
          }
        }, (error_) => {
          if (callback) {
            callback(error_);
          } else {
            promise.reject(error_);
          }
        });
      });
      return promise;
    }
    this.lock.getCursorLocation = true;
    var cleanup = (error_, x, y) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      this.removeListener("terminal", onTerminal);
      if (!wasGrabbing) {
        this.grabInput(false);
      }
      if (error_) {
        if (this.shutdown) {
          error_.code = "shutdown";
        }
        if (callback) {
          callback(error_);
        } else {
          promise.reject(error_);
        }
        return;
      }
      if (callback) {
        callback(void 0, x, y);
      } else {
        promise.resolve({x, y});
      }
    };
    var onTerminal = (name2, data) => {
      if (name2 !== "CURSOR_LOCATION") {
        return;
      }
      this.lock.getCursorLocation = false;
      this.emit("unlock_getCursorLocation");
      cleanup(void 0, data.x, data.y);
    };
    if (!wasGrabbing) {
      this.grabInput();
    }
    this.on("terminal", onTerminal);
    this.requestCursorLocation();
    Promise$1.resolveSafeTimeout(this.timeout).then(() => {
      if (alreadyCleanedUp) {
        return;
      }
      var error_ = new Error(".getCursorLocation() timed out");
      error_.code = "timeout";
      cleanup(error_);
    });
    return promise;
  };
  notChainable.getColor = function(register, callback) {
    var wasGrabbing = this.grabbing, alreadyCleanedUp = false, error;
    if (this.shutdown) {
      return Promise$1.resolved;
    }
    if (this.esc.requestColor.na) {
      error = new Error("Terminal is not capable");
      if (callback) {
        callback(error);
        return Promise$1.resolved;
      }
      return Promise$1.reject(error);
    }
    var promise = new Promise$1();
    var cleanup = (error_, data) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      this.removeListener("terminal", onTerminal);
      if (!wasGrabbing) {
        this.grabInput(false);
      }
      if (error_) {
        if (this.shutdown) {
          error_.code = "shutdown";
        }
        if (callback) {
          callback(error_);
        } else {
          promise.reject(error_);
        }
        return;
      }
      if (callback) {
        callback(void 0, data);
      } else {
        promise.resolve(data);
      }
    };
    var onTerminal = (name2, data) => {
      if (name2 !== "COLOR_REGISTER") {
        return;
      }
      if (data.register !== register) {
        return;
      }
      if (register < 16) {
        this.colorRegister[register] = {r: data.r, g: data.g, b: data.b};
      }
      cleanup(void 0, data);
    };
    if (!wasGrabbing) {
      this.grabInput();
    }
    this.requestColor(register);
    this.on("terminal", onTerminal);
    Promise$1.resolveSafeTimeout(this.timeout).then(() => {
      if (alreadyCleanedUp) {
        return;
      }
      var error_ = new Error(".getColor() timed out");
      error_.code = "timeout";
      cleanup(error_);
    });
    return promise;
  };
  notChainable.getPalette = function(callback) {
    var defaultPalette, wasGrabbing = this.grabbing;
    if (this.shutdown) {
      return Promise$1.resolved;
    }
    if (!wasGrabbing) {
      this.grabInput();
    }
    if (this.esc.requestColor.na) {
      defaultPalette = this.colorRegister.slice(0, 16);
      if (callback) {
        callback(void 0, defaultPalette);
        return Promise$1.resolved;
      }
      return Promise$1.resolve(defaultPalette);
    }
    return Promise$1.concurrent(4, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], (register) => this.getColor(register)).then((palette) => {
      if (!wasGrabbing) {
        this.grabInput(false);
      }
      if (callback) {
        callback(void 0, palette);
      } else {
        return palette;
      }
    }, (error) => {
      if (!wasGrabbing) {
        this.grabInput(false);
      }
      if (callback) {
        callback(error);
      } else {
        throw error;
      }
    });
  };
  notChainable.setColor = function(register, r, g, b, names) {
    if (r && typeof r === "object") {
      b = r.b;
      g = r.g;
      r = r.r;
      names = g;
    }
    if (typeof register !== "number" || register < 0 || register > 15) {
      throw new Error("Bad register value");
    }
    if (!Array.isArray(names)) {
      names = [];
    }
    if (typeof r !== "number" || r < 0 || r > 255 || typeof g !== "number" || g < 0 || g > 255 || typeof b !== "number" || b < 0 || b > 255) {
      throw new Error("Bad RGB value");
    }
    if (this.setColorLL.na) {
      return;
    }
    this.colorRegister[register] = {
      r,
      g,
      b,
      names
    };
    this.setColorLL(register, r, g, b);
  };
  notChainable.setPalette = function(palette) {
    var i;
    if (typeof palette === "string") {
      try {
        palette = require("./colorScheme/" + palette + ".json");
      } catch (error) {
        throw new Error("[terminal] .setPalette(): color scheme not found: " + palette);
      }
    }
    if (!Array.isArray(palette)) {
      throw new Error("[terminal] .setPalette(): argument #0 should be an Array of RGB Object or a built-in color scheme");
    }
    if (this.setColorLL.na) {
      return;
    }
    for (i = 0; i <= 15; i++) {
      if (!palette[i] || typeof palette[i] !== "object") {
        continue;
      }
      this.setColor(i, palette[i]);
    }
  };
  notChainable.getClipboard = function(source = "c") {
    var wasGrabbing = this.grabbing, alreadyCleanedUp = false, extClipboard$1;
    if (this.shutdown) {
      return Promise$1.resolved;
    }
    if (this.esc.requestClipboard.na) {
      extClipboard$1 = extClipboard;
      return extClipboard$1.getClipboard(source).catch(() => "");
    }
    var promise = new Promise$1();
    var cleanup = (error_, data) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      this.removeListener("terminal", onTerminal);
      if (!wasGrabbing) {
        this.grabInput(false);
      }
      if (error_) {
        if (this.shutdown) {
          error_.code = "shutdown";
        }
        promise.reject(error_);
        return;
      }
      promise.resolve(data);
    };
    var onTerminal = (name2, data) => {
      if (name2 !== "CLIPBOARD") {
        return;
      }
      cleanup(void 0, data.content);
    };
    if (!wasGrabbing) {
      this.grabInput();
    }
    this.requestClipboard(source[0]);
    this.on("terminal", onTerminal);
    Promise$1.resolveSafeTimeout(this.timeout).then(() => {
      if (alreadyCleanedUp) {
        return;
      }
      var error_ = new Error(".getClipboard() timed out");
      error_.code = "timeout";
      cleanup(error_);
    });
    return promise;
  };
  notChainable.setClipboard = function(str, source = "c") {
    return __async(this, null, function* () {
      var extClipboard$1;
      if (this.esc.setClipboardLL.na) {
        extClipboard$1 = extClipboard;
        return extClipboard$1.setClipboard(str, source).catch(() => void 0);
      }
      var base64 = Buffer.from(str).toString("base64");
      this.setClipboardLL(source[0], base64);
      return Promise$1.resolved;
    });
  };
  notChainable.getTerminfo = function(key) {
    var wasGrabbing = this.grabbing, alreadyCleanedUp = false;
    if (this.shutdown) {
      return Promise$1.resolved;
    }
    if (this.esc.xtgettcapLL.na) {
      return Promise$1.reject(new Error("Terminal is not capable"));
    }
    var promise = new Promise$1();
    if (this.lock.getTerminfo) {
      this.once("unlock_getTerminfo", () => this.getTerminfo(key).propagate(promise));
      return promise;
    }
    this.lock.getTerminfo = true;
    var cleanup = (error, data) => {
      if (alreadyCleanedUp) {
        return;
      }
      alreadyCleanedUp = true;
      this.removeListener("terminal", onTerminal);
      if (!wasGrabbing) {
        this.grabInput(false);
      }
      if (error) {
        if (this.shutdown) {
          error.code = "shutdown";
        }
        promise.reject(error);
        return;
      }
      if (!data.valid || data.key !== key) {
        promise.resolve();
        return;
      }
      promise.resolve(data.value);
    };
    var onTerminal = (name2, data) => {
      if (name2 !== "TERMINFO") {
        return;
      }
      this.lock.getTerminfo = false;
      this.emit("unlock_getTerminfo");
      cleanup(void 0, data);
    };
    if (!wasGrabbing) {
      this.grabInput();
    }
    this.on("terminal", onTerminal);
    this.xtgettcapLL(Buffer.from(key).toString("hex"));
    Promise$1.resolveSafeTimeout(this.timeout).then(() => {
      if (alreadyCleanedUp) {
        return;
      }
      var error = new Error(".getTerminfo() timed out");
      error.code = "timeout";
      cleanup(error);
    });
    return promise;
  };
  var defaultColorRegister = require$$15;
  (function buildDefaultColorRegister() {
    var register, offset, factor, l;
    for (register = 16; register < 232; register++) {
      offset = register - 16;
      factor = 255 / 5;
      defaultColorRegister[register] = {
        r: Math.round(Math.floor(offset / 36) % 6 * factor),
        g: Math.round(Math.floor(offset / 6) % 6 * factor),
        b: Math.round(offset % 6 * factor),
        names: []
      };
    }
    for (register = 232; register <= 255; register++) {
      offset = register - 231;
      factor = 255 / 25;
      l = Math.round(offset * factor);
      defaultColorRegister[register] = {
        r: l,
        g: l,
        b: l,
        names: []
      };
    }
  })();
  notChainable.rgbForRegister = function(register) {
    if (register < 0 || register > 255) {
      throw new Error("Bad register value");
    }
    return {
      r: this.colorRegister[register].r,
      g: this.colorRegister[register].g,
      b: this.colorRegister[register].b
    };
  };
  notChainable.registerForRgb = function(r, g, b, minRegister, maxRegister) {
    if (r && typeof r === "object") {
      maxRegister = b;
      minRegister = g;
      b = r.b;
      g = r.g;
      r = r.r;
    }
    if (typeof r !== "number" || r < 0 || r > 255 || typeof g !== "number" || g < 0 || g > 255 || typeof b !== "number" || b < 0 || b > 255) {
      throw new Error("Bad RGB value");
    }
    if (typeof maxRegister !== "number" || maxRegister < 0 || maxRegister > 255) {
      maxRegister = 15;
    }
    if (typeof minRegister !== "number" || minRegister < 0 || minRegister > 255) {
      minRegister = 0;
    }
    if (minRegister > maxRegister) {
      var tmp;
      tmp = maxRegister;
      maxRegister = minRegister;
      minRegister = tmp;
    }
    return this._registerForRgb(r, g, b, minRegister, maxRegister);
  };
  notChainable._registerForRgb = function(r, g, b, minRegister, maxRegister) {
    var register, delta, minDelta = Infinity, rgb = [r, g, b];
    for (register = minRegister; register <= maxRegister; register++) {
      delta = termkit$1.chroma.distance(rgb, this.colorRegister[register], "hcl");
      if (delta < minDelta) {
        minDelta = delta;
        minRegister = register;
      }
    }
    return minRegister;
  };
  notChainable.colorNameForRgb = function(r, g, b) {
    return termkit$1.indexToColorName(this.registerForRgb(r, g, b, 0, 15));
  };
  notChainable.colorNameForHex = function(hex) {
    var rgba = termkit$1.hexToRgba(hex);
    return this.colorNameForRgb(rgba.r, rgba.g, rgba.b);
  };
  notChainable.registerForRgbCache = function(cache, r, g, b, minRegister, maxRegister) {
    var key = r + "-" + g + "-" + b;
    if (cache[key]) {
      return cache[key];
    }
    return cache[key] = this._registerForRgb(r, g, b, minRegister, maxRegister);
  };
  notChainable.drawCursor = function() {
  };
  notChainable.put = function(options, str, ...args) {
    var i, x, y, dx, dy, attr, wrap, characters, len, moveToNeeded, inline;
    if (!options) {
      options = {};
    }
    wrap = options.wrap === void 0 ? true : options.wrap;
    x = options.x || 0;
    y = options.y || 0;
    if (typeof x !== "number" || x < 1) {
      x = 1;
    } else if (x > this.width) {
      x = this.width;
    } else {
      x = Math.floor(x);
    }
    if (typeof y !== "number" || y < 1) {
      y = 1;
    } else if (y > this.height) {
      y = this.height;
    } else {
      y = Math.floor(y);
    }
    dx = 1;
    dy = 0;
    switch (options.direction) {
      case "left":
        dx = -1;
        break;
      case "up":
        dx = 0;
        dy = -1;
        break;
      case "down":
        dx = 0;
        dy = 1;
        break;
      case null:
      case "none":
        dx = 0;
        dy = 0;
        break;
    }
    if (typeof options.dx === "number") {
      dx = options.dx;
    }
    if (typeof options.dy === "number") {
      dy = options.dy;
    }
    inline = dx === 1 && dy === 0;
    attr = options.attr || this.esc.styleReset.on;
    if (attr && typeof attr === "object") {
      attr = this.object2attr(attr);
    }
    if (typeof attr !== "string") {
      attr = this.esc.styleReset.on;
    }
    if (typeof str !== "string") {
      if (str.toString) {
        str = str.toString();
      } else {
        return;
      }
    }
    if (args.length) {
      str = string.format(str, ...args);
    }
    str = termkit$1.stripControlChars(str);
    characters = string.unicode.toArray(str);
    len = characters.length;
    moveToNeeded = true;
    this.stdout.write(attr);
    for (i = 0; i < len; i++) {
      if (moveToNeeded) {
        this.moveTo(x, y);
      }
      this(characters[i]);
      x += dx;
      y += dy;
      moveToNeeded = !inline;
      if (x < 0) {
        if (!wrap) {
          break;
        }
        x = this.width - 1;
        y--;
        moveToNeeded = true;
      } else if (x >= this.width) {
        if (!wrap) {
          break;
        }
        x = 0;
        y++;
        moveToNeeded = true;
      }
      if (y < 0) {
        break;
      } else if (y >= this.height) {
        break;
      }
    }
  };
  notChainable.drawNdarrayImage = function(pixels) {
    var x, xMax = Math.min(pixels.shape[0], this.width), y, yMax = Math.ceil(pixels.shape[1] / 2), hasAlpha = pixels.shape[2] === 4, maxRegister = this.support["256colors"] ? 255 : 15, fgColor, bgColor, fgAlpha, bgAlpha, cache = {};
    for (y = 0; y < yMax; y++) {
      for (x = 0; x < xMax; x++) {
        if (this.support.trueColor) {
          fgAlpha = hasAlpha ? pixels.get(x, y * 2, 3) / 255 : 1;
          if (y * 2 + 1 < pixels.shape[1]) {
            bgAlpha = hasAlpha ? pixels.get(x, y * 2 + 1, 3) / 255 : 1;
            this.noFormat(this.optimized.color24bits(Math.round(fgAlpha * pixels.get(x, y * 2, 0)), Math.round(fgAlpha * pixels.get(x, y * 2, 1)), Math.round(fgAlpha * pixels.get(x, y * 2, 2))) + this.optimized.bgColor24bits(Math.round(bgAlpha * pixels.get(x, y * 2 + 1, 0)), Math.round(bgAlpha * pixels.get(x, y * 2 + 1, 1)), Math.round(bgAlpha * pixels.get(x, y * 2 + 1, 2))) + "\u2580");
          } else {
            this.noFormat(this.optimized.color24bits(Math.round(fgAlpha * pixels.get(x, y * 2, 0)), Math.round(fgAlpha * pixels.get(x, y * 2, 1)), Math.round(fgAlpha * pixels.get(x, y * 2, 2))) + this.optimized.bgColor24bits(0, 0, 0) + "\u2580");
          }
        } else {
          fgColor = hasAlpha && pixels.get(x, y * 2, 3) < 127 ? 0 : this.registerForRgbCache(cache, pixels.get(x, y * 2, 0), pixels.get(x, y * 2, 1), pixels.get(x, y * 2, 2), 0, maxRegister);
          if (y * 2 + 1 < pixels.shape[1]) {
            bgColor = hasAlpha && pixels.get(x, y * 2 + 1, 3) < 127 ? 0 : this.registerForRgbCache(cache, pixels.get(x, y * 2 + 1, 0), pixels.get(x, y * 2 + 1, 1), pixels.get(x, y * 2 + 1, 2), 0, maxRegister);
            this.noFormat(this.optimized.color256[fgColor] + this.optimized.bgColor256[bgColor] + "\u2580");
          } else {
            this.noFormat(this.optimized.color256[fgColor] + this.optimized.bgColor256[0] + "\u2580");
          }
        }
      }
      this.styleReset()("\n");
    }
  };
  notChainable.drawImage = function(filepath, options, callback) {
    return termkit$1.image.load.call(this, notChainable.drawNdarrayImage.bind(this), filepath, options, callback);
  };
  var windows = function(termkit) {
    termkit.globalConfig.preferProcessSigwinch = true;
  };
  const termkit = {};
  var termkit_1 = termkit;
  const lazy = Lazyness_1(require);
  termkit.globalConfig = {};
  lazy.requireProperty(termkit, "tty", "./tty.js");
  Object.assign(termkit, misc_1);
  Object.assign(termkit, detectTerminal);
  termkit.Terminal = Terminal_1;
  termkit.createTerminal = termkit.Terminal.create;
  if (process.platform === "win32") {
    windows(termkit);
  }
  lazy.requireProperties(termkit, {
    image: "./image.js",
    Palette: "./Palette.js",
    Rect: "./Rect.js",
    ScreenBuffer: "./ScreenBuffer.js",
    ScreenBufferHD: "./ScreenBufferHD.js",
    TextBuffer: "./TextBuffer.js",
    Vte: "./vte/Vte.js",
    autoComplete: "./autoComplete.js",
    spChars: "./spChars.js",
    Element: "./document/Element.js",
    Document: "./document/Document.js",
    Container: "./document/Container.js",
    Text: "./document/Text.js",
    AnimatedText: "./document/AnimatedText.js",
    Button: "./document/Button.js",
    ToggleButton: "./document/ToggleButton.js",
    TextBox: "./document/TextBox.js",
    EditableTextBox: "./document/EditableTextBox.js",
    Slider: "./document/Slider.js",
    Bar: "./document/Bar.js",
    LabeledInput: "./document/LabeledInput.js",
    InlineInput: "./document/InlineInput.js",
    Form: "./document/Form.js",
    RowMenu: "./document/RowMenu.js",
    ColumnMenu: "./document/ColumnMenu.js",
    ColumnMenuMulti: "./document/ColumnMenuMulti.js",
    SelectList: "./document/SelectList.js",
    SelectListMulti: "./document/SelectListMulti.js",
    DropDownMenu: "./document/DropDownMenu.js",
    TextTable: "./document/TextTable.js",
    Layout: "./document/Layout.js",
    Window: "./document/Window.js",
    chroma: "chroma-js"
  });
  lazy.properties(termkit, {
    terminal: () => {
      var guessed = termkit.guessTerminal();
      return termkit.createTerminal({
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr,
        generic: guessed.generic || "unknown",
        appId: guessed.safe ? guessed.appId : void 0,
        isTTY: guessed.isTTY,
        isSSH: guessed.isSSH,
        processSigwinch: true,
        preferProcessSigwinch: !!termkit.globalConfig.preferProcessSigwinch
      });
    },
    realTerminal: () => {
      var guessed = termkit.guessTerminal(true);
      var input = termkit.tty.getInput();
      var output = termkit.tty.getOutput();
      return termkit.createTerminal({
        stdin: input,
        stdout: output,
        stderr: process.stderr,
        generic: guessed.generic || "unknown",
        appId: guessed.safe ? guessed.appId : void 0,
        isTTY: true,
        isSSH: guessed.isSSH,
        processSigwinch: true,
        preferProcessSigwinch: !!termkit.globalConfig.preferProcessSigwinch
      });
    }
  }, true);
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const __onProcessExitCallbacks = [];
  function onProcessExit(callback) {
    if (!__onProcessExitCallbacks.length) {
      let exitHandler = function(state) {
        return __awaiter(this, void 0, void 0, function* () {
          if (isExiting)
            return;
          isExiting = true;
          for (let i = 0; i < __onProcessExitCallbacks.length; i++) {
            const cbFn = __onProcessExitCallbacks[i];
            yield cbFn(state);
          }
          setTimeout(() => {
            termkit_1.terminal.processExit("SIGTERM");
          }, 100);
        });
      };
      let isExiting = false;
      process.on("close", (code) => code === 0 ? exitHandler("success") : exitHandler("error"));
      process.on("exit", (code) => code === 0 ? exitHandler("success") : exitHandler("error"));
      process.on("custom_exit", (state) => {
        exitHandler(state);
      });
      process.on("SIGINT", () => exitHandler("killed"));
      process.on("SIGUSR1", () => exitHandler("killed"));
      process.on("SIGUSR2", () => exitHandler("killed"));
      process.on("uncaughtException", () => exitHandler("error"));
    }
    if (__onProcessExitCallbacks.indexOf(callback) !== -1)
      return;
    __onProcessExitCallbacks.push(callback);
  }
  var onProcessExit$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": onProcessExit});
})();
